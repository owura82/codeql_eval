pointer_traits<__tree_node<__value_type<long, Position>, void *> *>pointer_traits<__tree_node<__value_type<long, Position>, void *> *> &const pointer_traits<__tree_node<__value_type<long, Position>, void *> *>const pointer_traits<__tree_node<__value_type<long, Position>, void *> *> &__rebind_pointer<void *, __value_type<long, Position>>__rebind_pointer<void *, __value_type<long, Position>> &const __rebind_pointer<void *, __value_type<long, Position>>const __rebind_pointer<void *, __value_type<long, Position>> &__rebind_pointer<void *, const __value_type<long, Position>>__rebind_pointer<void *, const __value_type<long, Position>> &const __rebind_pointer<void *, const __value_type<long, Position>>const __rebind_pointer<void *, const __value_type<long, Position>> &conditional<true, __tree_end_node<__tree_node_base<void *> *> *, __tree_node<__value_type<long, Position>, void *> *>conditional<true, __tree_end_node<__tree_node_base<void *> *> *, __tree_node<__value_type<long, Position>, void *> *> &const conditional<true, __tree_end_node<__tree_node_base<void *> *> *, __tree_node<__value_type<long, Position>, void *> *>const conditional<true, __tree_end_node<__tree_node_base<void *> *> *, __tree_node<__value_type<long, Position>, void *> *> &__tree_map_pointer_types<__value_type<long, Position>, void *, __tree_key_value_types<__value_type<long, Position>>, true>__tree_map_pointer_types<__value_type<long, Position>, void *, __tree_key_value_types<__value_type<long, Position>>, true> &const __tree_map_pointer_types<__value_type<long, Position>, void *, __tree_key_value_types<__value_type<long, Position>>, true>const __tree_map_pointer_types<__value_type<long, Position>, void *, __tree_key_value_types<__value_type<long, Position>>, true> &__size_type<allocator<__value_type<long, Position>>, long, true>__size_type<allocator<__value_type<long, Position>>, long, true> &const __size_type<allocator<__value_type<long, Position>>, long, true>const __size_type<allocator<__value_type<long, Position>>, long, true> &__const_void_pointer<__value_type<long, Position> *, allocator<__value_type<long, Position>>, false>__const_void_pointer<__value_type<long, Position> *, allocator<__value_type<long, Position>>, false> &const __const_void_pointer<__value_type<long, Position> *, allocator<__value_type<long, Position>>, false>const __const_void_pointer<__value_type<long, Position> *, allocator<__value_type<long, Position>>, false> &__pointer<__value_type<long, Position>, allocator<__value_type<long, Position>>, allocator<__value_type<long, Position>>, true>__pointer<__value_type<long, Position>, allocator<__value_type<long, Position>>, allocator<__value_type<long, Position>>, true> &const __pointer<__value_type<long, Position>, allocator<__value_type<long, Position>>, allocator<__value_type<long, Position>>, true>const __pointer<__value_type<long, Position>, allocator<__value_type<long, Position>>, allocator<__value_type<long, Position>>, true> &__const_pointer<__value_type<long, Position>, __value_type<long, Position> *, allocator<__value_type<long, Position>>, true>__const_pointer<__value_type<long, Position>, __value_type<long, Position> *, allocator<__value_type<long, Position>>, true> &const __const_pointer<__value_type<long, Position>, __value_type<long, Position> *, allocator<__value_type<long, Position>>, true>const __const_pointer<__value_type<long, Position>, __value_type<long, Position> *, allocator<__value_type<long, Position>>, true> &__void_pointer<__value_type<long, Position> *, allocator<__value_type<long, Position>>, false>__void_pointer<__value_type<long, Position> *, allocator<__value_type<long, Position>>, false> &const __void_pointer<__value_type<long, Position> *, allocator<__value_type<long, Position>>, false>const __void_pointer<__value_type<long, Position> *, allocator<__value_type<long, Position>>, false> &__alloc_traits_difference_type<allocator<__value_type<long, Position>>, __value_type<long, Position> *, true>__alloc_traits_difference_type<allocator<__value_type<long, Position>>, __value_type<long, Position> *, true> &const __alloc_traits_difference_type<allocator<__value_type<long, Position>>, __value_type<long, Position> *, true>const __alloc_traits_difference_type<allocator<__value_type<long, Position>>, __value_type<long, Position> *, true> &__propagate_on_container_move_assignment<allocator<__value_type<long, Position>>, true>__propagate_on_container_move_assignment<allocator<__value_type<long, Position>>, true> &const __propagate_on_container_move_assignment<allocator<__value_type<long, Position>>, true>const __propagate_on_container_move_assignment<allocator<__value_type<long, Position>>, true> &__is_always_equal<allocator<__value_type<long, Position>>, true>__is_always_equal<allocator<__value_type<long, Position>>, true> &const __is_always_equal<allocator<__value_type<long, Position>>, true>const __is_always_equal<allocator<__value_type<long, Position>>, true> &rebind_alloc<__tree_node<__value_type<long, Position>, void *>>rebind_alloc<__tree_node<__value_type<long, Position>, void *>> &const rebind_alloc<__tree_node<__value_type<long, Position>, void *>>const rebind_alloc<__tree_node<__value_type<long, Position>, void *>> &__rebind_pointer<void *, __tree_node<__value_type<long, Position>, void *>>__rebind_pointer<void *, __tree_node<__value_type<long, Position>, void *>> &const __rebind_pointer<void *, __tree_node<__value_type<long, Position>, void *>>const __rebind_pointer<void *, __tree_node<__value_type<long, Position>, void *>> &__compressed_pair_elem<__map_value_compare<long, __value_type<long, Position>, less<long>, true>, 1, true>__compressed_pair_elem<__map_value_compare<long, __value_type<long, Position>, less<long>, true>, 1, true> &const __compressed_pair_elem<__map_value_compare<long, __value_type<long, Position>, less<long>, true>, 1, true>const __compressed_pair_elem<__map_value_compare<long, __value_type<long, Position>, less<long>, true>, 1, true> &__compressed_pair_elem<allocator<__tree_node<__value_type<long, Position>, void *>>, 1, true>__compressed_pair_elem<allocator<__tree_node<__value_type<long, Position>, void *>>, 1, true> &const __compressed_pair_elem<allocator<__tree_node<__value_type<long, Position>, void *>>, 1, true>const __compressed_pair_elem<allocator<__tree_node<__value_type<long, Position>, void *>>, 1, true> &__has_pointer<__map_node_destructor<allocator<__tree_node<__value_type<long, Position>, void *>>>, void>__has_pointer<__map_node_destructor<allocator<__tree_node<__value_type<long, Position>, void *>>>, void> &const __has_pointer<__map_node_destructor<allocator<__tree_node<__value_type<long, Position>, void *>>>, void>const __has_pointer<__map_node_destructor<allocator<__tree_node<__value_type<long, Position>, void *>>>, void> &__compressed_pair_elem<__map_node_destructor<allocator<__tree_node<__value_type<long, Position>, void *>>>, 1, false>__compressed_pair_elem<__map_node_destructor<allocator<__tree_node<__value_type<long, Position>, void *>>>, 1, false> &const __compressed_pair_elem<__map_node_destructor<allocator<__tree_node<__value_type<long, Position>, void *>>>, 1, false>const __compressed_pair_elem<__map_node_destructor<allocator<__tree_node<__value_type<long, Position>, void *>>>, 1, false> &__pop_heapconst __compressed_pair<unsigned long, __map_value_compare<long, __value_type<long, Position>, less<long>, true>> *__compressed_pair<unsigned long, __map_value_compare<long, __value_type<long, Position>, less<long>, true>> *const less<long> *less<long> *__map_node_destructor<allocator<__tree_node<__value_type<long, Position>, void *>>> *__compressed_pair_elem<__tree_node<__value_type<long, Position>, void *> *, 0, false> *const __compressed_pair_elem<__tree_node<__value_type<long, Position>, void *> *, 0, false> *__compressed_pair<__tree_end_node<__tree_node_base<void *> *>, allocator<__tree_node<__value_type<long, Position>, void *>>> *__tree_node<__value_type<long, Position>, void *> *&&remove_reference<__tree_node<__value_type<long, Position>, void *> *>remove_reference<__tree_node<__value_type<long, Position>, void *> *> &const remove_reference<__tree_node<__value_type<long, Position>, void *> *>const remove_reference<__tree_node<__value_type<long, Position>, void *> *> &__rebind_pointer<void *, pair<const long, Position>>__rebind_pointer<void *, pair<const long, Position>> &const __rebind_pointer<void *, pair<const long, Position>>const __rebind_pointer<void *, pair<const long, Position>> &__rebind_pointer<void *, const pair<const long, Position>>__rebind_pointer<void *, const pair<const long, Position>> &const __rebind_pointer<void *, const pair<const long, Position>>const __rebind_pointer<void *, const pair<const long, Position>> &is_pointer<__tree_node<__value_type<long, Position>, void *> *>is_pointer<__tree_node<__value_type<long, Position>, void *> *> &const is_pointer<__tree_node<__value_type<long, Position>, void *> *>const is_pointer<__tree_node<__value_type<long, Position>, void *> *> &pointer_traits<pair<const long, Position> *>pointer_traits<pair<const long, Position> *> &const pointer_traits<pair<const long, Position> *>const pointer_traits<pair<const long, Position> *> &rebind<const __value_type<long, Position>>rebind<const __value_type<long, Position>> &const rebind<const __value_type<long, Position>>const rebind<const __value_type<long, Position>> &rebind<const pair<const long, Position>>rebind<const pair<const long, Position>> &const rebind<const pair<const long, Position>>const rebind<const pair<const long, Position>> &rebind<pair<const long, Position>>rebind<pair<const long, Position>> &const rebind<pair<const long, Position>>const rebind<pair<const long, Position>> &__is_referenceable<..(*)(..)>__is_referenceable<..(*)(..)> &const __is_referenceable<..(*)(..)>const __is_referenceable<..(*)(..)> &__compressed_pair_elem<__map_value_compare<long, __value_type<long, Position>, less<long>, true>, 1, true> *const __compressed_pair<__tree_end_node<__tree_node_base<void *> *>, allocator<__tree_node<__value_type<long, Position>, void *>>> *__compressed_pair_elem<__map_node_destructor<allocator<__tree_node<__value_type<long, Position>, void *>>>, 1, false> *__compressed_pair_elem<allocator<__tree_node<__value_type<long, Position>, void *>>, 1, true> *const __compressed_pair_elem<__map_value_compare<long, __value_type<long, Position>, less<long>, true>, 1, true> *pointer_traits<__value_type<long, Position> *>pointer_traits<__value_type<long, Position> *> &const pointer_traits<__value_type<long, Position> *>const pointer_traits<__value_type<long, Position> *> &allocator<__tree_node<__value_type<long, Position>, void *>> *widen/Users/owura/Repos/codeql_eval/proj_repos/Exiv2-exiv2-pull-962-commits-e925bc5addd881543fa503470c8a859e112cca62/exiv2/src/getopt.hpp/Users/owura/Repos/codeql_eval/proj_repos/Exiv2-exiv2-pull-962-commits-e925bc5addd881543fa503470c8a859e112cca62/exiv2/samples/getopt-test.cpp"getopt.hpp"char **conststandard getopt()"standard getopt()"::optarg = " = " optind = " optind = " opterr = " opterr = " optopt = " optopt = " optarg = " optarg = "homemade getopt()"homemade getopt()"Util::optargparamsParamsParams *~ParamsParams &const Paramsconst Params &nonoptionParams::nonoption()"Params::nonoption()"Params::option()"Params::option()" opt = " opt = "rcGetopt *Params::getopt()"Params::getopt()" rc = " rc = ":hVvqfbuktTFa:Y:O:D:r:p:P:d:e:i:c:m:M:l:S:g:K:n:Q:":hVvqfbuktTFa:Y:O:D:r:p:P:d:e:i:c:m:M:l:S:g:K:n:Q:"optstringSafe(x)(x?x:"unknown")EXV_HAVE_UNISTD_H// Handle command line arguments// class Params//! Handle non-option parameters.//! Handle options and their arguments./*!
      @brief Call Getopt::getopt() with optstring, to inititate command line
             argument parsing, perform consistency checks after all command line
             arguments are parsed.

      @param argc Argument count as passed to main() on program invocation.
      @param argv Argument array as passed to main() on program invocation.

      @return 0 if successful, >0 in case of errors.
     */// getopt.{cpp|hpp} is not part of libexiv2// Params::getopt() rc = 0// Params::nonoption() file2// Params::nonoption() file1// Params::nonoption() EIXxgklnycsvth// Params::nonoption() -P// Params::nonoption() pr// Params::option() opt = 118 optarg =  optopt = 118// -1 optind = 2 opterr = 1 optopt = 118 optarg = unknown// 118 = v optind = 2 opterr = 1 optopt = 118 optarg = unknown// homemade getopt()// standard getopt()// Output:// $ getopt-test -v pr -P EIXxgklnycsvth file1 file2// Command:// Sample program to test getopt()// getopt-test.cpp__allocator_traits_rebind_t__is_cpp17_copy_insertable<_Alloc, _EnableIf<<expression>, void>>__is_cpp17_copy_insertable<_Alloc, <unnamed>>__is_cpp17_move_insertable<_Alloc, _EnableIf<<expression>, void>>__is_cpp17_move_insertable<_Alloc, <unnamed>>__is_default_allocator<allocator<_Tp>>__is_default_allocator<_Tp>__rebind_alloc_helper<_Traits, _Tp>allocator_traits<_Alloc>__has_select_on_container_copy_construction<_Alloc, void>__has_select_on_container_copy_construction<_Alloc, <unnamed>>__has_max_size<_Alloc, void>__has_max_size<_Alloc, <unnamed>>__has_destroy<_Alloc, _Pointer, void>__has_destroy<_Alloc, _Pointer, <unnamed>>__has_construct<_Alloc, _Args...>__has_construct_impl<void, _Alloc, _Args...>__has_construct_impl<<unnamed>, _Alloc, _Args...>__has_allocate_hint<_Alloc, _SizeType, _ConstVoidPtr, void>_SizeType_ConstVoidPtr__has_allocate_hint<_Alloc, _SizeType, _ConstVoidPtr, <unnamed>>__allocator_traits_rebind<_Alloc<_Tp, _Args...>, _Up, false>__allocator_traits_rebind<_Alloc<_Tp, _Args...>, _Up, true>__allocator_traits_rebind<_Tp, _Up, <unnamed>>__has_rebind_other<_Tp, _Up, type>__has_rebind_other<_Tp, _Up, <unnamed>>__is_always_equal<_Alloc, true>__is_always_equal<_Alloc, <unnamed>>__has_is_always_equal<_Tp, type>__has_is_always_equal<_Tp, <unnamed>>__propagate_on_container_swap<_Alloc, true>__propagate_on_container_swap<_Alloc, <unnamed>>__has_propagate_on_container_swap<_Tp, type>__has_propagate_on_container_swap<_Tp, <unnamed>>__propagate_on_container_move_assignment<_Alloc, true>__propagate_on_container_move_assignment<_Alloc, <unnamed>>__has_propagate_on_container_move_assignment<_Tp, type>__has_propagate_on_container_move_assignment<_Tp, <unnamed>>__propagate_on_container_copy_assignment<_Alloc, true>__propagate_on_container_copy_assignment<_Alloc, <unnamed>>__has_propagate_on_container_copy_assignment<_Tp, type>__has_propagate_on_container_copy_assignment<_Tp, <unnamed>>__alloc_traits_difference_type<_Alloc, _Ptr, true>__alloc_traits_difference_type<_Alloc, _Ptr, <unnamed>>__has_alloc_traits_difference_type<_Tp, type>__has_alloc_traits_difference_type<_Tp, <unnamed>>__size_type<_Alloc, _DiffType, true>__size_type<_Alloc, _DiffType, <unnamed>>__has_size_type<_Tp, type>__has_size_type<_Tp, <unnamed>>__const_void_pointer<_Ptr, _Alloc, false>__const_void_pointer<_Ptr, _Alloc, <unnamed>>__has_const_void_pointer<_Tp, type>__has_const_void_pointer<_Tp, <unnamed>>__void_pointer<_Ptr, _Alloc, false>__void_pointer<_Ptr, _Alloc, <unnamed>>__has_void_pointer<_Tp, type>__has_void_pointer<_Tp, <unnamed>>__const_pointer<_Tp, _Ptr, _Alloc, false>__const_pointer<_Tp, _Ptr, _Alloc, <unnamed>>__has_const_pointer<_Tp, type>__has_const_pointer<_Tp, <unnamed>>__pointer<_Tp, _Alloc, _RawAlloc, false>_RawAlloc__pointer<_Tp, _Alloc, _RawAlloc, <unnamed>>__has_pointer<_Tp, type>__has_pointer<_Tp, <unnamed>>(void)declval<_Alloc>().select_on_container_copy_construction()(void)declval<_Alloc&>().max_size()(void)declval<_Alloc>().destroy(declval<_Pointer>())(void)declval<_Alloc>().construct(declval<_Args>()...)(void)declval<_Alloc>().allocate(declval<_SizeType>(), declval<_ConstVoidPtr>())__has_is_always_equal__has_propagate_on_container_swap__has_propagate_on_container_move_assignment__has_propagate_on_container_copy_assignment__has_alloc_traits_difference_type__has_size_type__has_const_void_pointer__has_void_pointer__has_const_pointer_LIBCPP_ALLOCATOR_TRAITS_HAS_XXX_LIBCPP_ALLOCATOR_TRAITS_HAS_XXX(NAME,PROPERTY)template <class _Tp, class = void> struct NAME : false_type { }; template <class _Tp> struct NAME<_Tp, typename __void_t<typename _Tp:: PROPERTY >::type> : true_type { }_LIBCPP___MEMORY_ALLOCATOR_TRAITS_H// _LIBCPP___MEMORY_ALLOCATOR_TRAITS_H// __is_cpp17_copy_insertable// __is_cpp17_move_insertable// __is_default_allocator// __has_select_on_container_copy_construction// __has_max_size// __has_destroy// __has_construct// __has_allocate_hint// __allocator_traits_rebind// __is_always_equal// __propagate_on_container_swap// __propagate_on_container_move_assignment// __propagate_on_container_copy_assignment// __alloc_traits_difference_type// __size_type// __const_void_pointer// __void_pointer// __const_pointerINIReader &const INIReaderconst INIReader &~INIReaderINIReader *INIReaderValueHandlerMakeKeyGetBooleanGetRealGetIntegerParseErrorini_parse_streamini_parse_fileini_parseini_readerini_handler_values_errorINI_MAX_LINEINI_STOP_ON_FIRST_ERRORINI_USE_STACKINI_INLINE_COMMENT_PREFIXES";"INI_ALLOW_INLINE_COMMENTSINI_ALLOW_BOMINI_ALLOW_MULTILINE__INI_H____INIREADER_H__Exiv2// __INIREADER_H__//!< value handler//!< return key encoded from section/name//!< values from file//!< status/*! @brief Get a boolean value from INI file, returning default_value if not found or if
        not a valid true/false value. Valid true values are "true", "yes", "on", "1",
        and valid false values are "false", "no", "off", "0" (not case sensitive).

      @param section name of section
      @param name    name of key
      @param default_value default if not found

      @return value
    *//*! @brief Get a real (floating point double) value from INI file, returning
        default_value if not found or not a valid floating point value
        according to strtod().

      @param section name of section
      @param name    name of key
      @param default_value default if not found

      @return value
    *//*! @brief Get an integer (long) value from INI file, returning default_value if
        not found or not a valid integer (decimal "1234", "-1234", or hex "0x4d2").

      @param section name of section
      @param name    name of key
      @param default_value default if not found

      @return value
    *//*! @brief Get a string value from INI file, returning default_value if not found.

      @param section name of section
      @param name    name of key
      @param default_value default if not found

      @return value
    *//*! @brief Return the result of ini_parse(), i.e., 0 on success, line number of
        first error on parse error, or -1 on file open error.
    *//*! @brief Construct INIReader and parse given filename. See ini.h for more info
       about the parsing.
    *//*! @brief Read an INI file into easy-to-access name/value pairs. (Note that I've gone
  for simplicity here rather than speed, but it should be pretty decent.)
  *//* __INI_H__ *///! @brief Maximum line length for any line in INI file.//! @brief Stop parsing on first error (default is to keep parsing).//! @brief Nonzero to use stack, zero to use heap (malloc/free)./*! @brief Nonzero to allow inline comments (with valid inline comment characters
   specified by INI_INLINE_COMMENT_PREFIXES). Set to 0 to turn off and match
   Python 3.2+ configparser behaviour.
*//*! @brief Nonzero to allow a UTF-8 BOM sequence (0xEF 0xBB 0xBF) at the start of
   the file. See http://code.google.com/p/inih/issues/detail?id=21
*//*! @brief Nonzero to allow multi-line value parsing, in the style of Python's
    configparser. If allowed, ini_parse() will call the handler with the same
    name for each subsequent line parsed.
*//*! @brief Same as ini_parse(), but takes an ini_reader function pointer instead of
   filename. Used for implementing custom or string-based I/O.
   @param reader   magic
   @param stream   more magic
   @param handler  user defined handler
   @param user     void pointer passed to user handler

   @return 0 on success
*//*! @brief Same as ini_parse(), but takes a FILE* instead of filename. This doesn't
   close the file when it's finished -- the caller must do that.

   @param file     open "C" file
   @param handler  user defined handler
   @param user     void pointer passed to user handler
   *//*!
    @brief Parse given INI-style file. May have [section]s, name=value pairs
   (whitespace stripped), and comments starting with ';' (semicolon). Section
   is "" if name=value pair parsed before any section heading. name:value
   pairs are also supported as a concession to Python's configparser.

   For each name=value pair parsed, call handler function with given user
   pointer as well as section, name, and value (data only valid for duration
   of handler call). Handler should return nonzero on success, zero on error.

   @param filename path to file
   @param handler  user defined handler
   @param user     void pointer passed to user handler

   @return 0 on success, line number of first error on parse error (doesn't
   stop on first error), -1 on file open error, or -2 on memory allocation
   error (only when INI_USE_STACK is zero).

   @return 0 on success
*///! Typedef for prototype of fgets-style reader function.//! @brief typedef for prototype of handler function./* Make this header file easier to include in C++ code *//* inih -- simple .INI file parser

inih is released under the New BSD license (see LICENSE.txt). Go to the project
home page for more info:

https://github.com/benhoyt/inih

*/// https://github.com/benhoyt/inih// Go to the project home page for more info:// inih and INIReader are released under the New BSD license (see LICENSE.txt).// Read an INI file into easy-to-access name/value pairs.usersectiondefault_valuestream/Users/owura/Repos/codeql_eval/proj_repos/Exiv2-exiv2-pull-962-commits-e925bc5addd881543fa503470c8a859e112cca62/exiv2/samples/ini-test.cpp"ini.hpp""config.h"iniini-test.ini"ini-test.ini"Can't load '"Can't load '"Config loaded from : '"Config loaded from : '"' "' "version="version="protocol"protocol", name=", name=""user""name"UNKNOWN"UNKNOWN", email=", email="email"email", pi=", pi="pi"pi"-1.0, active=", active="active"active"169="169="canon"canon""169"UNDEFINED"UNDEFINED", 170=", 170=""170"// #include <exiv2/exiv2.h>// Example that shows simple usage of the INIReader class/*
670 rmills@rmillsmbp:~/gnu/exiv2/trunk/samples $ gcc ../src/ini.cpp  ini-test.cpp -lstdc++ -o ini-test
671 rmills@rmillsmbp:~/gnu/exiv2/trunk/samples $ ./ini-test
Config loaded from : 'initest.ini' version=6, name=Bob Smith, email=bob@smith.com, pi=3.14159, active=1
169=Sigma 35mm F1.4 DG HSM ART, 170=UNDEFINED
672 rmills@rmillsmbp:~/gnu/exiv2/trunk/samples $
*/count_(3)/Users/owura/Repos/codeql_eval/proj_repos/Exiv2-exiv2-pull-962-commits-e925bc5addd881543fa503470c8a859e112cca62/exiv2/samples/iotest.cppWriteReadSeekBasicIo &byte[4096]unsigned char[4096]tester1this is a little test of MemIo"this is a little test of MemIo"tester2Appending this on the end"Appending this on the end"expectthis is a little teAppending this on the end"this is a little teAppending this on the end"size1size2Exiv2::kerDataSourceOpenFailedconst BasicIocloser: WRS initial write failed
": WRS initial write failed\n": WRS size is not ": WRS size is not "backupBasicIo::curEOF: WRS missing null terminator 1
": WRS missing null terminator 1\n": WRS strings don't match 1
": WRS strings don't match 1\n"BasicIo::end: WRS bad getb o
": WRS bad getb o\n": WRS bad getb I
": WRS bad getb I\n": WRS bad putb
": WRS bad putb\n": WRS bad getb O
": WRS bad getb O\n"BasicIo::beg: WRS bad write 1
": WRS bad write 1\n": WRS something went wrong
": WRS something went wrong\n": WRS missing null terminator 2
": WRS missing null terminator 2\n": WRS strings don't match 2
": WRS strings don't match 2\n"fileInfileOut1memIo1memIo2fileTestiotest.txt"iotest.txt"fileOut2readCountbyte[32]unsigned char[32] filein fileout1 fileout2
" filein fileout1 fileout2\n"fileouts are overwritten and should match filein exactly
"fileouts are overwritten and should match filein exactly\n"const FileIow+b"w+b"Exiv2::kerFileOpenFailedchar *const &const char(&)[4]char(&)[4]const MemIo: Sizes do not match
": Sizes do not match\n"const char(&)[11]char(&)[11]: MemIo bad write 2
": MemIo bad write 2\n": FileIo bad write 2
": FileIo bad write 2\n"// Make sure we got the null back// open should seek to beginning// Another test of reading and writing// Create or overwrite the file, then close it// Read writereadseek test on FileIo// Read writereadseek test on MemIo// Make sure they are all the same size// Copy to output file through memIo// for EOF/*
  Abstract : Tester application for BasicIo functions. Tests MemIo primarily
        since FileIo just sits atop of FILE* streams.

  File     : iotest.cpp
  Author(s): Brad Schick (brad) <brad@robotbattle.com>
  History  : 04-Dec-04, brad: created
 *//*
 * This program is part of the Exiv2 distribution.
 *
 * This program is free software; you can redistribute it and/or
 * modify it under the terms of the GNU General Public License
 * as published by the Free Software Foundation; either version 2
 * of the License, or (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin Street, 5th Floor, Boston, MA 02110-1301 USA.
 */io/Users/owura/Repos/codeql_eval/proj_repos/Exiv2-exiv2-pull-962-commits-e925bc5addd881543fa503470c8a859e112cca62/exiv2/samples/iptceasy.cppIptcDataIptcData *Iptcdatum &Iptc.Application2.Headline"Iptc.Application2.Headline"The headline I am"The headline I am"Iptc.Application2.Keywords"Iptc.Application2.Keywords"Yet another keyword"Yet another keyword"Iptc.Application2.DateCreated"Iptc.Application2.DateCreated"const char[30]char[30]2004-8-3"2004-8-3"Iptc.Application2.Urgency"Iptc.Application2.Urgency"Iptc.Envelope.ModelVersion"Iptc.Envelope.ModelVersion"Iptc.Envelope.TimeSent"Iptc.Envelope.TimeSent"14:41:0-05:00"14:41:0-05:00"Iptc.Application2.RasterizedCaption"Iptc.Application2.RasterizedCaption"230 42 34 2 90 84 23 146"230 42 34 2 90 84 23 146"Iptc.0x0009.0x0001"Iptc.0x0009.0x0001"Who am I?"Who am I?"very!"very!"Time sent: "Time sent: "const IptcDataconst IptcData &~IptcData// Set IPTC data and write it to the file// Open image file// The quickest way to access, set or modify IPTC metadata.// iptceasy.cpp/Users/owura/Repos/codeql_eval/proj_repos/Exiv2-exiv2-pull-962-commits-e925bc5addd881543fa503470c8a859e112cca62/exiv2/samples/iptcprint.cpp: No IPTC data found in the file": No IPTC data found in the file"md// Sample program to print the IPTC metadata of an image// iptcprint.cpp<__algorithm/min.h><__algorithm/find_end.h><__algorithm/find_first_of.h><__algorithm/fill_n.h><__algorithm/copy_n.h><__algorithm/copy_backward.h><__algorithm/copy.h>__do_string_hash_SizeT__str_find_last_not_of__npos__str_find_first_not_of__pe__str_find_last_ofeq__str_find_first_of__str_rfind__str_find__search_substring__char_traits_length_checked__assign_constexpr__copy_constexpr__quoted_output_proxychar_traits<char32_t> &const char_traits<char32_t>const char_traits<char32_t> &eof42949672950xFFFFFFFFint_type(0xFFFFFFFF)eq_int_typeto_int_typeto_char_typenot_eofchar32_t *char32_t &__s2 < __s1 || __s2 >= __s1+__n"char_traits::copy overlapped range"const char32_tconst char32_t *char_type(0)ltchar_traits<char16_t> &const char_traits<char16_t>const char_traits<char16_t> &0xFFFFint_type(0xFFFF)char16_t *char16_t &const char16_tconst char16_t *char_traits<wchar_t> &const char_traits<wchar_t>const char_traits<wchar_t> &int_type(WEOF)__c1__c2wchar_t &char_traits<char> &const char_traits<char>const char_traits<char> &int_type(EOF)__builtin_strlen__quoted_output_proxy<_CharT, _Iter, _Traits>__escape_LIBCPP_STRING_UNSTABLE_EXTERN_TEMPLATE_LIST(_Func,_CharType)_Func(_LIBCPP_FUNC_VIS basic_string<_CharType>& basic_string<_CharType>::replace(size_type, size_type, value_type const*, size_type)) _Func(_LIBCPP_FUNC_VIS basic_string<_CharType>::size_type basic_string<_CharType>::rfind(value_type const*, size_type, size_type) const) _Func(_LIBCPP_FUNC_VIS void basic_string<_CharType>::__init(value_type const*, size_type, size_type)) _Func(_LIBCPP_FUNC_VIS basic_string<_CharType>& basic_string<_CharType>::replace(size_type, size_type, value_type const*)) _Func(_LIBCPP_FUNC_VIS basic_string<_CharType>::size_type basic_string<_CharType>::find_last_not_of(value_type const*, size_type, size_type) const) _Func(_LIBCPP_FUNC_VIS basic_string<_CharType>::~basic_string()) _Func(_LIBCPP_FUNC_VIS basic_string<_CharType>::size_type basic_string<_CharType>::find_first_not_of(value_type const*, size_type, size_type) const) _Func(_LIBCPP_FUNC_VIS basic_string<_CharType>& basic_string<_CharType>::insert(size_type, size_type, value_type)) _Func(_LIBCPP_FUNC_VIS basic_string<_CharType>& basic_string<_CharType>::operator=(value_type)) _Func(_LIBCPP_FUNC_VIS void basic_string<_CharType>::__init(value_type const*, size_type)) _Func(_LIBCPP_FUNC_VIS void basic_string<_CharType>::__init_copy_ctor_external(value_type const*, size_type)) _Func(_LIBCPP_FUNC_VIS const _CharType& basic_string<_CharType>::at(size_type) const) _Func(_LIBCPP_FUNC_VIS basic_string<_CharType>& basic_string<_CharType>::insert(size_type, value_type const*, size_type)) _Func(_LIBCPP_FUNC_VIS basic_string<_CharType>::size_type basic_string<_CharType>::find_first_of(value_type const*, size_type, size_type) const) _Func(_LIBCPP_FUNC_VIS basic_string<_CharType>& basic_string<_CharType>::replace(size_type, size_type, size_type, value_type)) _Func(_LIBCPP_FUNC_VIS basic_string<_CharType>& basic_string<_CharType>::__assign_external(value_type const*, size_type)) _Func(_LIBCPP_FUNC_VIS basic_string<_CharType>& basic_string<_CharType>::__assign_external(value_type const*)) _Func(_LIBCPP_FUNC_VIS void basic_string<_CharType>::reserve(size_type)) _Func(_LIBCPP_FUNC_VIS basic_string<_CharType>& basic_string<_CharType>::append(value_type const*, size_type)) _Func(_LIBCPP_FUNC_VIS basic_string<_CharType>& basic_string<_CharType>::assign(basic_string const&, size_type, size_type)) _Func(_LIBCPP_FUNC_VIS basic_string<_CharType>::size_type basic_string<_CharType>::copy(value_type*, size_type, size_type) const) _Func(_LIBCPP_FUNC_VIS basic_string<_CharType>::basic_string(basic_string const&, size_type, size_type, allocator<_CharType> const&)) _Func(_LIBCPP_FUNC_VIS basic_string<_CharType>::size_type basic_string<_CharType>::find(value_type, size_type) const) _Func(_LIBCPP_FUNC_VIS void basic_string<_CharType>::__init(size_type, value_type)) _Func(_LIBCPP_FUNC_VIS basic_string<_CharType>& basic_string<_CharType>::insert(size_type, value_type const*)) _Func(_LIBCPP_FUNC_VIS basic_string<_CharType>::size_type basic_string<_CharType>::find_last_of(value_type const*, size_type, size_type) const) _Func(_LIBCPP_FUNC_VIS void basic_string<_CharType>::__grow_by(size_type, size_type, size_type, size_type, size_type, size_type)) _Func(_LIBCPP_FUNC_VIS void basic_string<_CharType>::__grow_by_and_replace(size_type, size_type, size_type, size_type, size_type, size_type, value_type const*)) _Func(_LIBCPP_FUNC_VIS basic_string<_CharType>& basic_string<_CharType>::__assign_no_alias<false>(value_type const*, size_type)) _Func(_LIBCPP_FUNC_VIS basic_string<_CharType>& basic_string<_CharType>::__assign_no_alias<true>(value_type const*, size_type)) _Func(_LIBCPP_FUNC_VIS void basic_string<_CharType>::push_back(value_type)) _Func(_LIBCPP_FUNC_VIS basic_string<_CharType>& basic_string<_CharType>::append(size_type, value_type)) _Func(_LIBCPP_FUNC_VIS basic_string<_CharType>::size_type basic_string<_CharType>::rfind(value_type, size_type) const) _Func(_LIBCPP_FUNC_VIS const basic_string<_CharType>::size_type basic_string<_CharType>::npos) _Func(_LIBCPP_FUNC_VIS basic_string<_CharType>& basic_string<_CharType>::assign(size_type, value_type)) _Func(_LIBCPP_FUNC_VIS void basic_string<_CharType>::__erase_external_with_move(size_type, size_type)) _Func(_LIBCPP_FUNC_VIS basic_string<_CharType>& basic_string<_CharType>::append(basic_string const&, size_type, size_type)) _Func(_LIBCPP_FUNC_VIS int basic_string<_CharType>::compare(value_type const*) const) _Func(_LIBCPP_FUNC_VIS int basic_string<_CharType>::compare(size_type, size_type, value_type const*) const) _Func(_LIBCPP_FUNC_VIS _CharType& basic_string<_CharType>::at(size_type)) _Func(_LIBCPP_FUNC_VIS basic_string<_CharType>::size_type basic_string<_CharType>::find(value_type const*, size_type, size_type) const) _Func(_LIBCPP_FUNC_VIS int basic_string<_CharType>::compare(size_type, size_type, basic_string const&, size_type, size_type) const) _Func(_LIBCPP_FUNC_VIS int basic_string<_CharType>::compare(size_type, size_type, value_type const*, size_type) const) _Func(_LIBCPP_FUNC_VIS basic_string<_CharType>& basic_string<_CharType>::append(value_type const*)) _Func(_LIBCPP_FUNC_VIS basic_string<_CharType>& basic_string<_CharType>::replace(size_type, size_type, basic_string const&, size_type, size_type)) _Func(_LIBCPP_FUNC_VIS basic_string<_CharType>::iterator basic_string<_CharType>::insert(basic_string::const_iterator, value_type)) _Func(_LIBCPP_FUNC_VIS void basic_string<_CharType>::resize(size_type, value_type)) _Func(_LIBCPP_FUNC_VIS basic_string<_CharType>& basic_string<_CharType>::insert(size_type, basic_string const&, size_type, size_type))_LIBCPP_STRING_V1_EXTERN_TEMPLATE_LIST(_Func,_CharType)_Func(_LIBCPP_FUNC_VIS basic_string<_CharType>& basic_string<_CharType>::replace(size_type, size_type, value_type const*, size_type)) _Func(_LIBCPP_FUNC_VIS basic_string<_CharType>::size_type basic_string<_CharType>::rfind(value_type const*, size_type, size_type) const) _Func(_LIBCPP_FUNC_VIS void basic_string<_CharType>::__init(value_type const*, size_type, size_type)) _Func(_LIBCPP_FUNC_VIS basic_string<_CharType>::basic_string(basic_string const&)) _Func(_LIBCPP_FUNC_VIS basic_string<_CharType>& basic_string<_CharType>::replace(size_type, size_type, value_type const*)) _Func(_LIBCPP_FUNC_VIS basic_string<_CharType>::basic_string(basic_string const&, allocator<_CharType> const&)) _Func(_LIBCPP_FUNC_VIS basic_string<_CharType>::size_type basic_string<_CharType>::find_last_not_of(value_type const*, size_type, size_type) const) _Func(_LIBCPP_FUNC_VIS basic_string<_CharType>::~basic_string()) _Func(_LIBCPP_FUNC_VIS basic_string<_CharType>::size_type basic_string<_CharType>::find_first_not_of(value_type const*, size_type, size_type) const) _Func(_LIBCPP_FUNC_VIS basic_string<_CharType>& basic_string<_CharType>::insert(size_type, size_type, value_type)) _Func(_LIBCPP_FUNC_VIS basic_string<_CharType>& basic_string<_CharType>::operator=(value_type)) _Func(_LIBCPP_FUNC_VIS void basic_string<_CharType>::__init(value_type const*, size_type)) _Func(_LIBCPP_FUNC_VIS const _CharType& basic_string<_CharType>::at(size_type) const) _Func(_LIBCPP_FUNC_VIS basic_string<_CharType>& basic_string<_CharType>::insert(size_type, value_type const*, size_type)) _Func(_LIBCPP_FUNC_VIS basic_string<_CharType>::size_type basic_string<_CharType>::find_first_of(value_type const*, size_type, size_type) const) _Func(_LIBCPP_FUNC_VIS basic_string<_CharType>& basic_string<_CharType>::replace(size_type, size_type, size_type, value_type)) _Func(_LIBCPP_FUNC_VIS basic_string<_CharType>& basic_string<_CharType>::assign(value_type const*, size_type)) _Func(_LIBCPP_FUNC_VIS void basic_string<_CharType>::reserve(size_type)) _Func(_LIBCPP_FUNC_VIS basic_string<_CharType>& basic_string<_CharType>::append(value_type const*, size_type)) _Func(_LIBCPP_FUNC_VIS basic_string<_CharType>& basic_string<_CharType>::assign(basic_string const&, size_type, size_type)) _Func(_LIBCPP_FUNC_VIS basic_string<_CharType>::size_type basic_string<_CharType>::copy(value_type*, size_type, size_type) const) _Func(_LIBCPP_FUNC_VIS basic_string<_CharType>::basic_string(basic_string const&, size_type, size_type, allocator<_CharType> const&)) _Func(_LIBCPP_FUNC_VIS basic_string<_CharType>::size_type basic_string<_CharType>::find(value_type, size_type) const) _Func(_LIBCPP_FUNC_VIS void basic_string<_CharType>::__init(size_type, value_type)) _Func(_LIBCPP_FUNC_VIS basic_string<_CharType>& basic_string<_CharType>::insert(size_type, value_type const*)) _Func(_LIBCPP_FUNC_VIS basic_string<_CharType>::size_type basic_string<_CharType>::find_last_of(value_type const*, size_type, size_type) const) _Func(_LIBCPP_FUNC_VIS void basic_string<_CharType>::__grow_by(size_type, size_type, size_type, size_type, size_type, size_type)) _Func(_LIBCPP_FUNC_VIS void basic_string<_CharType>::__grow_by_and_replace(size_type, size_type, size_type, size_type, size_type, size_type, value_type const*)) _Func(_LIBCPP_FUNC_VIS void basic_string<_CharType>::push_back(value_type)) _Func(_LIBCPP_FUNC_VIS basic_string<_CharType>& basic_string<_CharType>::append(size_type, value_type)) _Func(_LIBCPP_FUNC_VIS basic_string<_CharType>::size_type basic_string<_CharType>::rfind(value_type, size_type) const) _Func(_LIBCPP_FUNC_VIS const basic_string<_CharType>::size_type basic_string<_CharType>::npos) _Func(_LIBCPP_FUNC_VIS basic_string<_CharType>& basic_string<_CharType>::assign(size_type, value_type)) _Func(_LIBCPP_FUNC_VIS basic_string<_CharType>& basic_string<_CharType>::erase(size_type, size_type)) _Func(_LIBCPP_FUNC_VIS basic_string<_CharType>& basic_string<_CharType>::append(basic_string const&, size_type, size_type)) _Func(_LIBCPP_FUNC_VIS int basic_string<_CharType>::compare(value_type const*) const) _Func(_LIBCPP_FUNC_VIS int basic_string<_CharType>::compare(size_type, size_type, value_type const*) const) _Func(_LIBCPP_FUNC_VIS _CharType& basic_string<_CharType>::at(size_type)) _Func(_LIBCPP_FUNC_VIS basic_string<_CharType>& basic_string<_CharType>::assign(value_type const*)) _Func(_LIBCPP_FUNC_VIS basic_string<_CharType>::size_type basic_string<_CharType>::find(value_type const*, size_type, size_type) const) _Func(_LIBCPP_FUNC_VIS int basic_string<_CharType>::compare(size_type, size_type, basic_string const&, size_type, size_type) const) _Func(_LIBCPP_FUNC_VIS int basic_string<_CharType>::compare(size_type, size_type, value_type const*, size_type) const) _Func(_LIBCPP_FUNC_VIS basic_string<_CharType>& basic_string<_CharType>::operator=(basic_string const&)) _Func(_LIBCPP_FUNC_VIS basic_string<_CharType>& basic_string<_CharType>::append(value_type const*)) _Func(_LIBCPP_FUNC_VIS basic_string<_CharType>& basic_string<_CharType>::replace(size_type, size_type, basic_string const&, size_type, size_type)) _Func(_LIBCPP_FUNC_VIS basic_string<_CharType>::iterator basic_string<_CharType>::insert(basic_string::const_iterator, value_type)) _Func(_LIBCPP_FUNC_VIS void basic_string<_CharType>::resize(size_type, value_type)) _Func(_LIBCPP_FUNC_VIS basic_string<_CharType>& basic_string<_CharType>::insert(size_type, basic_string const&, size_type, size_type))_LIBCPP___STRING__has_feature(cxx_constexpr_string_builtins)_LIBCPP_DEBUG_LEVEL >= 1// _LIBCPP___STRING//  This would be a nice place for a string_ref// __str_find_last_not_of// __str_find_first_not_of// __str_find_last_of// __str_find_first_of// __str_rfind// There is nothing to search, just return __pos.// the string.// __first1 + 1 is most likely not aligned, as the match is in the middle of// __first2 is most likely aligned, as it is user's "pattern" string, and// already know that it matches the first byte of __first2: this is because// It is faster to compare from the first byte of __first1 even if we// Find __f2 the first byte matching in __first1.// Check whether __first1 still has at least __len2 bytes.// First element of __first2 is loop invariant.// Stop short when source is smaller than pattern.// Take advantage of knowing source and pattern lengths.// __str_find// helper fns for basic_string and string_view// #_LIBCPP_HAS_NO_CHAR8_T// TODO use '__builtin_char_memchr' if it ever supports char8_t ??// TODO use '__builtin_strlen' if it ever supports char8_t ??// char_traits<wchar_t>// char_traits<char>// constexpr versions of move/copy/assign.// char_traits// must never be removed from the stable list.// functions supporting new c++ version / API changes. Typically entries// For stable, the ABI list should rarely change, except for adding new// optimization opportunities.// and add (new) external functions to better control inlining and compiler// For unstable, we may explicitly remove function that are external in V1,// As the name implies, the ABI lists define the V1 (Stable) and unstable ABI.// - _LIBCPP_STRING_UNSTABLE_EXTERN_TEMPLATE_LIST// - _LIBCPP_STRING_V1_EXTERN_TEMPLATE_LIST// readability of that header. We maintain 2 ABI lists:// The extern template ABI lists are kept outside of <string> to improve the// readability of that header.// The the extern template ABI lists are kept outside of <string> to improve the// for wmemcpy// for streampos & friends// for __libcpp_is_constant_evaluated// for memcpy// for uint_least16_t// for __murmur2_or_cityhash//===-------------------------- __string ----------------------------------===//__first1__last1__first2__last2xsputnuflowxsgetnshowmanycsetp__pbumppbumpepptrpptrpbasesetggbumpegptrgptrebackbasic_streambuf<_CharT, _Traits> &const basic_streambuf<_CharT, _Traits>const basic_streambuf<_CharT, _Traits> &basic_streambufsputnsputcsungetcsputbackcsgetnsgetcsbumpcsnextcin_availpubsyncpubseekpospubseekoffpubsetbufgetlocpubimbue~basic_streambuf__eout___nout___bout___einp___ninp___binp___loc_(is_same<_CharT, typename traits_type::char_type>::value), "traits_type::char_type must be the same type as CharT"_LIBCPP_STREAMBUFbasic_ios<wchar_t, char_traits<wchar_t>>class _LIBCPP_EXTERN_TEMPLATE_TYPE_VIS basic_ios<wchar_t>class __attribute__ ((__visibility__("default"))) basic_ios<wchar_t>basic_ios<char, char_traits<char>>class _LIBCPP_EXTERN_TEMPLATE_TYPE_VIS basic_ios<char>class __attribute__ ((__visibility__("default"))) basic_ios<char>basic_streambuf<wchar_t, char_traits<wchar_t>>class _LIBCPP_EXTERN_TEMPLATE_TYPE_VIS basic_streambuf<wchar_t>class __attribute__ ((__visibility__("default"))) basic_streambuf<wchar_t>basic_streambuf<char, char_traits<char>>class _LIBCPP_EXTERN_TEMPLATE_TYPE_VIS basic_streambuf<char>class __attribute__ ((__visibility__("default"))) basic_streambuf<char>// _LIBCPP_STREAMBUF// 27.6.2.4.5 Put area:// 27.6.2.4.4 Putback:// 27.6.2.4.3 Get area:// 27.6.2.4.2 Buffer management and positioning:// 27.6.2.4.1 Locales:// 27.6.2.4 virtual functions:// 27.6.2.3.3 Put area:// 27.6.2.3.2 Get area:// 27.6.2.2.5 Put area:// 27.6.2.2.4 Putback:// 27.6.2.2.3 Get area:// Get and put areas:// 27.6.2.2.2 buffer and positioning:// 27.6.2.2.1 locales:/*
    streambuf synopsis

namespace std
{

template <class charT, class traits = char_traits<charT> >
class basic_streambuf
{
public:
    // types:
    typedef charT char_type;
    typedef traits traits_type;
    typedef typename traits_type::int_type int_type;
    typedef typename traits_type::pos_type pos_type;
    typedef typename traits_type::off_type off_type;

    virtual ~basic_streambuf();

    // 27.6.2.2.1 locales:
    locale pubimbue(const locale& loc);
    locale getloc() const;

    // 27.6.2.2.2 buffer and positioning:
    basic_streambuf* pubsetbuf(char_type* s, streamsize n);
    pos_type pubseekoff(off_type off, ios_base::seekdir way,
                        ios_base::openmode which = ios_base::in | ios_base::out);
    pos_type pubseekpos(pos_type sp,
                        ios_base::openmode which = ios_base::in | ios_base::out);
    int pubsync();

    // Get and put areas:
    // 27.6.2.2.3 Get area:
    streamsize in_avail();
    int_type snextc();
    int_type sbumpc();
    int_type sgetc();
    streamsize sgetn(char_type* s, streamsize n);

    // 27.6.2.2.4 Putback:
    int_type sputbackc(char_type c);
    int_type sungetc();

    // 27.6.2.2.5 Put area:
    int_type sputc(char_type c);
    streamsize sputn(const char_type* s, streamsize n);

protected:
    basic_streambuf();
    basic_streambuf(const basic_streambuf& rhs);
    basic_streambuf& operator=(const basic_streambuf& rhs);
    void swap(basic_streambuf& rhs);

    // 27.6.2.3.2 Get area:
    char_type* eback() const;
    char_type* gptr() const;
    char_type* egptr() const;
    void gbump(int n);
    void setg(char_type* gbeg, char_type* gnext, char_type* gend);

    // 27.6.2.3.3 Put area:
    char_type* pbase() const;
    char_type* pptr() const;
    char_type* epptr() const;
    void pbump(int n);
    void setp(char_type* pbeg, char_type* pend);

    // 27.6.2.4 virtual functions:
    // 27.6.2.4.1 Locales:
    virtual void imbue(const locale& loc);

    // 27.6.2.4.2 Buffer management and positioning:
    virtual basic_streambuf* setbuf(char_type* s, streamsize n);
    virtual pos_type seekoff(off_type off, ios_base::seekdir way,
                             ios_base::openmode which = ios_base::in | ios_base::out);
    virtual pos_type seekpos(pos_type sp,
                             ios_base::openmode which = ios_base::in | ios_base::out);
    virtual int sync();

    // 27.6.2.4.3 Get area:
    virtual streamsize showmanyc();
    virtual streamsize xsgetn(char_type* s, streamsize n);
    virtual int_type underflow();
    virtual int_type uflow();

    // 27.6.2.4.4 Putback:
    virtual int_type pbackfail(int_type c = traits_type::eof());

    // 27.6.2.4.5 Put area:
    virtual streamsize xsputn(const char_type* s, streamsize n);
    virtual int_type overflow (int_type c = traits_type::eof());
};

}  // std

*///===------------------------- streambuf ----------------------------------===//__pbeg__pend__gbeg__gnext__gend__whichinitwsbasic_istream<char, _Traits> &signed char &unsigned char &__input_c_string__input_arithmetic_with_numeric_limits__input_arithmetic__stateios_base::goodbit__sen__extr__chios_base::eofbit__setstate_nothrowexceptionsbasic_iostream<_CharT, _Traits> &basic_iostream<_CharT, _Traits> &&basic_iostream~basic_iostreamungetputbackreadsomeignoregcountlong double &unsigned long long &long long &unsigned int &short &const basic_istream<_CharT, _Traits>const basic_istream<_CharT, _Traits> &basic_istream~basic_istream__is_istreamable<_Stream, _Tp, decltype((<expression>))>__is_istreamable<_Stream, _Tp, <unnamed>>declval<_Stream>() >> declval<_Tp>(), void()__gc__LIBCPP_ISTREAMbasic_iostream<char, char_traits<char>>class _LIBCPP_EXTERN_TEMPLATE_TYPE_VIS basic_iostream<char>class __attribute__ ((__visibility__("default"))) basic_iostream<char>basic_istream<wchar_t, char_traits<wchar_t>>class _LIBCPP_EXTERN_TEMPLATE_TYPE_VIS basic_istream<wchar_t>class __attribute__ ((__visibility__("default"))) basic_istream<wchar_t>basic_istream<char, char_traits<char>>class _LIBCPP_EXTERN_TEMPLATE_TYPE_VIS basic_istream<char>class __attribute__ ((__visibility__("default"))) basic_istream<char>// _LIBCPP_ISTREAM// assign/swap// constructor/destructor// according to the spec, exceptions here are caught but not rethrown//    ~sentry() = default;// 27.7.1.3 Unformatted input:// 27.7.1.2 Formatted input:// 27.7.1.1.3 Prefix/suffix:// 27.7.1.1.2 Assign/swap:// 27.7.1.1.1 Constructor/destructor:/*
    istream synopsis

template <class charT, class traits = char_traits<charT> >
class basic_istream
    : virtual public basic_ios<charT,traits>
{
public:
    // types (inherited from basic_ios (27.5.4)):
    typedef charT                          char_type;
    typedef traits                         traits_type;
    typedef typename traits_type::int_type int_type;
    typedef typename traits_type::pos_type pos_type;
    typedef typename traits_type::off_type off_type;

    // 27.7.1.1.1 Constructor/destructor:
    explicit basic_istream(basic_streambuf<char_type, traits_type>* sb);
    basic_istream(basic_istream&& rhs);
    virtual ~basic_istream();

    // 27.7.1.1.2 Assign/swap:
    basic_istream& operator=(basic_istream&& rhs);
    void swap(basic_istream& rhs);

    // 27.7.1.1.3 Prefix/suffix:
    class sentry;

    // 27.7.1.2 Formatted input:
    basic_istream& operator>>(basic_istream& (*pf)(basic_istream&));
    basic_istream& operator>>(basic_ios<char_type, traits_type>&
                              (*pf)(basic_ios<char_type, traits_type>&));
    basic_istream& operator>>(ios_base& (*pf)(ios_base&));
    basic_istream& operator>>(basic_streambuf<char_type, traits_type>* sb);
    basic_istream& operator>>(bool& n);
    basic_istream& operator>>(short& n);
    basic_istream& operator>>(unsigned short& n);
    basic_istream& operator>>(int& n);
    basic_istream& operator>>(unsigned int& n);
    basic_istream& operator>>(long& n);
    basic_istream& operator>>(unsigned long& n);
    basic_istream& operator>>(long long& n);
    basic_istream& operator>>(unsigned long long& n);
    basic_istream& operator>>(float& f);
    basic_istream& operator>>(double& f);
    basic_istream& operator>>(long double& f);
    basic_istream& operator>>(void*& p);

    // 27.7.1.3 Unformatted input:
    streamsize gcount() const;
    int_type get();
    basic_istream& get(char_type& c);
    basic_istream& get(char_type* s, streamsize n);
    basic_istream& get(char_type* s, streamsize n, char_type delim);
    basic_istream& get(basic_streambuf<char_type,traits_type>& sb);
    basic_istream& get(basic_streambuf<char_type,traits_type>& sb, char_type delim);

    basic_istream& getline(char_type* s, streamsize n);
    basic_istream& getline(char_type* s, streamsize n, char_type delim);

    basic_istream& ignore(streamsize n = 1, int_type delim = traits_type::eof());
    int_type peek();
    basic_istream& read (char_type* s, streamsize n);
    streamsize readsome(char_type* s, streamsize n);

    basic_istream& putback(char_type c);
    basic_istream& unget();
    int sync();

    pos_type tellg();
    basic_istream& seekg(pos_type);
    basic_istream& seekg(off_type, ios_base::seekdir);
protected:
    basic_istream(const basic_istream& rhs) = delete;
    basic_istream(basic_istream&& rhs);
    // 27.7.2.1.2 Assign/swap:
    basic_istream& operator=(const basic_istream& rhs) = delete;
    basic_istream& operator=(basic_istream&& rhs);
    void swap(basic_istream& rhs);
};

// 27.7.1.2.3 character extraction templates:
template<class charT, class traits>
  basic_istream<charT,traits>& operator>>(basic_istream<charT,traits>&, charT&);

template<class traits>
  basic_istream<char,traits>& operator>>(basic_istream<char,traits>&, unsigned char&);

template<class traits>
  basic_istream<char,traits>& operator>>(basic_istream<char,traits>&, signed char&);

template<class charT, class traits>
  basic_istream<charT,traits>& operator>>(basic_istream<charT,traits>&, charT*);

template<class traits>
  basic_istream<char,traits>& operator>>(basic_istream<char,traits>&, unsigned char*);

template<class traits>
  basic_istream<char,traits>& operator>>(basic_istream<char,traits>&, signed char*);

template <class charT, class traits>
  void
  swap(basic_istream<charT, traits>& x, basic_istream<charT, traits>& y);

typedef basic_istream<char> istream;
typedef basic_istream<wchar_t> wistream;

template <class charT, class traits = char_traits<charT> >
class basic_iostream :
    public basic_istream<charT,traits>,
    public basic_ostream<charT,traits>
{
public:
    // types:
    typedef charT                          char_type;
    typedef traits                         traits_type;
    typedef typename traits_type::int_type int_type;
    typedef typename traits_type::pos_type pos_type;
    typedef typename traits_type::off_type off_type;

    // constructor/destructor
    explicit basic_iostream(basic_streambuf<char_type, traits_type>* sb);
    basic_iostream(basic_iostream&& rhs);
    virtual ~basic_iostream();

    // assign/swap
    basic_iostream& operator=(basic_iostream&& rhs);
    void swap(basic_iostream& rhs);
};

template <class charT, class traits>
  void
  swap(basic_iostream<charT, traits>& x, basic_iostream<charT, traits>& y);

typedef basic_iostream<char> iostream;
typedef basic_iostream<wchar_t> wiostream;

template <class charT, class traits>
  basic_istream<charT,traits>&
  ws(basic_istream<charT,traits>& is);

// rvalue stream extraction
template <class Stream, class T>
  Stream&& operator>>(Stream&& is, T&& x);

}  // std

*///===--------------------------- istream ----------------------------------===//__noskipws/Users/owura/Repos/codeql_eval/proj_repos/Exiv2-exiv2-pull-962-commits-e925bc5addd881543fa503470c8a859e112cca62/exiv2/samples/iptctest.cppprocessModifykeyStart 	" \t"keyEnddataStartInvalid 'm' command at line "Invalid \'m\' command at line "iptcKeyiterIptc dataset already exists and is not repeatable"Iptc dataset already exists and is not repeatable"const char[50]char[50]const char(&)[50]char(&)[50]processRemoveInvalid 'r' command at line "Invalid \'r\' command at line "processAddInvalid 'a' command at line "Invalid \'a\' command at line "processLine'A''R''M''q''Q'Unknown command ("Unknown command (") at line ") at line "linenum image
" image\n"Commands read from stdin.
"Commands read from stdin.\n"istream &// if data starts and ends with quotes, remove them// Save any changes// Process commands/*
  Abstract : Sample program test the Iptc reading and writing.
             This is not designed to be a robust application.

  File     : iptctest.cpp
  Author(s): Brad Schick (brad) <brad@robotbattle.com>
  History  : 01-Aug-04, brad: created
 *//Users/owura/Repos/codeql_eval/proj_repos/Exiv2-exiv2-pull-962-commits-e925bc5addd881543fa503470c8a859e112cca62/exiv2/samples/key-test.cpptcekTestcase failed (operator<<)"Testcase failed (operator<<)"Exif"Exif"Testcase failed (familyName)"Testcase failed (familyName)"Iop"Iop"Testcase failed (groupName)"Testcase failed (groupName)"InteroperabilityVersion"InteroperabilityVersion"Testcase failed (tagName)"Testcase failed (tagName)"Testcase failed (tag)"Testcase failed (tag)"Testcase failed (ifdName: "Testcase failed (ifdName: "Interoperability"Interoperability"Testcase failed (sectionName)"Testcase failed (sectionName)"ek2os2ek4Exif.Image.0x0110"Exif.Image.0x0110"Testcase failed (converted key)"Testcase failed (converted key)"const char[32]char[32]Model"Model"Testcase failed (converted tagName)"Testcase failed (converted tagName)"ek5Exif.Nikon3.0x0007"Exif.Nikon3.0x0007"Exif.Nikon3.Focus"Exif.Nikon3.Focus"Focus"Focus"ik1Iptc.Envelope.0x0005"Iptc.Envelope.0x0005"Iptc.Envelope.Destination"Iptc.Envelope.Destination"Testcase failed (converted Iptc key)"Testcase failed (converted Iptc key)""Destination"Envelope"Envelope"Testcase failed (converted recordName)"Testcase failed (converted recordName)"ik2439810xabcd46600x1234Iptc.0x1234.0xabcd"Iptc.0x1234.0xabcd"Testcase failed (unknown Iptc key)"Testcase failed (unknown Iptc key)""0xabcd""0x1234"All "All " testcases passed." testcases passed." of " of " testcases failed." testcases failed."// -----// sectionName// ifdName// tagName// groupName// familyName// operator<<// Copy constructor/*
  Abstract : Key unit tests

  File     : key-test.cpp
  Author(s): Andreas Huggel (ahu) <ahuggel@gmx.net>
  History  : 24-Aug-04, ahu: created

 */count_(0)/Users/owura/Repos/codeql_eval/proj_repos/Exiv2-exiv2-pull-962-commits-e925bc5addd881543fa503470c8a859e112cca62/exiv2/samples/largeiptc-test.cppirbsizeHdrsizeDatarawIptc image datafile
" image datafile\n"Reading "Reading " bytes from " bytes from "Exiv2::kerFailedToReadImageDataIPTC fields: "IPTC fields: "Iptc.Application2.Preview"Iptc.Application2.Preview"IRB buffer : "IRB buffer : "const byte **unsigned char **uint32_t *Comparing IPTC and IRB size... "Comparing IPTC and IRB size... "not "not "ok
"ok\n"Comparing IPTC and IRB data... "Comparing IPTC and IRB data... "// Set Iptc data and write it to the file// Set IRB, compare with IPTC raw data// Set Preview field to the content of the data file// Read metadata from file// Read data file into data buffer// Test for large (>65535 bytes) IPTC buffer<__nullptr>auto_ptr<void> &const auto_ptr<void>const auto_ptr<void> &operator std::__1::auto_ptr<_Up>operator std::__1::auto_ptr_ref<_Up>auto_ptr<_Tp> *auto_ptrconst auto_ptr<_Tp>const auto_ptr<_Tp> *~auto_ptrauto_ptr<_Tp> &auto_ptr<_Up> &auto_ptr<void>auto_ptr<_Tp>auto_ptr_ref<_Tp>_LIBCPP___MEMORY_AUTO_PTR_H// _LIBCPP___MEMORY_AUTO_PTR_H<ctype.h>Getopt &const Getoptconst Getopt &Getopterrcntconst Getopt *progname~Getopterrcnt_progname_optposGETOPT_HUtil// namespace Util//! Total number of errors returned by calls to option()//! Program name (argv[0])/*!
          @brief Callback used by getopt() to pass on each non-option parameter
                 found on the command line.

          Implement this method in a derived class to handle the non-option
          parameters as needed. The default implementation ignores all non-option
          parameters.

          @param argv The non-option parameter from the command line.

          @return 0 if successful, 1 in case of an error.
         *//*!
          @brief Callback used by getopt() to pass on each option and its
                 argument (if any).

          Implement this method in a derived class to handle the options as
          needed. See the manual pages for %getopt(3) for further details, in
          particular, the semantics of optarg and optopt.

          @param opt Value of the option character as returned by %getopt(3).
          @param optarg The corresponding option argument.
          @param optopt The actual option character in case of an unrecognized
                 option or a missing option argument (opt is '?' or ':').

          @return 0 if successful, 1 in case of an error.
         *//*!
          @brief Parse command line arguments.

          Parses the command line arguments. Calls option() with the
          character value of the option and its argument (if any) for each
          recognized option and with ':' or '?' for unrecognized options.
          See the manual pages for %getopt(3) for details.  In addition,
          nonoption() is invoked for each remaining non-option parameter on
          the command line.

          @param argc Argument count as passed to main() on  program invocation.
          @param argv Argument array as passed to main() on  program invocation.
          @param optstring String containing the legitimate option characters.

          @return Number of errors (the sum of the return values from option()
                  and nonoption()).
         *///! Destructor./*!
      @brief Parse the command line options of a program.

      A wrapper around the POSIX %getopt(3) function.  Parses the command line
      options and passes each option to virtual option().  A derived class
      implements this method to handle options as needed.  Similarly,
      remaining non-option parameters are passed to the virtual nonoption()
      method.
     */// *********************************************************************/Users/owura/Repos/codeql_eval/proj_repos/Exiv2-exiv2-pull-962-commits-e925bc5addd881543fa503470c8a859e112cca62/exiv2/src/Users/owura/Repos/codeql_eval/proj_repos/Exiv2-exiv2-pull-962-commits-e925bc5addd881543fa503470c8a859e112cca62/exiv2/samples/metacopy.hpp:iecaph":iecaph"first_(true)help_(false)iptc_(false)exif_(false)comment_(false)xmp_(false)preserve_(false)write_read_preserve_xmp_comment_exif_iptc_help_first_optstring_METACOPY_HPP_const Params *usage// METACOPY_HPP_//! Print further usage explanations to an output stream.//! Print a minimal usage note to an output stream./*!
      @brief Call Getopt::getopt() with optstring, to initiate command line
             argument parsing, perform consistency checks after all command line
             arguments are parsed.

      @param argc Argument count as passed to main() on program invocation.
      @param argv Argument array as passed to main() on program invocation.

      @return 0 if successful, >0 in case of errors.
     *//*!
      @brief Default constructor. Note that optstring_ is initialized here.
     *///!< Destination file//!< Source file//!< Preserve existing metadata option flag.//!< XMP option flag.//!< JPEG comment option flag.//!< Exif option flag.//!< Iptc option flag.//!< Help option flag./*!
  @file    metacopy.hpp
  @brief   Defines class Params, used for the command line handling
  @author  Brad Schick (brad) <brad@robotbattle.com>
  @date    13-Jul-04, brad: created
 *//Users/owura/Repos/codeql_eval/proj_repos/Exiv2-exiv2-pull-962-commits-e925bc5addd881543fa503470c8a859e112cca62/exiv2/samples/metacopy.cpp"metacopy.hpp"readImg.get() != 0writeImg.get() != 0fileIoFileIo *BasicIo *memIoMemIo *readImgAutoPtr &auto_ptr<BasicIo> &writeImgconst auto_ptr<BasicIo>const Imageconst Image *: Could not write metadata to (": Could not write metadata to (")
")\n"
Options:
"\nOptions:\n"   -i      Read Iptc data from readfile and write to writefile.
"   -i      Read Iptc data from readfile and write to writefile.\n"const char[65]char[65]   -e      Read Exif data from readfile and write to writefile.
"   -e      Read Exif data from readfile and write to writefile.\n"   -c      Read Jpeg comment from readfile and write to writefile.
"   -c      Read Jpeg comment from readfile and write to writefile.\n"   -x      Read XMP data from readfile and write to writefile.
"   -x      Read XMP data from readfile and write to writefile.\n"const char[64]char[64]   -a      Read all metadata from readfile and write to writefile.
"   -a      Read all metadata from readfile and write to writefile.\n"   -p      Preserve existing metadata in writefile if not replaced.
"   -p      Preserve existing metadata in writefile if not replaced.\n"const char[69]char[69]   -h      Display this help and exit.

"   -h      Display this help and exit.\n\n"const char[41]char[41]
Reads and writes raw metadata. Use -h option for help.
"\nReads and writes raw metadata. Use -h option for help.\n"const char[57]char[57] [-iecaph] readfile writefile
" [-iecaph] readfile writefile\n": Unexpected extra argument (": Unexpected extra argument ("'h': Option -": Option -" requires an argument
" requires an argument\n"'?': Unrecognized option -": Unrecognized option -": getopt returned unexpected character code ": getopt returned unexpected character code ": Read and write files must be specified
": Read and write files must be specified\n": Write file must be specified
": Write file must be specified\n": Option -p has no effect when all metadata types are specified.
": Option -p has no effect when all metadata types are specified.\n"const char[66]char[66]// Params::help// Params::getopt// Further consistency checks/*optarg*/// Use MemIo to increase test coverage.// include local header files which are not part of libexiv2/*
  Abstract : Tester application for image file handling

  File     : metacopy.cpp
  Author(s): Brad Schick (brad) <brad@robotbattle.com>
  History  : 13-Jul-04, brad: created
 *//Users/owura/Repos/codeql_eval/proj_repos/Exiv2-exiv2-pull-962-commits-e925bc5addd881543fa503470c8a859e112cca62/exiv2/samples/mmap-test.cpppDatarb"rb"const char *const &const char(&)[3]char(&)[3]// Read from the mapped region again// Reopen file in write mode and write to it// Read from the memory mapped region// Map it to memory// Open the file in read mode// Simple mmap tests// mmap-test.cpp/Users/owura/Repos/codeql_eval/proj_repos/Exiv2-exiv2-pull-962-commits-e925bc5addd881543fa503470c8a859e112cca62/exiv2/samples/mrwthumb.cpp"image.hpp""exif.hpp""error.hpp"Exif.Minolta.ThumbnailOffset"Exif.Minolta.ThumbnailOffset"img_thumb.jpg"img_thumb.jpg"wb"wb"// The first byte of the buffer needs to be patched// Sample program to extract a Minolta thumbnail from the makernote// mrwthumb.cppwidthconst ctype<_CharT>const ctype<_CharT> &ctype<_CharT> &__ctspacebasic_istream<_CharT, _Traits> *"xmp_exiv2.hpp""iptc.hpp""basicio.hpp"Blob &vector<unsigned char, allocator<unsigned char>> &ImageFactory &const ImageFactoryconst ImageFactory &ImageFactorycheckTypecheckModecreateIoImage &const Image &ImagetypeNameimageTypesetTypeSupportedconst NativePreviewListconst NativePreviewList &vector<NativePreview, allocator<NativePreview>> &nativePreviewswriteXmpFromPacketsupportsMetadataxmpPacketpixelHeightpixelWidthmimeTypebyteSwap8const DataBufconst DataBuf &DataBuf &byteSwap4byteSwap2byteSwapisPrintICCisPrintXMPis8ByteTypeis4ByteTypeis2ByteTypeisRationalTypeisLongLongTypeisLongTypeisShortTypeisStringTypeisLittleEndianPlatformisBigEndianPlatformprintIFDStructureprintTiffStructuresetByteOrderclearMetadatasetMetadataDataBuf *iccProfileiccProfileDefinedclearIccProfilesetIccProfileclearCommentsetCommentclearXmpDatasetXmpDataclearXmpPacketsetXmpPacketclearIptcDatasetIptcDataclearExifDatasetExifDatawriteMetadatareadMetadataprintStructurekpsNone~ImageNativePreview &const NativePreviewconst NativePreview &~NativePreviewNativePreviewIsThisTypeFctNewInstanceFctPrintStructureOptionkpsBasickpsXMPkpsRecursivekpsIccProfilekpsIptcEraseNativePreviewListinit_tags_writeXmpFromPacket_supportedMetadata_imageType_nativePreviews_mimeType_filter_height_width_size_position_pixelHeight_pixelWidth_xmpPacket_iccProfile_xmpData_iptcData_exifData_io_noneIMAGE_HPP_// #ifndef IMAGE_HPP_//! Append \em len bytes pointed to by \em buf to \em blob.// template, inline and free functions// class ImageFactory//! Prevent copy construction: not implemented./*!
          @brief Determine if the content of \em io is an image of \em type.

          The \em advance flag determines if the read position in the
          stream is moved (see below). This applies only if the type
          matches and the function returns true. If the type does not
          match, the stream position is not changed. However, if
          reading from the stream fails, the stream position is
          undefined. Consult the stream state to obtain more
          information in this case.

          @param type Type of the image.
          @param io BasicIo instance to read from.
          @param advance Flag indicating whether the position of the io
              should be advanced by the number of characters read to
              analyse the data (true) or left at its original
              position (false). This applies only if the type matches.
          @return  true  if the data matches the type of this class;<BR>
                   false if the data does not match
        *//*!
          @brief Returns the access mode or supported metadata functions for an
              image type and a metadata type.
          @param type       The image type.
          @param metadataId The metadata identifier.
          @return Access mode for the requested image type and metadata identifier.
          @throw Error(kerUnsupportedImageType) if the image type is not supported.
         *//*!
          @brief Returns the image type of data provided by a BasicIo instance.
              The passed in \em io instance is (re)opened by this method.
          @param io A BasicIo instance that provides image data. The contents
              of the image data are tested to determine the type.
          @return %Image type or Image::none if the type is not recognized.
         *//*!
          @brief Returns the image type of the provided data buffer.
          @param data Pointer to a data buffer containing an image. The contents
              of the memory are tested to determine the image type.
          @param size Number of bytes pointed to by \em data.
          @return %Image type or Image::none if the type is not recognized.
         *//*!
          @brief Like getType() but accepts a unicode path in an std::wstring.
          @note This function is only available on Windows.
         *//*!
          @brief Returns the image type of the provided file.
          @param path %Image file. The contents of the file are tested to
              determine the image type. File extension is ignored.
          @return %Image type or Image::none if the type is not recognized.
         *//*!
          @brief Create an Image subclass of the requested type by writing a
              new image to a BasicIo instance. If the BasicIo instance already
              contains data, it will be overwritten.
          @param type Type of the image to be created.
          @param io An auto-pointer that owns a BasicIo instance that will
              be written to when creating a new image.
          @note This method takes ownership of the passed in BasicIo instance
              through the auto-pointer. Callers should not continue to use the
              BasicIo instance after it is passed to this method.  Use the
              Image::io() method to get a temporary reference.
          @return An auto-pointer that owns an Image instance of the requested
              type. If the image type is not supported, the pointer is 0.
         *//*!
          @brief Create an Image subclass of the requested type by creating a
              new image in memory.
          @param type Type of the image to be created.
          @return An auto-pointer that owns an Image instance of the requested
              type.
          @throw Error If the image type is not supported
         *//*!
          @brief Like create() but accepts a unicode path in an std::wstring.
          @note This function is only available on Windows.
         *//*!
          @brief Create an Image subclass of the requested type by creating a
              new image file. If the file already exists, it will be overwritten.
          @param type Type of the image to be created.
          @param path %Image file to create. File extension is ignored.
          @return An auto-pointer that owns an Image instance of the requested
              type.
          @throw Error If the image type is not supported.
         *//*!
          @brief Create an Image subclass of the appropriate type by reading
              the provided BasicIo instance. %Image type is derived from the
              data provided by \em io. The passed in \em io instance is
              (re)opened by this method.
          @param io An auto-pointer that owns a BasicIo instance that provides
              image data. The contents of the image data are tested to determine
              the type.
          @note This method takes ownership of the passed
              in BasicIo instance through the auto-pointer. Callers should not
              continue to use the BasicIo instance after it is passed to this method.
              Use the Image::io() method to get a temporary reference.
          @return An auto-pointer that owns an Image instance whose type
              matches that of the \em io data. If no image type could be
              determined, the pointer is 0.
          @throw Error If opening the BasicIo fails
         *//*!
          @brief Create an Image subclass of the appropriate type by reading
              the provided memory. %Image type is derived from the memory
              contents.
          @param data Pointer to a data buffer containing an image. The contents
              of the memory are tested to determine the image type.
          @param size Number of bytes pointed to by \em data.
          @return An auto-pointer that owns an Image instance whose type
              matches that of the data buffer.
          @throw Error If the memory contains data of an unknown image type.
         *//*!
          @brief Like open() but accepts a unicode path in an std::wstring.
          @note This function is only available on Windows.
         *//*!
          @brief Create an Image subclass of the appropriate type by reading
              the specified file. %Image type is derived from the file
              contents.
          @param  path %Image file. The contents of the file are tested to
              determine the image type. File extension is ignored.
          @param useCurl Indicate whether the libcurl is used or not.
                If it's true, http is handled by CurlIo. Otherwise it is handled by HttpIo.
          @return An auto-pointer that owns an Image instance whose type
              matches that of the file.
          @throw Error If opening the file fails or it contains data of an
              unknown image type.
         *//*!
          @brief Like createIo() but accepts a unicode path in an std::wstring.
          @note This function is only available on Windows.
         *//*!
          @brief Create the appropriate class type implemented BasicIo based on the protocol of the input.

          "-" path implies the data from stdin and it is handled by StdinIo.
          Http path can be handled by either HttpIo or CurlIo. Https, ftp paths
          are handled by CurlIo. Ssh, sftp paths are handled by SshIo. Others are handled by FileIo.

          @param path %Image file.
          @param useCurl Indicate whether the libcurl is used or not.
                If it's true, http is handled by CurlIo. Otherwise it is handled by HttpIo.
          @return An auto-pointer that owns an BasicIo instance.
          @throw Error If the file is not found or it is unable to connect to the server to
                read the remote file.
         *//*!
      @brief Returns an Image instance of the specified type.

      The factory is implemented as a static class.
    *///! Type for function pointer that checks image types//! Type for function pointer that creates new Image instances// class Image//!< Flag marking if map of tags needs to be initialized//!< Map of tags//!< Byte order//!< Determines the source when writing XMP//!< Bitmap with all supported metadata types//!< Image type//! Assignment operator//! @name NOT implemented//! Return tag type for given tag id.//! Return tag name for given tag id.//!< list of native previews//!< image pixel height//!< image pixel width//!< XMP packet//!< User comment//!< ICC buffer (binary data)//!< XMP data container//!< IPTC data container//!< Exif data container//!< Image data IO pointer//! set type support for this image format//! Return list of native previews. This is meant to be used only by the PreviewManager.//! Return the flag indicating the source when writing XMP metadata./*!
          @brief Check if image supports a particular type of metadata.
             This method is deprecated. Use checkMode() instead.
         *//*!
          @brief Returns the access mode, i.e., the metadata functions, which
             this image supports for the metadata type \em metadataId.
          @param metadataId The metadata identifier.
          @return Access mode for the requested image type and metadata identifier.
         *//*!
          @brief Return a reference to the BasicIo instance being used for Io.

          This refence is particularly useful to reading the results of
          operations on a MemIo instance. For example after metadata has
          been modified and the writeMetadata() method has been called,
          this method can be used to get access to the modified image.

          @return BasicIo instance that can be used to read or write image
             data directly.
          @note If the returned BasicIo is used to write to the image, the
             Image class will not see those changes until the readMetadata()
             method is called.
         *//*!
          @brief Return the raw XMP packet as a string.
         *//*!
          @brief Return a copy of the image comment. May be an empty string.
         *//*!
          @brief Returns an XmpData instance containing currently buffered
              XMP data.

          The contained XMP data may have been read from the image by
          a previous call to readMetadata() or added directly. The XMP
          data in the returned instance will be written to the image when
          writeMetadata() is called.

          @return modifiable XmpData instance containing XMP values
         *//*!
          @brief Returns an IptcData instance containing currently buffered
              IPTC data.

          The contained IPTC data may have been read from the image by
          a previous call to readMetadata() or added directly. The IPTC
          data in the returned instance will be written to the image when
          writeMetadata() is called.

          @return modifiable IptcData instance containing IPTC values
         *//*!
          @brief Returns an ExifData instance containing currently buffered
              Exif data.

          The Exif data may have been read from the image by
          a previous call to readMetadata() or added directly. The Exif
          data in the returned instance will be written to the image when
          writeMetadata() is called.

          @return read only ExifData instance containing Exif values
         *//*!
          @brief Return the pixel height of the image.
         *//*!
          @brief Return the pixel width of the image.
         *//*!
          @brief Return the MIME type of the image.

          @note For each supported image format, the library knows only one MIME
          type.  This may not be the most specific MIME type for that format. In
          particular, several RAW formats are variants of the TIFF format with
          the same magic as TIFF itself. Class TiffImage handles most of them
          and thus they all have MIME type "image/tiff", although a more
          specific MIME type may exist (e.g., "image/x-nikon-nef").
         *//*!
          @brief Check if the Image instance is valid. Use after object
              construction.
          @return true if the Image is in a valid state.
         *//*!
          @brief Return the byte order in which the Exif metadata of the image is
                 encoded. Initially, it is not set (\em invalidByteOrder).
         *//*!
          @brief is the host platform littleEndian
         *//*!
          @brief is the host platform bigEndian
         *//*!
          @brief Print out the structure of a TIFF IFD
         *//*!
          @brief Print out the structure of image file.
          @throw Error if reading of the file fails or the image data is
                not valid (does not look like data of the specific image type).
         *//*!
          @brief Set the byte order to encode the Exif metadata in.

          The setting is only used when new Exif metadata is created and may
          not be applicable at all for some image formats. If the target image
          already contains Exif metadata, the byte order of the existing data
          is used. If byte order is not set when writeMetadata() is called,
          little-endian byte order (II) is used by default.
         *//*!
          @brief Determine the source when writing XMP.

          Depending on the setting of this flag, writeMetadata() writes
          XMP from the buffered raw XMP packet or from parsed XMP data.
          The default is to write from parsed XMP data. The switch is also
          set by all functions to set and clear the buffered raw XMP packet
          and parsed XMP data, so using this function should usually not be
          necessary.

          If %Exiv2 was compiled without XMP support, the default for this
          flag is true and it will never be changed in order to preserve
          access to the raw XMP packet.
         *//*!
          @brief Return a modifiable reference to the raw XMP packet.
         *//*!
          @brief Returns an ExifData instance containing currently buffered
              Exif data.

          The contained Exif data may have been read from the image by
          a previous call to readMetadata() or added directly. The Exif
          data in the returned instance will be written to the image when
          writeMetadata() is called.

          @return modifiable ExifData instance containing Exif values
         *//*!
          @brief Erase all buffered metadata. Metadata is not removed
              from the actual image until the writeMetadata() method is called.
         *//*!
          @brief Copy all existing metadata from source Image. The data is
              copied into internal buffers and is not written to the image
              until the writeMetadata() method is called.
          @param image Metadata source. All metadata types are copied.
         *//*!
          @brief return iccProfile
         *//*!
          @brief Erase iccProfile. the profile is not removed from
              the actual image until the writeMetadata() method is called.
         *//*!
          @brief Set the image iccProfile. The new profile is not written
              to the image until the writeMetadata() method is called.
          @param iccProfile DataBuf containing profile (binary)
          @param bTestValid - tests that iccProfile contains credible data
         *//*!
          @brief Erase any buffered comment. Comment is not removed
              from the actual image until the writeMetadata() method is called.
         *//*!
          @brief Set the image comment. The new comment is not written
              to the image until the writeMetadata() method is called.
          @param comment String containing comment.
         *//*!
          @brief Erase any buffered XMP data. XMP data is not removed from
              the actual image until the writeMetadata() method is called.

          This has the same effect as clearXmpPacket() but operates on the
          buffered parsed XMP data.

          Subsequent calls to writeMetadata() encode the XMP data to
          a raw XMP packet and write the newly encoded packet to the image.
          In the process, the buffered raw XMP packet is updated.
          In order to write directly from the raw XMP packet, use
          writeXmpFromPacket(true) or setXmpPacket().
         *//*!
          @brief Assign new XMP data. The new XMP data is not written
              to the image until the writeMetadata() method is called.

          Subsequent calls to writeMetadata() encode the XMP data to
          a raw XMP packet and write the newly encoded packet to the image.
          In the process, the buffered raw XMP packet is updated.
          In order to write directly from the raw XMP packet, use
          writeXmpFromPacket(true) or setXmpPacket().

          @param xmpData An XmpData instance holding XMP data to be copied
         *//*!
          @brief Erase the buffered XMP packet. XMP data is not removed from
              the actual image until the writeMetadata() method is called.

          This has the same effect as clearXmpData() but operates on the
          buffered raw XMP packet only, not the parsed XMP data.

          Subsequent calls to writeMetadata() write the XMP packet from
          the buffered raw XMP packet rather than from buffered parsed XMP
          data. In order to write from parsed XMP data again, use
          either writeXmpFromPacket(false) or setXmpData().
         *//*!
          @brief Assign a raw XMP packet. The new XMP packet is not written
              to the image until the writeMetadata() method is called.

          Subsequent calls to writeMetadata() write the XMP packet from
          the buffered raw XMP packet rather than from buffered parsed XMP
          data. In order to write from parsed XMP data again, use
          either writeXmpFromPacket(false) or setXmpData().

          @param xmpPacket A string containing the raw XMP packet.
         *//*!
          @brief Erase any buffered IPTC data. IPTC data is not removed from
              the actual image until the writeMetadata() method is called.
         *//*!
          @brief Assign new IPTC data. The new IPTC data is not written
              to the image until the writeMetadata() method is called.
          @param iptcData An IptcData instance holding IPTC data to be copied
         *//*!
          @brief Erase any buffered Exif data. Exif data is not removed from
              the actual image until the writeMetadata() method is called.
         *//*!
          @brief Assign new Exif data. The new Exif data is not written
              to the image until the writeMetadata() method is called.
          @param exifData An ExifData instance holding Exif data to be copied
         *//*!
          @brief Write metadata back to the image.

          All existing metadata sections in the image are either created,
          replaced, or erased. If values for a given metadata type have been
          assigned, a section for that metadata type will either be created or
          replaced. If no values have been assigned to a given metadata type,
          any exists section for that metadata type will be removed from the
          image.

          @throw Error if the operation fails
         *//*!
          @brief Read all metadata supported by a specific image format from the
              image. Before this method is called, the image metadata will be
              cleared.

          This method returns success even if no metadata is found in the
          image. Callers must therefore check the size of individual metadata
          types before accessing the data.

          @throw Error if opening or reading of the file fails or the image
              data is not valid (does not look like data of the specific image
              type).
         *//*!
          @brief Print out the structure of image file.
          @throw Error if reading of the file fails or the image data is
                not valid (does not look like data of the specific image type).
          @warning This function is not thread safe and intended for exiv2 -pS for debugging.
          @warning You may need to put the stream into binary mode (see src/actions.cpp)
         *///! Virtual Destructor/*!
          @brief Constructor taking the image type, a bitmap of the supported
              metadata types and an auto-pointer that owns an IO instance.
              See subclass constructor doc.
         *///! Image auto_ptr type/*!
      @brief Abstract base class defining the interface for an image. This is
         the top-level interface to the Exiv2 library.

      Image has containers to store image metadata and subclasses implement
      read and save metadata from and to specific image formats.<BR>
      Most client apps will obtain an Image instance by calling a static
      ImageFactory method. The Image class can then be used to to read, write,
      and save metadata.
     *//*!
      @brief Options for printStructure
     *///! List of native previews. This is meant to be used only by the PreviewManager.//!< MIME type//!< Filter//!< Height//!< Width//!< Size//!< Position//! Native preview information. This is meant to be used only by the PreviewManager.//!< Not an image//! Supported image formats/*!
  @file    image.hpp
 */supportedMetadatablobadvancemetadataIduseCurlbSwapoutdepthflagbTestValid/Users/owura/Repos/codeql_eval/proj_repos/Exiv2-exiv2-pull-962-commits-e925bc5addd881543fa503470c8a859e112cca62/exiv2/src/utils.hpp/Users/owura/Repos/codeql_eval/proj_repos/Exiv2-exiv2-pull-962-commits-e925bc5addd881543fa503470c8a859e112cca62/exiv2/samples/path-test.cpp"utils.hpp": Failed to open file for reading
": Failed to open file for reading\n"	'"\t'"'	 '"'\t '"'	 ==> Testcase failed
"'\t ==> Testcase failed\n"~basic_ifstreambasic_ifstream<char, char_traits<char>> *~basic_istringstreambasic_istringstream<char, char_traits<char>, allocator<char>> *// path-test.cppPreviewProperties &const PreviewPropertiesconst PreviewProperties &~PreviewPropertiesPreviewProperties *PreviewPropertiesPreviewManager &const PreviewManagerconst PreviewManager &PreviewManagergetPreviewImagegetPreviewPropertiesPreviewImageidheightextensionwriteFilePreviewImage &const PreviewImageconst PreviewImage &~PreviewImagePreviewPropertiesListPreviewIdid_extension_image_pData_properties_PREVIEW_HPP_// #ifndef PREVIEW_HPP_// class PreviewManager/*!
          @brief Return the preview image for the given preview properties.
         *//*!
          @brief Return the properties of all preview images in a list
                 sorted by preview width * height, starting with the smallest
                 preview image.
         *///! @name Constructors/*!
      @brief Class for extracting preview images from image metadata.
     */// class PreviewImage//!< Size of the preview image data//!< Pointer to the preview image data//!< Preview image properties//! Private constructor/*!
          @brief Return the preview image type identifier.
        *//*!
          @brief Return the height of the preview image in pixels.
        *//*!
          @brief Return the width of the preview image in pixels.
        *//*!
          @brief Like extension() but returns the unicode encoded extension in
                 an std::wstring.
          @note This function is only available on Windows.
         *//*!
          @brief Return the file extension for the format of the preview image
                 (".tif" or ".jpg").
         *//*!
          @brief Return the MIME type of the preview image, usually either
                 \c "image/tiff" or \c "image/jpeg".
         *//*!
          @brief Like writeFile() but accepts a unicode path in an std::wstring.
          @note This function is only available on Windows.
         *//*!
          @brief Write the thumbnail image to a file.

          A filename extension is appended to \em path according to the image
          type of the preview image, so \em path should not include an extension.
          The function will overwrite an existing file of the same name.

          @param path File name of the preview image without extension.
          @return The number of bytes written.
        *//*!
          @brief Return the size of the preview image in bytes.
         *//*!
          @brief Return a pointer to the image data for read-only access.
         *//*!
          @brief Return a copy of the preview image data. The caller owns
                 this copy and %DataBuf ensures that it will be deleted.
         *//*!
      @brief Class that holds preview image properties and data buffer.
     *///! Container type to hold all preview images metadata.//! Identifies type of preview image.//! Preview image height in pixels or 0 for unknown height.//! Preview image width in pixels or 0 for unknown width.//! Preview image size in bytes.//! Unicode preview image extension in an std::wstring//! Preview image extension.//! Preview image mime type./*!
      @brief Preview image properties.
     *///! Type of preview image./*!
  @file    preview.hpp
  @brief   Classes to access all preview images embedded in an image.
  @author  Vladimir Nadvornik (vn)
           <a href="mailto:nadvornik@suse.cz">nadvornik@suse.cz</a>
  @date    18-Sep-08, vn: created
 */properties/Users/owura/Repos/codeql_eval/proj_repos/Exiv2-exiv2-pull-962-commits-e925bc5addd881543fa503470c8a859e112cca62/exiv2/samples/prevtest.cpploaderconst __wrap_iter<PreviewProperties *>const __wrap_iter<PreviewProperties *> &__wrap_iter<PreviewProperties *> &preview preview, type " preview, type " bytes, " bytes, " pixels" pixels"_"_"const unsigned int &// Cleanup// Test access to preview images// prevtest.cpp__wrap_iter<PreviewProperties *> *const __wrap_iter<PreviewProperties *> *"slice.hpp"IntTypegcdstringTochar(&)[]T[]T(&)[]const T *T *Kconst Kconst K &K &floatToRationalCastparseRationalparseFloatparseLongexvGettextexifTimeisHexhexdumpd2Dataf2Datar2Datal2Datas2Dataur2Dataul2Dataus2DataURational &const URationalconst URational &Rational &getDoublegetFloatgetRationalgetLonggetShortgetURationalgetULongLonggetULonggetUShortconst Slice<T>const Slice<T> &Slice<T> &makeSlicetypeSizeTypeInfo &const TypeInfoconst TypeInfo &TypeInfooperator Exiv2::DataBufRefDataBufDataBufRefDataBufRef *(byte*)(0)long(0)freealloc~DataBufTypeIdunsignedByteasciiStringsignedBytetiffIfdunsignedLongLongsignedLongLongtiffIfd80x100000x100010x100020x100030x10004xmpText0x10005xmpAlt0x100060x10007xmpSeq0x10008langAlt0x10009invalidTypeId1310700x1fffelastTypeId1310710x1ffffBlobAccessModeamNoneamReadamWriteamReadWriteMetadataIdmdNonemdExifmdIptcmdCommentmdXmpmdIccProfileWriteMethodwmIntrusivewmNonIntrusiveByteOrderlittleEndianbigEndianRationalURationalbyteEXV_COUNTOF(a)(sizeof(Exiv2::sizer(a)))EXV_WARN_UNUSED_RESULT__attribute__ ((warn_unused_result))EXV_MAX(a,b)((a) > (b) ? (a) : (b))EXV_MIN(a,b)((a) < (b) ? (a) : (b))EXV_CALL_MEMBER_FN(object,ptrToMember)((object).*(ptrToMember))TYPES_HPP__MSC_VER >= _MSC_VER_2010EXV_HAVE_STDINT_Hdefined(__GNUC__) && (__GNUC__ >= 4) || defined(__clang__)defined(_MSC_VER) && (_MSC_VER >= 1700)warn_unused_result// #ifndef TYPES_HPP_// and we require it of user-defined types).// positive value (the standard guarantees this for built-in types,// As n and m are now positive, we can be sure that %= returns a// IntType may be a user-defined type).// lookup issues and other problems, I code this explicitly. (Remember,// This is abs() - given the existence of broken compilers with Koenig// Avoid repeated construction/*!
      @brief Return the greatest common denominator of n and m.
             (Implementation from Boost rational.hpp)

      @note We use n and m as temporaries in this function, so there is no
            value in using const IntType& as we would only need to make a copy
            anyway...
     *//*!
      @brief Specialization of stringTo(const std::string& s, bool& ok) for \em bool.

      Handles the same string values as the XMP SDK. Converts the string to lowercase
      and returns \c true if it is "true", "t" or "1", and \c false if it is
      "false", "f" or "0".
     *//*!
      @brief Utility function to convert a string to a value of type \c T.

      The string representation of the value must match that recognized by
      the input operator for \c T for this function to succeed.

      @param  s  String to convert
      @param  ok Output variable indicating the success of the operation.
      @return Returns the converted value and sets \em ok to \c true if the
              conversion was successful or \c false if not.
     *///! Utility function to convert the argument of any type to a string//! Macro to determine the size of an array//! Template used in the COUNTOF macro to determine the size of an array/*!
      @brief Find an element that matches \em key in the array \em src.

      Designed to be used with lookup tables as shown in the example below.
      Requires a %Key structure (ideally in the array) and a comparison operator
      to compare a key with an array element.  The size of the array is
      determined automagically. Thanks to Stephan Broennimann for this nifty
      implementation.

      @code
      struct Bar {
          int i;
          int k;
          const char* data;

          struct Key;
          bool operator==(const Bar::Key& rhs) const;
      };

      struct Bar::Key {
          Key(int a, int b) : i(a), k(b) {}
          int i;
          int k;
      };

      bool Bar::operator==(const Bar::Key& key) const // definition
      {
          return i == key.i && k == key.k;
      }

      const Bar bars[] = {
          { 1, 1, "bar data 1" },
          { 1, 2, "bar data 2" },
          { 1, 3, "bar data 3" }
      };

      int main ( void ) {
          const Bar* bar = find(bars, Bar::Key(1, 3));
          if (bar) std::cout << bar->data << "\n";
          else std::cout << "Key not found.\n";
          return 0;
      }
      @endcode
    */// template and inline definitions/*!
      @brief Very simple conversion of a \em float to a \em Rational.

      Test it with the values that you expect and check the implementation
      to see if this is really what you want!
     *//*!
      @brief Return a \em Rational set to the value represented by \em s.

      Besides strings that represent \em Rational values, the function also
      handles \em long, \em float and boolean
      (see also: stringTo(const std::string& s, bool& ok)).
      Uses floatToRationalCast(float f) if the string can be parsed into a
      \em float.

      @param  s  String to parse
      @param  ok Output variable indicating the success of the operation.
      @return Returns the \em Rational value represented by \em s and sets \em ok
              to \c true if the conversion was successful or \c false if not.
    *//*!
      @brief Return a \em float set to the value represented by \em s.

      Besides strings that represent \em float values, the function also
      handles \em long, \em Rational and boolean
      (see also: stringTo(const std::string& s, bool& ok)).

      @param  s  String to parse
      @param  ok Output variable indicating the success of the operation.
      @return Returns the \em float value represented by \em s and sets \em ok
              to \c true if the conversion was successful or \c false if not.
    *//*!
      @brief Return a \em long set to the value represented by \em s.

      Besides strings that represent \em long values, the function also
      handles \em float, \em Rational and boolean
      (see also: stringTo(const std::string& s, bool& ok)).

      @param  s  String to parse
      @param  ok Output variable indicating the success of the operation.
      @return Returns the \em long value represented by \em s and sets \em ok
              to \c true if the conversion was successful or \c false if not.
    *///! Convert a unicode std::wstring s to an std::string.//! Convert an std::string s to a unicode string returned as a std::wstring./*!
      @brief Translate a string using the gettext framework. This wrapper hides
             all the implementation details from the interface.
     *//*!
      @brief Converts a string in the form "%Y:%m:%d %H:%M:%S", e.g.,
             "2007:05:24 12:31:55" to broken down time format,
             returns 0 if successful, else 1.
     *//*!
      @brief Return true if str is a hex number starting with prefix followed
             by size hex digits, false otherwise. If size is 0, any number of
             digits is allowed and all are checked.
     *//*!
      @brief Print len bytes from buf in hex and ASCII format to the given
             stream, prefixed with the position in the buffer adjusted by
             offset.
     *//*!
      @brief Convert a double precision floating point (IEEE 754 binary64) double
             to data, write the data to the buffer, return number of bytes written.
     *//*!
      @brief Convert a single precision floating point (IEEE 754 binary32) float
             to data, write the data to the buffer, return number of bytes written.
     *//*!
      @brief Convert a signed rational to data, write the data to the buffer,
             return number of bytes written.
     *//*!
      @brief Convert a signed long to data, write the data to the buffer,
             return number of bytes written.
     *//*!
      @brief Convert a signed short to data, write the data to the buffer,
             return number of bytes written.
     *//*!
      @brief Convert an unsigned rational to data, write the data to the buffer,
             return number of bytes written.
     *//*!
      @brief Convert an unsigned long to data, write the data to the buffer,
             return number of bytes written.
     *//*!
      @brief Convert an unsigned short to data, write the data to the buffer,
             return number of bytes written.
     *///! Input operator for our fake unsigned rational//! Output operator for our fake unsigned rational//! Input operator for our fake rational//! Output operator for our fake rational//! Read an 8 byte double precision floating point value (IEEE 754 binary64) from the data buffer//! Read a 4 byte single precision floating point value (IEEE 754 binary32) from the data buffer//! Read an 8 byte signed rational value from the data buffer//! Read a 4 byte signed long value from the data buffer//! Read a 2 byte signed short value from the data buffer//! Read an 8 byte unsigned rational value from the data buffer//! Read a 8 byte unsigned long value from the data buffer//! Read a 4 byte unsigned long value from the data buffer//! Read a 2 byte unsigned short value from a Slice//! Read a 2 byte unsigned short value from the data buffer//! Overload of makeSlice for `const DataBuf`, returning an immutable Slice/*!
     * @brief Create a new Slice from a DataBuf given the bounds.
     *
     * @param[in] begin, end  Bounds of the new Slice. `begin` must be smaller
     *     than `end` and both must not be larger than LONG_MAX.
     * @param[in] buf  The DataBuf from which' data the Slice will be
     *     constructed
     *
     * @throw std::invalid_argument when `end` is larger than `LONG_MAX` or
     * anything that the constructor of @ref Slice throws
     */// class DataBuf/*!
          @name Conversions

          Special conversions with auxiliary type to enable copies
          and assignments, similar to those used for std::auto_ptr.
          See http://www.josuttis.com/libbook/auto_ptr.html for a discussion.
         *///! Reset value/*!
           @brief Free the internal buffer and reset the size to 0.
          *//*!
          @brief Release ownership of the buffer to the caller. Returns the
                 buffer as a data pointer and size pair, resets the internal
                 buffer.
         *//*!
          @brief Allocate a data buffer of at least the given size. Note that if
                 the requested \em size is less than the current buffer size, no
                 new memory is allocated and the buffer size doesn't change.
         *//*!
          @brief Assignment operator. Transfers the buffer and releases the
                 buffer at the original object similar to std::auto_ptr, i.e.,
                 the original object is modified.
         *///! Destructor, deletes the allocated buffer/*!
          @brief Copy constructor. Transfers the buffer to the newly created
                 object similar to std::auto_ptr, i.e., the original object is
                 modified.
         *///! Constructor, copies an existing buffer//! Constructor with an initial buffer size//! Default constructor/*!
      @brief Utility class containing a character array. All it does is to take
             care of memory allocation and deletion. Its primary use is meant to
             be as a stack variable in functions that need a temporary data
             buffer.
     *///! Pointer to a byte array and its size/*!
      @brief Auxiliary type to enable copies and assignments, similar to
             std::auto_ptr_ref. See http://www.josuttis.com/libbook/auto_ptr.html
             for a discussion.
     *///! Return the size in bytes of one element of this type//! Return the type id for a type name//! Return the name of the type, 0 if unknown.//! Type information lookup functions. Implemented as a static class.//! Container for binary data//!< Last type id.//!< Invalid type id.//!< XMP language alternative type.//!< XMP sequence type.//!< XMP bag type.//!< XMP alternative type.//!< XMP text type.//!< %Exiv2 type for a CIFF directory.//!< %Exiv2 type for the Exif user comment.//!< IPTC time type.//!< IPTC date type.//!< IPTC string type.//!< TIFF IFD type, 64-bit (8-byte) unsigned integer.//!< Exif LONG LONG type, 64-bit (8-byte) signed integer.//!< Exif LONG LONG type, 64-bit (8-byte) unsigned integer.//!< TIFF IFD type, 32-bit (4-byte) unsigned integer.//!< TIFF DOUBLE type, double precision (8-byte) IEEE format.//!< TIFF FLOAT type, single precision (4-byte) IEEE format.//!< Exif SRATIONAL type, two SLONGs: numerator and denumerator of a fraction.//!< Exif SLONG type, a 32-bit (4-byte) signed (twos-complement) integer.//!< Exif SSHORT type, a 16-bit (2-byte) signed (twos-complement) integer.//!< Exif UNDEFINED type, an 8-bit byte that may contain anything.//!< Exif SBYTE type, an 8-bit signed (twos-complement) integer.//!< Exif RATIONAL type, two LONGs: numerator and denumerator of a fraction.//!< Exif LONG type, 32-bit (4-byte) unsigned integer.//!< Exif SHORT type, 16-bit (2-byte) unsigned integer.//!< Exif ASCII type, 8-bit byte.//!< Exif BYTE type, 8-bit unsigned integer./*!
      @brief %Exiv2 value type identifiers.

      Used primarily as identifiers when creating %Exiv2 Value instances.
      See Value::create. 0x0000 to 0xffff are reserved for TIFF (Exif) types.
     *///! An identifier for each mode of metadata support//! An identifier for each type of metadata//! Type to indicate write method used by TIFF parsers//! Type to express the byte order (little or big endian)//! 8 byte signed rational type.//! 8 byte unsigned rational type.//! 1 byte unsigned integer type.// type definitions// forward declarations//! Simple common max macro//! Simple common min macro// Simple min and max macros/*!
  @brief Macro to make calls to member functions through a pointer more readable.
         See the C++ FAQ LITE, item
         <a href="http://www.parashift.com/c++-faq-lite/pointers-to-members.html#faq-33.5" title="[33.5] How can I avoid syntax errors when calling a member function using a pointer-to-member-function?">[33.5] How can I avoid syntax errors when calling a member function using a pointer-to-member-function?</a>.
 */// MSVC macro to convert a string to a wide string// Earlier compilers have MS C99 equivalents such as __int8// Visual Studio 2010 and later has stdint.h/*!
  @file    types.hpp
  @brief   Type definitions for %Exiv2 and related functionality
  @author  Andreas Huggel (ahu)
           <a href="mailto:ahuggel@gmx.net">ahuggel@gmx.net</a>
  @date    09-Jan-04, ahu: created<BR>
           11-Feb-04, ahu: isolated as a component<BR>
           31-Jul-04, brad: added Time, Data and String values
 */prefix"value.hpp"setValuecmpMetadataByKeycmpMetadataByTagKey *const Key *~Key~MetadatumMetadatumMETADATUM_HPP_// #ifndef METADATUM_HPP_/*!
      @brief Compare two metadata by key. Return true if the key of metadatum
             lhs is less than that of rhs.
     *//*!
      @brief Compare two metadata by tag. Return true if the tag of metadatum
             lhs is less than that of rhs.
     *//*!
      @brief Output operator for Metadatum types, writing the interpreted
             tag value.
     */// class Metadatum/*!
          @brief Return a constant reference to the value.

          This method is provided mostly for convenient and versatile output of
          the value which can (to some extent) be formatted through standard
          stream manipulators.  Do not attempt to write to the value through
          this reference. An Error is thrown if the value is not set; as an
          alternative to catching it, one can use count() to check if there
          is any data before calling this method.

          @return A constant reference to the value.
          @throw Error if the value is not set.
         *//*!
          @brief Return an auto-pointer to a copy (clone) of the value. The
                 caller owns this copy and the auto-poiner ensures that it will
                 be deleted.

          This method is provided for users who need full control over the
          value. A caller may, e.g., downcast the pointer to the appropriate
          subclass of Value to make use of the interface of the subclass to set
          or modify its contents.

          @return An auto-pointer containing a pointer to a copy (clone) of the
                  value, 0 if the value is not set.
         *//*!
          @brief Return the <EM>n</EM>-th component of the value converted to Rational.
                 The return value is -1/1 if the value is not set and the behaviour
                 of the method is undefined if there is no <EM>n</EM>-th component.
         *//*!
          @brief Return the <EM>n</EM>-th component of the value converted to float.
                 The return value is -1 if the value is not set and the behaviour
                 of the method is undefined if there is no <EM>n</EM>-th component.
         *//*!
          @brief Return the <EM>n</EM>-th component of the value converted to long.
                 The return value is -1 if the value is not set and the behaviour
                 of the method is undefined if there is no <EM>n</EM>-th component.
         *//*!
          @brief Return the <EM>n</EM>-th component of the value converted to
                 a string. The behaviour of the method is undefined if there
                 is no <EM>n</EM>-th component.
         *///! Return the value as a string.//! Return the number of components in the value//! Return the size in bytes of one component of this type//! Return the name of the type//! Return the type id of the value//! Return the tag//! Return a label for the tag//! Return the name of the tag (which is also the third part of the key)//! Return the name of the metadata group (which is also the second part of the key)//! Return the name of the metadata family (which is also the first part of the key)/*!
          @brief Return the key of the metadatum. The key is of the form
                 'familyName.groupName.tagName'. Note however that the key
                 is not necessarily unique, e.g., an ExifData object may
                 contain multiple metadata with the same key.
         *//*!
          @brief Write the interpreted value to an output stream, return
                 the stream.

          The method takes an optional pointer to a metadata container.
          Pretty-print functions may use that to refer to other metadata as it
          is sometimes not sufficient to know only the value of the metadatum
          that should be interpreted. Thus, it is advisable to always call this
          method with a pointer to the metadata container if possible.

          This functionality is currently only implemented for Exif tags.
          The pointer is ignored when used to write IPTC datasets or XMP
          properties.

          Without the optional metadata pointer, you do not usually have to use
          this function; it is used for the implementation of the output
          operator for %Metadatum,
          operator<<(std::ostream &os, const Metadatum &md).

          See also print(), which prints the interpreted value to a string.
         *//*!
          @brief Write value to a data buffer and return the number
                 of bytes written.

          The user must ensure that the buffer has enough memory. Otherwise
          the call results in undefined behaviour.

          @param buf Data buffer to write to.
          @param byteOrder Applicable byte order (little or big endian).
          @return Number of characters written.
        *//*!
          @brief Write the interpreted value to a string.

          Implemented in terms of write(), see there.
         *//*!
          @brief Set the value to the string buf.
                 Uses Value::read(const std::string& buf). If the metadatum does
                 not have a value yet, then one is created. See subclasses for
                 more details. Return 0 if the value was read successfully.
         *//*!
          @brief Set the value. This method copies (clones) the value pointed
                 to by pValue.
         *///! Default Constructor/*!
      @brief Abstract base class defining the interface to access information
             related to one metadata tag.
     *///! Output operator for Key types// class Key/*!
          @brief Write the key to an output stream. You do not usually have
                 to use this function; it is used for the implementation of
                 the output operator for %Key,
                 operator<<(std::ostream &os, const Key &key).
        *//*!
          @brief Return an auto-pointer to a copy of itself (deep copy).
                 The caller owns this copy and the auto-pointer ensures that it
                 will be deleted.
         *///! Return the tag number//! Return the name of the group (the second part of the key)//! Return an identifier for the type of metadata (the first part of the key)/*!
          @brief Return the key of the metadatum as a string. The key is of the
                 form 'familyName.groupName.tagName'. Note however that the
                 key is not necessarily unique, e.g., an ExifData may contain
                 multiple metadata with the same key.
         *///! Shortcut for a %Key auto pointer./*!
      @brief Abstract base class defining the %Key of a metadatum.
             Keys are used to identify and group metadata.
    */// class declarations/*!
  @file    metadatum.hpp
  @brief   Provides abstract base classes Metadatum and Key
  @author  Andreas Huggel (ahu)
           <a href="mailto:ahuggel@gmx.net">ahuggel@gmx.net</a>
  @author  Brad Schick (brad)
           <a href="mailto:brad@robotbattle.com">brad@robotbattle.com</a>
  @date    09-Jan-04, ahu: created<BR>
           31-Jul-04, brad: isolated as a component<BR>
           23-Aug-04, ahu: added Key
 */lhspMetadatapValue<list>"tags.hpp"ExifParser &const ExifParserconst ExifParser &encodedecodeExifThumb &const ExifThumbconst ExifThumb &ExifThumbsetJpegThumbnailExifThumbC &const ExifThumbCconst ExifThumbC &ExifThumbCidxifdNameifdIdconst int16_tconst int16_t &const uint32_tconst uint32_t &const Exifdatum &~ExifdatumExifdatumfindKeysortByTagsortByKeyaddExifParserExifMetadataexifMetadata_EXIF_HPP_// #ifndef EXIF_HPP_// class ExifParser/*!
          @brief Encode metadata from the provided metadata to Exif format.

          Encode Exif metadata from the \em ExifData container to binary Exif
          format in the \em blob, encoded in \em byteOrder.

          This simpler encode method uses "intrusive" writing, i.e., it builds
          the binary representation of the metadata from scratch. It does not
          attempt "non-intrusive", i.e., in-place updating. It's better to use
          the other encode() method, if the metadata is already available in
          binary format, in order to allow for "non-intrusive" updating of the
          existing binary representation.

          This is just an inline wrapper for
          ExifParser::encode(blob, 0, 0, byteOrder, exifData).

          @param blob      Container for the binary Exif data.
          @param byteOrder Byte order to use.
          @param exifData  Exif metadata container.
        *//*!
          @brief Encode Exif metadata from the provided metadata to binary Exif
                 format.

          The original binary Exif data in the memory block \em pData, \em size
          is parsed and updated in-place if possible ("non-intrusive"
          writing). If that is not possible (e.g., if new tags were added), the
          entire Exif structure is re-written to the \em blob ("intrusive"
          writing). The return value indicates which write method was used. If
          it is \c wmNonIntrusive, the original memory \em pData, \em size
          contains the result and \em blob is empty. If the return value is
          \c wmIntrusive, a new Exif structure was created and returned in
          \em blob. The memory block \em pData, \em size may be partly updated in
          this case and should not be used anymore.

          Encode is a lossy operation. It attempts to fit the Exif data into a
          binary block suitable as the payload of a JPEG APP1 Exif segment,
          which can be at most 65527 bytes large. Encode omits IFD0 tags that
          are "not recorded" in compressed images according to the Exif 2.2
          specification. It also doesn't write tags in groups which do not occur
          in JPEG images. If the resulting binary block is larger than allowed,
          it further deletes specific large preview tags, unknown tags larger
          than 4kB and known tags larger than 40kB. The operation succeeds even
          if the end result is still larger than the allowed size. Application
          should therefore always check the size of the \em blob.

          @param blob      Container for the binary Exif data if "intrusive"
                           writing is necessary. Empty otherwise.
          @param pData     Pointer to the binary Exif data buffer. Must
                           point to data in Exif format; no checks are
                           performed. Will be modified if "non-intrusive"
                           writing is possible.
          @param size      Length of the data buffer.
          @param byteOrder Byte order to use.
          @param exifData  Exif metadata container.

          @return Write method used.
        *//*!
          @brief Decode metadata from a buffer \em pData of length \em size
                 with binary Exif data to the provided metadata container.

                 The buffer must start with a TIFF header. Return byte order
                 in which the data is encoded.

          @param exifData Exif metadata container.
          @param pData 	  Pointer to the data buffer. Must point to data in
                          binary Exif format; no checks are performed.
          @param size 	  Length of the data buffer
          @return Byte order in which the data is encoded.
        *//*!
      @brief Stateless parser class for Exif data. Images use this class to
             decode and encode binary Exif data.

      @note  Encode is lossy and is not the inverse of decode.
     */// class ExifData//! Get the number of metadata entries//! Return true if there is no Exif metadata/*!
          @brief Find the first Exifdatum with the given \em key, return a const
                 iterator to it.
         *///! End of the metadata//! Begin of the metadata/*!
          @brief Find the first Exifdatum with the given \em key, return an
                 iterator to it.
         *///! Sort metadata by tag//! Sort metadata by key/*!
          @brief Delete all Exifdatum instances resulting in an empty container.
                 Note that this also removes thumbnails.
         *//*!
          @brief Remove all elements of the range \em beg, \em end, return the
                 position of the next element. Note that iterators into
                 the metadata are potentially invalidated by this call.
         *//*!
          @brief Delete the Exifdatum at iterator position \em pos, return the
                 position of the next exifdatum. Note that iterators into
                 the metadata, including \em pos, are potentially invalidated
                 by this call.
         *//*!
          @brief Add a copy of the \em exifdatum to the Exif metadata.  No
                 duplicate checks are performed, i.e., it is possible to add
                 multiple metadata with the same key.

          @throw Error if the makernote cannot be created
         *//*!
          @brief Add an Exifdatum from the supplied key and value pair.  This
                 method copies (clones) key and value. No duplicate checks are
                 performed, i.e., it is possible to add multiple metadata with
                 the same key.
         *//*!
          @brief Returns a reference to the %Exifdatum that is associated with a
                 particular \em key. If %ExifData does not already contain such
                 an %Exifdatum, operator[] adds object \em Exifdatum(key).

          @note  Since operator[] might insert a new element, it can't be a const
                 member function.
         *///! ExifMetadata const iterator type//! ExifMetadata iterator type/*!
      @brief A container for Exif data.  This is a top-level class of the %Exiv2
             library. The container holds Exifdatum objects.

      Provide high-level access to the Exif data of an image:
      - read Exif information from JPEG files
      - access metadata through keys and standard C++ iterators
      - add, modify and delete metadata
      - write Exif data to JPEG files
      - extract Exif metadata to files, insert from these files
      - extract and delete Exif thumbnail (JPEG and TIFF thumbnails)
    *///! Container type to hold all metadata// class ExifThumb//!< Reference to the related Exif metadata./*!
          @brief Delete the thumbnail from the Exif data. Removes all
                 Exif.%Thumbnail.*, i.e., Exif IFD1 tags.
         *//*!
          @brief Set the Exif thumbnail to the JPEG image pointed to by \em buf,
                 and size \em size.

          This sets only the Compression, JPEGInterchangeFormat and
          JPEGInterchangeFormatLength tags, which is not all the thumbnail
          Exif information mandatory according to the Exif standard. (But it's
          enough to work with the thumbnail.)

          @note  No checks on the image format or size are performed.
          @note  Additional existing Exif thumbnail tags are not modified.
         *//*!
          @brief Like setJpegThumbnail(const std::string& path) but accepts a
                 unicode path in an std::wstring.
          @note This function is only available on Windows.
         *//*!
          @brief Set the Exif thumbnail to the JPEG image \em path.

          This sets only the Compression, JPEGInterchangeFormat and
          JPEGInterchangeFormatLength tags, which is not all the thumbnail
          Exif information mandatory according to the Exif standard. (But it's
          enough to work with the thumbnail.)

          @throw Error if reading the file fails.

          @note  No checks on the file format or size are performed.
          @note  Additional existing Exif thumbnail tags are not modified.
         *//*!
          @brief Set the Exif thumbnail to the JPEG image pointed to by \em buf,
                 and size \em size. Set XResolution, YResolution and
                 ResolutionUnit to \em xres, \em yres and \em unit, respectively.

          This results in the minimal thumbnail tags being set for a JPEG
          thumbnail, as mandated by the Exif standard.

          @throw Error if reading the file fails.

          @note  No checks on the image format or size are performed.
          @note  Additional existing Exif thumbnail tags are not modified.
          @note  The JPEG image inserted as thumbnail image should not
                 itself contain Exif data (or other metadata), as existing
                 applications may have problems with that. (The preview
                 application that comes with OS X for one.) - David Harvey.
         *//*!
          @brief Like setJpegThumbnail() but accepts a unicode path in an
                 std::wstring.
          @note This function is only available on Windows.
         *//*!
          @brief Set the Exif thumbnail to the JPEG image \em path. Set
                 XResolution, YResolution and ResolutionUnit to \em xres,
                 \em yres and \em unit, respectively.

          This results in the minimal thumbnail tags being set for a JPEG
          thumbnail, as mandated by the Exif standard.

          @throw Error if reading the file fails.

          @note  No checks on the file format or size are performed.
          @note  Additional existing Exif thumbnail tags are not modified.
          @note  The JPEG image inserted as thumbnail image should not
                 itself contain Exif data (or other metadata), as existing
                 applications may have problems with that. (The preview
                 application that comes with OS X for one.) - David Harvey.
         *//*!
      @brief Access and modify an Exif %thumbnail image. This class implements
             manipulators to set and erase the thumbnail image that is optionally
             embedded in IFD1 of the Exif data. Accessors are provided by the
             base class, ExifThumbC.

      @note Various other preview and thumbnail images may be contained in an
            image, depending on its format and the camera make and model. This
            class only provides access to the Exif thumbnail as specified in the
            Exif standard.
     *///!< Const reference to the Exif metadata./*!
          @brief Like extension() but returns the extension in a wchar_t.
          @note This function is only available on Windows.
         *//*!
          @brief Return the file extension for the format of the thumbnail
                 (".tif" or ".jpg").
         *//*!
          @brief Return the MIME type of the thumbnail, either \c "image/tiff"
                 or \c "image/jpeg".
         *//*!
          @brief Write the thumbnail image to a file.

          A filename extension is appended to \em path according to the image
          type of the thumbnail, so \em path should not include an extension.
          The function will overwrite an existing file of the same name.

          @param path File name of the thumbnail without extension.
          @return The number of bytes written.
        *//*!
          @brief Return the thumbnail image in a %DataBuf. The caller owns the
                 data buffer and %DataBuf ensures that it will be deleted.
         *//*!
      @brief Access to a Exif %thumbnail image. This class provides higher level
             accessors to the thumbnail image that is optionally embedded in IFD1
             of the Exif data. These methods do not write to the Exif metadata.
             Manipulators are provided in subclass ExifThumb.

      @note Various other preview and thumbnail images may be contained in an
            image, depending on its format and the camera make and model. This
            class only provides access to the Exif thumbnail as specified in the
            Exif standard.
     */// class Exifdatum//!< Value/*!
          @brief Return a copy of the data area of the value. The caller owns
                 this copy and %DataBuf ensures that it will be deleted.

          Values may have a data area, which can contain additional
          information besides the actual value. This method is used to access
          such a data area.

          @return A %DataBuf containing a copy of the data area or an empty
                  %DataBuf if the value does not have a data area assigned or the
                  value is not set.
         *///! Return the index (unique id of this key within the original IFD)//! Return the name of the IFD//! Return the IFD id as an integer. (Do not use, this is meant for library internal use.)//! Return the key of the %Exifdatum./*!
          @brief Set the data area by copying (cloning) the buffer pointed to
                 by \em buf.

          Values may have a data area, which can contain additional
          information besides the actual value. This method is used to set such
          a data area.

          @param buf Pointer to the source data area
          @param len Size of the data area
          @return Return -1 if the %Exifdatum does not have a value yet or the
                  value has no data area, else 0.
         *//*!
          @brief Set the value to the string \em value.  Uses Value::read(const
                 std::string&).  If the %Exifdatum does not have a Value yet,
                 then a %Value of the correct type for this %Exifdatum is
                 created. An AsciiValue is created for unknown tags. Return
                 0 if the value was read successfully.
         *//*!
          @brief Assign \em value to the %Exifdatum.
                 Calls setValue(const Value*).
         *//*!
          @brief Assign \em value to the %Exifdatum.
                 Calls setValue(const std::string&).
         *//*!
          @brief Assign \em value to the %Exifdatum. The type of the new Value
                 is set to RationalValue.
         *//*!
          @brief Assign \em value to the %Exifdatum. The type of the new Value
                 is set to LongValue.
         *//*!
          @brief Assign \em value to the %Exifdatum. The type of the new Value
                 is set to ShortValue.
         *//*!
          @brief Assign \em value to the %Exifdatum. The type of the new Value
                 is set to URationalValue.
         *//*!
          @brief Assign \em value to the %Exifdatum. The type of the new Value
                 is set to ULongValue.
         *//*!
          @brief Assign \em value to the %Exifdatum. The type of the new Value
                 is set to UShortValue.
         *//*!
          @brief Constructor for new tags created by an application. The
                 %Exifdatum is created from a \em key / value pair. %Exifdatum copies
                 (clones) the \em key and value if one is provided. Alternatively,
                 a program can create an 'empty' %Exifdatum with only a key
                 and set the value using setValue().

          @param key %ExifKey.
          @param pValue Pointer to an %Exifdatum value.
          @throw Error if the key cannot be parsed and converted.
         *//*!
      @brief An Exif metadatum, consisting of an ExifKey and a Value and
             methods to manipulate these.
     *//*!
  @brief Provides classes and functions to encode and decode Exif and Iptc data.
         The <b>libexiv2</b> API consists of the objects of this namespace.
 *//*!
  @file    exif.hpp
  @brief   Encoding and decoding of Exif data
  @author  Andreas Huggel (ahu)
           <a href="mailto:ahuggel@gmx.net">ahuggel@gmx.net</a>
  @date    09-Jan-04, ahu: created
 */begexifdatumxresyresunit"exv_conf.h"dumpLibraryInfotestVersionversionNumberHexStringversionStringversionNumberexv_grep_keys_tEXIV2_TEST_VERSION(major,minor,patch)( EXIV2_VERSION >= EXIV2_MAKE_VERSION(major,minor,patch) )EXIV2_VERSIONEXIV2_MAKE_VERSION(EXIV2_MAJOR_VERSION,EXIV2_MINOR_VERSION,EXIV2_PATCH_VERSION)EXIV2_MAKE_VERSION(major,minor,patch)(((major) << 16) | ((minor) << 8) | (patch))VERSION_HPP_defined(EXV_HAVE_REGEX_H)// VERSION_HPP_/*!
      @brief dumpLibraryInfo implements the exiv2 option --version --verbose
             used by exiv2 test suite to inspect libraries loaded at run-time
     *//*!
      @brief Test the version of the available %Exiv2 library at runtime. Return
             true if it is the same as or newer than the passed-in version.

      Versions are denoted using a triplet of integers: \em major.minor.patch .
      The fourth version number is designated a "tweak" an used by Release Candidates
    *//*!
      @brief Return the version of %Exiv2 as "C" string eg "0.27.0.2".
    *//*!
      @brief Return the version of %Exiv2 as hex string of fixed length 6.
    *//*!
      @brief Return the version string Example: "0.25.0" (major.minor.patch)
    *//*!
      @brief Return the version of %Exiv2 available at runtime as an integer.
    *//*!
  @brief Macro to test the version the %Exiv2 library at compile-time.
         Return true if it is the same as or newer than the passed-in version.

  Versions prior to v0.27 are denoted using a triplet of integers: \em MAJOR.MINOR.PATCH .
  From v0.27 forward, the fourth digit is a "tweak" and designates the pre-release number of the version.

  @code
  // Application code is expected to include <exiv2/exiv2.hpp>
  // Don't include the <exiv2/version.hpp> file directly
  // Early Exiv2 versions didn't have version.hpp and the macros.

  #include <exiv2/exiv2.hpp>

  // Make sure an EXIV2_TEST_VERSION macro exists:
  #ifdef EXIV2_VERSION
  # ifndef EXIV2_TEST_VERSION
  # define EXIV2_TEST_VERSION(major,minor,patch) \
      ( EXIV2_VERSION >= EXIV2_MAKE_VERSION(major,minor,patch) )
  # endif
  #else
  # define EXIV2_TEST_VERSION(major,minor,patch) (false)
  #endif

  std::cout << "Compiled with Exiv2 version " << EXV_PACKAGE_VERSION << "\n"
            << "Runtime Exiv2 version is    " << Exiv2::version()    << "\n";

  // Test the Exiv2 version available at runtime but compile the if-clause only if
  // the compile-time version is at least 0.15. Earlier versions didn't have a
  // testVersion() function:

  #if EXIV2_TEST_VERSION(0,15,0)
  if (Exiv2::testVersion(0,13,0)) {
      std::cout << "Available Exiv2 version is equal to or greater than 0.13\n";
  }
  else {
      std::cout << "Installed Exiv2 version is less than 0.13\n";
  }
  #else
  std::cout << "Compile-time Exiv2 version doesn't have Exiv2::testVersion()\n";
  #endif
  @endcode
 *//*!
  @brief The %Exiv2 version number of the library used at compile-time as
         an integer number for easy comparison.
 *//*!
  @brief Make an integer version number for comparison from a major, minor and
         a patch version number.
 *//*!
   @brief exv_grep_keys_t is a vector of keys to match to strings
  *///! should we ignore cast in the match?//! simple string to match/*!
    @brief Exiv2_grep_key_t constructor
    *//*!
   @brief exv_grep_key_t is a simple string and the ignore flag
  *//*!
  @file    version.hpp
  @brief   Precompiler define and a function to test the %Exiv2 version.
           References: Similar versioning defines are used in KDE, GTK and other
           libraries. See http://apr.apache.org/versioning.html for accompanying
           guidelines.
  @author  Andreas Huggel (ahu)
           <a href="mailto:ahuggel@gmx.net">ahuggel@gmx.net</a>
  @date    31-May-06, ahu: created
 */patch/Users/owura/Repos/codeql_eval/proj_repos/Exiv2-exiv2-pull-962-commits-e925bc5addd881543fa503470c8a859e112cca62/exiv2/samples/remotetest.cppwriteTest.get() != 0readTest.get() != 0useCurlFromExiv2TestAppswriteTestreadTestexifReadData file {--nocurl | --curl}

" file {--nocurl | --curl}\n\n"--nocurl"--nocurl"--curl"--curl"Modify the metadata ...
"Modify the metadata ...\n"Hello World"Hello World"Exif.Image.Software"Exif.Image.Software""Exiv2"Exif.Image.Copyright"Exif.Image.Copyright"Exif.Image.Make"Exif.Image.Make"Canon"Canon"Exif.Canon.OwnerName"Exif.Canon.OwnerName"Tuan"Tuan"Exif.CanonCs.LensType"Exif.CanonCs.LensType"uint16_t(65535)2013:06:09 14:30:30"2013:06:09 14:30:30"Print out the new metadata ...
"Print out the new metadata ...\n"Reset ...
"Reset ...\n"Have a nice day"Have a nice day"Exiv2.org"Exiv2.org"Exif.Image.Make not found"Exif.Image.Make not found"const char(&)[26]char(&)[26]Exif.Image.DateTime not found"Exif.Image.DateTime not found"const char(&)[30]char(&)[30]Exif.Canon.OwnerName not found"Exif.Canon.OwnerName not found"const char(&)[31]char(&)[31]Exif.CanonCs.LensType not found"Exif.CanonCs.LensType not found"const char(&)[32]char(&)[32]// del, reset the metadata// read the result to make sure everything fine// set/add metadata// and reset the metadata back to the original status.// It makes some modifications on the metadata of remote file, reads new metadata from that file// Tester application for testing remote i/o.// remotetest.cpp/Users/owura/Repos/codeql_eval/proj_repos/Exiv2-exiv2-pull-962-commits-e925bc5addd881543fa503470c8a859e112cca62/exiv2/samples/stringto-test.cpp"string""long""float""Rational"testcaseschar(&)[23]const char *[23]char *[23]const char *(&)[23]char *(&)[23]..(*)(..))[23]EXV_COUNTOF(testcases)nok"nok""/"True"True"False"False""t""f""-1""0.0"0.1"0.1"0.01"0.01"0.001"0.001"-1.49999"-1.49999"-1.5"-1.5"1.49999"1.49999"1.5"1.5"0/1"0/1"1/1"1/1"1/3"1/3"-1/3"-1/3"4/3"4/3"-4/3"-4/3"0/0"0/0"text"text"// nok// Rational// float// long// bool// Test conversions from string to long, float and Rational types.// stringto-test.cpp/Users/owura/Repos/codeql_eval/proj_repos/Exiv2-exiv2-pull-962-commits-e925bc5addd881543fa503470c8a859e112cca62/exiv2/samples/taglist.cppitemGroups"Groups"const GroupInfoconst GroupInfo *GroupInfo *groupListIptc"Iptc"--group"--group"warning:"warning:" is not a valid Exif group name " is not a valid Exif group name "const TagInfoconst TagInfo *TagInfo *tagInfo [--group name|Groups|Exif|Canon|CanonCs|CanonSi|CanonCf|Fujifilm|Minolta|Nikon1|Nikon2|Nikon3|Olympus|Panasonic|Pentax|Sigma|Sony|Iptc" [--group "
                         "name|Groups|Exif|Canon|CanonCs|CanonSi|CanonCf|Fujifilm|Minolta|Nikon1|Nikon2|Nikon3|Olympus|"
                         "Panasonic|Pentax|Sigma|Sony|Iptc"const char[136]char[136]|dc|xmp|xmpRights|xmpMM|xmpBJ|xmpTPg|xmpDM|pdf|photoshop|crs|tiff|exif|aux|iptc]
"|dc|xmp|xmpRights|xmpMM|xmpBJ|xmpTPg|xmpDM|pdf|photoshop|crs|tiff|exif|aux|iptc]\n"const char[82]char[82]Print Exif tags, MakerNote tags, or Iptc datasets
"Print Exif tags, MakerNote tags, or Iptc datasets\n"// result is good// assume unhappy ending!/*
                    https://cgit.kde.org/digikam.git/tree/core/libs/dmetadata/metaengine_exif.cpp#n1077
                    const Exiv2::GroupInfo* gi = Exiv2::ExifTags::groupList();

                    while (gi->tagList_ != 0)
                    {
                       // NOTE: See BUG #375809 : MPF tags = exception Exiv2 0.26

                       if (QLatin1String(gi->ifdName_) != QLatin1String("Makernote"))
                       {
                           Exiv2::TagListFct tl     = gi->tagList_;
                           const Exiv2::TagInfo* ti = tl();

                           while (ti->tag_ != 0xFFFF)
                           {
                               tags << ti;
                               ++ti;
                           }
                       }

                       ++gi;
                    }
                   *//*
  Abstract:  Print a simple comma separated list of tags defined in Exiv2

  File:      taglist.cpp
  Author(s): Andreas Huggel (ahu) <ahuggel@gmx.net>
  History:   07-Jan-04, ahu: created
 *//Users/owura/Repos/codeql_eval/proj_repos/Exiv2-exiv2-pull-962-commits-e925bc5addd881543fa503470c8a859e112cca62/exiv2/src/enforce.hppenforceUconst Uconst U &U &Vconst Vconst V &V &exception_t/*!
 * @brief Ensure that condition is true, otherwise throw an Exiv2::Error with
 * the given error_code, arg1, arg2 & arg3.
 *//*!
 * @brief Ensure that condition is true, otherwise throw an Exiv2::Error with
 * the given error_code, arg1 & arg2.
 *//*!
 * @brief Ensure that condition is true, otherwise throw an Exiv2::Error with
 * the given error_code & arg1.
 *//*!
 * @brief Ensure that condition is true, otherwise throw an Exiv2::Error with
 * the given error_code.
 *//*!
 * @brief Ensure that condition is true, otherwise throw an exception of the
 * type exception_t
 *
 * @tparam exception_t  Exception type that is thrown, must provide a
 * constructor that accepts a single argument to which arg1 is forwarded.
 *
 * @todo once we have C++>=11 use variadic templates and std::forward to remove
 * all overloads of enforce
 *//*!
  @file    enforce.hpp
  @brief   Port of D's enforce() to C++ & Exiv2
  @author  Dan ermk (D4N)
           <a href="mailto:dan.cermak@cgc-instruments.com">dan.cermak@cgc-instruments.com</a>
  @date    11-March-18, D4N: created
 */// ********************************************************* -*- C++ -*-conditionerr_code/Users/owura/Repos/codeql_eval/proj_repos/Exiv2-exiv2-pull-962-commits-e925bc5addd881543fa503470c8a859e112cca62/exiv2/samples/tiff-test.cpp<enforce.hpp>No Exif data found in the file"No Exif data found in the file"mini9tiffImageMIME type:  "MIME type:  "const TiffImageImage size: "Image size: " x " x "Before
"Before\n"======
"======\n"Yesterday at noon"Yesterday at noon"After
"After\n"~TiffImageTiffImage *mini1wmconst char(&)[36]char(&)[36]encode returned an unexpected value"encode returned an unexpected value"blob.size() == 0Test 1: Writing empty Exif data without original binary data: ok.
"Test 1: Writing empty Exif data without original binary data: ok.\n"const char[67]char[67]Test 2: Writing empty Exif data with original binary data: ok.
"Test 2: Writing empty Exif data with original binary data: ok.\n"Test 3: Wrote non-empty Exif data without original binary data:
"Test 3: Wrote non-empty Exif data without original binary data:\n"boconst vector<unsigned char, allocator<unsigned char>>decode returned an unexpected value"decode returned an unexpected value"// Write something to a new structure, without a previous binary image// Write nothing, this time with a previous binary image// Write nothing to a new structure, without a previous binary image// First and very simple TIFF write test.// tiff-test.cpp/Users/owura/Repos/codeql_eval/proj_repos/Exiv2-exiv2-pull-962-commits-e925bc5addd881543fa503470c8a859e112cca62/exiv2/samples/werror-test.cppExiv2::kerGeneralErrorARG1"ARG1"const char(&)[5]char(&)[5]ARG2"ARG2"ARG3"ARG3"const Errorconst Error &Caught Error '"Caught Error '"// Simple tests for the wide-string error class WError// werror-test.cpp/Users/owura/Repos/codeql_eval/proj_repos/Exiv2-exiv2-pull-962-commits-e925bc5addd881543fa503470c8a859e112cca62/exiv2/samples/write-test.cppexifPrinttestCaseimage1image1.get() != 0---> Reading file "---> Reading file "---> Modifying Exif data
"---> Modifying Exif data\n"Metadatum with key = "Metadatum with key = " not found" not found"image2image2.get() != 0---> Writing Exif data to file "---> Writing Exif data to file "---> Writing Exif thumbnail to file "---> Writing Exif thumbnail to file ".*
".*\n"et2testFileisstestNoUsage: write-test file case

"Usage: write-test file case\n\n"where case is an integer between 1 and 11
"where case is an integer between 1 and 11\n"Case 1: "Case 1: "Non-intrusive change to the standard Exif metadata
"Non-intrusive change to the standard Exif metadata\n"const char[52]char[52]test1.jpg"test1.jpg"thumb1"thumb1"1999:11:22 00:11:22"1999:11:22 00:11:22"Case 2: "Case 2: "Non-intrusive change to the makernote metadata
"Non-intrusive change to the makernote metadata\n"test2.jpg"test2.jpg"thumb2"thumb2"Chan YeeSend"Chan YeeSend"Case 3: "Case 3: "Non-intrusive change to the Exif metadata (w/o makernote)
"Non-intrusive change to the Exif metadata (w/o makernote)\n"test3.jpg"test3.jpg"thumb3"thumb3"Case 4: "Case 4: "Intrusive change to the standard Exif metadata
"Intrusive change to the standard Exif metadata\n"test4.jpg"test4.jpg"thumb4"thumb4"1999:11:22 00:11:22 and twenty seconds"1999:11:22 00:11:22 and twenty seconds"Case 5: "Case 5: "Intrusive change to the Canon makernote metadata
"Intrusive change to the Canon makernote metadata\n"test5.jpg"test5.jpg"thumb5"thumb5"Frau Chan YeeSend und Herr Andreas Huggel"Frau Chan YeeSend und Herr Andreas Huggel"Case 6: "Case 6: "Intrusive change to the Exif metadata (w/o makernote)
"Intrusive change to the Exif metadata (w/o makernote)\n"const char[55]char[55]test6.jpg"test6.jpg"thumb6"thumb6"Case 7: "Case 7: "Intrusive change to the Fujifilm makernote metadata
"Intrusive change to the Fujifilm makernote metadata\n"test7.jpg"test7.jpg"thumb7"thumb7"Exif.Fujifilm.Quality"Exif.Fujifilm.Quality"Typical Fujifilm Quality"Typical Fujifilm Quality"Case 8: "Case 8: "Intrusive change to the Sigma makernote metadata
"Intrusive change to the Sigma makernote metadata\n"test8.jpg"test8.jpg"thumb8"thumb8"Exif.Sigma.ResolutionMode"Exif.Sigma.ResolutionMode"Sigma HI resolution"Sigma HI resolution"Case 9: "Case 9: "Intrusive change to the Nikon1 makernote metadata
"Intrusive change to the Nikon1 makernote metadata\n"test9.jpg"test9.jpg"thumb9"thumb9"Exif.Nikon1.Quality"Exif.Nikon1.Quality"Typical Nikon1 Quality"Typical Nikon1 Quality"Case 10: "Case 10: "Intrusive change to the Nikon2 makernote metadata
"Intrusive change to the Nikon2 makernote metadata\n"test10.jpg"test10.jpg"thumb10"thumb10"Exif.Nikon2.0x0002"Exif.Nikon2.0x0002"Nikon2 Version 2"Nikon2 Version 2"Case 11: "Case 11: "file1file2thumbIntrusive change to the Nikon3 makernote metadata
"Intrusive change to the Nikon3 makernote metadata\n"test11.jpg"test11.jpg"thumb11"thumb11"Exif.Nikon3.Quality"Exif.Nikon3.Quality"Typical Nikon3 Quality"Typical Nikon3 Quality"Usage: exiftest file case

"Usage: exiftest file case\n\n"// Open second image// Load existing metadata//Open first image// ToDo: Write to a broken (truncated) IFD entry// ToDo: Erase Sigma thumbnail// local declarations/*
  Abstract : ExifData write unit tests

  Author(s): Andreas Huggel (ahu) <ahuggel@gmx.net>

  Test procedure:
   $ rm -f test.jpg thumb.jpg iii ttt;
   $ ./exifprint ../test/img_1771.jpg > iii;
   $ cp ../test/img_1771.jpg ./test.jpg;
   $ ./makernote-test2 ../test/img_1771.jpg > ttt;
   $ diff iii ttt

 *//Users/owura/Repos/codeql_eval/proj_repos/Exiv2-exiv2-pull-962-commits-e925bc5addd881543fa503470c8a859e112cca62/exiv2/samples/write2-test.cppv1v2v3v4edMn1rEdedMn2edMn3edMn4edMn5edMn6edMn7edMn8edMn9edMn10ed5ed6ed7v5----- Some IFD0 tags
"----- Some IFD0 tags\n"160 161 162 163"160 161 162 163"-2 -1 0 1"-2 -1 0 1"-2/3 -1/3 0/3 1/3"-2/3 -1/3 0/3 1/3"255 254 253 252"255 254 253 252"Exif.Image.WhitePoint"Exif.Image.WhitePoint"
----- One Exif tag
"\n----- One Exif tag\n"Test 2"Test 2"
----- Canon MakerNote tags
"\n----- Canon MakerNote tags\n"Canon PowerShot S40"Canon PowerShot S40"Exif.Canon.0xabcd"Exif.Canon.0xabcd"A Canon makernote tag"A Canon makernote tag"Exif.CanonCs.0x0002"Exif.CanonCs.0x0002"uint16_t(41)Exif.CanonSi.0x0005"Exif.CanonSi.0x0005"uint16_t(42)Exif.CanonCf.0x0001"Exif.CanonCf.0x0001"uint16_t(43)Exif.CanonPi.0x0001"Exif.CanonPi.0x0001"uint16_t(44)Exif.CanonPa.0x0001"Exif.CanonPa.0x0001"uint16_t(45)
----- Non-intrusive writing of special Canon MakerNote tags
"\n----- Non-intrusive writing of special Canon MakerNote tags\n"const char[62]char[62]Exif.CanonCs.0x0001"Exif.CanonCs.0x0001"uint16_t(88)Exif.CanonSi.0x0004"Exif.CanonSi.0x0004"uint16_t(99)
----- One Fujifilm MakerNote tag
"\n----- One Fujifilm MakerNote tag\n"FUJIFILM"FUJIFILM"FinePixS2Pro"FinePixS2Pro"Exif.Fujifilm.0x1000"Exif.Fujifilm.0x1000"A Fujifilm QUALITY tag"A Fujifilm QUALITY tag"
----- One Sigma/Foveon MakerNote tag
"\n----- One Sigma/Foveon MakerNote tag\n"SIGMA"SIGMA"SIGMA SD10"SIGMA SD10"Exif.Sigma.0x0018"Exif.Sigma.0x0018"Software? Exiv2!"Software? Exiv2!"
----- One Nikon1 MakerNote tag
"\n----- One Nikon1 MakerNote tag\n"NIKON"NIKON"E990"E990"Exif.Nikon1.0x0080"Exif.Nikon1.0x0080"ImageAdjustment by Exiv2"ImageAdjustment by Exiv2"
----- One Nikon2 MakerNote tag
"\n----- One Nikon2 MakerNote tag\n"E950"E950"Exif.Nikon2.0xffff"Exif.Nikon2.0xffff"An obscure Nikon2 tag"An obscure Nikon2 tag"
----- One Nikon3 MakerNote tag
"\n----- One Nikon3 MakerNote tag\n"NIKON CORPORATION"NIKON CORPORATION"NIKON D70"NIKON D70"Exif.Nikon3.0x0004"Exif.Nikon3.0x0004"A boring Nikon3 Quality tag"A boring Nikon3 Quality tag"
----- One Olympus MakerNote tag
"\n----- One Olympus MakerNote tag\n"OLYMPUS CORPORATION"OLYMPUS CORPORATION"C8080WZ"C8080WZ"Exif.Olympus.0x0201"Exif.Olympus.0x0201"
----- One Panasonic MakerNote tag
"\n----- One Panasonic MakerNote tag\n"Panasonic"Panasonic"DMC-FZ5"DMC-FZ5"Exif.Panasonic.0x0001"Exif.Panasonic.0x0001"
----- One Sony1 MakerNote tag
"\n----- One Sony1 MakerNote tag\n"SONY"SONY"DSC-W7"DSC-W7"Exif.Sony1.0x2000"Exif.Sony1.0x2000"0 1 2 3 4 5"0 1 2 3 4 5"
----- Minolta MakerNote tags
"\n----- Minolta MakerNote tags\n"Minolta"Minolta"A fancy Minolta camera"A fancy Minolta camera"Exif.Minolta.ColorMode"Exif.Minolta.ColorMode"uint32_t(1)Exif.MinoltaCsNew.WhiteBalance"Exif.MinoltaCsNew.WhiteBalance"uint32_t(2)Exif.MinoltaCs5D.WhiteBalance"Exif.MinoltaCs5D.WhiteBalance"uint16_t(3)Exif.MinoltaCs5D.ColorTemperature"Exif.MinoltaCs5D.ColorTemperature"int16_t(-1)Exif.MinoltaCs7D.WhiteBalance"Exif.MinoltaCs7D.WhiteBalance"uint16_t(4)Exif.MinoltaCs7D.ExposureCompensation"Exif.MinoltaCs7D.ExposureCompensation"int16_t(-2)Exif.MinoltaCs7D.ColorTemperature"Exif.MinoltaCs7D.ColorTemperature"-3int16_t(-3)
----- One IOP tag
"\n----- One IOP tag\n"Test 3"Test 3"
----- One GPS tag
"\n----- One GPS tag\n"19 20"19 20"
----- One IFD1 tag
"\n----- One IFD1 tag\n"Test 5"Test 5"
----- One IOP and one IFD1 tag
"\n----- One IOP and one IFD1 tag\n"
----- One IFD0 and one IFD1 tag
"\n----- One IFD0 and one IFD1 tag\n"Test 7"Test 7"/*
  Abstract : ExifData write unit tests for Exif data created from scratch

  File     : write2-test.cpp
  Author(s): Andreas Huggel (ahu) <ahuggel@gmx.net>
  History  : 26-Jun-04, ahu: created

 */<__utility/move.h>__libcpp_is_constant_evaluated__builtin_is_constant_evaluated__promoted_type__convert_to_integral_Fp__sfinae_test_impl__and_helper__extract_key_first_tag &const __extract_key_first_tagconst __extract_key_first_tag &__extract_key_self_tag &const __extract_key_self_tagconst __extract_key_self_tag &__extract_key_fail_tag &const __extract_key_fail_tagconst __extract_key_fail_tag &__test_swapswap(declval<_LHS>(), declval<_RHS>())_LHS_RHScommon_type<> &const common_type<>const common_type<> &__make_unsigned<__uint128_t, true> &const __make_unsigned<__uint128_t, true>const __make_unsigned<__uint128_t, true> &__make_unsigned<__int128_t, true> &const __make_unsigned<__int128_t, true>const __make_unsigned<__int128_t, true> &__make_unsigned<unsigned long long, true> &const __make_unsigned<unsigned long long, true>const __make_unsigned<unsigned long long, true> &__make_unsigned<signed long long, true> &const __make_unsigned<signed long long, true>const __make_unsigned<signed long long, true> &__make_unsigned<unsigned long, true> &const __make_unsigned<unsigned long, true>const __make_unsigned<unsigned long, true> &__make_unsigned<signed long, true> &const __make_unsigned<signed long, true>const __make_unsigned<signed long, true> &__make_unsigned<unsigned int, true> &const __make_unsigned<unsigned int, true>const __make_unsigned<unsigned int, true> &__make_unsigned<signed int, true> &const __make_unsigned<signed int, true>const __make_unsigned<signed int, true> &__make_unsigned<unsigned short, true> &const __make_unsigned<unsigned short, true>const __make_unsigned<unsigned short, true> &__make_unsigned<signed short, true> &const __make_unsigned<signed short, true>const __make_unsigned<signed short, true> &__make_unsigned<bool, true> &const __make_unsigned<bool, true>const __make_unsigned<bool, true> &__make_signed<__uint128_t, true> &const __make_signed<__uint128_t, true>const __make_signed<__uint128_t, true> &__make_signed<__int128_t, true> &const __make_signed<__int128_t, true>const __make_signed<__int128_t, true> &__make_signed<unsigned long long, true> &const __make_signed<unsigned long long, true>const __make_signed<unsigned long long, true> &__make_signed<signed long long, true> &const __make_signed<signed long long, true>const __make_signed<signed long long, true> &__make_signed<unsigned long, true> &const __make_signed<unsigned long, true>const __make_signed<unsigned long, true> &__make_signed<signed long, true> &const __make_signed<signed long, true>const __make_signed<signed long, true> &__make_signed<unsigned int, true> &const __make_signed<unsigned int, true>const __make_signed<unsigned int, true> &__make_signed<signed int, true> &const __make_signed<signed int, true>const __make_signed<signed int, true> &__make_signed<unsigned short, true> &const __make_signed<unsigned short, true>const __make_signed<unsigned short, true> &__make_signed<signed short, true> &const __make_signed<signed short, true>const __make_signed<signed short, true> &__make_signed<bool, true> &const __make_signed<bool, true>const __make_signed<bool, true> &__numeric_type<void> &const __numeric_type<void>const __numeric_type<void> &__struct_double4 &const __struct_double4const __struct_double4 &__struct_double &const __struct_doubleconst __struct_double &__nat &const __natconst __nat &__any &const __anyconst __any &__any__is_referenceable_impl &const __is_referenceable_implconst __is_referenceable_impl &is_scalaris_scalar<nullptr_t> &const is_scalar<nullptr_t>const is_scalar<nullptr_t> &__libcpp_is_floating_point__libcpp_is_floating_point<long double> &const __libcpp_is_floating_point<long double>const __libcpp_is_floating_point<long double> &__libcpp_is_floating_point<double> &const __libcpp_is_floating_point<double>const __libcpp_is_floating_point<double> &__libcpp_is_floating_point<float> &const __libcpp_is_floating_point<float>const __libcpp_is_floating_point<float> &__libcpp_is_unsigned_integer__libcpp_is_unsigned_integer<__uint128_t> &const __libcpp_is_unsigned_integer<__uint128_t>const __libcpp_is_unsigned_integer<__uint128_t> &__libcpp_is_unsigned_integer<unsigned long long> &const __libcpp_is_unsigned_integer<unsigned long long>const __libcpp_is_unsigned_integer<unsigned long long> &__libcpp_is_unsigned_integer<unsigned long> &const __libcpp_is_unsigned_integer<unsigned long>const __libcpp_is_unsigned_integer<unsigned long> &__libcpp_is_unsigned_integer<unsigned int> &const __libcpp_is_unsigned_integer<unsigned int>const __libcpp_is_unsigned_integer<unsigned int> &__libcpp_is_unsigned_integer<unsigned short> &const __libcpp_is_unsigned_integer<unsigned short>const __libcpp_is_unsigned_integer<unsigned short> &__libcpp_is_unsigned_integer<unsigned char> &const __libcpp_is_unsigned_integer<unsigned char>const __libcpp_is_unsigned_integer<unsigned char> &__libcpp_is_signed_integer__libcpp_is_signed_integer<__int128_t> &const __libcpp_is_signed_integer<__int128_t>const __libcpp_is_signed_integer<__int128_t> &__libcpp_is_signed_integer<signed long long> &const __libcpp_is_signed_integer<signed long long>const __libcpp_is_signed_integer<signed long long> &__libcpp_is_signed_integer<signed long> &const __libcpp_is_signed_integer<signed long>const __libcpp_is_signed_integer<signed long> &__libcpp_is_signed_integer<signed int> &const __libcpp_is_signed_integer<signed int>const __libcpp_is_signed_integer<signed int> &__libcpp_is_signed_integer<signed short> &const __libcpp_is_signed_integer<signed short>const __libcpp_is_signed_integer<signed short> &__libcpp_is_signed_integer<signed char> &const __libcpp_is_signed_integer<signed char>const __libcpp_is_signed_integer<signed char> &__is_nullptr_t_impl__is_nullptr_t_impl<nullptr_t> &const __is_nullptr_t_impl<nullptr_t>const __is_nullptr_t_impl<nullptr_t> &__two &const __twoconst __two &_MetaBase<false> &const _MetaBase<false>const _MetaBase<false> &_MetaBase<true> &const _MetaBase<true>const _MetaBase<true> &operator _Tptrue_type_IsSame_IsNotSame__swap_result_t_EnableIf__identity_t__and_helper<_Pred...>(0)_And_IsCharLikeType_If_BoolConstanthash<__thread_id>_Or__sfinae_test_impl<_Templ, _Args...>(0)_IsValidExpansion__is_primary_templateconst typeconst type &__make_const_lvalue_ref__can_extract_map_key<_ValTy, _Key, _Key, _RawValTy>_ValTy_RawValTy__can_extract_map_key<_ValTy, _Key, _ContainerValueTy, _RawValTy>_ContainerValueTy__can_extract_key<_Pair, _Key, pair<_First, _Second>>_Pair__can_extract_key<_ValTy, _Key, _RawValTy>__extract_key_first_tag__extract_key_self_tag__extract_key_fail_tag__sfinae_underlying_type<_Tp, false>__sfinae_underlying_type<_Tp, <unnamed>>((type)1) + 0underlying_type<_Tp>__underlying_type_impl<_Tp, true>__underlying_type_impl<_Tp, false>__underlying_type_impl<_Tp, <unnamed>>__is_nothrow_swappable<_Tp>__is_swappable<_Tp>__nothrow_swappable_with<_Tp, _Up, false>__nothrow_swappable_with<_Tp, _Up, _Swappable>_Swappable__swappable_with<_Tp, _Up, false>__swappable_with<_Tp, _Up, _NotVoid>_NotVoid(__test_swap<_Up, _Tp>(0))__swap2(__test_swap<_Tp, _Up>(0))__swap1result_of<..(..)>_Fn__result_of<..(..), false, true>__result_of_mp<_Rp _Class::*, _Tp, false>_Class__result_of_mdp<_Rp _Class::*, _Tp, true>__result_of_mdp<_Rp _Class::*, _Tp, false>__result_of_mdp<_MP, _Tp, <unnamed>>__result_of_mp<_MP, _Tp, true>_ReturnType__result_of_mp<_MP, _Tp, _IsMemberFunctionPtr>_IsMemberFunctionPtr__result_of<..(..), true, false>declval<_Fn>()(declval<_Args>()...)__result_of<_Fn, <unnamed>, <unnamed>>result_of<_Callable>_Callable__is_reference_wrapper<_Tp>__is_reference_wrapper_impl<reference_wrapper<_Tp>>__is_reference_wrapper_impl<_Tp>is_trivial<_Tp>is_trivially_copyable<_Tp>is_standard_layout<_Tp>is_literal_type<_Tp>is_pod<_Tp>is_nothrow_destructible<_Tp[]>is_nothrow_destructible<_Tp>__libcpp_nothrow_destructor<_Tp>is_nothrow_move_assignable<_Tp>is_nothrow_copy_assignable<_Tp>is_nothrow_assignable<_Tp, _Arg>_Argis_nothrow_move_constructible<_Tp>is_nothrow_copy_constructible<_Tp>is_nothrow_default_constructible<_Tp>is_nothrow_constructible<_Tp, _Args...>is_trivially_destructible<_Tp>is_trivially_move_assignable<_Tp>is_trivially_copy_assignable<_Tp>is_trivially_assignable<_Tp, _Arg>is_trivially_move_constructible<_Tp>is_trivially_copy_constructible<_Tp>is_trivially_default_constructible<_Tp>is_trivially_constructible<_Tp, _Args...>is_move_constructible<_Tp>is_copy_constructible<_Tp>is_default_constructible<_Tp>is_constructible<_Tp, _Args...>__member_pointer_class_type<_Ret _ClassType::*>_Ret_ClassType__member_pointer_class_type<_DecayedFp>_DecayedFp__member_pointer_traits<_MP>__member_pointer_traits_imp<_Rp _Class::*, false, true>__member_pointer_traits_imp<..(*)(..), true, false>_Param_FnTypeconst volatile _Classvolatile _Classconst _Class__member_pointer_traits_imp<_MP, _IsMemberFunctionPtr, _IsMemberObjectPtr>_IsMemberObjectPtris_destructible<_Tp>is_move_assignable<_Tp>is_copy_assignable<_Tp>is_assignable<_Tp, _Up>__select_2nd<<unnamed>, _Tp>common_type<_Tp, _Up, _Vp, _Rest...>_Restcommon_type<_Tp, _Up>common_type<_Tp>common_type<>__common_type_impl<__common_types<_Tp, _Up, _Vp, _Rest...>, type>__common_type_impl<__common_types<_Tp, _Up>, type>common_type<_Tp...>__common_types<Tp...>Tp__common_type_impl<<unnamed>, <unnamed>>__common_type2_imp<_Tp, _Up, type>__common_type2_imp<_Tp, _Up, <unnamed>>make_unsigned<_Tp>__make_unsigned<__uint128_t, true>__make_unsigned<__int128_t, true>__make_unsigned<unsigned long long, true>__make_unsigned<signed long long, true>__make_unsigned<unsigned long, true>__make_unsigned<signed long, true>__make_unsigned<unsigned int, true>__make_unsigned<signed int, true>__make_unsigned<unsigned short, true>__make_unsigned<signed short, true>__make_unsigned<bool, true>__make_unsigned<_Tp, true>__make_unsigned<_Tp, <unnamed>>make_signed<_Tp>__make_signed<__uint128_t, true>__make_signed<__int128_t, true>__make_signed<unsigned long long, true>__make_signed<signed long long, true>__make_signed<unsigned long, true>__make_signed<signed long, true>__make_signed<unsigned int, true>__make_signed<signed int, true>__make_signed<unsigned short, true>__make_signed<signed short, true>__make_signed<bool, true>__make_signed<_Tp, true>__make_signed<_Tp, <unnamed>>__apply_cv<_Tp &, _Up, true, true>const volatile _Upconst volatile _Up &__apply_cv<_Tp &, _Up, false, true>volatile _Upvolatile _Up &__apply_cv<_Tp &, _Up, true, false>const _Upconst _Up &__apply_cv<_Tp &, _Up, false, false>__apply_cv<_Tp, _Up, true, true>__apply_cv<_Tp, _Up, false, true>__apply_cv<_Tp, _Up, true, false>__apply_cv<_Tp, _Up, <unnamed>, <unnamed>>__find_first<__type_list<_Hp, _Tp>, _Size, false>__find_first<__type_list<_Hp, _Tp>, _Size, true>_Hp__find_first<_TypeList, _Size, <unnamed>>_TypeList__unsigned_types__signed_types__promote<_A1, _A2, _A3>_A1_A2_A3__promote_imp<_A1, void, void, true>__promote_imp<_A1, _A2, void, true>__type1() + __type2()__type2__type1__promote_imp<_A1, _A2, _A3, true>__type1() + __type2() + __type3()__type3__promote_imp<_A1, _A2, _A3, <unnamed>>__numeric_type<void>__numeric_type<_Tp>__test(declval<_Tp>())aligned_union<_Len, _Type0, _Types...>_Len_Type0_Types__static_max<_I0, _I1, _In...>_I0_I1_In__static_max<_I0>__static_max<_I0, _In...>aligned_storage<_Len, 16384UL>16384aligned_storage<_Len, 8192UL>aligned_storage<_Len, 4096UL>aligned_storage<_Len, 2048UL>0x8002048aligned_storage<_Len, 1024UL>0x400aligned_storage<_Len, 512UL>0x200aligned_storage<_Len, 256UL>0x100aligned_storage<_Len, 128UL>aligned_storage<_Len, 64UL>aligned_storage<_Len, 32UL>aligned_storage<_Len, 16UL>aligned_storage<_Len, 8UL>aligned_storage<_Len, 4UL>aligned_storage<_Len, 2UL>aligned_storage<_Len, 1UL>aligned_storage<_Len, _Align>_Align_Aligner__find_max_align<__type_list<_Hp, _Tp>, _Len>__select_align<_Len, _A1, _A2>__find_max_align<__type_list<_Hp, __nat>, _Len>__find_max_align<_TL, _Len>_TL__find_pod<__type_list<_Hp, _Tp>, _Align>__find_pod<__type_list<_Hp, __nat>, _Align>__find_pod<_TL, _Align>__fallback_overaligned<_Align>__all_types__struct_double4__struct_double__align_type<_Tp>__type_list<_Hp, _Tp>_Tail_Headalignment_of<_Tp>has_virtual_destructor<_Tp>is_polymorphic<_Tp>is_empty<_Tp>is_convertible<_T1, _T2>__is_core_convertible<_Tp, _Up, void>__is_core_convertible<_Tp, _Up, <unnamed>>is_base_of<_Bp, _Dp>_Bp__libcpp_is_final<_Tp>is_abstract<_Tp>decay<_Tp>__decay<_Up, true>__decay<_Up, <unnamed>>remove_all_extents<_Tp[]>remove_all_extents<_Tp>remove_extent<_Tp[]>remove_extent<_Tp>extent<_Tp, _Dim>_Dimrank<_Tp[]>rank<_Tp>is_unsigned<_Tp>__libcpp_is_unsigned<_Tp, false>__libcpp_is_unsigned<_Tp, <unnamed>>__libcpp_is_unsigned_impl<_Tp, false>__libcpp_is_unsigned_impl<_Tp, <unnamed>>is_signed<_Tp>__libcpp_is_signed<_Tp, false>__libcpp_is_signed<_Tp, <unnamed>>__libcpp_is_signed_impl<_Tp, false>__libcpp_is_signed_impl<_Tp, <unnamed>>add_pointer<_Tp>__add_pointer_impl<_Tp, false>__add_pointer_impl<_Tp, <unnamed>>remove_pointer<_Tp *const volatile>_Tp *const volatileremove_pointer<_Tp *volatile>_Tp *volatileremove_pointer<_Tp *const>_Tp *constremove_pointer<_Tp *>remove_pointer<_Tp>__is_same_uncvref<_Tp, _Up>__unconstref<_Tp>__uncvref<_Tp>add_rvalue_reference<_Tp>__add_rvalue_reference_impl<_Tp, true>__add_rvalue_reference_impl<_Tp, <unnamed>>add_lvalue_reference<_Tp>__add_lvalue_reference_impl<_Tp, true>__add_lvalue_reference_impl<_Tp, <unnamed>>remove_reference<_Tp &&>remove_reference<_Tp &>remove_reference<_Tp>add_cv<_Tp>const volatile _Tpadd_volatile<_Tp>volatile _Tpadd_const<_Tp>__is_referenceable<_Tp>__is_referenceable_implis_compound<_Tp>is_object<_Tp>is_scalar<nullptr_t>is_scalar<_Tp>__is_block<_Tp>is_fundamental<_Tp>is_arithmetic<_Tp>is_enum<_Tp>is_member_object_pointer<_Tp>is_member_pointer<_Tp>is_member_function_pointer<_Tp>__libcpp_is_member_pointer<_Tp _Up::*>__is_member__is_func__is_obj__libcpp_is_member_pointer<_Tp>is_function<_Tp>is_class<_Tp>is_union<_Tp>is_reference<_Tp>is_rvalue_reference<_Tp>is_lvalue_reference<_Tp>is_pointer<_Tp>is_array<_Tp>is_floating_point<_Tp>__libcpp_is_floating_point<long double>__libcpp_is_floating_point<double>__libcpp_is_floating_point<float>__libcpp_is_floating_point<_Tp>__libcpp_is_unsigned_integer<__uint128_t>__libcpp_is_unsigned_integer<unsigned long long>__libcpp_is_unsigned_integer<unsigned long>__libcpp_is_unsigned_integer<unsigned int>__libcpp_is_unsigned_integer<unsigned short>__libcpp_is_unsigned_integer<unsigned char>__libcpp_is_unsigned_integer<_Tp>__libcpp_is_signed_integer<__int128_t>__libcpp_is_signed_integer<signed long long>__libcpp_is_signed_integer<signed long>__libcpp_is_signed_integer<signed int>__libcpp_is_signed_integer<signed short>__libcpp_is_signed_integer<signed char>__libcpp_is_signed_integer<_Tp>is_integral<_Tp>__is_nullptr_t<_Tp>__is_nullptr_t_impl<nullptr_t>__is_nullptr_t_impl<_Tp>is_void<_Tp>remove_cv<_Tp>remove_volatile<volatile _Tp>remove_volatile<_Tp>remove_const<const _Tp>remove_const<_Tp>is_volatile<_Tp>is_const<_Tp>__two__test_for_primary_templateis_same<_Tp, _Up>enable_if<true, _Tp>enable_if<<unnamed>, _Tp>conditional<false, _If, _Then>_Thenconditional<_Bp, _If, _Then>__dependent_type<_Tp, <unnamed>>__identity<_Tp>__void_t<<unnamed>>_Lazy<_Func, _Args...>__expand_to_true_SecondType_FirstType_Not<_Pred>_MetaBase<false>_Result_OrImpl_SelectApplyImpl_SelectImpl_MetaBase<true>_EnableIfImpl_SecondImpl_FirstImpl_MetaBase<<unnamed>>integral_constant<_Tp, __v>false_type_Tp(&)[]_Templ<unnamed>_IfRes_ElseRes_Rest...true ? declval<_Tp>() : declval<_Up>()static_cast<void(*)(_Up)>(0) ( static_cast<_Tp(*)()>(0)() )_Func_SecondFn_FirstFnreference_wrapper<_Tp>pair<_T1, _T2>__datadouble[4]alignment_value__max__min_LIBCPP_OPTIONAL_PACK_LIBCPP_OPTIONAL_PACK(__VA_ARGS__...), __VA_ARGS___CREATE_ALIGNED_STORAGE_SPECIALIZATION_CREATE_ALIGNED_STORAGE_SPECIALIZATION(n)template <size_t _Len>struct _LIBCPP_TEMPLATE_VIS aligned_storage<_Len, n>{ struct _ALIGNAS(n) type { unsigned char __lx[(_Len + n - 1)/n * n]; };}_LIBCPP_BOOL_CONSTANT(__b)integral_constant<bool,(__b)>_LIBCPP_TYPE_TRAITS__detail__has_keyword(__is_same)_LIBCPP_STD_VER > 14 && !defined(_LIBCPP_HAS_NO_VARIABLE_TEMPLATES)__has_keyword(__is_const)__has_keyword(__is_volatile)__has_keyword(__remove_const)__has_keyword(__remove_volatile)__has_keyword(__remove_cv)__has_keyword(__is_void)__has_keyword(__is_integral)_LIBCPP_HAS_NO_INT128__has_keyword(__is_array)__has_keyword(__is_pointer) &&                                             \defined(_LIBCPP_HAS_OBJC_ARC)__has_keyword(__is_lvalue_reference) && \__has_feature(is_union) || defined(_LIBCPP_COMPILER_GCC)__has_feature(is_class) || defined(_LIBCPP_COMPILER_GCC)__has_keyword(__is_member_function_pointer)__has_keyword(__is_member_pointer)__has_keyword(__is_member_object_pointer)__has_feature(is_enum) || defined(_LIBCPP_COMPILER_GCC)__has_keyword(__is_fundamental) &&                                         \__has_keyword(__is_scalar) && !defined(_LIBCPP_CXX03_LANG)defined(_LIBCPP_HAS_EXTENSION_BLOCKS)__has_keyword(__is_object)__has_keyword(__is_compound) && !defined(_LIBCPP_CXX03_LANG)__has_keyword(__remove_reference)__has_keyword(__is_signed) &&                                              \__has_keyword(__is_unsigned) &&                                            \__has_keyword(__array_extent)_LIBCPP_STD_VER > 14 && !defined(_LIBCPP_HAS_NO_IS_AGGREGATE)!defined(_LIBCPP_HAS_NO_VARIABLE_TEMPLATES)__has_feature(is_convertible_to) && !defined(_LIBCPP_USE_IS_CONVERTIBLE_FALLBACK)__has_feature(is_empty) || defined(_LIBCPP_COMPILER_GCC)__has_feature(is_polymorphic) || defined(_LIBCPP_COMPILER_MSVC)__has_feature(has_virtual_destructor) || defined(_LIBCPP_COMPILER_GCC)_LIBCPP_STD_VER > 14 && defined(_LIBCPP_HAS_UNIQUE_OBJECT_REPRESENTATIONS)!defined(_LIBCPP_CXX03_LANG) || defined(__clang__)_LIBCPP_STD_VER > 17 && !defined(_LIBCPP_HAS_NO_CONCEPTS)__has_keyword(__is_assignable)__has_keyword(__is_destructible)__has_feature(cxx_reference_qualified_functions) || defined(_LIBCPP_COMPILER_GCC)defined(_LIBCPP_COMPILER_GCC) && _GNUC_VER_NEW >= 10000!defined(_LIBCPP_CXX03_LANG) && !__has_feature(is_constructible) && !defined(_LIBCPP_GCC_SUPPORTS_IS_CONSTRUCTIBLE)__has_feature(is_constructible) || defined(_LIBCPP_GCC_SUPPORTS_IS_CONSTRUCTIBLE)__has_feature(is_trivially_constructible) || _GNUC_VER >= 501__has_feature(has_trivial_constructor) || defined(_LIBCPP_COMPILER_GCC)__has_feature(is_trivially_assignable) || _GNUC_VER >= 501__has_keyword(__is_trivially_destructible)__has_feature(has_trivial_destructor) || defined(_LIBCPP_COMPILER_GCC)__has_keyword(__is_nothrow_constructible)__has_keyword(__is_nothrow_assignable)__has_feature(is_pod) || defined(_LIBCPP_COMPILER_GCC)_LIBCPP_STD_VER <= 17 || defined(_LIBCPP_ENABLE_CXX20_REMOVED_TYPE_TRAITS)__has_feature(is_standard_layout) || defined(_LIBCPP_COMPILER_GCC)__has_feature(is_trivially_copyable)_GNUC_VER >= 501__has_feature(is_trivial) || defined(_LIBCPP_COMPILER_GCC)_LIBCPP_HAS_NO_BUILTIN_IS_CONSTANT_EVALUATED__is_reference__is_rvalue_reference__is_lvalue_reference__is_pointer__is_array__is_integral__is_void__remove_cv__remove_volatile__remove_const__is_volatile__is_const__is_same__is_nothrow_assignable__is_nothrow_constructible__is_trivially_destructible__is_destructible__is_assignableclass... _Rest__is_nothrow_swappable<_Tp>::valueis_nothrow_move_constructible<_Tp>::value && is_nothrow_move_assignable<_Tp>::value*declval<_Tp>()__array_extent_Tp(0) < _Tp(-1)__is_unsigned_Tp(-1) < _Tp(0)__is_signed__remove_reference__is_referenceable_impl::__test<_Tp>(0)__is_compound__is_object__is_scalar__is_fundamental__is_member_object_pointer__is_member_pointer__is_member_function_pointer// because they do not properly include <utility> before using std::move or std::forward.// Remove these unnecessary headers. Without them, several clients don't build anymore// _LIBCPP_TYPE_TRAITS// purposefully not versioned// std::byte// because _Key == _ContainerValueTy// This specialization returns __extract_key_fail_tag for non-map containers// and _ValTy == _Key.// It returns true if _Key != _ContainerValueTy (the container is a map not a set)// __can_extract_map_key uses true_type/false_type instead of the tags.// These traits are used in __tree and __hash_table// is_scoped_enum [meta.unary.prop]// __detail// Extra parens are needed for the C++03 definition of decltype.// ALL generic swap overloads MUST already have a declaration available at this point.// __swappable// is_nothrow_invocable// is_invocable// invoke_result// _LIBCPP_STD_VER <= 17 || defined(_LIBCPP_ENABLE_CXX20_REMOVED_TYPE_TRAITS)// _Fn must be member pointer// member data pointer// member function pointer// result_of// or incomplete array types as required by the standard.// FIXME: Check that _Ret, _Fp, and _Args... are all complete types, cv void,// __invokable// bullet 7// bullets 4, 5 and 6// bullets 1, 2 and 3// fall back - none of the bullets// __invoke forward declarations// is_trivial;// is_trivially_copyable;// is_standard_layout;// _LIBCPP_STD_VER > 14 && !defined(_LIBCPP_HAS_NO_VARIABLE_TEMPLATES)// is_literal_type;// is_pod// is_nothrow_destructible// is_nothrow_move_assignable// is_nothrow_copy_assignable// _LIBCPP_HAS_NO_NOEXCEPT// is_nothrow_assignable// is_nothrow_move_constructible// is_nothrow_copy_constructible// is_nothrow_default_constructible/*is constructible*//*is reference*/// is_nothrow_constructible// is_trivially_destructible// is_trivially_move_assignable// is_trivially_copy_assignable// !__has_feature(is_trivially_assignable)// is_trivially_assignable// is_trivially_move_constructible// is_trivially_copy_constructible// is_trivially_default_constructible// !__has_feature(is_trivially_constructible)// is_trivially_constructible// is_move_constructible// is_copy_constructible// !C++03// arguments to workaround Clang's PR43454.// Second, we implement the trait in a funny manner with two defaulted template// default initialization syntax isn't valid.// First of all, we can't implement this check in C++03 mode because the {}// is_default_constructible//  classes with explicit conversion operators.// NOTE: The static_cast implementation below is required to support// Example: static_cast<int&&>(declval<double>());// static_cast<T&&>(e) for non-reference-compatible types.// This overload is needed to work around a Clang bug that disallows// template <class T, class... Args> struct is_constructible;//     typedef ... _FnType;//     typedef ... _ReturnType;//     typedef ... _ClassType;// __has_feature(cxx_reference_qualified_functions) || defined(_LIBCPP_COMPILER_GCC)// __has_keyword(__is_destructible)//    where _Up is remove_all_extents<_Tp>::type//  Otherwise, return "declval<_Up&>().~_Up()" is well-formed//  if it's an array of unknown bound, return false//  if it's   void,     return false//  if it's a function, return false//  if it's a reference, return true// is_destructible// is_move_assignable// is_copy_assignable// __has_keyword(__is_assignable)// is_assignable// _LIBCPP_STD_VER > 17 && !defined(_LIBCPP_HAS_NO_CONCEPTS)// bullet 5 - Otherwise, there shall be no member `type`.//            any, as `common_reference_t<C, Rest...>`.// bullet 4 - If there is such a type `C`, the member typedef type shall denote the same type, if//                  - Otherwise, there shall be no member `type`.//                    then the member typedef `type` denotes that type.// sub-bullet 4 & 5 - Otherwise, if common_type_t<T1, T2> is well-formed,// then the member typedef `type` denotes that type.// sub-bullet 3 - Otherwise, if COND-RES(T1, T2) is well-formed,// is well-formed, then the member typedef `type` denotes that type.// sub-bullet 2 - Otherwise, if basic_common_reference<remove_cvref_t<T1>, remove_cvref_t<T2>, XREF(T1), XREF(T2)>::type// the member typedef `type` denotes that type.// sub-bullet 1 - If T1 and T2 are reference types and COMMON-REF(T1, T2) is well-formed, then// bullet 3 - sizeof...(T) == 2// bullet 2 - sizeof...(T) == 1// bullet 1 - sizeof...(T) == 0// Note C: For the common_reference trait applied to a parameter pack [...]//    Otherwise, COMMON-REF(A, B) is ill-formed.//    COMMON-REF(A, B) is COMMON-REF(B, A).//    Otherwise, if A is an lvalue reference and B is an rvalue reference, then//    is_convertible_v<A, D> is true, then COMMON-REF(A, B) is D.//    ... If A is an rvalue reference and B is an lvalue reference and D is well-formed and//    Otherwise, let D be COMMON-REF(const X&, Y&). ...//    is_convertible_v<A, C> && is_convertible_v<B, C> is true, then COMMON-REF(A, B) is C.//    .... If A and B are both rvalue reference types, C is well-formed, and//    Otherwise, let C be remove_reference_t<COMMON-REF(X&, Y&)>&&. ...//    COND-RES(COPYCV(X, Y)&, COPYCV(Y, X)&) if that type exists and is a reference type.//    If A and B are both lvalue reference types, COMMON-REF(A, B) is// and let COMMON-REF(A, B) be:// Given types A and B, let X be remove_reference_t<A>, let Y be remove_reference_t<B>,// [Note: `XREF(A)` is `__xref<A>::template __apply`]// `U`.// with the addition of `A`'s cv and reference qualifiers, for a non-reference cv-unqualified type// Let `XREF(A)` denote a unary alias template `T` such that `T<U>` denotes the same type as `U`// Let COND_RES(X, Y) be:// common_reference// top-level cv-qualifiers.// Let COPYCV(FROM, TO) be an alias for type TO with the addition of FROM's// bullet 4 - sizeof...(Tp) > 2// sub-bullet 1 - "If is_same_v<T1, D1> is false or ..."// bullet 3 - sizeof...(Tp) == 2// bullet 2 - sizeof...(Tp) == 1// bullet 1 - sizeof...(Tp) == 0// Clang provides variadic templates in C++03 as an extension.// sub-bullet 3 - "if decay_t<decltype(false ? declval<D1>() : declval<D2>())> ..."// sub-bullet 4 - "if COND_RES(CREF(D1), CREF(D2)) denotes a type..."// make_signed / make_unsigned// __promote// aligned_union// !defined(_LIBCPP_OBJECT_FORMAT_COFF)// PE/COFF does not support alignment beyond 8192 (=0x2000)// aligned_storage// alignment_of// has_unique_object_representations// has_virtual_destructor// __has_feature(is_polymorphic)// is_polymorphic// __has_feature(is_empty)// is_empty// is_nothrow_convertible// __has_feature(is_convertible_to)// is_convertible// and __is_core_convertible<immovable-type,immovable-type> is true in C++17 and later.// to a function. Notice that __is_core_convertible<void,void> is false,// We can't test for that, but we can test implicit convertibility by passing it// [conv.general]/3 says "E is convertible to T" whenever "T t=E;" is well-formed.// __is_core_convertible// is_base_of// _LIBCPP_STD_VER > 14 && !defined(_LIBCPP_HAS_NO_IS_AGGREGATE)// is_aggregate// is_final// is_abstract// decay// is_unbounded_array// is_bounded_array// remove_all_extents// remove_extent// __has_keyword(__array_extent)// extent// rank// __has_keyword(__is_unsigned)// floating point// No currently-released version of AppleClang contains the fixed intrinsic.// Before Clang 13, __is_unsigned returned true for enums with signed underlying type.// is_unsigned// __has_keyword(__is_signed)// Before Clang 10, __is_signed didn't work for floating-point types or enums.// is_signed// type_identity// add_pointer// remove_pointer// remove_cvref - same as __uncvref// __is_same_uncvref// __uncvref// from volatile-qualified types _Tp.// Suppress deprecation notice for volatile-qualified return type resulting// add_lvalue_reference// __has_keyword(__remove_reference)// remove_reference// add_cv// add_volatile// add_const// __is_referenceable  [defns.referenceable]// __has_keyword(__is_compound)// >= 11 because in C++03 nullptr isn't actually nullptr// is_compound// __has_keyword(__is_object)// is_object// __has_keyword(__is_scalar)// In C++03 nullptr_t is library-provided but must still count as "scalar."// is_scalar// __has_keyword(__is_fundamental)// In C++03 nullptr_t is library-provided but must still count as "fundamental."// Before Clang 10, __is_fundamental didn't work for nullptr_t.// is_fundamental// is_arithmetic// __has_feature(is_enum) || defined(_LIBCPP_COMPILER_GCC)// is_enum// __has_keyword(__is_member_object_pointer)// is_member_object_pointer// __has_keyword(__is_member_pointer)// is_member_pointer// __has_keyword(__is_member_function_pointer)// is_function// is_class// is_union// __has_keyword(__is_lvalue_reference) && etc...// is_reference// __has_keyword(__is_pointer)// Before Clang 11 / AppleClang 12.0.5, __is_pointer didn't work for Objective-C types.// is_pointer// __has_keyword(__is_array)// is_array// is_floating_point// five types with "char" in their name, compose the "integral" types.// The signed and unsigned integer types, plus bool and the// __int128_t is an extended signed integer type.// [basic.fundamental] defines five standard signed integer types;// __libcpp_is_signed_integer, __libcpp_is_unsigned_integer// __has_keyword(__is_integral)// is_integral// __is_nullptr_t// __has_keyword(__is_void)// is_void// __has_keyword(__remove_cv)// remove_cv// __has_keyword(__remove_volatile)// remove_volatile// __has_keyword(__remove_const)// remove_const// __has_keyword(__is_volatile)// is_volatile// __has_keyword(__is_const)// is_const// helper class:// __is_same// is_same// Member detector base/*
    type_traits synopsis

namespace std
{

    // helper class:
    template <class T, T v> struct integral_constant;
    typedef integral_constant<bool, true>  true_type;   // C++11
    typedef integral_constant<bool, false> false_type;  // C++11

    template <bool B>                                   // C++14
    using bool_constant = integral_constant<bool, B>;   // C++14
    typedef bool_constant<true> true_type;              // C++14
    typedef bool_constant<false> false_type;            // C++14

    // helper traits
    template <bool, class T = void> struct enable_if;
    template <bool, class T, class F> struct conditional;

    // Primary classification traits:
    template <class T> struct is_void;
    template <class T> struct is_null_pointer;  // C++14
    template <class T> struct is_integral;
    template <class T> struct is_floating_point;
    template <class T> struct is_array;
    template <class T> struct is_pointer;
    template <class T> struct is_lvalue_reference;
    template <class T> struct is_rvalue_reference;
    template <class T> struct is_member_object_pointer;
    template <class T> struct is_member_function_pointer;
    template <class T> struct is_enum;
    template <class T> struct is_union;
    template <class T> struct is_class;
    template <class T> struct is_function;

    // Secondary classification traits:
    template <class T> struct is_reference;
    template <class T> struct is_arithmetic;
    template <class T> struct is_fundamental;
    template <class T> struct is_member_pointer;
    template <class T> struct is_scoped_enum; // C++2b
    template <class T> struct is_scalar;
    template <class T> struct is_object;
    template <class T> struct is_compound;

    // Const-volatile properties and transformations:
    template <class T> struct is_const;
    template <class T> struct is_volatile;
    template <class T> struct remove_const;
    template <class T> struct remove_volatile;
    template <class T> struct remove_cv;
    template <class T> struct add_const;
    template <class T> struct add_volatile;
    template <class T> struct add_cv;

    // Reference transformations:
    template <class T> struct remove_reference;
    template <class T> struct add_lvalue_reference;
    template <class T> struct add_rvalue_reference;

    // Pointer transformations:
    template <class T> struct remove_pointer;
    template <class T> struct add_pointer;

    template<class T> struct type_identity;                     // C++20
    template<class T>
      using type_identity_t = typename type_identity<T>::type;  // C++20

    // Integral properties:
    template <class T> struct is_signed;
    template <class T> struct is_unsigned;
    template <class T> struct make_signed;
    template <class T> struct make_unsigned;

    // Array properties and transformations:
    template <class T> struct rank;
    template <class T, unsigned I = 0> struct extent;
    template <class T> struct remove_extent;
    template <class T> struct remove_all_extents;

    template <class T> struct is_bounded_array;                 // C++20
    template <class T> struct is_unbounded_array;               // C++20

    // Member introspection:
    template <class T> struct is_pod;
    template <class T> struct is_trivial;
    template <class T> struct is_trivially_copyable;
    template <class T> struct is_standard_layout;
    template <class T> struct is_literal_type; // Deprecated in C++17; removed in C++20
    template <class T> struct is_empty;
    template <class T> struct is_polymorphic;
    template <class T> struct is_abstract;
    template <class T> struct is_final; // C++14
    template <class T> struct is_aggregate; // C++17

    template <class T, class... Args> struct is_constructible;
    template <class T>                struct is_default_constructible;
    template <class T>                struct is_copy_constructible;
    template <class T>                struct is_move_constructible;
    template <class T, class U>       struct is_assignable;
    template <class T>                struct is_copy_assignable;
    template <class T>                struct is_move_assignable;
    template <class T, class U>       struct is_swappable_with;       // C++17
    template <class T>                struct is_swappable;            // C++17
    template <class T>                struct is_destructible;

    template <class T, class... Args> struct is_trivially_constructible;
    template <class T>                struct is_trivially_default_constructible;
    template <class T>                struct is_trivially_copy_constructible;
    template <class T>                struct is_trivially_move_constructible;
    template <class T, class U>       struct is_trivially_assignable;
    template <class T>                struct is_trivially_copy_assignable;
    template <class T>                struct is_trivially_move_assignable;
    template <class T>                struct is_trivially_destructible;

    template <class T, class... Args> struct is_nothrow_constructible;
    template <class T>                struct is_nothrow_default_constructible;
    template <class T>                struct is_nothrow_copy_constructible;
    template <class T>                struct is_nothrow_move_constructible;
    template <class T, class U>       struct is_nothrow_assignable;
    template <class T>                struct is_nothrow_copy_assignable;
    template <class T>                struct is_nothrow_move_assignable;
    template <class T, class U>       struct is_nothrow_swappable_with; // C++17
    template <class T>                struct is_nothrow_swappable;      // C++17
    template <class T>                struct is_nothrow_destructible;

    template <class T> struct has_virtual_destructor;

    template<class T> struct has_unique_object_representations;         // C++17

    // Relationships between types:
    template <class T, class U> struct is_same;
    template <class Base, class Derived> struct is_base_of;

    template <class From, class To> struct is_convertible;
    template <typename From, typename To> struct is_nothrow_convertible;                  // C++20
    template <typename From, typename To> inline constexpr bool is_nothrow_convertible_v; // C++20

    template <class Fn, class... ArgTypes> struct is_invocable;
    template <class R, class Fn, class... ArgTypes> struct is_invocable_r;

    template <class Fn, class... ArgTypes> struct is_nothrow_invocable;
    template <class R, class Fn, class... ArgTypes> struct is_nothrow_invocable_r;

    // Alignment properties and transformations:
    template <class T> struct alignment_of;
    template <size_t Len, size_t Align = most_stringent_alignment_requirement>
        struct aligned_storage;
    template <size_t Len, class... Types> struct aligned_union;
    template <class T> struct remove_cvref; // C++20

    template <class T> struct decay;
    template <class... T> struct common_type;
    template <class T> struct underlying_type;
    template <class> class result_of; // undefined; deprecated in C++17; removed in C++20
    template <class Fn, class... ArgTypes> class result_of<Fn(ArgTypes...)>; // deprecated in C++17; removed in C++20
    template <class Fn, class... ArgTypes> struct invoke_result;  // C++17

    // const-volatile modifications:
    template <class T>
      using remove_const_t    = typename remove_const<T>::type;  // C++14
    template <class T>
      using remove_volatile_t = typename remove_volatile<T>::type;  // C++14
    template <class T>
      using remove_cv_t       = typename remove_cv<T>::type;  // C++14
    template <class T>
      using add_const_t       = typename add_const<T>::type;  // C++14
    template <class T>
      using add_volatile_t    = typename add_volatile<T>::type;  // C++14
    template <class T>
      using add_cv_t          = typename add_cv<T>::type;  // C++14

    // reference modifications:
    template <class T>
      using remove_reference_t     = typename remove_reference<T>::type;  // C++14
    template <class T>
      using add_lvalue_reference_t = typename add_lvalue_reference<T>::type;  // C++14
    template <class T>
      using add_rvalue_reference_t = typename add_rvalue_reference<T>::type;  // C++14

    // sign modifications:
    template <class T>
      using make_signed_t   = typename make_signed<T>::type;  // C++14
    template <class T>
      using make_unsigned_t = typename make_unsigned<T>::type;  // C++14

    // array modifications:
    template <class T>
      using remove_extent_t      = typename remove_extent<T>::type;  // C++14
    template <class T>
      using remove_all_extents_t = typename remove_all_extents<T>::type;  // C++14

    template <class T>
      inline constexpr bool is_bounded_array_v
        = is_bounded_array<T>::value;                                     // C++20
      inline constexpr bool is_unbounded_array_v
        = is_unbounded_array<T>::value;                                   // C++20

    // pointer modifications:
    template <class T>
      using remove_pointer_t = typename remove_pointer<T>::type;  // C++14
    template <class T>
      using add_pointer_t    = typename add_pointer<T>::type;  // C++14

    // other transformations:
    template <size_t Len, size_t Align=default-alignment>
      using aligned_storage_t = typename aligned_storage<Len,Align>::type;  // C++14
    template <size_t Len, class... Types>
      using aligned_union_t   = typename aligned_union<Len,Types...>::type;  // C++14
    template <class T>
      using remove_cvref_t    = typename remove_cvref<T>::type;  // C++20
    template <class T>
      using decay_t           = typename decay<T>::type;  // C++14
    template <bool b, class T=void>
      using enable_if_t       = typename enable_if<b,T>::type;  // C++14
    template <bool b, class T, class F>
      using conditional_t     = typename conditional<b,T,F>::type;  // C++14
    template <class... T>
      using common_type_t     = typename common_type<T...>::type;  // C++14
    template <class T>
      using underlying_type_t = typename underlying_type<T>::type;  // C++14
    template <class T>
      using result_of_t       = typename result_of<T>::type;  // C++14; deprecated in C++17; removed in C++20
    template <class Fn, class... ArgTypes>
      using invoke_result_t   = typename invoke_result<Fn, ArgTypes...>::type;  // C++17

    template <class...>
      using void_t = void;   // C++17

      // See C++14 20.10.4.1, primary type categories
      template <class T> inline constexpr bool is_void_v
        = is_void<T>::value;                                             // C++17
      template <class T> inline constexpr bool is_null_pointer_v
        = is_null_pointer<T>::value;                                     // C++17
      template <class T> inline constexpr bool is_integral_v
        = is_integral<T>::value;                                         // C++17
      template <class T> inline constexpr bool is_floating_point_v
        = is_floating_point<T>::value;                                   // C++17
      template <class T> inline constexpr bool is_array_v
        = is_array<T>::value;                                            // C++17
      template <class T> inline constexpr bool is_pointer_v
        = is_pointer<T>::value;                                          // C++17
      template <class T> inline constexpr bool is_lvalue_reference_v
        = is_lvalue_reference<T>::value;                                 // C++17
      template <class T> inline constexpr bool is_rvalue_reference_v
        = is_rvalue_reference<T>::value;                                 // C++17
      template <class T> inline constexpr bool is_member_object_pointer_v
        = is_member_object_pointer<T>::value;                            // C++17
      template <class T> inline constexpr bool is_member_function_pointer_v
        = is_member_function_pointer<T>::value;                          // C++17
      template <class T> inline constexpr bool is_enum_v
        = is_enum<T>::value;                                             // C++17
      template <class T> inline constexpr bool is_union_v
        = is_union<T>::value;                                            // C++17
      template <class T> inline constexpr bool is_class_v
        = is_class<T>::value;                                            // C++17
      template <class T> inline constexpr bool is_function_v
        = is_function<T>::value;                                         // C++17

      // See C++14 20.10.4.2, composite type categories
      template <class T> inline constexpr bool is_reference_v
        = is_reference<T>::value;                                        // C++17
      template <class T> inline constexpr bool is_arithmetic_v
        = is_arithmetic<T>::value;                                       // C++17
      template <class T> inline constexpr bool is_fundamental_v
        = is_fundamental<T>::value;                                      // C++17
      template <class T> inline constexpr bool is_object_v
        = is_object<T>::value;                                           // C++17
      template <class T> inline constexpr bool is_scalar_v
        = is_scalar<T>::value;                                           // C++17
      template <class T> inline constexpr bool is_compound_v
        = is_compound<T>::value;                                         // C++17
      template <class T> inline constexpr bool is_member_pointer_v
        = is_member_pointer<T>::value;                                   // C++17
      template <class T> inline constexpr bool is_scoped_enum_v
        = is_scoped_enum<T>::value;                                      // C++2b

      // See C++14 20.10.4.3, type properties
      template <class T> inline constexpr bool is_const_v
        = is_const<T>::value;                                            // C++17
      template <class T> inline constexpr bool is_volatile_v
        = is_volatile<T>::value;                                         // C++17
      template <class T> inline constexpr bool is_trivial_v
        = is_trivial<T>::value;                                          // C++17
      template <class T> inline constexpr bool is_trivially_copyable_v
        = is_trivially_copyable<T>::value;                               // C++17
      template <class T> inline constexpr bool is_standard_layout_v
        = is_standard_layout<T>::value;                                  // C++17
      template <class T> inline constexpr bool is_pod_v
        = is_pod<T>::value;                                              // C++17
      template <class T> inline constexpr bool is_literal_type_v
        = is_literal_type<T>::value;                                     // C++17; deprecated in C++17; removed in C++20
      template <class T> inline constexpr bool is_empty_v
        = is_empty<T>::value;                                            // C++17
      template <class T> inline constexpr bool is_polymorphic_v
        = is_polymorphic<T>::value;                                      // C++17
      template <class T> inline constexpr bool is_abstract_v
        = is_abstract<T>::value;                                         // C++17
      template <class T> inline constexpr bool is_final_v
        = is_final<T>::value;                                            // C++17
      template <class T> inline constexpr bool is_aggregate_v
        = is_aggregate<T>::value;                                        // C++17
      template <class T> inline constexpr bool is_signed_v
        = is_signed<T>::value;                                           // C++17
      template <class T> inline constexpr bool is_unsigned_v
        = is_unsigned<T>::value;                                         // C++17
      template <class T, class... Args> inline constexpr bool is_constructible_v
        = is_constructible<T, Args...>::value;                           // C++17
      template <class T> inline constexpr bool is_default_constructible_v
        = is_default_constructible<T>::value;                            // C++17
      template <class T> inline constexpr bool is_copy_constructible_v
        = is_copy_constructible<T>::value;                               // C++17
      template <class T> inline constexpr bool is_move_constructible_v
        = is_move_constructible<T>::value;                               // C++17
      template <class T, class U> inline constexpr bool is_assignable_v
        = is_assignable<T, U>::value;                                    // C++17
      template <class T> inline constexpr bool is_copy_assignable_v
        = is_copy_assignable<T>::value;                                  // C++17
      template <class T> inline constexpr bool is_move_assignable_v
        = is_move_assignable<T>::value;                                  // C++17
      template <class T, class U> inline constexpr bool is_swappable_with_v
        = is_swappable_with<T, U>::value;                                // C++17
      template <class T> inline constexpr bool is_swappable_v
        = is_swappable<T>::value;                                        // C++17
      template <class T> inline constexpr bool is_destructible_v
        = is_destructible<T>::value;                                     // C++17
      template <class T, class... Args> inline constexpr bool is_trivially_constructible_v
        = is_trivially_constructible<T, Args...>::value;                 // C++17
      template <class T> inline constexpr bool is_trivially_default_constructible_v
        = is_trivially_default_constructible<T>::value;                  // C++17
      template <class T> inline constexpr bool is_trivially_copy_constructible_v
        = is_trivially_copy_constructible<T>::value;                     // C++17
      template <class T> inline constexpr bool is_trivially_move_constructible_v
        = is_trivially_move_constructible<T>::value;                     // C++17
      template <class T, class U> inline constexpr bool is_trivially_assignable_v
        = is_trivially_assignable<T, U>::value;                          // C++17
      template <class T> inline constexpr bool is_trivially_copy_assignable_v
        = is_trivially_copy_assignable<T>::value;                        // C++17
      template <class T> inline constexpr bool is_trivially_move_assignable_v
        = is_trivially_move_assignable<T>::value;                        // C++17
      template <class T> inline constexpr bool is_trivially_destructible_v
        = is_trivially_destructible<T>::value;                           // C++17
      template <class T, class... Args> inline constexpr bool is_nothrow_constructible_v
        = is_nothrow_constructible<T, Args...>::value;                   // C++17
      template <class T> inline constexpr bool is_nothrow_default_constructible_v
        = is_nothrow_default_constructible<T>::value;                    // C++17
      template <class T> inline constexpr bool is_nothrow_copy_constructible_v
        = is_nothrow_copy_constructible<T>::value;                       // C++17
      template <class T> inline constexpr bool is_nothrow_move_constructible_v
        = is_nothrow_move_constructible<T>::value;                       // C++17
      template <class T, class U> inline constexpr bool is_nothrow_assignable_v
        = is_nothrow_assignable<T, U>::value;                            // C++17
      template <class T> inline constexpr bool is_nothrow_copy_assignable_v
        = is_nothrow_copy_assignable<T>::value;                          // C++17
      template <class T> inline constexpr bool is_nothrow_move_assignable_v
        = is_nothrow_move_assignable<T>::value;                          // C++17
      template <class T, class U> inline constexpr bool is_nothrow_swappable_with_v
        = is_nothrow_swappable_with<T, U>::value;                       // C++17
      template <class T> inline constexpr bool is_nothrow_swappable_v
        = is_nothrow_swappable<T>::value;                               // C++17
      template <class T> inline constexpr bool is_nothrow_destructible_v
        = is_nothrow_destructible<T>::value;                             // C++17
      template <class T> inline constexpr bool has_virtual_destructor_v
        = has_virtual_destructor<T>::value;                              // C++17
      template<class T> inline constexpr bool has_unique_object_representations_v // C++17
        = has_unique_object_representations<T>::value;

      // See C++14 20.10.5, type property queries
      template <class T> inline constexpr size_t alignment_of_v
        = alignment_of<T>::value;                                        // C++17
      template <class T> inline constexpr size_t rank_v
        = rank<T>::value;                                                // C++17
      template <class T, unsigned I = 0> inline constexpr size_t extent_v
        = extent<T, I>::value;                                           // C++17

      // See C++14 20.10.6, type relations
      template <class T, class U> inline constexpr bool is_same_v
        = is_same<T, U>::value;                                          // C++17
      template <class Base, class Derived> inline constexpr bool is_base_of_v
        = is_base_of<Base, Derived>::value;                              // C++17
      template <class From, class To> inline constexpr bool is_convertible_v
        = is_convertible<From, To>::value;                               // C++17
      template <class Fn, class... ArgTypes> inline constexpr bool is_invocable_v
        = is_invocable<Fn, ArgTypes...>::value;                          // C++17
      template <class R, class Fn, class... ArgTypes> inline constexpr bool is_invocable_r_v
        = is_invocable_r<R, Fn, ArgTypes...>::value;                     // C++17
      template <class Fn, class... ArgTypes> inline constexpr bool is_nothrow_invocable_v
        = is_nothrow_invocable<Fn, ArgTypes...>::value;                  // C++17
      template <class R, class Fn, class... ArgTypes> inline constexpr bool is_nothrow_invocable_r_v
        = is_nothrow_invocable_r<R, Fn, ArgTypes...>::value;             // C++17

      // [meta.logical], logical operator traits:
      template<class... B> struct conjunction;                           // C++17
      template<class... B>
        inline constexpr bool conjunction_v = conjunction<B...>::value;  // C++17
      template<class... B> struct disjunction;                           // C++17
      template<class... B>
        inline constexpr bool disjunction_v = disjunction<B...>::value;  // C++17
      template<class B> struct negation;                                 // C++17
      template<class B>
        inline constexpr bool negation_v = negation<B>::value;           // C++17

}

*///===------------------------ type_traits ---------------------------------===//<__bits>const __bit_iterator<__bitset<0UL, 0UL>, true, 0UL>const __bit_iterator<__bitset<0UL, 0UL>, true, 0UL> &__bit_iterator<__bitset<0UL, 0UL>, true, 0UL> &const __bit_iterator<__bitset<0UL, 0UL>, false, 0UL>const __bit_iterator<__bitset<0UL, 0UL>, false, 0UL> &__bit_iterator<__bitset<0UL, 0UL>, false, 0UL> &__count_bool_false_IC__count_bool_true__find_bool_false__find_bool_trueequal_IC1_IC2__equal_unaligned__equal_alignedrotateswap_ranges__C1__C2__swap_ranges_unaligned__swap_ranges_aligned__copy_backward_unaligned__copy_backward_aligned__copy_unaligned__copy_aligned__fill_n_true__fill_n_falseconst __bit_iterator<_Cp, _IsConst, <unnamed>>const __bit_iterator<_Cp, _IsConst, <unnamed>> &__bit_iterator<_Cp, _IsConst, <unnamed>> &_Cp_IsConstfill_n__bit_array__bit_reference__bit_reference<_Cp, <unnamed>> *operator&__bit_reference<_Cp, <unnamed>> &const __bit_reference<_Cp, <unnamed>>const __bit_reference<_Cp, <unnamed>> &operator~__bit_const_reference<_Cp> &const __bit_const_reference<_Cp>const __bit_const_reference<_Cp> &__bit_const_reference__bit_const_reference<_Cp> *const __bit_reference<_Cp, value>const __bit_reference<_Cp, value> &__bit_reference<_Cp, value> &__bit_iterator__bit_iterator<_Cp, _IsConst, <unnamed>> *const _If<_IsConst, __private_nat, __bit_iterator<_Cp, _IsConst, <unnamed>>>const _If<_IsConst, __private_nat, __bit_iterator<_Cp, _IsConst, <unnamed>>> &_SelectImpl<__private_nat, __bit_iterator<_Cp, _IsConst, <unnamed>>> &const __bit_iterator<_Cp, false, 0>const __bit_iterator<_Cp, false, 0> &__bit_iterator<_Cp, false, 0> &__seg___ctz___bit_array<_Cp>__bit_reference<_Cp, false>__bit_reference<_Cp, <unnamed>>__has_storage_type<_Tp>__bit_const_reference<_Cp>__bit_iterator<_Cp, _IsConst, <unnamed>>__bit_array<_Dp>__private_nat__storage_type[4]__word___mask__LIBCPP___BIT_REFERENCE// _LIBCPP___BIT_REFERENCE// implicitly generated and trivial.// When _IsConst=true, the assignment operators are// the implicit generation of a defaulted one is deprecated.// so we must also provide a copy assignment operator because// When _IsConst=false, we have a user-provided copy constructor,// and trivial.// the copy and move constructors are implicitly generated// When _IsConst=true, this is a converting constructor;// It is non-trivial. Making it trivial would break ABI.// When _IsConst=false, this is the copy constructor.// do last word// do middle words// __first2.__ctz_ == 0;// __first1.__ctz_ == 0;// __first2.__ctz_ = 0;// __first1.__ctz_ = 0;// do first word// equal// rotate// __first.__ctz_ == 0;// __first.__ctz_ = 0;// swap_ranges// __result.__ctz_ == 0// __result.__ctz_ != 0 || __n == 0// __last.__ctz_ == 0 || __n == 0// __last.__ctz_ = 0// __result.__ctz_ == 0 || __n == 0// fill// do first partial word// fill_n// count__ctz"datasets.hpp"IptcParser &const IptcParserconst IptcParser &const Slice<unsigned char *>const Slice<unsigned char *> &Slice<unsigned char *> &const IptcData *findIdIptcDataSets::application2const Iptcdatum &~IptcdatumIptcdatumIptcParserIptcMetadataiptcMetadata_marker_IPTC_HPP_// #ifndef IPTC_HPP_// class IptcParser// Dataset marker// Constant data/*!
          @brief Encode the IPTC datasets from \em iptcData to a binary
                 representation in IPTC IIM4 format.

          Convert the IPTC datasets to binary format and return it.  Caller owns
          the returned buffer. The copied data follows the IPTC IIM4 standard.

          @return Data buffer containing the binary IPTC data in IPTC IIM4 format.
         *//*!
          @brief Decode binary IPTC data in IPTC IIM4 format from a buffer \em pData
                 of length \em size to the provided metadata container.

          @param iptcData Metadata container to add the decoded IPTC datasets to.
          @param pData    Pointer to the data buffer to read from.
          @param size     Number of bytes in the data buffer.

          @return 0 if successful;<BR>
                  5 if the binary IPTC data is invalid or corrupt
         *//*!
      @brief Stateless parser class for IPTC data. Images use this class to
             decode and encode binary IPTC data.
     */// class IptcData/*!
          @brief dump iptc formatted binary data (used by printStructure kpsRecursive)
        *//*!
          @brief Return the metadata charset name or 0
         *//*!
          @brief Return the exact size of all contained IPTC metadata
         *///! Return true if there is no IPTC metadata/*!
          @brief Find the first Iptcdatum with the given record and dataset
                 number, return a const iterator to it.
         *//*!
          @brief Find the first Iptcdatum with the given key, return a const
                 iterator to it.
         *//*!
          @brief Find the first Iptcdatum with the given record and dataset it,
                return a const iterator to it.
         *//*!
          @brief Find the first Iptcdatum with the given key, return an iterator
                 to it.
         *///! Sort metadata by tag (aka dataset)/*!
          @brief Delete all Iptcdatum instances resulting in an empty container.
         *//*!
          @brief Delete the Iptcdatum at iterator position pos, return the
                 position of the next Iptcdatum. Note that iterators into
                 the metadata, including pos, are potentially invalidated
                 by this call.
         *//*!
          @brief Add a copy of the Iptcdatum to the IPTC metadata. A check
                 for non-repeatable datasets is performed.
          @return 0 if successful;<BR>
                 6 if the dataset already exists and is not repeatable;<BR>
         *//*!
          @brief Add an %Iptcdatum from the supplied key and value pair. This
                 method copies (clones) the value. A check for non-repeatable
                 datasets is performed.
          @return 0 if successful;<BR>
                  6 if the dataset already exists and is not repeatable
         *//*!
          @brief Returns a reference to the %Iptcdatum that is associated with a
                 particular \em key. If %IptcData does not already contain such
                 an %Iptcdatum, operator[] adds object \em Iptcdatum(key).

          @note  Since operator[] might insert a new element, it can't be a const
                 member function.
         */// Use the compiler generated constructors and assignment operator//! IptcMetadata const iterator type//! IptcMetadata iterator type/*!
      @brief A container for IPTC data. This is a top-level class of
             the %Exiv2 library.

      Provide high-level access to the IPTC data of an image:
      - read IPTC information from JPEG files
      - access metadata through keys and standard C++ iterators
      - add, modify and delete metadata
      - write IPTC data to JPEG files
      - extract IPTC metadata to files, insert from these files
    */// class Iptcdatum//! Return the tag (aka dataset) number/*!
           @brief Return the name of the tag (aka dataset)
           @return tag name
         *//*!
           @brief Return the record id
           @return record id
         *//*!
           @brief Return the name of the record (deprecated)
           @return record name
         *//*!
          @brief Return the key of the Iptcdatum. The key is of the form
                 '<b>Iptc</b>.recordName.datasetName'. Note however that the key
                 is not necessarily unique, i.e., an IptcData object may contain
                 multiple metadata with the same key.
         *//*!
          @brief Set the value to the string \em value, using
                 Value::read(const std::string&).
                 If the %Iptcdatum does not have a Value yet, then a %Value of
                 the correct type for this %Iptcdatum is created. If that
                 fails (because of an unknown dataset), a StringValue is
                 created. Return 0 if the value was read successfully.
         *//*!
          @brief Assign \em value to the %Iptcdatum.
                 Calls setValue(const Value*).
         *//*!
          @brief Assign \em value to the %Iptcdatum.
                 Calls setValue(const std::string&).
         *//*!
          @brief Assign \em value to the %Iptcdatum. The type of the new Value
                 is set to UShortValue.
         *//*!
          @brief Constructor for new tags created by an application. The
                 %Iptcdatum is created from a key / value pair. %Iptcdatum
                 copies (clones) the value if one is provided. Alternatively, a
                 program can create an 'empty' %Iptcdatum with only a key and
                 set the value using setValue().

          @param key The key of the %Iptcdatum.
          @param pValue Pointer to a %Iptcdatum value.
          @throw Error if the key cannot be parsed and converted
                 to a tag number and record id.
         *//*!
      @brief An IPTC metadatum ("dataset"), consisting of an IptcKey and a
             Value and methods to manipulate these.
     *//*!
  @file    iptc.hpp
  @brief   Encoding and decoding of IPTC data
  @author  Brad Schick (brad)
           <a href="mailto:brad@robotbattle.com">brad@robotbattle.com</a>
  @date    31-Jul-04, brad: created
 */bytesdatasetiptcdatum"properties.hpp"Xmpdatum &const bool &Xmpdatum *const Xmpdatumconst Xmpdatum &~XmpdatumXmpdatumconst XmpKeyconst XmpKey &XmpKey &XmpParser &const XmpParserconst XmpParser &registeredNamespacesunregisterNsregisterNsterminateinitializeuseCompactFormatXmpDataconst XmpData *setPacketusePacketeraseFamilyXmpParserXmpLockFctXmpFormatFlagsomitPacketWrapper0x0010ULreadOnlyPacket0x0020UL0x0040ULincludeThumbnailPad0x0100ULexactPacketLength0x0200ULwriteAliasComments0x0400ULomitAllFormatting0x0800ULXmpMetadataImplusePacket_xmpMetadata_p_pLockData_xmpLockFct_initialized_XMP_HPP_// #ifndef XMP_HPP_// class XmpParser// permit XmpProperties -> registerNs() and registeredNamespaces()//! Indicates if the XMP Toolkit has been initialized/*!
          @brief Get namespaces registered with XMPsdk
         *//*!
          @brief Delete a namespace from the XMP Toolkit.

          XmpProperties::unregisterNs calls this to synchronize namespaces.
        *//*!
          @brief Register a namespace with the XMP Toolkit.
         *//*!
          @brief Terminate the XMP Toolkit and unregister custom namespaces.

          Call this method when the XmpParser is no longer needed to
          allow the XMP Toolkit to cleanly shutdown.
         *//*!
          @brief Initialize the XMP Toolkit.

          Calling this method is usually not needed, as encode() and
          decode() will initialize the XMP Toolkit if necessary.

          The function takes optional pointers to a callback function
          \em xmpLockFct and related data \em pLockData that the parser
          uses when XMP namespaces are subsequently registered.

          The initialize() function itself still is not thread-safe and
          needs to be called in a thread-safe manner (e.g., on program
          startup), but if used with suitable additional locking
          parameters, any subsequent registration of namespaces will be
          thread-safe.

          Example usage on Windows using a critical section:

          @code
          void main()
          {
              struct XmpLock
              {
                  CRITICAL_SECTION cs;
                  XmpLock()  { InitializeCriticalSection(&cs); }
                  ~XmpLock() { DeleteCriticalSection(&cs); }

                  static void LockUnlock(void* pData, bool fLock)
                  {
                      XmpLock* pThis = reinterpret_cast<XmpLock*>(pData);
                      if (pThis)
                      {
                          (fLock) ? EnterCriticalSection(&pThis->cs)
                                  : LeaveCriticalSection(&pThis->cs);
                      }
                  }
              } xmpLock;

              // Pass the locking mechanism to the XMP parser on initialization.
              // Note however that this call itself is still not thread-safe.
              Exiv2::XmpParser::initialize(XmpLock::LockUnlock, &xmpLock);

              // Program continues here, subsequent registrations of XMP
              // namespaces are serialized using xmpLock.

          }
          @endcode

          @return True if the initialization was successful, else false.
         *//*!
          @brief Lock/unlock function type

          A function of this type can be passed to initialize() to
          make subsequent registration of XMP namespaces thread-safe.
          See the initialize() function for more information.

          @param pLockData Pointer to the pLockData passed to initialize()
          @param lockUnlock Indicates whether to lock (true) or unlock (false)
         *//*!
          @brief Encode (serialize) XMP metadata from \em xmpData into a
                 string xmpPacket. The XMP packet returned in the string
                 follows the XMP specification. This method only modifies
                 \em xmpPacket if the operations succeeds (return code 0).

          @param xmpPacket   Reference to a string to hold the encoded XMP
                             packet.
          @param xmpData     XMP properties to encode.
          @param formatFlags Flags that control the format of the XMP packet,
                             see enum XmpFormatFlags.
          @param padding     Padding length.
          @return 0 if successful;<BR>
                  1 if XMP support has not been compiled-in;<BR>
                  2 if the XMP toolkit failed to initialize;<BR>
                  3 if the XMP toolkit failed and raised an XMP_Error
        *//*!
          @brief Decode XMP metadata from an XMP packet \em xmpPacket into
                 \em xmpData. The format of the XMP packet must follow the
                 XMP specification. This method clears any previous contents
                 of \em xmpData.

          @param xmpData   Container for the decoded XMP properties
          @param xmpPacket The raw XMP packet to decode
          @return 0 if successful;<BR>
                  1 if XMP support has not been compiled-in;<BR>
                  2 if the XMP toolkit failed to initialize;<BR>
                  3 if the XMP toolkit failed and raised an XMP_Error
        *///!< Omit all formatting whitespace.//!< Show aliases as XML comments.//!< The padding parameter is the overall packet length.//!< Include a padding allowance for a thumbnail image.//!< Use a compact form of RDF.//!< Default is a writeable packet.//!< Omit the XML packet wrapper.//! Options to control the format of the serialized XMP packet./*!
      @brief Stateless parser class for XMP packets. Images use this
             class to parse and serialize XMP packets. The parser uses
             the XMP toolkit to do the job.
     */// class XmpData// ! getPacket//! setPacket//! set usePacket_//! are we to use the packet?//! Return true if there is no XMP metadata/*!
          @brief Find the first Xmpdatum with the given key, return a const
                 iterator to it.
         *//*!
          @brief Find the first Xmpdatum with the given key, return an iterator
                 to it.
         *///! Delete all Xmpdatum instances resulting in an empty container./*!
          @brief Delete the Xmpdatum at iterator position pos and update pos
                 erases all following keys from the same family
                 See: https://github.com/Exiv2/exiv2/issues/521
         *//*
        @brief Delete the Xmpdatum at iterator position pos, return the
                position of the next Xmpdatum.

        @note  Iterators into the metadata, including pos, are potentially
                invalidated by this call.
        @brief Delete the Xmpdatum at iterator position pos and update pos
        *//*!
          @brief Add a copy of the Xmpdatum to the XMP metadata.
          @return 0 if successful.
         *//*!
          @brief Add an %Xmpdatum from the supplied key and value pair. This
                 method copies (clones) the value.
          @return 0 if successful.
         *//*!
          @brief Returns a reference to the %Xmpdatum that is associated with a
                 particular \em key. If %XmpData does not already contain such
                 an %Xmpdatum, operator[] adds object \em Xmpdatum(key).

          @note  Since operator[] might insert a new element, it can't be a const
                 member function.
         *///! XmpMetadata const iterator type//! XmpMetadata iterator type/*!
      @brief A container for XMP data. This is a top-level class of
             the %Exiv2 library.

      Provide high-level access to the XMP data of an image:
      - read XMP information from an XML block
      - access metadata through keys and standard C++ iterators
      - add, modify and delete metadata
      - serialize XMP data to an XML block
    */// class Xmpdatum// Pimpl idiom//! The Exif typeSize doesn't make sense here. Return 0.// Todo: Remove this method from the baseclass//! Properties don't have a tag number. Return 0.//! Return the property name.//! Return the (preferred) schema namespace prefix./*!
          @brief Return the key of the Xmpdatum. The key is of the form
                 '<b>Xmp</b>.prefix.property'. Note however that the
                 key is not necessarily unique, i.e., an XmpData object may
                 contain multiple metadata with the same key.
         *///! Not implemented. Calling this method will raise an exception./*!
          @brief Set the value to the string \em value. Uses Value::read(const
                 std::string&).  If the %Xmpdatum does not have a Value yet,
                 then a %Value of the correct type for this %Xmpdatum is
                 created. If the key is unknown, a XmpTextValue is used as
                 default. Return 0 if the value was read successfully.
         *//*!
          @brief Assign Value \em value to the %Xmpdatum.
                 Calls setValue(const Value*).
         *//*!
          @brief Assign a \em value of any type with an output operator
                 to the %Xmpdatum. Calls operator=(const std::string&).
         *//*!
          @brief Assign a boolean \em value to the %Xmpdatum.
                 Translates the value to a string "true" or "false".
         *//*!
          @brief Assign const char* \em value to the %Xmpdatum.
                 Calls operator=(const std::string&).
         *//*!
          @brief Assign std::string \em value to the %Xmpdatum.
                 Calls setValue(const std::string&).
         *//*!
          @brief Constructor for new tags created by an application. The
                 %Xmpdatum is created from a key / value pair. %Xmpdatum
                 copies (clones) the value if one is provided. Alternatively, a
                 program can create an 'empty' %Xmpdatum with only a key and
                 set the value using setValue().

          @param key The key of the %Xmpdatum.
          @param pValue Pointer to a %Xmpdatum value.
          @throw Error if the key cannot be parsed and converted
                 to a known schema namespace prefix and property name.
         *//*!
      @brief Information related to an XMP property. An XMP metadatum consists
             of an XmpKey and a Value and provides methods to manipulate these.
     *//*!
  @file    xmp.hpp
  @brief   Encoding and decoding of XMP data
  @author  Andreas Huggel (ahu)
           <a href="mailto:ahuggel@gmx.net">ahuggel@gmx.net</a>
  @date    13-Jul-07, ahu: created
 */xmpLockFctpLockDataformatFlagspaddingxmpdatum/Users/owura/Repos/codeql_eval/proj_repos/Exiv2-exiv2-pull-962-commits-e925bc5addd881543fa503470c8a859e112cca62/exiv2/samples/xmpdump.cpp: No XMP packet found in the file": No XMP packet found in the file"// Sample program to dump the XMP packet of an image// xmpdump.cpp/Users/owura/Repos/codeql_eval/proj_repos/Exiv2-exiv2-pull-962-commits-e925bc5addd881543fa503470c8a859e112cca62/exiv2/samples/xmpparse.cpp: Failed to parse file contents (XMP packet)": Failed to parse file contents (XMP packet)": No XMP properties found in the XMP packet": No XMP properties found in the XMP packet"// Read an XMP packet from a file, parse it and print all (known) properties.// xmpparse.cpp/Users/owura/Repos/codeql_eval/proj_repos/Exiv2-exiv2-pull-962-commits-e925bc5addd881543fa503470c8a859e112cca62/exiv2/samples/xmpparser-test.cpp-----> Decoding XMP data read from "-----> Decoding XMP data read from " <-----
" <-----\n"-new"-new"-----> Encoding XMP data to write to "-----> Encoding XMP data to write to ": Failed to encode the XMP data": Failed to encode the XMP data"Exiv2::kerCallFailedFileIo::write"FileIo::write"// Read an XMP packet from a file, parse and re-serialize it.// xmpparser-test.cpp/Users/owura/Repos/codeql_eval/proj_repos/Exiv2-exiv2-pull-962-commits-e925bc5addd881543fa503470c8a859e112cca62/exiv2/samples/xmpprint.cpp: No XMP data found in the file": No XMP data found in the file"// ========================================================================//      g++ -o xmprint xmprint.cpp `pkg-config --cflags --libs exiv2`// Linux standalone compilation : // all (known) properties.// Read an XMP from a video or graphic file, parse it and print // xmpprint.cpp/Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX.sdk/usr/include/c++/v1/cmath/Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX.sdk/usr/include/c++/v1/math.h/Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX.sdk/usr/include/math.h/Users/owura/Repos/codeql_eval/proj_repos/Exiv2-exiv2-pull-962-commits-e925bc5addd881543fa503470c8a859e112cca62/exiv2/samples/xmpsample.cpp<cmath>xmpData["Xmp.dc.one"].toLong() == -1xmpData["Xmp.dc.one"].value().ok()getv1isEqual(getv1.toFloat(), -1)getv1.ok()getv1.toRational() == Exiv2::Rational(-1, 1)getv2isEqual(getv2.toFloat(), 3.1415f)getv2.ok()getv2.toLong() == 3RisEqual(static_cast<float>(R.first) / R.second, 3.1415f )getv3isEqual(getv3.toFloat(), 5.0f/7.0f)getv3.ok()getv3.toLong() == 0getv3.toRational() == Exiv2::Rational(5, 7)getv6getv6.toLong() == 0getv6.ok()getv6.toFloat() == 0.0fgetv6.toRational() == Exiv2::Rational(0, 1)!getv7.ok()getv8getv8.toLong() == 1getv8.ok()getv8.toFloat() == 1.0fgetv8.toRational() == Exiv2::Rational(1, 1)Seven"Seven"Xmp.dc.one"Xmp.dc.one"Xmp.dc.two"Xmp.dc.two"Xmp.dc.three"Xmp.dc.three"Xmp.dc.six"Xmp.dc.six"getv7Xmp.dc.seven"Xmp.dc.seven"Xmp.dc.eight"Xmp.dc.eight"tv"16"Xmp.dc.source"Xmp.dc.source"xmpsample.cpp"xmpsample.cpp"Xmp.dc.subject"Xmp.dc.subject"Palmtree"Palmtree"Rubbertree"Rubbertree"Xmp.dc.title"Xmp.dc.title"lang=de-DE Sonnenuntergang am Strand"lang=de-DE Sonnenuntergang am Strand"lang=en-US Sunset on the beach"lang=en-US Sunset on the beach"const double &3.1415000000000001813.1415const unsigned shortconst unsigned short &Xmp.dc.four"Xmp.dc.four"uint16_t(255)Xmp.dc.five"Xmp.dc.five"image/jpeg"image/jpeg"Xmp.dc.format"Xmp.dc.format"1) The first creator"1) The first creator"2) The second creator"2) The second creator"3) And another one"3) And another one"Xmp.dc.creator"Xmp.dc.creator"lang=de-DE Hallo, Welt"lang=de-DE Hallo, Welt"Hello, World"Hello, World"Xmp.dc.description"Xmp.dc.description"Xmp.tiff.ImageDescription"Xmp.tiff.ImageDescription"TIFF image description"TIFF image description"lang=de-DE TIFF Bildbeschreibung"lang=de-DE TIFF Bildbeschreibung"myNamespace/"myNamespace/""ns"Xmp.ns.myProperty"Xmp.ns.myProperty"myValue"myValue"Xmp.xmpDM.videoFrameSize/stDim:w"Xmp.xmpDM.videoFrameSize/stDim:w"const XmpValue *XmpValue *"9"Xmp.xmpDM.videoFrameSize/stDim:h"Xmp.xmpDM.videoFrameSize/stDim:h"inch"inch"Xmp.xmpDM.videoFrameSize/stDim:unit"Xmp.xmpDM.videoFrameSize/stDim:unit"Xmp.dc.publisher"Xmp.dc.publisher"James Bond"James Bond"Xmp.dc.publisher[1]/?ns:role"Xmp.dc.publisher[1]/?ns:role"secret agent"secret agent"programmer"programmer"Xmp.dc.creator[2]/?ns:role"Xmp.dc.creator[2]/?ns:role"Exiv2::XmpValue::xaBagXmp.xmpBJ.JobRef"Xmp.xmpBJ.JobRef"Exiv2::XmpValue::xaNoneBirthday party"Birthday party"Xmp.xmpBJ.JobRef[1]/stJob:name"Xmp.xmpBJ.JobRef[1]/stJob:name"Photographer"Photographer"Xmp.xmpBJ.JobRef[1]/stJob:role"Xmp.xmpBJ.JobRef[1]/stJob:role"Wedding ceremony"Wedding ceremony"Xmp.xmpBJ.JobRef[2]/stJob:name"Xmp.xmpBJ.JobRef[2]/stJob:name"Best man"Best man"Xmp.xmpBJ.JobRef[2]/stJob:role"Xmp.xmpBJ.JobRef[2]/stJob:role"Xmp.iptc.CreatorContactInfo/Iptc4xmpCore:CiAdrCity"Xmp.iptc.CreatorContactInfo/Iptc4xmpCore:CiAdrCity"Kuala Lumpur"Kuala Lumpur"Xmp.iptc.CreatorContactInfo/Iptc4xmpCore:CiAdrCtry"Xmp.iptc.CreatorContactInfo/Iptc4xmpCore:CiAdrCtry"Malaysia"Malaysia"Xmp.iptc.CreatorContactInfo/Iptc4xmpCore:CiUrlWork"Xmp.iptc.CreatorContactInfo/Iptc4xmpCore:CiUrlWork"http://www.exiv2.org"http://www.exiv2.org"Failed to serialize XMP data"Failed to serialize XMP data"const char(&)[29]char(&)[29]isEqual1.000000000000000082e-050.00001// Serialize the XMP data and output the XMP packet// -------------------------------------------------------------------------// Output XMP properties// Add a creator contact info structure// Set the array type.// Clear the value// Add an array of structures// Add a qualifer to an array element of Xmp.dc.creator (added above)// creates an unordered array// Add an element with a qualifier (using the namespace registered above)// Add a structure// the key.// types. However, these can be added by using an XmpTextValue and a path as// There are no specialized values for structures, qualifiers and nested// Add a property in the new custom namespace.// image, namespaces are decoded and registered at the same time.// when properties are added manually. If the XMP metadata is read from an// Register a namespace which Exiv2 doesn't know yet. This is only needed// behaviour if desired.// other property and leaves it to the application to implement specific// alias for Xmp.dc.description. Exiv2 treats an alias just like any// According to the XMP specification, Xmp.tiff.ImageDescription is an// qualifier// The default doesn't need a// Add a language alternative property// order in the array.// elements are added is their// The sequence in which the array// or xmpBag or xmpAlt.// Add an ordered array of text values.// Add a simple XMP property in a known namespace// properties and language alternatives.// Exiv2 has specialized values for simple XMP properties, arrays of simple// Deleting an XMP property// this should fail// long(5.0 / 7.0)// Extracting values// In addition, there is a dedicated assignment operator for Exiv2::Value// default XMP value type for unknown properties is a simple text value.// type can be assigned to an Xmpdatum, if they have an output operator. The// Any properties can be set provided the namespace is known. Values of any// a language alternative with two entries and without default// add a 2nd array item// an array item// a simple text value// Teaser: Setting XMP properties doesn't get much easier than this:// The XMP property container// Sample/test for high level XMP classes. See also addmoddel.cpp// xmpsample.cpp<system_error>set_rdbufios_base *copyfmtconst ios_baseconst ios_base &__call_callbacksconst ios_base *__set_failbit_and_consider_rethrowbadbadbitfailfailbitfailbit | badbit(failbit | badbit)eofbitgoodbitrdstatesync_with_stdioregister_callback~ios_basepwordiwordxallocprecisionunsetfsetfInit &const Initconst Init &Init~Initfailure &const failureconst failure &~failurefailurefailure *io_errc::streamdefaultfloatios_base::floatfieldhexfloatios_base::fixedios_base::scientificios_base::fixed | ios_base::scientificscientificfixedoctios_base::octios_base::basefieldhexios_base::hexdecios_base::decrightios_base::rightios_base::adjustfieldleftios_base::leftinternalios_base::internalnounitbufios_base::unitbufunitbufnouppercaseios_base::uppercaseuppercasenoskipwsios_base::skipwsskipwsnoshowposios_base::showposshowposnoshowpointios_base::showpointshowpointnoshowbaseios_base::showbaseshowbasenoboolalphaios_base::boolalphaboolalpha__throw_failuremake_error_conditionconst io_errcconst error_categoryconst error_category &error_category &make_error_codeiostream_categoryis_error_code_enumis_error_code_enum<__lx> &const is_error_code_enum<__lx>const is_error_code_enum<__lx> &is_error_code_enum<io_errc> &const is_error_code_enum<io_errc>const is_error_code_enum<io_errc> &io_errc &const io_errc &io_errcoperator intconst io_errc *io_errc *basic_ios<_CharT, _Traits> &&basic_ios<_CharT, _Traits> *basic_iosconst basic_ios<_CharT, _Traits>const basic_ios<_CharT, _Traits> *narrowconst basic_ios<_CharT, _Traits> &tie~basic_iosoperator!operator void *event_callbackeventerase_eventimbue_eventcopyfmt_eventseek_diropen_modeio_stateis_error_code_enum<__lx>is_error_code_enum<io_errc>openmodecuriostatestreamsizeevent_callback *..(**)(..)__fn___index___event_size___event_cap___iarray___iarray_size___iarray_cap___parray___parray_size___parray_cap___tie___rdbuf___exceptions___rdstate___width___precision___xindex_trunc0x08binaryateapp0x0floatfieldscientific | fixedbasefielddec | octdec | oct | hexadjustfieldleft | rightleft | right | internal__iostate__wide__prec__mask__fmtfl__msg__dfault__tiestr_LIBCPP_IOSdefined(_LIBCPP_HAS_C_ATOMIC_IMP) && !defined(_LIBCPP_HAS_NO_THREADS)// _LIBCPP_IOS// purposefully does no initialization// 27.5.4.2 Members:// 27.5.4.1 Constructor/destructor:// and implicitly convert to bool, but not implicitly convert to int.// Preserve the ability to compare with literal 0,// iostate// width// precision// fmtflags//enum class io_errc// enabled with clang.// TODO(EricWF): Enable this for both Clang and GCC. Currently it is only// All data members must be scalars// 27.5.2.6 callbacks;// destructor// 27.5.2.5 storage:// 27.5.2.3 locales:// 27.5.2.2 fmtflags state:// for __xindex_/*
    ios synopsis

#include <iosfwd>

namespace std
{

typedef OFF_T streamoff;
typedef SZ_T streamsize;
template <class stateT> class fpos;

class ios_base
{
public:
    class failure;

    typedef T1 fmtflags;
    static constexpr fmtflags boolalpha;
    static constexpr fmtflags dec;
    static constexpr fmtflags fixed;
    static constexpr fmtflags hex;
    static constexpr fmtflags internal;
    static constexpr fmtflags left;
    static constexpr fmtflags oct;
    static constexpr fmtflags right;
    static constexpr fmtflags scientific;
    static constexpr fmtflags showbase;
    static constexpr fmtflags showpoint;
    static constexpr fmtflags showpos;
    static constexpr fmtflags skipws;
    static constexpr fmtflags unitbuf;
    static constexpr fmtflags uppercase;
    static constexpr fmtflags adjustfield;
    static constexpr fmtflags basefield;
    static constexpr fmtflags floatfield;

    typedef T2 iostate;
    static constexpr iostate badbit;
    static constexpr iostate eofbit;
    static constexpr iostate failbit;
    static constexpr iostate goodbit;

    typedef T3 openmode;
    static constexpr openmode app;
    static constexpr openmode ate;
    static constexpr openmode binary;
    static constexpr openmode in;
    static constexpr openmode out;
    static constexpr openmode trunc;

    typedef T4 seekdir;
    static constexpr seekdir beg;
    static constexpr seekdir cur;
    static constexpr seekdir end;

    class Init;

    // 27.5.2.2 fmtflags state:
    fmtflags flags() const;
    fmtflags flags(fmtflags fmtfl);
    fmtflags setf(fmtflags fmtfl);
    fmtflags setf(fmtflags fmtfl, fmtflags mask);
    void unsetf(fmtflags mask);

    streamsize precision() const;
    streamsize precision(streamsize prec);
    streamsize width() const;
    streamsize width(streamsize wide);

    // 27.5.2.3 locales:
    locale imbue(const locale& loc);
    locale getloc() const;

    // 27.5.2.5 storage:
    static int xalloc();
    long& iword(int index);
    void*& pword(int index);

    // destructor
    virtual ~ios_base();

    // 27.5.2.6 callbacks;
    enum event { erase_event, imbue_event, copyfmt_event };
    typedef void (*event_callback)(event, ios_base&, int index);
    void register_callback(event_callback fn, int index);

    ios_base(const ios_base&) = delete;
    ios_base& operator=(const ios_base&) = delete;

    static bool sync_with_stdio(bool sync = true);

protected:
    ios_base();
};

template <class charT, class traits = char_traits<charT> >
class basic_ios
    : public ios_base
{
public:
    // types:
    typedef charT char_type;
    typedef typename traits::int_type int_type;  // removed in C++17
    typedef typename traits::pos_type pos_type;  // removed in C++17
    typedef typename traits::off_type off_type;  // removed in C++17
    typedef traits traits_type;

    operator unspecified-bool-type() const;
    bool operator!() const;
    iostate rdstate() const;
    void clear(iostate state = goodbit);
    void setstate(iostate state);
    bool good() const;
    bool eof() const;
    bool fail() const;
    bool bad() const;

    iostate exceptions() const;
    void exceptions(iostate except);

    // 27.5.4.1 Constructor/destructor:
    explicit basic_ios(basic_streambuf<charT,traits>* sb);
    virtual ~basic_ios();

    // 27.5.4.2 Members:
    basic_ostream<charT,traits>* tie() const;
    basic_ostream<charT,traits>* tie(basic_ostream<charT,traits>* tiestr);

    basic_streambuf<charT,traits>* rdbuf() const;
    basic_streambuf<charT,traits>* rdbuf(basic_streambuf<charT,traits>* sb);

    basic_ios& copyfmt(const basic_ios& rhs);

    char_type fill() const;
    char_type fill(char_type ch);

    locale imbue(const locale& loc);

    char narrow(char_type c, char dfault) const;
    char_type widen(char c) const;

    basic_ios(const basic_ios& ) = delete;
    basic_ios& operator=(const basic_ios&) = delete;

protected:
    basic_ios();
    void init(basic_streambuf<charT,traits>* sb);
    void move(basic_ios& rhs);
    void swap(basic_ios& rhs) noexcept;
    void set_rdbuf(basic_streambuf<charT, traits>* sb);
};

// 27.5.5, manipulators:
ios_base& boolalpha (ios_base& str);
ios_base& noboolalpha(ios_base& str);
ios_base& showbase (ios_base& str);
ios_base& noshowbase (ios_base& str);
ios_base& showpoint (ios_base& str);
ios_base& noshowpoint(ios_base& str);
ios_base& showpos (ios_base& str);
ios_base& noshowpos (ios_base& str);
ios_base& skipws (ios_base& str);
ios_base& noskipws (ios_base& str);
ios_base& uppercase (ios_base& str);
ios_base& nouppercase(ios_base& str);
ios_base& unitbuf (ios_base& str);
ios_base& nounitbuf (ios_base& str);

// 27.5.5.2 adjustfield:
ios_base& internal (ios_base& str);
ios_base& left (ios_base& str);
ios_base& right (ios_base& str);

// 27.5.5.3 basefield:
ios_base& dec (ios_base& str);
ios_base& hex (ios_base& str);
ios_base& oct (ios_base& str);

// 27.5.5.4 floatfield:
ios_base& fixed (ios_base& str);
ios_base& scientific (ios_base& str);
ios_base& hexfloat (ios_base& str);
ios_base& defaultfloat(ios_base& str);

// 27.5.5.5 error reporting:
enum class io_errc
{
    stream = 1
};

concept_map ErrorCodeEnum<io_errc> { };
error_code make_error_code(io_errc e) noexcept;
error_condition make_error_condition(io_errc e) noexcept;
storage-class-specifier const error_category& iostream_category() noexcept;

}  // std

*///===---------------------------- ios -------------------------------------===//__sync__fn__indexconst __tree_iterator<int, __tree_node<int, void *> *, long>const __tree_iterator<int, __tree_node<int, void *> *, long> &__tree_iterator<int, __tree_node<int, void *> *, long> &const __tree_const_iterator<int, __tree_node<int, void *> *, long>const __tree_const_iterator<int, __tree_node<int, void *> *, long> &__tree_const_iterator<int, __tree_node<int, void *> *, long> &const __tree_const_iterator<__value_type<TaskType, Task *>, __tree_node<__value_type<TaskType, Task *>, void *> *, long>const __tree_const_iterator<__value_type<TaskType, Task *>, __tree_node<__value_type<TaskType, Task *>, void *> *, long> &__tree_const_iterator<__value_type<TaskType, Task *>, __tree_node<__value_type<TaskType, Task *>, void *> *, long> &const __tree_iterator<__value_type<TaskType, Task *>, __tree_node<__value_type<TaskType, Task *>, void *> *, long>const __tree_iterator<__value_type<TaskType, Task *>, __tree_node<__value_type<TaskType, Task *>, void *> *, long> &__tree_iterator<__value_type<TaskType, Task *>, __tree_node<__value_type<TaskType, Task *>, void *> *, long> &const __map_const_iterator<__tree_const_iterator<__value_type<TaskType, Task *>, __tree_node<__value_type<TaskType, Task *>, void *> *, long>>const __map_const_iterator<__tree_const_iterator<__value_type<TaskType, Task *>, __tree_node<__value_type<TaskType, Task *>, void *> *, long>> &__map_const_iterator<__tree_const_iterator<__value_type<TaskType, Task *>, __tree_node<__value_type<TaskType, Task *>, void *> *, long>> &const __map_iterator<__tree_iterator<__value_type<TaskType, Task *>, __tree_node<__value_type<TaskType, Task *>, void *> *, long>>const __map_iterator<__tree_iterator<__value_type<TaskType, Task *>, __tree_node<__value_type<TaskType, Task *>, void *> *, long>> &__map_iterator<__tree_iterator<__value_type<TaskType, Task *>, __tree_node<__value_type<TaskType, Task *>, void *> *, long>> &const set<_Key, _Compare, _Allocator> */Users/owura/Repos/codeql_eval/proj_repos/Exiv2-exiv2-pull-962-commits-e925bc5addd881543fa503470c8a859e112cca62/exiv2/src/actions.hpp"exiv2app.hpp"FixCom &const FixComconst FixCom &FixComFixCom *Taskconst Taskconst Task &Task &Task *FixIso &const FixIsoconst FixIso &FixIsoFixIso *Modify &const Modifyconst Modify &ModifyModify *Insert &const Insertconst Insert &InsertInsert *Extract &const Extractconst Extract &ExtractExtract *Erase &const Eraseconst Erase &EraseErase *Adjust &const Adjustconst Adjust &Adjust *Rename &const Renameconst Rename &RenameRename *Print &const Printconst Print &PrintPrint *TaskFactory &const TaskFactoryconst TaskFactory &~TaskFactoryTaskFactory *TaskFactoryrunTaskTyperenameextractmodifyfixisofixcomRegistrypath_dayAdjustment_monthAdjustment_yearAdjustment_adjustment_align_registry_ACTIONS_HPP_Actionconst FixCom *~FixComconst FixIso *~FixIsoregNamespaceconst ModifyCmdconst ModifyCmd &ModifyCmd &delMetadatumsetMetadatumaddMetadatumconst Modify *applyCommands~Modifyconst Insert *insertIccProfileinsertXmpPacketinsertThumbnail~Insertconst Extract *writeIccProfilewritePreviewFilewritePreviewswriteThumbnail~Extractconst Erase *eraseIccProfileeraseXmpDataeraseCommenteraseIptcDataeraseExifDataeraseThumbnail~EraseadjustDateTimeconst Adjust *~Adjustconst Rename *~Renameconst Print *printTagprintLabelprintMetadatumprintMetadatakeyTaggrepTagprintListprintSummaryprintPreviewListprintComment~Printinstance_registerTaskcleanupinstanceconst Task *~Task// #ifndef ACTIONS_HPP_// namespace Action// class FixCom/*!
      @brief Fix the character encoding of Exif UNICODE user comments.
             Decodes the comment using the auto-detected or specified
             character encoding and writes it back in UCS-2.
     */// class FixIso/*!
      @brief %Copy ISO settings from any of the Nikon makernotes to the
             regular Exif tag, Exif.Photo.ISOSpeedRatings.
     */// class Modify//! Register an XMP namespace according to \em modifyCmd//! Delete a metadatum from \em pImage according to \em modifyCmd//! Set a metadatum in \em pImage according to \em modifyCmd//! Add a metadatum to \em pImage according to \em modifyCmd/*src*///! Copy constructor needed because of AutoPtr member//! Apply modification commands to the \em pImage, return 0 if successful./*!
      @brief %Modify the Exif data according to the commands in the
             modification table.
     */// class Insert/*!
          @brief Insert an ICC profile from binary DataBuf into file \em path.
         *//*!
          @brief Insert an ICC profile from iccPath into file \em path.
         *//*!
          @brief Insert xmp from a DataBuf into file \em path.
         *//*!
          @brief Insert an XMP packet from a xmpPath into file \em path.
         *//*!
          @brief Insert a Jpeg thumbnail image from a file into file \em path.
                 The filename of the thumbnail is expected to be the image
                 filename (\em path) minus its suffix plus "-thumb.jpg".
         *//*!
      @brief %Insert the Exif data from corresponding *.exv files.
     */// class Extract/*!
          @brief Write embedded iccProfile files.
         *//*!
          @brief Write one preview image to a file. The filename is composed by
                 removing the suffix from the image filename and appending
                 "-preview<num>" and the appropriate suffix (".jpg" or ".tif"),
                 depending on the format of the Exif thumbnail image.
         *//*!
          @brief Write preview images to files.
         *//*!
          @brief Write the thumbnail image to a file. The filename is composed by
                 removing the suffix from the image filename and appending
                 "-thumb" and the appropriate suffix (".jpg" or ".tif"), depending
                 on the format of the Exif thumbnail image.
         *//*!
      @brief %Extract the entire exif data or only the thumbnail section.
     */// class Erase/*!
          @brief Erase ICCProfile from the file.
         *//*!
          @brief Erase XMP packet from the file.
         *//*!
          @brief Erase Jpeg comment from the file.
         *//*!
          @brief Erase all Iptc data from the file.
         *//*!
          @brief Erase the complete Exif data block from the file.
         *//*!
          @brief Delete the thumbnail image, incl IFD1 metadata from the file.
         *//*!
      @brief %Erase the entire exif data or only the thumbnail section.
     */// class Adjust//! %Adjust the Exif (or other metadata) timestamps// class Rename/*!
      @brief %Rename a file to its metadate creation timestamp,
             in the specified format.
     */// class Print// for the alignment of the summary output/*!
          @brief Print one summary line with a label (if provided) and requested
                 data. A line break is printed only if a label is provided.
          @return 1 if a line was written, 0 if the information was not found.
         *///! Type for an Exiv2 Easy access function/*!
          @brief Print one summary line with a label (if provided) and requested
                 data. A line break is printed only if a label is provided.
          @return 1 if a line was written, 0 if the key was not found.
         *///! Print the label for a summary line//! Print a metadatum in a user defined format, return true if something was printed//! Print all metadata in a user defined format//! Return true if key should be printed, else false//! Print Exif, IPTC and XMP metadata in user defined format//! Print Exif summary information//! Print list of available preview images//! Print the Jpeg comment//! %Print the Exif (or other metadata) of a file to stdout// class TaskFactory//! List of task types and corresponding prototypes.//! Type used to store Task prototype classes//! Pointer to the one and only instance of this class.//! Prevent construction other than through instance()./*!
          @brief Register a task prototype together with its type.

          The task factory creates new tasks of a given type by cloning its
          associated prototype. Additional tasks can be registered.  If called
          for a type which already exists in the list, the corresponding
          prototype is replaced.

          @param type Task type.
          @param task Pointer to the prototype. Ownership is transferred to the
                 task factory. That's what the auto pointer indicates.
        *//*!
          @brief  Create a task.

          @param  type Identifies the type of task to create.
          @return An auto pointer that owns a task of the requested type.  If
                  the task type is not supported, the pointer is 0.
          @remark The caller of the function should check the content of the
                  returned auto pointer and take appropriate action (e.g., throw
                  an exception) if it is 0.
         *//*!
          @brief Get access to the task factory.

          Clients access the task factory exclusively through
          this method.
        *//*!
      @brief Task factory.

      Creates an instance of the task of the requested type.  The factory is
      implemented as a singleton, which can be accessed only through the static
      member function instance().
    */// class Task/*!
          @brief Application interface to perform a task.

          @param path Path of the file to process.
          @return 0 if successful.
         *///! Virtual copy construction.//! Shortcut for an auto pointer./*!
      @brief Abstract base class for all concrete actions.

      Task provides a simple interface that actions must implement and a few
      commonly used helpers.
     *///! Enumerates all tasks/*!
  @brief Contains all action classes (task subclasses).
 *//*!
  @file    actions.hpp
  @brief   Implements base class Task, TaskFactory and the various supported
           actions (derived from Task).
  @author  Andreas Huggel (ahu)
           <a href="mailto:ahuggel@gmx.net">ahuggel@gmx.net</a>
  @date    11-Dec-03, ahu: created
 */modifyCmdpImageiccProfileBlobiccPathxmpBlobxmpPathpvImgeasyAccessFctlabeltaskbasic_ofstream<_CharT, _Traits> */Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX.sdk/usr/include/utime.hutimeconst utimbufconst utimbuf *utimbuf *utimbuf &const utimbuf &utimbufmodtimeactime_UTIME_H_/* !_UTIME_H_ *//* Modification time *//* Access time *//*-
 * Copyright (c) 1990, 1993
 *	The Regents of the University of California.  All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *	This product includes software developed by the University of
 *	California, Berkeley and its contributors.
 * 4. Neither the name of the University nor the names of its contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 *
 *	@(#)utime.h	8.1 (Berkeley) 6/2/93
 *//Users/owura/Repos/codeql_eval/proj_repos/Exiv2-exiv2-pull-962-commits-e925bc5addd881543fa503470c8a859e112cca62/exiv2/src/exiv2app.hpp/Users/owura/Repos/codeql_eval/proj_repos/Exiv2-exiv2-pull-962-commits-e925bc5addd881543fa503470c8a859e112cca62/exiv2/src/i18n.h/usr/local/Cellar/gettext/0.20.2_1/include/libintl.h867868869870871872873874875876877878879880881882/Users/owura/Repos/codeql_eval/proj_repos/Exiv2-exiv2-pull-962-commits-e925bc5addd881543fa503470c8a859e112cca62/exiv2/src/actions.cpp<utime.h><ctime>"i18n.h""futils.hpp""preview.hpp""easyaccess.hpp""xmpsidecar.hpp""jpgimage.hpp""actions.hpp""Failed to open the file\n": ": "Failed to open the file
minChCountdontOverwrite"Overwrite"Overwrite `" `"'? "'? "'y''Y'newFilePathExiv2::pFilerenameFile:basename:":basename:":dirname:":dirname:":parentname:":parentname:"basename"Filename format yields empty filename for the file"Filename format yields empty filename for the file"This file already has the correct name"This file already has the correct namegoseqfileExistsPolicy"File""exists. [O]verwrite, [r]ename or [s]kip?"Params::overwritePolicyParams::renamePolicyParams::askPolicyFileexists. [O]verwrite, [r]ename or [s]kip?strAndWidthnewPath"Renaming file to""updating timestamp"Renaming file toupdating timestamp"Failed to rename"Failed to renamemetacopybStdinbStdoutstdInioStdinsourceImagesourceImage.get() != 0targettargetImagetargetImage.get() != 0auto_ptr<Image> &"Writing Exif data from"Params::ctExifWriting Exif data from"Writing IPTC data from"Params::ctIptcWriting IPTC data from"Writing XMP data from"Params::ctXmpParams::ctXmpRawParams::ctXmp|Params::ctXmpRaw(Params::ctXmp|Params::ctXmpRaw)tRawSidecarParams::ctXmpSidecarParams::ctXmpSidecar | Params::ctXmpRawWriting XMP data fromconst vector<ModifyCmd, allocator<ModifyCmd>>Exiv2::kpsXMP"Writing JPEG comment from"Params::ctCommentWriting JPEG comment from"Could not write metadata to file"sourcetgttargetTypepreserveCould not write metadata to file_fileno(stdout)O_BINARY~basic_ofstreambasic_ofstream<char, char_traits<char>> *temporaryPathpid/tmp/"/tmp/"sCount_%d"_%d"tm2Strtime2Strstr2Tmsizeof(struct tm)(time_t)-1String &const Stringconst String &const String *String *Timestamp &const Timestampconst Timestamp &TimestamptouchTimestamp *setModeAndPrintStructure"No Exif data found in the file\n""No Exif user comment found""Found Exif user comment with unexpected value type""No Exif UNICODE user comment found""Setting Exif UNICODE user comment to"pcvcsIdNo Exif data found in the file
No Exif user comment foundFound Exif user comment with unexpected value typeExiv2::CommentValue::unicodeNo Exif UNICODE user comment foundSetting Exif UNICODE user comment to "" \""charset=""charset=\""timeStr" "\" "Exiv2 exception in fixcom action for file "Exiv2 exception in fixcom action for file ":
":\n""Standard Exif ISO tag exists; not modified\n""Setting Exif ISO value to"Exif.Photo.ISOSpeedRatings"Exif.Photo.ISOSpeedRatings"Standard Exif ISO tag exists; not modified
Setting Exif ISO value toExiv2 exception in fixiso action for file "Exiv2 exception in fixiso action for file ""Reg "Reg =""=\"""Del"DelexifexifKeyiptcxmpxmpKey"Set"" ("\" (")")"metadatum"Warning""Failed to read""value"WarningFailed to read"Add""Setting JPEG comment"Setting JPEG comment '" '"ModifyCmds &vector<ModifyCmd, allocator<ModifyCmd>> &modifyCmdsconst __wrap_iter<ModifyCmd *>const __wrap_iter<ModifyCmd *> &__wrap_iter<ModifyCmd *> &retinvalidCmdId == i->cmdId_const __wrap_iter<const ModifyCmd *>const __wrap_iter<const ModifyCmd *> &__wrap_iter<const ModifyCmd *> &delreginvalidCmdIdExiv2 exception in modify action for file "Exiv2 exception in modify action for file "iccProfilePath.icc".icc"thumbPath-thumb.jpg"-thumb.jpg"exifThumbParams::ctStdInOutParams::ctThumbsuffixexvPath.exv".exv".xmp".xmp"Exiv2::ImageType::noneParams::ctXmpSidecar|Params::ctXmpRaw(Params::ctXmpSidecar|Params::ctXmpRaw)Params::ctIccProfileExiv2 exception in insert action for file "Exiv2 exception in insert action for file ""No embedded iccProfile: ""Writing iccProfile: "No embedded iccProfile: iccFileWriting iccProfile: pvFile-preview"-preview"pvPath"Writing preview""pixels""bytes""to file"Writing previewpixels) ") "to file"Image does not have preview"Image does not have previewpvMgrpvListconst PreviewNumbersconst PreviewNumbers &set<int, less<int>, allocator<int>> &numbersconst vector<PreviewProperties, allocator<PreviewProperties>>thumbExt"Image does not contain an Exif thumbnail\n""Writing thumbnail""Bytes""Exif data doesn't contain a thumbnail\n"Image does not contain an Exif thumbnail
-thumb"-thumb"Writing thumbnailBytesExif data doesn't contain a thumbnail
_O_BINARYParams::ctPreviewExiv2::ImageType::xmpExiv2::ImageType::exvExiv2 exception in extract action for file "Exiv2 exception in extract action for file ""Erasing ICC Profile data from the file"Erasing ICC Profile data from the file"Erasing XMP data from the file"Erasing XMP data from the file"Erasing JPEG comment from the file"Erasing JPEG comment from the file"Erasing IPTC data from the file"Erasing IPTC data from the file"Erasing Exif data from the file"Erasing Exif data from the file"Erasing thumbnail data"Erasing thumbnail dataParams::ctIptcRawExiv2::kpsIptcEraseExiv2 exception in erase action for file "Exiv2 exception in erase action for file ""Timestamp of metadatum with key""not set\n"Timestamp of metadatum with keynot set
"Adjusting""by""years""year""months""month""days""day""s"commaAdjustingby +" +"yearsmonthsdays"Failed to parse timestamp"Failed to parse timestampmonOverflow"Can't adjust timestamp by"999980999999 - 1900-9001000 - 1900Can't adjust timestamp by86400YodAdjust[3]YodAdjust *Params::yodYearParams::yodMonthParams::yodDayExif.Image.DateTimeOriginal"Exif.Image.DateTimeOriginal"Exiv2 exception in adjust action for file "Exiv2 exception in adjust action for file ""Neither tag""nor""found in the file""Image file creation timestamp not set in the file""in the file""Updating timestamp to"Neither tag `Exif.Photo.DateTimeOriginal' " `Exif.Photo.DateTimeOriginal' "nor `Exif.Image.DateTime' " `Exif.Image.DateTime' "found in the fileImage file creation timestamp not set in the filein the fileUpdating timestamp toExiv2 exception in rename action for file "Exiv2 exception in rename action for file "manyFilesParams::prTagParams::prSet"set"Params::prGroupParams::prKeyParams::prNameParams::prLabelParams::prTypeParams::prCountParams::prSize"(Binary value suppressed)"Params::prValuedone(Binary value suppressed)Exiv2::CommentValue::undefinedParams::prTransParams::prHexnoExifExiv2::mdExifnoIptcExiv2::mdIptcnoXmpExiv2::mdXmp"No IPTC data found in the file\n""No XMP data found in the file\n"No IPTC data found in the file
No XMP data found in the file
const vector<regex_t, allocator<regex_t>>const __wrap_iter<const basic_string<char, char_traits<char>, allocator<char>> *>const __wrap_iter<const basic_string<char, char_traits<char>, allocator<char>> *> &__wrap_iter<const basic_string<char, char_traits<char>, allocator<char>> *> &gconst __wrap_iter<regex_t *>const __wrap_iter<regex_t *> &__wrap_iter<regex_t *> &const __wrap_iter<const regex_t *>const __wrap_iter<const regex_t *> &__wrap_iter<const regex_t *> &regmatch_t *Exiv2::mdNoneExiv2::mdExif | Exiv2::mdIptcExiv2::mdExif | Exiv2::mdIptc | Exiv2::mdXmpParams::prKey | Params::prTypeParams::prKey | Params::prType | Params::prCountParams::prKey | Params::prType | Params::prCount | Params::prTrans"File name"File name"File size"File size"MIME type"MIME type"Image size"Image size"Image timestamp"Image timestamp"Image number"Exif.Canon.FileNumber"Exif.Canon.FileNumber"Image numberExif.Photo.ExposureTime"Exif.Photo.ExposureTime"Exif.Photo.ShutterSpeedValue"Exif.Photo.ShutterSpeedValue"Exif.Photo.FNumber"Exif.Photo.FNumber""Aperture"ApertureExif.Photo.ApertureValue"Exif.Photo.ApertureValue""Exposure bias"Exif.Photo.ExposureBiasValue"Exif.Photo.ExposureBiasValue"Exposure bias"Flash"Exif.Photo.Flash"Exif.Photo.Flash"Flash"35 mm equivalent"Exif.Photo.FocalLength"Exif.Photo.FocalLength"Exif.Photo.FocalLengthIn35mmFilm"Exif.Photo.FocalLengthIn35mmFilm"35 mm equivalentExif.Canon.FocalLength"Exif.Canon.FocalLength"Exif.Photo.SubjectDistance"Exif.Photo.SubjectDistance"Exif.CanonSi.SubjectDistance"Exif.CanonSi.SubjectDistance"Exif.CanonFi.FocusDistanceLower"Exif.CanonFi.FocusDistanceLower"Exif.CanonFi.FocusDistanceUpper"Exif.CanonFi.FocusDistanceUpper"xdimydim"Exif Resolution"Exif Resolutionimage/tiff"image/tiff"Exif.Image.ImageWidth"Exif.Image.ImageWidth"Exif.Photo.PixelXDimension"Exif.Photo.PixelXDimension"Exif.Image.ImageLength"Exif.Image.ImageLength"Exif.Photo.PixelYDimension"Exif.Photo.PixelYDimension""Thumbnail"Thumbnail"None"None"Copyright""Exif comment"Exif commentcntpm"Preview"const __wrap_iter<const PreviewProperties *>const __wrap_iter<const PreviewProperties *> &__wrap_iter<const PreviewProperties *> &"JPEG comment"JPEG commentExiv2::kpsNoneParams::pmSummaryParams::pmListParams::pmCommentParams::pmPreviewParams::pmStructureExiv2::kpsBasicParams::pmRecursiveExiv2::kpsRecursiveParams::pmXMPParams::pmIccProfileExiv2::kpsIccProfileExiv2 exception in print action for file "Exiv2 exception in print action for file "const overflow_errorconst overflow_error &overflow_error &std::overflow_error exception in print action for file "std::overflow_error exception in print action for file "const char[56]const runtime_errorTaskType &Task *&Strings_modtime_actime_850045858cs_setmode(a,b)_fileno(a)(unnamed namespace)!defined(__MINGW__) && !defined(_MSC_VER)defined(PTHREAD_RECURSIVE_MUTEX_INITIALIZER)defined(PTHREAD_RECURSIVE_MUTEX_INITIALIZER_NP)// returns 0xFFFFFFFF on error// use current directory for remote files// renameFile// Workaround for MinGW rename which does not overwrite existing files// skip// Defined outside of the function so that Exiv2::find() can see it// metacopy// delete temporary target// if we used a temporary target, copy it to stdout// std::cout << "long cut" << std::endl;// http://www.cplusplus.com/doc/tutorial/files/// std::cout << "short cut" << std::endl;// printTarget("in metacopy",Params::instance().target_,true);// option -eXX// #1148 use Raw XMP packet if there are no XMP modification commands// Copy each type of metadata// Open or create the target file// Apply any modification commands to the source image on-the-fly// read the source metadata/* This is the critical section object (statically allocated). *//* Unix/Linux/Cygwin/MacOSX */// use static CS/MUTEX to make temporaryPath() thread safe// tm2Str// time2Str// str2Tm// Conversions to set remaining fields of the tm structure//! @endcond// interpret tm according to current timezone settings//! @cond IGNORE// local definitions// FixCom::run// Remove BOM and convert value from source charset to UCS-2, but keep byte order// FixIso::run// Copy the proprietary tag to the standard place// Adjust::adjustDateTime// Let's not create files with non-4-digit years, we can't read them.// Key not found. That's ok, we do nothing.// Adjust::run// or the default type// use the current type of the metadatum, if any;// If a type was explicitly requested, use it; else// empty metadatum if reading the value fails// This function looks rather complex because we try to avoid adding an// Modify::applyCommands// loop through command table and apply each command// Modify::run// Save both exif and iptc metadata// Insert::insertThumbnail// Insert::insertIccProfile// clear existing profile, assign the blob and rewrite image// read in the metadata// test path exists// for path "foo.XXX", do a binary copy of "foo.icc"// Insert::insertXmpPacket// Insert::run// -i{tgt}-  reading from stdin?// Extract::writePreviewFile// Extract::writeIccProfile// -eC-// Extract::writePreviews// Write all previews// Extract::writeThumbnail// Quick fix for bug #612// Erase::run// Thumbnail must be before Exif// Rename::run// Print::printPreviewList// Print::printComment// Print::printMetadatum// #1114 - show negative values for SByte// https://notfaq.wordpress.com/2007/08/04/cc-convert-string-to-upperlower-case/// Print::printMetadata// With -g or -K, return -3 if no matching tags were found// With -v, inform about the absence of any (requested) type of metadata// Print::printList// Set defaults for metadata types and data columns// Print::printTag// Print::printSummary// Exif Comment// Copyright// Thumbnail// White balance// Exif Resolution// Image quality setting (compression)// Macro mode// Metering mode// Exposure mode// ISO speed// Subject distance// Todo: Calculate 35 mm equivalent a la jhead// Actual focal length and 35 mm equivalent// Flash bias// Flash// Exposure bias// Get if from FNumber and, failing that, try ApertureValue// Aperture// From ExposureTime, failing that, try ShutterSpeedValue// Exposure time// Todo: Image number for cameras other than Canon// Image number// Image Timestamp// Camera model// Camera make// Image size// MIME type// Filesize// Filename// TaskFactory::create// TaskFactory c'tor// Register a prototype of each known task// TaskFactory::registerTask//TaskFactory::cleanup// TaskFactory::instance// class member definitions//! Print image Structure information/*!
      @brief Output a text with a given minimum number of chars, honoring
             multi-byte characters correctly. Replace code in the form
             os << setw(width) << myString
             with
             os << make_pair( myString, width)
     *//*!
      @brief Check if file \em path exists and whether it should be
             overwritten. Ask user if necessary. Return 1 if the file
             exists and shouldn't be overwritten, else 0.
     *//*!
      @brief Make a file path from the current file path, destination
             directory (if any) and the filename extension passed in.

      @param path Path of the existing file
      @param ext  New filename extension (incl. the dot '.' if required)
      @return 0 if successful, 1 if the new file exists and the user
             chose not to overwrite it.
     *//*!
      @brief Rename a file according to a timestamp value.

      @param path The original file path. Contains the new path on exit.
      @param tm   Pointer to a buffer with the broken-down time to rename
                  the file to.
      @return 0 if successful, -1 if the file was skipped, 1 on error.
    *//*!
      @brief Copy metadata from source to target according to Params::copyXyz

      @param source Source file path
      @param target Target file path. An *.exv file is created if target doesn't
                    exist.
      @param targetType Image type for the target image in case it needs to be
                    created.
      @param preserve Indicates if existing metadata in the target file should
                    be kept.
      @return 0 if successful, else an error code
    *///! Convert a tm structure to a string "YYYY:MM:DD HH:MI:SS", "" on error//! Convert a localtime to a string "YYYY:MM:DD HH:MI:SS", "" on error/*!
      @brief Convert a string "YYYY:MM:DD HH:MI:SS" to a struct tm type,
             returns 0 if successful
     *///! Set the timestamp of a file//! Read the timestamp from a broken-down time in buffer \em tm.//! Read the timestamp of a file//! C'tor//! Helper class to set the timestamp of a file to that of another file// for stat()// NLS support./*
  File:      actions.cpp
 */pair<const TaskType, Task *>const TaskTypeconst pair<const TaskType, Task *>const pair<const TaskType, Task *> &pair<const TaskType, Task *> &auto_ptr_ref<Print>auto_ptr_ref<Print> &const auto_ptr_ref<Print>const auto_ptr_ref<Print> &__wrap_iter<const PreviewProperties *>const PreviewProperties *__wrap_iter<regex_t *>__wrap_iter<regex_t *> *auto_ptr_ref<Rename>auto_ptr_ref<Rename> &const auto_ptr_ref<Rename>const auto_ptr_ref<Rename> &auto_ptr_ref<Adjust>auto_ptr_ref<Adjust> &const auto_ptr_ref<Adjust>const auto_ptr_ref<Adjust> &auto_ptr_ref<Erase>auto_ptr_ref<Erase> &const auto_ptr_ref<Erase>const auto_ptr_ref<Erase> &auto_ptr_ref<Extract>auto_ptr_ref<Extract> &const auto_ptr_ref<Extract>const auto_ptr_ref<Extract> &auto_ptr_ref<Insert>auto_ptr_ref<Insert> &const auto_ptr_ref<Insert>const auto_ptr_ref<Insert> &auto_ptr_ref<Modify>auto_ptr_ref<Modify> &const auto_ptr_ref<Modify>const auto_ptr_ref<Modify> &__wrap_iter<const ModifyCmd *>const ModifyCmd *ModifyCmd *__wrap_iter<ModifyCmd *>__wrap_iter<ModifyCmd *> *auto_ptr_ref<FixIso>auto_ptr_ref<FixIso> &const auto_ptr_ref<FixIso>const auto_ptr_ref<FixIso> &auto_ptr_ref<FixCom>auto_ptr_ref<FixCom> &const auto_ptr_ref<FixCom>const auto_ptr_ref<FixCom> &pair<basic_string<char, char_traits<char>, allocator<char>>, int>pair<basic_string<char, char_traits<char>, allocator<char>>, int> *const pair<basic_string<char, char_traits<char>, allocator<char>>, int>const pair<basic_string<char, char_traits<char>, allocator<char>>, int> &pair<basic_string<char, char_traits<char>, allocator<char>>, int> &map<TaskType, Task *, less<TaskType>, allocator<pair<const TaskType, Task *>>>less<TaskType> &allocator<pair<const TaskType, Task *>> &__tree_node<__value_type<TaskType, Task *>, void *> *pair<const TaskType, Task *> *auto_ptr<Print>auto_ptr<Print> &auto_ptr<Rename>auto_ptr<Rename> &auto_ptr<Adjust>auto_ptr<Adjust> &auto_ptr<Erase>auto_ptr<Erase> &auto_ptr<Extract>auto_ptr<Extract> &auto_ptr<Insert>auto_ptr<Insert> &auto_ptr<Modify>auto_ptr<Modify> &auto_ptr<FixIso>auto_ptr<FixIso> &auto_ptr<FixCom>auto_ptr<FixCom> &__map_iterator<__tree_iterator<__value_type<TaskType, Task *>, __tree_node<__value_type<TaskType, Task *>, void *> *, long>>__map_iterator<__tree_iterator<__value_type<TaskType, Task *>, __tree_node<__value_type<TaskType, Task *>, void *> *, long>> *__map_const_iterator<__tree_const_iterator<__value_type<TaskType, Task *>, __tree_node<__value_type<TaskType, Task *>, void *> *, long>>__tree_iterator<__value_type<TaskType, Task *>, __tree_node<__value_type<TaskType, Task *>, void *> *, long>__tree_iterator<__value_type<TaskType, Task *>, __tree_node<__value_type<TaskType, Task *>, void *> *, long> *__value_type<TaskType, Task *> *__value_type<TaskType, Task *> &__tree_const_iterator<__value_type<TaskType, Task *>, __tree_node<__value_type<TaskType, Task *>, void *> *, long>allocator<__tree_node<__value_type<TaskType, Task *>, void *>>allocator<__tree_node<__value_type<TaskType, Task *>, void *>> &const allocator<__tree_node<__value_type<TaskType, Task *>, void *>>const allocator<__tree_node<__value_type<TaskType, Task *>, void *>> &const __tree_node<__value_type<TaskType, Task *>, void *>const __tree_node<__value_type<TaskType, Task *>, void *> &__tree_node<__value_type<TaskType, Task *>, void *> &const __tree_node<__value_type<TaskType, Task *>, void *> *__allocator_traits_rebind<allocator<__value_type<TaskType, Task *>>, __tree_node<__value_type<TaskType, Task *>, void *>, true>__allocator_traits_rebind<allocator<__value_type<TaskType, Task *>>, __tree_node<__value_type<TaskType, Task *>, void *>, true> &const __allocator_traits_rebind<allocator<__value_type<TaskType, Task *>>, __tree_node<__value_type<TaskType, Task *>, void *>, true>const __allocator_traits_rebind<allocator<__value_type<TaskType, Task *>>, __tree_node<__value_type<TaskType, Task *>, void *>, true> &__allocator_traits_rebind<allocator<__tree_node<__value_type<TaskType, Task *>, void *>>, __tree_node_base<void *>, true>__allocator_traits_rebind<allocator<__tree_node<__value_type<TaskType, Task *>, void *>>, __tree_node_base<void *>, true> &const __allocator_traits_rebind<allocator<__tree_node<__value_type<TaskType, Task *>, void *>>, __tree_node_base<void *>, true>const __allocator_traits_rebind<allocator<__tree_node<__value_type<TaskType, Task *>, void *>>, __tree_node_base<void *>, true> &allocator<__value_type<TaskType, Task *>>allocator<__value_type<TaskType, Task *>> &const allocator<__value_type<TaskType, Task *>>const allocator<__value_type<TaskType, Task *>> &const __value_type<TaskType, Task *>const __value_type<TaskType, Task *> &const __value_type<TaskType, Task *> *__allocator_traits_rebind<allocator<pair<const TaskType, Task *>>, __value_type<TaskType, Task *>, true>__allocator_traits_rebind<allocator<pair<const TaskType, Task *>>, __value_type<TaskType, Task *>, true> &const __allocator_traits_rebind<allocator<pair<const TaskType, Task *>>, __value_type<TaskType, Task *>, true>const __allocator_traits_rebind<allocator<pair<const TaskType, Task *>>, __value_type<TaskType, Task *>, true> &allocator<pair<const TaskType, Task *>>const allocator<pair<const TaskType, Task *>>const allocator<pair<const TaskType, Task *>> &const pair<const TaskType, Task *> *__identity<allocator<pair<const TaskType, Task *>>>__identity<allocator<pair<const TaskType, Task *>>> &const __identity<allocator<pair<const TaskType, Task *>>>const __identity<allocator<pair<const TaskType, Task *>>> &map<TaskType, Task *, less<TaskType>, allocator<pair<const TaskType, Task *>>> *const __map_const_iterator<__tree_const_iterator<__value_type<TaskType, Task *>, __tree_node<__value_type<TaskType, Task *>, void *> *, long>> *__map_const_iterator<__tree_const_iterator<__value_type<TaskType, Task *>, __tree_node<__value_type<TaskType, Task *>, void *> *, long>> *const TaskType &const unique_ptr<__tree_node<__value_type<TaskType, Task *>, void *>, __map_node_destructor<allocator<__tree_node<__value_type<TaskType, Task *>, void *>>>>const __map_iterator<__tree_iterator<__value_type<TaskType, Task *>, __tree_node<__value_type<TaskType, Task *>, void *> *, long>> *__map_value_compare<TaskType, __value_type<TaskType, Task *>, less<TaskType>, true> &auto_ptr<Task> *auto_ptr<Print> *operator std::__1::auto_ptr_ref<Action::Print>__wrap_iter<const PreviewProperties *> *const __wrap_iter<const PreviewProperties *> *vector<regex_t, allocator<regex_t>> *__vector_base<regex_t, allocator<regex_t>> *make_pairauto_ptr<Rename> *operator std::__1::auto_ptr_ref<Action::Rename>auto_ptr<Adjust> *operator std::__1::auto_ptr_ref<Action::Adjust>auto_ptr<Erase> *operator std::__1::auto_ptr_ref<Action::Erase>auto_ptr<Extract> *operator std::__1::auto_ptr_ref<Action::Extract>__tree_const_iterator<int, __tree_node<int, void *> *, long> *vector<PreviewProperties, allocator<PreviewProperties>> *__vector_base<PreviewProperties, allocator<PreviewProperties>> *const __tree_const_iterator<int, __tree_node<int, void *> *, long> *const set<int, less<int>, allocator<int>>const set<int, less<int>, allocator<int>> *set<int, less<int>, allocator<int>> *const auto_ptr<Image> *auto_ptr<Image> *auto_ptr<Insert> *operator std::__1::auto_ptr_ref<Action::Insert>auto_ptr<Modify> *operator std::__1::auto_ptr_ref<Action::Modify>__wrap_iter<const ModifyCmd *> *const __wrap_iter<const ModifyCmd *> *vector<ModifyCmd, allocator<ModifyCmd>> *__vector_base<ModifyCmd, allocator<ModifyCmd>> *__wrap_iter<Xmpdatum *> *auto_ptr<FixIso> *operator std::__1::auto_ptr_ref<Action::FixIso>auto_ptr<FixCom> *operator std::__1::auto_ptr_ref<Action::FixCom>const __map_value_compare<TaskType, __value_type<TaskType, Task *>, less<TaskType>, true>const __map_value_compare<TaskType, __value_type<TaskType, Task *>, less<TaskType>, true> &__tree_node<__value_type<TaskType, Task *>, void *> *&__map_node_destructor<allocator<__tree_node<__value_type<TaskType, Task *>, void *>>> &operator std::__1::__tree_node<std::__1::__value_type<Action::TaskType, Action::Task *>, void *> *operator Action::Print *operator Action::Rename *operator Action::Erase *operator Action::Extract *operator Action::Insert *operator Action::Modify *operator Action::Adjust *operator Action::FixIso *operator Action::FixCom *conditional<false, __nat, pair<const TaskType, Task *>>conditional<false, __nat, pair<const TaskType, Task *>> &const conditional<false, __nat, pair<const TaskType, Task *>>const conditional<false, __nat, pair<const TaskType, Task *>> &pointer_traits<pair<const TaskType, Task *> *>pointer_traits<pair<const TaskType, Task *> *> &const pointer_traits<pair<const TaskType, Task *> *>const pointer_traits<pair<const TaskType, Task *> *> &conditional<false, __nat, const pair<const TaskType, Task *>>conditional<false, __nat, const pair<const TaskType, Task *>> &const conditional<false, __nat, const pair<const TaskType, Task *>>const conditional<false, __nat, const pair<const TaskType, Task *>> &pointer_traits<const pair<const TaskType, Task *> *>pointer_traits<const pair<const TaskType, Task *> *> &const pointer_traits<const pair<const TaskType, Task *> *>const pointer_traits<const pair<const TaskType, Task *> *> &__non_trivial_if<true, allocator<pair<const TaskType, Task *>>>__non_trivial_if<true, allocator<pair<const TaskType, Task *>>> &const __non_trivial_if<true, allocator<pair<const TaskType, Task *>>>const __non_trivial_if<true, allocator<pair<const TaskType, Task *>>> &rebind<__value_type<TaskType, Task *>>rebind<__value_type<TaskType, Task *>> &const rebind<__value_type<TaskType, Task *>>const rebind<__value_type<TaskType, Task *>> &__has_rebind_other<allocator<pair<const TaskType, Task *>>, __value_type<TaskType, Task *>, void>__has_rebind_other<allocator<pair<const TaskType, Task *>>, __value_type<TaskType, Task *>, void> &const __has_rebind_other<allocator<pair<const TaskType, Task *>>, __value_type<TaskType, Task *>, void>const __has_rebind_other<allocator<pair<const TaskType, Task *>>, __value_type<TaskType, Task *>, void> &__non_trivial_if<true, allocator<__value_type<TaskType, Task *>>>__non_trivial_if<true, allocator<__value_type<TaskType, Task *>>> &const __non_trivial_if<true, allocator<__value_type<TaskType, Task *>>>const __non_trivial_if<true, allocator<__value_type<TaskType, Task *>>> &__has_rebind_other<allocator<__tree_node<__value_type<TaskType, Task *>, void *>>, __tree_node_base<void *>, void>__has_rebind_other<allocator<__tree_node<__value_type<TaskType, Task *>, void *>>, __tree_node_base<void *>, void> &const __has_rebind_other<allocator<__tree_node<__value_type<TaskType, Task *>, void *>>, __tree_node_base<void *>, void>const __has_rebind_other<allocator<__tree_node<__value_type<TaskType, Task *>, void *>>, __tree_node_base<void *>, void> &rebind<__tree_node<__value_type<TaskType, Task *>, void *>>rebind<__tree_node<__value_type<TaskType, Task *>, void *>> &const rebind<__tree_node<__value_type<TaskType, Task *>, void *>>const rebind<__tree_node<__value_type<TaskType, Task *>, void *>> &__has_rebind_other<allocator<__value_type<TaskType, Task *>>, __tree_node<__value_type<TaskType, Task *>, void *>, void>__has_rebind_other<allocator<__value_type<TaskType, Task *>>, __tree_node<__value_type<TaskType, Task *>, void *>, void> &const __has_rebind_other<allocator<__value_type<TaskType, Task *>>, __tree_node<__value_type<TaskType, Task *>, void *>, void>const __has_rebind_other<allocator<__value_type<TaskType, Task *>>, __tree_node<__value_type<TaskType, Task *>, void *>, void> &__non_trivial_if<true, allocator<__tree_node<__value_type<TaskType, Task *>, void *>>>__non_trivial_if<true, allocator<__tree_node<__value_type<TaskType, Task *>, void *>>> &const __non_trivial_if<true, allocator<__tree_node<__value_type<TaskType, Task *>, void *>>>const __non_trivial_if<true, allocator<__tree_node<__value_type<TaskType, Task *>, void *>>> &__tree_node_types<__tree_node<__value_type<TaskType, Task *>, void *> *, __tree_node<__value_type<TaskType, Task *>, void *>>__tree_node_types<__tree_node<__value_type<TaskType, Task *>, void *> *, __tree_node<__value_type<TaskType, Task *>, void *>> &const __tree_node_types<__tree_node<__value_type<TaskType, Task *>, void *> *, __tree_node<__value_type<TaskType, Task *>, void *>>const __tree_node_types<__tree_node<__value_type<TaskType, Task *>, void *> *, __tree_node<__value_type<TaskType, Task *>, void *>> &pointer_traits<__tree_node<__value_type<TaskType, Task *>, void *> *>pointer_traits<__tree_node<__value_type<TaskType, Task *>, void *> *> &const pointer_traits<__tree_node<__value_type<TaskType, Task *>, void *> *>const pointer_traits<__tree_node<__value_type<TaskType, Task *>, void *> *> &__tree_key_value_types<__value_type<TaskType, Task *>>__tree_key_value_types<__value_type<TaskType, Task *>> &const __tree_key_value_types<__value_type<TaskType, Task *>>const __tree_key_value_types<__value_type<TaskType, Task *>> &__tree_map_pointer_types<__value_type<TaskType, Task *>, void *, __tree_key_value_types<__value_type<TaskType, Task *>>, true>__tree_map_pointer_types<__value_type<TaskType, Task *>, void *, __tree_key_value_types<__value_type<TaskType, Task *>>, true> &const __tree_map_pointer_types<__value_type<TaskType, Task *>, void *, __tree_key_value_types<__value_type<TaskType, Task *>>, true>const __tree_map_pointer_types<__value_type<TaskType, Task *>, void *, __tree_key_value_types<__value_type<TaskType, Task *>>, true> &reverse_iterator<__wrap_iter<const PreviewProperties *>>reverse_iterator<__wrap_iter<regex_t *>>unique_ptr<__tree_node<int, void *>, __tree_node_destructor<allocator<__tree_node<int, void *>>>>reverse_iterator<__wrap_iter<ModifyCmd *>>reverse_iterator<__wrap_iter<const ModifyCmd *>>allocator_traits<allocator<__tree_node<__value_type<TaskType, Task *>, void *>>>allocator_traits<allocator<__tree_node<__value_type<TaskType, Task *>, void *>>> &const allocator_traits<allocator<__tree_node<__value_type<TaskType, Task *>, void *>>>const allocator_traits<allocator<__tree_node<__value_type<TaskType, Task *>, void *>>> &__value_type<TaskType, Task *>__map_value_compare<TaskType, __value_type<TaskType, Task *>, less<TaskType>, true>__map_value_compare<TaskType, __value_type<TaskType, Task *>, less<TaskType>, true> *__rebind_alloc_helper<allocator_traits<allocator<pair<const TaskType, Task *>>>, __value_type<TaskType, Task *>>__rebind_alloc_helper<allocator_traits<allocator<pair<const TaskType, Task *>>>, __value_type<TaskType, Task *>> &const __rebind_alloc_helper<allocator_traits<allocator<pair<const TaskType, Task *>>>, __value_type<TaskType, Task *>>const __rebind_alloc_helper<allocator_traits<allocator<pair<const TaskType, Task *>>>, __value_type<TaskType, Task *>> &allocator_traits<allocator<pair<const TaskType, Task *>>>allocator_traits<allocator<pair<const TaskType, Task *>>> &const allocator_traits<allocator<pair<const TaskType, Task *>>>const allocator_traits<allocator<pair<const TaskType, Task *>>> &reverse_iterator<__map_iterator<__tree_iterator<__value_type<TaskType, Task *>, __tree_node<__value_type<TaskType, Task *>, void *> *, long>>>reverse_iterator<__map_const_iterator<__tree_const_iterator<__value_type<TaskType, Task *>, __tree_node<__value_type<TaskType, Task *>, void *> *, long>>>__tree_node<__value_type<TaskType, Task *>, void *>__tree<__value_type<TaskType, Task *>, __map_value_compare<TaskType, __value_type<TaskType, Task *>, less<TaskType>, true>, allocator<__value_type<TaskType, Task *>>>__map_node_destructor<allocator<__tree_node<__value_type<TaskType, Task *>, void *>>>const __map_node_destructor<allocator<__tree_node<__value_type<TaskType, Task *>, void *>>>const __map_node_destructor<allocator<__tree_node<__value_type<TaskType, Task *>, void *>>> &unique_ptr<__tree_node<__value_type<TaskType, Task *>, void *>, __map_node_destructor<allocator<__tree_node<__value_type<TaskType, Task *>, void *>>>>unique_ptr<__tree_node<__value_type<TaskType, Task *>, void *>, __map_node_destructor<allocator<__tree_node<__value_type<TaskType, Task *>, void *>>>> &iterator_traits<ModifyCmd *>iterator_traits<ModifyCmd *> &const iterator_traits<ModifyCmd *>const iterator_traits<ModifyCmd *> &iterator_traits<const ModifyCmd *>iterator_traits<const ModifyCmd *> &const iterator_traits<const ModifyCmd *>const iterator_traits<const ModifyCmd *> &iterator_traits<regex_t *>iterator_traits<regex_t *> &const iterator_traits<regex_t *>const iterator_traits<regex_t *> &iterator_traits<const PreviewProperties *>iterator_traits<const PreviewProperties *> &const iterator_traits<const PreviewProperties *>const iterator_traits<const PreviewProperties *> &__tree<__value_type<TaskType, Task *>, __map_value_compare<TaskType, __value_type<TaskType, Task *>, less<TaskType>, true>, allocator<__value_type<TaskType, Task *>>> *const __tree<__value_type<TaskType, Task *>, __map_value_compare<TaskType, __value_type<TaskType, Task *>, less<TaskType>, true>, allocator<__value_type<TaskType, Task *>>>const __tree<__value_type<TaskType, Task *>, __map_value_compare<TaskType, __value_type<TaskType, Task *>, less<TaskType>, true>, allocator<__value_type<TaskType, Task *>>> *const __wrap_iter<ModifyCmd *> *const __tree<int, less<int>, allocator<int>>const __tree<int, less<int>, allocator<int>> *__tree<int, less<int>, allocator<int>> *__tree_node<int, void *> *const __wrap_iter<regex_t *> *const __tree_iterator<__value_type<TaskType, Task *>, __tree_node<__value_type<TaskType, Task *>, void *> *, long> *unique_ptr<__tree_node<__value_type<TaskType, Task *>, void *>, __map_node_destructor<allocator<__tree_node<__value_type<TaskType, Task *>, void *>>>> *const unique_ptr<__tree_node<__value_type<TaskType, Task *>, void *>, __map_node_destructor<allocator<__tree_node<__value_type<TaskType, Task *>, void *>>>> *const TaskType *TaskType *Task **__tree_const_iterator<__value_type<TaskType, Task *>, __tree_node<__value_type<TaskType, Task *>, void *> *, long> *const __tree_const_iterator<__value_type<TaskType, Task *>, __tree_node<__value_type<TaskType, Task *>, void *> *, long> *conditional<false, __nat, const __value_type<TaskType, Task *>>conditional<false, __nat, const __value_type<TaskType, Task *>> &const conditional<false, __nat, const __value_type<TaskType, Task *>>const conditional<false, __nat, const __value_type<TaskType, Task *>> &pointer_traits<const __value_type<TaskType, Task *> *>pointer_traits<const __value_type<TaskType, Task *> *> &const pointer_traits<const __value_type<TaskType, Task *> *>const pointer_traits<const __value_type<TaskType, Task *> *> &__compressed_pair_elem<__tree_node<__value_type<TaskType, Task *>, void *> *, 0, false>__compressed_pair_elem<__tree_node<__value_type<TaskType, Task *>, void *> *, 0, false> &const __compressed_pair_elem<__tree_node<__value_type<TaskType, Task *>, void *> *, 0, false>const __compressed_pair_elem<__tree_node<__value_type<TaskType, Task *>, void *> *, 0, false> &__tree_node<__value_type<TaskType, Task *>, void *> *const__tree_node<__value_type<TaskType, Task *>, void *> *const &conditional<false, __nat, __value_type<TaskType, Task *>>conditional<false, __nat, __value_type<TaskType, Task *>> &const conditional<false, __nat, __value_type<TaskType, Task *>>const conditional<false, __nat, __value_type<TaskType, Task *>> &pointer_traits<__value_type<TaskType, Task *> *>pointer_traits<__value_type<TaskType, Task *> *> &const pointer_traits<__value_type<TaskType, Task *> *>const pointer_traits<__value_type<TaskType, Task *> *> &remove_cv<const PreviewProperties>remove_cv<const PreviewProperties> &const remove_cv<const PreviewProperties>const remove_cv<const PreviewProperties> &remove_cv<regex_t>remove_cv<regex_t> &const remove_cv<regex_t>const remove_cv<regex_t> &remove_cv<const ModifyCmd>remove_cv<const ModifyCmd> &const remove_cv<const ModifyCmd>const remove_cv<const ModifyCmd> &remove_cv<ModifyCmd>remove_cv<ModifyCmd> &const remove_cv<ModifyCmd>const remove_cv<ModifyCmd> &__compressed_pair<__tree_node<__value_type<TaskType, Task *>, void *> *, __map_node_destructor<allocator<__tree_node<__value_type<TaskType, Task *>, void *>>>>__compressed_pair<__tree_node<__value_type<TaskType, Task *>, void *> *, __map_node_destructor<allocator<__tree_node<__value_type<TaskType, Task *>, void *>>>> &const __compressed_pair<__tree_node<__value_type<TaskType, Task *>, void *> *, __map_node_destructor<allocator<__tree_node<__value_type<TaskType, Task *>, void *>>>>const __compressed_pair<__tree_node<__value_type<TaskType, Task *>, void *> *, __map_node_destructor<allocator<__tree_node<__value_type<TaskType, Task *>, void *>>>> &__pointer<__tree_node<__value_type<TaskType, Task *>, void *>, __map_node_destructor<allocator<__tree_node<__value_type<TaskType, Task *>, void *>>>, __map_node_destructor<allocator<__tree_node<__value_type<TaskType, Task *>, void *>>>, true>__pointer<__tree_node<__value_type<TaskType, Task *>, void *>, __map_node_destructor<allocator<__tree_node<__value_type<TaskType, Task *>, void *>>>, __map_node_destructor<allocator<__tree_node<__value_type<TaskType, Task *>, void *>>>, true> &const __pointer<__tree_node<__value_type<TaskType, Task *>, void *>, __map_node_destructor<allocator<__tree_node<__value_type<TaskType, Task *>, void *>>>, __map_node_destructor<allocator<__tree_node<__value_type<TaskType, Task *>, void *>>>, true>const __pointer<__tree_node<__value_type<TaskType, Task *>, void *>, __map_node_destructor<allocator<__tree_node<__value_type<TaskType, Task *>, void *>>>, __map_node_destructor<allocator<__tree_node<__value_type<TaskType, Task *>, void *>>>, true> &__unique_ptr_deleter_sfinae<__map_node_destructor<allocator<__tree_node<__value_type<TaskType, Task *>, void *>>>>__unique_ptr_deleter_sfinae<__map_node_destructor<allocator<__tree_node<__value_type<TaskType, Task *>, void *>>>> &const __unique_ptr_deleter_sfinae<__map_node_destructor<allocator<__tree_node<__value_type<TaskType, Task *>, void *>>>>const __unique_ptr_deleter_sfinae<__map_node_destructor<allocator<__tree_node<__value_type<TaskType, Task *>, void *>>>> &__map_node_destructor<allocator<__tree_node<__value_type<TaskType, Task *>, void *>>> &&__compressed_pair<__tree_end_node<__tree_node_base<void *> *>, allocator<__tree_node<__value_type<TaskType, Task *>, void *>>>__compressed_pair<__tree_end_node<__tree_node_base<void *> *>, allocator<__tree_node<__value_type<TaskType, Task *>, void *>>> &const __compressed_pair<__tree_end_node<__tree_node_base<void *> *>, allocator<__tree_node<__value_type<TaskType, Task *>, void *>>>const __compressed_pair<__tree_end_node<__tree_node_base<void *> *>, allocator<__tree_node<__value_type<TaskType, Task *>, void *>>> &__compressed_pair<unsigned long, __map_value_compare<TaskType, __value_type<TaskType, Task *>, less<TaskType>, true>>__compressed_pair<unsigned long, __map_value_compare<TaskType, __value_type<TaskType, Task *>, less<TaskType>, true>> &const __compressed_pair<unsigned long, __map_value_compare<TaskType, __value_type<TaskType, Task *>, less<TaskType>, true>>const __compressed_pair<unsigned long, __map_value_compare<TaskType, __value_type<TaskType, Task *>, less<TaskType>, true>> &__make_tree_node_types<__value_type<TaskType, Task *>, void *>__make_tree_node_types<__value_type<TaskType, Task *>, void *> &const __make_tree_node_types<__value_type<TaskType, Task *>, void *>const __make_tree_node_types<__value_type<TaskType, Task *>, void *> &allocator_traits<allocator<__value_type<TaskType, Task *>>>allocator_traits<allocator<__value_type<TaskType, Task *>>> &const allocator_traits<allocator<__value_type<TaskType, Task *>>>const allocator_traits<allocator<__value_type<TaskType, Task *>>> &__rebind_alloc_helper<allocator_traits<allocator<__value_type<TaskType, Task *>>>, __tree_node<__value_type<TaskType, Task *>, void *>>__rebind_alloc_helper<allocator_traits<allocator<__value_type<TaskType, Task *>>>, __tree_node<__value_type<TaskType, Task *>, void *>> &const __rebind_alloc_helper<allocator_traits<allocator<__value_type<TaskType, Task *>>>, __tree_node<__value_type<TaskType, Task *>, void *>>const __rebind_alloc_helper<allocator_traits<allocator<__value_type<TaskType, Task *>>>, __tree_node<__value_type<TaskType, Task *>, void *>> &__rebind_alloc_helper<allocator_traits<allocator<__tree_node<__value_type<TaskType, Task *>, void *>>>, __tree_node_base<void *>>__rebind_alloc_helper<allocator_traits<allocator<__tree_node<__value_type<TaskType, Task *>, void *>>>, __tree_node_base<void *>> &const __rebind_alloc_helper<allocator_traits<allocator<__tree_node<__value_type<TaskType, Task *>, void *>>>, __tree_node_base<void *>>const __rebind_alloc_helper<allocator_traits<allocator<__tree_node<__value_type<TaskType, Task *>, void *>>>, __tree_node_base<void *>> &__tree_node_destructor<allocator<__tree_node<__value_type<TaskType, Task *>, void *>>>unique_ptr<__tree_node<__value_type<TaskType, Task *>, void *>, __tree_node_destructor<allocator<__tree_node<__value_type<TaskType, Task *>, void *>>>>pair<__tree_iterator<__value_type<TaskType, Task *>, __tree_node<__value_type<TaskType, Task *>, void *> *, long>, bool>pair<__tree_iterator<__value_type<TaskType, Task *>, __tree_node<__value_type<TaskType, Task *>, void *> *, long>, __tree_iterator<__value_type<TaskType, Task *>, __tree_node<__value_type<TaskType, Task *>, void *> *, long>>pair<__tree_const_iterator<__value_type<TaskType, Task *>, __tree_node<__value_type<TaskType, Task *>, void *> *, long>, __tree_const_iterator<__value_type<TaskType, Task *>, __tree_node<__value_type<TaskType, Task *>, void *> *, long>>__pointer<pair<const TaskType, Task *>, allocator<pair<const TaskType, Task *>>, allocator<pair<const TaskType, Task *>>, true>__pointer<pair<const TaskType, Task *>, allocator<pair<const TaskType, Task *>>, allocator<pair<const TaskType, Task *>>, true> &const __pointer<pair<const TaskType, Task *>, allocator<pair<const TaskType, Task *>>, allocator<pair<const TaskType, Task *>>, true>const __pointer<pair<const TaskType, Task *>, allocator<pair<const TaskType, Task *>>, allocator<pair<const TaskType, Task *>>, true> &__const_pointer<pair<const TaskType, Task *>, pair<const TaskType, Task *> *, allocator<pair<const TaskType, Task *>>, true>__const_pointer<pair<const TaskType, Task *>, pair<const TaskType, Task *> *, allocator<pair<const TaskType, Task *>>, true> &const __const_pointer<pair<const TaskType, Task *>, pair<const TaskType, Task *> *, allocator<pair<const TaskType, Task *>>, true>const __const_pointer<pair<const TaskType, Task *>, pair<const TaskType, Task *> *, allocator<pair<const TaskType, Task *>>, true> &__void_pointer<pair<const TaskType, Task *> *, allocator<pair<const TaskType, Task *>>, false>__void_pointer<pair<const TaskType, Task *> *, allocator<pair<const TaskType, Task *>>, false> &const __void_pointer<pair<const TaskType, Task *> *, allocator<pair<const TaskType, Task *>>, false>const __void_pointer<pair<const TaskType, Task *> *, allocator<pair<const TaskType, Task *>>, false> &__const_void_pointer<pair<const TaskType, Task *> *, allocator<pair<const TaskType, Task *>>, false>__const_void_pointer<pair<const TaskType, Task *> *, allocator<pair<const TaskType, Task *>>, false> &const __const_void_pointer<pair<const TaskType, Task *> *, allocator<pair<const TaskType, Task *>>, false>const __const_void_pointer<pair<const TaskType, Task *> *, allocator<pair<const TaskType, Task *>>, false> &__alloc_traits_difference_type<allocator<pair<const TaskType, Task *>>, pair<const TaskType, Task *> *, true>__alloc_traits_difference_type<allocator<pair<const TaskType, Task *>>, pair<const TaskType, Task *> *, true> &const __alloc_traits_difference_type<allocator<pair<const TaskType, Task *>>, pair<const TaskType, Task *> *, true>const __alloc_traits_difference_type<allocator<pair<const TaskType, Task *>>, pair<const TaskType, Task *> *, true> &__size_type<allocator<pair<const TaskType, Task *>>, long, true>__size_type<allocator<pair<const TaskType, Task *>>, long, true> &const __size_type<allocator<pair<const TaskType, Task *>>, long, true>const __size_type<allocator<pair<const TaskType, Task *>>, long, true> &__propagate_on_container_move_assignment<allocator<pair<const TaskType, Task *>>, true>__propagate_on_container_move_assignment<allocator<pair<const TaskType, Task *>>, true> &const __propagate_on_container_move_assignment<allocator<pair<const TaskType, Task *>>, true>const __propagate_on_container_move_assignment<allocator<pair<const TaskType, Task *>>, true> &__is_always_equal<allocator<pair<const TaskType, Task *>>, true>__is_always_equal<allocator<pair<const TaskType, Task *>>, true> &const __is_always_equal<allocator<pair<const TaskType, Task *>>, true>const __is_always_equal<allocator<pair<const TaskType, Task *>>, true> &rebind_alloc<__value_type<TaskType, Task *>>rebind_alloc<__value_type<TaskType, Task *>> &const rebind_alloc<__value_type<TaskType, Task *>>const rebind_alloc<__value_type<TaskType, Task *>> &__pointer<__tree_node<__value_type<TaskType, Task *>, void *>, allocator<__tree_node<__value_type<TaskType, Task *>, void *>>, allocator<__tree_node<__value_type<TaskType, Task *>, void *>>, true>__pointer<__tree_node<__value_type<TaskType, Task *>, void *>, allocator<__tree_node<__value_type<TaskType, Task *>, void *>>, allocator<__tree_node<__value_type<TaskType, Task *>, void *>>, true> &const __pointer<__tree_node<__value_type<TaskType, Task *>, void *>, allocator<__tree_node<__value_type<TaskType, Task *>, void *>>, allocator<__tree_node<__value_type<TaskType, Task *>, void *>>, true>const __pointer<__tree_node<__value_type<TaskType, Task *>, void *>, allocator<__tree_node<__value_type<TaskType, Task *>, void *>>, allocator<__tree_node<__value_type<TaskType, Task *>, void *>>, true> &__const_pointer<__tree_node<__value_type<TaskType, Task *>, void *>, __tree_node<__value_type<TaskType, Task *>, void *> *, allocator<__tree_node<__value_type<TaskType, Task *>, void *>>, true>__const_pointer<__tree_node<__value_type<TaskType, Task *>, void *>, __tree_node<__value_type<TaskType, Task *>, void *> *, allocator<__tree_node<__value_type<TaskType, Task *>, void *>>, true> &const __const_pointer<__tree_node<__value_type<TaskType, Task *>, void *>, __tree_node<__value_type<TaskType, Task *>, void *> *, allocator<__tree_node<__value_type<TaskType, Task *>, void *>>, true>const __const_pointer<__tree_node<__value_type<TaskType, Task *>, void *>, __tree_node<__value_type<TaskType, Task *>, void *> *, allocator<__tree_node<__value_type<TaskType, Task *>, void *>>, true> &__void_pointer<__tree_node<__value_type<TaskType, Task *>, void *> *, allocator<__tree_node<__value_type<TaskType, Task *>, void *>>, false>__void_pointer<__tree_node<__value_type<TaskType, Task *>, void *> *, allocator<__tree_node<__value_type<TaskType, Task *>, void *>>, false> &const __void_pointer<__tree_node<__value_type<TaskType, Task *>, void *> *, allocator<__tree_node<__value_type<TaskType, Task *>, void *>>, false>const __void_pointer<__tree_node<__value_type<TaskType, Task *>, void *> *, allocator<__tree_node<__value_type<TaskType, Task *>, void *>>, false> &__const_void_pointer<__tree_node<__value_type<TaskType, Task *>, void *> *, allocator<__tree_node<__value_type<TaskType, Task *>, void *>>, false>__const_void_pointer<__tree_node<__value_type<TaskType, Task *>, void *> *, allocator<__tree_node<__value_type<TaskType, Task *>, void *>>, false> &const __const_void_pointer<__tree_node<__value_type<TaskType, Task *>, void *> *, allocator<__tree_node<__value_type<TaskType, Task *>, void *>>, false>const __const_void_pointer<__tree_node<__value_type<TaskType, Task *>, void *> *, allocator<__tree_node<__value_type<TaskType, Task *>, void *>>, false> &__alloc_traits_difference_type<allocator<__tree_node<__value_type<TaskType, Task *>, void *>>, __tree_node<__value_type<TaskType, Task *>, void *> *, true>__alloc_traits_difference_type<allocator<__tree_node<__value_type<TaskType, Task *>, void *>>, __tree_node<__value_type<TaskType, Task *>, void *> *, true> &const __alloc_traits_difference_type<allocator<__tree_node<__value_type<TaskType, Task *>, void *>>, __tree_node<__value_type<TaskType, Task *>, void *> *, true>const __alloc_traits_difference_type<allocator<__tree_node<__value_type<TaskType, Task *>, void *>>, __tree_node<__value_type<TaskType, Task *>, void *> *, true> &__size_type<allocator<__tree_node<__value_type<TaskType, Task *>, void *>>, long, true>__size_type<allocator<__tree_node<__value_type<TaskType, Task *>, void *>>, long, true> &const __size_type<allocator<__tree_node<__value_type<TaskType, Task *>, void *>>, long, true>const __size_type<allocator<__tree_node<__value_type<TaskType, Task *>, void *>>, long, true> &__propagate_on_container_move_assignment<allocator<__tree_node<__value_type<TaskType, Task *>, void *>>, true>__propagate_on_container_move_assignment<allocator<__tree_node<__value_type<TaskType, Task *>, void *>>, true> &const __propagate_on_container_move_assignment<allocator<__tree_node<__value_type<TaskType, Task *>, void *>>, true>const __propagate_on_container_move_assignment<allocator<__tree_node<__value_type<TaskType, Task *>, void *>>, true> &__is_always_equal<allocator<__tree_node<__value_type<TaskType, Task *>, void *>>, true>__is_always_equal<allocator<__tree_node<__value_type<TaskType, Task *>, void *>>, true> &const __is_always_equal<allocator<__tree_node<__value_type<TaskType, Task *>, void *>>, true>const __is_always_equal<allocator<__tree_node<__value_type<TaskType, Task *>, void *>>, true> &pair<__tree_iterator<int, __tree_node<int, void *> *, long>, bool>__tree_node_destructor<allocator<__tree_node<int, void *>>>__rebind_pointer<void *, pair<const TaskType, Task *>>__rebind_pointer<void *, pair<const TaskType, Task *>> &const __rebind_pointer<void *, pair<const TaskType, Task *>>const __rebind_pointer<void *, pair<const TaskType, Task *>> &__rebind_pointer<void *, const pair<const TaskType, Task *>>__rebind_pointer<void *, const pair<const TaskType, Task *>> &const __rebind_pointer<void *, const pair<const TaskType, Task *>>const __rebind_pointer<void *, const pair<const TaskType, Task *>> &conditional<true, __tree_end_node<__tree_node_base<void *> *> *, __tree_node<__value_type<TaskType, Task *>, void *> *>conditional<true, __tree_end_node<__tree_node_base<void *> *> *, __tree_node<__value_type<TaskType, Task *>, void *> *> &const conditional<true, __tree_end_node<__tree_node_base<void *> *> *, __tree_node<__value_type<TaskType, Task *>, void *> *>const conditional<true, __tree_end_node<__tree_node_base<void *> *> *, __tree_node<__value_type<TaskType, Task *>, void *> *> &__rebind_pointer<void *, __value_type<TaskType, Task *>>__rebind_pointer<void *, __value_type<TaskType, Task *>> &const __rebind_pointer<void *, __value_type<TaskType, Task *>>const __rebind_pointer<void *, __value_type<TaskType, Task *>> &__rebind_pointer<void *, const __value_type<TaskType, Task *>>__rebind_pointer<void *, const __value_type<TaskType, Task *>> &const __rebind_pointer<void *, const __value_type<TaskType, Task *>>const __rebind_pointer<void *, const __value_type<TaskType, Task *>> &is_void<const pair<const TaskType, Task *>>is_void<const pair<const TaskType, Task *>> &const is_void<const pair<const TaskType, Task *>>const is_void<const pair<const TaskType, Task *>> &const __map_value_compare<TaskType, __value_type<TaskType, Task *>, less<TaskType>, true> *const less<TaskType>unique_ptr<__tree_node<__value_type<TaskType, Task *>, void *>, __map_node_destructor<allocator<__tree_node<__value_type<TaskType, Task *>, void *>>>> &&const __compressed_pair<__tree_node<__value_type<TaskType, Task *>, void *> *, __map_node_destructor<allocator<__tree_node<__value_type<TaskType, Task *>, void *>>>> *__compressed_pair<__tree_node<__value_type<TaskType, Task *>, void *> *, __map_node_destructor<allocator<__tree_node<__value_type<TaskType, Task *>, void *>>>> *remove_reference<const __map_value_compare<TaskType, __value_type<TaskType, Task *>, less<TaskType>, true> &>remove_reference<const __map_value_compare<TaskType, __value_type<TaskType, Task *>, less<TaskType>, true> &> &const remove_reference<const __map_value_compare<TaskType, __value_type<TaskType, Task *>, less<TaskType>, true> &>const remove_reference<const __map_value_compare<TaskType, __value_type<TaskType, Task *>, less<TaskType>, true> &> &remove_reference<const TaskType &>remove_reference<const TaskType &> &const remove_reference<const TaskType &>const remove_reference<const TaskType &> &remove_reference<__map_node_destructor<allocator<__tree_node<__value_type<TaskType, Task *>, void *>>>>remove_reference<__map_node_destructor<allocator<__tree_node<__value_type<TaskType, Task *>, void *>>>> &const remove_reference<__map_node_destructor<allocator<__tree_node<__value_type<TaskType, Task *>, void *>>>>const remove_reference<__map_node_destructor<allocator<__tree_node<__value_type<TaskType, Task *>, void *>>>> &rebind<const __value_type<TaskType, Task *>>rebind<const __value_type<TaskType, Task *>> &const rebind<const __value_type<TaskType, Task *>>const rebind<const __value_type<TaskType, Task *>> &is_pointer<__tree_node<__value_type<TaskType, Task *>, void *> *>is_pointer<__tree_node<__value_type<TaskType, Task *>, void *> *> &const is_pointer<__tree_node<__value_type<TaskType, Task *>, void *> *>const is_pointer<__tree_node<__value_type<TaskType, Task *>, void *> *> &rebind<const pair<const TaskType, Task *>>rebind<const pair<const TaskType, Task *>> &const rebind<const pair<const TaskType, Task *>>const rebind<const pair<const TaskType, Task *>> &rebind<pair<const TaskType, Task *>>rebind<pair<const TaskType, Task *>> &const rebind<pair<const TaskType, Task *>>const rebind<pair<const TaskType, Task *>> &__pointer<__value_type<TaskType, Task *>, allocator<__value_type<TaskType, Task *>>, allocator<__value_type<TaskType, Task *>>, true>__pointer<__value_type<TaskType, Task *>, allocator<__value_type<TaskType, Task *>>, allocator<__value_type<TaskType, Task *>>, true> &const __pointer<__value_type<TaskType, Task *>, allocator<__value_type<TaskType, Task *>>, allocator<__value_type<TaskType, Task *>>, true>const __pointer<__value_type<TaskType, Task *>, allocator<__value_type<TaskType, Task *>>, allocator<__value_type<TaskType, Task *>>, true> &__const_pointer<__value_type<TaskType, Task *>, __value_type<TaskType, Task *> *, allocator<__value_type<TaskType, Task *>>, true>__const_pointer<__value_type<TaskType, Task *>, __value_type<TaskType, Task *> *, allocator<__value_type<TaskType, Task *>>, true> &const __const_pointer<__value_type<TaskType, Task *>, __value_type<TaskType, Task *> *, allocator<__value_type<TaskType, Task *>>, true>const __const_pointer<__value_type<TaskType, Task *>, __value_type<TaskType, Task *> *, allocator<__value_type<TaskType, Task *>>, true> &__void_pointer<__value_type<TaskType, Task *> *, allocator<__value_type<TaskType, Task *>>, false>__void_pointer<__value_type<TaskType, Task *> *, allocator<__value_type<TaskType, Task *>>, false> &const __void_pointer<__value_type<TaskType, Task *> *, allocator<__value_type<TaskType, Task *>>, false>const __void_pointer<__value_type<TaskType, Task *> *, allocator<__value_type<TaskType, Task *>>, false> &__const_void_pointer<__value_type<TaskType, Task *> *, allocator<__value_type<TaskType, Task *>>, false>__const_void_pointer<__value_type<TaskType, Task *> *, allocator<__value_type<TaskType, Task *>>, false> &const __const_void_pointer<__value_type<TaskType, Task *> *, allocator<__value_type<TaskType, Task *>>, false>const __const_void_pointer<__value_type<TaskType, Task *> *, allocator<__value_type<TaskType, Task *>>, false> &__alloc_traits_difference_type<allocator<__value_type<TaskType, Task *>>, __value_type<TaskType, Task *> *, true>__alloc_traits_difference_type<allocator<__value_type<TaskType, Task *>>, __value_type<TaskType, Task *> *, true> &const __alloc_traits_difference_type<allocator<__value_type<TaskType, Task *>>, __value_type<TaskType, Task *> *, true>const __alloc_traits_difference_type<allocator<__value_type<TaskType, Task *>>, __value_type<TaskType, Task *> *, true> &__size_type<allocator<__value_type<TaskType, Task *>>, long, true>__size_type<allocator<__value_type<TaskType, Task *>>, long, true> &const __size_type<allocator<__value_type<TaskType, Task *>>, long, true>const __size_type<allocator<__value_type<TaskType, Task *>>, long, true> &__propagate_on_container_move_assignment<allocator<__value_type<TaskType, Task *>>, true>__propagate_on_container_move_assignment<allocator<__value_type<TaskType, Task *>>, true> &const __propagate_on_container_move_assignment<allocator<__value_type<TaskType, Task *>>, true>const __propagate_on_container_move_assignment<allocator<__value_type<TaskType, Task *>>, true> &__is_always_equal<allocator<__value_type<TaskType, Task *>>, true>__is_always_equal<allocator<__value_type<TaskType, Task *>>, true> &const __is_always_equal<allocator<__value_type<TaskType, Task *>>, true>const __is_always_equal<allocator<__value_type<TaskType, Task *>>, true> &rebind_alloc<__tree_node<__value_type<TaskType, Task *>, void *>>rebind_alloc<__tree_node<__value_type<TaskType, Task *>, void *>> &const rebind_alloc<__tree_node<__value_type<TaskType, Task *>, void *>>const rebind_alloc<__tree_node<__value_type<TaskType, Task *>, void *>> &__rebind_pointer<void *, __tree_node<__value_type<TaskType, Task *>, void *>>__rebind_pointer<void *, __tree_node<__value_type<TaskType, Task *>, void *>> &const __rebind_pointer<void *, __tree_node<__value_type<TaskType, Task *>, void *>>const __rebind_pointer<void *, __tree_node<__value_type<TaskType, Task *>, void *>> &__compressed_pair_elem<__map_value_compare<TaskType, __value_type<TaskType, Task *>, less<TaskType>, true>, 1, true>__compressed_pair_elem<__map_value_compare<TaskType, __value_type<TaskType, Task *>, less<TaskType>, true>, 1, true> &const __compressed_pair_elem<__map_value_compare<TaskType, __value_type<TaskType, Task *>, less<TaskType>, true>, 1, true>const __compressed_pair_elem<__map_value_compare<TaskType, __value_type<TaskType, Task *>, less<TaskType>, true>, 1, true> &__compressed_pair_elem<allocator<__tree_node<__value_type<TaskType, Task *>, void *>>, 1, true>__compressed_pair_elem<allocator<__tree_node<__value_type<TaskType, Task *>, void *>>, 1, true> &const __compressed_pair_elem<allocator<__tree_node<__value_type<TaskType, Task *>, void *>>, 1, true>const __compressed_pair_elem<allocator<__tree_node<__value_type<TaskType, Task *>, void *>>, 1, true> &__has_pointer<__map_node_destructor<allocator<__tree_node<__value_type<TaskType, Task *>, void *>>>, void>__has_pointer<__map_node_destructor<allocator<__tree_node<__value_type<TaskType, Task *>, void *>>>, void> &const __has_pointer<__map_node_destructor<allocator<__tree_node<__value_type<TaskType, Task *>, void *>>>, void>const __has_pointer<__map_node_destructor<allocator<__tree_node<__value_type<TaskType, Task *>, void *>>>, void> &__compressed_pair_elem<__map_node_destructor<allocator<__tree_node<__value_type<TaskType, Task *>, void *>>>, 1, false>__compressed_pair_elem<__map_node_destructor<allocator<__tree_node<__value_type<TaskType, Task *>, void *>>>, 1, false> &const __compressed_pair_elem<__map_node_destructor<allocator<__tree_node<__value_type<TaskType, Task *>, void *>>>, 1, false>const __compressed_pair_elem<__map_node_destructor<allocator<__tree_node<__value_type<TaskType, Task *>, void *>>>, 1, false> &remove_volatile<ModifyCmd>remove_volatile<ModifyCmd> &const remove_volatile<ModifyCmd>const remove_volatile<ModifyCmd> &is_void<const __value_type<TaskType, Task *>>is_void<const __value_type<TaskType, Task *>> &const is_void<const __value_type<TaskType, Task *>>const is_void<const __value_type<TaskType, Task *>> &__compressed_pair<__tree_end_node<__tree_node_base<void *> *>, allocator<__tree_node<__value_type<TaskType, Task *>, void *>>> *__compressed_pair<unsigned long, __map_value_compare<TaskType, __value_type<TaskType, Task *>, less<TaskType>, true>> *__map_node_destructor<allocator<__tree_node<__value_type<TaskType, Task *>, void *>>> *__compressed_pair_elem<__tree_node<__value_type<TaskType, Task *>, void *> *, 0, false> *const __compressed_pair_elem<__tree_node<__value_type<TaskType, Task *>, void *> *, 0, false> *__tree_node<__value_type<TaskType, Task *>, void *> *&&const less<TaskType> *less<TaskType> *remove_reference<__tree_node<__value_type<TaskType, Task *>, void *> *>remove_reference<__tree_node<__value_type<TaskType, Task *>, void *> *> &const remove_reference<__tree_node<__value_type<TaskType, Task *>, void *> *>const remove_reference<__tree_node<__value_type<TaskType, Task *>, void *> *> &const __compressed_pair<__tree_end_node<__tree_node_base<void *> *>, allocator<__tree_node<__value_type<TaskType, Task *>, void *>>> *__compressed_pair_elem<__map_node_destructor<allocator<__tree_node<__value_type<TaskType, Task *>, void *>>>, 1, false> *__compressed_pair_elem<allocator<__tree_node<__value_type<TaskType, Task *>, void *>>, 1, true> *__compressed_pair_elem<__map_value_compare<TaskType, __value_type<TaskType, Task *>, less<TaskType>, true>, 1, true> *allocator<__tree_node<__value_type<TaskType, Task *>, void *>> *EXIV2LIB_DEPRECATED_NO_EXPORTEXIV2LIB_NO_EXPORT EXIV2LIB_DEPRECATEDEXIV2LIB_DEPRECATED_EXPORTEXIV2API EXIV2LIB_DEPRECATEDEXIV2LIB_DEPRECATED__attribute__ ((__deprecated__))EXIV2LIB_NO_EXPORTEXIV2API__attribute__((visibility("default")))EXIV2API_Hexiv2lib_STATICexiv2lib_EXPORTSEXIV2LIB_NO_DEPRECATED/* EXIV2API_H *//* DEFINE_NO_DEPRECATED *//* We are using this library *//* We are building this library */const allocator<_Tp>const allocator<_Tp> &allocator<_Tp> &const _Tp *address__non_trivial_if<true, _Unique> *allocator<const void> &const allocator<const void>const allocator<const void> &allocator<void> &const allocator<void>const allocator<void> &allocator<_Tp> *const allocator<_Tp> *allocator<const _Tp>__non_trivial_if<true, _Unique>_Unique__non_trivial_if<_Cond, _Unique>_Condallocator<const void>allocator<void>_LIBCPP___MEMORY_ALLOCATOR_H_LIBCPP_STD_VER <= 17 || defined(_LIBCPP_ENABLE_CXX20_REMOVED_ALLOCATOR_MEMBERS)// _LIBCPP___MEMORY_ALLOCATOR_H// C++20 Removed members//       allocator<void> trivial in C++20.// Note: For ABI compatibility between C++20 and previous standards, we make// allocator// it is safe to start deriving from __non_trivial_if in existing classes.// By making those __non_trivial_if base classes unique, we work around this problem and// classes are not allowed to share the same address.// that inherits from both D1 and D2 will change because the two __non_trivial_if base// have no base classes, but which now derive from __non_trivial_if. The layout of a class// existing class. Without that, imagine we have classes D1 and D2, both of which used to// which makes it possible to avoid breaking the ABI when making this a base class of an// The second template parameter exists to allow giving a unique type to __non_trivial_if,// if the condition is satisfied.// This class provides a non-trivial default constructor to the class that derives from itbasic_iostream<_CharT, _Traits> *const basic_istream<_CharT, _Traits> *const basic_ostringstream<_CharT, _Traits, _Allocator>const basic_ostringstream<_CharT, _Traits, _Allocator> *basic_ostringstream<_CharT, _Traits, _Allocator> *~HttpIoHttpIo *HttpIo &const HttpIoconst HttpIo &HttpIoRemoteIo &const RemoteIoconst RemoteIo &RemoteIoRemoteIo *Impl *XPathIo &const XPathIoconst XPathIo &XPathIoMemIo &const MemIo &MemIoFileIo &const FileIo &FileIoIoCloser &const IoCloserconst IoCloser &IoCloserIoCloser *~IoCloserconst BasicIo &BasicIopopulateFakeDataisopentellseektransfergetbputbtempFilePath_isTemp_bio_bigBlock_EXV_XPATH_MEMIOBASICIO_HPP_ReplaceStringInPlaceHttpImplconst RemoteIo *~RemoteIowriteDataToFileXPathIo *~XPathIoGEN_FILE_EXTTEMP_FILE_EXTconst MemIo *~MemIoconst FileIo *setPath~FileIo~BasicIo// #ifndef BASICIO_HPP_/*!
      @brief The callback function is called by libcurl to write the data
    *//*!
      @brief Like ReplaceStringInPlace() but accepts a unicode path in an std::wstring.
      @return the subject after replacing.
      @note This function is only available on Windows.
     *//*!
      @brief replace each substring of the subject that matches the given search string with the given replacement.
      @return the subject after replacing.
     *//*!
      @brief Like writeFile() but accepts a unicode path in an std::wstring.
      @note This function is only available on Windows.
     *//*!
      @brief Write DataBuf \em buf to file \em path.
      @return Return the number of bytes written.
      @throw Error In case of failure.
     *//*!
      @brief Like readFile() but accepts a unicode path in an std::wstring.
      @note This function is only available on Windows.
     *//*!
      @brief Read file \em path into a DataBuf, which is returned.
      @return Buffer containing the file.
      @throw Error In case of failure.
     *///! Default Destructor// NOT IMPLEMENTED/*!
          @brief Like SshIo(const std::string&  url,  size_t blockSize = 1024) but accepts a
              unicode url in an std::wstring.
          @note This constructor is only available on Windows.
         *//*!
          @brief Constructor that accepts the URL on which IO will be
              performed.
          @param url The full path of url
          @param blockSize the size of the memory block. The file content is
                divided into the memory blocks. These blocks are populated
                on demand from the server, so it avoids copying the complete file.
          @throw Error if it is unable to init ssh session.
         *//*!
        @brief Provides the ssh read/write access and sftp read access for the RemoteIo.
            This class is based on libssh.
    *//*!
          @brief Write access is only available for some protocols. This method
                will call RemoteIo::write(BasicIo& src) if the write access is available
                for the protocol. Otherwise, it throws the Error.
         *//*!
          @brief Write access is only available for some protocols. This method
                will call RemoteIo::write(const byte* data, long wcount) if the write
                access is available for the protocol. Otherwise, it throws the Error.
         *//*!
          @brief Like CurlIo(const std::string&  url,  size_t blockSize = 0) but accepts a
              unicode url in an std::wstring.
          @note This constructor is only available on Windows.
         *//*!
          @brief Constructor that accepts the URL on which IO will be
              performed.
          @param url The full path of url
          @param blockSize the size of the memory block. The file content is
                divided into the memory blocks. These blocks are populated
                on demand from the server, so it avoids copying the complete file.
          @throw Error if it is unable to init curl pointer.
         *//*!
        @brief Provides the http, https read/write access and ftp read access for the RemoteIo.
            This class is based on libcurl.
    *//*!
          @brief Like HttpIo(const std::string& url, size_t blockSize = 1024) but accepts a
              unicode url in an std::wstring.
          @note This constructor is only available on Windows.
         *//*!
          @brief Constructor that accepts the http URL on which IO will be
              performed. The constructor does not open the file, and
              therefore never failes.
          @param url The full path of url
          @param blockSize the size of the memory block. The file content is
                divided into the memory blocks. These blocks are populated
                on demand from the server, so it avoids copying the complete file.
         *//*!
        @brief Provides the http read/write access for the RemoteIo.
    */// class RemoteIo//! Pointer to implementation/*!
          @brief Mark all the bNone blocks to bKnow. This avoids allocating memory
            for parts of the file that contain image-date (non-metadata/pixel data)

          @note This method should be only called after the concerned data (metadata)
                are all downloaded from the remote file to memory.
         *//*
         @brief Like path() but returns a unicode URL path in an std::wstring.
         @note This function is only available on Windows.
        *///!Returns the URL of the file.//!Returns true if the IO position has reached the end, otherwise false.//!Always returns 0//!Returns true if the memory area is allocated./*!
         @brief Get the current memory buffer size in bytes.
         @return Size of the in memory data in bytes;<BR>
                -1 if failure;
        *//*!
         @brief Get the current IO position.
         @return Offset from the start of the memory block
        *//*!
          @brief Not support
          @return 0
         *//*isWriteable*//*!
         @brief Not support
         @return NULL
        *//*!
         @brief Move the current IO position.
         @param offset Number of bytes to move the IO position
             relative to the starting position specified by \em pos
         @param pos Position from which the seek should start
         @return 0 if successful;<BR>
                Nonzero if failure;
        *//*!
          @brief Remove the contents of the file and then transfer data from
              the \em src BasicIo object into the empty file.

          The write access is done in an efficient way. It only sends the range of different
          bytes between the current data and BasicIo instance to the remote machine.

          @param src Reference to another BasicIo instance. The entire contents
              of src are transferred to this object. The \em src object is
              invalidated by the method.
          @throw Error In case of failure

          @note The write access is only supported by http, https, ssh.
         *//*!
         @brief Read one byte from the memory blocks. The IO position is
             advanced by one byte.
             If the memory block is not populated (!= bMemory), it will connect to server
             and populate the data to the memory block.
         @return The byte read from the memory block if successful;<BR>
                EOF if failure;
        *//*!
         @brief Read data from the the memory blocks. Reading starts at the current
             IO position and the position is advanced by the number of
             bytes read.
             If the memory blocks are not populated (!= bMemory), it will connect to server
             and populate the data to memory blocks.
         @param buf Pointer to a block of memory into which the read data
             is stored. The memory block must be at least \em rcount bytes
             long.
         @param rcount Maximum number of bytes to read. Fewer bytes may be
             read if \em rcount bytes are not available.
         @return Number of bytes read from the memory block successfully;<BR>
                0 if failure;
        *//*!
         @brief Read data from the memory blocks. Reading starts at the current
             IO position and the position is advanced by the number of
             bytes read.
             If the memory blocks are not populated (False), it will connect to server
             and populate the data to memory blocks.
         @param rcount Maximum number of bytes to read. Fewer bytes may be
             read if \em rcount bytes are not available.
         @return DataBuf instance containing the bytes read. Use the
               DataBuf::size_ member to find the number of bytes read.
               DataBuf::size_ will be 0 on failure.
        *//*!
         @brief Not support
         @return 0 means failure
        *//*!
          @brief Write data that is read from another BasicIo instance to the remote file.

          The write access is done in an efficient way. It only sends the range of different
          bytes between the current data and BasicIo instance to the remote machine.

          @param src Reference to another BasicIo instance. Reading start
              at the source's current IO position
          @return The size of BasicIo instance;<BR>
                 0 if failure;
          @throw Error In case of failure

          @note The write access is only supported by http, https, ssh.
         *//*!
          @brief Not support this method.
          @return 0 means failure
         *//*!
          @brief Reset the IO position to the start. It does not release the data.
          @return 0 if successful;<BR>
              Nonzero if failure.
         *//*!
          @brief Connect to the remote server, get the size of the remote file and
            allocate the array of blocksMap.

            If the blocksMap is already allocated (this method has been called before),
            it just reset IO position to the start and does not flush the old data.
          @return 0 if successful;<BR>
              Nonzero if failure.
         *///! Destructor. Releases all managed memory./*!
        @brief Provides remote binary file IO by implementing the BasicIo interface. This is an
            abstract class. The logics for remote access are implemented in HttpIo, CurlIo, SshIo which
            are the derived classes of RemoteIo.
    */// class XPathIo// True if the file is a temporary file and it should be deleted in destructor./*!
          @brief Like writeDataToFile(const std::string& orgPath) but accepts a
              unicode url in an std::wstring.
          @note This constructor is only available on Windows.
         *//*!
            @brief Read the data from stdin/data uri path and write them to the file.
            @param orgPath It equals "-" if the input data's from stdin. Otherwise, it's data uri path.
            @return the name of the new file.
            @throw Error if it fails.
         *///! @name Static methods/*!
            @brief Change the name of the temp file and make it untemporary before
                    calling the method of superclass FileIo::transfer.
         *///! Destructor. Releases all managed memory and removes the temp file./*!
          @brief Like XPathIo(const std::string& orgPath) but accepts a
              unicode url in an std::wstring.
          @note This constructor is only available on Windows.
         *///! Default constructor that reads data from stdin/data uri path and writes them to the temp file./*!
            @brief The extension of the generated file which is created when getting input data
                    to add or modify the metadata.
        *//*!
            @brief The extension of the temporary file which is created when getting input data
                    to read metadata. This file will be deleted in destructor.
        *//*!
            @brief Read the data from data uri path and write the data to memory.
            @param path The data uri.
            @throw Error if no base64 data in path.
         *//*!
            @brief Read data from stdin and write the data to memory.
            @throw Error if it can't convert stdin to binary.
         *//*!
          @brief Like XPathIo(const std::string& path) but accepts a
              unicode url in an std::wstring.
          @note This constructor is only available on Windows.
         *//*!
      @brief Provides binary IO for the data from stdin and data uri path.
     */// class MemIo/*
          @brief Like path() but returns a unicode dummy path in an std::wstring.
          @note This function is only available on Windows.
         *///! Returns a dummy path, indicating that memory access is used//!Always returns true/*!
          @brief Get the current memory buffer size in bytes.
          @return Size of the in memory data in bytes;<BR>
                 -1 if failure;
         *//*!
          @brief Get the current IO position.
          @return Offset from the start of the memory block
         *//*!
          @brief Allow direct access to the underlying data buffer. The buffer
                 is not protected against write access in any way, the argument
                 is ignored.
          @note  The application must ensure that the memory pointed to by the
                 returned pointer remains valid and allocated as long as the
                 MemIo object exists.
         *//*!
          @brief Move the current IO position.
          @param offset Number of bytes to move the IO position
              relative to the starting position specified by \em pos
          @param pos Position from which the seek should start
          @return 0 if successful;<BR>
                 Nonzero if failure;
         *//*!
          @brief Clear the memory block and then transfer data from
              the \em src BasicIo object into a new block of memory.

          This method is optimized to simply swap memory block if the source
          object is another MemIo instance. The source BasicIo instance
          is invalidated by this operation and should not be used after this
          method returns. This method exists primarily to be used with
          the BasicIo::temporary() method.

          @param src Reference to another BasicIo instance. The entire contents
              of src are transferred to this object. The \em src object is
              invalidated by the method.
          @throw Error In case of failure
         *//*!
          @brief Read one byte from the memory block. The IO position is
              advanced by one byte.
          @return The byte read from the memory block if successful;<BR>
                 EOF if failure;
         *//*!
          @brief Read data from the memory block. Reading starts at the current
              IO position and the position is advanced by the number of
              bytes read.
          @param buf Pointer to a block of memory into which the read data
              is stored. The memory block must be at least \em rcount bytes
              long.
          @param rcount Maximum number of bytes to read. Fewer bytes may be
              read if \em rcount bytes are not available.
          @return Number of bytes read from the memory block successfully;<BR>
                 0 if failure;
         *//*!
          @brief Read data from the memory block. Reading starts at the current
              IO position and the position is advanced by the number of
              bytes read.
          @param rcount Maximum number of bytes to read. Fewer bytes may be
              read if \em rcount bytes are not available.
          @return DataBuf instance containing the bytes read. Use the
                DataBuf::size_ member to find the number of bytes read.
                DataBuf::size_ will be 0 on failure.
         *//*!
          @brief Write one byte to the memory block. The IO position is
              advanced by one byte.
          @param data The single byte to be written.
          @return The value of the byte written if successful;<BR>
                 EOF if failure;
         *//*!
          @brief Write data that is read from another BasicIo instance to
              the memory block. If needed, the size of the internal memory
              block is expanded. The IO position is advanced by the number
              of bytes written.
          @param src Reference to another BasicIo instance. Reading start
              at the source's current IO position
          @return Number of bytes written to the memory block successfully;<BR>
                 0 if failure;
         *//*!
          @brief Write data to the memory block. If needed, the size of the
              internal memory block is expanded. The IO position is advanced
              by the number of bytes written.
          @param data Pointer to data. Data must be at least \em wcount
              bytes long
          @param wcount Number of bytes to be written.
          @return Number of bytes written to the memory block successfully;<BR>
                 0 if failure;
         *//*!
          @brief Does nothing on MemIo objects.
          @return 0
         *//*!
          @brief Memory IO is always open for reading and writing. This method
                 therefore only resets the IO position to the start.

          @return 0
         *///! Destructor. Releases all managed memory/*!
          @brief Constructor that accepts a block of memory. A copy-on-write
              algorithm allows read operations directly from the original data
              and will create a copy of the buffer on the first write operation.
          @param data Pointer to data. Data must be at least \em size
              bytes long
          @param size Number of bytes to copy.
         *///! Default constructor that results in an empty object/*!
      @brief Provides binary IO on blocks of memory by implementing the BasicIo
          interface. A copy-on-write implementation ensures that the data passed
          in is only copied when necessary, i.e., as soon as data is written to
          the MemIo. The original data is only used for reading. If writes are
          performed, the changed data can be retrieved using the read methods
          (since the data used in construction is never modified).

      @note If read only usage of this class is common, it might be worth
          creating a specialized readonly class or changing this one to
          have a readonly mode.
     */// class FileIo/*
          @brief Like path() but returns the unicode path of the file in an std::wstring.
          @note This function is only available on Windows.
         *///! Returns the path of the file//! Returns true if the file position has reached the end, otherwise false.//! Returns 0 if the file is in a valid state, otherwise nonzero.//! Returns true if the file is open, otherwise false./*!
          @brief Flush any buffered writes and get the current file size
              in bytes.
          @return Size of the file in bytes;<BR>
                 -1 if failure;
         *//*!
          @brief Get the current file position.
          @return Offset from the start of the file if successful;<BR>
                 -1 if failure;
         *//*!
          @brief Like setPath(const std::string& path) but accepts a
              unicode path in an std::wstring.
          @note This method is only available on Windows.
         *//*!
          @brief close the file source and set a new path.
         *//*!
          @brief Remove a mapping established with mmap(). If the mapped area is
                 writeable, this ensures that changes are written back to the
                 underlying file.
          @return 0 if successful;<BR>
                  Nonzero if failure;
         *//*!
          @brief Map the file into the process's address space. The file must be
                 open before mmap() is called. If the mapped area is writeable,
                 changes may not be written back to the underlying file until
                 munmap() is called. The pointer is valid only as long as the
                 FileIo object exists.
          @param isWriteable Set to true if the mapped area should be writeable
                 (default is false).
          @return A pointer to the mapped area.
          @throw Error In case of failure.
         *//*!
          @brief Move the current file position.
          @param offset Number of bytes to move the file position
              relative to the starting position specified by \em pos
          @param pos Position from which the seek should start
          @return 0 if successful;<BR>
                 Nonzero if failure;
         *//*!
          @brief Remove the contents of the file and then transfer data from
              the \em src BasicIo object into the empty file.

          This method is optimized to simply rename the source file if the
          source object is another FileIo instance. The source BasicIo object
          is invalidated by this operation and should not be used after this
          method returns. This method exists primarily to be used with
          the BasicIo::temporary() method.

          @note If the caller doesn't have permissions to write to the file,
              an exception is raised and \em src is deleted.

          @param src Reference to another BasicIo instance. The entire contents
              of src are transferred to this object. The \em src object is
              invalidated by the method.
          @throw Error In case of failure
         *//*!
          @brief Read one byte from the file. The file position is
              advanced by one byte.
          @return The byte read from the file if successful;<BR>
                 EOF if failure;
         *//*!
          @brief Read data from the file. Reading starts at the current
              file position and the position is advanced by the number of
              bytes read.
          @param buf Pointer to a block of memory into which the read data
              is stored. The memory block must be at least \em rcount bytes
              long.
          @param rcount Maximum number of bytes to read. Fewer bytes may be
              read if \em rcount bytes are not available.
          @return Number of bytes read from the file successfully;<BR>
                 0 if failure;
         *//*!
          @brief Read data from the file. Reading starts at the current
              file position and the position is advanced by the number of
              bytes read.
          @param rcount Maximum number of bytes to read. Fewer bytes may be
              read if \em rcount bytes are not available.
          @return DataBuf instance containing the bytes read. Use the
                DataBuf::size_ member to find the number of bytes read.
                DataBuf::size_ will be 0 on failure.
         *//*!
          @brief Write one byte to the file. The file position is
              advanced by one byte.
          @param data The single byte to be written.
          @return The value of the byte written if successful;<BR>
                 EOF if failure;
         *//*!
          @brief Write data that is read from another BasicIo instance to
              the file. The file position is advanced by the number
              of bytes written.
          @param src Reference to another BasicIo instance. Reading start
              at the source's current IO position
          @return Number of bytes written to the file successfully;<BR>
                 0 if failure;
         *//*!
          @brief Write data to the file. The file position is advanced
              by the number of bytes written.
          @param data Pointer to data. Data must be at least \em wcount
              bytes long
          @param wcount Number of bytes to be written.
          @return Number of bytes written to the file successfully;<BR>
                 0 if failure;
         *//*!
          @brief Flush and unwritten data and close the file . It is
              safe to call close on an already closed instance.
          @return 0 if successful;<BR>
                 Nonzero if failure;
         *//*!
          @brief Open the file using using the default access mode of "rb".
              This method can also be used to "reopen" a file which will flush
              any unwritten data and reset the IO position to the start.
          @return 0 if successful;<BR>
              Nonzero if failure.
         *//*!
          @brief Open the file using using the specified mode.

          This method can also be used to "reopen" a file which will flush any
          unwritten data and reset the IO position to the start. Although
          files can be opened in binary or text mode, this class has
          only been tested carefully in binary mode.

          @param mode Specified that type of access allowed on the file.
              Valid values match those of the C fopen command exactly.
          @return 0 if successful;<BR>
              Nonzero if failure.
         *///! Destructor. Flushes and closes an open file./*!
          @brief Like FileIo(const std::string& path) but accepts a
              unicode path in an std::wstring.
          @note This constructor is only available on Windows.
         *//*!
          @brief Constructor that accepts the file path on which IO will be
              performed. The constructor does not open the file, and
              therefore never failes.
          @param path The full path of a file
         *//*!
      @brief Provides binary file IO by implementing the BasicIo
          interface.
     */// class IoCloser// Not implemented//! The BasicIo reference//! Close the BasicIo if it is open//! Destructor, closes the BasicIo reference//! Constructor, takes a BasicIo reference/*!
      @brief Utility class that closes a BasicIo instance upon destruction.
          Meant to be used as a stack variable in functions that need to
          ensure BasicIo instances get closed. Useful when functions return
          errors from many locations.
     */// class BasicIo/*!
          @brief this is allocated and populated by mmap()
         *//*!
          @brief Like path() but returns a unicode path in an std::wstring.
          @note This function is only available on Windows.
         *//*!
          @brief Return the path to the IO resource. Often used to form
              comprehensive error messages where only a BasicIo instance is
              available.
         *///!Returns 0 if the IO source is in a valid state, otherwise nonzero.//!Returns true if the IO source is open, otherwise false./*!
          @brief Get the current size of the IO source in bytes.
          @return Size of the IO source in bytes;<BR>
                 -1 if failure;
         *//*!
          @brief Get the current IO position.
          @return Offset from the start of IO if successful;<BR>
                 -1 if failure;
         *//*!
          @brief Remove a mapping established with mmap(). If the mapped area
                 is writeable, this ensures that changes are written back.
          @return 0 if successful;<BR>
                  Nonzero if failure;
         *//*!
          @brief Direct access to the IO data. For files, this is done by
                 mapping the file into the process's address space; for memory
                 blocks, this allows direct access to the memory block.
          @param isWriteable Set to true if the mapped area should be writeable
                 (default is false).
          @return A pointer to the mapped area.
          @throw Error In case of failure.
         *//*!
          @brief Move the current IO position.
          @param offset Number of bytes to move the position relative
              to the starting position specified by \em pos
          @param pos Position from which the seek should start
          @return 0 if successful;<BR>
              Nonzero if failure;
         *//*!
          @brief Remove all data from this object's IO source and then transfer
              data from the \em src BasicIo object into this object.

          The source object is invalidated by this operation and should not be
          used after this method returns. This method exists primarily to
          be used with the BasicIo::temporary() method.

          @param src Reference to another BasicIo instance. The entire contents
              of src are transferred to this object. The \em src object is
              invalidated by the method.
          @throw Error In case of failure
         *//*!
          @brief Read one byte from the IO source. Current IO position is
              advanced by one byte.
          @return The byte read from the IO source if successful;<BR>
              EOF if failure;
         *//*!
          @brief Read data from the IO source. Reading starts at the current
              IO position and the position is advanced by the number of bytes
              read.
          @param buf Pointer to a block of memory into which the read data
              is stored. The memory block must be at least \em rcount bytes
              long.
          @param rcount Maximum number of bytes to read. Fewer bytes may be
              read if \em rcount bytes are not available.
          @return Number of bytes read from IO source successfully;<BR>
              0 if failure;
         *//*!
          @brief Read data from the IO source. Reading starts at the current
              IO position and the position is advanced by the number of bytes
              read.
          @param rcount Maximum number of bytes to read. Fewer bytes may be
              read if \em rcount bytes are not available.
          @return DataBuf instance containing the bytes read. Use the
              DataBuf::size_ member to find the number of bytes read.
              DataBuf::size_ will be 0 on failure.
         *//*!
          @brief Write one byte to the IO source. Current IO position is
              advanced by one byte.
          @param data The single byte to be written.
          @return The value of the byte written if successful;<BR>
              EOF if failure;
         *//*!
          @brief Write data that is read from another BasicIo instance to
              the IO source. Current IO position is advanced by the number
              of bytes written.
          @param src Reference to another BasicIo instance. Reading start
              at the source's current IO position
          @return Number of bytes written to IO source successfully;<BR>
              0 if failure;
         *//*!
          @brief Write data to the IO source. Current IO position is advanced
              by the number of bytes written.
          @param data Pointer to data. Data must be at least \em wcount
              bytes long
          @param wcount Number of bytes to be written.
          @return Number of bytes written to IO source successfully;<BR>
              0 if failure;
         *//*!
          @brief Close the IO source. After closing a BasicIo instance can not
              be read or written. Closing flushes any unwritten data. It is
              safe to call close on a closed instance.
          @return 0 if successful;<BR>
              Nonzero if failure.
         *//*!
          @brief Open the IO source using the default access mode. The
              default mode should allow for reading and writing.

          This method can also be used to "reopen" an IO source which will
          flush any unwritten data and reset the IO position to the start.
          Subclasses may provide custom methods to allow for
          opening IO sources differently.

          @return 0 if successful;<BR>
              Nonzero if failure.
         *///! Seek starting positions//! BasicIo auto_ptr type/*!
      @brief An interface for simple binary IO.

      Designed to have semantics and names similar to those of C style FILE*
      operations. Subclasses should all behave the same so that they can be
      interchanged.
     */// it uses MemIo. Otherwises, it uses FileIo.// The way to handle data from stdin or data uri path. If EXV_XPATH_MEMIO = 1,// for std::auto_ptr/*
  File:      basicio.hpp
 */biosubjectsearchblockSizercountwcountorgPathisWriteablemodegetProcessPathstrErrorpathOfFileUrlfileExistsfileProtocolbase64decodebase64encodeurldecodeurlencodegetEnvconst Uriconst Uri &UriDecodeEnVarenvHTTPPOSTenvTIMEOUTProtocolpFilepHttppFtppHttpspSftppSshpFileUripDataUripStdinPasswordUsernamePortHostPathQueryStringFUTILS_HPP_// #ifndef FUTILS_HPP_/// @brief Decode the url components./// @brief Parse the input URL to the protocol, host, path, username, password//!< URL password//!< URL username//!< URL port//!< URL host//!< URL protocol//!< URL file path//!< URL query string/*!
      @brief A container for URL components. It also provides the method to parse a
            URL to get the protocol, host, path, port, querystring, username, password.

      Source: http://stackoverflow.com/questions/2616011/easy-way-to-parse-a-url-in-c-cross-platform

      @todo This class can probably be hidden from the API
     *///! @brief Return the path of the current process./*!
      @brief Return a system error message and the error code (errno).
             See %strerror(3).
     *//*!
      @brief Like pathOfFileUrl(const std::string& url) but accepts a unicode path in an std::wstring.
      @note This function is only available on Windows.
     *//*!
      @brief Get the path of file URL.

      @param  url The file URL in the format file:///path or file://host/path
      @return the path of file URL.
     *//*!
      @brief Like fileExists(const std::string& path, bool ct =false) but
            accepts a unicode path in an std::wstring.
      @note This function is only available on Windows.
     *//*!
      @brief Test if a file exists.

      @param  path Name of file to verify.
      @param  ct   Flag to check if <i>path</i> is a regular file.
      @return true if <i>path</i> exists and, if <i>ct</i> is set,
      is a regular file, else false.

      @note The function calls <b>stat()</b> test for <i>path</i>
      and its type, see stat(2). <b>errno</b> is left unchanged
      in case of an error.
     *//*!
      @brief Like fileProtocol() but accept a unicode path in an std::wstring.
      @note This function is only available on Windows.
     *//*!
      @brief Return the protocol of the path.
      @param path The path of file to extract the protocol.
      @return the protocol of the path.
     *//*!
      @brief Decode base64 data and put the resulting string in out.
      @param in The data need to decode.
      @param out The container for the result, it should be large enough to contain the result.
      @param out_size The size of out in bytes.
      @return the size of the resulting string. If it fails, return -1.

      @note Source: https://github.com/davidgaleano/libwebsockets/blob/master/lib/base64-decode.c
      *//*!
      @brief Encode in base64 the data in data_buf and put the resulting string in result.
      @param data_buf The data need to encode
      @param dataLength Size in bytes of the in buffer
      @param result The container for the result, NULL if it fails
      @param resultSize Size in bytes of the out string, it should be at least
             ((dataLength + 2) / 3) * 4 + 1
      @return 1 indicate success

      @note Source: http://en.wikibooks.org/wiki/Algorithm_Implementation/Miscellaneous/Base64
      *//*!
      @brief Like urlencode(char* str) but accept the input url in the std::string and modify it.
      @todo This function can probably be hidden into the implementation details
     *//*!
      @brief Decode the input url.
      @param str The url needs decoding.
      @return the url-decoded version of str.

      @note Be sure to 'free' the returned string after use with 'delete []'.
            Source: http://www.geekhideout.com/urlcode.shtml
      @todo This function can probably be hidden into the implementation details
     *//*!
      @brief Encode the input url.
      @param str The url needs encoding.
      @return the url-encoded version of str.
      @note Source: http://www.geekhideout.com/urlcode.shtml
      @todo This function can probably be hidden into the implementation details
     *//*!
      @brief  Return the value of environmental variable.
      @param[in]  var The name of environmental variable. Must be a member of the enumeration @ref EnVar.
      @return the value of environmental variable. If it's empty, the default value is returned.
      @throws std::out_of_range when an unexpected EnVar is given as input.
     *///! the collection of protocols.//! the name of environmental variables./*!
  @file    futils.hpp
  @brief   Basic file utility functions required by Exiv2
  @author  Andreas Huggel (ahu)
           <a href="mailto:ahuggel@gmx.net">ahuggel@gmx.net</a>
  @date    12-Dec-03, ahu: created<BR>
           02-Apr-05, ahu: moved to Exiv2 namespace
 */ctout_sizedata_bufdataLengthresultSizeenv_varhttpHTTP_HPP_/*!
     @brief execute an HTTP request
     @param request -  a Dictionary of headers to send to server
     @param response - a Dictionary of response headers (dictionary is filled by the response)
     @param errors   - a String with an error
     @return Server response 200 = OK, 404 = Not Found etc...
    */"rwlock.hpp"const XmpPropertyInfoconst XmpPropertyInfo &XmpPropertyInfo &const XmpNsInfoconst XmpNsInfo *XmpNsInfo *lookupNsRegistryconst Prefixconst Prefix &Prefix &printPropertyprintPropertiesnsInfoconst XmpPropertyInfo *XmpPropertyInfo *propertyListnsDescpropertyInfopropertyTypepropertyDescpropertyTitleXmpKey *~XmpKeyXmpKeylookupNsRegistryUnsafeunregisterNsUnsafensInfoUnsafeXmpProperties &const XmpPropertiesconst XmpProperties &XmpPropertiesXmpNsInfo &const XmpNsInfo &const Nsconst Ns &Ns &~NsNs~PrefixPrefixNsRegistryXmpNsInfoXmpPropertyInfoXmpCategoryxmpInternalxmpExternalns_prefix_xmpPropertyInfo_xmpCategory_typeId_xmpValueType_nsRegistry_rwLock_PROPERTIES_HPP_// #ifndef PROPERTIES_HPP_//! Output operator for property info// class XmpKey//! Return the schema namespace for the prefix of the key// Todo: Should this be removed? What about tagLabel then?/*!
          @brief Return the name of the group (the second part of the key).
                 For XMP keys, the group name is the schema prefix name.
        *///! Copy constructor./*!
          @brief Constructor to create an XMP key from a schema prefix
                 and a property name.

          @param prefix   Schema prefix name
          @param property Property name

          @throw Error if the schema prefix is not known.
        *//*!
          @brief Constructor to create an XMP key from a key string.

          @param key The key string.
          @throw Error if the first part of the key is not '<b>Xmp</b>' or
                 the second part of the key cannot be parsed and converted
                 to a known (i.e., built-in or registered) schema prefix.
        *///! Shortcut for an %XmpKey auto pointer./*!
      @brief Concrete keys for XMP metadata.
     */// class XmpProperties/*!
          @brief Get all registered namespaces (for both Exiv2 and XMPsdk)
         *///!< Namespace registry/*!
          @brief Get the registered namespace for a specific \em prefix from the registry.
         *///! Type for the namespace registry/*!
          @brief Unregister all custom namespaces.

          The function only unregisters namespaces registered earlier, it does not
          unregister built-in namespaces.

          @note This invalidates XMP keys generated in any custom namespace.
         *///! lock to be used while modifying properties/*!
          @brief Unregister a custom namespace \em ns.

          The function only has an effect if there is a namespace \em ns
          registered earlier, it does not unregister built-in namespaces.

          @note This invalidates XMP keys generated in this namespace.
         *//*!
          @brief Register namespace \em ns with preferred prefix \em prefix.

          If the prefix is a known or previously registered prefix, the
          corresponding namespace URI is overwritten.

          @note This invalidates XMP keys generated with the previous prefix.
         *///! Interpret and print the value of an XMP property//! Print a list of properties of a schema namespace to output stream \em os./*!
           @brief Return the (preferred) prefix for schema namespace \em ns.
           @param ns Schema namespace
           @return The prefix or an empty string if namespace \em ns is not
                  registered.
         *//*!
          @brief Return information about a schema namespace for \em prefix.
                 Always returns a valid pointer.
          @param prefix The prefix
          @return A pointer to the related information
          @throw Error if no namespace is registered with \em prefix.
         *//*!
          @brief Return read-only list of built-in properties for \em prefix.
          @param prefix Prefix
          @return Pointer to the built-in properties for prefix, may be 0 if
                  none is configured in the namespace info.
          @throw Error if no namespace is registered with \em prefix.
         *//*!
           @brief Return the namespace description for the schema associated
                  with \em prefix.
           @param prefix Prefix
           @return The namespace description
           @throw Error if no namespace is registered with \em prefix.
         *//*!
           @brief Return the namespace name for the schema associated
                  with \em prefix.
           @param prefix Prefix
           @return The namespace name
           @throw Error if no namespace is registered with \em prefix.
         *//*!
          @brief Return information for the property for key.

          If the key is a path to a nested property (one which contains a slash,
          like \c Xmp.MP.RegionInfo/MPRI:Regions), determines the innermost element
          (\c Xmp.MPRI.Regions) and returns its property information.

          @param key The property key
          @return A pointer to the property information, 0 if the
                 key is of an unknown property.
         *//*!
          @brief Return the type for property \em key. The default
                 for unknown keys is xmpText.
          @param key The property key
          @return The type of the property
         *//*!
          @brief Return the description of the property.
          @param key The property key
          @return The description of the property, 0 if the
                 key is of an unknown property.
         *//*!
          @brief Return the title (label) of the property.
          @param key The property key
          @return The title (label) of the property, 0 if the
                 key is of an unknown property.
         *///! XMP property reference, implemented as a static class.//!< Brief description of the namespace//!< List of known properties//!< (Preferred) prefix//!< Namespace//! Comparison operator for prefix//! Comparison operator for namespace//! The namespace string//! For comparison with namespace//! The prefix string.//! For comparison with prefix//! Structure mapping XMP namespaces and (preferred) prefixes.//!< Property description//!< Category (internal or external)//!< Exiv2 default type for the property//!< XMP value type (for info only)//!< Property title or label//!< Property name//! Comparison operator for name//! Information about one XMP property.//! Category of an XMP property/*!
  @file    properties.hpp
  @brief   XMP property and type information.<BR>References:<BR>
  <a href="http://www.adobe.com/devnet/xmp/pdfs/xmp_specification.pdf">XMP Specification</a> from Adobe
  <I>(Property descriptions copied from the XMP specification with the permission of Adobe)</I>
  @author  Andreas Huggel (ahu)
           <a href="mailto:ahuggel@gmx.net">ahuggel@gmx.net</a>
  @author  Gilles Caulier (cgilles)
           <a href="mailto:caulier dot gilles at gmail dot com">caulier dot gilles at gmail dot com</a>
  @date    13-Jul-07, ahu: created
 */property<chrono>_LIBCPP_FILESYSTEM!defined(_LIBCPP_HAS_NO_LOCALIZATION)defined(_LIBCPP_HAS_NO_FILESYSTEM_LIBRARY)// _LIBCPP_FILESYSTEM// enable recursive_directory_iterator range-based for statements// class recursive_directory_iterator// non-default implementation provided to support self-move assign.// constructors and destructor// enable directory_iterator range-based for statements// construct the dir_stream//ctor & dtor/*allow_dne*/// constructors and destructors// operational functions// key function//                filesystem_error to work around PR41078.// TODO(ldionne): We need to pop the pragma and push it again after// See reverse_iterator and __is_stashing_iterator/* _LIBCPP_WIN32API *//* !_LIBCPP_WIN32API */// !_LIBCPP_HAS_NO_LOCALIZATION// iterators// relative paths// Seems to be a server root name// A server root name, like \\server, is always absolute// If no root name, it's relative, e.g. \example is relative to the current drive// A drive letter with no root directory is relative, e.g. x:example.// query// decomposition/* !_LIBCPP_HAS_NO_LOCALIZATION */// generic format observers// character type, and once to replace path delimiters.// it iterates twice over the string; once to convert it to the right// Note: This (and generic_u8string below) is slightly suboptimal as// native format observers// private helper to allow reserving memory in the path// modifiers// concatenation// to append a separator instead of overwriting the path with "/"// is known at compile time to be "/' since the user almost certainly intended// FIXME: Use _LIBCPP_DIAGNOSE_WARNING to produce a diagnostic when __src// appends// assignments// TODO Implement locale conversions./* !_LIBCPP_HAS_NO_CHAR8_T */// observers// constructors// others, the readonly flag is cleared.// permissions, as long as the write bit is set for either owner, group or// file, and the executable bit is always returned as set. When setting// On Windows, these permission bits map to one single readonly flag per// or socket.// On Windows, the library never identifies files as  block, character, fifo// for quoted/*
    filesystem synopsis

    namespace std { namespace filesystem {

    class path;

    void swap(path& lhs, path& rhs) noexcept;
    size_t hash_value(const path& p) noexcept;

    bool operator==(const path& lhs, const path& rhs) noexcept;
    bool operator!=(const path& lhs, const path& rhs) noexcept;
    bool operator< (const path& lhs, const path& rhs) noexcept;
    bool operator<=(const path& lhs, const path& rhs) noexcept;
    bool operator> (const path& lhs, const path& rhs) noexcept;
    bool operator>=(const path& lhs, const path& rhs) noexcept;

    path operator/ (const path& lhs, const path& rhs);

    // fs.path.io operators are friends of path.
    template <class charT, class traits>
    friend basic_ostream<charT, traits>&
    operator<<(basic_ostream<charT, traits>& os, const path& p);

    template <class charT, class traits>
    friend basic_istream<charT, traits>&
    operator>>(basic_istream<charT, traits>& is, path& p);

    template <class Source>
      path u8path(const Source& source);
    template <class InputIterator>
      path u8path(InputIterator first, InputIterator last);

    class filesystem_error;
    class directory_entry;

    class directory_iterator;

    // enable directory_iterator range-based for statements
    directory_iterator begin(directory_iterator iter) noexcept;
    directory_iterator end(const directory_iterator&) noexcept;

    class recursive_directory_iterator;

    // enable recursive_directory_iterator range-based for statements
    recursive_directory_iterator begin(recursive_directory_iterator iter) noexcept;
    recursive_directory_iterator end(const recursive_directory_iterator&) noexcept;

    class file_status;

    struct space_info
    {
      uintmax_t capacity;
      uintmax_t free;
      uintmax_t available;
    };

    enum class file_type;
    enum class perms;
    enum class perm_options;
    enum class copy_options;
    enum class directory_options;

    typedef chrono::time_point<trivial-clock>  file_time_type;

    // operational functions

    path absolute(const path& p);
    path absolute(const path& p, error_code &ec);

    path canonical(const path& p);
    path canonical(const path& p, error_code& ec);

    void copy(const path& from, const path& to);
    void copy(const path& from, const path& to, error_code& ec);
    void copy(const path& from, const path& to, copy_options options);
    void copy(const path& from, const path& to, copy_options options,
                   error_code& ec);

    bool copy_file(const path& from, const path& to);
    bool copy_file(const path& from, const path& to, error_code& ec);
    bool copy_file(const path& from, const path& to, copy_options option);
    bool copy_file(const path& from, const path& to, copy_options option,
                           error_code& ec);

    void copy_symlink(const path& existing_symlink, const path& new_symlink);
    void copy_symlink(const path& existing_symlink, const path& new_symlink,
                              error_code& ec) noexcept;

    bool create_directories(const path& p);
    bool create_directories(const path& p, error_code& ec);

    bool create_directory(const path& p);
    bool create_directory(const path& p, error_code& ec) noexcept;

    bool create_directory(const path& p, const path& attributes);
    bool create_directory(const path& p, const path& attributes,
                                  error_code& ec) noexcept;

    void create_directory_symlink(const path& to, const path& new_symlink);
    void create_directory_symlink(const path& to, const path& new_symlink,
                                          error_code& ec) noexcept;

    void create_hard_link(const path& to, const path& new_hard_link);
    void create_hard_link(const path& to, const path& new_hard_link,
                                  error_code& ec) noexcept;

    void create_symlink(const path& to, const path& new_symlink);
    void create_symlink(const path& to, const path& new_symlink,
                                error_code& ec) noexcept;

    path current_path();
    path current_path(error_code& ec);
    void current_path(const path& p);
    void current_path(const path& p, error_code& ec) noexcept;

    bool exists(file_status s) noexcept;
    bool exists(const path& p);
    bool exists(const path& p, error_code& ec) noexcept;

    bool equivalent(const path& p1, const path& p2);
    bool equivalent(const path& p1, const path& p2, error_code& ec) noexcept;

    uintmax_t    file_size(const path& p);
    uintmax_t    file_size(const path& p, error_code& ec) noexcept;

    uintmax_t    hard_link_count(const path& p);
    uintmax_t    hard_link_count(const path& p, error_code& ec) noexcept;

    bool is_block_file(file_status s) noexcept;
    bool is_block_file(const path& p);
    bool is_block_file(const path& p, error_code& ec) noexcept;

    bool is_character_file(file_status s) noexcept;
    bool is_character_file(const path& p);
    bool is_character_file(const path& p, error_code& ec) noexcept;

    bool is_directory(file_status s) noexcept;
    bool is_directory(const path& p);
    bool is_directory(const path& p, error_code& ec) noexcept;

    bool is_empty(const path& p);
    bool is_empty(const path& p, error_code& ec) noexcept;

    bool is_fifo(file_status s) noexcept;
    bool is_fifo(const path& p);
    bool is_fifo(const path& p, error_code& ec) noexcept;

    bool is_other(file_status s) noexcept;
    bool is_other(const path& p);
    bool is_other(const path& p, error_code& ec) noexcept;

    bool is_regular_file(file_status s) noexcept;
    bool is_regular_file(const path& p);
    bool is_regular_file(const path& p, error_code& ec) noexcept;

    bool is_socket(file_status s) noexcept;
    bool is_socket(const path& p);
    bool is_socket(const path& p, error_code& ec) noexcept;

    bool is_symlink(file_status s) noexcept;
    bool is_symlink(const path& p);
    bool is_symlink(const path& p, error_code& ec) noexcept;

    file_time_type  last_write_time(const path& p);
    file_time_type  last_write_time(const path& p, error_code& ec) noexcept;
    void last_write_time(const path& p, file_time_type new_time);
    void last_write_time(const path& p, file_time_type new_time,
                                 error_code& ec) noexcept;

    void permissions(const path& p, perms prms,
                     perm_options opts=perm_options::replace);
    void permissions(const path& p, perms prms, error_code& ec) noexcept;
    void permissions(const path& p, perms prms, perm_options opts,
                     error_code& ec);

    path proximate(const path& p, error_code& ec);
    path proximate(const path& p, const path& base = current_path());
    path proximate(const path& p, const path& base, error_code &ec);

    path read_symlink(const path& p);
    path read_symlink(const path& p, error_code& ec);

    path relative(const path& p, error_code& ec);
    path relative(const path& p, const path& base=current_path());
    path relative(const path& p, const path& base, error_code& ec);

    bool remove(const path& p);
    bool remove(const path& p, error_code& ec) noexcept;

    uintmax_t    remove_all(const path& p);
    uintmax_t    remove_all(const path& p, error_code& ec);

    void rename(const path& from, const path& to);
    void rename(const path& from, const path& to, error_code& ec) noexcept;

    void resize_file(const path& p, uintmax_t size);
    void resize_file(const path& p, uintmax_t size, error_code& ec) noexcept;

    space_info   space(const path& p);
    space_info   space(const path& p, error_code& ec) noexcept;

    file_status  status(const path& p);
    file_status  status(const path& p, error_code& ec) noexcept;

    bool status_known(file_status s) noexcept;

    file_status  symlink_status(const path& p);
    file_status  symlink_status(const path& p, error_code& ec) noexcept;

    path temp_directory_path();
    path temp_directory_path(error_code& ec);

    path weakly_canonical(path const& p);
    path weakly_canonical(path const& p, error_code& ec);


} }  // namespaces std::filesystem

*///===--------------------------- filesystem -------------------------------===///Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX.sdk/usr/include/sys/_types/_o_sync.hO_SYNC/* O_SYNC *//* synch I/O file integrity *//Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX.sdk/usr/include/sys/_types/_o_dsync.hO_DSYNC0x400000/* O_DSYNC *//* synch I/O data integrity *//Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX.sdk/usr/include/sys/fcntl.h<sys/_types/_o_dsync.h><sys/_types/_o_sync.h>filesec_unset_propertyfilesec_set_propertyfilesec_query_propertyfilesec_get_propertyfilesec_freefilesec_dupfilesec_initflockopen_dprotected_npopenx_npfcntlcreatopenatlog2phys &const log2physconst log2phys &fbootstraptransfer &const fbootstraptransferconst fbootstraptransfer &fspecread &const fspecreadconst fspecread &ftrimactivefile &const ftrimactivefileconst ftrimactivefile &fpunchhole &const fpunchholeconst fpunchhole &fstore &const fstoreconst fstore &fgetsigsinfo &const fgetsigsinfoconst fgetsigsinfo &fchecklv &const fchecklvconst fchecklv &fsupplement &const fsupplementconst fsupplement &fsignatures &const fsignaturesconst fsignatures &radvisory &const radvisoryconst radvisory &flocktimeout &const flocktimeoutconst flocktimeout &flock &const flockconst flock &filesec_property_tFILESEC_OWNERFILESEC_GROUPFILESEC_UUIDFILESEC_MODEFILESEC_ACLFILESEC_GRPUUIDFILESEC_ACL_RAWFILESEC_ACL_ALLOCSIZElog2physfbootstraptransfer_tfbootstraptransferfspecread_tfspecreadftrimactivefile_tftrimactivefilefpunchhole_tfpunchholefstore_tfstorefgetsigsinfo_tfgetsigsinfofchecklv_tfchecklvfsupplement_tfsupplementfsignatures_tfsignaturesradvisoryflocktimeoutl2p_devoffsetl2p_contigbytesl2p_flagsfbt_bufferfbt_lengthfbt_offsetfsr_lengthfsr_offsetreservedfsr_flagsfta_lengthfta_offsetfp_lengthfp_flagsfst_bytesallocfst_lengthfst_offsetfst_posmodefst_flagsfg_sig_is_platformfg_info_requestfg_file_startlv_error_messagelv_error_message_sizelv_file_startfs_orig_fdfs_blob_sizefs_blob_startfs_file_startfs_hash_typeUSER_FSIGNATURES_CDHASH_LENfs_cdhashfs_fsignatures_sizera_countra_offsettimeoutfll_whencel_typel_pidl_lenl_start_FILESEC_REMOVE_ACL((void *)1)_FILESEC_UNSET_PROPERTYFILESEC_GUIDO_ALERT0x20000000O_POPUP0x80000000LOCK_UNLOCK_NBLOCK_EXLOCK_SHGETSIGSINFO_PLATFORM_BINARYF_VOLPOSMODEF_PEOFPOSMODEF_ALLOCATEALLF_ALLOCATECONTIGF_WRLCKF_UNLCKF_RDLCKFD_CLOEXECF_DUPFD_CLOEXECFCNTL_FS_SPECIFIC_BASEF_FSRESERVEDF_GETSIGSINFOF_ADDFILESUPPLF_ADDFILESIGS_INFOF_GETPATH_NOFIRMLINKF_SPECULATIVE_READF_TRIM_ACTIVE_FILEF_PUNCHHOLEF_CHECK_LVF_ADDFILESIGS_RETURNF_BARRIERFSYNCF_ADDFILESIGS_FOR_DYLD_SIMF_FINDSIGSF_GETPROTECTIONLEVELF_SINGLE_WRITERF_TRANSCODEKEYF_GETNOSIGPIPEF_SETNOSIGPIPEF_GETCODEDIRF_GETPATH_MTMINFOF_SETBACKINGSTOREF_GETLKPIDF_LOG2PHYS_EXTF_SETPROTECTIONCLASSF_GETPROTECTIONCLASSF_NODIRECTF_ADDFILESIGSF_ADDSIGSF_GLOBAL_NOCACHEF_THAW_FSF_FREEZE_FSF_PATHPKG_CHECKF_FULLFSYNCF_GETPATHF_LOG2PHYSF_NOCACHEF_RDAHEADF_RDADVISEF_SETSIZEF_PREALLOCATEF_CHKCLEANF_FLUSH_DATAF_SETLKWTIMEOUTF_SETLKWF_SETLKF_GETLKF_SETOWNF_GETOWNF_SETFLF_GETFLF_SETFDF_GETFDF_DUPFDCPF_MASK(CPF_OVERWRITE|CPF_IGNORE_MODE)CPF_IGNORE_MODECPF_OVERWRITEO_NDELAYO_NONBLOCKFNDELAYFNONBLOCKFFDSYNCFFSYNCO_FSYNCFASYNCO_ASYNCFAPPENDO_APPENDO_DP_GETRAWUNENCRYPTEDO_DP_GETRAWENCRYPTEDAT_SYMLINK_NOFOLLOW_ANYAT_FDONLYAT_REALDEVAT_REMOVEDIRAT_SYMLINK_FOLLOWAT_SYMLINK_NOFOLLOWAT_EACCESSAT_FDCWDO_NOFOLLOW_ANYO_CLOEXEC0x01000000O_SYMLINK0x00200000O_DIRECTORYO_NOCTTYO_EVTONLYO_EXCL0x00000800O_TRUNC0x00000400O_CREAT0x00000200O_NOFOLLOW0x00000100O_EXLOCKO_SHLOCKFWRITEFREADO_ACCMODE0x0003O_RDWRO_WRONLYO_RDONLY_SYS_FCNTL_H_/* !_SYS_FCNTL_H_ *//*
 * data-protected non-portable open(2) :
 *  int open_dprotected_np(user_addr_t path, int flags, int class, int dpflags, int mode)
 *//* XXX backwards compatibility *//* XXX these are private to the implementation *//* small, clean popup window *//* force window to popup on open *//*                 OUT: bytes into device *//* F_LOG2PHYS_EXT: IN:  bytes into file *//* F_LOG2PHYS:     OUT: bytes into device *//*                 OUT: number of contiguous bytes at this position *//* F_LOG2PHYS_EXT: IN:  number of bytes to be queried *//* F_LOG2PHYS:     unused so far *//* unused so far *//*
 * For F_LOG2PHYS this information is passed back to user
 * Currently only devoffset is returned - that is the VOP_BMAP
 * result - the disk device address corresponding to the
 * current file offset (likely set with an lseek).
 *
 * The flags could hold an indication of whether the # of
 * contiguous bytes reflects the true extent length on disk,
 * or is an advisory value that indicates there is at least that
 * many bytes contiguous.  For some filesystems it might be too
 * inefficient to provide anything beyond the advisory value.
 * Flags and contiguous bytes return values are not yet implemented.
 * For them the fcntl will nedd to switch from using BMAP to CMAP
 * and a per filesystem type flag will be needed to interpret the
 * contiguous bytes count result from CMAP.
 *
 * F_LOG2PHYS_EXT is a variant of F_LOG2PHYS that uses a passed in
 * file offset and length instead of the current file offset.
 * F_LOG2PHYS_EXT operates on the same structure as F_LOG2PHYS, but
 * treats it as an in/out.
 *//* IN: buffer to be read/written *//* IN: number of bytes to transfer *//* IN: offset to start read/write *//* fbootstraptransfer_t used by F_READBOOTSTRAP and F_WRITEBOOTSTRAP commands *//* IN: size of the region *//* IN: start of the region *//* to maintain 8-byte alignment *//* IN: flags word *//* fspecread_t used by F_SPECULATIVE_READ *//* factive_file_trim_t used by F_TRIM_ACTIVE_FILE *//* (to maintain 8-byte alignment) *//* unused *//* fpunchhole_t used by F_PUNCHHOLE *//* OUT: number of bytes allocated *//* IN: indicates use of offset field *//* fstore_t type used by F_PREALLOCATE command *//* unlock file *//* don't block when locking *//* exclusive file lock *//* shared file lock *//* lock operations for flock(2) *//* OUT: 1 if the signature is a plat form binary, 0 if not *//* IN: Key indicating the info requested *//* IN: Offset in the file to look for a signature, -1 for any signature *//* fgetsigsinfo_t used by F_GETSIGSINFO command *//* At this time F_GETSIGSINFO can only indicate platformness.
 *  As additional requestable information is defined, new keys will be added and the
 *  fgetsigsinfo_t structure will be lengthened to add space for the additional information
 *//*
 * DYLD needs to check if the object is allowed to be combined
 * into the main binary. This is done between the code signature
 * is loaded and dyld is doing all the work to process the LOAD commands.
 *
 * While this could be done in F_ADDFILESIGS.* family the hook into
 * the MAC module doesn't say no when LV isn't enabled and then that
 * is cached on the vnode, and the MAC module never gets change once
 * a process that library validation enabled.
 *//* address of original image           *//* signature blob size                 *//* offset of signature in Mach-O image *//* offset of Mach-O image in FAT file  */// output: hash algorithm type for cdhash// output: cdhash// input: size of this struct (for compatibility)/* Prior to F_ADDFILESIGS_INFO, this struct ended after fs_blob_size. *//* The following fields are only applicable to F_ADDFILESIGS_INFO (64bit only). *//*
 * detached code signatures data type -
 * information passed by user to system used by F_ADDSIGS and F_ADDFILESIGS.
 * F_ADDFILESIGS is a shortcut for files that contain their own signature and
 * doesn't require mapping of the file in order to load the signature.
 *//*
 * advisory file read data type -
 * information passed by user to system
 *//* timespec struct for timeout *//* flock passed for file locking *//*
 * Advisory file segment locking with time out -
 * Information passed to system by user for F_SETLKWTIMEOUT
 *//* type of l_start *//* lock type: read/write, etc. *//* lock owner *//* len = 0 means until end of file *//* starting offset *//*
 * Advisory file segment locking data type -
 * information passed to system by user
 *//* specify volume starting postion *//* we can keep them in sync should we desire *//* Make it past all of the SEEK pos modes so that *//* Position Modes (fst_posmode) for F_PREALLOCATE *//* allocate all requested space or no space at all *//* allocate contigious space *//* allocate flags (F_PREALLOCATE) *//*
 * [XSI] The values used for l_whence shall be defined as described
 * in <unistd.h>
 *//* exclusive or write lock *//* unlock *//* shared or read lock *//* record locking flags (F_GETLK, F_SETLK, F_SETLKW) *//* close-on-exec flag *//* file descriptor flags (F_GETFD, F_SETFD) *//* mark the dup with FD_CLOEXEC */// FS-specific fcntl()'s numbers begin at 0x00010000 and go up/* Placeholder for future usage *//* Look up code signature information attached to a file or slice *//* Add supplemental signature from same file with fd reference to original *//* Add signature from same file, return information *//* return the full path without firmlinks of the fd *//* Synchronous advisory read fcntl for regular and compressed file *//* Trim an active file *//* Deallocate a range of the file *//* Check if Library Validation allows this Mach-O file to be mapped into the calling process *//* Add signature from same file, return end offset in structure on success *//* fsync + issue barrier to drive *//* Add signature from same file, only if it is signed by Apple (used by dyld for simulator) *//* Add detached code signatures (used by dyld for shared libs) *//* Get the protection version number for this filesystem *//* may be broken into smaller chunks with throttling in between *//* file being written to a by single writer... if throttling enabled, writes *//* For some cases, we need to rewrap the key for AKS/MKB *//* Status of SIGPIPE for this fd *//* No SIGPIPE generated on EPIPE *//* Returns the code directory, with associated hashes, to the caller *//* return the full path of the FD, but error in specific mtmd circumstances *//* Mark the file as being the backing store for another filesystem *//* See F_DUPFD_CLOEXEC below for 67 *//* See man fcntl(2) F_GETLK
	                                 * Similar to F_GETLK but in addition l_pid is treated as an input parameter
	                                 * which is used as a matching value when searching locks on the file
	                                 * so that only locks owned by the process with pid l_pid are returned.
	                                 * However, any flock(2) type lock will also be found with the returned value
	                                 * of l_pid set to -1 (as with F_GETLK).
	                                 *//* file offset to device offset, extended *//* Set the protection class of a file for the EA, requires int *//* Get the protection class of a file from the EA, returns int *//* should not be used (i.e. its ok to temporaily create cached pages) *//* used in conjunction with F_NOCACHE to indicate that DIRECT, synchonous writes *//* add signature from same file (used by dyld for shared libs) *//* add detached signatures *//* turn data caching off/on (globally) for this file *//* "thaw" all fs operations *//* "freeze" all fs operations *//* find which component (if any) is a package *//* fsync + ask the drive to flush to the media *//* return the full path of the fd *//* file offset to device offset *//* turn data caching off/on for this fd *//*
 * 46,47 used to be F_READBOOTSTRAP and F_WRITEBOOTSTRAP
 *//* turn read ahead off/on for this fd *//* Issue an advisory read async with no copy to user *//* Truncate a file. Equivalent to calling truncate(2) *//* Preallocate storage *//* Used for regression test *//* F_SETLK; wait if blocked, return on timeout *//* F_SETLK; wait if blocked *//* set record locking information *//* get record locking information *//* set SIGIO/SIGURG proc/pgrp *//* get SIGIO/SIGURG proc/pgrp *//* set file status flags *//* get file status flags *//* set file descriptor flags *//* get file descriptor flags *//* duplicate file descriptor *//* command values *//*
 * Constants used for fcntl(2)
 *//*
 * Flags used for copyfile(2)
 *//* compat *//* kernel *//* kernel/compat *//*
 * The O_* flags used to have only F* names, which were used in the kernel
 * and by fcntl.  We retain the F* names for the kernel f_flags field
 * and for backward compatibility for fcntl.
 *//* Data Protection Flags *//* Path should not contain any symlinks *//* Use only the fd and Ignore the path for fstatat(2) *//* Return real device inodes resides on for fstatat(2) *//* Path refers to directory *//* Act on target of symlink *//* Act on the symlink itself not the target *//* Use effective ids in access check *//*
 * Flags for the at functions
 *//*
 * Descriptor value for the current working directory
 *//* no symlinks allowed in path *//* implicitly set FD_CLOEXEC *///      O_DSYNC         0x00400000      /* synch I/O data integrity *//* allow open of a symlink *//* don't assign controlling terminal *//* descriptor requested for event notifications only *//* error if already exists *//* truncate to zero length *//* create if nonexistant *//* don't follow symlinks *//* source compatibility: do not use *//* signal pgrp when data ready *//* open with exclusive file lock *//* open with shared file lock *//* set append mode *//* no delay *//*
 * Kernel encoding of open mode; separate read and write bits that are
 * independently testable: 1 greater than the above.
 *
 * XXX
 * FREAD and FWRITE are excluded from the #ifdef KERNEL so that TIOCFLUSH,
 * which was documented to use FREAD/FWRITE, continues to work.
 *//* mask for above modes *//* open for reading and writing *//* open for writing only *//* open for reading only *//* open-only flags *//*
 * File status flags: these are used by open(2), fcntl(2).
 * They are also used (indirectly) in the kernel file structure f_flags,
 * which is a superset of the open/fcntl flags.  Open flags and f_flags
 * are inter-convertible using OFLAGS(fflags) and FFLAGS(oflags).
 * Open/fcntl flags begin with O_; kernel-internal flags begin with F.
 *//* We should not be exporting size_t here.  Temporary for gcc bootstrapping. *//*
 * This file includes the definitions for open and fcntl
 * described by POSIX for <fcntl.h>; it also includes
 * related kernel definitions.
 *//*-
 * Copyright (c) 1983, 1990, 1993
 *	The Regents of the University of California.  All rights reserved.
 * (c) UNIX System Laboratories, Inc.
 * All or some portions of this file are derived from material licensed
 * to the University of California by American Telephone and Telegraph
 * Co. or Unix System Laboratories, Inc. and are reproduced herein with
 * the permission of UNIX System Laboratories, Inc.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *	This product includes software developed by the University of
 *	California, Berkeley and its contributors.
 * 4. Neither the name of the University nor the names of its contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 *
 *	@(#)fcntl.h	8.3 (Berkeley) 1/21/94
 *//Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX.sdk/usr/include/fcntl.h<sys/fcntl.h>/Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX.sdk/usr/include/sys/xattr.hflistxattrlistxattrfremovexattrremovexattrfsetxattrsetxattrfgetxattrgetxattrXATTR_RESOURCEFORK_NAME"com.apple.ResourceFork"XATTR_FINDERINFO_NAME"com.apple.FinderInfo"XATTR_MAXNAMELENXATTR_SHOWCOMPRESSIONXATTR_NODEFAULTXATTR_NOSECURITYXATTR_REPLACEXATTR_CREATEXATTR_NOFOLLOW_SYS_XATTR_H_/* _SYS_XATTR_H_ *//* See the ATTR_CMN_FNDRINFO section of getattrlist(2) for details on FinderInfo *//* option for f/getxattr() and f/listxattr() to expose the HFS Compression extended attributes *//* Set this to bypass the default extended attribute file (dot-underscore file) *//* Set this to bypass authorization checking (eg. if doing auth-related work) *//* set the value, fail if attr does not exist *//* set the value, fail if attr already exists *//* Options for setxattr calls *//* Don't follow symbolic links *//* Options for pathname based xattr calls *//*
 * Copyright (c) 2004-2012 Apple Inc. All rights reserved.
 *
 * @APPLE_OSREFERENCE_LICENSE_HEADER_START@
 *
 * This file contains Original Code and/or Modifications of Original Code
 * as defined in and that are subject to the Apple Public Source License
 * Version 2.0 (the 'License'). You may not use this file except in
 * compliance with the License. The rights granted to you under the License
 * may not be used to create, or enable the creation or redistribution of,
 * unlawful or unlicensed copies of an Apple operating system, or to
 * circumvent, violate, or enable the circumvention or violation of, any
 * terms of an Apple operating system software license agreement.
 *
 * Please obtain a copy of the License at
 * http://www.opensource.apple.com/apsl/ and read it before using this file.
 *
 * The Original Code and all software distributed under the License are
 * distributed on an 'AS IS' basis, WITHOUT WARRANTY OF ANY KIND, EITHER
 * EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES,
 * INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE, QUIET ENJOYMENT OR NON-INFRINGEMENT.
 * Please see the License for the specific language governing rights and
 * limitations under the License.
 *
 * @APPLE_OSREFERENCE_LICENSE_HEADER_END@
 */fdnamebuffposition/Users/owura/Repos/codeql_eval/proj_repos/Exiv2-exiv2-pull-962-commits-e925bc5addd881543fa503470c8a859e112cca62/exiv2/src/basicio.cpp<sys/xattr.h><fcntl.h>"http.hpp"st::stat"::stat"FileIo::read"FileIo::read"const char(&)[13]char(&)[13]HttpImpl *~HttpImplHttpImpl &const HttpImplconst HttpImpl &writeRemotescriptPathPlease set the path of the server script to handle http post data to EXIV2_HTTP_POST environmental variable."Please set the path of the server script to handle http post data to EXIV2_HTTP_POST environmental variable."const char[109]char[109]const char(&)[109]char(&)[109]protocolIndex://"://"scriptUriverb"verb"POST"POST"encodeLengthencodeDataoperator new[]urlencodeDatasspath="path=""&"from="from="to="to="data="data="postDataContent-Length: "Content-Length: "Content-Type: application/x-www-form-urlencoded
"Content-Type: application/x-www-form-urlencoded\n"const char[49]char[49]
"\r\n"header"header"getDataByRangeresponseDicGET"GET"Range: bytes="Range: bytes="body"body"getFileLengthHEAD"HEAD"lengthIterContent-Length"Content-Length"p_->isMalloced_nBlocksBlockMap *const BlockMaplowBlockhighBlocknRealDatablocknewIdxunable to open src when transferring"unable to open src when transferring"const char(&)[37]char(&)[37]expectedBlock(long)( p_->size_ - p_->idx_)allowfakeDatasizeof(byte)Unable to allocate data"Unable to allocate data"const char(&)[24]char(&)[24]iBlockstartPostotalReadp_->blockSize_ - startPosblockRblockIndexfindDiffisFakeDatablockDatadataSizeremainp_->blockSize_BlockMap[]the file length is 0"the file length is 0"const char(&)[21]char(&)[21]Impl &const Implconst Impl &populateBlocksisMalloced_blockSize_Data By Range is empty. Please check the permission."Data By Range is empty. Please check the permission."const char(&)[53]char(&)[53]~ImplisMalloced_(false)eof_(false)BlockMap &const BlockMap &BlockMapgetSizeconst BlockMap *getDataisKnownbKnownisInMembMemoryisNonebNonemarkKnownpopulate~BlockMaptimestampstd::ios::out | std::ios::binarystd::ios::out | std::ios::binary | std::ios::truncchar[102400]102400100*1024readBufreadBufSizesizeof(readBuf)const basic_istream<char, char_traits<char>>base64Posbase64,"base64,"decodeDataNo base64 data"No base64 data"const char(&)[15]char(&)[15]Unable to decode base 64."Unable to decode base 64."currentPath"MemIo"const auto_ptr<Impl>p_->size_ - p_->idx_availwriteTotalneed3276832*1024maxBlockSize4*102441943044*1024*1024blockSize * (1 + need / blockSize)wantp_->fp_ != 0'+'StructStat &const Impl *Impl::opRead"munmap"Impl::opWrite PROT_READ"mmap"fileSeekImpl::opSeekwasOpenlastModestatOkorigStModespfpfbuf1a+b"a+b"buf2::remove"::remove"const char(&)[9]char(&)[9]::chmod"::chmod"const char(&)[8]char(&)[8]writeCountcopyXattrFromnamebufSize"listxattr"const char(&)[10]char(&)[10]namebufnamebufPosconst ssize_tvalueSize"getxattr"switchModefp_ != 0oldOpModereopenopReadopWriteopSeekr+b"r+b"isWriteable_(false)const StructStatconst StructStat &StructStatStructStat *blockType_eOpModehostInfo_totalRead_protocol_eof_idx_blocksMap_data_sizeAlloced_opMode_pMappedArea_mappedLength_isWriteable_fp_openMode_.exiv2".exiv2".exiv2_temp".exiv2_temp"EXV_HAVE_SYS_MMAN_HEXV_HAVE_PROCESS_Hdefined(__MINGW__) || (defined(WIN32) && !defined(__CYGWIN))defined WIN32 && !defined __CYGWIN___WIN64defined(EXV_UNICODE_PATH)defined EXV_HAVE_MMAP && defined EXV_HAVE_MUNMAPEXV_HAVE_LSTATSUPPRESS_WARNINGSdefined(WIN32) && defined(REPLACEFILE_IGNORE_MERGE_ERRORS)// remove filepath.exiv2datatemp// replace the original file with filepath.exiv2tmp// copy the tail (from byte toByte to the end of file) of original file to filepath.exiv2tmp// concatenate the filepath.exiv2datatemp to filepath.exiv2tmp// file and the new file) to filepath.exiv2datatemp// upload the data (the byte ranges which are different between the original// copy the head (byte 0 to byte fromByte) of original file to filepath.exiv2tmp//printf("ssh update size=%ld from=%ld to=%ld\n", (long)size, from, to);//std::string cmd = "stat -c %s " + hostInfo_.Path;// ssh// sftp// class RemoteIo::Impl//!< Assignment//!< Copy constructor/*!
          @brief Submit the data to the remote machine. The data replace a part of the remote file.
                The replaced part of remote file is indicated by from and to parameters.
          @param data The data are submitted to the remote machine.
          @param size The size of data.
          @param from The start position in the remote file where the data replace.
          @param to The end position in the remote file where the data replace.
          @note The write access is only available on the SSH protocol. It requires the write permission
                to edit the remote file.
          @throw Error if it fails.
         *//*!
          @brief Get the data by range.
          @param lowBlock The start block index.
          @param highBlock The end block index.
          @param response The data from the server.
          @throw Error if the server returns the error code.
          @note Set lowBlock = -1 and highBlock = -1 to get the whole file content.
         *//*!
          @brief Get the length (in bytes) of the remote file.
          @return Return -1 if the size is unknown. Otherwise it returns the length of remote file (in bytes).
          @throw Error if the server returns the error code.
         */// METHODS//!< sftp file handler//!< SSH pointer//!< host information extracted from path//! Destructor. Closes ssh session and releases all managed memory.//! Constructor accepting a unicode path in an std::wstring//! Internal Pimpl structure of class RemoteIo.// Perform the request, res will get the return code.// url encode// encode base64//curl_easy_setopt(curl_, CURLOPT_VERBOSE, 1); // debugging mode// no progress meter please// reset all options// add the protocol and host to the path// return -1 if unknown// get length// HEAD// so we need the large block size to reduce the overhead of creating the connection.// the reason is that getDataByRange() in FTP always creates the new connection,// The default block size for FTP is much larger than other protocols// init curl pointer//!< The number of seconds to wait while trying to connect./*!
          @brief Submit the data to the remote machine. The data replace a part of the remote file.
                The replaced part of remote file is indicated by from and to parameters.
          @param data The data are submitted to the remote machine.
          @param size The size of data.
          @param from The start position in the remote file where the data replace.
          @param to The end position in the remote file where the data replace.
          @throw Error if it fails.
          @note The write access is only available on HTTP & HTTPS protocols. The data are submitted to server
                via POST method. It requires the script file on the remote machine to receive the data
                and edit the remote file. The server-side script may be specified with the environment
                string EXIV2_HTTP_POST. The default value is "/exiv2.php". More info is available at
                http://dev.exiv2.org/wiki/exiv2
         *///!< libcurl pointer//! Destructor. Cleans up the curl pointer and releases all managed memory.// create the header// standadize the path without "/" at the beginning.// class HttpIo::HttpImpl/*!
          @brief Submit the data to the remote machine. The data replace a part of the remote file.
                The replaced part of remote file is indicated by from and to parameters.
          @param data The data are submitted to the remote machine.
          @param size The size of data.
          @param from The start position in the remote file where the data replace.
          @param to The end position in the remote file where the data replace.
          @note The data are submitted to the remote machine via POST. This requires the script file
                on the remote machine to receive the data and edit the remote file. The server-side
                script may be specified with the environment string EXIV2_HTTP_POST. The default value is
                "/exiv2.php". More info is available at http://dev.exiv2.org/wiki/exiv2
          @throw Error if it fails.
         *///!< the host information extracted from the path//! Internal Pimpl structure of class HttpIo.// if (newIdx < 0 || newIdx > (long) p_->size_) return 1;// #1198.  Don't return 1 when asked to seek past EOF.  Stay calm and set eof_//not very sure about this. need more test!!    - note by Shawn  fly2xj@gmail.com //TODO/*newIdx < 0 || */// connect to the remote machine & populate the blocks just in time./*unused data*/// submit to the remote machine.// free buf// fake data// find $right// find $left/*
         * The idea is to compare the file content, find the different bytes and submit them to the remote machine.
         * To simplify it, it:
         *      + goes from the left, find the first different position -> $left
         *      + goes from the right, find the first different position -> $right
         * The different bytes are [$left-$right] part.
         */// means failure/* unused wcount*//* unused data*/// means OK// file is empty// unable to get the length of remote file, get the whole file content.// reset the IO position// optimize: ignore all true blocks on left & right sides./*!
          @brief Get the data from the remote machine and write them to the memory blocks.
          @param lowBlock The start block index.
          @param highBlock The end block index.
          @return Number of bytes written to the memory block successfully
          @throw Error if it fails.
         *//*!
          @brief Submit the data to the remote machine. The data replace a part of the remote file.
                The replaced part of remote file is indicated by from and to parameters.
          @param data The data are submitted to the remote machine.
          @param size The size of data.
          @param from The start position in the remote file where the data replace.
          @param to The end position in the remote file where the data replace.
          @note The write access is available on some protocols. HTTP and HTTPS require the script file
                on the remote machine to handle the data. SSH requires the permission to edit the file.
          @throw Error if it fails.
         *///!< bytes requested from host//!< the protocol of url//!< EOF indicator//!< Was the blocksMap_ allocated?//!< Index into the memory area//!< The file size//!< An array contains all blocksMap//!< Size of the block memory.//!< Unicode path//!< (Standard) path//! Internal Pimpl abstract structure of class RemoteIo.// read data uri and write to the temp file.// read stdin and write to the temp file.// convert stdin to binary// generating the name for temp file.// call super class method// printf("Warning: Failed to rename the temp file. \n");// rename the file// replace temp path to gent path.// printf ("Warning: Unable to remove the temp file %s.\n", tempFilePath_.c_str());// error when removing file// Generic reopen to reset position to start// Optimization if src is another instance of MemIo// Allocate in blocks// Minimum size for 1st block// 32768           `// class BlockMap/*!
          @brief Change the status to bKnow. bKnow blocks do not contain the data,
                but they keep the size of data. This avoids allocating memory for parts
                of the file that contain image-date (non-metadata/pixel data) which never change in exiv2.
          @param num The size of the data
         *///! @param num The size of data//! @param source The data populate to the block//! @brief Populate the block.//! Default constructor. the init status of the block is bNone.//! the status of the block./*!
      @brief Utility class provides the block mapping to the part of data. This avoids allocating
            a single contiguous block of memory to the big data.
     */// class MemIo::Impl//!< Reserve memory//!< Was the buffer allocated?//!< Size of the allocated buffer//!< Size of the memory area//!< Pointer to the start of the memory area//!< Constructor 2//!< Default constructor//! Internal Pimpl structure of class MemIo.// Default open is in read-only binary mode// This is required on msvcrt before stat after writing to a file// Flush and commit only if the file is open for writing// FileIo::transfer// Generic handling, reopen both to reset to start// if (fileIo)// Set original file permissions// Check permissions of new file// (see also http://stackoverflow.com/a/11023068)// like a virus scanner or disk indexer// that file has been opened with FILE_SHARE_DELETE by another process,// if the target filename still exists, which regularly happens when// Windows implementation that deals with the fact that ::rename fails// EXV_UNICODE_PATH// if (p_->wpMode_ == Impl::wpUnicode)// MSVCRT rename that does not overwrite existing files// !EXV_HAVE_LSTAT// EXV_HAVE_LSTAT// We need the permissions of the file, not the symlink// In case path() is a symlink, get the path of the linked-to file// So that the allocated memory is freed. Must have same scope as pf// Get the permissions of the file, or linked-to file, on platforms which have lstat// Remove the (temporary) file// Check if the file can be written to, if it already exists// Optimization if src is another instance of FileIo// try to reset back to where write stopped// Workaround for platforms without mmap: Read the file into memory// reject those files.// Applications should test for files with a length of 0 (zero) and// an error code of ERROR_FILE_INVALID.// TODO: An attempt to map a file with a length of 0 (zero) fails with// Windows implementation// defined WIN32 && !defined __CYGWIN__// FileIo::Impl::winNumberOfLinks// FileIo::Impl::copyXattrFrom// No xattr support for this platform.// #906.  Mountain Lion 'sandbox' terminates the app when we call setxattr// No extended attributes in source file// FileIo::Impl::stat// FileIo::Impl::switchMode// 'Manual' open("r+b") to avoid munmap()// Reopen the file// Flush. On msvcrt fflush does not do the job// flush when switching _to_ opSeek.// Don't do anything when switching _from_ opSeek mode; we// Flush if current mode allows writing, else reopen// as in this case we know that we can write to the file)// Flush if current mode allows reading, else reopen (in mode "r+b"// class FileIo::Impl// Windows function to determine the number of hardlinks (on NTFS)//! copy extended attributes (xattr) from another file//! stat wrapper for internal use/*!
          @brief Switch to a new access mode, reopening the file if needed.
              Optimized to only reopen the file when it is really necessary.
          @param opMode The mode to switch to.
          @return 0 if successful
         */// #endif//!< Number of hard links (broken on Windows, see winNumberOfLinks())//!< Permissions//! Simple struct stat wrapper for internal use// TYPES//!< Can the mapped area be written to?//!< Is the mapped area allocated?//!< Size of the memory-mapped area//!< Pointer to the memory-mapped area//!< Handle from CreateFileMapping//!< Duplicated fd//!< File open mode//!< File stream pointer//!< Indicates which path is in use//! Used to indicate if the path is stored as a standard or unicode string//! Mode of operation// Enumerations//! Internal Pimpl structure of class FileIo.// Windows doesn't provide nlink_t// Platform specific headers for handling extended attributes (xattr)// for getpid, stat// for mmap and munmap// for stat, chmod// timestamp for the name of temporary file// for alloc, realloc, free// for remove, rename// _O_BINARY in FileIo::FileIo// write the temporary file// std::memcpy/*
  File:      basicio.cpp
 */opModecodecvt<_CharT, char, state_type>auto_ptr<BasicIo>auto_ptr<Impl>auto_ptr<Impl> &basic_filebuf<char, char_traits<char>> &const basic_filebuf<char, char_traits<char>> &const codecvt<char, char, __mbstate_t>const codecvt<char, char, __mbstate_t> *codecvt<char, char, __mbstate_t> *basic_ifstream<char, char_traits<char>> &const basic_ifstream<char, char_traits<char>>const basic_ifstream<char, char_traits<char>> &basic_ofstream<char, char_traits<char>> &const basic_ofstream<char, char_traits<char>>const basic_ofstream<char, char_traits<char>> &auto_ptr<Impl> *const auto_ptr<Impl> *const basic_istream<char, char_traits<char>> *basic_istream<char, char_traits<char>> *operator std::__1::basic_filebuf<char, std::__1::char_traits<char>> *unsafeGetIteratorAtunsafeAtconst PtrSliceStorage<storage_type>const PtrSliceStorage<storage_type> *PtrSliceStorage<storage_type> *storage_typePtrSliceStorageNull pointer passed to slice constructor"Null pointer passed to slice constructor"ContainerStoragecontainercontainer &slice_typesubSliceto_const_baseconst MutableSliceBase<storage_type, data_type>const MutableSliceBase<storage_type, data_type> *MutableSliceBase<storage_type, data_type> *MutableSliceBasedata_typedata_type &const ConstSliceBase<storage_type, data_type>const ConstSliceBase<storage_type, data_type> *ConstSliceBase<storage_type, data_type> *const SliceBaseconst SliceBase *SliceBase *ConstSliceBasemakeSliceUntilmakeSliceFromSliceBase &const SliceBase &SliceBaserangeCheckIndex outside of the slice"Index outside of the slice"Begin must be smaller than end"Begin must be smaller than end"SliceSlice<T *> *const containerconst container &PtrSliceStorage<storage_type>ContainerStorage<container>MutableSliceBase<storage_type, data_type>base_typeConstSliceBase<storage_type, data_type>remove_pointer<T *const>T *constremove_pointer<T *>remove_pointer<T>remove_cv<T>remove_volatile<volatile T>volatile Tremove_volatile<T>remove_const<const T>remove_const<T>Slice<T *>Slice<const T *>Slice<const container>Slice<container>storage_end_begin_EXIV2_INCLUDE_SLICE_HPPInternalindex <= data_.size()/* EXIV2_INCLUDE_SLICE_HPP *//*!
     * Overload of makeSliceUntil for pointer based slices.
     *//*!
     * @brief Return a new slice spanning until `end`.
     *//*!
     * @brief Return a new slice spanning from begin until the end of the
     * container.
     *//*!
     * @brief Return a new slice spanning the whole container.
     *//*!
     * Overload of makeSlice for slices of C-arrays.
     *//*!
     * @brief Return a new slice with the given bounds.
     *
     * Convenience wrapper around the slice's constructor for automatic template
     * parameter deduction.
     */// TODO: use using in C++11/*!
     * Specialization of slices for (mutable) C-arrays.
     *//*!
         * Constructor.
         *
         * @param[in] ptr  C-array of which a slice should be constructed. Must
         *     not be a null pointer.
         * @param[in] begin  Index of the first element in the slice.
         * @param[in] end  Index of the first element that is no longer in the
         *     slice.
         *
         * Please note that the constructor has no way how to verify that
         * `begin` and `end` are not out of bounds of the provided array!
         *//*!
     * Specialization of slices for constant C-arrays.
     *
     * These have exactly the same interface as the slices for STL-containers,
     * with the *crucial* exception, that the slice's constructor *cannot* make
     * a proper bounds check! It can only verify that you didn't accidentally
     * swap begin and end!
     *//*!
     * @brief Specialization of slices for constant containers.
     *//*!
         * Constructs a new constant subSlice. Behaves otherwise exactly like
         * the non-const version.
         *//*!
         * Construct a sub-slice of this slice with the given bounds. The bounds
         * are evaluated with respect to the current slice.
         *
         * @param[in] begin  First element in the new slice.
         * @param[in] end  First element beyond the new slice.
         *
         * @throw std::out_of_range when begin or end are invalid
         *//*!
         * @brief Construct a slice of the container `cont` starting at `begin`
         * (including) and ending before `end`.
         *
         * @param[in] cont Reference to the container
         * @param[in] begin First element of the slice.
         * @param[in] end First element beyond the slice.
         *
         * @throws std::out_of_range For invalid slice bounds: when end is not
         * larger than begin or when the slice's bounds are larger than the
         * container's size.
         *
         * Please note that due to the requirement that `end` must be larger
         * than `begin` (they cannot be equal) it is impossible to construct a
         * slice with zero length.
         *//*!
     * @brief Slice (= view) for STL containers.
     *
     * This is a very simple implementation of slices (i.e. views of sub-arrays)
     * for STL containers that support O(1) element access and random access
     * iterators (like std::vector, std::array and std::string).
     *
     * A slice represents the semi-open interval [begin, end) and provides a
     * (mutable) view, it does however not own the data! It can be used to
     * conveniently pass parts of containers into functions without having to use
     * iterators or offsets.
     *
     * In contrast to C++20's std::span<T> it is impossible to read beyond the
     * container's bounds and unchecked access is not-possible (by design).
     *
     * Example usage:
     * ~~~~~~~~~~~~~~~~~~~~~~~~~{.cpp}
     * std::vector<int> vec = {0, 1, 2, 3, 4};
     * slice<std::vector<int> > one_two(vec, 1, 3);
     * assert(one_two.size() == 2);
     * assert(one_two.at(0) == 1 && one_two.at(1) == 2);
     * // mutate the contents:
     * one_two.at(0) *= 2;
     * one_two.at(1) *= 3;
     * assert(one_two.at(0) == 2 && one_two.at(1) == 6);
     * ~~~~~~~~~~~~~~~~~~~~~~~~~
     *
     * Slices also offer access via iterators of the same type as the underlying
     * container, so that they can be used in a comparable fashion:
     * ~~~~~~~~~~~~~~~~~~~~~~~~~{.cpp}
     * std::vector<int> vec = {0, 1, 2, 3, 4};
     * slice<std::vector<int>> three_four(vec, 3, 5);
     * assert(*three_four.begin() == 3 && *three_four.end() == 4);
     * // this prints:
     * // 3
     * // 4
     * for (const auto & elem : three_four) {
     *     std::cout << elem << std::endl;
     * }
     * ~~~~~~~~~~~~~~~~~~~~~~~~~
     *
     * @tparam container A STL container type, like vector or array. Must support
     * array-like access via the `at()` method.
     */// namespace Internal/*!
             * Obtain an iterator (=pointer) at the position of the element with
             * the given index in the container.
             *
             * @throw nothing
             *//*!
             * Obtain a reference to the element with the given `index` in the
             * array.
             *
             * @throw nothing
             */// TODO: change this to nullptr once we use C++11/*end*//*begin*//*!
             * Stores ptr and checks that it is not `NULL`. The slice's bounds
             * are ignored, as we do not know the array's length.
             *
             * @throw std::invalid_argument when ptr is `NULL`
             *//*!
         * @brief Implementation of the storage concept for slices of C arrays.
         *
         * @tparam storage_type  Type as which the C-array should be stored. Use
         * this parameter to save constant arrays as `const` and mutable ones as
         * non-`const`.
         */// we are screwed if the container got changed => try to catch it/*!
             * Obtain an iterator at the position of the element with the given
             * index in the container.
             *
             * @throw whatever container::begin() and std::advance() throw
             *//*!
             * Obtain a constant reference to the element with the given `index`
             * in the container.
             *
             * @throw whatever container::at() throws
             *//* begin*//*!
             * @throw std::out_of_range when end is larger than the container's
             * size.
             *//*!
         * Implementation of the storage concept for STL-containers.
         *
         * @tparam container  Type of the STL-container.
         */// additions are safe, begin & end are smaller than size()// throw an exception)// end == 0 is not a legal value (subtraction will underflow and// element beyond the slice// end == size() is a legal value, since end is the first/*!
             * Create a mutable sub-slice with the given bounds (with respect to
             * the current slice).
             *
             * @tparam slice_type  Type of the slice that this function shall
             * return. Provide it with the type of the class that derives from
             * mutable_slice_base.
             *//*!
             * Explicitly convert this instance into a base-class of the
             * appropriate constant version of this slice.
             *
             * This function is required to properly implement the `subSlice()
             * const` function for mutable slices. The problem here is, that a
             * slice<T> and a slice<const T> actually don't share the same base
             * class `ConstSliceBase<storage_type, T>`. Instead `slice<T>`
             * inherits from `ConstSliceBase<storage_type, T>` and `slice<const
             * T>` inherits from `ConstSliceBase<storage_type, const T>`.
             *
             * Now, `slice<T>` can call the `subSlice() const` method from its
             * base class, but that will return a mutable `slice<T>`! Instead we
             * use this function to convert the ``slice<T>` into the parent of
             * the appropriate `slice<const T>` and call its `subSlice() const`,
             * which returns the correct type.
             *//*!
             * Obtain an iterator to the first element beyond the slice.
             *//*!
             * Obtain an iterator to the first element in the slice.
             */// TODO: use using base_type::at once we have C++11/*!
             * Obtain a reference to the element with the specified index in the
             * slice.
             *
             * @throw std::out_of_range when index is out of bounds of the slice
             *//*!
             * Forwards everything to the constructor of const_slice_base
             *
             * @todo use using once we have C++11
             *//*!
         * This class provides all public-facing non-const-qualified methods of
         * slices. It only re-implements the const-qualified versions as
         * non-const.
         *//*!
             * Stores a reference to the actual data.
             */// additions are safe, begin and end are smaller than size()/*!
             * Create a constant sub-slice with the given bounds (with respect
             * to the current slice).
             *
             * @tparam slice_type  Type of the slice that this function shall
             * return. Provide it with the type of the class that derives from
             * mutable_slice_base.
             *//*!
             * Obtain a constant iterator to the first beyond the slice.
             *//*!
             * Obtain a constant iterator to the first element in the slice.
             */// => no overflow is possible// thus: index + begin < end <= SIZE_T_MAX// and: index < end - begin// we know: begin_ < end <= size() <= SIZE_T_MAX/*!
             * Obtain a constant reference to the element with the specified
             * index in the slice.
             *
             * @throw std::out_of_range when index is out of bounds of the slice
             *//*!
             * Default contructor, requires begin to be smaller than end,
             * otherwise an exception is thrown. Also forwards all parameters to
             * the constructor of storage_
             *//*!
         * @brief This class provides the public-facing const-qualified methods
         * of a slice.
         *
         * The public methods are implemented in a generic fashion using a
         * storage_type. This type contains the actual reference to the data to
         * which the slice points and provides the following methods:
         *
         * - (const) value_type& unsafeAt(size_t index) (const)
         *   Return the value at the given index of the underlying container,
         *   without promising to perform a range check and without any
         *   knowledge of the slices' size
         *
         * - const_iterator/iterator unsafeGetIteratorAt(size_t index) (const)
         *   Return a (constant) iterator at the given index of the underlying
         *   container. Again, no range checks are promised.
         *
         * - Constructor(data_type& data, size_t begin, size_t end)
         *   Can use `begin` & `end` to perform range checks on `data`, but
         *   should not store both values. Must not take ownership of `data`!
         *
         * - Must save data as a public member named `data_`.
         *
         * - Must provide appropriate typedefs for iterator, const_iterator and
         *   value_type
         *//*!
             * lower and upper bounds of the slice with respect to the
             * container/array stored in storage_
             *//*!
             * Throw an exception when index is too large.
             *
             * @throw std::out_of_range when `index` will access an element
             * outside of the slice
             */// cannot underflow, as we know that begin < end/*!
             * Return the number of elements in the slice.
             *//*!
         * Common base class of all slice implementations.
         *
         * Implements only the most basic functions, which do not require any
         * knowledge about the stored data.
         */// TODO: remove these custom implementations once we have C++11/*!
  @file    slice.hpp
  @brief   Simple implementation of slices (=views) for STL containers and C-arrays
  @author  Dan ermk (D4N)
           <a href="mailto:dan.cermak@cgc-instruments.com">dan.cermak@cgc-instruments.com</a>
  @date    30-March-18, D4N: created
 *//*
 * Copyright (C) 2004-2018 Exiv2 maintainers
 *
 * This program is part of the Exiv2 distribution.
 *
 * This program is free software; you can redistribute it and/or
 * modify it under the terms of the GNU General Public License
 * as published by the Free Software Foundation; either version 2
 * of the License, or (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin Street, 5th Floor, Boston, MA 02110-1301 USA.
 */cont__new_endconst TagInfo &TagInfo &isExifGroupisMakerGroupdefaultCountsectionNametaglisttagListExifTags &const ExifTagsconst ExifTags &ExifTagsGroupInfo &const GroupInfo &const GroupNameconst GroupName &GroupName &~GroupNameGroupNameExifKey *defaultTypeIdtagDescsetIdx~ExifKeyExifKeyTagInfoGroupInfoTagListFctPrintFctg_tagList_groupName_ifdName_ifdId_printFct_sectionId_TAGS_HPP_// #ifndef TAGS_HPP_//! Output operator for TagInfo// class ExifKey//! Return the index (unique id of this key within the original Exif data, 0 if not set)// Todo: should be in the base class//! Return the default type id for this tag.//! Return the tag description.//! Set the index./*!
          @brief Constructor to create an Exif key from a TagInfo instance.
          @param ti The TagInfo instance
          @throw Error if the key cannot be constructed from the tag number
                 and group name.
         *//*!
          @brief Constructor to create an Exif key from the tag number and
                 group name.
          @param tag The tag value
          @param groupName The name of the group, i.e., the second part of
                 the Exif key.
          @throw Error if the key cannot be constructed from the tag number
                 and group name.
         *//*!
          @brief Constructor to create an Exif key from a key string.

          @param key The key string.
          @throw Error if the first part of the key is not '<b>Exif</b>' or
                 the remainin parts of the key cannot be parsed and
                 converted to a group name and tag name.
        *///! Shortcut for an %ExifKey auto pointer./*!
      @brief Concrete keys for Exif metadata and access to Exif tag reference data.
     */// class ExifTags/*!
          @brief Return true if \em groupName is a TIFF or Exif IFD, else false.
                 This is used to differentiate between standard Exif IFDs
                 and IFDs associated with the makernote.
        *//*!
          @brief Return true if \em groupName is a makernote group.
        *///! Return the name of the IFD for the group.//! Return the default number of components (not bytes!) \em key has. (0=any, -1=count not known)//! Return the name of the section for an Exif \em key.//! Print the list of tags for \em groupName//! Print a list of all standard Exif tags to output stream//! Return read-only list of built-in \em groupName tags.//! Return read-only list of built-in groups//! Access to Exif group and tag lists and misc. tag reference methods, implemented as a static class.// struct TagInfo//!< Pointer to tag print function//!< The number of values (not bytes!), 0=any, -1=count not known.//!< Type id//!< Section id//!< Link to the (preferred) IFD//!< Short tag description//!< Tag title//!< One word tag label//!< Tag//! Tag information//!< Group name//! Search key to find a GroupInfo by its group name.//!< Tag list//!< Group name, unique for each group.//!< IFD name//!< IFD id//!< Comparison operator for group name//!< Comparison operator for IFD id//! The details of an Exif group. Groups include IFDs and binary arrays.//! A function returning a tag list.//! Type for a function pointer for functions interpreting the tag value/*!
  @file    tags.hpp
  @brief   Exif tag and type information
  @author  Andreas Huggel (ahu)
           <a href="mailto:ahuggel@gmx.net">ahuggel@gmx.net</a>
  @date    15-Jan-04, ahu: created<BR>
           11-Feb-04, ahu: isolated as a component
 */tisectionIdprintFct/Users/owura/Repos/codeql_eval/proj_repos/Exiv2-exiv2-pull-962-commits-e925bc5addd881543fa503470c8a859e112cca62/exiv2/include/exiv2/bigtiffimage.hppbigtiffisBigTiffTypenewBigTiffInstance/Users/owura/Repos/codeql_eval/proj_repos/Exiv2-exiv2-pull-962-commits-e925bc5addd881543fa503470c8a859e112cca62/exiv2/src/image_int.hppbinaryToHexbinaryToStringconst binaryToStringHelper<T>const binaryToStringHelper<T> &binaryToStringHelper<T> &buf_bTrailingNullstringFormatbinaryToStringHelperbinaryToStringHelper<T> *binaryToStringHelper<T>ATTRIBUTE_FORMAT_PRINTF__attribute__((format(printf, 1, 0)))IMAGE_INT_HPP_(defined(__GNUG__) || defined(__GNUC__)) || defined(__clang__)printf// #ifndef IMAGE_INT_HPP_// namespace Internal, Exiv2/*!
      @brief indent output for kpsRecursive in \em printStructure() \em .
     *//*!
      @brief format binary for display of raw data .
     *//*!
     * @brief format binary data for display in @ref Image::printStructure()
     *
     * This function creates a new helper class that can be passed to a
     * `std::ostream` for output. It creates a printable version of the binary
     * data in the slice sl according to the following rules:
     * - characters with numeric values larger than 0x20 (= space) and smaller
     *   or equal to 0x7F (Delete) are printed as ordinary characters
     * - characters outside of that range are printed as '.'
     * - if the last element of the slice is 0, then it is omitted
     *
     * @param[in] sl  Slice containing binary data buffer that should be
     *     printed.
     *
     * @return Helper object, that can be passed into a std::ostream and
     *     produces an output according to the aforementioned rules.
     *
     * @throw This function does not throw. The output of the helper object to
     *     the stream throws neither.
     */// <- buf_ would be now dangling, were it a reference// binaryToString(makeSlice(buf, 0, n));// invoke:// the Slice is stored by value to avoid dangling references, in case we/*!
     * @brief Actual implementation of the output algorithm described in @ref
     * binaryToString
     *
     * @throws nothing
     *//*!
     * @brief Helper struct for binary data output via @ref binaryToString.
     *
     * The only purpose of this struct is to provide a custom
     * `operator<<(std::ostream&)` for the output of binary data, that is not
     * used for all Slices by default.
     *//*!
      @brief format a string in the pattern of \em sprintf \em .
     *//*!
  @file    image_int.hpp
  @brief   Internal image helpers
  @author  Andreas Huggel (ahu)
           <a href="mailto:ahuggel@gmx.net">ahuggel@gmx.net</a>
  @date    10-May-15, ahu: created
 */binToStrsl/Users/owura/Repos/codeql_eval/proj_repos/Exiv2-exiv2-pull-962-commits-e925bc5addd881543fa503470c8a859e112cca62/exiv2/src/safe_op.hpp/Users/owura/Repos/codeql_eval/proj_repos/Exiv2-exiv2-pull-962-commits-e925bc5addd881543fa503470c8a859e112cca62/exiv2/src/bigtiffimage.cpp"enforce.hpp""image_int.hpp""safe_op.hpp""bigtiffimage.hpp"readHeaderbyte[2]unsigned char[2]magic0x2A0x2Bbyte[4]unsigned char[4]const ByteOrderconst ByteOrder &ByteOrder &byte[8]unsigned char[8]const uint64_tBigTiffImage &const BigTiffImageconst BigTiffImage &BigTiffImagereadDataconst BigTiffImage *BigTiffImage *printIFDbFirstbPrintentriesconst HeaderHeader::StandardTifftooBignextDirOffsetSTRUCTURE OF BIGTIFF FILE "STRUCTURE OF BIGTIFF FILE "entries = "entries = "spkountpadusePointer address |    tag                           |     " address |    tag                           |     " type |    count |    offset | value
" type |    count |    offset | value\n"restoreentrySize%8u | %#06x %-25s |%10s |%9u |"%8u | %#06x %-25s |%10s |%9u |"%10u | "%10u | "dir_offset%10s | "%10s | "const binaryToStringHelper<unsigned char *>const binaryToStringHelper<unsigned char *> &binaryToStringHelper<unsigned char *> & ..." ..."346650x87690x014aifdOffset337230x83bbread_bytes375000x927cjumpbyte[20]unsigned char[20]charsNikon"Nikon"nikon_bytesNikon makernote"Nikon makernote"makernote"makernote"END "END "~BigTiffImageheader_.isValid()ImageType::bigtiffdataSize_(0)doSwap_(false)Header &const Header &HeaderHeader *dirOffsetconst Header *isValid()StandardTiffBigTiffisValiddata_size_(0)validdoSwap_dataSize_header_dir_offset_data_size_version_// restore// position// tag is an IFD// TODO: fix it// printTiffStructure(memIo,out,option,depth);// create a file// tag is an embedded tiff// read// save/* MakerNote */// TODO: once we have C++11 use bytes.data()// allocate memory/* IPTCNAA *//*SubIFDs*//* ExifTag */// copy data// use 'data' as data :)// read into buffer// big data? Use 'data' as pointer to real data// again more than 2^64// more than we can handle// we got number bigger than 2^64// (don't perform that check when count == 0 => will cause a division by zero exception)// size > std::numeric_limits<uint64_t>::max() / count// =>// size * count > std::numeric_limits<uint64_t>::max()// #55 and #56 memory allocation crash test/data/POC8// restrict long arrays// TODO: figure out what's going on with kount//prepare to print the value// output spacer// Read data as raw value. what should be done about it will be decided depending on type// Read the dictionary// Read top of directory// buffer// overrides// null// 4 or 8// 42 or 43     - regular tiff or big tifforderauto_ptr_ref<Image>auto_ptr_ref<Image> &const auto_ptr_ref<Image>const auto_ptr_ref<Image> &binaryToStringHelper<unsigned char *>binaryToStringHelper<unsigned char *> *numeric_limits<unsigned long long>const float_round_styleconst float_denorm_stylenumeric_limitsnumeric_limits<unsigned long long> &const numeric_limits<unsigned long long>const numeric_limits<unsigned long long> &round_styletinyness_beforetrapsis_modulois_boundedis_iec559has_denorm_losshas_denormhas_signaling_NaNhas_quiet_NaNhas_infinitymax_exponent10max_exponentmin_exponent10min_exponentradixis_exactis_integeris_signedmax_digits10digits10digitsis_specializedauto_ptr<Image>Slice<unsigned char *>Slice<unsigned char *> *operator std::__1::auto_ptr_ref<Exiv2::Image>auto_ptr<BasicIo> *vector<unsigned char, allocator<unsigned char>> *const vector<unsigned char, allocator<unsigned char>> *__vector_base<unsigned char, allocator<unsigned char>> *const __vector_base<unsigned char, allocator<unsigned char>>const __vector_base<unsigned char, allocator<unsigned char>> *resOverflow in addition"Overflow in addition"summand_1summand_2const MutableSliceBase<PtrSliceStorage, unsigned char *>const ConstSliceBase<PtrSliceStorage, unsigned char *>operator Exiv2::BasicIo *operator Exiv2::Image *ConstSliceBase<PtrSliceStorage, unsigned char *>ConstSliceBase<PtrSliceStorage, unsigned char *> &const ConstSliceBase<PtrSliceStorage, unsigned char *> &MutableSliceBase<PtrSliceStorage, unsigned char *>MutableSliceBase<PtrSliceStorage, unsigned char *> &const MutableSliceBase<PtrSliceStorage, unsigned char *> &__libcpp_numeric_limits<unsigned long long, true>__libcpp_numeric_limits<unsigned long long, true> &const __libcpp_numeric_limits<unsigned long long, true>const __libcpp_numeric_limits<unsigned long long, true> &const unsigned long longconst MutableSliceBase<PtrSliceStorage, unsigned char *> *MutableSliceBase<PtrSliceStorage, unsigned char *> *const ConstSliceBase<PtrSliceStorage, unsigned char *> *ConstSliceBase<PtrSliceStorage, unsigned char *> *allocator<unsigned char> &unsigned char *&__libcpp_compute_min<unsigned long long, 64, false>__libcpp_compute_min<unsigned long long, 64, false> &const __libcpp_compute_min<unsigned long long, 64, false>const __libcpp_compute_min<unsigned long long, 64, false> &is_arithmetic<unsigned long long>is_arithmeticis_arithmetic<unsigned long long> &const is_arithmetic<unsigned long long>const is_arithmetic<unsigned long long> &PtrSliceStorage<unsigned char *>PtrSliceStorage<unsigned char *> &const PtrSliceStorage<unsigned char *>const PtrSliceStorage<unsigned char *> &remove_cv<unsigned char>remove_cv<unsigned char> &const remove_cv<unsigned char>const remove_cv<unsigned char> &const PtrSliceStorage<unsigned char *> *PtrSliceStorage<unsigned char *> *remove_const<unsigned char>remove_const<unsigned char> &const remove_const<unsigned char>const remove_const<unsigned char> &~BmpImageBmpImage *BmpImage &const BmpImageconst BmpImage &BmpImagebmpBMPIMAGE_HPP_isBmpTypenewBmpInstanceconst BmpImage *// #ifndef BMPIMAGE_HPP_//! Check if the file iIo is a Windows Bitmap image./*!
      @brief Create a new BmpImage instance and return an auto-pointer to it.
             Caller owns the returned object and the auto-pointer ensures that
             it will be deleted.
     */// ImageFactory needs to be made a friend.// These could be static private functions on Image subclasses but then// class BmpImage/*!
          @brief Not supported. Calling this function will throw an instance
              of Error(kerInvalidSettingForImage).
         *//*!
          @brief Todo: Not supported yet(?). Calling this function will throw
              an instance of Error(kerInvalidSettingForImage).
         *//*!
          @brief Todo: Write metadata back to the image. This method is not
              yet(?) implemented. Calling it will throw an Error(kerWritingImageFormatUnsupported).
         *//*!
          @brief Constructor to open a Windows bitmap image. Since the
              constructor can not return a result, callers should check the
              good() method after object construction to determine success
              or failure.
          @param io An auto-pointer that owns a BasicIo instance used for
              reading and writing image metadata. \b Important: The constructor
              takes ownership of the passed in BasicIo instance through the
              auto-pointer. Callers should not continue to use the BasicIo
              instance after it is passed to this method.  Use the Image::io()
              method to get a temporary reference.
         *///! @name NOT Implemented/*!
      @brief Class to access Windows bitmaps. This is just a stub - we only
          read width and height.
     *///!< Windows bitmap (bmp) image type (see class BmpImage)// Add Windows Bitmap (BMP) to the supported image formats/*!
  @file    bmpimage.hpp
  @brief   Windows Bitmap (BMP) image
  @author  Marco Piovanelli, Ovolab (marco)
           <a href="mailto:marco.piovanelli@pobox.com">marco.piovanelli@pobox.com</a>
  @date    05-Mar-2007, marco: created
 */iIo/Users/owura/Repos/codeql_eval/proj_repos/Exiv2-exiv2-pull-962-commits-e925bc5addd881543fa503470c8a859e112cca62/exiv2/src/bmpimage.cpp"bmpimage.hpp" 2const unsigned char[2]BmpImageId'B'matched-lenimage/x-ms-bmp"image/x-ms-bmp"Image comment"Image comment"BMP"BMP"IPTC metadata"IPTC metadata"Exif metadata"Exif metadata"const BasicIo *byte[54]unsigned char[54]ImageType::bmp/*create*/// Todo: implement me!/*
          The Windows bitmap header goes as follows -- all numbers are in little-endian byte order:

          offset  length   name                   description
          ======  =======  =====================  =======
           0      2 bytes  signature              always 'BM'
           2      4 bytes  bitmap size
           6      4 bytes  reserved
          10      4 bytes  bitmap offset
          14      4 bytes  header size
          18      4 bytes  bitmap width
          22      4 bytes  bitmap height
          26      2 bytes  plane count
          28      2 bytes  depth
          30      4 bytes  compression            0 = none; 1 = RLE, 8 bits/pixel; 2 = RLE, 4 bits/pixel; 3 = bitfield; 4 = JPEG; 5 = PNG
          34      4 bytes  image size             size of the raw bitmap data, in bytes
          38      4 bytes  horizontal resolution  (in pixels per meter)
          42      4 bytes  vertical resolution    (in pixels per meter)
          46      4 bytes  color count
          50      4 bytes  important colors       number of "important" colors
        */// Ensure that this is the correct image type// not supported/*comment*//*iptcData*//*exifData*//*
  File:      bmpimage.cpp
  Author(s): Marco Piovanelli, Ovolab (marco)
  History:   05-Mar-2007, marco: created
 */const auto_ptr<BasicIo> *EXV_HAVE_PRINTUCS2EXV_HAVE_ICONVEXV_HAVE_LENSDATAEXIV2_TWEAK_VERSION"0.27.2.2"EXV_PACKAGE_STRING"exiv2 0.27.2.2"EXV_PACKAGE_NAME"exiv2"EXV_HAVE_LIBZEXV_HAVE_SYS_TYPES_HEXV_HAVE_SYS_STAT_HEXV_HAVE_MUNMAPEXV_HAVE_MMAPEXV_HAVE_STRINGS_HEXV_HAVE_STDBOOL_HEXV_HAVE_MEMORY_HEXV_HAVE_REGEX_HEXV_ICONV_CONSTEXV_HAVE_STRERROR_REXV_ENABLE_NLSEXV_HAVE_GMTIME_R_EXV_CONF_H_defined(ICONV_ACCEPTS_CONST_INPUT) || defined(__NetBSD__)/* !_EXV_CONF_H_ */// Definition to enable conversion of UCS2 encoded Windows tags to UTF-8.// Define if you have the iconv function.// Definition to enable translation of Nikon lens names./* Define to the version of this package. *//* Define to the full name and version of this package. *//* Define to the full name of this package. *//* Define if you have (Exiv2/xmpsdk) Adobe XMP Toolkit. *//* #undef EXV_HAVE_PROCESS_H */// Define if you have the <process.h> header file.// Define if you have are using the zlib library.// Define if you have the <sys/mman.h> header file./* Define if you have the <unistd.h> header file. */// Define if you have  the <sys/types.h> header file.// Define if you have <sys/stat.h> header file.// Define if you have the munmap function.// Define if you have the mmap function.// Define if you have the <strings.h> header file.// Define if you have the <stdint.h> header file.// Define if stdbool.h conforms to C99.// Define if have the <memory.h> header file.// Define if you have the <regex.h> header file./* #undef ICONV_ACCEPTS_CONST_INPUT *//* Define to `const' or to empty, depending on the second argument of `iconv'. *//* #undef EXV_UNICODE_PATH */// Define to enable the Windows unicode path support./* #undef EXV_STRERROR_R_CHAR_P */// Define if the strerror_r function returns char*.// Define if you have the strerror_r function./* #undef EXV_ENABLE_VIDEO */// Define if you want video support.// Define if you want translation of program messages to the user's native language/* #undef EXV_HAVE_LIBINTL_H */// Define if you have the <libintl.h> header file.// Define if you have the `gmtime_r' function./* #undef EXV_ENABLE_WEBREADY */// Define if you require webready support./* #undef EXV_USE_CURL */// Define to 1 if you want to use libcurl in httpIO./* #undef EXV_USE_SSH */// Defined if you want to use libssh for SshIO.// File generated by cmake from cmake/config.h.cmake.EXV_SEPARATOR_CHR_CONFIG_H__WIN32_WINNT_MSC_VER < 1800_MSC_VER >= _MSC_VER_2008HAVE_PID_T__MING____CYGWIN__defined(__CYGWIN32__) || defined(__CYGWIN64__)defined(__BYTE_ORDER__) && defined(__ORDER_LITTLE_ENDIAN__)__BYTE_ORDER__  ==         __ORDER_LITTLE_ENDIAN__defined(_MSC_VER) || defined(__CYGWIN__) || defined(__MINGW__)defined(WIN32) && !defined(__CYGWIN__)// _CONFIG_H_/////////////////////////////////////////// Path separator marcos      ////////// End of platform marcos //////////*
  If you're using Solaris and the Solaris Studio compiler
  you must -library=stdcxx4 along with these inclusions below
*////// Start of platform marcos ////////////////////////////////////////////////////// End of Visual Studio Support /////// _MSC_VER/* On Microsoft compilers pid_t has to be set to int. */// Disable warnings from std templates about exporting interfaces// Disable warnings about 'deprecated' standard functions// Visual Studio 2012 and earlier// Constants required by Microsoft SDKs to define SHGetFolderPathA and others///// Start of Visual Studio Support /////// config.h__get_nullptr_tconst nullptr_t &nullptr_tnullptr_t *operator _Tp _Up::*operator _Tp *const nullptr_t *operator int std::__1::nullptr_t::__nat::*nullptr_VSTD::__get_nullptr_t()_LIBCPP_NULLPTR// _LIBCPP_NULLPTR// _LIBCPP_HAS_NO_NULLPTR//===--------------------------- __nullptr --------------------------------===//<wchar.h>__libcpp_wmemchr__libcpp_wcsstr__libcpp_wcsrchr__libcpp_wcspbrk__libcpp_wcschrwmemchrwcsstrwcsrchrwcspbrkwcschr__CORRECT_ISO_CPP_WCHAR_H_PROTO_LIBCPP_WCHAR_Hdefined(__need_wint_t) || defined(__need_mbstate_t)!defined(_LIBCPP_WCHAR_H)defined(_WCHAR_H_CPLUSPLUS_98_CONFORMANCE_)__GLIBC_PREREQ(2, 10)defined(_CRT_CONST_CORRECT_OVERLOADS)defined(__cplusplus) && !defined(_LIBCPP_WCHAR_H_HAS_CONST_OVERLOADS) && defined(_LIBCPP_PREFERRED_OVERLOAD)defined(__cplusplus) && defined(_LIBCPP_MSVCRT_LIKE)// _LIBCPP_WCHAR_H// requirement for wide characters altogether. Also see rdar://82342411.// That breaks using-declarations in <cwchar>. In the future, we should remove the// RTKit's libc does not currently forward-declare `struct tm` like it's supposed to.// TODO:// __cplusplus && _LIBCPP_MSVCRT// extern "C++"// Determine whether we have const-correct overloads for wcschr and friends./*
    wchar.h synopsis

Macros:

    NULL
    WCHAR_MAX
    WCHAR_MIN
    WEOF

Types:

    mbstate_t
    size_t
    tm
    wint_t

int fwprintf(FILE* restrict stream, const wchar_t* restrict format, ...);
int fwscanf(FILE* restrict stream, const wchar_t* restrict format, ...);
int swprintf(wchar_t* restrict s, size_t n, const wchar_t* restrict format, ...);
int swscanf(const wchar_t* restrict s, const wchar_t* restrict format, ...);
int vfwprintf(FILE* restrict stream, const wchar_t* restrict format, va_list arg);
int vfwscanf(FILE* restrict stream, const wchar_t* restrict format, va_list arg);  // C99
int vswprintf(wchar_t* restrict s, size_t n, const wchar_t* restrict format, va_list arg);
int vswscanf(const wchar_t* restrict s, const wchar_t* restrict format, va_list arg);  // C99
int vwprintf(const wchar_t* restrict format, va_list arg);
int vwscanf(const wchar_t* restrict format, va_list arg);  // C99
int wprintf(const wchar_t* restrict format, ...);
int wscanf(const wchar_t* restrict format, ...);
wint_t fgetwc(FILE* stream);
wchar_t* fgetws(wchar_t* restrict s, int n, FILE* restrict stream);
wint_t fputwc(wchar_t c, FILE* stream);
int fputws(const wchar_t* restrict s, FILE* restrict stream);
int fwide(FILE* stream, int mode);
wint_t getwc(FILE* stream);
wint_t getwchar();
wint_t putwc(wchar_t c, FILE* stream);
wint_t putwchar(wchar_t c);
wint_t ungetwc(wint_t c, FILE* stream);
double wcstod(const wchar_t* restrict nptr, wchar_t** restrict endptr);
float wcstof(const wchar_t* restrict nptr, wchar_t** restrict endptr);         // C99
long double wcstold(const wchar_t* restrict nptr, wchar_t** restrict endptr);  // C99
long wcstol(const wchar_t* restrict nptr, wchar_t** restrict endptr, int base);
long long wcstoll(const wchar_t* restrict nptr, wchar_t** restrict endptr, int base);  // C99
unsigned long wcstoul(const wchar_t* restrict nptr, wchar_t** restrict endptr, int base);
unsigned long long wcstoull(const wchar_t* restrict nptr, wchar_t** restrict endptr, int base);  // C99
wchar_t* wcscpy(wchar_t* restrict s1, const wchar_t* restrict s2);
wchar_t* wcsncpy(wchar_t* restrict s1, const wchar_t* restrict s2, size_t n);
wchar_t* wcscat(wchar_t* restrict s1, const wchar_t* restrict s2);
wchar_t* wcsncat(wchar_t* restrict s1, const wchar_t* restrict s2, size_t n);
int wcscmp(const wchar_t* s1, const wchar_t* s2);
int wcscoll(const wchar_t* s1, const wchar_t* s2);
int wcsncmp(const wchar_t* s1, const wchar_t* s2, size_t n);
size_t wcsxfrm(wchar_t* restrict s1, const wchar_t* restrict s2, size_t n);
const wchar_t* wcschr(const wchar_t* s, wchar_t c);
      wchar_t* wcschr(      wchar_t* s, wchar_t c);
size_t wcscspn(const wchar_t* s1, const wchar_t* s2);
size_t wcslen(const wchar_t* s);
const wchar_t* wcspbrk(const wchar_t* s1, const wchar_t* s2);
      wchar_t* wcspbrk(      wchar_t* s1, const wchar_t* s2);
const wchar_t* wcsrchr(const wchar_t* s, wchar_t c);
      wchar_t* wcsrchr(      wchar_t* s, wchar_t c);
size_t wcsspn(const wchar_t* s1, const wchar_t* s2);
const wchar_t* wcsstr(const wchar_t* s1, const wchar_t* s2);
      wchar_t* wcsstr(      wchar_t* s1, const wchar_t* s2);
wchar_t* wcstok(wchar_t* restrict s1, const wchar_t* restrict s2, wchar_t** restrict ptr);
const wchar_t* wmemchr(const wchar_t* s, wchar_t c, size_t n);
      wchar_t* wmemchr(      wchar_t* s, wchar_t c, size_t n);
int wmemcmp(wchar_t* restrict s1, const wchar_t* restrict s2, size_t n);
wchar_t* wmemcpy(wchar_t* restrict s1, const wchar_t* restrict s2, size_t n);
wchar_t* wmemmove(wchar_t* s1, const wchar_t* s2, size_t n);
wchar_t* wmemset(wchar_t* s, wchar_t c, size_t n);
size_t wcsftime(wchar_t* restrict s, size_t maxsize, const wchar_t* restrict format,
                const tm* restrict timeptr);
wint_t btowc(int c);
int wctob(wint_t c);
int mbsinit(const mbstate_t* ps);
size_t mbrlen(const char* restrict s, size_t n, mbstate_t* restrict ps);
size_t mbrtowc(wchar_t* restrict pwc, const char* restrict s, size_t n, mbstate_t* restrict ps);
size_t wcrtomb(char* restrict s, wchar_t wc, mbstate_t* restrict ps);
size_t mbsrtowcs(wchar_t* restrict dst, const char** restrict src, size_t len,
                 mbstate_t* restrict ps);
size_t wcsrtombs(char* restrict dst, const wchar_t** restrict src, size_t len,
                 mbstate_t* restrict ps);

*///===--------------------------- wchar.h ----------------------------------===//const nothrow_tconst nothrow_t &nothrow_t &__launder__libcpp_aligned_free__libcpp_aligned_alloc__libcpp_deallocate_unsized__libcpp_deallocate__do_deallocate_handle_size__libcpp_allocate__libcpp_operator_delete__libcpp_operator_new__is_overaligned_for_new__throw_bad_allocget_new_handlerset_new_handlerbad_array_new_length &const bad_array_new_lengthconst bad_array_new_length &bad_array_new_length~bad_array_new_lengthbad_alloc &const bad_allocconst bad_alloc &bad_alloc~bad_allocnothrow_talign_val_t(size_t)-1new_handler_THROW_BAD_ALLOCthrow(std::bad_alloc)_LIBCPP_HAS_NO_SIZED_DEALLOCATION_LIBCPP_HAS_NO_LIBRARY_SIZED_DEALLOCATION_LIBCPP_HAS_NO_LANGUAGE_SIZED_DEALLOCATION_LIBCPP_NEWdefined(_LIBCPP_ABI_VCRUNTIME)!defined(__cpp_sized_deallocation) || __cpp_sized_deallocation  < 201309L!defined(_LIBCPP_BUILDING_LIBRARY) && _LIBCPP_STD_VER < 14 && \defined(_LIBCPP_HAS_NO_LIBRARY_SIZED_DEALLOCATION) || \!defined(_LIBCPP_ABI_VCRUNTIME)!defined(_LIBCPP_HAS_NO_LIBRARY_ALIGNED_ALLOCATION) && \defined(_LIBCPP_CXX03_LANG)_LIBCPP_HAS_NO_LIBRARY_ALIGNED_ALLOCATION__STDCPP_DEFAULT_NEW_ALIGNMENT____has_builtin(__builtin_operator_new) && __has_builtin(__builtin_operator_delete)defined(_LIBCPP_HAS_NO_ALIGNED_ALLOCATION)!defined(_LIBCPP_HAS_NO_LIBRARY_ALIGNED_ALLOCATION)defined(_LIBCPP_MSVCRT_LIKE)defined(_LIBCPP_ON_RTKIT) || defined(_LIBCPP_ON_SEP)!(is_same<void, typename remove_cv<_Tp>::type>::value), "can't launder cv-void"!(is_function<_Tp>::value), "can't launder functions"16UL// _LIBCPP_NEW// !_LIBCPP_HAS_NO_ALIGNED_ALLOCATION// If posix_memalign fails, __result is unmodified so we still return `nullptr`.// TODO: Transition to using aligned_alloc by default// Returns the allocated memory, or `nullptr` on failure.// chances are that you want to use `__libcpp_allocate` instead.// allocation routines -- if you need to allocate memory inside the library,// on the target platform. This is used to implement libc++'s own memory// Low-level helpers to call the aligned allocation and deallocation functions// !_LIBCPP_ABI_VCRUNTIME// std// feature.// Enable the declaration even if the compiler doesn't support the language// not in C++ spec// purposefully not using versioning namespace/*
    new synopsis

namespace std
{

class bad_alloc
    : public exception
{
public:
    bad_alloc() noexcept;
    bad_alloc(const bad_alloc&) noexcept;
    bad_alloc& operator=(const bad_alloc&) noexcept;
    virtual const char* what() const noexcept;
};

class bad_array_new_length : public bad_alloc // C++14
{
public:
    bad_array_new_length() noexcept;
};

enum class align_val_t : size_t {}; // C++17

struct destroying_delete_t { // C++20
  explicit destroying_delete_t() = default;
};
inline constexpr destroying_delete_t destroying_delete{}; // C++20

struct nothrow_t { explicit nothrow_t() = default; };
extern const nothrow_t nothrow;
typedef void (*new_handler)();
new_handler set_new_handler(new_handler new_p) noexcept;
new_handler get_new_handler() noexcept;

// 21.6.4, pointer optimization barrier
template <class T> constexpr T* launder(T* p) noexcept; // C++17
}  // std

void* operator new(std::size_t size);                                   // replaceable, nodiscard in C++20
void* operator new(std::size_t size, std::align_val_t alignment);       // replaceable, C++17, nodiscard in C++20
void* operator new(std::size_t size, const std::nothrow_t&) noexcept;   // replaceable, nodiscard in C++20
void* operator new(std::size_t size, std::align_val_t alignment,
                   const std::nothrow_t&) noexcept;                     // replaceable, C++17, nodiscard in C++20
void  operator delete(void* ptr) noexcept;                              // replaceable
void  operator delete(void* ptr, std::size_t size) noexcept;            // replaceable, C++14
void  operator delete(void* ptr, std::align_val_t alignment) noexcept;  // replaceable, C++17
void  operator delete(void* ptr, std::size_t size,
                      std::align_val_t alignment) noexcept;             // replaceable, C++17
void  operator delete(void* ptr, const std::nothrow_t&) noexcept;       // replaceable
void  operator delete(void* ptr, std:align_val_t alignment,
                      const std::nothrow_t&) noexcept;                  // replaceable, C++17

void* operator new[](std::size_t size);                                 // replaceable, nodiscard in C++20
void* operator new[](std::size_t size,
                     std::align_val_t alignment) noexcept;              // replaceable, C++17, nodiscard in C++20
void* operator new[](std::size_t size, const std::nothrow_t&) noexcept; // replaceable, nodiscard in C++20
void* operator new[](std::size_t size, std::align_val_t alignment,
                     const std::nothrow_t&) noexcept;                   // replaceable, C++17, nodiscard in C++20
void  operator delete[](void* ptr) noexcept;                            // replaceable
void  operator delete[](void* ptr, std::size_t size) noexcept;          // replaceable, C++14
void  operator delete[](void* ptr,
                        std::align_val_t alignment) noexcept;           // replaceable, C++17
void  operator delete[](void* ptr, std::size_t size,
                        std::align_val_t alignment) noexcept;           // replaceable, C++17
void  operator delete[](void* ptr, const std::nothrow_t&) noexcept;     // replaceable
void  operator delete[](void* ptr, std::align_val_t alignment,
                        const std::nothrow_t&) noexcept;                // replaceable, C++17

void* operator new  (std::size_t size, void* ptr) noexcept;             // nodiscard in C++20
void* operator new[](std::size_t size, void* ptr) noexcept;             // nodiscard in C++20
void  operator delete  (void* ptr, void*) noexcept;
void  operator delete[](void* ptr, void*) noexcept;

*///===----------------------------- new ------------------------------------===//__throw_bad_castbad_typeid &const bad_typeidconst bad_typeid &bad_typeid~bad_typeidbad_cast &const bad_castconst bad_cast &~bad_castbad_castbad_cast *const type_info *type_info *hash_codebefore~type_infotype_info__type_info_implementations &const __type_info_implementationsconst __type_info_implementations &__non_unique_arm_rtti_bit_impl &const __non_unique_arm_rtti_bit_implconst __non_unique_arm_rtti_bit_impl &__is_type_name_unique9223372036854775808__non_unique_rtti_bit::value__lt__builtin_strcmp__eq__hash__string_to_type_name__type_name_to_string9223372036854775807~__non_unique_rtti_bit::value__non_unique_impl__non_unique_impl &const __non_unique_implconst __non_unique_impl &5381__string_impl_base &const __string_impl_baseconst __string_impl_base &__unique_impl__unique_impl &const __unique_implconst __unique_impl &__type_name_t__type_info_implementations__non_unique_arm_rtti_bit_impl__non_unique_rtti_bit__string_impl_base__impl__type_name_LIBCPP_TYPE_INFO_VTABLE_POINTER_AUTH_LIBCPP_TYPEINFO_COMPARISON_IMPLEMENTATION__LIBCPP_TYPEINFOdefined(_LIBCPP_ABI_MICROSOFT)_LIBCPP_OBJECT_FORMAT_COFFdefined(__APPLE__) && defined(__LP64__) && !defined(__x86_64__)_LIBCPP_TYPEINFO_COMPARISON_IMPLEMENTATION == 1_LIBCPP_TYPEINFO_COMPARISON_IMPLEMENTATION == 2_LIBCPP_TYPEINFO_COMPARISON_IMPLEMENTATION == 3defined(__arm64__) && __has_cpp_attribute(clang::ptrauth_vtable_pointer)// __LIBCPP_TYPEINFO// defined(_LIBCPP_ABI_VCRUNTIME)// defined(_LIBCPP_ABI_MICROSOFT)// this implementation is actually used.// The unique bit is the top bit. It is expected that __type_name_t is 64 bits when// is unique and the other one isn't. In both cases they are unequal.// Either both are unique and have a different address, or one of them// On all other platforms, assume the Itanium C++ ABI and use the Unique implementation.// On arm64 on Apple platforms, use the special NonUniqueARMRTTIBit implementation.// Windows binaries can't merge typeinfos, so use the NonUnique implementation.// we pick a default implementation based on the platform here.// This value can be overriden in the __config_site. When it's not overriden,// boundaries, such types are thus considered different types.// to be deduplicated by the linker within the linked image. Across linked image// a unique RTTI: the RTTI is emitted with linkonce_odr linkage and is assumed// Otherwise, types declared with hidden visibility are always considered to have// symbol, it is given hidden visibility instead and the non-unique bit is set.// if a type would normally have a default-visibility RTTI emitted as a weak// The intent of this design is to remove the need for weak symbols. Specifically,// then both RTTIs are necessarily not to be considered equal.// However, if one of the RTTIs is guaranteed unique and the other one isn't,// be unique, we must perform a deep string comparison of the type names.// suffices to compare their addresses. If both the RTTIs can't be assumed to// When comparing type_infos, if both RTTIs can be assumed to be unique, it// be assumed to be unique within the program.// to be unique within the program. If the high bit is unset, then the RTTI can// ABI. If that high bit is set, that specific copy of the RTTI can't be assumed// the high bit of that pointer, which is assumed to be free for use under that// the compiler packs the pointer to the type name into a uintptr_t and reserves// the RTTI for a given type inside a program. When constructing the type_info,// This implementation of type_info does not assume always a unique copy of// This implementation is specific to ARM64 on Apple platforms.// -------------------------------------------------------------------------- ////               (_LIBCPP_TYPEINFO_COMPARISON_IMPLEMENTATION = 3)//                          NonUniqueARMRTTIBit// comparison is equal.// type_infos are equal if their addresses are equal or if a deep string// (For example: -Bsymbolic or llvm.org/PR37398). Under this assumption, two// the linker may have failed to merge every copy of a types RTTI// copy of the RTTI for a given type inside a program. For various reasons// This implementation of type_info does not assume there is always a unique//               (_LIBCPP_TYPEINFO_COMPARISON_IMPLEMENTATION = 2)//                             NonUnique// a deep string comparison.// to implement equality-comparison of type_infos instead of having to perform// Under this assumption, we can always compare the addresses of the type names// Itanium ABI (http://itanium-cxx-abi.github.io/cxx-abi/abi.html#vtable-components).// given type inside a program. This is a valid assumption when abiding to the// This implementation of type_info assumes a unique copy of the RTTI for a// ------------------------------------------------------------------------- ////               (_LIBCPP_TYPEINFO_COMPARISON_IMPLEMENTATION = 1)//                               Unique// ========================================================================== ////                           Implementations// !defined(_LIBCPP_ABI_MICROSOFT)/*

    typeinfo synopsis

namespace std {

class type_info
{
public:
    virtual ~type_info();

    bool operator==(const type_info& rhs) const noexcept;
    bool operator!=(const type_info& rhs) const noexcept;

    bool before(const type_info& rhs) const noexcept;
    size_t hash_code() const noexcept;
    const char* name() const noexcept;

    type_info(const type_info& rhs) = delete;
    type_info& operator=(const type_info& rhs) = delete;
};

class bad_cast
    : public exception
{
public:
    bad_cast() noexcept;
    bad_cast(const bad_cast&) noexcept;
    bad_cast& operator=(const bad_cast&) noexcept;
    virtual const char* what() const noexcept;
};

class bad_typeid
    : public exception
{
public:
    bad_typeid() noexcept;
    bad_typeid(const bad_typeid&) noexcept;
    bad_typeid& operator=(const bad_typeid&) noexcept;
    virtual const char* what() const noexcept;
};

}  // std

*///===-------------------------- typeinfo ----------------------------------===//<__utility/swap.h><__utility/pair.h><__tuple><__functional/unary_function.h>_HashTstruct <unnamed>struct <unnamed> &const struct <unnamed>const struct <unnamed> &union <unnamed> &const union <unnamed>const union <unnamed> &__hash_combineconst _PairTconst __scalar_hash<_PairT, 2UL>__loadwordhashhash<long double> &const hash<long double>const hash<long double> &const hash<long double> *hash<long double> *0.0Lhash<double> &const hash<double>const hash<double> &const hash<double> *hash<double> *const __scalar_hash<double, 1UL>const __scalar_hash<double, 1UL> *__scalar_hash<double, 1UL> *hash<float> &const hash<float>const hash<float> &const hash<float> *hash<float> *const __scalar_hash<float, 0UL>const __scalar_hash<float, 0UL> *__scalar_hash<float, 0UL> *hash<__uint128_t> &const hash<__uint128_t>const hash<__uint128_t> &hash<__int128_t> &const hash<__int128_t>const hash<__int128_t> &hash<unsigned long long> &const hash<unsigned long long>const hash<unsigned long long> &hash<long long> &const hash<long long>const hash<long long> &hash<unsigned long> &const hash<unsigned long>const hash<unsigned long> &const hash<unsigned long> *hash<unsigned long> *hash<long> &const hash<long>const hash<long> &const hash<long> *hash<long> *hash<unsigned int> &const hash<unsigned int>const hash<unsigned int> &const hash<unsigned int> *hash<unsigned int> *hash<int> &const hash<int>const hash<int> &const hash<int> *hash<int> *hash<unsigned short> &const hash<unsigned short>const hash<unsigned short> &const hash<unsigned short> *hash<unsigned short> *hash<short> &const hash<short>const hash<short> &const hash<short> *hash<short> *hash<wchar_t> &const hash<wchar_t>const hash<wchar_t> &const hash<wchar_t> *hash<wchar_t> *hash<char32_t> &const hash<char32_t>const hash<char32_t> &const hash<char32_t> *hash<char32_t> *hash<char16_t> &const hash<char16_t>const hash<char16_t> &const hash<char16_t> *hash<char16_t> *hash<unsigned char> &const hash<unsigned char>const hash<unsigned char> &const hash<unsigned char> *hash<unsigned char> *hash<signed char> &const hash<signed char>const hash<signed char> &const hash<signed char> *hash<signed char> *hash<char> &const hash<char>const hash<char> &const hash<char> *hash<char> *hash<bool> &const hash<bool>const hash<bool> &const hash<bool> *hash<bool> *_PairT &const _PairT &const __scalar_hash<_Tp, 2UL>const __scalar_hash<_Tp, 2UL> *__scalar_hash<_Tp, 2UL> *const __scalar_hash<_Tp, 1UL>const __scalar_hash<_Tp, 1UL> *__scalar_hash<_Tp, 1UL> *const __scalar_hash<_Tp, 0UL>const __scalar_hash<_Tp, 0UL> *__scalar_hash<_Tp, 0UL> *__hash_len_33_to_64const _Size__vf__vs__wf__ws__weak_hash_len_32_with_seeds__hash_len_17_to_32__hash_len_0_to_16/Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX.sdk/usr/include/c++/v1/__functional__hash_len_16__mul113760685077881275930x9ddfea08eb382d69ULL__shift_mix__rotate_by_at_least_1__rotate__murmur2_or_cityhash<_Size, 64UL> *hash<long double>hash<double>hash<float>hash<__uint128_t>hash<__int128_t>hash<unsigned long long>hash<long long>hash<unsigned long>hash<long>hash<unsigned int>hash<int>hash<unsigned short>hash<short>hash<wchar_t>hash<char32_t>hash<char16_t>hash<unsigned char>hash<signed char>hash<char>hash<bool>hash<_Tp *>_PairT__scalar_hash<_Tp, 4UL>__scalar_hash<_Tp, 3UL>__scalar_hash<_Tp, 2UL>__scalar_hash<_Tp, 1UL>__scalar_hash<_Tp, 0UL>__scalar_hash<_Tp, <unnamed>>__murmur2_or_cityhash<_Size, 64UL>__murmur2_or_cityhash<_Size, 32UL>__murmur2_or_cityhash<_Size, <unnamed>>__k3__k2__k1__k0_LIBCPP___FUNCTIONAL_HASH_Hdefined(__i386__) || (defined(__x86_64__) && defined(__ILP32__))// _LIBCPP___FUNCTIONAL_HASH_H// Zero out padding bits// -0.0 and 0.0 should return same hash// !_LIBCPP_HAS_NO_CHAR8_T// Decrease len to the nearest multiple of 64, and operate on 64-byte chunks.// loop we keep 56 bytes of state: v, w, x, y, and z.// For strings over 64 bytes we hash the end first, and then as we// cityhash64// Return an 8-byte hash for 33 to 64 bytes.// Return a 16-byte hash for s[0] ... s[31], a, and b.  Quick and dirty.// Callers do best to use "random-looking" values for a and b.// Return a 16-byte hash for 48 bytes.  Quick and dirty.// Some primes between 2^63 and 2^64.// murmur2// multiplication, which can be very slow on 32-bit systems.// is 64 bits.  This is because cityhash64 uses 64bit x 64bit// We use murmur2 when size_t is 32 bits, and cityhash64 when size_t__shift__key<__iterator/iterator.h>__pad_and_output_Chconst _Chconst _Ch *_Ch *_Trconst ostreambuf_iterator<_CharT, _Traits>const ostreambuf_iterator<_CharT, _Traits> *ostreambuf_iterator<_CharT, _Traits> *streambuf_type *ostreambuf_iterator<_CharT, _Traits> &ostreambuf_iteratorostream_type &ostream_typestreambuf_type__sbuf__LIBCPP___ITERATOR_OSTREAMBUF_ITERATOR_H_LIBCPP_STD_VER <= 14 || !defined(_LIBCPP_ABI_NO_ITERATOR_BASES)// _LIBCPP___ITERATOR_OSTREAMBUF_ITERATOR_H// for forward declaration of basic_streambuf__ob__oe__iob__fl__compressed_pair<_T1, _T2> &_Base2 *__compressed_pair_elem<_T2, 1, <expression>> *__get_second_base__compressed_pair<_T1, _T2> *_Base1 *__compressed_pair_elem<_T1, 0, <expression>> *__get_first_baseconst __compressed_pair<_T1, _T2>const __compressed_pair<_T1, _T2> *const _Base2const _Base1const __compressed_pair_elem<_Tp, _Idx, true>const __compressed_pair_elem<_Tp, _Idx, true> *__compressed_pair_elem<_Tp, _Idx, true> *const __compressed_pair_elem<_Tp, _Idx, _CanBeEmptyBase>const __compressed_pair_elem<_Tp, _Idx, _CanBeEmptyBase> *__compressed_pair_elem<_Tp, _Idx, _CanBeEmptyBase> *__value_init_tag &const __value_init_tagconst __value_init_tag &const __default_init_tagconst __default_init_tag &__compressed_pair<_T1, _T2>__compressed_pair_elem<_Tp, _Idx, true>_Idx__compressed_pair_elem<_Tp, _Idx, _CanBeEmptyBase>_CanBeEmptyBase__value_init_tag__default_init_tag(!is_same<_T1, _T2>::value), "__compressed_pair cannot be instantiated when T1 and T2 are the same type; " "The current implementation is NOT ABI-compatible with the previous " "implementation for this configuration"__compressed_pair cannot be instantiated when T1 and T2 are the same type; The current implementation is NOT ABI-compatible with the previous implementation for this configuration_LIBCPP___MEMORY_COMPRESSED_PAIR_H__is_nothrow_swappable<_T1>::value && __is_nothrow_swappable<_T2>::value// _LIBCPP___MEMORY_COMPRESSED_PAIR_H//  object and the allocator have the same type).// (The exception is std::function where it is possible that the function// is *almost never* used in a scenario where it's possible for T1 == T2.// NOTE: This static assert should never fire because __compressed_pair// Tag used to default initialize one or both of the pair's elements.// needed in c++03 for some constructors__pair_LIBCPP___ALGORITHM_FIND_H// _LIBCPP___ALGORITHM_FIND_H/Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX.sdk/usr/include/c++/v1/__algorithmconst ptrdiff_t__len2__len1__f2<__string><__ranges/enable_view.h><__ranges/enable_borrowed_range.h>const basic_string_view<_CharT, char_traits<_CharT>>basic_string_view<_CharT, _Traits> &remove_suffixremove_prefixbasic_string_viewconst basic_string_view<_CharT, _Traits>const basic_string_view<_CharT, _Traits> &hash<basic_string_view<_CharT, char_traits<_CharT>>>wstring_viewu32string_viewu16string_viewstring_viewbasic_string_view<_CharT, _Traits>const _CharT &( is_trivial<value_type>::value), "Character type of basic_string_view must be trivial"Character type of basic_string_view must be trivial( is_standard_layout<value_type>::value), "Character type of basic_string_view must be standard-layout"Character type of basic_string_view must be standard-layout(!is_array<value_type>::value), "Character type of basic_string_view must not be an array"Character type of basic_string_view must not be an array_LIBCPP_STRING_VIEW_LIBCPP_STD_VER > 17 && !defined(_LIBCPP_HAS_NO_RANGES)"string_view::find(): received nullptr"__s.size() == 0 || __s.data() != nullptr__s.size() == 0 || __s.data() != std::__1::__get_nullptr_t()__n <= size()"remove_suffix() can't remove more than size()""string_view::find_last_not_of(): received nullptr""string_view::find_first_not_of(): received nullptr""string_view::find_last_of(): received nullptr""string_view::find_first_of(): received nullptr""string_view::rfind(): received nullptr"_LIBCPP_PREFERRED_NAME(wstring_view)"remove_prefix() can't remove more than size()""string_view::back(): string is empty""string_view::front(): string is empty"__pos < size()"string_view[] index out of bounds"// _LIBCPP_STRING_VIEW// [string.view.hash]// operator >=// operator <=// operator >// operator <// operator !=// operator ==// [string.view.comparison]// _LIBCPP_STD_VER > 17 && !defined(_LIBCPP_HAS_NO_RANGES)// first __rlen chars matched// [string.view.modifiers], modifiers:// [string.view.access], element access// [string.view.capacity], capacity// [string.view.iterators], iterators// [string.view.cons], construct/copy// size_type(-1);// See [string.view.iterators]// types/*
string_view synopsis

namespace std {

    // 7.2, Class template basic_string_view
    template<class charT, class traits = char_traits<charT>>
        class basic_string_view;

    template<class charT, class traits>
    inline constexpr bool ranges::enable_view<basic_string_view<charT, traits>> = true;

    template<class charT, class traits>
    inline constexpr bool ranges::enable_borrowed_range<basic_string_view<charT, traits>> = true;  // C++20

    // 7.9, basic_string_view non-member comparison functions
    template<class charT, class traits>
    constexpr bool operator==(basic_string_view<charT, traits> x,
                              basic_string_view<charT, traits> y) noexcept;
    template<class charT, class traits>
    constexpr bool operator!=(basic_string_view<charT, traits> x,
                              basic_string_view<charT, traits> y) noexcept;
    template<class charT, class traits>
    constexpr bool operator< (basic_string_view<charT, traits> x,
                                 basic_string_view<charT, traits> y) noexcept;
    template<class charT, class traits>
    constexpr bool operator> (basic_string_view<charT, traits> x,
                              basic_string_view<charT, traits> y) noexcept;
    template<class charT, class traits>
    constexpr bool operator<=(basic_string_view<charT, traits> x,
                                 basic_string_view<charT, traits> y) noexcept;
    template<class charT, class traits>
    constexpr bool operator>=(basic_string_view<charT, traits> x,
                              basic_string_view<charT, traits> y) noexcept;
    // see below, sufficient additional overloads of comparison functions

    // 7.10, Inserters and extractors
    template<class charT, class traits>
      basic_ostream<charT, traits>&
        operator<<(basic_ostream<charT, traits>& os,
                   basic_string_view<charT, traits> str);

    // basic_string_view typedef names
    typedef basic_string_view<char> string_view;
    typedef basic_string_view<char8_t> u8string_view; // C++20
    typedef basic_string_view<char16_t> u16string_view;
    typedef basic_string_view<char32_t> u32string_view;
    typedef basic_string_view<wchar_t> wstring_view;

    template<class charT, class traits = char_traits<charT>>
    class basic_string_view {
      public:
      // types
      typedef traits traits_type;
      typedef charT value_type;
      typedef charT* pointer;
      typedef const charT* const_pointer;
      typedef charT& reference;
      typedef const charT& const_reference;
      typedef implementation-defined const_iterator;
      typedef const_iterator iterator;
      typedef reverse_iterator<const_iterator> const_reverse_iterator;
      typedef const_reverse_iterator reverse_iterator;
      typedef size_t size_type;
      typedef ptrdiff_t difference_type;
      static constexpr size_type npos = size_type(-1);

      // 7.3, basic_string_view constructors and assignment operators
      constexpr basic_string_view() noexcept;
      constexpr basic_string_view(const basic_string_view&) noexcept = default;
      basic_string_view& operator=(const basic_string_view&) noexcept = default;
      template<class Allocator>
      constexpr basic_string_view(const charT* str);
      basic_string_view(nullptr_t) = delete; // C++2b
      constexpr basic_string_view(const charT* str, size_type len);

      // 7.4, basic_string_view iterator support
      constexpr const_iterator begin() const noexcept;
      constexpr const_iterator end() const noexcept;
      constexpr const_iterator cbegin() const noexcept;
      constexpr const_iterator cend() const noexcept;
      const_reverse_iterator rbegin() const noexcept;
      const_reverse_iterator rend() const noexcept;
      const_reverse_iterator crbegin() const noexcept;
      const_reverse_iterator crend() const noexcept;

      // 7.5, basic_string_view capacity
      constexpr size_type size() const noexcept;
      constexpr size_type length() const noexcept;
      constexpr size_type max_size() const noexcept;
      constexpr bool empty() const noexcept;

      // 7.6, basic_string_view element access
      constexpr const_reference operator[](size_type pos) const;
      constexpr const_reference at(size_type pos) const;
      constexpr const_reference front() const;
      constexpr const_reference back() const;
      constexpr const_pointer data() const noexcept;

      // 7.7, basic_string_view modifiers
      constexpr void remove_prefix(size_type n);
      constexpr void remove_suffix(size_type n);
      constexpr void swap(basic_string_view& s) noexcept;

      size_type copy(charT* s, size_type n, size_type pos = 0) const;  // constexpr in C++20

      constexpr basic_string_view substr(size_type pos = 0, size_type n = npos) const;
      constexpr int compare(basic_string_view s) const noexcept;
      constexpr int compare(size_type pos1, size_type n1, basic_string_view s) const;
      constexpr int compare(size_type pos1, size_type n1,
                            basic_string_view s, size_type pos2, size_type n2) const;
      constexpr int compare(const charT* s) const;
      constexpr int compare(size_type pos1, size_type n1, const charT* s) const;
      constexpr int compare(size_type pos1, size_type n1,
                            const charT* s, size_type n2) const;
      constexpr size_type find(basic_string_view s, size_type pos = 0) const noexcept;
      constexpr size_type find(charT c, size_type pos = 0) const noexcept;
      constexpr size_type find(const charT* s, size_type pos, size_type n) const noexcept; // noexcept as an extension
      constexpr size_type find(const charT* s, size_type pos = 0) const noexcept; // noexcept as an extension
      constexpr size_type rfind(basic_string_view s, size_type pos = npos) const noexcept;
      constexpr size_type rfind(charT c, size_type pos = npos) const noexcept;
      constexpr size_type rfind(const charT* s, size_type pos, size_type n) const noexcept; // noexcept as an extension
      constexpr size_type rfind(const charT* s, size_type pos = npos) const noexcept; // noexcept as an extension
      constexpr size_type find_first_of(basic_string_view s, size_type pos = 0) const noexcept;
      constexpr size_type find_first_of(charT c, size_type pos = 0) const noexcept;
      constexpr size_type find_first_of(const charT* s, size_type pos, size_type n) const noexcept; // noexcept as an extension
      constexpr size_type find_first_of(const charT* s, size_type pos = 0) const noexcept; // noexcept as an extension
      constexpr size_type find_last_of(basic_string_view s, size_type pos = npos) const noexcept;
      constexpr size_type find_last_of(charT c, size_type pos = npos) const noexcept;
      constexpr size_type find_last_of(const charT* s, size_type pos, size_type n) const noexcept; // noexcept as an extension
      constexpr size_type find_last_of(const charT* s, size_type pos = npos) const noexcept; // noexcept as an extension
      constexpr size_type find_first_not_of(basic_string_view s, size_type pos = 0) const noexcept;
      constexpr size_type find_first_not_of(charT c, size_type pos = 0) const noexcept;
      constexpr size_type find_first_not_of(const charT* s, size_type pos, size_type n) const noexcept; // noexcept as an extension
      constexpr size_type find_first_not_of(const charT* s, size_type pos = 0) const noexcept; // noexcept as an extension
      constexpr size_type find_last_not_of(basic_string_view s, size_type pos = npos) const noexcept;
      constexpr size_type find_last_not_of(charT c, size_type pos = npos) const noexcept;
      constexpr size_type find_last_not_of(const charT* s, size_type pos, size_type n) const noexcept; // noexcept as an extension
      constexpr size_type find_last_not_of(const charT* s, size_type pos = npos) const noexcept; // noexcept as an extension

      constexpr bool starts_with(basic_string_view s) const noexcept; // C++20
      constexpr bool starts_with(charT c) const noexcept;             // C++20
      constexpr bool starts_with(const charT* s) const;               // C++20
      constexpr bool ends_with(basic_string_view s) const noexcept;   // C++20
      constexpr bool ends_with(charT c) const noexcept;               // C++20
      constexpr bool ends_with(const charT* s) const;                 // C++20

      constexpr bool contains(basic_string_view s) const noexcept; // C++2b
      constexpr bool contains(charT c) const noexcept;             // C++2b
      constexpr bool contains(const charT* s) const;               // C++2b

     private:
      const_pointer data_;  // exposition only
      size_type     size_;  // exposition only
    };

  // 7.11, Hash support
  template <class T> struct hash;
  template <> struct hash<string_view>;
  template <> struct hash<u8string_view>; // C++20
  template <> struct hash<u16string_view>;
  template <> struct hash<u32string_view>;
  template <> struct hash<wstring_view>;

  constexpr basic_string_view<char>     operator "" sv( const char *str,     size_t len ) noexcept;
  constexpr basic_string_view<wchar_t>  operator "" sv( const wchar_t *str,  size_t len ) noexcept;
  constexpr basic_string_view<char8_t>  operator "" sv( const char8_t *str,  size_t len ) noexcept; // C++20
  constexpr basic_string_view<char16_t> operator "" sv( const char16_t *str, size_t len ) noexcept;
  constexpr basic_string_view<char32_t> operator "" sv( const char32_t *str, size_t len ) noexcept;

}  // namespace std


*///===------------------------ string_view ---------------------------------===//__otheroperator^operator|anyalltestto_ullongto_ulongoperator>>=operator<<=operator^=operator|=operator&=bitsetconst __bitset<1UL, _Size>const __bitset<1UL, _Size> &__bitset<1UL, _Size> &__bitsetconst __bitset<_N_words, _Size>const __bitset<_N_words, _Size> &__bitset<_N_words, _Size> &__bitset<0UL, 0UL> &const __bitset<0UL, 0UL>const __bitset<0UL, 0UL> &const __bitset<0UL, 0UL> *__bitset<0UL, 0UL> *const unsigned long *hash<bitset<_Size>>bitset<_Size>__bitset<1UL, _Size>const __storage_typeconst __storage_type *__storage_type *__has_storage_type<__bitset<_N_words, _Size>>__bitset<_N_words, _Size>_N_words__bitset<0UL, 0UL>__storage_type[]unsigned long[]sizeof(__storage_type)static_cast<unsigned>(sizeof(__storage_type) * CHAR_BIT)_LIBCPP_BITSET__SIZEOF_SIZE_T__ == 8__SIZEOF_SIZE_T__ == 4// _LIBCPP_BITSET// 23.3.5.2 bitset operations:// 23.3.5.1 constructors:/*
    bitset synopsis

namespace std
{

namespace std {

template <size_t N>
class bitset
{
public:
    // bit reference:
    class reference
    {
        friend class bitset;
        reference() noexcept;
    public:
        ~reference() noexcept;
        reference& operator=(bool x) noexcept;           // for b[i] = x;
        reference& operator=(const reference&) noexcept; // for b[i] = b[j];
        bool operator~() const noexcept;                 // flips the bit
        operator bool() const noexcept;                  // for x = b[i];
        reference& flip() noexcept;                      // for b[i].flip();
    };

    // 23.3.5.1 constructors:
    constexpr bitset() noexcept;
    constexpr bitset(unsigned long long val) noexcept;
    template <class charT>
        explicit bitset(const charT* str,
                        typename basic_string<charT>::size_type n = basic_string<charT>::npos,
                        charT zero = charT('0'), charT one = charT('1'));
    template<class charT, class traits, class Allocator>
        explicit bitset(const basic_string<charT,traits,Allocator>& str,
                        typename basic_string<charT,traits,Allocator>::size_type pos = 0,
                        typename basic_string<charT,traits,Allocator>::size_type n =
                                 basic_string<charT,traits,Allocator>::npos,
                        charT zero = charT('0'), charT one = charT('1'));

    // 23.3.5.2 bitset operations:
    bitset& operator&=(const bitset& rhs) noexcept;
    bitset& operator|=(const bitset& rhs) noexcept;
    bitset& operator^=(const bitset& rhs) noexcept;
    bitset& operator<<=(size_t pos) noexcept;
    bitset& operator>>=(size_t pos) noexcept;
    bitset& set() noexcept;
    bitset& set(size_t pos, bool val = true);
    bitset& reset() noexcept;
    bitset& reset(size_t pos);
    bitset operator~() const noexcept;
    bitset& flip() noexcept;
    bitset& flip(size_t pos);

    // element access:
    constexpr bool operator[](size_t pos) const; // for b[i];
    reference operator[](size_t pos);            // for b[i];
    unsigned long to_ulong() const;
    unsigned long long to_ullong() const;
    template <class charT, class traits, class Allocator>
        basic_string<charT, traits, Allocator> to_string(charT zero = charT('0'), charT one = charT('1')) const;
    template <class charT, class traits>
        basic_string<charT, traits, allocator<charT> > to_string(charT zero = charT('0'), charT one = charT('1')) const;
    template <class charT>
        basic_string<charT, char_traits<charT>, allocator<charT> > to_string(charT zero = charT('0'), charT one = charT('1')) const;
    basic_string<char, char_traits<char>, allocator<char> > to_string(char zero = '0', char one = '1') const;
    size_t count() const noexcept;
    constexpr size_t size() const noexcept;
    bool operator==(const bitset& rhs) const noexcept;
    bool operator!=(const bitset& rhs) const noexcept;
    bool test(size_t pos) const;
    bool all() const noexcept;
    bool any() const noexcept;
    bool none() const noexcept;
    bitset operator<<(size_t pos) const noexcept;
    bitset operator>>(size_t pos) const noexcept;
};

// 23.3.5.3 bitset operators:
template <size_t N>
bitset<N> operator&(const bitset<N>&, const bitset<N>&) noexcept;

template <size_t N>
bitset<N> operator|(const bitset<N>&, const bitset<N>&) noexcept;

template <size_t N>
bitset<N> operator^(const bitset<N>&, const bitset<N>&) noexcept;

template <class charT, class traits, size_t N>
basic_istream<charT, traits>&
operator>>(basic_istream<charT, traits>& is, bitset<N>& x);

template <class charT, class traits, size_t N>
basic_ostream<charT, traits>&
operator<<(basic_ostream<charT, traits>& os, const bitset<N>& x);

template <size_t N> struct hash<std::bitset<N>>;

}  // std

*///===---------------------------- bitset ----------------------------------===//__bs__one<errno.h>_LIBCPP_CERRNO// _LIBCPP_CERRNO/*
    cerrno synopsis

Macros:

    EDOM
    EILSEQ  // C99
    ERANGE
    errno

*///===-------------------------- cerrno ------------------------------------===//<cerrno>errc &const errcconst errc &errcconst errc *errc *address_family_not_supportedEAFNOSUPPORTaddress_in_useEADDRINUSEaddress_not_availableEADDRNOTAVAILalready_connectedEISCONNargument_list_too_longE2BIGargument_out_of_domainEDOMbad_addressEFAULTbad_file_descriptorEBADFbad_messageEBADMSGbroken_pipeEPIPEconnection_abortedECONNABORTEDconnection_already_in_progressEALREADYconnection_refusedECONNREFUSEDconnection_resetECONNRESETcross_device_linkEXDEVdestination_address_requiredEDESTADDRREQdevice_or_resource_busyEBUSYdirectory_not_emptyENOTEMPTYexecutable_format_errorENOEXECfile_existsEEXISTfile_too_largeEFBIGfilename_too_longENAMETOOLONGfunction_not_supportedENOSYShost_unreachableEHOSTUNREACHidentifier_removedEIDRMillegal_byte_sequenceEILSEQinappropriate_io_control_operationENOTTYinterruptedEINTRinvalid_argumentEINVALinvalid_seekESPIPEio_errorEIOis_a_directoryEISDIRmessage_sizeEMSGSIZEnetwork_downENETDOWNnetwork_resetENETRESETnetwork_unreachableENETUNREACHno_buffer_spaceENOBUFSno_child_processECHILDno_linkENOLINKno_lock_availableENOLCKno_message_availableENODATAno_messageENOMSGno_protocol_optionENOPROTOOPTno_space_on_deviceENOSPCno_stream_resourcesENOSRno_such_device_or_addressENXIOno_such_deviceENODEVno_such_file_or_directoryENOENTno_such_processESRCHnot_a_directoryENOTDIRnot_a_socketENOTSOCKnot_a_streamENOSTRnot_connectedENOTCONNnot_enough_memoryENOMEMnot_supportedENOTSUPoperation_canceledECANCELEDoperation_in_progressEINPROGRESSoperation_not_permittedEPERMoperation_not_supportedEOPNOTSUPPoperation_would_blockowner_deadEOWNERDEADpermission_deniedEACCESprotocol_errorEPROTOprotocol_not_supportedEPROTONOSUPPORTread_only_file_systemEROFSresource_deadlock_would_occurEDEADLKresource_unavailable_try_againEAGAINresult_out_of_rangeERANGEstate_not_recoverableENOTRECOVERABLEstream_timeoutETIMEtext_file_busyETXTBSYtimed_outETIMEDOUTtoo_many_files_open_in_systemENFILEtoo_many_files_openEMFILEtoo_many_linksEMLINKtoo_many_symbolic_link_levelsELOOPvalue_too_largeEOVERFLOWwrong_protocol_typeEPROTOTYPE_LIBCPP___ERRC// _LIBCPP___ERRC//enum class errc// for them:// Some error codes are not present on all platforms, so we provide equivalents/*
    system_error synopsis

namespace std
{

enum class errc
{
    address_family_not_supported,       // EAFNOSUPPORT
    address_in_use,                     // EADDRINUSE
    address_not_available,              // EADDRNOTAVAIL
    already_connected,                  // EISCONN
    argument_list_too_long,             // E2BIG
    argument_out_of_domain,             // EDOM
    bad_address,                        // EFAULT
    bad_file_descriptor,                // EBADF
    bad_message,                        // EBADMSG
    broken_pipe,                        // EPIPE
    connection_aborted,                 // ECONNABORTED
    connection_already_in_progress,     // EALREADY
    connection_refused,                 // ECONNREFUSED
    connection_reset,                   // ECONNRESET
    cross_device_link,                  // EXDEV
    destination_address_required,       // EDESTADDRREQ
    device_or_resource_busy,            // EBUSY
    directory_not_empty,                // ENOTEMPTY
    executable_format_error,            // ENOEXEC
    file_exists,                        // EEXIST
    file_too_large,                     // EFBIG
    filename_too_long,                  // ENAMETOOLONG
    function_not_supported,             // ENOSYS
    host_unreachable,                   // EHOSTUNREACH
    identifier_removed,                 // EIDRM
    illegal_byte_sequence,              // EILSEQ
    inappropriate_io_control_operation, // ENOTTY
    interrupted,                        // EINTR
    invalid_argument,                   // EINVAL
    invalid_seek,                       // ESPIPE
    io_error,                           // EIO
    is_a_directory,                     // EISDIR
    message_size,                       // EMSGSIZE
    network_down,                       // ENETDOWN
    network_reset,                      // ENETRESET
    network_unreachable,                // ENETUNREACH
    no_buffer_space,                    // ENOBUFS
    no_child_process,                   // ECHILD
    no_link,                            // ENOLINK
    no_lock_available,                  // ENOLCK
    no_message_available,               // ENODATA
    no_message,                         // ENOMSG
    no_protocol_option,                 // ENOPROTOOPT
    no_space_on_device,                 // ENOSPC
    no_stream_resources,                // ENOSR
    no_such_device_or_address,          // ENXIO
    no_such_device,                     // ENODEV
    no_such_file_or_directory,          // ENOENT
    no_such_process,                    // ESRCH
    not_a_directory,                    // ENOTDIR
    not_a_socket,                       // ENOTSOCK
    not_a_stream,                       // ENOSTR
    not_connected,                      // ENOTCONN
    not_enough_memory,                  // ENOMEM
    not_supported,                      // ENOTSUP
    operation_canceled,                 // ECANCELED
    operation_in_progress,              // EINPROGRESS
    operation_not_permitted,            // EPERM
    operation_not_supported,            // EOPNOTSUPP
    operation_would_block,              // EWOULDBLOCK
    owner_dead,                         // EOWNERDEAD
    permission_denied,                  // EACCES
    protocol_error,                     // EPROTO
    protocol_not_supported,             // EPROTONOSUPPORT
    read_only_file_system,              // EROFS
    resource_deadlock_would_occur,      // EDEADLK
    resource_unavailable_try_again,     // EAGAIN
    result_out_of_range,                // ERANGE
    state_not_recoverable,              // ENOTRECOVERABLE
    stream_timeout,                     // ETIME
    text_file_busy,                     // ETXTBSY
    timed_out,                          // ETIMEDOUT
    too_many_files_open_in_system,      // ENFILE
    too_many_files_open,                // EMFILE
    too_many_links,                     // EMLINK
    too_many_symbolic_link_levels,      // ELOOP
    value_too_large,                    // EOVERFLOW
    wrong_protocol_type                 // EPROTOTYPE
};

*///===---------------------------- __errc ----------------------------------===//<__errc>system_error &const system_errorconst system_error &const system_error *system_error *~system_errorsystem_errorerror_codeerror_code *const error_category *error_category *const error_code *default_error_conditioncategory__val_(0)equivalentconst error_conditionconst error_condition &error_condition &error_conditionerror_condition *const error_condition *__throw_system_errorsystem_categorygeneric_categoryhash<error_condition> &const hash<error_condition>const hash<error_condition> &const hash<error_condition> *hash<error_condition> *hash<error_code> &const hash<error_code>const hash<error_code> &const hash<error_code> *hash<error_code> *__do_message &const __do_messageconst __do_message &~__do_message__do_messageis_error_condition_enumis_error_condition_enum<__lx> &const is_error_condition_enum<__lx>const is_error_condition_enum<__lx> &is_error_condition_enum<errc> &const is_error_condition_enum<errc>const is_error_condition_enum<errc> &error_category~error_categoryhash<error_condition>hash<error_code>is_error_condition_enum<__lx>is_error_condition_enum<errc>is_error_condition_enum<_Tp>is_error_code_enum<_Tp>__ec___cat___val__LIBCPP_SYSTEM_ERROR// _LIBCPP_SYSTEM_ERROR// system_error// error_code// class error_category// is_error_condition_enum// is_error_code_enum/*
    system_error synopsis

namespace std
{

class error_category
{
public:
    virtual ~error_category() noexcept;

    constexpr error_category();
    error_category(const error_category&) = delete;
    error_category& operator=(const error_category&) = delete;

    virtual const char* name() const noexcept = 0;
    virtual error_condition default_error_condition(int ev) const noexcept;
    virtual bool equivalent(int code, const error_condition& condition) const noexcept;
    virtual bool equivalent(const error_code& code, int condition) const noexcept;
    virtual string message(int ev) const = 0;

    bool operator==(const error_category& rhs) const noexcept;
    bool operator!=(const error_category& rhs) const noexcept;
    bool operator<(const error_category& rhs) const noexcept;
};

const error_category& generic_category() noexcept;
const error_category& system_category() noexcept;

template <class T> struct is_error_code_enum
    : public false_type {};

template <class T> struct is_error_condition_enum
    : public false_type {};

template <class _Tp>
inline constexpr size_t is_error_condition_enum_v = is_error_condition_enum<_Tp>::value; // C++17

template <class _Tp>
inline constexpr size_t is_error_code_enum_v = is_error_code_enum<_Tp>::value; // C++17

class error_code
{
public:
    // constructors:
    error_code() noexcept;
    error_code(int val, const error_category& cat) noexcept;
    template <class ErrorCodeEnum>
        error_code(ErrorCodeEnum e) noexcept;

    // modifiers:
    void assign(int val, const error_category& cat) noexcept;
    template <class ErrorCodeEnum>
        error_code& operator=(ErrorCodeEnum e) noexcept;
    void clear() noexcept;

    // observers:
    int value() const noexcept;
    const error_category& category() const noexcept;
    error_condition default_error_condition() const noexcept;
    string message() const;
    explicit operator bool() const noexcept;
};

// non-member functions:
bool operator<(const error_code& lhs, const error_code& rhs) noexcept;
template <class charT, class traits>
    basic_ostream<charT,traits>&
    operator<<(basic_ostream<charT,traits>& os, const error_code& ec);

class error_condition
{
public:
    // constructors:
    error_condition() noexcept;
    error_condition(int val, const error_category& cat) noexcept;
    template <class ErrorConditionEnum>
        error_condition(ErrorConditionEnum e) noexcept;

    // modifiers:
    void assign(int val, const error_category& cat) noexcept;
    template <class ErrorConditionEnum>
        error_condition& operator=(ErrorConditionEnum e) noexcept;
    void clear() noexcept;

    // observers:
    int value() const noexcept;
    const error_category& category() const noexcept;
    string message() const noexcept;
    explicit operator bool() const noexcept;
};

bool operator<(const error_condition& lhs, const error_condition& rhs) noexcept;

class system_error
    : public runtime_error
{
public:
    system_error(error_code ec, const string& what_arg);
    system_error(error_code ec, const char* what_arg);
    system_error(error_code ec);
    system_error(int ev, const error_category& ecat, const string& what_arg);
    system_error(int ev, const error_category& ecat, const char* what_arg);
    system_error(int ev, const error_category& ecat);

    const error_code& code() const noexcept;
    const char* what() const noexcept;
};

template <> struct is_error_condition_enum<errc>
    : true_type { }

error_code make_error_code(errc e) noexcept;
error_condition make_error_condition(errc e) noexcept;

// Comparison operators:
bool operator==(const error_code& lhs, const error_code& rhs) noexcept;
bool operator==(const error_code& lhs, const error_condition& rhs) noexcept;
bool operator==(const error_condition& lhs, const error_code& rhs) noexcept;
bool operator==(const error_condition& lhs, const error_condition& rhs) noexcept;
bool operator!=(const error_code& lhs, const error_code& rhs) noexcept;
bool operator!=(const error_code& lhs, const error_condition& rhs) noexcept;
bool operator!=(const error_condition& lhs, const error_code& rhs) noexcept;
bool operator!=(const error_condition& lhs, const error_condition& rhs) noexcept;

template <> struct hash<std::error_code>;
template <> struct hash<std::error_condition>;

}  // std

*///===---------------------------- system_error ----------------------------===//__catevwhat_arg__ev__ecat__what_arg__code__condition<__threading_support>__safe_nanosecond_cast_Rep_Periodunique_lock<_Mutex> &_Mutex__do_timed_waitunique_lock<mutex> &_Clocknative_handlecondition_variable *__libcpp_condvar_t *wait_forconst duration<_Rep, _Period>const duration<_Rep, _Period> &duration<_Rep, _Period> &_Predicatewait_untilconst time_point<_Clock, _Duration>const time_point<_Clock, _Duration> &time_point<_Clock, _Duration> &_Durationwaitnotify_allnotify_onecondition_variable &const condition_variableconst condition_variable &condition_variable~condition_variablecv_status &const cv_statusconst cv_status &cv_statusconst cv_status *cv_status *mutex_type *_Mutex *mutexowns_locktry_lock_untiltry_lock_fortry_lockunique_lock<_Mutex> &&unique_lockconst unique_lock<_Mutex>const unique_lock<_Mutex> &~unique_lockmutex_type &_Mutex &lock_guard<_Mutex> &const lock_guard<_Mutex>const lock_guard<_Mutex> &lock_guard~lock_guardadopt_lock_t &const adopt_lock_tconst adopt_lock_t &adopt_lock_ttry_to_lock_t &const try_to_lock_tconst try_to_lock_t &try_to_lock_tdefer_lock_t &const defer_lock_tconst defer_lock_t &defer_lock_tmutex *__libcpp_mutex_t *~mutexmutex &const mutexconst mutex &native_handle_typeno_timeoutunique_lock<_Mutex>mutex_typelock_guard<_Mutex>1018212795__owns___m_850045863adopt_locktry_to_lockdefer_lockis_nothrow_default_constructible<mutex>::value, "the default constructor for std::mutex must be nothrow"the default constructor for std::mutex must be nothrow_LIBCPP___MUTEX_BASE_LIBCPP_HAS_NO_THREADSdefined(_LIBCPP_HAS_TRIVIAL_MUTEX_DESTRUCTION)defined(_LIBCPP_CXX03_LANG) || defined(_LIBCPP_BUILDING_LIBRARY)_LIBCPP_HAS_TRIVIAL_CONDVAR_DESTRUCTIONdefined(_LIBCPP_HAS_COND_CLOCKWAIT)release_capability()requires_capability(__m)acquire_capability(__m)scoped_lockabletry_acquire_capability(true)acquire_capability()capability("mutex")// _LIBCPP___MUTEX_BASE// !_LIBCPP_HAS_NO_THREADS// _LIBCPP_HAS_COND_CLOCKWAIT//enum class cv_status/* _LIBCPP_INLINE_VAR */__lk<__mutex_base>__call_oncevolatile _State_typevolatile _State_type &__call_once_proxycall_onceonce_flag &const _Callableconst _Callable &_Callable &_L0_L0 &_L1_L1 &__call_once_param_Fp &recursive_timed_mutex &const recursive_timed_mutexconst recursive_timed_mutex &recursive_timed_mutex~recursive_timed_mutextimed_mutex &const timed_mutexconst timed_mutex &timed_mutex~timed_mutexrecursive_mutex *__libcpp_recursive_mutex_t *recursive_mutex &const recursive_mutexconst recursive_mutex &recursive_mutex~recursive_mutexconst once_flagconst once_flag &once_flagonce_flag *__call_once_param<_Fp>_State_type__f___id___count___locked___state__LIBCPP_MUTEX// _LIBCPP_MUTEX/*
    mutex synopsis

namespace std
{

class mutex
{
public:
     constexpr mutex() noexcept;
     ~mutex();

    mutex(const mutex&) = delete;
    mutex& operator=(const mutex&) = delete;

    void lock();
    bool try_lock();
    void unlock();

    typedef pthread_mutex_t* native_handle_type;
    native_handle_type native_handle();
};

class recursive_mutex
{
public:
     recursive_mutex();
     ~recursive_mutex();

    recursive_mutex(const recursive_mutex&) = delete;
    recursive_mutex& operator=(const recursive_mutex&) = delete;

    void lock();
    bool try_lock() noexcept;
    void unlock();

    typedef pthread_mutex_t* native_handle_type;
    native_handle_type native_handle();
};

class timed_mutex
{
public:
     timed_mutex();
     ~timed_mutex();

    timed_mutex(const timed_mutex&) = delete;
    timed_mutex& operator=(const timed_mutex&) = delete;

    void lock();
    bool try_lock();
    template <class Rep, class Period>
        bool try_lock_for(const chrono::duration<Rep, Period>& rel_time);
    template <class Clock, class Duration>
        bool try_lock_until(const chrono::time_point<Clock, Duration>& abs_time);
    void unlock();
};

class recursive_timed_mutex
{
public:
     recursive_timed_mutex();
     ~recursive_timed_mutex();

    recursive_timed_mutex(const recursive_timed_mutex&) = delete;
    recursive_timed_mutex& operator=(const recursive_timed_mutex&) = delete;

    void lock();
    bool try_lock() noexcept;
    template <class Rep, class Period>
        bool try_lock_for(const chrono::duration<Rep, Period>& rel_time);
    template <class Clock, class Duration>
        bool try_lock_until(const chrono::time_point<Clock, Duration>& abs_time);
    void unlock();
};

struct defer_lock_t { explicit defer_lock_t() = default; };
struct try_to_lock_t { explicit try_to_lock_t() = default; };
struct adopt_lock_t { explicit adopt_lock_t() = default; };

inline constexpr defer_lock_t  defer_lock{};
inline constexpr try_to_lock_t try_to_lock{};
inline constexpr adopt_lock_t  adopt_lock{};

template <class Mutex>
class lock_guard
{
public:
    typedef Mutex mutex_type;

    explicit lock_guard(mutex_type& m);
    lock_guard(mutex_type& m, adopt_lock_t);
    ~lock_guard();

    lock_guard(lock_guard const&) = delete;
    lock_guard& operator=(lock_guard const&) = delete;
};

template <class... MutexTypes>
class scoped_lock // C++17
{
public:
    using mutex_type = Mutex;  // If MutexTypes... consists of the single type Mutex

    explicit scoped_lock(MutexTypes&... m);
    scoped_lock(adopt_lock_t, MutexTypes&... m);
    ~scoped_lock();
    scoped_lock(scoped_lock const&) = delete;
    scoped_lock& operator=(scoped_lock const&) = delete;
private:
    tuple<MutexTypes&...> pm; // exposition only
};

template <class Mutex>
class unique_lock
{
public:
    typedef Mutex mutex_type;
    unique_lock() noexcept;
    explicit unique_lock(mutex_type& m);
    unique_lock(mutex_type& m, defer_lock_t) noexcept;
    unique_lock(mutex_type& m, try_to_lock_t);
    unique_lock(mutex_type& m, adopt_lock_t);
    template <class Clock, class Duration>
        unique_lock(mutex_type& m, const chrono::time_point<Clock, Duration>& abs_time);
    template <class Rep, class Period>
        unique_lock(mutex_type& m, const chrono::duration<Rep, Period>& rel_time);
    ~unique_lock();

    unique_lock(unique_lock const&) = delete;
    unique_lock& operator=(unique_lock const&) = delete;

    unique_lock(unique_lock&& u) noexcept;
    unique_lock& operator=(unique_lock&& u) noexcept;

    void lock();
    bool try_lock();

    template <class Rep, class Period>
        bool try_lock_for(const chrono::duration<Rep, Period>& rel_time);
    template <class Clock, class Duration>
        bool try_lock_until(const chrono::time_point<Clock, Duration>& abs_time);

    void unlock();

    void swap(unique_lock& u) noexcept;
    mutex_type* release() noexcept;

    bool owns_lock() const noexcept;
    explicit operator bool () const noexcept;
    mutex_type* mutex() const noexcept;
};

template <class Mutex>
  void swap(unique_lock<Mutex>& x, unique_lock<Mutex>& y) noexcept;

template <class L1, class L2, class... L3>
  int try_lock(L1&, L2&, L3&...);
template <class L1, class L2, class... L3>
  void lock(L1&, L2&, L3&...);

struct once_flag
{
    constexpr once_flag() noexcept;

    once_flag(const once_flag&) = delete;
    once_flag& operator=(const once_flag&) = delete;
};

template<class Callable, class ...Args>
  void call_once(once_flag& flag, Callable&& func, Args&&... args);

}  // std

*///===--------------------------- mutex ------------------------------------===//__func__vp__l0__l1___mb_cur_max_l___mb_cur_max_xlocale *locale_t_xlocale__XLOCALE_H_/* __XLOCALE_H_ *//*
 * Copyright (c) 2005 Apple Computer, Inc. All rights reserved.
 *
 * @APPLE_LICENSE_HEADER_START@
 * 
 * This file contains Original Code and/or Modifications of Original Code
 * as defined in and that are subject to the Apple Public Source License
 * Version 2.0 (the 'License'). You may not use this file except in
 * compliance with the License. Please obtain a copy of the License at
 * http://www.opensource.apple.com/apsl/ and read it before using this
 * file.
 * 
 * The Original Code and all software distributed under the License are
 * distributed on an 'AS IS' basis, WITHOUT WARRANTY OF ANY KIND, EITHER
 * EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES,
 * INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE, QUIET ENJOYMENT OR NON-INFRINGEMENT.
 * Please see the License for the specific language governing rights and
 * limitations under the License.
 * 
 * @APPLE_LICENSE_HEADER_END@
 */<_xlocale.h><_ctype.h>toupper_ltolower_lisxdigit_l_CTYPE_Xisupper_l_CTYPE_Uisspecial_l1048576_CTYPE_Tisspace_l_CTYPE_Sisrune_l42949672800xFFFFFFF0Lispunct_l_CTYPE_Pisprint_l262144_CTYPE_Risphonogram_l2097152_CTYPE_Qisnumber_l_CTYPE_Dislower_l_CTYPE_Lisideogram_l524288_CTYPE_Iishexnumber_lisgraph_l_CTYPE_Gisdigit_liscntrl_l_CTYPE_Cisblank_l131072_CTYPE_Bisalpha_l_CTYPE_Aisalnum_l1280digittoint_l0x0F__wcwidth_l3758096384_CTYPE_SWM3758358528_CTYPE_SWS__tolower_l__darwin_rune_t[256]__darwin_rune_t *__toupper_l__istype_l__uint32_t[256]unsigned int[256]__uint32_t *__maskrune_l___toupper_l___tolower_l___runetype_l_XLOCALE__CTYPE_H_!defined(_DONT_USE_CTYPE_INLINE_) && \_EXTERNALIZE_CTYPE_INLINES_/* _XLOCALE__CTYPE_H_ *//* using inlines *//* not using inlines *//* _EXTERNALIZE_CTYPE_INLINES_ *//* See comments in <machine/_type.h> about __darwin_ct_rune_t. *//*
 * Use inline functions if we are allowed to and the compiler supports them.
 *//Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX.sdk/usr/include/xlocale_c_l_f<xlocale/_ctype.h><__wctype.h>wctype_ltowupper_ltowlower_liswxdigit_liswupper_liswspace_liswpunct_liswprint_liswlower_liswgraph_liswdigit_liswctype_liswcntrl_liswalpha_liswalnum_l_XLOCALE___WCTYPE_H_/* _XLOCALE___WCTYPE_H_ */_wc_charclass<_stdio.h>vasprintf_lasprintf_lvdprintf_ldprintf_lvsscanf_lvsnprintf_lvscanf_lvfscanf_lsnprintf_lvsprintf_lvprintf_lvfprintf_lsscanf_lsprintf_lscanf_lprintf_lfscanf_lfprintf_l_XLOCALE__STDIO_H___DARWIN_C_LEVEL >= 200112L || defined(__cplusplus)__DARWIN_C_LEVEL >= 200809L || defined(__cplusplus)__DARWIN_C_LEVEL >= __DARWIN_C_FULL || defined(__cplusplus)__printf____scanf__"Use vsnprintf_l instead.""Use snprintf_l instead."/* _XLOCALE__STDIO_H_ *//*
 * Copyright (c) 2005, 2009, 2010 Apple Inc. All rights reserved.
 *
 * @APPLE_LICENSE_HEADER_START@
 * 
 * This file contains Original Code and/or Modifications of Original Code
 * as defined in and that are subject to the Apple Public Source License
 * Version 2.0 (the 'License'). You may not use this file except in
 * compliance with the License. Please obtain a copy of the License at
 * http://www.opensource.apple.com/apsl/ and read it before using this
 * file.
 * 
 * The Original Code and all software distributed under the License are
 * distributed on an 'AS IS' basis, WITHOUT WARRANTY OF ANY KIND, EITHER
 * EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES,
 * INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE, QUIET ENJOYMENT OR NON-INFRINGEMENT.
 * Please see the License for the specific language governing rights and
 * limitations under the License.
 * 
 * @APPLE_LICENSE_HEADER_END@
 */wctomb_lwcstombs_lstrtouq_lstrtoull_lstrtoul_lstrtoq_lstrtoll_lstrtold_lstrtol_lstrtof_lstrtod_lmbtowc_lmbstowcs_lmblen_latoll_latol_latoi_latof_l_XLOCALE__STDLIB_H_!__DARWIN_NO_LONG_LONG/* _XLOCALE__STDLIB_H_ *//* !__DARWIN_NO_LONG_LONG */strncasecmp_lstrcasestr_lstrcasecmp_lstrxfrm_lstrcoll_l_XLOCALE__STRING_H_/* _XLOCALE__STRING_H_ */strptime_lstrftime_l_XLOCALE__TIME_H___strftime__/* _XLOCALE__TIME_H_ *//*
 * Copyright (c) 2005, 2009 Apple Inc. All rights reserved.
 *
 * @APPLE_LICENSE_HEADER_START@
 * 
 * This file contains Original Code and/or Modifications of Original Code
 * as defined in and that are subject to the Apple Public Source License
 * Version 2.0 (the 'License'). You may not use this file except in
 * compliance with the License. Please obtain a copy of the License at
 * http://www.opensource.apple.com/apsl/ and read it before using this
 * file.
 * 
 * The Original Code and all software distributed under the License are
 * distributed on an 'AS IS' basis, WITHOUT WARRANTY OF ANY KIND, EITHER
 * EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES,
 * INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE, QUIET ENJOYMENT OR NON-INFRINGEMENT.
 * Please see the License for the specific language governing rights and
 * limitations under the License.
 * 
 * @APPLE_LICENSE_HEADER_END@
 */<sys/_types/_wint_t.h><sys/_types/_mbstate_t.h>fgetwln_lwcsnrtombs_lconst wchar_t **mbstate_t *__mbstate_t *wcsncasecmp_lwcscasecmp_lmbsnrtowcs_lwcstoull_lwcstoll_lwcstold_lwcstof_lvwscanf_lvswscanf_lvfwscanf_lwscanf_lwprintf_lwcwidth_lwctob_lwcsxfrm_lwcswidth_lwcstoul_lwcstol_lwcstod_lwcsrtombs_lwcsftime_lwcscoll_lwcrtomb_lvwprintf_lvswprintf_lvfwprintf_lungetwc_lswscanf_lswprintf_lputwchar_lputwc_lmbsrtowcs_lmbsinit_lconst mbstate_tconst mbstate_t *mbrtowc_lmbrlen_lgetwchar_lgetwc_lfwscanf_lfwprintf_lfputws_lfputwc_lfgetws_lfgetwc_lbtowc_l_XLOCALE__WCHAR_H_/* _XLOCALE__WCHAR_H_ *//* Initially added in Issue 4 */<_types/_wctrans_t.h>wctrans_ltowctrans_lnextwctype_liswspecial_liswrune_liswphonogram_liswnumber_liswideogram_liswhexnumber_liswblank_l_XLOCALE__WCTYPE_H_/* _XLOCALE__WCTYPE_H_ */<xlocale/_wctype.h><xlocale/_wchar.h><xlocale/_time.h><xlocale/_string.h><xlocale/_stdlib.h><xlocale/_stdio.h><xlocale/__wctype.h><_locale.h>uselocalequerylocalenewlocalelconv *localeconv_lfreelocaleduplocaleconst locale_t_c_localeMB_CUR_MAX_L(x)(___mb_cur_max_l(x))MB_CUR_MAX(___mb_cur_max())LC_C_LOCALE((locale_t)NULL)LC_GLOBAL_LOCALE((locale_t)-1)_LC_LAST_MASK(1 << (_LC_NUM_MASK - 1))_LC_NUM_MASKLC_TIME_MASK(1 << 5)LC_NUMERIC_MASK(1 << 4)LC_MONETARY_MASK(1 << 3)LC_MESSAGES_MASK(1 << 2)LC_CTYPE_MASK(1 << 1)LC_COLLATE_MASK(1 << 0)LC_ALL_MASK( LC_COLLATE_MASK | LC_CTYPE_MASK | LC_MESSAGES_MASK | LC_MONETARY_MASK | LC_NUMERIC_MASK | LC_TIME_MASK )_XLOCALE_H_MB_CUR_MAX_L_CTYPE_H___WCTYPE_H__LANGINFO_H__MONETARY_H__STDIO_H__STDLIB_H__WCHAR_H__WCTYPE_H_/* _XLOCALE_H_ *//* _WCTYPE_H_ *//*WCHAR_CTYPE_H_ *//* _TIME_H_ *//*STRING_CTYPE_H_ *//* _STDLIB_H_ *//* _STDIO_H_ *//* _REGEX_H_ *//* _MONETARY_H_ *//* _LANGINFO_H_ *//* _INTTYPES_H_ *//* __WCTYPE_H_ *//* _CTYPE_H_ *//* MB_CUR_MAX *//* !MB_CUR_MAX_L */<xlocale.h><locale.h><cctype><mutex>tolowertoupperisgraphisalnumisxdigitispunctisdigitisalphaislowerisupperiscntrlisprintisspaceconst facetconst facet *facet *id &_Facetconst _Facetconst _Facet &_Facet &use_facethas_facetnumpunct_byname<wchar_t> &const numpunct_byname<wchar_t>const numpunct_byname<wchar_t> &numpunct_byname~numpunct_bynamenumpunct_byname<char> &const numpunct_byname<char>const numpunct_byname<char> &numpunct<wchar_t> &const numpunct<wchar_t>const numpunct<wchar_t> &numpunctdo_falsenamedo_truenamedo_groupingdo_thousands_sepdo_decimal_point~numpunctfalsenameconst numpunct<wchar_t> *numpunct<wchar_t> *truenamegroupingthousands_sepdecimal_pointnumpunct<char> &const numpunct<char>const numpunct<char> &const numpunct<char> *numpunct<char> *__widen_from_utf8<32UL> &const __widen_from_utf8<32UL>const __widen_from_utf8<32UL> &__widen_from_utf8~__widen_from_utf8__widen_from_utf8<32UL> *__widen_from_utf8<16UL> &const __widen_from_utf8<16UL>const __widen_from_utf8<16UL> &__widen_from_utf8<16UL> *__widen_from_utf8<8UL> &const __widen_from_utf8<8UL>const __widen_from_utf8<8UL> &__narrow_to_utf8<32UL> &const __narrow_to_utf8<32UL>const __narrow_to_utf8<32UL> &__narrow_to_utf8~__narrow_to_utf8__narrow_to_utf8<32UL> *__narrow_to_utf8<16UL> &const __narrow_to_utf8<16UL>const __narrow_to_utf8<16UL> &__narrow_to_utf8<16UL> *__narrow_to_utf8<8UL> &const __narrow_to_utf8<8UL>const __narrow_to_utf8<8UL> &~codecvt_bynamecodecvt_bynamecodecvt<char32_t, char, __mbstate_t> &const codecvt<char32_t, char, __mbstate_t>const codecvt<char32_t, char, __mbstate_t> &codecvtdo_max_lengthdo_lengthstate_type &const extern_typeconst extern_type *do_always_noconvdo_encodingdo_unshiftextern_type *extern_type *&do_inconst extern_type *&intern_type *intern_type *&char32_t *&do_outconst intern_typeconst intern_type *const intern_type *&~codecvtcodecvt<char32_t, char, __mbstate_t> *max_lengthconst codecvt<char32_t, char, __mbstate_t> *always_noconvunshiftcodecvt<char16_t, char, __mbstate_t> &const codecvt<char16_t, char, __mbstate_t>const codecvt<char16_t, char, __mbstate_t> &char16_t *&codecvt<char16_t, char, __mbstate_t> *const codecvt<char16_t, char, __mbstate_t> *codecvt<wchar_t, char, __mbstate_t> &const codecvt<wchar_t, char, __mbstate_t>const codecvt<wchar_t, char, __mbstate_t> &wchar_t *&const codecvt<wchar_t, char, __mbstate_t> *codecvt<wchar_t, char, __mbstate_t> *codecvt<char, char, __mbstate_t> &const codecvt<char, char, __mbstate_t> &__nm__frm__end__mx__frm_end__frm_nxt__to_end__to_nxtcodecvt_base &const codecvt_baseconst codecvt_base &codecvt_basecodecvt_base *ctype_byname<wchar_t> &const ctype_byname<wchar_t>const ctype_byname<wchar_t> &ctype_bynamedo_narrowdo_widendo_tolowerdo_toupperdo_scan_notdo_scan_isdo_ismask *~ctype_bynamectype_byname<char> &const ctype_byname<char>const ctype_byname<char> &ctype<char> &const ctype<char>const ctype<char> &ctype~ctypeconst maskconst mask *classic_tabletableconst ctype<char> *ctype<char> *scan_notscan_isctype<wchar_t> &const ctype<wchar_t>const ctype<wchar_t> &const ctype<wchar_t> *ctype<wchar_t> *ctype_base &const ctype_baseconst ctype_base &ctype_basectype_base *collate_byname<wchar_t> &const collate_byname<wchar_t>const collate_byname<wchar_t> &collate_bynamedo_transformdo_compare~collate_bynamecollate_byname<char> &const collate_byname<char>const collate_byname<char> &do_hash~collatecollate__global__install_ctorclassicglobalconst locale *locale *combine~localelocale_Facet *const idconst id &id *__id_(0)facet &const facet &facet~facetnumpunct_byname<wchar_t>numpunct_byname<char>numpunct_byname<_CharT>numpunct<wchar_t>numpunct<char>numpunct<_CharT>__widen_from_utf8<32UL>__widen_from_utf8<16UL>__widen_from_utf8<8UL>__widen_from_utf8<_Np>__narrow_to_utf8<32UL>__narrow_to_utf8<16UL>__narrow_to_utf8<8UL>__narrow_to_utf8<_Np>codecvt_byname<_InternT, _ExternT, _StateT>_InternT_ExternTcodecvt<char32_t, char, __mbstate_t>extern_typeintern_typecodecvt<char16_t, char, __mbstate_t>codecvt<wchar_t, char, __mbstate_t>codecvt<char, char, __mbstate_t>codecvt<_InternT, _ExternT, _StateT>partialnoconvctype_byname<wchar_t>ctype_byname<char>ctype_byname<_CharT>ctype<char>ctype<wchar_t>ctype<_CharT>maskcollate_byname<wchar_t>collate_byname<char>collate_byname<_CharT>collate<_CharT>const category__imp__low__high__lo__hi__lo1__hi1__lo2__hi2__grouping___thousands_sep___decimal_point___del___tab___flag___imp *__locale_table_size_CACHED_RUNESgraphalnumpunct9472alnum | punctalphadigitalpha | digit__regex_wordblankxdigitloweruppercntrlcollate | ctypemonetarycollate | ctype | monetarynumericcollate | ctype | monetary | numericcollate | ctype | monetary | numeric | timemessagescollate | ctype | monetary | numeric | time | messages__next_id_LIBCPP___LOCALEdefined(__NuttX__)defined(_AIX) || defined(__MVS__)defined(__ANDROID__)defined(__sun__)(defined(__APPLE__)      || defined(__FreeBSD__) \defined(__wasi__)defined(_LIBCPP_HAS_MUSL_LIBC)!defined(_LIBCPP_LOCALE__L_EXTENSIONS)defined(_LIBCPP_PROVIDES_DEFAULT_RUNE_TABLE)defined(__GLIBC__)defined(__mips__)defined(__APPLE__) || defined(__FreeBSD__) || defined(__EMSCRIPTEN__) || defined(__NetBSD__)defined(__EMSCRIPTEN__) || defined(__NetBSD__)defined(__NetBSD__)defined(__sun__) || defined(_AIX)defined(__GLIBC__) || defined(__EMSCRIPTEN__)codecvt_byname<char32_t, char, __mbstate_t>class _LIBCPP_DEPRECATED_IN_CXX20 _LIBCPP_EXTERN_TEMPLATE_TYPE_VIS codecvt_byname<char32_t, char, mbstate_t>class __attribute__ ((__visibility__("default"))) codecvt_byname<char32_t, char, mbstate_t>codecvt_byname<char16_t, char, __mbstate_t>class _LIBCPP_DEPRECATED_IN_CXX20 _LIBCPP_EXTERN_TEMPLATE_TYPE_VIS codecvt_byname<char16_t, char, mbstate_t>class __attribute__ ((__visibility__("default"))) codecvt_byname<char16_t, char, mbstate_t>codecvt_byname<wchar_t, char, __mbstate_t>class _LIBCPP_EXTERN_TEMPLATE_TYPE_VIS codecvt_byname<wchar_t, char, mbstate_t>class __attribute__ ((__visibility__("default"))) codecvt_byname<wchar_t, char, mbstate_t>codecvt_byname<char, char, __mbstate_t>class _LIBCPP_EXTERN_TEMPLATE_TYPE_VIS codecvt_byname<char, char, mbstate_t>class __attribute__ ((__visibility__("default"))) codecvt_byname<char, char, mbstate_t>collate<wchar_t>class _LIBCPP_EXTERN_TEMPLATE_TYPE_VIS collate<wchar_t>class __attribute__ ((__visibility__("default"))) collate<wchar_t>collate<char>class _LIBCPP_EXTERN_TEMPLATE_TYPE_VIS collate<char>class __attribute__ ((__visibility__("default"))) collate<char>// _LIBCPP___LOCALE// template <class charT> class numpunct_byname// template <class charT> class numpunct// C++20// deprecated in C++20// template <class _InternT, class _ExternT, class _StateT> class codecvt_byname// template <> class codecvt<char32_t, char8_t, mbstate_t> // C++20// template <> class codecvt<char32_t, char, mbstate_t> // deprecated in C++20// template <> class codecvt<char16_t, char8_t, mbstate_t> // C++20// template <> class codecvt<char16_t, char, mbstate_t> // deprecated in C++20// template <> class codecvt<wchar_t, char, mbstate_t>// template <> class codecvt<char, char, mbstate_t>// template <class internT, class externT, class stateT> class codecvt;// codecvt_base// template <class CharT> class ctype_byname;// FIXME: Don't hardcode this.// Same type as Newlib's _ctype_ array in newlib/libc/include/ctype.h.// see sys/ctype_bits.h, _CTYPE_Q// NetBSD defines classes up to 0x2000// defined(__BIONIC__)// historical value of the constant is preserved for ABI compatibility.// Historically this was a part of regex_traits rather than ctype_base. The// template <class charT> class ctype// template <class CharT> class collate_byname;// around a dllimport bug that expects an external instantiation.// FIXME(EricWF): The _LIBCPP_ALWAYS_INLINE is needed on Windows to work// template <class _CharT> class collate;// only needed for tests//    void operator=(const facet&) = delete;//    facet(const facet&) = delete;     // effectively done in __shared_count// global locale objects:// locale operations:// values assigned here are for exposition only// setlocale(LC_ALL, nullptr).// for the different categories in the same format as returned by// right thing when given a semicolon-separated list of locale settings// The CRT documentation doesn't explicitly say, but setlocale() does the// be what we want, so we only have to check the first case.// each category.  In the second case, we know at least one category won't// locale name, otherwise it will be a semicolon-separated string listing// If every category is the same, the locale string will simply be the// current locale is already the one we want.// already the current locale, so do an explicit check to see if the// Setting the locale can be expensive even when the locale given is// WASI libc uses musl's locales support.__nb__ne__wb__we__tab__delnl_item_NL_ITEM/* _NL_ITEM */<_types/_nl_item.h>catclosecatgetscatopen__nl_cat_d &const __nl_cat_dconst __nl_cat_d &__nl_cat_d *nl_catd__nl_cat_dNL_CAT_LOCALENL_SETD_NL_TYPES_H__NLS_PRIVATEformat_arg/* _NL_TYPES_H_ *//* _NLS_PRIVATE *//* msg number: 0 < x <= NL_MSGMAX *//* index of first msg_hdr in msg_hdr table *//* number of messages in the set  *//* set number: 0 < x <= NL_SETMAX *//*
 * MESSAGE CATALOG FILE FORMAT.
 *
 * The NetBSD/FreeBSD message catalog format is similar to the format used by
 * Svr4 systems.  The differences are:
 *   * fixed byte order (big endian)
 *   * fixed data field sizes
 *
 * A message catalog contains four data types: a catalog header, one
 * or more set headers, one or more message headers, and one or more
 * text strings.
 *//*-
 * Copyright (c) 1996 The NetBSD Foundation, Inc.
 * All rights reserved.
 *
 * This code is derived from software contributed to The NetBSD Foundation
 * by J.T. Conklin.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *        This product includes software developed by the NetBSD
 *        Foundation, Inc. and its contributors.
 * 4. Neither the name of The NetBSD Foundation nor the names of its
 *    contributors may be used to endorse or promote products derived
 *    from this software without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE NETBSD FOUNDATION, INC. AND CONTRIBUTORS
 * ``AS IS'' AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED
 * TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
 * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL THE FOUNDATION OR CONTRIBUTORS
 * BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
 * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
 * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
 * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
 * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
 * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
 * POSSIBILITY OF SUCH DAMAGE.
 *
 * $FreeBSD: src/include/nl_types.h,v 1.11 2005/02/27 16:20:53 phantom Exp $
 *//*	$NetBSD: nl_types.h,v 1.9 2000/10/03 19:53:32 sommerfeld Exp $	*/__libcpp_sscanf_l(__VA_ARGS__...)sscanf_l(__VA_ARGS__)__libcpp_asprintf_l(__VA_ARGS__...)asprintf_l(__VA_ARGS__)__libcpp_snprintf_l(__VA_ARGS__...)snprintf_l(__VA_ARGS__)__libcpp_mbsrtowcs_l(dest,src,len,ps,l)mbsrtowcs_l(dest, src, len, ps, l)__libcpp_localeconv_l(l)localeconv_l(l)__libcpp_mbrlen_l(s,n,ps,l)mbrlen_l(s, n, ps, l)__libcpp_mbtowc_l(pwc,pmb,max,l)mbtowc_l(pwc, pmb, max, l)__libcpp_mbrtowc_l(pwc,s,n,ps,l)mbrtowc_l(pwc, s, n, ps, l)__libcpp_mbsnrtowcs_l(dst,src,nms,len,ps,loc)mbsnrtowcs_l(dst, src, nms, len, ps, loc)__libcpp_wcrtomb_l(src,wc,ps,loc)wcrtomb_l(src, wc, ps, loc)__libcpp_wcsnrtombs_l(dst,src,nwc,len,ps,loc)wcsnrtombs_l(dst, src, nwc, len, ps, loc)__libcpp_wctob_l(wch,loc)wctob_l(wch, loc)__libcpp_btowc_l(ch,loc)btowc_l(ch, loc)__libcpp_mb_cur_max_l(loc)MB_CUR_MAX_L(loc)_LIBCPP_BSD_LOCALE_DEFAULTS_H// _LIBCPP_BSD_LOCALE_DEFAULTS_H// we will define the mapping from an internal macro to the real BSD symbol.// on other platforms though, for fear of conflicts with user code.  So here,// The BSDs have lots of *_l functions.  We don't want to define those symbols//===---------------------- __bsd_locale_defaults.h -----------------------===//<__bsd_locale_defaults.h><nl_types.h>__double_or_nothingunique_ptr<_Tp, ..(*)(..)> &__do_nothing__get_up_to_n_digits_InputIterator &iostate &__ns__num_get_float__do_strtod_LIBCPP_GET_C_LOCALE__num_get_unsigned_integral__num_get_signed_integral__check_grouping__scan_keyword_Ctypeconst _Ctypeconst _Ctype &_Ctype &wbuffer_convert<_Codecvt, _Elem, _Tr> *__closebasic_streambuf<_Elem, _Tr> *_Elem_Elem *streambuf *~wbuffer_convertwbuffer_convert_Codecvt_Codecvt *wbuffer_convert<_Codecvt, _Elem, _Tr> &const wbuffer_convert<_Codecvt, _Elem, _Tr>const wbuffer_convert<_Codecvt, _Elem, _Tr> &convertedto_bytesconst _Elemconst _Elem *const wide_stringconst wide_string &basic_string<_Elem, char_traits<_Elem>, _Wide_alloc> &from_bytesconst byte_stringconst byte_string &basic_string<char, char_traits<char>, _Byte_alloc> &~wstring_convertwstring_convertwstring_convert<_Codecvt, _Elem, _Wide_alloc, _Byte_alloc> &const wstring_convert<_Codecvt, _Elem, _Wide_alloc, _Byte_alloc>const wstring_convert<_Codecvt, _Elem, _Wide_alloc, _Byte_alloc> &~messages_bynamemessages_bynamedo_closedo_getbasic_string<_CharT, char_traits<_CharT>, allocator<_CharT>> &do_open~messagesmessages_base &const messages_baseconst messages_base &messages_basemessages_base *do_put~money_putmoney_put__formatchar_type *&_CharT *&const patternconst pattern &pattern &__gather_infostring_type &__money_put__do_getiter_type &unique_ptr<_CharT, ..(*)(..)> &~money_getmoney_get__money_getdo_neg_formatdo_pos_formatdo_frac_digitsdo_negative_signdo_positive_signdo_curr_symbol~moneypunct_bynamemoneypunct_byname~moneypunctneg_formatpos_formatfrac_digitsnegative_signpositive_signcurr_symbolmoneypunctmoney_base &const money_baseconst money_base &money_basemoney_base *~time_put_bynametime_put_bynametime_put~time_put__time_put &const __time_putconst __time_put &__time_put__do_put~__time_put__time_put *__Xconst string_type *basic_string<_CharT, char_traits<_CharT>, allocator<_CharT>> *__am_pm__months__weeksdo_date_order~time_get_bynametime_get_byname__analyze__do_date_order__time_get_storage~__time_get_storage__time_get &const __time_getconst __time_get &__time_get~__time_get__p2__om__bytebuf__pcvt__wstr__wptr__wchar__byte__byte_err__wide_err__wc__msgid__dflt__intl__digits__units__mb__mi__me__flags__de__neg__pat__dp__ts__grp__sym__sn__err__wn__psn__nsn__tm__fmt__mod__pb__get_day_year_num__get_weekday__get_second__get_minute__get_am_pm__get_12_hour__get_hour__get_year4__get_year__get_month__get_day__get_monthname__get_weekdayname__get_percent__get_white_spacedo_get_yeardo_get_monthnamedo_get_weekdaydo_get_datedo_get_time~time_getget_yearget_monthnameget_weekdayget_dateget_timedate_ordertime_getbasic_string<wchar_t, char_traits<wchar_t>, allocator<wchar_t>> *~__time_get_c_storagetime_base &const time_baseconst time_base &~num_putnum_put__widen_and_group_float__widen_and_group_int__num_put_base &const __num_put_baseconst __num_put_base &__identify_padding__format_float__format_int__do_get_unsigned_Unsigned_Unsigned &__do_get_signed_Signed_Signed &__do_get_floating_point~num_getnum_get__stage2_int_loopunsigned int *&__stage2_int_prep__stage2_float_loop__stage2_float_prep__num_get_base &const __num_get_baseconst __num_get_base &__get_basewbuffer_convert<_Codecvt, _Elem, _Tr>wstring_convert<_Codecvt, _Elem, _Wide_alloc, _Byte_alloc>_Wide_alloc_Byte_allocwide_stringbyte_stringmessages_byname<_CharT>catalogmessages<_CharT>money_put<_CharT, _OutputIterator>iter_type__money_put<_CharT>money_get<_CharT, _InputIterator>__money_get<_CharT>moneypunct_byname<_CharT, _International>_Internationalpatternmoneypunct<_CharT, _International>partsymbolsigntime_put_byname<_CharT, _OutputIterator>time_put<_CharT, _OutputIterator>time_get_byname<_CharT, _InputIterator>dateorder__time_get_storage<_CharT>time_get<_CharT, _InputIterator>__time_get_c_storage<_CharT>time_baseno_orderdmymdyymdydmnum_put<_CharT, _OutputIterator>__num_put<_CharT>__num_put_basenum_get<_CharT, _InputIterator>__fmtb__fmte__a_end__dc__thousands_sep__grouping__g__g_end__atoms__in_units__exp__decimal_point__num_get<_CharT>__num_get_base__bufptr___cvtcount___cvtstate___cvtptr___wide_err_string___byte_err_string___neg_format___pos_format___frac_digits___negative_sign___positive_sign___curr_symbol_field__X___x___c_string_type[2]basic_string<_CharT, char_traits<_CharT>, allocator<_CharT>>[2]__am_pm_string_type[24]basic_string<_CharT, char_traits<_CharT>, allocator<_CharT>>[24]__months_string_type[14]basic_string<_CharT, char_traits<_CharT>, allocator<_CharT>>[14]__weeks_intl__num_get_buf_sz_LIBCPP_TIME_GET_STORAGE_EXPLICIT_INSTANTIATION_LIBCPP_TIME_GET_STORAGE_EXPLICIT_INSTANTIATION(_CharT)template <> _LIBCPP_FUNC_VIS time_base::dateorder __time_get_storage<_CharT>::__do_date_order() const; template <> _LIBCPP_FUNC_VIS __time_get_storage<_CharT>::__time_get_storage(const char*); template <> _LIBCPP_FUNC_VIS __time_get_storage<_CharT>::__time_get_storage(const string&); template <> _LIBCPP_FUNC_VIS void __time_get_storage<_CharT>::init(const ctype<_CharT>&); template <> _LIBCPP_FUNC_VIS __time_get_storage<_CharT>::string_type __time_get_storage<_CharT>::__analyze(char, const ctype<_CharT>&); extern template _LIBCPP_FUNC_VIS time_base::dateorder __time_get_storage<_CharT>::__do_date_order() const; extern template _LIBCPP_FUNC_VIS __time_get_storage<_CharT>::__time_get_storage(const char*); extern template _LIBCPP_FUNC_VIS __time_get_storage<_CharT>::__time_get_storage(const string&); extern template _LIBCPP_FUNC_VIS void __time_get_storage<_CharT>::init(const ctype<_CharT>&); extern template _LIBCPP_FUNC_VIS __time_get_storage<_CharT>::string_type __time_get_storage<_CharT>::__analyze(char, const ctype<_CharT>&);_LIBCPP_HAS_CATOPEN_LIBCPP_LOCALEdefined(__unix__) || (defined(__APPLE__) && defined(__MACH__))!defined(__BIONIC__) && !defined(_NEWLIB_VERSION)defined(__CloudABI__) || defined(__NetBSD__)_LIBCPP_ABI_OPTIMIZED_LOCALE_NUM_GETmessages_byname<wchar_t>class _LIBCPP_EXTERN_TEMPLATE_TYPE_VIS messages_byname<wchar_t>class __attribute__ ((__visibility__("default"))) messages_byname<wchar_t>messages_byname<char>class _LIBCPP_EXTERN_TEMPLATE_TYPE_VIS messages_byname<char>class __attribute__ ((__visibility__("default"))) messages_byname<char>messages<wchar_t>class _LIBCPP_EXTERN_TEMPLATE_TYPE_VIS messages<wchar_t>class __attribute__ ((__visibility__("default"))) messages<wchar_t>messages<char>class _LIBCPP_EXTERN_TEMPLATE_TYPE_VIS messages<char>class __attribute__ ((__visibility__("default"))) messages<char>money_put<wchar_t, ostreambuf_iterator<wchar_t, char_traits<wchar_t>>>class _LIBCPP_EXTERN_TEMPLATE_TYPE_VIS money_put<wchar_t>class __attribute__ ((__visibility__("default"))) money_put<wchar_t>money_put<char, ostreambuf_iterator<char, char_traits<char>>>class _LIBCPP_EXTERN_TEMPLATE_TYPE_VIS money_put<char>class __attribute__ ((__visibility__("default"))) money_put<char>__money_put<wchar_t>class _LIBCPP_EXTERN_TEMPLATE_TYPE_VIS __money_put<wchar_t>class __attribute__ ((__visibility__("default"))) __money_put<wchar_t>__money_put<char>class _LIBCPP_EXTERN_TEMPLATE_TYPE_VIS __money_put<char>class __attribute__ ((__visibility__("default"))) __money_put<char>money_get<wchar_t, istreambuf_iterator<wchar_t, char_traits<wchar_t>>>class _LIBCPP_EXTERN_TEMPLATE_TYPE_VIS money_get<wchar_t>class __attribute__ ((__visibility__("default"))) money_get<wchar_t>money_get<char, istreambuf_iterator<char, char_traits<char>>>class _LIBCPP_EXTERN_TEMPLATE_TYPE_VIS money_get<char>class __attribute__ ((__visibility__("default"))) money_get<char>__money_get<wchar_t>class _LIBCPP_EXTERN_TEMPLATE_TYPE_VIS __money_get<wchar_t>class __attribute__ ((__visibility__("default"))) __money_get<wchar_t>__money_get<char>class _LIBCPP_EXTERN_TEMPLATE_TYPE_VIS __money_get<char>class __attribute__ ((__visibility__("default"))) __money_get<char>moneypunct_byname<wchar_t, true>class _LIBCPP_EXTERN_TEMPLATE_TYPE_VIS moneypunct_byname<wchar_t, true>class __attribute__ ((__visibility__("default"))) moneypunct_byname<wchar_t, true>moneypunct_byname<wchar_t, false>class _LIBCPP_EXTERN_TEMPLATE_TYPE_VIS moneypunct_byname<wchar_t, false>class __attribute__ ((__visibility__("default"))) moneypunct_byname<wchar_t, false>moneypunct_byname<char, true>class _LIBCPP_EXTERN_TEMPLATE_TYPE_VIS moneypunct_byname<char, true>class __attribute__ ((__visibility__("default"))) moneypunct_byname<char, true>moneypunct_byname<char, false>class _LIBCPP_EXTERN_TEMPLATE_TYPE_VIS moneypunct_byname<char, false>class __attribute__ ((__visibility__("default"))) moneypunct_byname<char, false>moneypunct<wchar_t, true>class _LIBCPP_EXTERN_TEMPLATE_TYPE_VIS moneypunct<wchar_t, true>class __attribute__ ((__visibility__("default"))) moneypunct<wchar_t, true>moneypunct<wchar_t, false>class _LIBCPP_EXTERN_TEMPLATE_TYPE_VIS moneypunct<wchar_t, false>class __attribute__ ((__visibility__("default"))) moneypunct<wchar_t, false>moneypunct<char, true>class _LIBCPP_EXTERN_TEMPLATE_TYPE_VIS moneypunct<char, true>class __attribute__ ((__visibility__("default"))) moneypunct<char, true>moneypunct<char, false>class _LIBCPP_EXTERN_TEMPLATE_TYPE_VIS moneypunct<char, false>class __attribute__ ((__visibility__("default"))) moneypunct<char, false>time_put_byname<wchar_t, ostreambuf_iterator<wchar_t, char_traits<wchar_t>>>class _LIBCPP_EXTERN_TEMPLATE_TYPE_VIS time_put_byname<wchar_t>class __attribute__ ((__visibility__("default"))) time_put_byname<wchar_t>time_put_byname<char, ostreambuf_iterator<char, char_traits<char>>>class _LIBCPP_EXTERN_TEMPLATE_TYPE_VIS time_put_byname<char>class __attribute__ ((__visibility__("default"))) time_put_byname<char>time_put<wchar_t, ostreambuf_iterator<wchar_t, char_traits<wchar_t>>>class _LIBCPP_EXTERN_TEMPLATE_TYPE_VIS time_put<wchar_t>class __attribute__ ((__visibility__("default"))) time_put<wchar_t>time_put<char, ostreambuf_iterator<char, char_traits<char>>>class _LIBCPP_EXTERN_TEMPLATE_TYPE_VIS time_put<char>class __attribute__ ((__visibility__("default"))) time_put<char>time_get_byname<wchar_t, istreambuf_iterator<wchar_t, char_traits<wchar_t>>>class _LIBCPP_EXTERN_TEMPLATE_TYPE_VIS time_get_byname<wchar_t>class __attribute__ ((__visibility__("default"))) time_get_byname<wchar_t>time_get_byname<char, istreambuf_iterator<char, char_traits<char>>>class _LIBCPP_EXTERN_TEMPLATE_TYPE_VIS time_get_byname<char>class __attribute__ ((__visibility__("default"))) time_get_byname<char>time_get<wchar_t, istreambuf_iterator<wchar_t, char_traits<wchar_t>>>class _LIBCPP_EXTERN_TEMPLATE_TYPE_VIS time_get<wchar_t>class __attribute__ ((__visibility__("default"))) time_get<wchar_t>time_get<char, istreambuf_iterator<char, char_traits<char>>>class _LIBCPP_EXTERN_TEMPLATE_TYPE_VIS time_get<char>class __attribute__ ((__visibility__("default"))) time_get<char>__kb__ke__case_sensitiveconst wstring *const string *num_put<wchar_t, ostreambuf_iterator<wchar_t, char_traits<wchar_t>>>class _LIBCPP_EXTERN_TEMPLATE_TYPE_VIS num_put<wchar_t>class __attribute__ ((__visibility__("default"))) num_put<wchar_t>num_put<char, ostreambuf_iterator<char, char_traits<char>>>class _LIBCPP_EXTERN_TEMPLATE_TYPE_VIS num_put<char>class __attribute__ ((__visibility__("default"))) num_put<char>__num_put<wchar_t>struct _LIBCPP_EXTERN_TEMPLATE_TYPE_VIS __num_put<wchar_t>struct __attribute__ ((__visibility__("default"))) __num_put<wchar_t>__num_put<char>struct _LIBCPP_EXTERN_TEMPLATE_TYPE_VIS __num_put<char>struct __attribute__ ((__visibility__("default"))) __num_put<char>num_get<wchar_t, istreambuf_iterator<wchar_t, char_traits<wchar_t>>>class _LIBCPP_EXTERN_TEMPLATE_TYPE_VIS num_get<wchar_t>class __attribute__ ((__visibility__("default"))) num_get<wchar_t>num_get<char, istreambuf_iterator<char, char_traits<char>>>class _LIBCPP_EXTERN_TEMPLATE_TYPE_VIS num_get<char>class __attribute__ ((__visibility__("default"))) num_get<char>__num_get<wchar_t>struct _LIBCPP_EXTERN_TEMPLATE_TYPE_VIS __num_get<wchar_t>struct __attribute__ ((__visibility__("default"))) __num_get<wchar_t>__num_get<char>struct _LIBCPP_EXTERN_TEMPLATE_TYPE_VIS __num_get<char>struct __attribute__ ((__visibility__("default"))) __num_get<char>__nar, sizeof(__nar), _LIBCPP_GET_C_LOCALE, __fmt, __v__nar, sizeof(__nar), 0, __fmt, __v&__nb, _LIBCPP_GET_C_LOCALE, __fmt, __v&__nb, 0, __fmt, __v&__nb, _LIBCPP_GET_C_LOCALE, __fmt, (int)__iob.precision(), __v&__nb, 0, __fmt, (int)__iob.precision(), __v__nb, __nbuf, _LIBCPP_GET_C_LOCALE, __fmt, __v__nb, __nbuf, 0, __fmt, __v__nb, __nbuf, _LIBCPP_GET_C_LOCALE, __fmt, (int)__iob.precision(), __v__nb, __nbuf, 0, __fmt, (int)__iob.precision(), __v&__bb, _LIBCPP_GET_C_LOCALE, "%.0Lf", __units&__bb, 0, "%.0Lf", __units__buf.c_str(), _LIBCPP_GET_C_LOCALE, "%p", &__v__buf.c_str(), 0, "%p", &__verrno(*__error())// _LIBCPP_LOCALE// __width > 0 || __off == 0, now check __way//state_type __svs = __st_;// FIXME: Do we ever need to restore the state here?// This only gets executed if _Elem is char// _LIBCPP_HAS_CATOPEN// !_LIBCPP_HAS_CATOPEN// messages// format// secure memory for formatting// gather info// secure memory for digit storage// convert to char// set alignment// print rest of sign, if any// reverse it// print units part// print fractional part// find end of digits// find beginning of digits// remember start of value so we can reverse it// money_put// match in the next loop.// beginning of __sym, which will prevent a// No match. Put __sym_space_end back at the// the beginning of __sym.// Match spaces we've already read against spaces at// sign is required// __nsn.size() > 0 &&  __psn.size() == 0// __nsn.size() == 0// sign is optional// can be compared to initial spaces in __sym.// Capture the spaces read into money_base::{space,none} so they// true == success// money_get// moneypunct_byname// moneypunct// money_base// time_get end primitives// Note:  ignoring case comes from the POSIX strptime spec// time_get primitives// get next digit// get first digit// Precondition:  __n >= 1// Stage 3 & 4// [__o, __oe) contains wide number// end of output// pad here// Stage 2 - Widen __nar// Stage 1 - Get pointer in narrow char// [__o, __oe) contains thousands_sep'd wide number// Stage 2 - Widen __nar while adding thousands separators// Stage 1 - Get number in narrow char// base prefix + terminating null character// round up// 1 char per 3 bits// Worst case is octal, with showbase enabled.// printed as an unsigned value.// Worst case is octal, with showbase enabled. Note that octal is always// EOF checked// Stage 3// Stage 2// Stage 1// Digit grouping checked// Stage 1, nothing to do// unsigned// signed// Return the first matching result// We've exited the loop because we hit eof and/or we have no more "might matches".//   which are now marked as not matching.//   was marked matched on a previous iteration, then such keywords// If we consumed a character and there might be a matched keyword that// consume if we matched a character//    to doesn't match// If the keyword doesn't match this character, then change the keyword//    then that keyword matches.// If a match is found, and that is the last character in the keyword,// If a match if found, consume __c// For each keyword which might match, see if the __indx character is __c// Peek at the next CharT but don't consume it// While there might be a match, test keywords against the next CharT// Initialize all statuses to __might_match, except for "" keywords are __does_match// but none of them definitely do// At this point, any keyword might match//  If the input is "abc", no match is found and "ab" are consumed.//  If the input is "a", the first keyword matches and eofbit is set.//  Keywords:  "a", "abb"//  Examples://  __ct is used to force to lower case before comparing characters.//  If on exit __b == __e, eofbit is set in __err.  If __case_sensitive is false,//  one keyword matches, an iterator to the first matching keyword is returned.//  Else an iterator pointing to the matching keyword is found.  If more than//  and failbit is set in __err.//  no keyword match is found.  If no keyword match is found, __ke is returned//  matching keyword.  If the longer matching keyword ends up not matching, then//  might match another keyword, the algorithm will attempt to find the longest//  If one keyword is a prefix of another, and the next CharT in the input//  or proved to not exist.  A keyword may be "", in which will match anything.//  __b will be incremented (visibly), consuming CharT until a match is found//  [__kb, __ke) or until it can be shown that there is no match in [__kb, __ke).// Scans [__b, __e) until a match is found in the basic_strings range// __scan_keyword// Get the C locale object// Most unix variants have catopen.  These are the specific ones that don't./*
    locale synopsis

namespace std
{

class locale
{
public:
    // types:
    class facet;
    class id;

    typedef int category;
    static const category // values assigned here are for exposition only
        none     = 0x000,
        collate  = 0x010,
        ctype    = 0x020,
        monetary = 0x040,
        numeric  = 0x080,
        time     = 0x100,
        messages = 0x200,
        all = collate | ctype | monetary | numeric | time | messages;

    // construct/copy/destroy:
    locale() noexcept;
    locale(const locale& other) noexcept;
    explicit locale(const char* std_name);
    explicit locale(const string& std_name);
    locale(const locale& other, const char* std_name, category);
    locale(const locale& other, const string& std_name, category);
    template <class Facet> locale(const locale& other, Facet* f);
    locale(const locale& other, const locale& one, category);

    ~locale(); // not virtual

    const locale& operator=(const locale& other) noexcept;

    template <class Facet> locale combine(const locale& other) const;

    // locale operations:
    basic_string<char> name() const;
    bool operator==(const locale& other) const;
    bool operator!=(const locale& other) const;
    template <class charT, class Traits, class Allocator>
      bool operator()(const basic_string<charT,Traits,Allocator>& s1,
                      const basic_string<charT,Traits,Allocator>& s2) const;

    // global locale objects:
    static locale global(const locale&);
    static const locale& classic();
};

template <class Facet> const Facet& use_facet(const locale&);
template <class Facet> bool has_facet(const locale&) noexcept;

// 22.3.3, convenience interfaces:
template <class charT> bool isspace (charT c, const locale& loc);
template <class charT> bool isprint (charT c, const locale& loc);
template <class charT> bool iscntrl (charT c, const locale& loc);
template <class charT> bool isupper (charT c, const locale& loc);
template <class charT> bool islower (charT c, const locale& loc);
template <class charT> bool isalpha (charT c, const locale& loc);
template <class charT> bool isdigit (charT c, const locale& loc);
template <class charT> bool ispunct (charT c, const locale& loc);
template <class charT> bool isxdigit(charT c, const locale& loc);
template <class charT> bool isalnum (charT c, const locale& loc);
template <class charT> bool isgraph (charT c, const locale& loc);
template <class charT> charT toupper(charT c, const locale& loc);
template <class charT> charT tolower(charT c, const locale& loc);

template<class Codecvt, class Elem = wchar_t,
         class Wide_alloc = allocator<Elem>,
         class Byte_alloc = allocator<char>>
class wstring_convert
{
public:
    typedef basic_string<char, char_traits<char>, Byte_alloc> byte_string;
    typedef basic_string<Elem, char_traits<Elem>, Wide_alloc> wide_string;
    typedef typename Codecvt::state_type                      state_type;
    typedef typename wide_string::traits_type::int_type       int_type;

    wstring_convert(Codecvt* pcvt = new Codecvt);          // before C++14
    explicit wstring_convert(Codecvt* pcvt = new Codecvt); // before C++20
    wstring_convert() : wstring_convert(new Codecvt) {}    // C++20
    explicit wstring_convert(Codecvt* pcvt);               // C++20

    wstring_convert(Codecvt* pcvt, state_type state);
    explicit wstring_convert(const byte_string& byte_err,           // explicit in C++14
                    const wide_string& wide_err = wide_string());
    wstring_convert(const wstring_convert&) = delete;               // C++14
    wstring_convert & operator=(const wstring_convert &) = delete;  // C++14
    ~wstring_convert();

    wide_string from_bytes(char byte);
    wide_string from_bytes(const char* ptr);
    wide_string from_bytes(const byte_string& str);
    wide_string from_bytes(const char* first, const char* last);

    byte_string to_bytes(Elem wchar);
    byte_string to_bytes(const Elem* wptr);
    byte_string to_bytes(const wide_string& wstr);
    byte_string to_bytes(const Elem* first, const Elem* last);

    size_t converted() const; // noexcept in C++14
    state_type state() const;
};

template <class Codecvt, class Elem = wchar_t, class Tr = char_traits<Elem>>
class wbuffer_convert
    : public basic_streambuf<Elem, Tr>
{
public:
    typedef typename Tr::state_type state_type;

    wbuffer_convert(streambuf* bytebuf = 0, Codecvt* pcvt = new Codecvt,
                    state_type state = state_type());          // before C++14
    explicit wbuffer_convert(streambuf* bytebuf = nullptr, Codecvt* pcvt = new Codecvt,
                            state_type state = state_type()); // before C++20
    wbuffer_convert() : wbuffer_convert(nullptr) {} // C++20
    explicit wbuffer_convert(streambuf* bytebuf, Codecvt* pcvt = new Codecvt,
                            state_type state = state_type()); // C++20

    wbuffer_convert(const wbuffer_convert&) = delete;               // C++14
    wbuffer_convert & operator=(const wbuffer_convert &) = delete;  // C++14
    ~wbuffer_convert();                                             // C++14

    streambuf* rdbuf() const;
    streambuf* rdbuf(streambuf* bytebuf);

    state_type state() const;
};

// 22.4.1 and 22.4.1.3, ctype:
class ctype_base;
template <class charT> class ctype;
template <> class ctype<char>; // specialization
template <class charT> class ctype_byname;
template <> class ctype_byname<char>; // specialization

class codecvt_base;
template <class internT, class externT, class stateT> class codecvt;
template <class internT, class externT, class stateT> class codecvt_byname;

// 22.4.2 and 22.4.3, numeric:
template <class charT, class InputIterator> class num_get;
template <class charT, class OutputIterator> class num_put;
template <class charT> class numpunct;
template <class charT> class numpunct_byname;

// 22.4.4, col lation:
template <class charT> class collate;
template <class charT> class collate_byname;

// 22.4.5, date and time:
class time_base;
template <class charT, class InputIterator> class time_get;
template <class charT, class InputIterator> class time_get_byname;
template <class charT, class OutputIterator> class time_put;
template <class charT, class OutputIterator> class time_put_byname;

// 22.4.6, money:
class money_base;
template <class charT, class InputIterator> class money_get;
template <class charT, class OutputIterator> class money_put;
template <class charT, bool Intl> class moneypunct;
template <class charT, bool Intl> class moneypunct_byname;

// 22.4.7, message retrieval:
class messages_base;
template <class charT> class messages;
template <class charT> class messages_byname;

}  // std

*///===-------------------------- locale ------------------------------------===//__signdbasic_istringstream<_CharT, _Traits, _Allocator> *__quotedquotedconst __quoted_proxy<_CharT, _Traits, _Allocator>const __quoted_proxy<_CharT, _Traits, _Allocator> &__quoted_proxy<_CharT, _Traits, _Allocator> &const __quoted_output_proxy<_CharT, _Iter, _Traits>const __quoted_output_proxy<_CharT, _Iter, _Traits> &__quoted_output_proxy<_CharT, _Iter, _Traits> &__quoted_input_String &__quoted_outputput_timebasic_ostream<_Cp, _Traits> &const __iom_t10<_Cp>const __iom_t10<_Cp> &__iom_t10<_Cp> &const __iom_t10<_CharT>const __iom_t10<_CharT> &__iom_t10<_CharT> &basic_istream<_Cp, _Traits> &const __iom_t9<_Cp>const __iom_t9<_Cp> &__iom_t9<_Cp> &const __iom_t9<_CharT>const __iom_t9<_CharT> &__iom_t9<_CharT> &put_money_MoneyTconst _MoneyTconst _MoneyT &_MoneyT &const __iom_t8<_Mp>const __iom_t8<_Mp> &__iom_t8<_Mp> &_Mpconst __iom_t8<_MoneyT>const __iom_t8<_MoneyT> &__iom_t8<_MoneyT> &get_moneyconst __iom_t7<_Mp>const __iom_t7<_Mp> &__iom_t7<_Mp> &const __iom_t7<_MoneyT>const __iom_t7<_MoneyT> &__iom_t7<_MoneyT> &setwsetprecisionsetfillconst __iom_t4<_CharT>const __iom_t4<_CharT> &__iom_t4<_CharT> &setbaseconst __iom_t3const __iom_t3 &__iom_t3 &setiosflagsconst __iom_t2const __iom_t2 &__iom_t2 &resetiosflagsconst __iom_t1const __iom_t1 &__iom_t1 &__quoted_proxy__iom_t10__iom_t9__iom_t8__iom_t7__iom_t6__iom_t6 *__iom_t5__iom_t5 *__iom_t4__iom_t4<_CharT> *__iom_t3__iom_t3 *__iom_t2__iom_t2 *__iom_t1__iom_t1 *__quoted_proxy<_CharT, _Traits, _Allocator>__iom_t10<_CharT>__iom_t9<_CharT>__iom_t8<_MoneyT>__iom_t7<_MoneyT>__iom_t4<_CharT>__string__fmt___tm___intl___mon___n__LIBCPP_IOMANIP// _LIBCPP_IOMANIP//  extractor for non-const basic_string& proxies// no delimiter, read the whole string// put_time// get_time// put_money// get_money// setw// setprecision// setfill// setbase// setiosflags// resetiosflags/*
    iomanip synopsis

namespace std {

// types T1, T2, ... are unspecified implementation types
T1 resetiosflags(ios_base::fmtflags mask);
T2 setiosflags (ios_base::fmtflags mask);
T3 setbase(int base);
template<charT> T4 setfill(charT c);
T5 setprecision(int n);
T6 setw(int n);
template <class moneyT> T7 get_money(moneyT& mon, bool intl = false);
template <class charT, class moneyT> T8 put_money(const moneyT& mon, bool intl = false);
template <class charT> T9 get_time(struct tm* tmb, const charT* fmt);
template <class charT> T10 put_time(const struct tm* tmb, const charT* fmt);

template <class charT>
  T11 quoted(const charT* s, charT delim=charT('"'), charT escape=charT('\\')); // C++14

template <class charT, class traits, class Allocator>
  T12 quoted(const basic_string<charT, traits, Allocator>& s,
             charT delim=charT('"'), charT escape=charT('\\')); // C++14

template <class charT, class traits, class Allocator>
  T13 quoted(basic_string<charT, traits, Allocator>& s,
             charT delim=charT('"'), charT escape=charT('\\')); // C++14

}  // std

*///===--------------------------- iomanip ----------------------------------===//__mon__proxywclogclogwcerrcerrwcoutwcincin_LIBCPP_IOSTREAM_LIBCPP_HAS_NO_STDIN_LIBCPP_HAS_NO_STDOUT// _LIBCPP_IOSTREAM/*
    iostream synopsis

#include <ios>
#include <istream>
#include <ostream>
#include <streambuf>

namespace std {

extern istream cin;
extern ostream cout;
extern ostream cerr;
extern ostream clog;
extern wistream wcin;
extern wostream wcout;
extern wostream wcerr;
extern wostream wclog;

}  // std

*///===--------------------------- iostream ---------------------------------===///Users/owura/Repos/codeql_eval/proj_repos/Exiv2-exiv2-pull-962-commits-e925bc5addd881543fa503470c8a859e112cca62/exiv2/src/tags_int.hppexposureTimefnumberprintXmpDateprintXmpVersionprintExifVersionprintNormalSoftHardprintGPSDirRefprint0xa40cprint0xa409print0xa407print0xa406print0xa405print0xa404print0xa403print0xa402print0xa401print0xa301print0xa300print0xa217print0xa001print0x9286print0x920aprint0x9208print0x9207print0x9206print0x9204print0x9202print0x9201print0x9101print0x8827print0x8822print0x829dprint0x829aprint0x8298print0x0213print0x0112print0x001eprint0x0019print0x000cprint0x000aprint0x0009print0x0007print0x0006print0x0005print0x0000printExifUnitprintUcs2printDegreesprintFloatprintLongprintValuetagNumberisExifIfdisMakerIfdgroupIdmpfTagListmnTagListgpsTagListiopTagListexifTagListifdTagListprintTagVocabularyconst TagVocabularyconst TagVocabulary[]TagVocabulary[]const TagVocabulary(&)[]TagVocabulary(&)[]const TagDetailsBitmaskconst TagDetailsBitmask *TagDetailsBitmask *const TagDetailsBitmask[]TagDetailsBitmask[]const TagDetailsBitmask(&)[]TagDetailsBitmask(&)[]sepprintTagBitmaskconst TagDetailsconst TagDetails *TagDetails *const TagDetails[]TagDetails[]const TagDetails(&)[]TagDetails(&)[]("("TagVocabulary &const TagVocabulary &SectionInfo &const SectionInfoconst SectionInfo &TagDetailsBitmask &const TagDetailsBitmask &TagDetails &const TagDetails &TagVocabularySectionInfoSectionIdsectionIdNotSetimgStructrecOffsetimgCharacterotherTagsexifFormatexifVersionimgConfiguserInforelatedFiledateTimecaptureCondgpsTagsiopTagsmpfTagsmakerTagsdngTagspanaRawtiffEptiffPm6adobeOpilastSectionIdIfdIdifdIdNotSetifd0Idifd1Idifd2Idifd3IdexifIdgpsIdiopIdmpfIdsubImage1IdsubImage2IdsubImage3IdsubImage4IdsubImage5IdsubImage6IdsubImage7IdsubImage8IdsubImage9IdsubThumb1IdpanaRawIdmnIdcanonIdcanonCsIdcanonSiIdcanonCfIdcanonPiIdcanonPaIdcanonTiIdcanonFiIdcanonPrIdcasioIdcasio2IdfujiIdminoltaIdminoltaCs5DIdminoltaCs7DIdminoltaCsOldIdminoltaCsNewIdnikon1Idnikon2Idnikon3IdnikonPvIdnikonVrIdnikonPcIdnikonWtIdnikonIiIdnikonAfIdnikonAf21IdnikonAf22IdnikonAFTIdnikonFiIdnikonMeIdnikonFl1IdnikonFl2IdnikonFl3IdnikonSi1IdnikonSi2IdnikonSi3IdnikonSi4IdnikonSi5IdnikonSi6IdnikonLd1IdnikonLd2IdnikonLd3IdnikonCb1IdnikonCb2IdnikonCb2aIdnikonCb2bIdnikonCb3IdnikonCb4IdolympusIdolympus2IdolympusCsIdolympusEqIdolympusRdIdolympusRd2IdolympusIpIdolympusFiIdolympusFe1IdolympusFe2IdolympusFe3IdolympusFe4IdolympusFe5IdolympusFe6IdolympusFe7IdolympusFe8IdolympusFe9IdolympusRiIdpanasonicIdpentaxIdpentaxDngIdsamsung2IdsamsungPvIdsamsungPwIdsigmaIdsony1Idsony2IdsonyMltIdsony1CsIdsony1Cs2Idsony2CsIdsony2Cs2Idsony2FpIdsony1MltCs7DIdsony1MltCsOldIdsony1MltCsNewIdsony1MltCsA100IdlastIdignoreIdTagDetailsBitmaskTagDetailsvoc_mask_val_EXV_PRINT_VOCABULARY(array)printTagVocabulary<EXV_COUNTOF(array), array>EXV_PRINT_TAG_BITMASK(array)printTagBitmask<EXV_COUNTOF(array), array>EXV_PRINT_TAG(array)printTag<EXV_COUNTOF(array), array>TAGS_INT_HPP_// #ifndef TAGS_INT_HPP_//! Calculate the exposure time from an APEX shutter speed value//! Calculate F number from an APEX aperture value//! Print a date following the format YYYY-MM-DDTHH:MM:SSZ//! Print any version encoded in the ASCII string majormajorminorminor//! Print any version packed in 4 Bytes format : major major minor minor//! Print contrast, sharpness (normal, soft, hard)//! Print GPS direction ref//! Print subject distance range//! Print saturation//! Print gain control//! Print scene capture type//! Print 35mm equivalent focal length//! Print digital zoom ratio//! Print white balance//! Print exposure mode//! Print custom rendered//! Print scene type//! Print file source//! Print sensing method//! Print color space//! Print the user comment//! Print the actual focal length of the lens//! Print light source//! Print metering mode//! Print the subject distance//! Print the exposure bias value//! Print f-number converted from APEX aperture value//! Print exposure time converted from APEX shutter speed value//! Print components configuration specific to compressed data//! Print ISO speed ratings//! Print exposure program//! Print the f-number//! Print the exposure time//! Print the copyright//! Print YCbCrPositioning//! Print orientation//! Print GPS differential correction//! Print GPS destination distance ref//! Print GPS speed ref//! Print GPS measurement mode//! Print GPS status//! Print GPS timestamp//! Print GPS altitude//! Print GPS altitude ref//! Print GPS version//! Print function for Exif units//! Print function converting from UCS-2LE to UTF-8//! Print a longitude or latitude value//! Print a Rational or URational value in floating point format//! Print the value converted to a long//! Default print function, using the Value output operator//! @name Functions printing interpreted tag values/*!
      @brief Return the tag number for one combination of IFD id and tagName.
             If the tagName is not known, it expects tag names in the
             form "0x01ff" and converts them to unsigned integer.

      @throw Error if the tagname or ifdId is invalid
     *///! Return the tag info for \em tagName and \em ifdId//! Return the tag info for \em tag and \em ifdId//! Return the tag list for \em ifdId//! Print the list of tags for \em ifdId to the output stream \em os//! Return true if \em ifdId is an %Exif IFD id.//! Return true if \em ifdId is a makernote IFD id. (Note: returns false for makerIfd)//! Return the group name for a group id//! Return the group id for a group name//! Return read-only list of built-in mfp Tags http://www.sno.phy.queensu.ca/~phil/exiftool/TagNames/MPF.html//! Return read-only list of built-in Exiv2 Makernote info tags//! Return read-only list of built-in GPS tags//! Return read-only list of built-in IOP tags//! Return read-only list of built-in Exif IFD tags//! Return read-only list of built-in IFD0/1 tags//! Shortcut for the printTagVocabulary template which requires typing the array name only once./*!
      @brief Generic pretty-print function to translate a controlled vocabulary value (string)
             to a description by looking up a reference table.
     *///! Shortcut for the printTagBitmask template which requires typing the array name only once.// *& acrobatics is a workaround for a MSVC 7.1 bug/*!
      @brief Generic print function to translate a long value to a description
             by looking up bitmasks in a reference table.
     *///! Shortcut for the printTag template which requires typing the array name only once./*!
      @brief Generic pretty-print function to translate a long value to a description
             by looking up a reference table.
     */// struct TagDetails/*!
          @brief Comparison operator for use with the find template

          Compare vocabulary strings like "PR-NON" with keys like
          "http://ns.useplus.org/ldf/vocab/PR-NON" and return true if the vocabulary
          string matches the end of the key.
         *///!< Description of the vocabulary string//!< Vocabulary string/*!
      @brief Helper structure for lookup tables for translations of controlled
             vocabulary strings to their descriptions.
     */// struct TagDetailsBitmask//!< Description of the tag value//!< Bitmask value/*!
      @brief Helper structure for lookup tables for translations of bitmask
             values to human readable labels.
     *///! Comparison operator for use with the find template//!< Translation of the tag value/*!
      @brief Helper structure for lookup tables for translations of numeric
             tag values to human readable labels.
     *///!< Section description//!< Section name (one word)//! The details of a section./*!
      @brief Section identifiers to logically group tags. A section consists
             of nothing more than a name, based on the Exif standard.
     *///! Type to specify the IFD to which a metadata belongs/*!
  @file    tags_int.hpp
  @brief   Internal Exif tag and type information
  @author  Andreas Huggel (ahu)
           <a href="mailto:ahuggel@gmx.net">ahuggel@gmx.net</a>
  @date    15-Jan-04, ahu: created<BR>
           11-Feb-04, ahu: isolated as a component
 */shutterSpeedValueapertureValuestack<_Tp, _Container> &const stack<_Tp, _Container>const stack<_Tp, _Container> &const stack<T1, _C1>const stack<T1, _C1> &stack<T1, _C1> &uses_allocator<stack<_Tp, _Container>, _Alloc>stack<_Tp, _Container>_LIBCPP_STACK// _LIBCPP_STACK/*
    stack synopsis

namespace std
{

template <class T, class Container = deque<T>>
class stack
{
public:
    typedef Container                                container_type;
    typedef typename container_type::value_type      value_type;
    typedef typename container_type::reference       reference;
    typedef typename container_type::const_reference const_reference;
    typedef typename container_type::size_type       size_type;

protected:
    container_type c;

public:
    stack() = default;
    ~stack() = default;

    stack(const stack& q) = default;
    stack(stack&& q) = default;

    stack& operator=(const stack& q) = default;
    stack& operator=(stack&& q) = default;

    explicit stack(const container_type& c);
    explicit stack(container_type&& c);
    template <class Alloc> explicit stack(const Alloc& a);
    template <class Alloc> stack(const container_type& c, const Alloc& a);
    template <class Alloc> stack(container_type&& c, const Alloc& a);
    template <class Alloc> stack(const stack& c, const Alloc& a);
    template <class Alloc> stack(stack&& c, const Alloc& a);

    bool empty() const;
    size_type size() const;
    reference top();
    const_reference top() const;

    void push(const value_type& x);
    void push(value_type&& x);
    template <class... Args> reference emplace(Args&&... args); // reference in C++17
    void pop();

    void swap(stack& c) noexcept(is_nothrow_swappable_v<Container>)
};

template<class Container>
  stack(Container) -> stack<typename Container::value_type, Container>;  // C++17

template<class Container, class Allocator>
  stack(Container, Allocator) -> stack<typename Container::value_type, Container>; // C++17

template <class T, class Container>
  bool operator==(const stack<T, Container>& x, const stack<T, Container>& y);
template <class T, class Container>
  bool operator< (const stack<T, Container>& x, const stack<T, Container>& y);
template <class T, class Container>
  bool operator!=(const stack<T, Container>& x, const stack<T, Container>& y);
template <class T, class Container>
  bool operator> (const stack<T, Container>& x, const stack<T, Container>& y);
template <class T, class Container>
  bool operator>=(const stack<T, Container>& x, const stack<T, Container>& y);
template <class T, class Container>
  bool operator<=(const stack<T, Container>& x, const stack<T, Container>& y);

template <class T, class Container>
  void swap(stack<T, Container>& x, stack<T, Container>& y)
  noexcept(noexcept(x.swap(y)));

}  // std

*///===---------------------------- stack -----------------------------------===///Users/owura/Repos/codeql_eval/proj_repos/Exiv2-exiv2-pull-962-commits-e925bc5addd881543fa503470c8a859e112cca62/exiv2/src/tifffwd_int.hpp"tags_int.hpp"PrimaryGroupsTiffPathNewTiffCompFctFindEncoderFctFindDecoderFctTiffEntryBase *EncoderFctconst TiffEntryBaseconst TiffEntryBase *DecoderFctOffsetWriterIoWrapperTiffMappingInfoTiffPathItemTiffRwStateTiffReaderTiffEncoderTiffDecoderTiffFinderTiffVisitorTiffIfdMakernoteTiffBinaryElementTiffBinaryArrayTiffMnEntryTiffSubIfdTiffDirectoryTiffSizeEntryTiffDataEntryTiffEntryTiffEntryBaseTiffComponentTiffHeaderBaseTIFFFWD_INT_HPP_MnHeader// #ifndef TIFFFWD_INT_HPP_//! Type for a list of primary image groups//! Stack to hold a path from the TIFF root element to a TIFF entry/*!
      @brief Type for a function pointer for a function to create a TIFF component.
             Use TiffComponent::AutoPtr, it is not used in this declaration only
             to reduce dependencies.
     *//*!
      @brief Type for a function pointer for a function to encode a TIFF component.
     *//*!
      @brief Type for a function pointer for a function to decode a TIFF component.
     *//*!
      @brief Function pointer type for a TiffDecoder member function
             to decode a TIFF component.
     */// Exiv2 namespace extensions/*!
  @file    tifffwd_int.hpp
  @brief   Internal TIFF parser related typedefs and forward definitions.
  @author  Andreas Huggel (ahu)
           <a href="mailto:ahuggel@gmx.net">ahuggel@gmx.net</a>
  @date    24-Jun-06, ahu: created
 *//Users/owura/Repos/codeql_eval/proj_repos/Exiv2-exiv2-pull-962-commits-e925bc5addd881543fa503470c8a859e112cca62/exiv2/src/makernote_int.hpp"tifffwd_int.hpp"nikonCryptTiffComponent *TiffComponent *constnikonAf2SelectornikonSelectorsonyCsSelectornewCasio2Mn2newCasioMnnewSony2Mn2newSony1Mn2newSonyMnnewSigmaMn2newSigmaMnnewSamsungMn2newSamsungMnnewPentaxDngMn2newPentaxMn2newPentaxMnnewPanasonicMn2newPanasonicMnnewNikon3Mn2newNikon2Mn2newNikonMnnewFujiMn2newFujiMnnewOlympus2Mn2newOlympusMn2newOlympusMnnewIfdMn2newIfdMnreadExiv2ConfiggetExiv2ConfigPathCasio2MnHeader &Casio2MnHeadersizeOfSignatureIoWrapper &~Casio2MnHeaderSonyMnHeader &SonyMnHeader~SonyMnHeaderSigmaMnHeader &SigmaMnHeader~SigmaMnHeaderSamsungMnHeader &const SamsungMnHeaderconst SamsungMnHeader &~SamsungMnHeaderSamsungMnHeaderbaseOffsetPentaxMnHeader &PentaxMnHeader~PentaxMnHeaderPentaxDngMnHeader &PentaxDngMnHeader~PentaxDngMnHeaderPanasonicMnHeader &PanasonicMnHeader~PanasonicMnHeaderNikon3MnHeader &Nikon3MnHeader~Nikon3MnHeaderNikon2MnHeader &Nikon2MnHeader~Nikon2MnHeaderFujiMnHeader &FujiMnHeader~FujiMnHeaderOlympus2MnHeader &Olympus2MnHeader~Olympus2MnHeaderOlympusMnHeader &OlympusMnHeader~OlympusMnHeaderMnHeader &const MnHeaderconst MnHeader &~MnHeaderTiffMnCreatorTiffMnCreator &const TiffMnCreatorconst TiffMnCreator &~TiffMnCreatorTiffMnCreator *TiffMnRegistry &const TiffMnRegistryconst TiffMnRegistry &TiffMnRegistryNewMnFct2NewMnFctstart_newMnFct2_newMnFct_mnGroup_make_const byte[]signature_signature2_signature1_const TiffMnRegistry[]TiffMnRegistry[]MAKERNOTE_INT_HPP_// #ifndef MAKERNOTE_INT_HPP_/*!
      @brief Encrypt and decrypt Nikon data.

      Checks the version of the Nikon data array and en/decrypts (portions of) it as
      needed. (The Nikon encryption algorithm is symmetric.)

      @note This function requires access to other components of the composite, it
            should only be called after all other components are read.

      @param tag Tag number of the binary array
      @param pData Pointer to the start of the data to en/decrypt.
      @param size Size of the data buffer.
      @param pRoot Pointer to the root element of the composite.
      @return En/decrypted data. Ownership of the memory is passed to the caller.
              The buffer may be empty in case no decryption was needed.
     *//*!
      @brief Function to select cfg + def of a Nikon complex binary array.

      @param tag Tag number of the binary array
      @param pData Pointer to the raw array data.
      @param size Size of the array data.
      @param pRoot Pointer to the root component of the TIFF tree.
      @return An index into the array set, -1 if no match was found.
     *//*!
      @brief Function to select cfg + def of the Sony Camera Settings complex binary array.

      @param tag Tag number of the binary array
      @param pData Pointer to the raw array data.
      @param size Size of the array data.
      @param pRoot Pointer to the root component of the TIFF tree.
      @return An index into the array set, -1 if no match was found.
     *///! Function to create a Casio2 makernote//! Function to create a Sony2 makernote//! Function to create a Sony1 makernote//! Function to create a Sony makernote//! Function to create a Sigma makernote//! Function to create a Samsung makernote//! Function to create an Pentax DNG makernote//! Function to create an Pentax makernote//! Function to create a Panasonic makernote//! Function to create a Nikon3 makernote//! Function to create a Nikon2 makernote/*!
      @brief Function to create a Nikon makernote. This will create the
             appropriate Nikon 1, 2 or 3 makernote, based on the arguments.
     *///! Function to create a Fujifilm makernote//! Function to create an Olympus II makernote//! Function to create an Olympus makernote//! Function to create a simple IFD makernote (Canon, Minolta, Nikon1)// class Casio2MnHeader//!< Byteorder for makernote (always big endian)//!< Casio makernote header signature//!< Start of the mn IFD rel. to mn start//!< Raw header data//! Return the size of the makernote header signature//! Header of a Casio2 Makernote// class SonyMnHeader//!< Sony makernote header signature//! Header of a Sony Makernote// class SigmaMnHeader//!< Sigma makernote header signature 2//!< Sigma makernote header signature 1//! Header of a Sigma Makernote// class SamsungMnHeader//! Header of a Samsung Makernote, only used for the relative offset// class PentaxMnHeader//!< Pentax makernote header signature//!< Data buffer for the makernote header//! Header of an Pentax Makernote// class PentaxDngMnHeader//!< Pentax DNG makernote header signature//! Header of an Pentax DNG Makernote// class PanasonicMnHeader//!< Panasonic makernote header signature//! Header of a Panasonic Makernote// class Nikon3MnHeader//!< Nikon 3 makernote header signature//!< Byteorder for makernote//! Header of a Nikon 3 Makernote// class Nikon2MnHeader//!< Nikon 2 makernote header signature//! Header of a Nikon 2 Makernote// class FujiMnHeader//!< Byteorder for makernote (always II)//!< Fujifilm makernote header signature// setByteOrder not implemented//! Header of a Fujifilm Makernote// class Olympus2MnHeader//!< Olympus makernote header signature//! Header of an Olympus II Makernote// class OlympusMnHeader//! Header of an Olympus Makernote// class MnHeader/*!
          @brief Return the base offset for the makernote IFD entries relative
                 to the start of the TIFF header. \em mnOffset is the offset
                 to the makernote from the start of the TIFF header.
         *//*!
          @brief Return the byte order for the makernote. If the return value is
                 invalidByteOrder, this means that the byte order of the the
                 image should be used for the makernote.
         *//*!
          @brief Return the offset to the start of the Makernote IFD from
                 the start of the Makernote (= the start of the header).
         *///! Write the header to a data buffer, return the number of bytes written.//! Return the size of the header (in bytes)./*!
          @brief Set the byte order for the makernote.
         *///! Read the header from a data buffer, return true if ok//! Makernote header interface. This class is used with TIFF makernotes.// class TiffMnCreator//<! List of makernotes//! Prevent destruction (needed if used as a policy class)/*!
          @brief Create the Makernote for a given group. This method is used
                 when a makernote is written back from Exif tags.
         *//*!
          @brief Create the Makernote for camera \em make and details from
                 the makernote entry itself if needed. Return a pointer to
                 the newly created TIFF component. Set tag and group of the
                 new component to \em tag and \em group. This method is used
                 when a makernote is parsed from the Exif block.
          @note  Ownership for the component is transferred to the caller,
                 who is responsible to delete the component. No smart pointer
                 is used to indicate this transfer here in order to reduce
                 file dependencies.
        *//*!
      @brief TIFF makernote factory for concrete TIFF makernotes.
     *///!< Makernote create function (group)//!< Makernote create function (image)//!< Group identifier//!< Camera make//! Compare a TiffMnRegistry structure with a makernote group/*!
          @brief Compare a TiffMnRegistry structure with a key being the make
                 string from the image. The two are equal if
                 TiffMnRegistry::make_ equals a substring of the key of the
                 same size. E.g., registry = "OLYMPUS",
                 key = "OLYMPUS OPTICAL CO.,LTD" (found in the image) match.
         *///! Makernote registry structure//! Type for a pointer to a function creating a makernote (group)//! Type for a pointer to a function creating a makernote (image)/*!
          @brief Read value from Exiv2 configuration file
         *//*!
          @brief Determine the path to the Exiv2 configuration file
         */// function prototypes/*!
  @file    makernote_int.hpp
  @brief   Makernote factory and registry, IFD makernote header, and camera
           vendor specific makernote implementations.<BR>References:<BR>
  [1] <a href="http://www.sno.phy.queensu.ca/~phil/exiftool/">ExifTool</a> by Phil Harvey<BR>
  [2] <a href="http://www.cybercom.net/~dcoffin/dcraw/">Decoding raw digital photos in Linux</a> by Dave Coffin
  @author  Andreas Huggel (ahu)
           <a href="mailto:ahuggel@gmx.net">ahuggel@gmx.net</a>
  @date    11-Apr-06, ahu: created
 */pRootgroupmnGroupioWrappermnOffsetmakedef/Users/owura/Repos/codeql_eval/proj_repos/Exiv2-exiv2-pull-962-commits-e925bc5addd881543fa503470c8a859e112cca62/exiv2/src/canonmn_int.hppCanonMakerNote &const CanonMakerNoteconst CanonMakerNote &CanonMakerNoteCANONMN_INT_HPP_canonEvconst TagInfo[]TagInfo[]tagInfoPr_tagInfoPa_tagInfoFi_tagInfoTi_tagInfoPi_tagInfoCf_tagInfoSi_tagInfoCs_tagInfo_printFiFocusDistanceprintSi0x0017printSi0x0016printSi0x0015printSi0x0013printSi0x000eprintSi0x0009printSi0x0003printSi0x0002printCsLensprintCsLensTypeprintCs0x0002print0x0008printFocalLengthprintFiFileNumbertagListPrtagListFitagListTitagListPitagListCftagListPatagListSitagListCs// #ifndef CANONMN_INT_HPP_/*!
       @brief Convert Canon hex-based EV (modulo 0x20) to real number
              Ported from Phil Harvey's Image::ExifTool::Canon::CanonEv
              by Will Stokes

       0x00 -> 0
       0x0c -> 0.33333
       0x10 -> 0.5
       0x14 -> 0.66666
       0x20 -> 1
       ..
       160 -> 5
       128 -> 4
       143 -> 4.46875
     */// class CanonMakerNote//! Focus Distance//! MeasuredEV2//! Shutter speed//! Aperture//! Subject distance//! AF point used//! Sequence number//! MeasuredEV//! ISO speed used//! Camera lens information//! Camera lens type. For some values, the exact type can only be determined if \em metadata is provided.//! Self timer//! Print the serial number of the camera//! Print the image number//! Print the focal length//! Print the FileInfo FileNumber//! @name Print functions for Canon %MakerNote tags//! Return read-only list of built-in Canon Processing Info tags//! Return read-only list of built-in Canon File Info tags//! Return read-only list of built-in Canon Time Info tags//! Return read-only list of built-in Canon Picture Info tags//! Return read-only list of built-in Canon Custom Function tags//! Return read-only list of built-in Canon Panorama tags//! Return read-only list of built-in Canon Shot Info tags//! Return read-only list of built-in Canon Camera Settings tags//! Return read-only list of built-in Canon tags//! MakerNote for Canon cameras/*!
  @file    canonmn_int.hpp
  @brief   Canon makernote tags.<BR>References:<BR>
           [1] <a href="http://www.burren.cx/david/canon.html">EXIF MakerNote of Canon</a> by David Burren<br>
           [2] <a href="http://www.sno.phy.queensu.ca/~phil/exiftool/TagNames/Canon.html">Canon makernote tags</a> by Phil Harvey
  @author  <a href="mailto:ahuggel@gmx.net">Andreas Huggel (ahu)</a><br>
           <a href="mailto:david@edeca.net">David Cannings (dc)</a>
           <a href="mailto:andi.clemens@gmx.net">Andi Clemens (ac)</a>
  @date    18-Feb-04, ahu: created<BR>
           07-Mar-04, ahu: isolated as a separate component<BR>
           12-Aug-06,  dc: started updating all tags
 */pExifDatametadatalibintl_set_relocation_prefixlibintl_newlocalelibintl_setlocalebind_textdomain_codesetlibintl_bind_textdomain_codesetbindtextdomainlibintl_bindtextdomaintextdomainlibintl_textdomaindcngettextlibintl_dcngettextdngettextlibintl_dngettextngettextlibintl_ngettextdcgettextlibintl_dcgettextdgettextlibintl_dgettextgettextlibintl_gettextlibintl_versionsetlocale_INTL_MAY_RETURN_STRING_ARG(n)__attribute__ ((__format_arg__ (n)))_INTL_ASM(cname)_INTL_REDIRECT_INLINELIBINTL_VERSION0x001402__GNU_GETTEXT_SUPPORTED_REVISION(major)((major) == 0 || (major) == 1 ? 1 : -1)__USE_GNU_GETTEXT_LIBINTL_H(defined __APPLE__ && defined __MACH__) && 1!defined LC_MESSAGES && !(defined __LOCALE_H || (defined _LOCALE_H && defined __sun))__DJGPP__!(defined _INTL_REDIRECT_INLINE || defined _INTL_REDIRECT_MACROS)defined __GNUC__ && __GNUC__ >= 2 && !(defined __APPLE_CC__ && __APPLE_CC__ > 1) && !defined __MINGW32__ && !(__GNUC__ == 2 && defined _AIX) && (defined __STDC__ || defined __cplusplus)_INTL_REDIRECT_ASMdefined __GNUC__ && __GNUC__ >= 3 && !(defined __APPLE_CC__ && __APPLE_CC__ > 1 && !(defined __clang__ && __clang__ && __clang_major__ >= 3) && defined __cplusplus)_INTL_REDIRECT_MACROS!1(defined __STDC__ && __STDC__) || defined __cplusplus || defined _MSC_VER!(defined fprintf && defined _GL_STDIO_H)!(defined vfprintf && defined _GL_STDIO_H)!(defined printf && defined _GL_STDIO_H)defined __NetBSD__ || defined __BEOS__ || defined __CYGWIN__ || defined __MINGW32__!(defined vprintf && defined _GL_STDIO_H)!(defined sprintf && defined _GL_STDIO_H)!(defined vsprintf && defined _GL_STDIO_H)!(defined snprintf && defined _GL_STDIO_H)!(defined vsnprintf && defined _GL_STDIO_H)!(defined asprintf && defined _GL_STDIO_H)!(defined vasprintf && defined _GL_STDIO_H)GNULIB_defined_newlocaleGNULIB_defined_duplocaleGNULIB_defined_freelocale(defined __APPLE__ && defined __MACH__) || defined _WIN32 || defined __CYGWIN__GNULIB_defined_setlocale!(defined __CYGWIN__ && !defined LC_ALL_MASK)__APPLE_CC__6000/* libintl.h *//* Declare newlocale() only if the system headers define the 'locale_t' type. *//* don't override gnulib *//* Support for the locale chosen by the user.  *//* Support for retrieving the name of a locale_t object.  *//* Don't break __attribute__((format(printf,M,N))).
   This redefinition is only possible because the libc in NetBSD, Cygwin,
   mingw does not have a function __printf__.
   Alternatively, we could have done this redirection only when compiling with
   __GNUC__, together with a symbol redirection:
       extern int printf (const char *, ...)
              __asm__ (#__USER_LABEL_PREFIX__ "libintl_printf");
   But doing it now would introduce a binary incompatibility with already
   distributed versions of libintl on these systems.  *//* Get va_list.  *//* Support for format strings with positions in *printf(), following the
   POSIX/XSI specification.
   Note: These replacements for the *printf() functions are visible only
   in source files that #include <libintl.h> or #include "gettext.h".
   Packages that use *printf() in source files that don't refer to _()
   or gettext() but for which the format string could be the return value
   of _() or gettext() need to add this #include.  Oh well.  *//* Specify the character encoding in which the messages from the
   DOMAINNAME message catalog will be returned.  *//* Specify that the DOMAINNAME message catalog will be found
   in DIRNAME rather than in the system locale data base.  *//* Set the current default message catalog to DOMAINNAME.
   If DOMAINNAME is null, return the current default.
   If DOMAINNAME is "", reset to the default of "messages".  *//* Similar to 'dcgettext' but select the plural form corresponding to the
   number N.  *//* Similar to 'dgettext' but select the plural form corresponding to the
   number N.  *//* Similar to 'gettext' but select the plural form corresponding to the
   number N.  *//* Look up MSGID in the DOMAINNAME message catalog for the current CATEGORY
   locale.  *//* Look up MSGID in the DOMAINNAME message catalog for the current
   LC_MESSAGES locale.  *//* Look up MSGID in the current default message catalog for the current
   LC_MESSAGES locale.  If not found, returns MSGID itself (the default
   text).  *//* _INTL_MAY_RETURN_STRING_ARG(n) declares that the given function may return
   its n-th argument literally.  This enables GCC to warn for example about
   printf (gettext ("foo %y")).  *//* Auxiliary macros.  *//* The user can define _INTL_REDIRECT_INLINE or _INTL_REDIRECT_MACROS.
   If he doesn't, we choose the method.  A third possible method is
   _INTL_REDIRECT_ASM, supported only by GCC.  *//* We redirect the functions to those prefixed with "libintl_".  This is
   necessary, because some systems define gettext/textdomain/... in the C
   library (namely, Solaris 2.4 and newer, and GNU libc 2.0 and newer).
   If we used the unprefixed names, there would be cases where the
   definition in the C library would override the one in the libintl.so
   shared library.  Recall that on ELF systems, the symbols are looked
   up in the following order:
     1. in the executable,
     2. in the shared libraries specified on the link command line, in order,
     3. in the dependencies of the shared libraries specified on the link
        command line,
     4. in the dlopen()ed shared libraries, in the order in which they were
        dlopen()ed.
   The definition in the C library would override the one in libintl.so if
   either
     * -lc is given on the link command line and -lintl isn't, or
     * -lc is given on the link command line before -lintl, or
     * libintl.so is a dependency of a dlopen()ed shared library but not
       linked to the executable at link time.
   Since Solaris gettext() behaves differently than GNU gettext(), this
   would be unacceptable.

   The redirection happens by default through macros in C, so that &gettext
   is independent of the compilation unit, but through inline functions in
   C++, in order not to interfere with the name mangling of class fields or
   class methods called 'gettext'.  *//* Version number: (major<<16) + (minor<<8) + subminor *//* Resolve a platform specific conflict on DJGPP.  GNU gettext takes
   precedence over _conio_gettext.  *//* Provide information about the supported file formats.  Returns the
   maximum minor revision number supported for a given major revision.  *//* We define an additional symbol to signal that we use the GNU
   implementation of gettext.  *//* The LC_MESSAGES locale category is the category used by the functions
   gettext() and dgettext().  It is specified in POSIX, but not in ANSI C.
   On systems that don't define it, use an arbitrary value instead.
   On Solaris, <locale.h> defines __LOCALE_H (or _LOCALE_H in Solaris 2.5)
   then includes <libintl.h> (i.e. this file!) and then only defines
   LC_MESSAGES.  To avoid a redefinition warning, don't define LC_MESSAGES
   in this case.  *//* Message catalogs for internationalization.
   Copyright (C) 1995-1997, 2000-2016, 2018-2020 Free Software Foundation, Inc.

   This program is free software: you can redistribute it and/or modify
   it under the terms of the GNU Lesser General Public License as published by
   the Free Software Foundation; either version 2.1 of the License, or
   (at your option) any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU Lesser General Public License for more details.

   You should have received a copy of the GNU Lesser General Public License
   along with this program.  If not, see <https://www.gnu.org/licenses/>.  *//usr/local/Cellar/gettext/0.20.2_1/include/usr/local/Cellar/gettext/0.20.2_1/usr/local/Cellar/gettext/usr/local/Cellar/usr/local/usr__domainname__codeset__dirname__msgid1__msgid2__category<libintl.h>_exvGettextN_(String)_(String)_exvGettext(String)I18N_H_/* I18N_H_ *//* EXV_ENABLE_NLS *//* NLS is disabled */// Definition is in types.cpp/* NLS can be disabled through the configure --disable-nls option. *//*
  File:      i18n.h
  Brief:     i18n definitions. Do not use. This is an Exiv2 internal header.
  Author(s): Gilles Caulier (gc) <caulier.gilles@kdemail.net>
  History:   01-Nov-06, gc: created
 *//* **************************************************************** -*- C -*- */significandgammafinitedremroundtolrinttolscalbyny1y0jnj1j0__sincospidouble *const __double2__stret__sincospiffloat *const __float2__sincos__sincosf__sincospi_stret__sincospif_stret__sincos_stret__sincosf_stret__tanpi__tanpif__sinpi__sinpif__cospi__cospif__exp10__exp10f__nan__infl__inf__inff__inline_isnormall__builtin_fabsl3.3621031431120935063e-4932__inline_isnormald__builtin_fabs2.225073858507201383e-308__inline_isnormalf__builtin_fabsf1.175494351e-38__inline_signbitl__inline_signbitd__inline_signbitf__inline_isnanl__inline_isnand__inline_isnanf__inline_isinfl__builtin_infl+Infinity__builtin_infl()__inline_isinfd__builtin_inf__builtin_inf()__inline_isinff__builtin_inff__builtin_inff()__inline_isfinitel__inline_isfinited__inline_isfinitef__fpclassifyl__fpclassifyd__fpclassifyf__math_errhandling__double2 &const __double2 &__float2 &const __float2 &truncltgammalscalbnlscalblnlroundlrintlremquolremainderlnexttowardlnextafterlnearbyintlnanllroundllrintllogbllog2llog1plllroundlllrintllgammalilogblhypotlfminlfmaxlfmalfdimlexpm1lexp2lerfclerflcopysignlcbrtlatanhlasinhlacoshltanhltanlsqrtlsinhlsinlpowlmodfllong double *log10lloglldexplfrexplfmodlfloorlfabslexplcoshlcoslceillatan2latanlasinlacosltruncftgammaftgammascalbnfscalbnscalblnfscalblnroundfroundrintfrintremquofremquoremainderfremaindernexttowardfnexttowardnextafterfnextafternearbyintfnearbyintnanfnanlroundflroundlrintflrintlogbflogblog2flog2log1pflog1pllroundfllroundllrintfllrintlgammaflgammailogbfilogbhypotfhypotfminffminfmaxffmaxfmafmaffdimffdimexpm1fexpm1exp2fexp2erfcferfcerfferfcopysignfcopysigncbrtfcbrtatanhfatanhasinhfasinhacoshfacoshtanhftanhtanftansqrtfsqrtsinhfsinhsinfsinpowfpowmodffmodflog10flog10logflogldexpfldexpfrexpffrexpfmodffmodfloorffloorfabsffabsexpfexpcoshfcoshcosfcosceilfceilatan2fatan2atanfatanasinfasinacosfacos__double2__float2double_tfloat_t__sexp__ld__cosval__sinvalsigngamPLOSSTLOSSUNDERFLOWOVERFLOWSINGDOMAINX_TLOSS1.41484755040568800000e+16HUGEMAXFLOATFP_QNANFP_NANFP_SNAN0x1.fffffep+127fM_SQRT1_20.707106781186547524400844362104849039M_SQRT21.41421356237309504880168872420969808M_2_SQRTPI1.12837916709551257389615890312154517M_2_PI0.636619772367581343075535053490057448M_1_PI0.318309886183790671537767526745028724M_PI_40.785398163397448309615660845819875721M_PI_21.57079632679489661923132169163975144M_PI3.14159265358979323846264338327950288M_LN102.30258509299404568401799145468436421M_LN20.693147180559945309417232121458176568M_LOG10E0.434294481903251827651128918916605082M_LOG2E1.44269504088896340735992468100189214M_E2.71828182845904523536028747135266250isunordered(x,y)__builtin_isunordered((x),(y))islessgreater(x,y)__builtin_islessgreater((x),(y))islessequal(x,y)__builtin_islessequal((x),(y))isless(x,y)__builtin_isless((x),(y))isgreaterequal(x,y)__builtin_isgreaterequal((x),(y))isgreater(x,y)__builtin_isgreater((x),(y))signbit(x)( sizeof(x) == sizeof(float) ? __inline_signbitf((float)(x)) : sizeof(x) == sizeof(double) ? __inline_signbitd((double)(x)) : __inline_signbitl((long double)(x)))isnan(x)( sizeof(x) == sizeof(float) ? __inline_isnanf((float)(x)) : sizeof(x) == sizeof(double) ? __inline_isnand((double)(x)) : __inline_isnanl((long double)(x)))isinf(x)( sizeof(x) == sizeof(float) ? __inline_isinff((float)(x)) : sizeof(x) == sizeof(double) ? __inline_isinfd((double)(x)) : __inline_isinfl((long double)(x)))isfinite(x)( sizeof(x) == sizeof(float) ? __inline_isfinitef((float)(x)) : sizeof(x) == sizeof(double) ? __inline_isfinited((double)(x)) : __inline_isfinitel((long double)(x)))isnormal(x)( sizeof(x) == sizeof(float) ? __inline_isnormalf((float)(x)) : sizeof(x) == sizeof(double) ? __inline_isnormald((double)(x)) : __inline_isnormall((long double)(x)))fpclassify(x)( sizeof(x) == sizeof(float) ? __fpclassifyf((float)(x)) : sizeof(x) == sizeof(double) ? __fpclassifyd((double)(x)) : __fpclassifyl((long double)(x)))math_errhandling(__math_errhandling())MATH_ERREXCEPTMATH_ERRNOFP_ILOGBNAN(-2147483647 - 1)FP_ILOGB0FP_FAST_FMALFP_FAST_FMAFFP_FAST_FMAFP_SUPERNORMALFP_SUBNORMALFP_NORMALFP_ZEROFP_INFINITEINFINITYHUGE_VALFNAN__builtin_nanf("0x7fc00000")HUGE_VALL__builtin_huge_vall()__builtin_huge_valf()HUGE_VAL__builtin_huge_val()__MATH____MATH_H____FLT_EVAL_METHOD__ == 0__FLT_EVAL_METHOD__ == 1__FLT_EVAL_METHOD__ == 2 || __FLT_EVAL_METHOD__ == -1defined __arm64__ || defined __ARM_VFPV4__(defined __i386__ || defined __x86_64__) && (defined __FMA__ || defined __AVX512F__)(defined(__GNUC__) && 0 == __FINITE_MATH_ONLY__)defined __i386__ || defined __x86_64__!(__DARWIN_NO_LONG_LONG)_REENTRANT(defined __MAC_OS_X_VERSION_MIN_REQUIRED && __MAC_OS_X_VERSION_MIN_REQUIRED < 1090) || \defined __MATH_LONG_DOUBLE_CONSTANTS!defined __cplusplus"Use `2*frexp( )` or `scalbn(x, -ilogb(x))` instead.""Use `isfinite((double)x)` instead."10.14"use `NAN` instead""use `(long double)INFINITY` instead""use `INFINITY` instead""use `(float)INFINITY` instead"ios, watchos, tvos"Use `2*frexp( )` or `scalbn(x, -ilogb(x))` instead.", macos(10.0, 10.9)macos(10.0, 10.9)__API_DEPRECATED_MSG8__API_DEPRECATED_MSG7__API_DEPRECATED_MSG6__API_DEPRECATED_MSG5__API_DEPRECATED_MSG4__API_DEPRECATED_MSG3__API_DEPRECATED_MSG2__API_DEPRECATED_MSG1, 0"tgamma", macos(10.0, 10.9)"tgamma"__API_DEPRECATED_REP8__API_DEPRECATED_REP7__API_DEPRECATED_REP6__API_DEPRECATED_REP5__API_DEPRECATED_REP4__API_DEPRECATED_REP3__API_DEPRECATED_REP2__API_DEPRECATED_REP1, 0macos(10.9), ios(7.0)macos(10.9)ios(7.0)"use `NAN` instead", macos(10.0, 10.14)macos(10.0, 10.14)"use `(long double)INFINITY` instead", macos(10.0, 10.9)"Use `isfinite((double)x)` instead.", macos(10.0, 10.9)"remainder", macos(10.0, 10.9)"remainder""lround", macos(10.0, 10.9)"lround""lrint", macos(10.0, 10.9)"lrint"macos(10.0), ios(3.2)macos(10.0)"use `INFINITY` instead", macos(10.0, 10.9)"use `(float)INFINITY` instead", macos(10.0, 10.9)__LDBL_MIN__3.36210314311209350626e-4932L__DBL_MIN__2.2250738585072014e-308__FLT_MIN__1.17549435e-38F__FINITE_MATH_ONLY____FLT_EVAL_METHOD__/* __MATH_H__ *//* !defined __cplusplus *//* Legacy BSD API; use `2*frexp( )` or `scalbn(x, -ilogb(x))` instead.        *//* Legacy BSD API; use the C99 `tgamma( )` function instead.                  *//* Legacy BSD API; use the C99 `isfinite( )` macro instead.                   *//* Legacy BSD API; use the C99 `remainder( )` function instead.               *//* Legacy BSD API; use the C99 `lround( )` function instead.                  *//* Legacy BSD API; use the C99 `lrint( )` function instead.                   *//******************************************************************************
 *  Legacy BSD extensions to the C standard                                   *
 ******************************************************************************//* defined __MATH_LONG_DOUBLE_CONSTANTS *//*  Long-double versions of M_E, etc for convenience on Intel where long-
    double is not the same as double.  Define __MATH_LONG_DOUBLE_CONSTANTS
    to make these constants available.                                        *//* 1/sqrt(2)      *//* sqrt(2)        *//* 2/sqrt(pi)     *//* 2/pi           *//* 1/pi           *//* pi/4           *//* pi/2           *//* pi             *//* loge(10)       *//* loge(2)        *//* log10(e)       *//* log2(e)        *//* e              *//*  Even though these might be more useful as long doubles, POSIX requires
    that they be double-precision literals.                                   *//******************************************************************************
 *  POSIX/UNIX extensions to the C standard                                   *
 ******************************************************************************//*  Implementation details of __sincos and __sincospi allowing them to return
    two results while allowing the compiler to optimize away unnecessary load-
    store traffic.  Although these interfaces are exposed in the math.h header
    to allow compilers to generate better code, users should call __sincos[f]
    and __sincospi[f] instead and allow the compiler to emit these calls.     *//*  __sincospi(x,sinp,cosp) computes the sine and cosine of pi times x with a
    single function call, storing the sine in the memory pointed to by sinp,
    and the cosine in the memory pointed to by cosp.  Edge cases match those
    of separate calls to __sinpi( ) and __cospi( ), and are documented in the
    man pages.
 
    These functions were introduced in OSX 10.9 and iOS 7.0.  Because they are
    implemented as header inlines, weak-linking does not function as normal,
    and they are simply hidden when targeting earlier OS versions.            *//*  __sincos and __sincosf were introduced in OSX 10.9 and iOS 7.0.  When
    targeting an older system, we simply split them up into discrete calls
    to sin( ) and cos( ).                                                     *//*  __sinpi(x) returns the sine of pi times x; __cospi(x) and __tanpi(x) return
    the cosine and tangent, respectively.  These functions can produce a more
    accurate answer than expressions of the form sin(M_PI * x) because they
    avoid any loss of precision that results from rounding the result of the
    multiplication M_PI * x.  They may also be significantly more efficient in
    some cases because the argument reduction for these functions is easier
    to compute.  Consult the man pages for edge case details.                 *//*  __sincos(x,sinp,cosp) computes the sine and cosine of x with a single
    function call, storing the sine in the memory pointed to by sinp, and
    the cosine in the memory pointed to by cosp. Edge cases match those of
    separate calls to sin( ) and cos( ).                                      *//*  __exp10(x) returns 10**x.  Edge cases match those of exp( ) and exp2( ).  *//*  Because these functions are not specified by any relevant standard, they
    are prefixed with __, which places them in the implementor's namespace, so
    they should not conflict with any developer or third-party code.  If they
    are added to a relevant standard in the future, un-prefixed names may be
    added to the library and they may be moved out of this section of the
    header.                                                                   
 
    Because these functions are non-standard, they may not be available on non-
    Apple platforms.                                                          *//******************************************************************************
 *  Apple extensions to the C standard                                        *
 ******************************************************************************//* _REENTRANT *//*  Reentrant variants of the lgamma[fl] functions.                           *//******************************************************************************
 *  Reentrant variants of lgamma[fl]                                          *
 ******************************************************************************//* Deprecated functions; use the INFINITY and NAN macros instead.             *//* !(__DARWIN_NO_LONG_LONG) *//*  long long is not part of C90. Make sure you are passing -std=c99 or
    -std=gnu99 or higher if you need these functions returning long longs     *//*	lgammaf, lgamma, and lgammal are not thread-safe. The thread-safe
    variants lgammaf_r, lgamma_r, and lgammal_r are made available if
    you define the _REENTRANT symbol before including <math.h>                *//******************************************************************************
 *                                                                            *
 *                              Math Functions                                *
 *                                                                            *
 ******************************************************************************//* defined(__GNUC__) && 0 == __FINITE_MATH_ONLY__ *//*  Implementations making function calls to fall back on when -ffast-math
    or similar is specified.  These are not available in iOS versions prior
    to 6.0.  If you need them, you must target that version or later.         *//*  These inline functions may fail to return expected results if unsafe
    math optimizations like those enabled by -ffast-math are turned on.
    Thus, (somewhat surprisingly) you only get the fast inline
    implementations if such compiler options are NOT enabled.  This is
    because the inline functions require the compiler to be adhering to
    the standard in order to work properly; -ffast-math, among other
    things, implies that NaNs don't happen, which allows the compiler to
    optimize away checks like x != x, which might lead to things like
    isnan(NaN) returning false.                                               
 
    Thus, if you compile with -ffast-math, actual function calls are
    generated for these utilities.                                            *//******************************************************************************
 *                                                                            *
 *                              Inquiry macros                                *
 *                                                                            *
 *  fpclassify      Returns one of the FP_* values.                           *
 *  isnormal        Non-zero if and only if the argument x is normalized.     *
 *  isfinite        Non-zero if and only if the argument x is finite.         *
 *  isnan           Non-zero if and only if the argument x is a NaN.          *
 *  signbit         Non-zero if and only if the sign of the argument x is     *
 *                  negative.  This includes, NaNs, infinities and zeros.     *
 *                                                                            *
 ******************************************************************************//* Exceptions raised by math functions.  *//* errno set by math functions.  *//* Bitmasks for the math_errhandling macro.  *//* The values returned by `ilogb' for 0 and NaN respectively. *//*  On these architectures, fma( ), fmaf( ), and fmal( ) function calls are
    significantly more costly than separate multiply and add operations.      *//*  When targeting the FMA ISA extension, fma() and fmaf( ) are generally
    about as fast as (or faster than) separate multiply and add of the same
    operands, but fmal( ) may be more costly.                                 *//*  On these architectures, fma(), fmaf( ), and fmal( ) are generally about as
    fast as (or faster than) separate multiply and add of the same operands.  *//* legacy PowerPC support; this is otherwise unused *//******************************************************************************
 *      Taxonomy of floating point data types                                 *
 ******************************************************************************//* __FLT_EVAL_METHOD__ *//*  Define float_t and double_t per C standard, ISO/IEC 9899:2011 7.12 2,
    taking advantage of GCC's __FLT_EVAL_METHOD__ (which a compiler may
    define anytime and GCC does) that shadows FLT_EVAL_METHOD (which a
    compiler must define only in float.h).                                    *//******************************************************************************
 * Floating point data types                                                  *
 ******************************************************************************//*
 * Copyright (c) 2002-2017 Apple Inc. All rights reserved.
 *
 * @APPLE_LICENSE_HEADER_START@
 * 
 * The contents of this file constitute Original Code as defined in and
 * are subject to the Apple Public Source License Version 1.1 (the
 * "License").  You may not use this file except in compliance with the
 * License.  Please obtain a copy of the License at
 * http://www.apple.com/publicsource and read it before using this file.
 * 
 * This Original Code and all software distributed under the License are
 * distributed on an "AS IS" basis, WITHOUT WARRANTY OF ANY KIND, EITHER
 * EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES,
 * INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE OR NON-INFRINGEMENT.  Please see the
 * License for the specific language governing rights and limitations
 * under the License.
 * 
 * @APPLE_LICENSE_HEADER_END@
 */__sinp__cospdefined(__need_malloc_and_calloc)!defined(_LIBCPP_STDLIB_H)_LIBCPP_HAS_NO_LONG_LONG!defined(_LIBCPP_MSVCRT) && !defined(__sun__)!defined(__sun__)!defined(_LIBCPP_MSVCRT) && !defined(__sun__) && !defined(_LIBCPP_ON_RTKIT)// _LIBCPP_STDLIB_H// TODO: Remove this once DriverKit provides allocation functions in <stdlib.h>. rdar://84311130// _LIBCPP_MSVCRT / __sun__// _LIBCPP_HAS_NO_LONG_LONG// MSVCRT already has the correct prototype in <stdlib.h> if __cplusplus is defined// div// !defined(__sun__)// Use builtins to prevent needing math.h// !defined(_LIBCPP_MSVCRT) && !defined(__sun__)// abs/*
    stdlib.h synopsis

Macros:

    EXIT_FAILURE
    EXIT_SUCCESS
    MB_CUR_MAX
    NULL
    RAND_MAX

Types:

    size_t
    div_t
    ldiv_t
    lldiv_t                                                               // C99

double    atof (const char* nptr);
int       atoi (const char* nptr);
long      atol (const char* nptr);
long long atoll(const char* nptr);                                        // C99
double             strtod  (const char* restrict nptr, char** restrict endptr);
float              strtof  (const char* restrict nptr, char** restrict endptr); // C99
long double        strtold (const char* restrict nptr, char** restrict endptr); // C99
long               strtol  (const char* restrict nptr, char** restrict endptr, int base);
long long          strtoll (const char* restrict nptr, char** restrict endptr, int base); // C99
unsigned long      strtoul (const char* restrict nptr, char** restrict endptr, int base);
unsigned long long strtoull(const char* restrict nptr, char** restrict endptr, int base); // C99
int rand(void);
void srand(unsigned int seed);
void* calloc(size_t nmemb, size_t size);
void free(void* ptr);
void* malloc(size_t size);
void* realloc(void* ptr, size_t size);
void abort(void);
int atexit(void (*func)(void));
void exit(int status);
void _Exit(int status);
char* getenv(const char* name);
int system(const char* string);
void* bsearch(const void* key, const void* base, size_t nmemb, size_t size,
              int (*compar)(const void *, const void *));
void qsort(void* base, size_t nmemb, size_t size,
           int (*compar)(const void *, const void *));
int         abs(      int j);
long        abs(     long j);
long long   abs(long long j);                                             // C++0X
long       labs(     long j);
long long llabs(long long j);                                             // C99
div_t     div(      int numer,       int denom);
ldiv_t    div(     long numer,      long denom);
lldiv_t   div(long long numer, long long denom);                          // C++0X
ldiv_t   ldiv(     long numer,      long denom);
lldiv_t lldiv(long long numer, long long denom);                          // C99
int mblen(const char* s, size_t n);
int mbtowc(wchar_t* restrict pwc, const char* restrict s, size_t n);
int wctomb(char* s, wchar_t wchar);
size_t mbstowcs(wchar_t* restrict pwcs, const char* restrict s, size_t n);
size_t wcstombs(char* restrict s, const wchar_t* restrict pwcs, size_t n);
int at_quick_exit(void (*func)(void))                                     // C++11
void quick_exit(int status);                                              // C++11
void *aligned_alloc(size_t alignment, size_t size);                       // C11

*///===--------------------------- stdlib.h ---------------------------------===//<math.h>__libcpp_copysign__builtin_copysignl__builtin_copysign__builtin_copysignfisunordered__libcpp_isunorderedislessgreater__libcpp_islessgreaterislessequal__libcpp_islessequalisless__libcpp_islessisgreaterequal__libcpp_isgreaterequalisgreater__libcpp_isgreaterisnormal__libcpp_isnormalisnan__builtin_isnan__libcpp_isnanisinf__builtin_isinf__libcpp_isinfisfinite__libcpp_isfinitefpclassify__libcpp_fpclassifysignbit__libcpp_signbit__builtin_trunc__builtin_truncl__builtin_round__builtin_roundl__builtin_rintf__builtin_rintl__builtin_lroundf__builtin_lroundl__builtin_lrintf__builtin_lrintl__builtin_llroundf__builtin_llroundl__builtin_llrintf__builtin_llrintl__builtin_fmaf__builtin_fmal__lcpp_x__lcpp_y__lcpp_z_LIBCPP_MATH_H__has_builtin(__builtin_signbit)__has_builtin(__builtin_fpclassify)__has_builtin(__builtin_isfinite)__has_builtin(__builtin_isinf)__has_builtin(__builtin_isnan)__has_builtin(__builtin_isnormal)!(defined(_AIX) || defined(__sun__))__has_builtin(__builtin_copysignf)__has_builtin(__builtin_copysign)__has_builtin(__builtin_copysignl)__has_builtin(__builtin_fmaf)__has_builtin(__builtin_fmal)__has_builtin(__builtin_fma)__has_builtin(__builtin_llrintf)__has_builtin(__builtin_llrintl)__has_builtin(__builtin_llrint)__has_builtin(__builtin_llroundf)__has_builtin(__builtin_llroundl)__has_builtin(__builtin_llround)__has_builtin(__builtin_lrintf)__has_builtin(__builtin_lrintl)__has_builtin(__builtin_lrint)__has_builtin(__builtin_lroundf)__has_builtin(__builtin_lroundl)__has_builtin(__builtin_lround)__has_builtin(__builtin_rintf)__has_builtin(__builtin_rintl)__has_builtin(__builtin_rint)__has_builtin(__builtin_round)__has_builtin(__builtin_roundl)__has_builtin(__builtin_trunc)__has_builtin(__builtin_truncl)defined(_LIBCPP_MSVCRT) && defined(_USE_MATH_DEFINES)(!(std::_IsSame<_A1, __result_type>::value && std::_IsSame<_A2, __result_type>::value)), ""(!(std::_IsSame<_A1, __result_type>::value && std::_IsSame<_A2, __result_type>::value && std::_IsSame<_A3, __result_type>::value)), ""// _LIBCPP_MATH_H// has previously been included.// and receive the definitions of mathematical constants, even if <math.h>// #include <math.h>// #define _USE_MATH_DEFINES// extension which allows users to do:// This include lives outside the header guard in order to support an MSVC// trunc// tgamma// scalbn// scalbln// round// rint// remquo// remainder// nexttoward// nextafter// nearbyint// nan// lround// lrint// logb// log2// log1p// llround// llrint// lgamma// ilogb// hypot// fmin// fmax// fma// fdim// expm1// exp2// erfc// erf// copysign// cbrt// atanh// asinh// acosh// tanh// tan// sqrt// sinh// sin// pow// modf// log10// log// ldexp// frexp// fmod// floor// fabs// exp// cosh// cos// ceil// atan2// atan// asin// acos// handled in stdlib.h// isunordered// islessgreater// islessequal// isless// isgreaterequal// isgreater// isnormal// isnan// isinf// isfinite// fpclassify// signbit// back to C++ linkage before including these C++ headers.// We support including .h headers inside 'extern "C"' contexts, so switch/*
    math.h synopsis

Macros:

    HUGE_VAL
    HUGE_VALF               // C99
    HUGE_VALL               // C99
    INFINITY                // C99
    NAN                     // C99
    FP_INFINITE             // C99
    FP_NAN                  // C99
    FP_NORMAL               // C99
    FP_SUBNORMAL            // C99
    FP_ZERO                 // C99
    FP_FAST_FMA             // C99
    FP_FAST_FMAF            // C99
    FP_FAST_FMAL            // C99
    FP_ILOGB0               // C99
    FP_ILOGBNAN             // C99
    MATH_ERRNO              // C99
    MATH_ERREXCEPT          // C99
    math_errhandling        // C99

Types:

    float_t                 // C99
    double_t                // C99

// C90

floating_point abs(floating_point x);

floating_point acos (arithmetic x);
float          acosf(float x);
long double    acosl(long double x);

floating_point asin (arithmetic x);
float          asinf(float x);
long double    asinl(long double x);

floating_point atan (arithmetic x);
float          atanf(float x);
long double    atanl(long double x);

floating_point atan2 (arithmetic y, arithmetic x);
float          atan2f(float y, float x);
long double    atan2l(long double y, long double x);

floating_point ceil (arithmetic x);
float          ceilf(float x);
long double    ceill(long double x);

floating_point cos (arithmetic x);
float          cosf(float x);
long double    cosl(long double x);

floating_point cosh (arithmetic x);
float          coshf(float x);
long double    coshl(long double x);

floating_point exp (arithmetic x);
float          expf(float x);
long double    expl(long double x);

floating_point fabs (arithmetic x);
float          fabsf(float x);
long double    fabsl(long double x);

floating_point floor (arithmetic x);
float          floorf(float x);
long double    floorl(long double x);

floating_point fmod (arithmetic x, arithmetic y);
float          fmodf(float x, float y);
long double    fmodl(long double x, long double y);

floating_point frexp (arithmetic value, int* exp);
float          frexpf(float value, int* exp);
long double    frexpl(long double value, int* exp);

floating_point ldexp (arithmetic value, int exp);
float          ldexpf(float value, int exp);
long double    ldexpl(long double value, int exp);

floating_point log (arithmetic x);
float          logf(float x);
long double    logl(long double x);

floating_point log10 (arithmetic x);
float          log10f(float x);
long double    log10l(long double x);

floating_point modf (floating_point value, floating_point* iptr);
float          modff(float value, float* iptr);
long double    modfl(long double value, long double* iptr);

floating_point pow (arithmetic x, arithmetic y);
float          powf(float x, float y);
long double    powl(long double x, long double y);

floating_point sin (arithmetic x);
float          sinf(float x);
long double    sinl(long double x);

floating_point sinh (arithmetic x);
float          sinhf(float x);
long double    sinhl(long double x);

floating_point sqrt (arithmetic x);
float          sqrtf(float x);
long double    sqrtl(long double x);

floating_point tan (arithmetic x);
float          tanf(float x);
long double    tanl(long double x);

floating_point tanh (arithmetic x);
float          tanhf(float x);
long double    tanhl(long double x);

//  C99

bool signbit(arithmetic x);

int fpclassify(arithmetic x);

bool isfinite(arithmetic x);
bool isinf(arithmetic x);
bool isnan(arithmetic x);
bool isnormal(arithmetic x);

bool isgreater(arithmetic x, arithmetic y);
bool isgreaterequal(arithmetic x, arithmetic y);
bool isless(arithmetic x, arithmetic y);
bool islessequal(arithmetic x, arithmetic y);
bool islessgreater(arithmetic x, arithmetic y);
bool isunordered(arithmetic x, arithmetic y);

floating_point acosh (arithmetic x);
float          acoshf(float x);
long double    acoshl(long double x);

floating_point asinh (arithmetic x);
float          asinhf(float x);
long double    asinhl(long double x);

floating_point atanh (arithmetic x);
float          atanhf(float x);
long double    atanhl(long double x);

floating_point cbrt (arithmetic x);
float          cbrtf(float x);
long double    cbrtl(long double x);

floating_point copysign (arithmetic x, arithmetic y);
float          copysignf(float x, float y);
long double    copysignl(long double x, long double y);

floating_point erf (arithmetic x);
float          erff(float x);
long double    erfl(long double x);

floating_point erfc (arithmetic x);
float          erfcf(float x);
long double    erfcl(long double x);

floating_point exp2 (arithmetic x);
float          exp2f(float x);
long double    exp2l(long double x);

floating_point expm1 (arithmetic x);
float          expm1f(float x);
long double    expm1l(long double x);

floating_point fdim (arithmetic x, arithmetic y);
float          fdimf(float x, float y);
long double    fdiml(long double x, long double y);

floating_point fma (arithmetic x, arithmetic y, arithmetic z);
float          fmaf(float x, float y, float z);
long double    fmal(long double x, long double y, long double z);

floating_point fmax (arithmetic x, arithmetic y);
float          fmaxf(float x, float y);
long double    fmaxl(long double x, long double y);

floating_point fmin (arithmetic x, arithmetic y);
float          fminf(float x, float y);
long double    fminl(long double x, long double y);

floating_point hypot (arithmetic x, arithmetic y);
float          hypotf(float x, float y);
long double    hypotl(long double x, long double y);

int ilogb (arithmetic x);
int ilogbf(float x);
int ilogbl(long double x);

floating_point lgamma (arithmetic x);
float          lgammaf(float x);
long double    lgammal(long double x);

long long llrint (arithmetic x);
long long llrintf(float x);
long long llrintl(long double x);

long long llround (arithmetic x);
long long llroundf(float x);
long long llroundl(long double x);

floating_point log1p (arithmetic x);
float          log1pf(float x);
long double    log1pl(long double x);

floating_point log2 (arithmetic x);
float          log2f(float x);
long double    log2l(long double x);

floating_point logb (arithmetic x);
float          logbf(float x);
long double    logbl(long double x);

long lrint (arithmetic x);
long lrintf(float x);
long lrintl(long double x);

long lround (arithmetic x);
long lroundf(float x);
long lroundl(long double x);

double      nan (const char* str);
float       nanf(const char* str);
long double nanl(const char* str);

floating_point nearbyint (arithmetic x);
float          nearbyintf(float x);
long double    nearbyintl(long double x);

floating_point nextafter (arithmetic x, arithmetic y);
float          nextafterf(float x, float y);
long double    nextafterl(long double x, long double y);

floating_point nexttoward (arithmetic x, long double y);
float          nexttowardf(float x, long double y);
long double    nexttowardl(long double x, long double y);

floating_point remainder (arithmetic x, arithmetic y);
float          remainderf(float x, float y);
long double    remainderl(long double x, long double y);

floating_point remquo (arithmetic x, arithmetic y, int* pquo);
float          remquof(float x, float y, int* pquo);
long double    remquol(long double x, long double y, int* pquo);

floating_point rint (arithmetic x);
float          rintf(float x);
long double    rintl(long double x);

floating_point round (arithmetic x);
float          roundf(float x);
long double    roundl(long double x);

floating_point scalbln (arithmetic x, long ex);
float          scalblnf(float x, long ex);
long double    scalblnl(long double x, long ex);

floating_point scalbn (arithmetic x, int ex);
float          scalbnf(float x, int ex);
long double    scalbnl(long double x, int ex);

floating_point tgamma (arithmetic x);
float          tgammaf(float x);
long double    tgammal(long double x);

floating_point trunc (arithmetic x);
float          truncf(float x);
long double    truncl(long double x);

*///===---------------------------- math.h ----------------------------------===//__lcpp_e_IntT__clamp_to_integral_RealT__max_representable_int_for_float_FloatT_FloatBigger_Bits__libcpp_isfinite_or_builtin__libcpp_isinf_or_builtin__libcpp_isnan_or_builtin_LIBCPP_CMATH(_IsSame<_FloatT, float>::value || _IsSame<_FloatT, double>::value || _IsSame<_FloatT,long double>::value), "unsupported floating point type"numeric_limits<_FloatT>::radix == 2, "FloatT has incorrect radix"is_integral<_IntT>::value, "must be an integral type"is_floating_point<_FloatT>::value, "must be a floating point type"// _LIBCPP_CMATH// The behavior is undefined if `__r` is NaN.// clamping to the integral types representable range.// Convert a floating point number to the specified integral type after/*
    cmath synopsis

Macros:

    HUGE_VAL
    HUGE_VALF               // C99
    HUGE_VALL               // C99
    INFINITY                // C99
    NAN                     // C99
    FP_INFINITE             // C99
    FP_NAN                  // C99
    FP_NORMAL               // C99
    FP_SUBNORMAL            // C99
    FP_ZERO                 // C99
    FP_FAST_FMA             // C99
    FP_FAST_FMAF            // C99
    FP_FAST_FMAL            // C99
    FP_ILOGB0               // C99
    FP_ILOGBNAN             // C99
    MATH_ERRNO              // C99
    MATH_ERREXCEPT          // C99
    math_errhandling        // C99

namespace std
{

Types:

    float_t                 // C99
    double_t                // C99

// C90

floating_point abs(floating_point x);

floating_point acos (arithmetic x);
float          acosf(float x);
long double    acosl(long double x);

floating_point asin (arithmetic x);
float          asinf(float x);
long double    asinl(long double x);

floating_point atan (arithmetic x);
float          atanf(float x);
long double    atanl(long double x);

floating_point atan2 (arithmetic y, arithmetic x);
float          atan2f(float y, float x);
long double    atan2l(long double y, long double x);

floating_point ceil (arithmetic x);
float          ceilf(float x);
long double    ceill(long double x);

floating_point cos (arithmetic x);
float          cosf(float x);
long double    cosl(long double x);

floating_point cosh (arithmetic x);
float          coshf(float x);
long double    coshl(long double x);

floating_point exp (arithmetic x);
float          expf(float x);
long double    expl(long double x);

floating_point fabs (arithmetic x);
float          fabsf(float x);
long double    fabsl(long double x);

floating_point floor (arithmetic x);
float          floorf(float x);
long double    floorl(long double x);

floating_point fmod (arithmetic x, arithmetic y);
float          fmodf(float x, float y);
long double    fmodl(long double x, long double y);

floating_point frexp (arithmetic value, int* exp);
float          frexpf(float value, int* exp);
long double    frexpl(long double value, int* exp);

floating_point ldexp (arithmetic value, int exp);
float          ldexpf(float value, int exp);
long double    ldexpl(long double value, int exp);

floating_point log (arithmetic x);
float          logf(float x);
long double    logl(long double x);

floating_point log10 (arithmetic x);
float          log10f(float x);
long double    log10l(long double x);

floating_point modf (floating_point value, floating_point* iptr);
float          modff(float value, float* iptr);
long double    modfl(long double value, long double* iptr);

floating_point pow (arithmetic x, arithmetic y);
float          powf(float x, float y);
long double    powl(long double x, long double y);

floating_point sin (arithmetic x);
float          sinf(float x);
long double    sinl(long double x);

floating_point sinh (arithmetic x);
float          sinhf(float x);
long double    sinhl(long double x);

floating_point sqrt (arithmetic x);
float          sqrtf(float x);
long double    sqrtl(long double x);

floating_point tan (arithmetic x);
float          tanf(float x);
long double    tanl(long double x);

floating_point tanh (arithmetic x);
float          tanhf(float x);
long double    tanhl(long double x);

//  C99

bool signbit(arithmetic x);

int fpclassify(arithmetic x);

bool isfinite(arithmetic x);
bool isinf(arithmetic x);
bool isnan(arithmetic x);
bool isnormal(arithmetic x);

bool isgreater(arithmetic x, arithmetic y);
bool isgreaterequal(arithmetic x, arithmetic y);
bool isless(arithmetic x, arithmetic y);
bool islessequal(arithmetic x, arithmetic y);
bool islessgreater(arithmetic x, arithmetic y);
bool isunordered(arithmetic x, arithmetic y);

floating_point acosh (arithmetic x);
float          acoshf(float x);
long double    acoshl(long double x);

floating_point asinh (arithmetic x);
float          asinhf(float x);
long double    asinhl(long double x);

floating_point atanh (arithmetic x);
float          atanhf(float x);
long double    atanhl(long double x);

floating_point cbrt (arithmetic x);
float          cbrtf(float x);
long double    cbrtl(long double x);

floating_point copysign (arithmetic x, arithmetic y);
float          copysignf(float x, float y);
long double    copysignl(long double x, long double y);

floating_point erf (arithmetic x);
float          erff(float x);
long double    erfl(long double x);

floating_point erfc (arithmetic x);
float          erfcf(float x);
long double    erfcl(long double x);

floating_point exp2 (arithmetic x);
float          exp2f(float x);
long double    exp2l(long double x);

floating_point expm1 (arithmetic x);
float          expm1f(float x);
long double    expm1l(long double x);

floating_point fdim (arithmetic x, arithmetic y);
float          fdimf(float x, float y);
long double    fdiml(long double x, long double y);

floating_point fma (arithmetic x, arithmetic y, arithmetic z);
float          fmaf(float x, float y, float z);
long double    fmal(long double x, long double y, long double z);

floating_point fmax (arithmetic x, arithmetic y);
float          fmaxf(float x, float y);
long double    fmaxl(long double x, long double y);

floating_point fmin (arithmetic x, arithmetic y);
float          fminf(float x, float y);
long double    fminl(long double x, long double y);

floating_point hypot (arithmetic x, arithmetic y);
float          hypotf(float x, float y);
long double    hypotl(long double x, long double y);

double       hypot(double x, double y, double z);                // C++17
float        hypot(float x, float y, float z);                   // C++17
long double  hypot(long double x, long double y, long double z); // C++17

int ilogb (arithmetic x);
int ilogbf(float x);
int ilogbl(long double x);

floating_point lgamma (arithmetic x);
float          lgammaf(float x);
long double    lgammal(long double x);

long long llrint (arithmetic x);
long long llrintf(float x);
long long llrintl(long double x);

long long llround (arithmetic x);
long long llroundf(float x);
long long llroundl(long double x);

floating_point log1p (arithmetic x);
float          log1pf(float x);
long double    log1pl(long double x);

floating_point log2 (arithmetic x);
float          log2f(float x);
long double    log2l(long double x);

floating_point logb (arithmetic x);
float          logbf(float x);
long double    logbl(long double x);

long lrint (arithmetic x);
long lrintf(float x);
long lrintl(long double x);

long lround (arithmetic x);
long lroundf(float x);
long lroundl(long double x);

double      nan (const char* str);
float       nanf(const char* str);
long double nanl(const char* str);

floating_point nearbyint (arithmetic x);
float          nearbyintf(float x);
long double    nearbyintl(long double x);

floating_point nextafter (arithmetic x, arithmetic y);
float          nextafterf(float x, float y);
long double    nextafterl(long double x, long double y);

floating_point nexttoward (arithmetic x, long double y);
float          nexttowardf(float x, long double y);
long double    nexttowardl(long double x, long double y);

floating_point remainder (arithmetic x, arithmetic y);
float          remainderf(float x, float y);
long double    remainderl(long double x, long double y);

floating_point remquo (arithmetic x, arithmetic y, int* pquo);
float          remquof(float x, float y, int* pquo);
long double    remquol(long double x, long double y, int* pquo);

floating_point rint (arithmetic x);
float          rintf(float x);
long double    rintl(long double x);

floating_point round (arithmetic x);
float          roundf(float x);
long double    roundl(long double x);

floating_point scalbln (arithmetic x, long ex);
float          scalblnf(float x, long ex);
long double    scalblnl(long double x, long ex);

floating_point scalbn (arithmetic x, int ex);
float          scalbnf(float x, int ex);
long double    scalbnl(long double x, int ex);

floating_point tgamma (arithmetic x);
float          tgammaf(float x);
long double    tgammal(long double x);

floating_point trunc (arithmetic x);
float          truncf(float x);
long double    truncl(long double x);

constexpr float       lerp(float a, float b, float t) noexcept;                   // C++20
constexpr double      lerp(double a, double b, double t) noexcept;                // C++20
constexpr long double lerp(long double a, long double b, long double t) noexcept; // C++20

}  // std

*///===---------------------------- cmath -----------------------------------===///Users/owura/Repos/codeql_eval/proj_repos/Exiv2-exiv2-pull-962-commits-e925bc5addd881543fa503470c8a859e112cca62/exiv2/src/canonmn_int.cpp"canonmn_int.hpp""makernote_int.hpp"frac0x1f0x0c12.032.032.0f10.6666669832.0f / 30x1420.064.064.0f21.3333339764.0f / 3printCsLensByFocalLengthTCltflLensTypeAndFocalLengthAndMaxApertureLensTypeAndFocalLengthAndMaxAperture *LensTypeAndFocalLengthAndMaxAperture &1.0const TagDetails[360]TagDetails[360]const TagDetails(&)[360]TagDetails(&)[360]const LensTypeAndFocalLengthAndMaxApertureconst LensTypeAndFocalLengthAndMaxAperture &1.3999999999999999111.4~LensTypeAndFocalLengthAndMaxApertureprintCsLensByFocalLengthprintCsLensByFocalLengthAndMaxApertureExif.CanonCs.MaxAperture"Exif.CanonCs.MaxAperture"ossconvertFocalLength"mm"extractLensFocalLengthExif.CanonCs.Lens"Exif.CanonCs.Lens"fuprintCsLensFFFFitModelitLensitApertCanon EOS 30D"Canon EOS 30D"24 24 1"24 24 1""95"Canon EF-S 24mm f/2.8 STM"Canon EF-S 24mm f/2.8 STM"exception &canonCsLensTypedivisorbasic_ios<char, char_traits<char>> &const basic_ios<char, char_traits<char>> &0xffffInfinite"Infinite" m" m"ur s" s"F"F"614400xf000 focus points; " focus points; "used40950x0fffcanonSiAFPointUsed"none" used" used"0.5len1len2 mm" mm" - " - ""undefined"const LensIdFctconst LensIdFct *LensIdFct *lifconst LensIdFct[49]LensIdFct[49]const LensIdFct(&)[49]LensIdFct(&)[49]Off"Off"uint32_t &42949017600xffff000020D"20D"350D"350D"REBEL XT"REBEL XT"Kiss Digital N"Kiss Digital N"dn654720xffc0fn0x3f30D"30D"400D"400D"REBEL XTi"REBEL XTi"Kiss Digital X"Kiss Digital X"K236"K236"10475520xffc0010230x3ff0x0fconst TagInfo[14]TagInfo[14]const TagInfo[18]TagInfo[18]const TagInfo[4]TagInfo[4]const TagInfo[7]TagInfo[7]const TagInfo[16]TagInfo[16]const TagInfo[3]TagInfo[3]const TagInfo[27]TagInfo[27]const TagInfo[44]TagInfo[44]const TagInfo[36]TagInfo[36]LensIdFct &const LensIdFct &LensIdFctfct_maxAperture_focalLength_focalLengthMax_focalLengthMin_lensType_"n/a""Chatham Islands""Wellington""Solomon Islands""Sydney""Adelaide""Tokyo""Hong Kong""Bangkok""Yangon""Dhaka""Kathmandu""Delhi""Karachi""Kabul""Dubai""Tehran""Moscow""Cairo""Paris""London""Azores""Fernando de Noronha""Sao Paulo""Newfoundland""Santiago""Caracas""New York""Chicago""Denver""Los Angeles""Anchorage""Honolulu""Samoa""(not set)"const TagDetails[35]TagDetails[35]n/aChatham IslandsWellingtonSolomon IslandsSydney0x0005Adelaide0x0006Tokyo0x0007Hong KongBangkok0x0009Yangon0x000aDhaka0x000bKathmandu0x000cDelhi0x000dKarachi0x000eKabul0x000fDubaiTehran0x0011Moscow0x0012Cairo0x0013Paris0x0014London0x0015Azores0x0016Fernando de Noronha0x0017Sao Paulo0x0018Newfoundland0x0019Santiago0x001aCaracas0x001bNew York0x001cChicago0x001dDenver0x001eLos Angeles0x001fAnchorageHonolulu0x0021Samoa327660x7ffe(not set)canonTimeZoneCity"Standard""Portrait""High Saturation""Adobe RGB""Low Saturation""CM Set 1""CM Set 2""User Def. 1""User Def. 2""User Def. 3""PC 1""PC 2""PC 3""Landscape""Neutral""Faithful""Monochrome""Auto""Fine Detail"const TagDetails[22]TagDetails[22]StandardPortrait0x03High SaturationAdobe RGB0x05Low Saturation0x06CM Set 10x07CM Set 20x21User Def. 10x22User Def. 20x23User Def. 30x41PC 10x42PC 20x43PC 30x810x820x83Landscape0x84Neutral0x85Faithful0x86Monochrome0x87Auto0x88Fine DetailcanonPictureStyle"Lowest""Low""High""Highest"const TagDetails[6]TagDetails[6]LowestLowHighHighestcanonSharpnessFrequency"Manual""Custom"const TagDetails[3]TagDetails[3]ManualCustomcanonToneCurve"Sepia""Blue""Purple""Green"const TagDetails[5]TagDetails[5]SepiaBluePurpleGreencanonToningEffect"Yellow""Orange""Red"YellowOrangeRedcanonFilterEffect"On (shift AB)""On (shift GM)"On (shift AB)On (shift GM)canonWBBracketMode"On 1""On 2""On"On 1On 2OncanonNoiseReduction"Large""Medium""Small""Medium 1""Medium 2""Medium 3""Postcard""Widescreen""Medium Widescreen""Small 1""Small 2""Small 3""640x480 Movie""Medium Movie""Small Movie""1280x720 Movie""1920x1080 Movie"const TagDetails[17]TagDetails[17]LargeMediumSmallMedium 1Medium 2Medium 3PostcardWidescreenMedium WidescreenSmall 1Small 2Small 3640x480 MovieMedium MovieSmall Movie1280x720 Movie1920x1080 MoviecanonRawJpgSize"AEB""FEB""ISO""WB"AEBFEBISOWBcanonBracketMode"top""upper-left""upper-right""left""center""right""lower-left""lower-right""bottom"const TagDetailsBitmask[9]TagDetailsBitmask[9]0x0010x002upper-left0x004upper-right0x0080x010center0x0200x040lower-left0x080lower-rightbottomcanonPiAFPointsUsed20D"mid-right""mid-left"const TagDetailsBitmask[7]TagDetailsBitmask[7]mid-rightmid-leftcanonPiAFPointsUsed"Left to right""Right to left""Bottom to top""Top to bottom""2x2 matrix (Clockwise)"Left to rightRight to leftBottom to topTop to bottom2x2 matrix (Clockwise)canonPaDirection-2 EV"-2 EV"654840xffcc-1.67 EV"-1.67 EV"654880xffd0-1.50 EV"-1.50 EV"654920xffd4-1.33 EV"-1.33 EV"655040xffe0-1 EV"-1 EV"655160xffec-0.67 EV"-0.67 EV"655200xfff0-0.50 EV"-0.50 EV"655240xfff4-0.33 EV"-0.33 EV"0 EV"0 EV"0.33 EV"0.33 EV"0.50 EV"0.50 EV"0.67 EV"0.67 EV"1 EV"1 EV"0x002c1.33 EV"1.33 EV"0x00301.50 EV"1.50 EV"0x00341.67 EV"1.67 EV"2 EV"2 EV"canonSiFlashBiasconst TagDetailsBitmask[3]TagDetailsBitmask[3]"Daylight""Cloudy""Tungsten""Fluorescent""Black & White""Shade""Manual Temperature (Kelvin)""PC Set 1""PC Set 2""PC Set 3""Daylight Fluorescent""Custom 1""Custom 2""Underwater""Custom 3""PC Set 4""PC Set 5""Auto (ambience priority)"DaylightCloudyTungstenFluorescentBlack & WhiteShadeManual Temperature (Kelvin)PC Set 1PC Set 2PC Set 3Daylight FluorescentCustom 1Custom 2UnderwaterCustom 3PC Set 4PC Set 5Auto (ambience priority)canonSiWhiteBalance"sRAW1 (mRAW)""sRAW2 (sRAW)"sRAW1 (mRAW)sRAW2 (sRAW)canonCsSRAWQuality"Full"0x0500Full12820x050212840x05040x7fffcanonCsManualFlashOutput"Vivid""Smooth""B&W""My color data"const TagDetails[9]TagDetails[9]VividSmoothB&WMy color datacanonCsPhotoEffect"Center""AF Point"const TagDetails[2]TagDetails[2]CenterAF PointcanonCsSpotMeteringMode"Shoot Only""Panning""Dynamic""Off (2)""On (2)""Shoot Only (2)""Panning (2)""Dynamic (2)"const TagDetails[10]TagDetails[10]Shoot OnlyPanningDynamicOff (2)On (2)Shoot Only (2)Panning (2)Dynamic (2)canonCsImageStabilization"Normal AE""Exposure compensation""AE lock""AE lock + exposure compensation""No AE"Normal AEExposure compensationAE lockAE lock + exposure compensationNo AEcanonCsAESetting"Single""Continuous"SingleContinuouscanonCsFocusContinuous"External flash""Internal flash""TTL""A-TTL""E-TTL""FP sync enabled""2nd-curtain sync used""FP sync used"External flashInternal flashTTLA-TTLE-TTLFP sync enabled2nd-curtain sync usedFP sync usedcanonCsFlashDetails"Did not fire""Fired"Did not fireFiredcanonCsFlashActivityconst LensIdFct[]LensIdFct[]41434154lensIdFctCanon EF 50mm f/1.8"Canon EF 50mm f/1.8"Canon EF 28mm f/2.8"Canon EF 28mm f/2.8"Canon EF 135mm f/2.8 Soft"Canon EF 135mm f/2.8 Soft"Canon EF 35-105mm f/3.5-4.5"Canon EF 35-105mm f/3.5-4.5"Sigma UC Zoom 35-135mm f/4-5.6"Sigma UC Zoom 35-135mm f/4-5.6"Canon EF 35-70mm f/3.5-4.5"Canon EF 35-70mm f/3.5-4.5"Canon EF 28-70mm f/3.5-4.5"Canon EF 28-70mm f/3.5-4.5"Sigma 18-50mm f/3.5-5.6 DC"Sigma 18-50mm f/3.5-5.6 DC"Sigma 18-125mm f/3.5-5.6 DC IF ASP"Sigma 18-125mm f/3.5-5.6 DC IF ASP"Tokina AF193-2 19-35mm f/3.5-4.5"Tokina AF193-2 19-35mm f/3.5-4.5"Sigma 28-80mm f/3.5-5.6 II Macro"Sigma 28-80mm f/3.5-5.6 II Macro"Canon EF 100-300mm f/5.6L"Canon EF 100-300mm f/5.6L"Canon EF 100-300mm f/5.6"Canon EF 100-300mm f/5.6"Sigma 70-300mm f/4-5.6 [APO] DG Macro"Sigma 70-300mm f/4-5.6 [APO] DG Macro"Tokina AT-X 242 AF 24-200mm f/3.5-5.6"Tokina AT-X 242 AF 24-200mm f/3.5-5.6"Canon EF 70-210mm f/4"Canon EF 70-210mm f/4"Sigma 55-200mm f/4-5.6 DC"Sigma 55-200mm f/4-5.6 DC"Canon EF 50mm f/2.5 Macro"Canon EF 50mm f/2.5 Macro"Sigma 50mm f/2.8 EX"Sigma 50mm f/2.8 EX"Sigma 28mm f/1.8"Sigma 28mm f/1.8"Sigma 105mm f/2.8 Macro EX"Sigma 105mm f/2.8 Macro EX"Sigma 70mm f/2.8 EX DG Macro EF"Sigma 70mm f/2.8 EX DG Macro EF"Canon EF 35mm f/2"Canon EF 35mm f/2"Canon EF 15mm f/2.8 Fisheye"Canon EF 15mm f/2.8 Fisheye"Canon EF 50-200mm f/3.5-4.5L"Canon EF 50-200mm f/3.5-4.5L"Canon EF 50-200mm f/3.5-4.5"Canon EF 50-200mm f/3.5-4.5"Canon EF 35-135mm f/3.5-4.5"Canon EF 35-135mm f/3.5-4.5"Canon EF 35-70mm f/3.5-4.5A"Canon EF 35-70mm f/3.5-4.5A"Canon EF 100-200mm f/4.5A"Canon EF 100-200mm f/4.5A"Canon EF 80-200mm f/2.8L"Canon EF 80-200mm f/2.8L"Canon EF 20-35mm f/2.8L"Canon EF 20-35mm f/2.8L"Tokina AT-X 280 AF PRO 28-80mm f/2.8 Aspherical"Tokina AT-X 280 AF PRO 28-80mm f/2.8 Aspherical"Canon EF 35-80mm f/4-5.6 Power Zoom"Canon EF 35-80mm f/4-5.6 Power Zoom"Canon EF 100mm f/2.8 Macro"Canon EF 100mm f/2.8 Macro"Cosina 100mm f/3.5 Macro AF"Cosina 100mm f/3.5 Macro AF"Tamron SP AF 90mm f/2.8 Di Macro"Tamron SP AF 90mm f/2.8 Di Macro"Tamron SP AF 180mm f/3.5 Di Macro"Tamron SP AF 180mm f/3.5 Di Macro"Carl Zeiss Planar T* 50mm f/1.4"Carl Zeiss Planar T* 50mm f/1.4"Canon EF 35-80mm f/4-5.6"Canon EF 35-80mm f/4-5.6"Canon EF 80-200mm f/4.5-5.6"Canon EF 80-200mm f/4.5-5.6"Tamron SP AF 28-105mm f/2.8 LD Aspherical IF"Tamron SP AF 28-105mm f/2.8 LD Aspherical IF"Tamron SP AF 28-75mm f/2.8 XR Di LD Aspherical [IF] Macro"Tamron SP AF 28-75mm f/2.8 XR Di LD Aspherical [IF] Macro"Tamron AF 70-300mm f/4-5.6 Di LD 1:2 Macro"Tamron AF 70-300mm f/4-5.6 Di LD 1:2 Macro"Tamron AF Aspherical 28-200mm f/3.8-5.6"Tamron AF Aspherical 28-200mm f/3.8-5.6"Canon EF 50mm f/1.8 II"Canon EF 50mm f/1.8 II"Canon EF 35-105mm f/4.5-5.6"Canon EF 35-105mm f/4.5-5.6"Canon EF 75-300mm f/4-5.6"Canon EF 75-300mm f/4-5.6"Tamron SP AF 300mm f/2.8 LD IF"Tamron SP AF 300mm f/2.8 LD IF"Canon EF 24mm f/2.8"Canon EF 24mm f/2.8"Sigma 15mm f/2.8 EX Fisheye"Sigma 15mm f/2.8 EX Fisheye"Voigtlander or Carl Zeiss Lens"Voigtlander or Carl Zeiss Lens"Voigtlander Ultron 40mm f/2 SLII Aspherical"Voigtlander Ultron 40mm f/2 SLII Aspherical"Voigtlander Color Skopar 20mm f/3.5 SLII Aspherical"Voigtlander Color Skopar 20mm f/3.5 SLII Aspherical"Voigtlander APO-Lanthar 90mm f/3.5 SLII Close Focus"Voigtlander APO-Lanthar 90mm f/3.5 SLII Close Focus"Carl Zeiss Distagon 15mm T* f/2.8 ZE"Carl Zeiss Distagon 15mm T* f/2.8 ZE"Carl Zeiss Distagon 18mm T* f/3.5 ZE"Carl Zeiss Distagon 18mm T* f/3.5 ZE"Carl Zeiss Distagon 21mm T* f/2.8 ZE"Carl Zeiss Distagon 21mm T* f/2.8 ZE"Carl Zeiss Distagon 25mm T* f/2 ZE"Carl Zeiss Distagon 25mm T* f/2 ZE"Carl Zeiss Distagon 28mm T* f/2 ZE"Carl Zeiss Distagon 28mm T* f/2 ZE"Carl Zeiss Distagon 35mm T* f/2 ZE"Carl Zeiss Distagon 35mm T* f/2 ZE"Carl Zeiss Distagon 35mm T* f/1.4 ZE"Carl Zeiss Distagon 35mm T* f/1.4 ZE"Carl Zeiss Planar 50mm T* f/1.4 ZE"Carl Zeiss Planar 50mm T* f/1.4 ZE"Carl Zeiss Makro-Planar T* 50mm f/2 ZE"Carl Zeiss Makro-Planar T* 50mm f/2 ZE"Carl Zeiss Makro-Planar T* 100mm f/2 ZE"Carl Zeiss Makro-Planar T* 100mm f/2 ZE"Carl Zeiss Apo-Sonnar T* 135mm f/2 ZE"Carl Zeiss Apo-Sonnar T* 135mm f/2 ZE"Canon EF 38-76mm f/4.5-5.6"Canon EF 38-76mm f/4.5-5.6"Tamron 70-200mm f/2.8 Di LD IF Macro"Tamron 70-200mm f/2.8 Di LD IF Macro"Tamron AF 28-300mm f/3.5-6.3 XR Di VC LD Aspherical [IF] Macro Model A20"Tamron AF 28-300mm f/3.5-6.3 XR Di VC LD Aspherical [IF] Macro Model A20"const char[73]char[73]Tamron SP AF 17-50mm f/2.8 XR Di II VC LD Aspherical [IF] "Tamron SP AF 17-50mm f/2.8 XR Di II VC LD Aspherical [IF] "Tamron AF 18-270mm f/3.5-6.3 Di II VC LD Aspherical [IF] Macro"Tamron AF 18-270mm f/3.5-6.3 Di II VC LD Aspherical [IF] Macro"Canon EF 28-80mm f/3.5-5.6"Canon EF 28-80mm f/3.5-5.6"Canon EF 28-90mm f/4-5.6"Canon EF 28-90mm f/4-5.6"Canon EF 28-200mm f/3.5-5.6"Canon EF 28-200mm f/3.5-5.6"Canon EF 28-105mm f/4-5.6"Canon EF 28-105mm f/4-5.6"Canon EF 90-300mm f/4.5-5.6"Canon EF 90-300mm f/4.5-5.6"Canon EF-S 18-55mm f/3.5-5.6"Canon EF-S 18-55mm f/3.5-5.6"Zeiss Milvus 35mm f/2"Zeiss Milvus 35mm f/2"Zeiss Milvus 50mm f/2 Makro"Zeiss Milvus 50mm f/2 Makro"Canon EF-S 18-55mm f/3.5-5.6 IS"Canon EF-S 18-55mm f/3.5-5.6 IS"Canon EF-S 55-250mm f/4-5.6 IS"Canon EF-S 55-250mm f/4-5.6 IS"Canon EF-S 18-200mm f/3.5-5.6 IS"Canon EF-S 18-200mm f/3.5-5.6 IS"Canon EF-S 18-135mm f/3.5-5.6 IS"Canon EF-S 18-135mm f/3.5-5.6 IS"Canon EF-S 18-55mm f/3.5-5.6 IS II"Canon EF-S 18-55mm f/3.5-5.6 IS II"Canon EF-S 18-55mm f/3.5-5.6 III"Canon EF-S 18-55mm f/3.5-5.6 III"Canon EF-S 55-250mm f/4-5.6 IS II"Canon EF-S 55-250mm f/4-5.6 IS II"Irix 11mm f/4"Irix 11mm f/4"Canon TS-E 135mm f/4L Macro"Canon TS-E 135mm f/4L Macro"Canon TS-E 17mm f/4L"Canon TS-E 17mm f/4L"Canon TS-E 24.0mm f/3.5 L II"Canon TS-E 24.0mm f/3.5 L II"Canon MP-E 65mm f/2.8 1-5x Macro Photo"Canon MP-E 65mm f/2.8 1-5x Macro Photo"Canon TS-E 24mm f/3.5L"Canon TS-E 24mm f/3.5L"Canon TS-E 45mm f/2.8"Canon TS-E 45mm f/2.8"Canon TS-E 90mm f/2.8"Canon TS-E 90mm f/2.8"Canon EF 300mm f/2.8L"Canon EF 300mm f/2.8L"Canon EF 50mm f/1.0L"Canon EF 50mm f/1.0L"Canon EF 28-80mm f/2.8-4L"Canon EF 28-80mm f/2.8-4L"Sigma 8mm f/3.5 EX DG Circular Fisheye"Sigma 8mm f/3.5 EX DG Circular Fisheye"Sigma 17-35mm f/2.8-4 EX DG Aspherical HSM"Sigma 17-35mm f/2.8-4 EX DG Aspherical HSM"Sigma 17-70mm f/2.8-4.5 DC Macro"Sigma 17-70mm f/2.8-4.5 DC Macro"Sigma APO 50-150mm f/2.8 EX DC HSM"Sigma APO 50-150mm f/2.8 EX DC HSM"Sigma APO 120-300mm f/2.8 EX DG HSM"Sigma APO 120-300mm f/2.8 EX DG HSM"Sigma 4.5mm F2.8 EX DC HSM Circular Fisheye"Sigma 4.5mm F2.8 EX DC HSM Circular Fisheye"Sigma 70-200mm f/2.8 APO EX HSM"Sigma 70-200mm f/2.8 APO EX HSM"Canon EF 1200mm f/5.6L"Canon EF 1200mm f/5.6L"Canon EF 600mm f/4L IS"Canon EF 600mm f/4L IS"Canon EF 200mm f/1.8L"Canon EF 200mm f/1.8L"Tamron SP 15-30mm f/2.8 Di VC USD A012"Tamron SP 15-30mm f/2.8 Di VC USD A012"Canon EF 85mm f/1.2L"Canon EF 85mm f/1.2L"Sigma 18-50mm f/2.8-4.5 DC OS HSM"Sigma 18-50mm f/2.8-4.5 DC OS HSM"Sigma 50-200mm f/4-5.6 DC OS HSM"Sigma 50-200mm f/4-5.6 DC OS HSM"Sigma 18-250mm f/3.5-6.3 DC OS HSM"Sigma 18-250mm f/3.5-6.3 DC OS HSM"Sigma 24-70mm f/2.8 IF EX DG HSM"Sigma 24-70mm f/2.8 IF EX DG HSM"Sigma 18-125mm f/3.8-5.6 DC OS HSM"Sigma 18-125mm f/3.8-5.6 DC OS HSM"Sigma 17-70mm f/2.8-4 DC Macro OS HSM | C"Sigma 17-70mm f/2.8-4 DC Macro OS HSM | C"Sigma 17-50mm f/2.8 OS HSM"Sigma 17-50mm f/2.8 OS HSM"Sigma 18-200mm f/3.5-6.3 DC OS HSM [II]"Sigma 18-200mm f/3.5-6.3 DC OS HSM [II]"Tamron AF 18-270mm f/3.5-6.3 Di II VC PZD"Tamron AF 18-270mm f/3.5-6.3 Di II VC PZD"Sigma 8-16mm f/4.5-5.6 DC HSM"Sigma 8-16mm f/4.5-5.6 DC HSM"Tamron SP 17-50mm f/2.8 XR Di II VC"Tamron SP 17-50mm f/2.8 XR Di II VC"Tamron SP 60mm f/2 Macro Di II"Tamron SP 60mm f/2 Macro Di II"Sigma 10-20mm f/3.5 EX DC HSM"Sigma 10-20mm f/3.5 EX DC HSM"Tamron SP 24-70mm f/2.8 Di VC USD"Tamron SP 24-70mm f/2.8 Di VC USD"Sigma 18-35mm f/1.8 DC HSM"Sigma 18-35mm f/1.8 DC HSM"Sigma 12-24mm f/4.5-5.6 DG HSM II"Sigma 12-24mm f/4.5-5.6 DG HSM II"Canon EF 400mm f/2.8L"Canon EF 400mm f/2.8L"Canon EF 500mm f/4.5L"Canon EF 500mm f/4.5L"Canon EF 300mm f/2.8L IS"Canon EF 300mm f/2.8L IS"Canon EF 500mm f/4L IS"Canon EF 500mm f/4L IS"Sigma 17-70mm f/2.8-4 DC Macro OS HSM"Sigma 17-70mm f/2.8-4 DC Macro OS HSM"Sigma 24-105mm F4 DG OS HSM [Art 013]"Sigma 24-105mm F4 DG OS HSM [Art 013]"Canon EF 35-135mm f/4-5.6 USM"Canon EF 35-135mm f/4-5.6 USM"Canon EF 100-300mm f/4.5-5.6 USM"Canon EF 100-300mm f/4.5-5.6 USM"Canon EF 70-210mm f/3.5-4.5 USM"Canon EF 70-210mm f/3.5-4.5 USM"Canon EF 28-80mm f/3.5-5.6 USM"Canon EF 28-80mm f/3.5-5.6 USM"Canon EF 100mm f/2 USM"Canon EF 100mm f/2 USM"Canon EF 14mm f/2.8L"Canon EF 14mm f/2.8L"Sigma 20mm EX f/1.8"Sigma 20mm EX f/1.8"Sigma 30mm f/1.4 DC HSM"Sigma 30mm f/1.4 DC HSM"Sigma 24mm f/1.8 DG Macro EX"Sigma 24mm f/1.8 DG Macro EX"Sigma 28mm f/1.8 DG Macro EX"Sigma 28mm f/1.8 DG Macro EX"Sigma 18-35mm f/1.8 DC HSM | A"Sigma 18-35mm f/1.8 DC HSM | A"Canon EF 200mm f/2.8L"Canon EF 200mm f/2.8L"Canon EF 300mm f/4L IS"Canon EF 300mm f/4L IS"Sigma 12-24mm f/4.5-5.6 EX DG ASPHERICAL HSM"Sigma 12-24mm f/4.5-5.6 EX DG ASPHERICAL HSM"Sigma 14mm f/2.8 EX Aspherical HSM"Sigma 14mm f/2.8 EX Aspherical HSM"Sigma 10-20mm f/4-5.6"Sigma 10-20mm f/4-5.6"Sigma 100-300mm f/4"Sigma 100-300mm f/4"Canon EF 35-350mm f/3.5-5.6L"Canon EF 35-350mm f/3.5-5.6L"Sigma 50-500mm f/4-6.3 APO HSM EX"Sigma 50-500mm f/4-6.3 APO HSM EX"Tamron AF 28-300mm f/3.5-6.3 XR LD Aspherical [IF] Macro"Tamron AF 28-300mm f/3.5-6.3 XR LD Aspherical [IF] Macro"Tamron AF 18-200mm f/3.5-6.3 XR Di II LD Aspherical [IF] Macro Model A14"Tamron AF 18-200mm f/3.5-6.3 XR Di II LD Aspherical [IF] Macro Model A14"Tamron 18-250mm f/3.5-6.3 Di II LD Aspherical [IF] Macro"Tamron 18-250mm f/3.5-6.3 Di II LD Aspherical [IF] Macro"Canon EF 20mm f/2.8 USM"Canon EF 20mm f/2.8 USM"Zeiss Milvus 21mm f/2.8"Zeiss Milvus 21mm f/2.8"Canon EF 85mm f/1.8 USM"Canon EF 85mm f/1.8 USM"Sigma 14mm f/1.8 DG HSM | A"Sigma 14mm f/1.8 DG HSM | A"Canon EF 28-105mm f/3.5-4.5 USM"Canon EF 28-105mm f/3.5-4.5 USM"Tamron SP 70-300mm f/4-5.6 Di VC USD"Tamron SP 70-300mm f/4-5.6 Di VC USD"Canon EF 20-35mm f/3.5-4.5 USM"Canon EF 20-35mm f/3.5-4.5 USM"Tamron AF 19-35mm f/3.5-4.5"Tamron AF 19-35mm f/3.5-4.5"Tokina AT-X 124 AF 12-24mm f/4 DX"Tokina AT-X 124 AF 12-24mm f/4 DX"Tokina AT-X 107 AF DX Fish-eye 10-17mm f/3.5-4.5"Tokina AT-X 107 AF DX Fish-eye 10-17mm f/3.5-4.5"Tokina AT-X 116 PRO DX AF 11-16mm f/2.8"Tokina AT-X 116 PRO DX AF 11-16mm f/2.8"Tokina AT-X 11-20 F2.8 PRO DX Aspherical 11-20mm f/2.8"Tokina AT-X 11-20 F2.8 PRO DX Aspherical 11-20mm f/2.8"Canon EF 28-70mm f/2.8L"Canon EF 28-70mm f/2.8L"Sigma 24-70mm EX f/2.8"Sigma 24-70mm EX f/2.8"Sigma 28-70mm f/2.8 EX"Sigma 28-70mm f/2.8 EX"Sigma 24-60mm f/2.8 EX DG"Sigma 24-60mm f/2.8 EX DG"Tamron AF 17-50mm f/2.8 Di-II LD Aspherical"Tamron AF 17-50mm f/2.8 Di-II LD Aspherical"Tamron 90mm f/2.8"Tamron 90mm f/2.8"Tamron SP AF 17-35mm f/2.8-4 Di LD Aspherical IF"Tamron SP AF 17-35mm f/2.8-4 Di LD Aspherical IF"Canon EF 300mm f/4L"Canon EF 300mm f/4L"Canon EF 400mm f/5.6L"Canon EF 400mm f/5.6L"Canon EF 70-200mm f/2.8 L"Canon EF 70-200mm f/2.8 L"Canon EF 70-200mm f/2.8 L + 1.4x"Canon EF 70-200mm f/2.8 L + 1.4x"Canon EF 70-200mm f/2.8 L + 2x"Canon EF 70-200mm f/2.8 L + 2x"Canon EF 28mm f/1.8 USM"Canon EF 28mm f/1.8 USM"Sigma 50-100mm f/1.8 DC HSM | A"Sigma 50-100mm f/1.8 DC HSM | A"Canon EF 17-35mm f/2.8L"Canon EF 17-35mm f/2.8L"Sigma 18-200mm f/3.5-6.3 DC OS"Sigma 18-200mm f/3.5-6.3 DC OS"Sigma 15-30mm f/3.5-4.5 EX DG Aspherical"Sigma 15-30mm f/3.5-4.5 EX DG Aspherical"Sigma 18-50mm f/2.8 Macro"Sigma 18-50mm f/2.8 Macro"Sigma 50mm f/1.4 EX DG HSM"Sigma 50mm f/1.4 EX DG HSM"Sigma 85mm f/1.4 EX DG HSM"Sigma 85mm f/1.4 EX DG HSM"Sigma 30mm f/1.4 EX DC HSM"Sigma 30mm f/1.4 EX DC HSM"Sigma 35mm f/1.4 DG HSM"Sigma 35mm f/1.4 DG HSM"Canon EF 200mm f/2.8L II"Canon EF 200mm f/2.8L II"Sigma 150-600mm f/5-6.3 DG OS HSM | S"Sigma 150-600mm f/5-6.3 DG OS HSM | S"Sigma 150-500mm f/5-6.3 APO DG OS HSM + 1.4x"Sigma 150-500mm f/5-6.3 APO DG OS HSM + 1.4x"Canon EF 180mm Macro f/3.5L"Canon EF 180mm Macro f/3.5L"Sigma 180mm EX HSM Macro f/3.5"Sigma 180mm EX HSM Macro f/3.5"Sigma APO Macro 150mm f/3.5 EX DG IF HSM"Sigma APO Macro 150mm f/3.5 EX DG IF HSM"Sigma 150-500mm f/5-6.3 APO DG OS HSM + 2x"Sigma 150-500mm f/5-6.3 APO DG OS HSM + 2x"Canon EF 135mm f/2L"Canon EF 135mm f/2L"Sigma 70-200mm f/2.8 EX DG APO OS HSM"Sigma 70-200mm f/2.8 EX DG APO OS HSM"Sigma 50-500mm f/4.5-6.3 APO DG OS HSM"Sigma 50-500mm f/4.5-6.3 APO DG OS HSM"Sigma 150-500mm f/5-6.3 APO DG OS HSM"Sigma 150-500mm f/5-6.3 APO DG OS HSM"Zeiss Milvus 100mm f/2 Makro"Zeiss Milvus 100mm f/2 Makro"Sigma 120-300mm f/2.8 EX APO DG OS HSM"Sigma 120-300mm f/2.8 EX APO DG OS HSM"Canon EF 24-85mm f/3.5-4.5 USM"Canon EF 24-85mm f/3.5-4.5 USM"Canon EF 28-135mm f/3.5-5.6 IS"Canon EF 28-135mm f/3.5-5.6 IS"Canon EF 24mm f/1.4L"Canon EF 24mm f/1.4L"Canon EF 35mm f/1.4L"Canon EF 35mm f/1.4L"Sigma 50mm f/1.4 DG HSM | A"Sigma 50mm f/1.4 DG HSM | A"Sigma 24mm f/1.4 DG HSM | A"Sigma 24mm f/1.4 DG HSM | A"Sigma 20mm f/1.4 DG HSM | A"Sigma 20mm f/1.4 DG HSM | A"Zeiss Milvus 50mm f/1.4"Zeiss Milvus 50mm f/1.4"Zeiss Milvus 85mm f/1.4"Zeiss Milvus 85mm f/1.4"Zeiss Otus 28mm f/1.4 ZE"Zeiss Otus 28mm f/1.4 ZE"Canon EF 100-400mm f/4.5-5.6L IS + 1.4x"Canon EF 100-400mm f/4.5-5.6L IS + 1.4x"Sigma 150-600mm f/5-6.3 DG OS HSM | S + 1.4x"Sigma 150-600mm f/5-6.3 DG OS HSM | S + 1.4x"Canon EF 100-400mm f/4.5-5.6L IS + 2x"Canon EF 100-400mm f/4.5-5.6L IS + 2x"Sigma 150-600mm f/5-6.3 DG OS HSM | S + 2x"Sigma 150-600mm f/5-6.3 DG OS HSM | S + 2x"Canon EF 100-400mm f/4.5-5.6L IS"Canon EF 100-400mm f/4.5-5.6L IS"Sigma 150mm f/2.8 EX DG OS HSM APO Macro"Sigma 150mm f/2.8 EX DG OS HSM APO Macro"Sigma 105mm f/2.8 EX DG OS HSM Macro"Sigma 105mm f/2.8 EX DG OS HSM Macro"Sigma 180mm f/2.8 EX DG OS HSM APO Macro"Sigma 180mm f/2.8 EX DG OS HSM APO Macro"Sigma 150-600mm f/5-6.3 DG OS HSM | C"Sigma 150-600mm f/5-6.3 DG OS HSM | C"Canon EF 400mm f/2.8L + 2x"Canon EF 400mm f/2.8L + 2x"Canon EF 70-200mm f/4L"Canon EF 70-200mm f/4L"Canon EF 70-200mm f/4L + 1.4x"Canon EF 70-200mm f/4L + 1.4x"Canon EF 70-200mm f/4L + 2x"Canon EF 70-200mm f/4L + 2x"Canon EF 70-200mm f/4L + 2.8x"Canon EF 70-200mm f/4L + 2.8x"Canon EF 100mm f/2.8 Macro USM"Canon EF 100mm f/2.8 Macro USM"Canon EF 400mm f/4 DO IS"Canon EF 400mm f/4 DO IS"Canon EF 35-80mm f/4-5.6 USM"Canon EF 35-80mm f/4-5.6 USM"Canon EF 80-200mm f/4.5-5.6 USM"Canon EF 80-200mm f/4.5-5.6 USM"Canon EF 35-105mm f/4.5-5.6 USM"Canon EF 35-105mm f/4.5-5.6 USM"Canon EF 75-300mm f/4-5.6 USM"Canon EF 75-300mm f/4-5.6 USM"Canon EF 75-300mm f/4-5.6 IS USM"Canon EF 75-300mm f/4-5.6 IS USM"Canon EF 50mm f/1.4 USM"Canon EF 50mm f/1.4 USM"Zeiss Otus 55mm f/1.4 ZE"Zeiss Otus 55mm f/1.4 ZE"Zeiss Otus 85mm f/1.4 ZE"Zeiss Otus 85mm f/1.4 ZE"Canon EF 28-80mm f/3.5-5.6 USM IV"Canon EF 28-80mm f/3.5-5.6 USM IV"Canon EF 22-55mm f/4-5.6 USM"Canon EF 22-55mm f/4-5.6 USM"Canon EF 55-200mm f/4.5-5.6"Canon EF 55-200mm f/4.5-5.6"Canon EF 28-90mm f/4-5.6 USM"Canon EF 28-90mm f/4-5.6 USM"Canon EF 28-200mm f/3.5-5.6 USM"Canon EF 28-200mm f/3.5-5.6 USM"Canon EF 28-105mm f/4-5.6 USM"Canon EF 28-105mm f/4-5.6 USM"Canon EF 90-300mm f/4.5-5.6 USM"Canon EF 90-300mm f/4.5-5.6 USM"Tamron SP 150-600mm F/5-6.3 Di VC USD"Tamron SP 150-600mm F/5-6.3 Di VC USD"Tamron 16-300mm f/3.5-6.3 Di II VC PZD Macro"Tamron 16-300mm f/3.5-6.3 Di II VC PZD Macro"Tamron SP 35mm f/1.8 Di VC USD"Tamron SP 35mm f/1.8 Di VC USD"Tamron SP 45mm f/1.8 Di VC USD"Tamron SP 45mm f/1.8 Di VC USD"Canon EF-S 18-55mm f/3.5-5.6 USM"Canon EF-S 18-55mm f/3.5-5.6 USM"Canon EF 55-200mm f/4.5-5.6 II USM"Canon EF 55-200mm f/4.5-5.6 II USM"Canon EF 70-200mm f/2.8L IS"Canon EF 70-200mm f/2.8L IS"Canon EF 70-200mm f/2.8L IS + 1.4x"Canon EF 70-200mm f/2.8L IS + 1.4x"Canon EF 70-200mm f/2.8L IS + 2x"Canon EF 70-200mm f/2.8L IS + 2x"Canon EF 70-200mm f/2.8L IS + 2.8x"Canon EF 70-200mm f/2.8L IS + 2.8x"Canon EF 16-35mm f/2.8L"Canon EF 16-35mm f/2.8L"Canon EF 24-70mm f/2.8L"Canon EF 24-70mm f/2.8L"Canon EF 17-40mm f/4L"Canon EF 17-40mm f/4L"Canon EF 70-300mm f/4.5-5.6 DO IS USM"Canon EF 70-300mm f/4.5-5.6 DO IS USM"Canon EF 28-300mm f/3.5-5.6L IS"Canon EF 28-300mm f/3.5-5.6L IS"Canon EF-S 17-85mm f4-5.6 IS USM"Canon EF-S 17-85mm f4-5.6 IS USM"Tokina AT-X 12-28 PRO DX 12-28mm f/4"Tokina AT-X 12-28 PRO DX 12-28mm f/4"Canon EF-S 10-22mm f/3.5-4.5 USM"Canon EF-S 10-22mm f/3.5-4.5 USM"Canon EF-S 60mm f/2.8 Macro USM"Canon EF-S 60mm f/2.8 Macro USM"Canon EF 24-105mm f/4L IS"Canon EF 24-105mm f/4L IS"Canon EF 70-300mm f/4-5.6 IS USM"Canon EF 70-300mm f/4-5.6 IS USM"Canon EF 85mm f/1.2L II"Canon EF 85mm f/1.2L II"Canon EF-S 17-55mm f/2.8 IS USM"Canon EF-S 17-55mm f/2.8 IS USM"Canon EF 50mm f/1.2L"Canon EF 50mm f/1.2L"Canon EF 70-200mm f/4L IS"Canon EF 70-200mm f/4L IS"Canon EF 70-200mm f/4L IS + 1.4x"Canon EF 70-200mm f/4L IS + 1.4x"Canon EF 70-200mm f/4L IS + 2x"Canon EF 70-200mm f/4L IS + 2x"Canon EF 70-200mm f/4L IS + 2.8x"Canon EF 70-200mm f/4L IS + 2.8x"Canon EF 16-35mm f/2.8L II"Canon EF 16-35mm f/2.8L II"Canon EF 14mm f/2.8L II USM"Canon EF 14mm f/2.8L II USM"Canon EF 200mm f/2L IS"Canon EF 200mm f/2L IS"Sigma 24-35mm f/2 DG HSM | A"Sigma 24-35mm f/2 DG HSM | A"Canon EF 800mm f/5.6L IS"Canon EF 800mm f/5.6L IS"Canon EF 24 f/1.4L II"Canon EF 24 f/1.4L II"Canon EF 70-200mm f/2.8L IS II USM"Canon EF 70-200mm f/2.8L IS II USM"Canon EF 70-200mm f/2.8L IS II USM + 1.4x"Canon EF 70-200mm f/2.8L IS II USM + 1.4x"Canon EF 70-200mm f/2.8L IS II USM + 2x"Canon EF 70-200mm f/2.8L IS II USM + 2x"Canon EF 100mm f/2.8L Macro IS USM"Canon EF 100mm f/2.8L Macro IS USM"Tamron SP 90mm f/2.8 Di VC USD Macro 1:1"Tamron SP 90mm f/2.8 Di VC USD Macro 1:1"Sigma 24-105mm f/4 DG OS HSM | A"Sigma 24-105mm f/4 DG OS HSM | A"Canon EF-S 15-85mm f/3.5-5.6 IS USM"Canon EF-S 15-85mm f/3.5-5.6 IS USM"Canon EF 70-300mm f/4-5.6L IS USM"Canon EF 70-300mm f/4-5.6L IS USM"Canon EF 8-15mm f/4L Fisheye USM"Canon EF 8-15mm f/4L Fisheye USM"Canon EF 300mm f/2.8L IS II USM"Canon EF 300mm f/2.8L IS II USM"Tamron SP 24-70mm f/2.8 Di VC USD G2"Tamron SP 24-70mm f/2.8 Di VC USD G2"Canon EF 400mm f/2.8L IS II USM"Canon EF 400mm f/2.8L IS II USM"Canon EF 500mm f/4L IS II USM"Canon EF 500mm f/4L IS II USM"Canon EF 24-105mm f/4L IS USM"Canon EF 24-105mm f/4L IS USM"Canon EF 600mm f/4.0L IS II USM"Canon EF 600mm f/4.0L IS II USM"Canon EF 24-70mm f/2.8L II USM"Canon EF 24-70mm f/2.8L II USM"Canon EF 200-400mm f/4L IS USM"Canon EF 200-400mm f/4L IS USM"Canon EF 200-400mm f/4L IS USM + 1.4x"Canon EF 200-400mm f/4L IS USM + 1.4x"Canon EF 28mm f/2.8 IS USM"Canon EF 28mm f/2.8 IS USM"Canon EF 24mm f/2.8 IS USM"Canon EF 24mm f/2.8 IS USM"Canon EF 24-70mm f/4L IS USM"Canon EF 24-70mm f/4L IS USM"Canon EF 35mm f/2 IS USM"Canon EF 35mm f/2 IS USM"Canon EF 400mm f/4 DO IS II USM"Canon EF 400mm f/4 DO IS II USM"Canon EF 16-35mm f/4L IS USM"Canon EF 16-35mm f/4L IS USM"Canon EF 11-24mm f/4L USM"Canon EF 11-24mm f/4L USM"Sigma 150-600mm f/5-6.3 DG OS HSM | C + 1.4x"Sigma 150-600mm f/5-6.3 DG OS HSM | C + 1.4x"Canon EF 100-400mm f/4.5-5.6L IS II USM"Canon EF 100-400mm f/4.5-5.6L IS II USM"Tamron SP 150-600mm F5-6.3 Di VC USD G2"Tamron SP 150-600mm F5-6.3 Di VC USD G2"Canon EF 100-400mm f/4.5-5.6L IS II USM + 1.4x"Canon EF 100-400mm f/4.5-5.6L IS II USM + 1.4x"Canon EF 35mm f/1.4L II USM"Canon EF 35mm f/1.4L II USM"Canon EF 16-35mm f/2.8L III USM"Canon EF 16-35mm f/2.8L III USM"Canon EF 24-105mm f/4L IS II USM"Canon EF 24-105mm f/4L IS II USM"4142Canon EF-S 18-135mm f/3.5-5.6 IS STM"Canon EF-S 18-135mm f/3.5-5.6 IS STM"Canon EF-M 18-55mm f/3.5-5.6 IS STM"Canon EF-M 18-55mm f/3.5-5.6 IS STM"Tamron 18-200mm F/3.5-6.3 Di III VC"Tamron 18-200mm F/3.5-6.3 Di III VC"4144Canon EF 40mm f/2.8 STM"Canon EF 40mm f/2.8 STM"4145Canon EF-M 22mm f/2 STM"Canon EF-M 22mm f/2 STM"4146Canon EF-S 18-55mm f/3.5-5.6 IS STM"Canon EF-S 18-55mm f/3.5-5.6 IS STM"4147Canon EF-M 11-22mm f/4-5.6 IS STM"Canon EF-M 11-22mm f/4-5.6 IS STM"4148Canon EF-S 55-250mm f/4-5.6 IS STM"Canon EF-S 55-250mm f/4-5.6 IS STM"4149Canon EF-M 55-200mm f/4.5-6.3 IS STM"Canon EF-M 55-200mm f/4.5-6.3 IS STM"4150Canon EF-S 10-18mm f/4.5-5.6 IS STM"Canon EF-S 10-18mm f/4.5-5.6 IS STM"4152Canon EF 24-105mm f/3.5-5.6 IS STM"Canon EF 24-105mm f/3.5-5.6 IS STM"4153Canon EF-M 15-45mm f/3.5-6.3 IS STM"Canon EF-M 15-45mm f/3.5-6.3 IS STM"4155Canon EF-M 28mm f/3.5 Macro IS STM"Canon EF-M 28mm f/3.5 Macro IS STM"4156Canon EF 50mm f/1.8 STM"Canon EF 50mm f/1.8 STM"4157Canon EF-M 18-150mm 1:3.5-6.3 IS STM"Canon EF-M 18-150mm 1:3.5-6.3 IS STM"4158Canon EF-S 18-55mm f/4-5.6 IS STM"Canon EF-S 18-55mm f/4-5.6 IS STM"4160Canon EF-S 35mm f/2.8 Macro IS STM"Canon EF-S 35mm f/2.8 Macro IS STM"36910Canon EF 70-300mm f/4-5.6 IS II USM"Canon EF 70-300mm f/4-5.6 IS II USM"36912Canon EF-S 18-135mm f/3.5-5.6 IS USM"Canon EF-S 18-135mm f/3.5-5.6 IS USM""Easy shooting (Auto)""Program (P)""Shutter priority (Tv)""Aperture priority (Av)""Manual (M)""A-DEP""M-DEP""Bulb"const TagDetails[8]TagDetails[8]Easy shooting (Auto)Program (P)Shutter priority (Tv)Aperture priority (Av)Manual (M)A-DEPM-DEPBulbcanonCsExposureProgram"Manual AF point selection""None (MF)""Auto-selected""Right""Left""Auto AF point selection""Face Detect"81970x2005Manual AF point selection122880x3000None (MF)122890x3001Auto-selected122900x3002Right122910x3003122920x3004Left163850x4001Auto AF point selection163900x4006Face DetectcanonCsAfPoint"Not known""Macro""Very close""Close""Middle range""Far range""Pan focus""Super macro""Infinity"const TagDetails[11]TagDetails[11]Not knownMacroVery closeCloseMiddle rangeFar rangePan focusSuper macroInfinitycanonCsFocusType"Default""Spot""Average""Evaluative""Partial""Center-weighted average"DefaultSpotAverageEvaluativePartialCenter-weighted averagecanonCsMeteringMode"Auto High"const TagDetails[31]TagDetails[31]Auto High"50""100""200""400""800"16464"80"1648416509"125"16544"160"1658416634"250"16704"320"1678416884"500"17024"640"1718417384"1000"176341250"1250"179841600"1600"18384188842500"2500"195843200"3200"203844000"4000"213845000"5000"227846400"6400"243848000"8000"26384"10000"2918412800"12800"canonCsISOSpeed"Normal"NormalcanonCsLnh"Other"2x"2x"4x"4x"OthercanonCsDigitalZoom"Full auto""Fast shutter""Slow shutter""Night""Gray Scale""Sports""Flash Off""Long Shutter""Super Macro""Foliage""Indoor""Fireworks""Beach""Snow""Kids & Pets""Night Snapshot""Digital Macro""My Colors""Movie Snap""Super Macro 2""Color Accent""Color Swap""Aquarium""ISO 3200""ISO 6400""Creative Light Effect""Easy""Quick Shot""Creative Auto""Zoom Blur""Low Light""Nostalgic""Super Vivid""Poster Effect""Face Self-timer""Smile""Wink Self-timer""Fisheye Effect""Miniature Effect""High-speed Burst""Best Image Selection""High Dynamic Range""Handheld Night Scene""Movie Digest""Live View Control""Discreet""Blur Reduction""Toy Camera Effect""Scene Intelligent Auto""High-speed Burst HQ""Smooth Skin""Soft Focus""Spotlight""Night 2""Night+""Super Night""Sunset""Night Scene""Surface""Low Light 2"const TagDetails[71]TagDetails[71]Full autoFast shutterSlow shutterNightGray ScaleSportsFlash OffLong ShutterSuper MacroFoliageIndoorFireworksBeachSnowKids & PetsNight SnapshotDigital MacroMy ColorsMovie SnapSuper Macro 2Color AccentColor SwapAquariumISO 3200ISO 6400Creative Light EffectEasyQuick ShotCreative AutoZoom BlurLow LightNostalgicSuper VividPoster EffectFace Self-timerSmileWink Self-timerFisheye EffectMiniature EffectHigh-speed BurstBest Image SelectionHigh Dynamic RangeHandheld Night SceneMovie DigestLive View ControlDiscreetBlur ReductionToy Camera EffectScene Intelligent AutoHigh-speed Burst HQSmooth SkinSoft FocusSpotlightNight 2Night+Super NightSunsetNight SceneSurfaceLow Light 2canonCsEasyModecanonCsImageSize"One shot AF""AI servo AF""AI focus AF""Manual focus (3)""Manual focus (6)""AF + MF""Movie Snap Focus""Movie Servo AF"const TagDetails[12]TagDetails[12]One shot AFAI servo AFAI focus AFManual focus (3)Manual focus (6)AF + MFMovie Snap FocusMovie Servo AFcanonCsFocusMode"Single / timer""Movie""Continuous, speed priority""Continuous, low""Continuous, high""Silent Single""Single, Silent""Continuous, Silent"Single / timerMovieContinuous, speed priorityContinuous, lowContinuous, highSilent SingleSingle, SilentContinuous, SilentcanonCsDriveMode"Red-eye""Slow sync""Auto + red-eye""On + red-eye""External"Red-eyeSlow syncAuto + red-eyeOn + red-eyeExternalcanonCsFlashMode"Economy""Fine""RAW""Superfine""Normal Movie""Movie (2)"const TagDetails[7]TagDetails[7]EconomyFineRAWSuperfineNormal MovieMovie (2)canonCsQualitycanonCsMacro"sRGB"sRGBcanonColorSpace"On (1)"On (1)canonSuperMacro"Format 1""Format 2"24159191040x90000000(long int)0x90000000Format 126843545600xa0000000(long int)0xa0000000Format 2canonSerialNumberFormatconst TagDetails[312]TagDetails[312]168427520x1010000(long int)0x1010000PowerShot A30"PowerShot A30"170393600x1040000(long int)0x1040000PowerShot S300 / Digital IXUS 300 / IXY Digital 300"PowerShot S300 / Digital IXUS 300 / IXY Digital 300"171704320x1060000(long int)0x1060000PowerShot A20"PowerShot A20"173015040x1080000(long int)0x1080000PowerShot A10"PowerShot A10"173670400x1090000(long int)0x1090000PowerShot S110 / Digital IXUS v / IXY Digital 200"PowerShot S110 / Digital IXUS v / IXY Digital 200"178257920x1100000(long int)0x1100000PowerShot G2"PowerShot G2"178913280x1110000(long int)0x1110000PowerShot S40"PowerShot S40"179568640x1120000(long int)0x1120000PowerShot S30"PowerShot S30"180224000x1130000(long int)0x1130000PowerShot A40"PowerShot A40"180879360x1140000(long int)0x1140000EOS D30"EOS D30"181534720x1150000(long int)0x1150000PowerShot A100"PowerShot A100"182190080x1160000(long int)0x1160000PowerShot S200 / Digital IXUS v2 / IXY Digital 200a"PowerShot S200 / Digital IXUS v2 / IXY Digital 200a"182845440x1170000(long int)0x1170000PowerShot A200"PowerShot A200"183500800x1180000(long int)0x1180000PowerShot S330 / Digital IXUS 330 / IXY Digital 300a"PowerShot S330 / Digital IXUS 330 / IXY Digital 300a"184156160x1190000(long int)0x1190000PowerShot G3"PowerShot G3"189399040x1210000(long int)0x1210000PowerShot S45"PowerShot S45"190709760x1230000(long int)0x1230000PowerShot SD100 / Digital IXUS II / IXY Digital 30"PowerShot SD100 / Digital IXUS II / IXY Digital 30"191365120x1240000(long int)0x1240000PowerShot S230 / Digital IXUS v3 / IXY Digital 320"PowerShot S230 / Digital IXUS v3 / IXY Digital 320"192020480x1250000(long int)0x1250000PowerShot A70"PowerShot A70"192675840x1260000(long int)0x1260000PowerShot A60"PowerShot A60"193331200x1270000(long int)0x1270000PowerShot S400 / Digital IXUS 400 / IXY Digital 400"PowerShot S400 / Digital IXUS 400 / IXY Digital 400"194641920x1290000(long int)0x1290000PowerShot G5"PowerShot G5"199229440x1300000(long int)0x1300000PowerShot A300"PowerShot A300"199884800x1310000(long int)0x1310000PowerShot S50"PowerShot S50"201850880x1340000(long int)0x1340000PowerShot A80"PowerShot A80"202506240x1350000(long int)0x1350000PowerShot SD10 / Digital IXUS i / IXY Digital L"PowerShot SD10 / Digital IXUS i / IXY Digital L"203161600x1360000(long int)0x1360000PowerShot S1 IS"PowerShot S1 IS"203816960x1370000(long int)0x1370000PowerShot Pro1"PowerShot Pro1"204472320x1380000(long int)0x1380000PowerShot S70"PowerShot S70"205127680x1390000(long int)0x1390000PowerShot S60"PowerShot S60"209715200x1400000(long int)0x1400000PowerShot G6"PowerShot G6"210370560x1410000(long int)0x1410000PowerShot S500 / Digital IXUS 500 / IXY Digital 500"PowerShot S500 / Digital IXUS 500 / IXY Digital 500"211025920x1420000(long int)0x1420000PowerShot A75"PowerShot A75"212336640x1440000(long int)0x1440000PowerShot SD110 / Digital IXUS IIs / IXY Digital 30a"PowerShot SD110 / Digital IXUS IIs / IXY Digital 30a"212992000x1450000(long int)0x1450000PowerShot A400"PowerShot A400"214302720x1470000(long int)0x1470000PowerShot A310"PowerShot A310"215613440x1490000(long int)0x1490000PowerShot A85"PowerShot A85"221511680x1520000(long int)0x1520000PowerShot S410 / Digital IXUS 430 / IXY Digital 450"PowerShot S410 / Digital IXUS 430 / IXY Digital 450"222167040x1530000(long int)0x1530000PowerShot A95"PowerShot A95"222822400x1540000(long int)0x1540000PowerShot SD300 / Digital IXUS 40 / IXY Digital 50"PowerShot SD300 / Digital IXUS 40 / IXY Digital 50"223477760x1550000(long int)0x1550000PowerShot SD200 / Digital IXUS 30 / IXY Digital 40"PowerShot SD200 / Digital IXUS 30 / IXY Digital 40"224133120x1560000(long int)0x1560000PowerShot A520"PowerShot A520"224788480x1570000(long int)0x1570000PowerShot A510"PowerShot A510"226099200x1590000(long int)0x1590000PowerShot SD20 / Digital IXUS i5 / IXY Digital L2"PowerShot SD20 / Digital IXUS i5 / IXY Digital L2"233308160x1640000(long int)0x1640000PowerShot S2 IS"PowerShot S2 IS"233963520x1650000(long int)0x1650000PowerShot SD430 / IXUS Wireless / IXY Wireless"PowerShot SD430 / IXUS Wireless / IXY Wireless"234618880x1660000(long int)0x1660000PowerShot SD500 / Digital IXUS 700 / IXY Digital 600"PowerShot SD500 / Digital IXUS 700 / IXY Digital 600"234946560x1668000(long int)0x1668000EOS D60"EOS D60"241172480x1700000(long int)0x1700000PowerShot SD30 / Digital IXUS i zoom / IXY Digital L3"PowerShot SD30 / Digital IXUS i zoom / IXY Digital L3"243793920x1740000(long int)0x1740000PowerShot A430"PowerShot A430"244449280x1750000(long int)0x1750000PowerShot A410"PowerShot A410"245104640x1760000(long int)0x1760000PowerShot S80"PowerShot S80"246415360x1780000(long int)0x1780000PowerShot A620"PowerShot A620"247070720x1790000(long int)0x1790000PowerShot A610"PowerShot A610"251658240x1800000(long int)0x1800000PowerShot SD630 / Digital IXUS 65 / IXY Digital 80"PowerShot SD630 / Digital IXUS 65 / IXY Digital 80"252313600x1810000(long int)0x1810000PowerShot SD450 / Digital IXUS 55 / IXY Digital 60"PowerShot SD450 / Digital IXUS 55 / IXY Digital 60"252968960x1820000(long int)0x1820000PowerShot TX1"PowerShot TX1"256245760x1870000(long int)0x1870000PowerShot SD400 / Digital IXUS 50 / IXY Digital 55"PowerShot SD400 / Digital IXUS 50 / IXY Digital 55"256901120x1880000(long int)0x1880000PowerShot A420"PowerShot A420"257556480x1890000(long int)0x1890000PowerShot SD900 / Digital IXUS 900 Ti / IXY Digital 1000"PowerShot SD900 / Digital IXUS 900 Ti / IXY Digital 1000"262144000x1900000(long int)0x1900000PowerShot SD550 / Digital IXUS 750 / IXY Digital 700"PowerShot SD550 / Digital IXUS 750 / IXY Digital 700"263454720x1920000(long int)0x1920000PowerShot A700"PowerShot A700"264765440x1940000(long int)0x1940000PowerShot SD700 IS / Digital IXUS 800 IS / IXY Digital 800 IS"PowerShot SD700 IS / Digital IXUS 800 IS / IXY Digital 800 IS"265420800x1950000(long int)0x1950000PowerShot S3 IS"PowerShot S3 IS"266076160x1960000(long int)0x1960000PowerShot A540"PowerShot A540"266731520x1970000(long int)0x1970000PowerShot SD600 / Digital IXUS 60 / IXY Digital 70"PowerShot SD600 / Digital IXUS 60 / IXY Digital 70"267386880x1980000(long int)0x1980000PowerShot G7"PowerShot G7"268042240x1990000(long int)0x1990000PowerShot A530"PowerShot A530"335544320x2000000(long int)0x2000000PowerShot SD800 IS / Digital IXUS 850 IS / IXY Digital 900 IS"PowerShot SD800 IS / Digital IXUS 850 IS / IXY Digital 900 IS"336199680x2010000(long int)0x2010000PowerShot SD40 / Digital IXUS i7 / IXY Digital L4"PowerShot SD40 / Digital IXUS i7 / IXY Digital L4"336855040x2020000(long int)0x2020000PowerShot A710 IS"PowerShot A710 IS"337510400x2030000(long int)0x2030000PowerShot A640"PowerShot A640"338165760x2040000(long int)0x2040000PowerShot A630"PowerShot A630"341442560x2090000(long int)0x2090000PowerShot S5 IS"PowerShot S5 IS"346030080x2100000(long int)0x2100000PowerShot A460"PowerShot A460"347340800x2120000(long int)0x2120000PowerShot SD850 IS / Digital IXUS 950 IS"PowerShot SD850 IS / Digital IXUS 950 IS"347996160x2130000(long int)0x2130000PowerShot A570 IS"PowerShot A570 IS"348651520x2140000(long int)0x2140000PowerShot A560"PowerShot A560"349306880x2150000(long int)0x2150000PowerShot SD750 / Digital IXUS 75 / IXY Digital 90"PowerShot SD750 / Digital IXUS 75 / IXY Digital 90"349962240x2160000(long int)0x2160000PowerShot SD1000 / Digital IXUS 70 / IXY Digital 10"PowerShot SD1000 / Digital IXUS 70 / IXY Digital 10"351272960x2180000(long int)0x2180000PowerShot A550"PowerShot A550"351928320x2190000(long int)0x2190000PowerShot A450"PowerShot A450"358481920x2230000(long int)0x2230000PowerShot G9"PowerShot G9"359137280x2240000(long int)0x2240000PowerShot A650 IS"PowerShot A650 IS"360448000x2260000(long int)0x2260000PowerShot A720 IS"PowerShot A720 IS"362414080x2290000(long int)0x2290000PowerShot SX100 IS"PowerShot SX100 IS"367001600x2300000(long int)0x2300000PowerShot SD950 IS / Digital IXUS 960 IS / IXY Digital 2000 IS"PowerShot SD950 IS / Digital IXUS 960 IS / IXY Digital 2000 IS"367656960x2310000(long int)0x2310000PowerShot SD870 IS / Digital IXUS 860 IS / IXY Digital 910 IS"PowerShot SD870 IS / Digital IXUS 860 IS / IXY Digital 910 IS"368312320x2320000(long int)0x2320000PowerShot SD890 IS / Digital IXUS 970 IS / IXY Digital 820 IS"PowerShot SD890 IS / Digital IXUS 970 IS / IXY Digital 820 IS"370933760x2360000(long int)0x2360000PowerShot SD790 IS / Digital IXUS 90 IS / IXY Digital 95 IS"PowerShot SD790 IS / Digital IXUS 90 IS / IXY Digital 95 IS"const char[60]char[60]371589120x2370000(long int)0x2370000PowerShot SD770 IS / Digital IXUS 85 IS / IXY Digital 25 IS"PowerShot SD770 IS / Digital IXUS 85 IS / IXY Digital 25 IS"372244480x2380000(long int)0x2380000PowerShot A590 IS"PowerShot A590 IS"372899840x2390000(long int)0x2390000PowerShot A580"PowerShot A580"378798080x2420000(long int)0x2420000PowerShot A470"PowerShot A470"379453440x2430000(long int)0x2430000PowerShot SD1100 IS / Digital IXUS 80 IS / IXY Digital 20 IS"PowerShot SD1100 IS / Digital IXUS 80 IS / IXY Digital 20 IS"const char[61]char[61]381419520x2460000(long int)0x2460000PowerShot SX1 IS"PowerShot SX1 IS"382074880x2470000(long int)0x2470000PowerShot SX10 IS"PowerShot SX10 IS"382730240x2480000(long int)0x2480000PowerShot A1000 IS"PowerShot A1000 IS"383385600x2490000(long int)0x2490000PowerShot G10"PowerShot G10"388628480x2510000(long int)0x2510000PowerShot A2000 IS"PowerShot A2000 IS"389283840x2520000(long int)0x2520000PowerShot SX110 IS"PowerShot SX110 IS"389939200x2530000(long int)0x2530000PowerShot SD990 IS / Digital IXUS 980 IS / IXY Digital 3000 IS"PowerShot SD990 IS / Digital IXUS 980 IS / IXY Digital 3000 IS"390594560x2540000(long int)0x2540000PowerShot SD880 IS / Digital IXUS 870 IS / IXY Digital 920 IS"PowerShot SD880 IS / Digital IXUS 870 IS / IXY Digital 920 IS"391249920x2550000(long int)0x2550000PowerShot E1"PowerShot E1"391905280x2560000(long int)0x2560000PowerShot D10"PowerShot D10"392560640x2570000(long int)0x2570000PowerShot SD960 IS / Digital IXUS 110 IS / IXY Digital 510 IS"PowerShot SD960 IS / Digital IXUS 110 IS / IXY Digital 510 IS"393216000x2580000(long int)0x2580000PowerShot A2100 IS"PowerShot A2100 IS"393871360x2590000(long int)0x2590000PowerShot A480"PowerShot A480"398458880x2600000(long int)0x2600000PowerShot SX200 IS"PowerShot SX200 IS"399114240x2610000(long int)0x2610000PowerShot SD970 IS / Digital IXUS 990 IS / IXY Digital 830 IS"PowerShot SD970 IS / Digital IXUS 990 IS / IXY Digital 830 IS"399769600x2620000(long int)0x2620000PowerShot SD780 IS / Digital IXUS 100 IS / IXY Digital 210 IS"PowerShot SD780 IS / Digital IXUS 100 IS / IXY Digital 210 IS"400424960x2630000(long int)0x2630000PowerShot A1100 IS"PowerShot A1100 IS"401080320x2640000(long int)0x2640000PowerShot SD1200 IS / Digital IXUS 95 IS / IXY Digital 110 IS"PowerShot SD1200 IS / Digital IXUS 95 IS / IXY Digital 110 IS"408944640x2700000(long int)0x2700000PowerShot G11"PowerShot G11"409600000x2710000(long int)0x2710000PowerShot SX120 IS"PowerShot SX120 IS"410255360x2720000(long int)0x2720000PowerShot S90"PowerShot S90"412221440x2750000(long int)0x2750000PowerShot SX20 IS"PowerShot SX20 IS"412876800x2760000(long int)0x2760000PowerShot SD980 IS / Digital IXUS 200 IS / IXY Digital 930 IS"PowerShot SD980 IS / Digital IXUS 200 IS / IXY Digital 930 IS"413532160x2770000(long int)0x2770000PowerShot SD940 IS / Digital IXUS 120 IS / IXY Digital 220 IS"PowerShot SD940 IS / Digital IXUS 120 IS / IXY Digital 220 IS"419430400x2800000(long int)0x2800000PowerShot A495"PowerShot A495"420085760x2810000(long int)0x2810000PowerShot A490"PowerShot A490"420741120x2820000(long int)0x2820000PowerShot A3100 IS / A3150 IS"PowerShot A3100 IS / A3150 IS"421396480x2830000(long int)0x2830000PowerShot A3000 IS"PowerShot A3000 IS"422051840x2840000(long int)0x2840000PowerShot SD1400 IS / IXUS 130 / IXY 400F"PowerShot SD1400 IS / IXUS 130 / IXY 400F"422707200x2850000(long int)0x2850000PowerShot SD1300 IS / IXUS 105 / IXY 200F"PowerShot SD1300 IS / IXUS 105 / IXY 200F"423362560x2860000(long int)0x2860000PowerShot SD3500 IS / IXUS 210 / IXY 10S"PowerShot SD3500 IS / IXUS 210 / IXY 10S"424017920x2870000(long int)0x2870000PowerShot SX210 IS"PowerShot SX210 IS"424673280x2880000(long int)0x2880000PowerShot SD4000 IS / IXUS 300 HS / IXY 30S"PowerShot SD4000 IS / IXUS 300 HS / IXY 30S"425328640x2890000(long int)0x2890000PowerShot SD4500 IS / IXUS 1000 HS / IXY 50S"PowerShot SD4500 IS / IXUS 1000 HS / IXY 50S"431226880x2920000(long int)0x2920000PowerShot G12"PowerShot G12"431882240x2930000(long int)0x2930000PowerShot SX30 IS"PowerShot SX30 IS"432537600x2940000(long int)0x2940000PowerShot SX130 IS"PowerShot SX130 IS"433192960x2950000(long int)0x2950000PowerShot S95"PowerShot S95"435159040x2980000(long int)0x2980000PowerShot A3300 IS"PowerShot A3300 IS"435814400x2990000(long int)0x2990000PowerShot A3200 IS"PowerShot A3200 IS"503316480x3000000(long int)0x3000000PowerShot ELPH 500 HS / IXUS 310 HS / IXY 31S"PowerShot ELPH 500 HS / IXUS 310 HS / IXY 31S"const char[46]char[46]503971840x3010000(long int)0x3010000PowerShot Pro90 IS"PowerShot Pro90 IS"503971850x3010001(long int)0x3010001PowerShot A800"PowerShot A800"504627200x3020000(long int)0x3020000PowerShot ELPH 100 HS / IXUS 115 HS / IXY 210F"PowerShot ELPH 100 HS / IXUS 115 HS / IXY 210F"505282560x3030000(long int)0x3030000PowerShot SX230 HS"PowerShot SX230 HS"505937920x3040000(long int)0x3040000PowerShot ELPH 300 HS / IXUS 220 HS / IXY 410F"PowerShot ELPH 300 HS / IXUS 220 HS / IXY 410F"506593280x3050000(long int)0x3050000PowerShot A2200"PowerShot A2200"507248640x3060000(long int)0x3060000PowerShot A1200"PowerShot A1200"507904000x3070000(long int)0x3070000PowerShot SX220 HS"PowerShot SX220 HS"508559360x3080000(long int)0x3080000PowerShot G1 X"PowerShot G1 X"509214720x3090000(long int)0x3090000PowerShot SX150 IS"PowerShot SX150 IS"513802240x3100000(long int)0x3100000PowerShot ELPH 510 HS / IXUS 1100 HS / IXY 51S"PowerShot ELPH 510 HS / IXUS 1100 HS / IXY 51S"514457600x3110000(long int)0x3110000PowerShot S100 (new)"PowerShot S100 (new)"515768320x3130000(long int)0x3130000PowerShot SX40 HS"PowerShot SX40 HS"515112960x3120000(long int)0x3120000PowerShot ELPH 310 HS / IXUS 230 HS / IXY 600F"PowerShot ELPH 310 HS / IXUS 230 HS / IXY 600F"516423680x3140000(long int)0x3140000IXY 32S"IXY 32S"517734400x3160000(long int)0x3160000PowerShot A1300"PowerShot A1300"518389760x3170000(long int)0x3170000PowerShot A810"PowerShot A810"519045120x3180000(long int)0x3180000PowerShot ELPH 320 HS / IXUS 240 HS / IXY 420F"PowerShot ELPH 320 HS / IXUS 240 HS / IXY 420F"519700480x3190000(long int)0x3190000PowerShot ELPH 110 HS / IXUS 125 HS / IXY 220F"PowerShot ELPH 110 HS / IXUS 125 HS / IXY 220F"524288000x3200000(long int)0x3200000PowerShot D20"PowerShot D20"524943360x3210000(long int)0x3210000PowerShot A4000 IS"PowerShot A4000 IS"525598720x3220000(long int)0x3220000PowerShot SX260 HS"PowerShot SX260 HS"526254080x3230000(long int)0x3230000PowerShot SX240 HS"PowerShot SX240 HS"526909440x3240000(long int)0x3240000PowerShot ELPH 530 HS / IXUS 510 HS / IXY 1"PowerShot ELPH 530 HS / IXUS 510 HS / IXY 1"527564800x3250000(long int)0x3250000PowerShot ELPH 520 HS / IXUS 500 HS / IXY 3"PowerShot ELPH 520 HS / IXUS 500 HS / IXY 3"528220160x3260000(long int)0x3260000PowerShot A3400 IS"PowerShot A3400 IS"528875520x3270000(long int)0x3270000PowerShot A2400 IS"PowerShot A2400 IS"529530880x3280000(long int)0x3280000PowerShot A2300"PowerShot A2300"536739840x3330000(long int)0x3330000PowerShot G15"PowerShot G15"537395200x3340000(long int)0x3340000PowerShot SX50"PowerShot SX50"538050560x3350000(long int)0x3350000PowerShot SX160 IS"PowerShot SX160 IS"538705920x3360000(long int)0x3360000PowerShot S110 (new)"PowerShot S110 (new)"539361280x3370000(long int)0x3370000PowerShot SX500 IS"PowerShot SX500 IS"540016640x3380000(long int)0x3380000PowerShot N"PowerShot N"540672000x3390000(long int)0x3390000IXUS 245 HS / IXY 430F"IXUS 245 HS / IXY 430F"545259520x3400000(long int)0x3400000PowerShot SX280 HS"PowerShot SX280 HS"545914880x3410000(long int)0x3410000PowerShot SX270 HS"PowerShot SX270 HS"546570240x3420000(long int)0x3420000PowerShot A3500 IS"PowerShot A3500 IS"547225600x3430000(long int)0x3430000PowerShot A2600"PowerShot A2600"548536320x3450000(long int)0x3450000PowerShot A1400"PowerShot A1400"549191680x3460000(long int)0x3460000PowerShot ELPH 130 IS / IXUS 140 / IXY 110F"PowerShot ELPH 130 IS / IXUS 140 / IXY 110F"549847040x3470000(long int)0x3470000PowerShot ELPH 115/120 IS / IXUS 132/135 / IXY 90F/100F"PowerShot ELPH 115/120 IS / IXUS 132/135 / IXY 90F/100F"551157760x3490000(long int)0x3490000PowerShot ELPH 330 HS / IXUS 255 HS / IXY 610F"PowerShot ELPH 330 HS / IXUS 255 HS / IXY 610F"556400640x3510000(long int)0x3510000PowerShot A2500"PowerShot A2500"558366720x3540000(long int)0x3540000PowerShot G16"PowerShot G16"559022080x3550000(long int)0x3550000PowerShot S120"PowerShot S120"559677440x3560000(long int)0x3560000PowerShot SX170 IS"PowerShot SX170 IS"560988160x3580000(long int)0x3580000PowerShot SX510 HS"PowerShot SX510 HS"561643520x3590000(long int)0x3590000PowerShot S200 (new)"PowerShot S200 (new)"566231040x3600000(long int)0x3600000IXY 620F"IXY 620F"566886400x3610000(long int)0x3610000PowerShot N100"PowerShot N100"568852480x3640000(long int)0x3640000PowerShot G1 X Mark II"PowerShot G1 X Mark II"569507840x3650000(long int)0x3650000PowerShot D30"PowerShot D30"570163200x3660000(long int)0x3660000PowerShot SX700 HS"PowerShot SX700 HS"570818560x3670000(long int)0x3670000PowerShot SX600 HS"PowerShot SX600 HS"571473920x3680000(long int)0x3680000PowerShot ELPH 140 IS / IXUS 150 / IXY 130"PowerShot ELPH 140 IS / IXUS 150 / IXY 130"572129280x3690000(long int)0x3690000PowerShot ELPH 135 / IXUS 145 / IXY 120"PowerShot ELPH 135 / IXUS 145 / IXY 120"576716800x3700000(long int)0x3700000PowerShot ELPH 340 HS / IXUS 265 HS / IXY 630"PowerShot ELPH 340 HS / IXUS 265 HS / IXY 630"577372160x3710000(long int)0x3710000PowerShot ELPH 150 IS / IXUS 155 / IXY 140"PowerShot ELPH 150 IS / IXUS 155 / IXY 140"579338240x3740000(long int)0x3740000EOS M3"EOS M3"579993600x3750000(long int)0x3750000PowerShot SX60 HS"PowerShot SX60 HS"580648960x3760000(long int)0x3760000PowerShot SX520 HS"PowerShot SX520 HS"581304320x3770000(long int)0x3770000PowerShot SX400 IS"PowerShot SX400 IS"581959680x3780000(long int)0x3780000PowerShot G7 X"PowerShot G7 X"582615040x3790000(long int)0x3790000PowerShot N2"PowerShot N2"587202560x3800000(long int)0x3800000PowerShot SX530 HS"PowerShot SX530 HS"588513280x3820000(long int)0x3820000PowerShot SX710 HS"PowerShot SX710 HS"589168640x3830000(long int)0x3830000PowerShot SX610 HS"PowerShot SX610 HS"589824000x3840000(long int)0x3840000EOS M10"EOS M10"590479360x3850000(long int)0x3850000PowerShot G3 X"PowerShot G3 X"591134720x3860000(long int)0x3860000PowerShot ELPH 165 HS / IXUS 165 / IXY 160"PowerShot ELPH 165 HS / IXUS 165 / IXY 160"591790080x3870000(long int)0x3870000PowerShot ELPH 160 / IXUS 160"PowerShot ELPH 160 / IXUS 160"592445440x3880000(long int)0x3880000PowerShot ELPH 350 HS / IXUS 275 HS / IXY 640"PowerShot ELPH 350 HS / IXUS 275 HS / IXY 640"593100800x3890000(long int)0x3890000PowerShot ELPH 170 IS / IXUS 170"PowerShot ELPH 170 IS / IXUS 170"598343680x3910000(long int)0x3910000PowerShot SX410 HS"PowerShot SX410 HS"599654400x3930000(long int)0x3930000PowerShot G9 X"PowerShot G9 X"600309760x3940000(long int)0x3940000EOS M5"EOS M5"600965120x3950000(long int)0x3950000PowerShot G5 X"PowerShot G5 X"602275840x3970000(long int)0x3970000PowerShot G7 X Mark II"PowerShot G7 X Mark II"602931200x3980000(long int)0x3980000EOS M100"EOS M100"603586560x3990000(long int)0x3990000PowerShot ELPH 360 HS / IXUS 285 HS / IXY 650"PowerShot ELPH 360 HS / IXUS 285 HS / IXY 650"671744000x4010000(long int)0x4010000PowerShot SX540 HS"PowerShot SX540 HS"672399360x4020000(long int)0x4020000PowerShot SX420 IS"PowerShot SX420 IS"673054720x4030000(long int)0x4030000PowerShot ELPH 190 IS / IXUS 180 / IXY 190"PowerShot ELPH 190 IS / IXUS 180 / IXY 190"673710080x4040000(long int)0x4040000PowerShot G1"PowerShot G1"673710090x4040001(long int)0x4040001IXY 180"IXY 180"674365440x4050000(long int)0x4050000PowerShot SX720 HS"PowerShot SX720 HS"675020800x4060000(long int)0x4060000PowerShot SX620 HS"PowerShot SX620 HS"675676160x4070000(long int)0x4070000EOS M6"EOS M6"681574400x4100000(long int)0x4100000PowerShot G9 X Mark II"PowerShot G9 X Mark II"1009254400x6040000(long int)0x6040000PowerShot S100 / Digital IXUS / IXY Digital"PowerShot S100 / Digital IXUS / IXY Digital"10742554750x4007d673(long int)0x4007d673DC19/DC21/DC22"DC19/DC21/DC22"10742554760x4007d674(long int)0x4007d674XH A1"XH A1"10742554770x4007d675(long int)0x4007d675HV10"HV10"10742554780x4007d676(long int)0x4007d676MD130/MD140/MD150/MD160/ZR850"MD130/MD140/MD150/MD160/ZR850"10742557350x4007d777(long int)0x4007d777DC50"DC50"10742557360x4007d778(long int)0x4007d778HV20"HV20"10742557370x4007d779(long int)0x4007d779DC211"DC211"10742557380x4007d77a(long int)0x4007d77aHG10"HG10"10742557390x4007d77b(long int)0x4007d77bHR10"HR10"10742557400x4007d77c(long int)0x4007d77cMD255/ZR950"MD255/ZR950"10742559000x4007d81c(long int)0x4007d81cHF11"HF11"10742559920x4007d878(long int)0x4007d878HV30"HV30"10742559960x4007d87c(long int)0x4007d87cXH A1S"XH A1S"10742559980x4007d87e(long int)0x4007d87eDC301/DC310/DC311/DC320/DC330"DC301/DC310/DC311/DC320/DC330"10742559990x4007d87f(long int)0x4007d87fFS100"FS100"10742560000x4007d880(long int)0x4007d880HF10"HF10"10742560020x4007d882(long int)0x4007d882HG20/HG21"HG20/HG21"10742561650x4007d925(long int)0x4007d925HF21"HF21"10742561660x4007d926(long int)0x4007d926HF S11"HF S11"10742562480x4007d978(long int)0x4007d978HV40"HV40"10742562630x4007d987(long int)0x4007d987DC410/DC411/DC420"DC410/DC411/DC420"10742562640x4007d988(long int)0x4007d988FS19/FS20/FS21/FS22/FS200"FS19/FS20/FS21/FS22/FS200"10742562650x4007d989(long int)0x4007d989HF20/HF200"HF20/HF200"10742562660x4007d98a(long int)0x4007d98aHF S10/S100"HF S10/S100"10742565260x4007da8e(long int)0x4007da8eHF R10/R16/R17/R18/R100/R106"HF R10/R16/R17/R18/R100/R106"10742565270x4007da8f(long int)0x4007da8fHF M30/M31/M36/M300/M306"HF M30/M31/M36/M300/M306"10742565280x4007da90(long int)0x4007da90HF S20/S21/S200"HF S20/S21/S200"10742565300x4007da92(long int)0x4007da92FS31/FS36/FS37/FS300/FS305/FS306/FS307"FS31/FS36/FS37/FS300/FS305/FS306/FS307"10742573210x4007dda9(long int)0x4007dda9HF G25"HF G25"10742578440x4007dfb4(long int)0x4007dfb4XC10"XC10"21474836490x80000001(long int)0x80000001EOS-1D"EOS-1D"21474840070x80000167(long int)0x80000167EOS-1DS"EOS-1DS"21474840080x80000168(long int)0x80000168EOS 10D"EOS 10D"21474840090x80000169(long int)0x80000169EOS-1D Mark III"EOS-1D Mark III"21474840160x80000170(long int)0x80000170EOS Digital Rebel / 300D / Kiss Digital"EOS Digital Rebel / 300D / Kiss Digital"21474840200x80000174(long int)0x80000174EOS-1D Mark II"EOS-1D Mark II"21474840210x80000175(long int)0x80000175EOS 20D"EOS 20D"21474840220x80000176(long int)0x80000176EOS Digital Rebel XSi / 450D / Kiss X2"EOS Digital Rebel XSi / 450D / Kiss X2"21474840400x80000188(long int)0x80000188EOS-1Ds Mark II"EOS-1Ds Mark II"21474840410x80000189(long int)0x80000189EOS Digital Rebel XT / 350D / Kiss Digital N"EOS Digital Rebel XT / 350D / Kiss Digital N"21474840480x80000190(long int)0x80000190EOS 40D"EOS 40D"21474841790x80000213(long int)0x80000213EOS 5D"EOS 5D"21474841810x80000215(long int)0x80000215EOS-1Ds Mark III"EOS-1Ds Mark III"21474841840x80000218(long int)0x80000218EOS 5D Mark II"EOS 5D Mark II"21474841850x80000219(long int)0x80000219WFT-E1"WFT-E1"21474842100x80000232(long int)0x80000232EOS-1D Mark II N"EOS-1D Mark II N"21474842120x80000234(long int)0x80000234EOS 30D"EOS 30D"21474842140x80000236(long int)0x80000236EOS Digital Rebel XTi / 400D / Kiss Digital X"EOS Digital Rebel XTi / 400D / Kiss Digital X"21474842250x80000241(long int)0x80000241WFT-E2"WFT-E2"21474842300x80000246(long int)0x80000246WFT-E3"WFT-E3"21474842400x80000250(long int)0x80000250EOS 7D"EOS 7D"21474842420x80000252(long int)0x80000252EOS Rebel T1i / 500D / Kiss X3"EOS Rebel T1i / 500D / Kiss X3"21474842440x80000254(long int)0x80000254EOS Rebel XS / 1000D / Kiss F"EOS Rebel XS / 1000D / Kiss F"21474842570x80000261(long int)0x80000261EOS 50D"EOS 50D"21474842650x80000269(long int)0x80000269EOS-1D X"EOS-1D X"21474842720x80000270(long int)0x80000270EOS Rebel T2i / 550D / Kiss X4"EOS Rebel T2i / 550D / Kiss X4"21474842730x80000271(long int)0x80000271WFT-E4"WFT-E4"21474842750x80000273(long int)0x80000273WFT-E5"WFT-E5"21474842890x80000281(long int)0x80000281EOS-1D Mark IV"EOS-1D Mark IV"21474842930x80000285(long int)0x80000285EOS 5D Mark III"EOS 5D Mark III"21474842940x80000286(long int)0x80000286EOS Rebel T3i / 600D / Kiss X5"EOS Rebel T3i / 600D / Kiss X5"21474842950x80000287(long int)0x80000287EOS 60D"EOS 60D"21474842960x80000288(long int)0x80000288EOS Rebel T3 / 1100D / Kiss X50"EOS Rebel T3 / 1100D / Kiss X50"21474842970x80000289(long int)0x80000289EOS 7D Mark II"EOS 7D Mark II"21474843110x80000297(long int)0x80000297WFT-E2 II"WFT-E2 II"21474843120x80000298(long int)0x80000298WFT-E4 II"WFT-E4 II"21474844170x80000301(long int)0x80000301EOS Rebel T4i / 650D / Kiss X6i"EOS Rebel T4i / 650D / Kiss X6i"21474844180x80000302(long int)0x80000302EOS 6D"EOS 6D"21474844520x80000324(long int)0x80000324EOS-1D C"EOS-1D C"21474844530x80000325(long int)0x80000325EOS 70D"EOS 70D"21474844540x80000326(long int)0x80000326EOS Rebel T5i / 700D / Kiss X7i"EOS Rebel T5i / 700D / Kiss X7i"21474844550x80000327(long int)0x80000327EOS Rebel T5 / 1200D / Kiss X70"EOS Rebel T5 / 1200D / Kiss X70"21474844560x80000328(long int)0x80000328EOS-1D X MARK II"EOS-1D X MARK II"21474844650x80000331(long int)0x80000331EOS M"EOS M"21474844960x80000350(long int)0x80000350EOS 80D"EOS 80D"21474845010x80000355(long int)0x80000355EOS M2"EOS M2"21474844860x80000346(long int)0x80000346EOS Rebel SL1 / 100D / Kiss X7"EOS Rebel SL1 / 100D / Kiss X7"21474844870x80000347(long int)0x80000347EOS Rebel T6s / 760D / 8000D"EOS Rebel T6s / 760D / 8000D"21474844890x80000349(long int)0x80000349EOS 5D Mark IV"EOS 5D Mark IV"21474845460x80000382(long int)0x80000382EOS 5DS"EOS 5DS"21474845630x80000393(long int)0x80000393EOS Rebel T6i / 750D / Kiss X8i"EOS Rebel T6i / 750D / Kiss X8i"21474846730x80000401(long int)0x80000401EOS 5DS R"EOS 5DS R"21474846760x80000404(long int)0x80000404EOS Rebel T6 / 1300D / Kiss X80"EOS Rebel T6 / 1300D / Kiss X80"21474846770x80000405(long int)0x80000405EOS Rebel T7i / 800D / Kiss X9i"EOS Rebel T7i / 800D / Kiss X9i"21474846800x80000408(long int)0x80000408EOS 77D / 9000D"EOS 77D / 9000D"canonModelIdcanonOffOn"ToneCurve""Tone curve""SharpnessFrequency""Sharpness frequency""SensorRedLevel""Sensor red level""SensorBlueLevel""Sensor blue level""WhiteBalanceRed""White balance red""WhiteBalanceBlue""White balance blue""WhiteBalance""ColorTemperature""Color Temperature""PictureStyle""Picture style""DigitalGain""Digital gain""WBShiftAB""WBShift AB""WBShiftGM""WB Shift GM""Unknown Canon Processing Info tag"ToneCurveTone curveSharpnessFrequencySharpness frequencySensorRedLevelSensor red levelSensorBlueLevelSensor blue levelWhiteBalanceRedWhite balance redWhiteBalanceBlueWhite balance blueWhiteBalanceColorTemperatureColor TemperaturePictureStylePicture styleDigitalGainDigital gainWBShiftABWBShift ABWBShiftGMWB Shift GM(UnknownCanonPrTag)"(UnknownCanonPrTag)"Unknown Canon Processing Info tag"Panorama Frame""Panorama frame number""Panorama Direction""Panorama direction""Unknown Canon Panorama tag"PanoramaFrame"PanoramaFrame"Panorama FramePanorama frame numberPanoramaDirection"PanoramaDirection"Panorama DirectionPanorama direction(UnknownCanonCs2Tag)"(UnknownCanonCs2Tag)"Unknown Canon Panorama tag"File Number""Bracket Mode""Bracket Value""Bracket Shot Number""Raw Jpg Quality""Raw Jpg Size""Noise Reduction""WB Bracket Mode""WB Bracket Value AB""WB Bracket Value GM""Filter Effect""Toning Effect""Macro Magnification""Macro magnification""Live View Shooting""Live view shooting""Focus Distance Upper""Focus Distance Lower""Flash Exposure Lock""Flash exposure lock""Unknown Canon File Info tag"FileNumber"FileNumber"File NumberBracketMode"BracketMode"Bracket ModeBracketValue"BracketValue"Bracket ValueBracketShotNumber"BracketShotNumber"Bracket Shot NumberRawJpgQuality"RawJpgQuality"Raw Jpg QualityRawJpgSize"RawJpgSize"Raw Jpg SizeNoiseReduction"NoiseReduction"Noise ReductionWBBracketMode"WBBracketMode"WB Bracket ModeWBBracketValueAB"WBBracketValueAB"WB Bracket Value ABWBBracketValueGM"WBBracketValueGM"WB Bracket Value GMFilterEffect"FilterEffect"Filter EffectToningEffect"ToningEffect"Toning EffectMacroMagnification"MacroMagnification"Macro MagnificationMacro magnificationLiveViewShooting"LiveViewShooting"Live View ShootingLive view shootingFocusDistanceUpper"FocusDistanceUpper"Focus Distance UpperFocusDistanceLower"FocusDistanceLower"Focus Distance LowerFlashExposureLock"FlashExposureLock"Flash Exposure LockFlash exposure lock(UnknownCanonFiTag)"(UnknownCanonFiTag)"Unknown Canon File Info tag"Time zone offset""Time zone offset in minutes""Time zone city""Daylight Savings""Daylight Saving Time""Unknown Canon Time Info tag"TimeZone"TimeZone"Time zone offsetTime zone offset in minutesTimeZoneCity"TimeZoneCity"Time zone cityDaylightSavings"DaylightSavings"Daylight SavingsDaylight Saving Time(UnknownCanonTiTag)"(UnknownCanonTiTag)"Unknown Canon Time Info tag"Image Width""Image width""Image Height""Image height""Image Width As Shot""Image width (as shot)""Image Height As Shot""Image height (as shot)""AF Points Used""AF points used""AF Points Used 20D""AF points used (20D)""Unknown Canon Picture Info tag"ImageWidth"ImageWidth"Image WidthImage widthImageHeight"ImageHeight"Image HeightImage heightImageWidthAsShot"ImageWidthAsShot"Image Width As ShotImage width (as shot)ImageHeightAsShot"ImageHeightAsShot"Image Height As ShotImage height (as shot)AFPointsUsed"AFPointsUsed"AF Points UsedAF points usedAFPointsUsed20D"AFPointsUsed20D"AF Points Used 20DAF points used (20D)(UnknownCanonPiTag)"(UnknownCanonPiTag)"Unknown Canon Picture Info tag"Long exposure noise reduction""Shutter Ae Lock""Shutter/AE lock buttons""Mirror Lockup""Mirror lockup""Exposure Level Increments""Tv/Av and exposure level""AF Assist""AF assist light""Flash Sync Speed Av""Shutter speed in Av mode""AEB Sequence""AEB sequence/auto cancellation""Shutter Curtain Sync""Shutter curtain sync""Lens AF Stop Button""Lens AF stop button Fn. Switch""Fill Flash Auto Reduction""Auto reduction of fill flash""Menu Button Return""Menu button return position""Set Button Function""SET button func. when shooting""Sensor Cleaning""Sensor cleaning""Superimposed Display""Superimposed display""Shutter Release No CF Card""Shutter Release W/O CF Card""Unknown Canon Custom Function tag"Long exposure noise reductionShutterAeLock"ShutterAeLock"Shutter Ae LockShutter/AE lock buttonsMirrorLockup"MirrorLockup"Mirror LockupMirror lockupExposureLevelIncrements"ExposureLevelIncrements"Exposure Level IncrementsTv/Av and exposure levelAFAssist"AFAssist"AF AssistAF assist lightFlashSyncSpeedAv"FlashSyncSpeedAv"Flash Sync Speed AvShutter speed in Av modeAEBSequence"AEBSequence"AEB SequenceAEB sequence/auto cancellationShutterCurtainSync"ShutterCurtainSync"Shutter Curtain SyncShutter curtain syncLensAFStopButton"LensAFStopButton"Lens AF Stop ButtonLens AF stop button Fn. SwitchFillFlashAutoReduction"FillFlashAutoReduction"Fill Flash Auto ReductionAuto reduction of fill flashMenuButtonReturn"MenuButtonReturn"Menu Button ReturnMenu button return positionSetButtonFunction"SetButtonFunction"Set Button FunctionSET button func. when shootingSensorCleaning"SensorCleaning"Sensor CleaningSensor cleaningSuperimposedDisplay"SuperimposedDisplay"Superimposed DisplaySuperimposed displayShutterReleaseNoCFCard"ShutterReleaseNoCFCard"Shutter Release No CF CardShutter Release W/O CF Card(UnknownCanonCfTag)"(UnknownCanonCfTag)"Unknown Canon Custom Function tag"ISO Speed Used""ISO speed used""Measured EV""Target Aperture""Target Shutter Speed""Target shutter speed""White Balance""White balance setting""Sequence""Sequence number (if in a continuous burst)""AF Point Used""AF point used""Flash Bias""Subject Distance""Aperture Value""Shutter Speed Value""Shutter speed""Measured EV 2""Unknown Canon Camera Settings 1 tag""0x0001"ISOSpeed"ISOSpeed"ISO Speed UsedISO speed usedMeasuredEV"MeasuredEV"Measured EVTargetAperture"TargetAperture"Target ApertureTargetShutterSpeed"TargetShutterSpeed"Target Shutter SpeedTarget shutter speed"0x0006"White BalanceWhite balance setting"0x0008"SequenceSequence number (if in a continuous burst)"0x000a""0x000b""0x000c""0x000d"AFPointUsed"AFPointUsed"AF Point UsedAF point usedFlashBias"FlashBias"Flash Bias"0x0010""0x0011""0x0012"SubjectDistance"SubjectDistance"Subject Distance"0x0014"ApertureValue"ApertureValue"Aperture ValueShutterSpeedValue"ShutterSpeedValue"Shutter Speed ValueShutter speedMeasuredEV2"MeasuredEV2"Measured EV 2"0x0018""0x0019""0x001a"(UnknownCanonCsTag)"(UnknownCanonCsTag)"Unknown Canon Camera Settings 1 tag"Selftimer""Self timer""Quality""Flash Mode""Flash mode setting""Drive Mode""Drive mode setting""Focus Mode""Focus mode setting""Image Size""Easy Mode""Easy shooting mode""Digital Zoom""Digital zoom""Contrast setting""Saturation setting""Sharpness setting""ISO Speed Mode""ISO speed setting""Metering Mode""Metering mode setting""Focus Type""Focus type setting""AF point selected""Exposure Program""Exposure mode setting""Lens Type""Lens type""Lens""'long' and 'short' focal length of lens (in 'focal units') and 'focal units' per mm""Short Focal""Short focal""Focal Units""Focal units""Max Aperture""Max aperture""Min Aperture""Min aperture""Flash Activity""Flash activity""Flash Details""Flash details""Focus Continuous""Focus continuous setting""AESetting""AE setting""Image Stabilization""Image stabilization""Display Aperture""Display aperture""Zoom Source Width""Zoom source width""Zoom Target Width""Zoom target width""Spot Metering Mode""Spot metering mode""Photo Effect""Photo effect""Manual Flash Output""Manual flash output""Color Tone""Color tone""SRAW Quality Tone""SRAW quality"SelftimerSelf timerQualityFlashMode"FlashMode"Flash ModeFlash mode settingDriveMode"DriveMode"Drive ModeDrive mode settingFocusMode"FocusMode"Focus ModeFocus mode setting"0x0009"ImageSize"ImageSize"Image SizeEasyMode"EasyMode"Easy ModeEasy shooting modeDigitalZoom"DigitalZoom"Digital ZoomDigital zoomContrast settingSaturation settingSharpness settingISO Speed ModeISO speed settingMeteringMode"MeteringMode"Metering ModeMetering mode settingFocusType"FocusType"Focus TypeFocus type settingAFPoint"AFPoint"AF point selectedExposureProgram"ExposureProgram"Exposure ProgramExposure mode setting"0x0015"LensType"LensType"Lens TypeLens typeLens'long' and 'short' focal length of lens (in 'focal units') and 'focal units' per mmconst char[84]char[84]ShortFocal"ShortFocal"Short FocalShort focalFocalUnits"FocalUnits"Focal UnitsFocal unitsMaxAperture"MaxAperture"Max ApertureMax apertureMinAperture"MinAperture"Min ApertureMin apertureFlashActivity"FlashActivity"Flash ActivityFlash activityFlashDetails"FlashDetails"Flash DetailsFlash details"0x001e""0x001f"FocusContinuous"FocusContinuous"Focus ContinuousFocus continuous settingAESettingAE setting0x0022ImageStabilization"ImageStabilization"Image StabilizationImage stabilization0x0023DisplayAperture"DisplayAperture"Display ApertureDisplay aperture0x0024ZoomSourceWidth"ZoomSourceWidth"Zoom Source WidthZoom source width0x0025ZoomTargetWidth"ZoomTargetWidth"Zoom Target WidthZoom target width0x0026"0x0026"0x0027SpotMeteringMode"SpotMeteringMode"Spot Metering ModeSpot metering mode0x0028PhotoEffect"PhotoEffect"Photo EffectPhoto effect0x0029ManualFlashOutput"ManualFlashOutput"Manual Flash OutputManual flash output0x002aColorTone"ColorTone"Color ToneColor tone0x002eSRAWQuality"SRAWQuality"SRAW Quality ToneSRAW quality"Camera Settings""Various camera settings""Focal Length""Shot Info""Shot information""Panorama""Image Type""Image type""Firmware Version""Firmware version""File number""Owner Name""Serial Number""Camera Info""Camera info""Custom Functions""ModelID""Model ID""Picture Info""Picture info""Thumbnail Image Valid Area""Thumbnail image valid area""Serial Number Format""Serial number format""AF Info""AF info""Time Info""Time zone information""Original Decision Data Offset""Original decision data offset""White Balance Table""White balance table""Lens Model""Lens model""Internal Serial Number""Internal serial number""Dust Removal Data""Dust removal data""Custom functions""Processing Info""Processing info""Measured Color""Measured color""ColorSpace""VRD Offset""VRD offset""Sensor Info""Sensor info""Color Data""Color data""Unknown CanonMakerNote tag""0x0000"CameraSettings"CameraSettings"Camera SettingsVarious camera settingsFocalLength"FocalLength"Focal Length"0x0003"ShotInfo"ShotInfo"Shot InfoShot informationPanorama"ImageType"Image TypeImage typeFirmwareVersion"FirmwareVersion"Firmware VersionFirmware versionFile numberOwnerName"OwnerName"Owner NameSerialNumber"SerialNumber"Serial NumberCameraInfo"CameraInfo"Camera InfoCamera infoCustomFunctions"CustomFunctions"Custom FunctionsModelIDModel IDPictureInfo"PictureInfo"Picture InfoPicture infoThumbnailImageValidArea"ThumbnailImageValidArea"Thumbnail Image Valid AreaThumbnail image valid areaSerialNumberFormat"SerialNumberFormat"Serial Number FormatSerial number formatSuperMacro"SuperMacro"AFInfo"AFInfo"AF InfoAF info0x0035TimeInfo"TimeInfo"Time InfoTime zone information0x0083OriginalDecisionDataOffset"OriginalDecisionDataOffset"Original Decision Data OffsetOriginal decision data offset0x00a4WhiteBalanceTable"WhiteBalanceTable"White Balance TableWhite balance table0x0095LensModel"LensModel"Lens ModelLens model0x0096InternalSerialNumber"InternalSerialNumber"Internal Serial NumberInternal serial number0x0097DustRemovalData"DustRemovalData"Dust Removal DataDust removal data0x0099Custom functions0x00a0ProcessingInfo"ProcessingInfo"Processing InfoProcessing info0x00aaMeasuredColor"MeasuredColor"Measured ColorMeasured color0x00b4ColorSpace0x00b5"0x00b5"0x00c0"0x00c0"0x00c1"0x00c1"0x00d0VRDOffset"VRDOffset"VRD OffsetVRD offset0x00e0SensorInfo"SensorInfo"Sensor InfoSensor infoColorData"ColorData"Color DataColor data(UnknownCanonMakerNoteTag)"(UnknownCanonMakerNoteTag)"Unknown CanonMakerNote tag// convert 1/3 (0x0c) and 2/3 (0x14) codes// remove fraction// temporarily remove sign// Todo: determine unit// see also printSi0x0017// exposure of 30s which is 5 EV below 1s// It might be explained by the fakt, that most Canons have a longest// The offset of '5' seems to be ok for most Canons (see Exiftool)// Ported from Exiftool by Will Stokes// #1034//! printCsLensType by searching the config file if necessary// lens + 2x TC// lens + 1.4x TC// just lens//! printCsLensByFocalLengthTC to human readable string//! printCsLensByFocalLength to human readable string//! printCsLensByFocalLengthAndMaxAperture to human readable string//! convertFocalLength to a human readable string//! extractLensFocalLength from metadata//! Compare tag details with a lens entry//!< Aperture//!< Focal length as a string//!< Maximum focal length//!< Mininum focal length//!< Lens type//! Helper structure// F2.8// 1140// Ported from Exiftool// Canon Time Info Tag//! canonTimeZoneCity - array of cityID/cityName used by Canon// Canon Processing Info Tag//! PictureStyle Values//! Sharpness Frequency Values//! Tone Curve Values// End of list marker// Canon File Info Tag//! ToningEffect, tag 0x000e//! FilterEffect, tag 0x000e//! WBBracketMode, tag 0x0009//! NoiseReduction, tag 0x0008//! RawJpgSize, tag 0x0007//! BracketMode, tag 0x0003// Canon Picture Info Tag//! AFPointsUsed20D, tag 0x001a//! AFPointsUsed, tag 0x0016// Canon Custom Function Tag Info// Canon Panorama Info//! PanoramaDirection, tag 0x0005// Canon Shot Info Tag//! FlashBias, tag 0x000f//! AFPointUsed, tag 0x000e//! WhiteBalance, multiple tags// Canon Camera Settings Tag Info//! SRAWQuality, tag 0x002e//! ManualFlashOutput, tag 0x0029// To silence compiler warning//! PhotoEffect, tag 0x0028//! SpotMeteringMode, tag 0x0027//! ImageStabilization, tag 0x0022//! AESetting, tag 0x0021//! FocusContinuous, tag 0x0020//! FlashDetails, tag 0x001d//! FlashActivity, tag 0x001c// not tested// works partly//! List of lens ids which require special treatment with the medicine//! Comparison operator for find template//!< Pretty-print function//!< Lens id//! A lens id and a pretty-print function for special treatment of the id.// 1// 0// 2//{ 254, "Tamron SP 90mm f/2.8 Di VC USD Macro 1:1 F017"              }, // 2 model released in 2016//{ 254, "Tamron SP 90mm f/2.8 Di VC USD Macro 1:1 F004"              }, // 1 older model// 5// 4// 3// 6// 7// 16// 15// 14// 13// 12// 11// 10// 9// 8//! LensType, tag 0x0016//! ExposureProgram, tag 0x0014//! AFPoint, tag 0x0013//! FocusType, tag 0x0012//! MeteringMode, tag 0x0011//! ISOSpeeds, tag 0x0010//! Contrast, Saturation Sharpness, tags 0x000d, 0x000e, 0x000f//! DigitalZoom, tag 0x000c//! EasyMode, tag 0x000b//! ImageSize, tag 0x000a//! FocusMode, tag 0x0007//! DriveMode, tag 0x0005//! FlashMode, tag 0x0004//! Quality, tag 0x0003//! Macro, tag 0x0001// Canon MakerNote Tag Info//! ColorSpace, tag 0x00b4//! SuperMacro, tag 0x001a//! SerialNumberFormat, tag 0x0015//! ModelId, tag 0x0010//! Special treatment pretty-print function for non-unique lens ids.//! OffOn, multiple tags/*
  File:      canonmn.cpp
  Author(s): Andreas Huggel (ahu) <ahuggel@gmx.net>
             David Cannings (dc) <david@edeca.net>
             Andi Clemens (ac) <andi.clemens@gmx.net>
 */is_floating_point<_A1>enable_if<value, bool>enable_if<<expression>, bool>numeric_limits<_IntT>numeric_limits<_FloatT>is_integral<_A1>is_signed<_A1>enable_if<value, int>is_arithmetic<_A1>numeric_limits<_A1>is_arithmetic<_A2>enable_if<value, double>__promote<_A1, _A2, void>is_arithmetic<_A3>enable_if<value, long long>enable_if<value, long>list<Exifdatum, allocator<Exifdatum>>allocator<Exifdatum> &__list_node_base<Exifdatum, void *> *__list_node<Exifdatum, void *> *is_same<_Alloc, type>reverse_iterator<iterator>reverse_iterator<const_iterator>__allocator_destructor<__node_allocator>unique_ptr<__node, __allocator_destructor<__node_allocator>>__list_node_base<_Tp, void_pointer>__list_iterator<_Tp, void_pointer>__list_const_iterator<_Tp, void_pointer>__list_node<_Tp, void_pointer>allocator_traits<type>__list_node_pointer_traits<_Tp, void_pointer>pointer_traits<__base_pointer>__compressed_pair<size_type, type>pointer_traits<type>__list_iterator<Exifdatum, void *>__list_iterator<Exifdatum, void *> *__list_const_iterator<Exifdatum, void *>__list_const_iterator<Exifdatum, void *> *__is_cpp17_input_iterator<_InpIter>enable_if<value, void>auto_ptr<TiffComponent>stack<TiffPathItem, deque<TiffPathItem, allocator<TiffPathItem>>>vector<IfdId, allocator<IfdId>>stack<T1, _C1>is_same<value_type, _Tp>__compressed_pair<size_type, _Allocator>__split_buffer<pointer, type>allocator_traits<_Allocator>__deque_iterator<_Tp, pointer, _Tp &, pointer, difference_type, value>__deque_iterator<_Tp, const_pointer, const _Tp &, const_pointer, difference_type, value>__deque_base_common<true>__deque_base_common<true> &const __deque_base_common<true>const __deque_base_common<true> &__deque_iterator<value_type, _Pp, _Rp, _MP, difference_type, _BS>__deque_iterator<_V2, _P2, _R2, _M2, _D2, _B2>__deque_iterator<_V1, _P1, _R1, _M1, _D1, _B1>__is_cpp17_random_access_iterator<_RAIter>__is_cpp17_input_iterator<_InputIter>__is_cpp17_random_access_iterator<_InputIter>__is_cpp17_forward_iterator<_InputIter>__is_cpp17_forward_iterator<_ForwardIterator>__is_cpp17_bidirectional_iterator<_ForwardIterator>__is_cpp17_bidirectional_iterator<_BiIter>__is_cpp17_forward_iterator<_InpIter>__is_cpp17_forward_iterator<_ForIter>auto_ptr<ExifKey>auto_ptr<ExifKey> &auto_ptr<Key>vector<T, allocator<T>>auto_ptr<ValueType<T>>auto_ptr_ref<DataValue>auto_ptr_ref<DataValue> &const auto_ptr_ref<DataValue>const auto_ptr_ref<DataValue> &auto_ptr_ref<StringValueBase>auto_ptr_ref<StringValueBase> &const auto_ptr_ref<StringValueBase>const auto_ptr_ref<StringValueBase> &auto_ptr_ref<StringValue>auto_ptr_ref<StringValue> &const auto_ptr_ref<StringValue>const auto_ptr_ref<StringValue> &auto_ptr_ref<AsciiValue>auto_ptr_ref<AsciiValue> &const auto_ptr_ref<AsciiValue>const auto_ptr_ref<AsciiValue> &auto_ptr_ref<CommentValue>auto_ptr_ref<CommentValue> &const auto_ptr_ref<CommentValue>const auto_ptr_ref<CommentValue> &auto_ptr_ref<DateValue>auto_ptr_ref<DateValue> &const auto_ptr_ref<DateValue>const auto_ptr_ref<DateValue> &auto_ptr_ref<TimeValue>auto_ptr_ref<TimeValue> &const auto_ptr_ref<TimeValue>const auto_ptr_ref<TimeValue> &__vector_base<pair<unsigned int, unsigned int>, allocator<pair<unsigned int, unsigned int>>>__vector_base<pair<unsigned int, unsigned int>, allocator<pair<unsigned int, unsigned int>>> &const __vector_base<pair<unsigned int, unsigned int>, allocator<pair<unsigned int, unsigned int>>>const __vector_base<pair<unsigned int, unsigned int>, allocator<pair<unsigned int, unsigned int>>> &pair<unsigned int, unsigned int> *vector<pair<unsigned int, unsigned int>, allocator<pair<unsigned int, unsigned int>>>allocator<pair<unsigned int, unsigned int>> &__vector_base<pair<int, int>, allocator<pair<int, int>>>__vector_base<pair<int, int>, allocator<pair<int, int>>> &const __vector_base<pair<int, int>, allocator<pair<int, int>>>const __vector_base<pair<int, int>, allocator<pair<int, int>>> &pair<int, int> *vector<pair<int, int>, allocator<pair<int, int>>>allocator<pair<int, int>> &__vector_base<float, allocator<float>>__vector_base<float, allocator<float>> &const __vector_base<float, allocator<float>>const __vector_base<float, allocator<float>> &vector<float, allocator<float>>allocator<float> &__vector_base<double, allocator<double>>__vector_base<double, allocator<double>> &const __vector_base<double, allocator<double>>const __vector_base<double, allocator<double>> &vector<double, allocator<double>>allocator<double> &auto_ptr_ref<Value>auto_ptr_ref<Value> &const auto_ptr_ref<Value>const auto_ptr_ref<Value> &auto_ptr<Value>auto_ptr<DataValue>auto_ptr<DataValue> &auto_ptr<StringValueBase>auto_ptr<StringValueBase> &auto_ptr<StringValue>auto_ptr<StringValue> &auto_ptr<AsciiValue>auto_ptr<AsciiValue> &auto_ptr<CommentValue>auto_ptr<CommentValue> &auto_ptr<XmpValue>auto_ptr<XmpTextValue>auto_ptr<XmpArrayValue>vector<basic_string<char, char_traits<char>, allocator<char>>, allocator<basic_string<char, char_traits<char>, allocator<char>>>>allocator<basic_string<char, char_traits<char>, allocator<char>>> &auto_ptr<LangAltValue>map<basic_string<char, char_traits<char>, allocator<char>>, basic_string<char, char_traits<char>, allocator<char>>, LangAltValueComparator, allocator<pair<const basic_string<char, char_traits<char>, allocator<char>>, basic_string<char, char_traits<char>, allocator<char>>>>>allocator<pair<const basic_string<char, char_traits<char>, allocator<char>>, basic_string<char, char_traits<char>, allocator<char>>>> &__tree_node<__value_type<basic_string<char, char_traits<char>, allocator<char>>, basic_string<char, char_traits<char>, allocator<char>>>, void *> *pair<const basic_string<char, char_traits<char>, allocator<char>>, basic_string<char, char_traits<char>, allocator<char>>> *pair<const basic_string<char, char_traits<char>, allocator<char>>, basic_string<char, char_traits<char>, allocator<char>>> &auto_ptr<DateValue>auto_ptr<DateValue> &auto_ptr<TimeValue>auto_ptr<TimeValue> &ValueType<unsigned short>ValueType<unsigned int>ValueType<short>ValueType<int>ValueType<pair<int, int>>ValueType<pair<unsigned int, unsigned int>>ValueType<float>ValueType<double>__iom_t7<_Mp>__iom_t8<_Mp>__iom_t9<_Cp>basic_istream<_Cp, _Traits>__iom_t10<_Cp>basic_ostream<_Cp, _Traits>__iom_t4<char>__iom_t4<char> *basic_ostream<char, _Traits>__quoted_output_proxy<_CharT, const _CharT *, char_traits<_CharT>>__quoted_output_proxy<_CharT, const_iterator, char_traits<_CharT>>pair<unsigned int, unsigned int>pair<int, int>vector<unsigned char, allocator<unsigned char>>pair<unsigned char *, long>const pair<unsigned char *, long>const pair<unsigned char *, long> &pair<unsigned char *, long> &pair<unsigned char *, long> *Slice<const unsigned char *>Slice<T>basic_istream<char, _Traits>is_base_of<ios_base, _Stream>__is_istreamable<_Stream &, _Tp &&, void>_Stream &__is_ostreamable<_Stream &, const _Tp &, void>__void_t<decltype(((<expression>)))>is_same<void, type>enable_if<value, basic_ostream<_CharT, _Traits> &>unique_ptr<_Yp, _Dp>__num_get__num_get<char> &const __num_get<char>const __num_get<char> &__num_get<wchar_t> &const __num_get<wchar_t>const __num_get<wchar_t> &num_get<char, istreambuf_iterator<char, char_traits<char>>> &const num_get<char, istreambuf_iterator<char, char_traits<char>>>const num_get<char, istreambuf_iterator<char, char_traits<char>>> &num_get<wchar_t, istreambuf_iterator<wchar_t, char_traits<wchar_t>>> &const num_get<wchar_t, istreambuf_iterator<wchar_t, char_traits<wchar_t>>>const num_get<wchar_t, istreambuf_iterator<wchar_t, char_traits<wchar_t>>> &__num_put__num_put<char> &const __num_put<char>const __num_put<char> &__num_put<wchar_t> &const __num_put<wchar_t>const __num_put<wchar_t> &num_put<char, ostreambuf_iterator<char, char_traits<char>>> &const num_put<char, ostreambuf_iterator<char, char_traits<char>>>const num_put<char, ostreambuf_iterator<char, char_traits<char>>> &num_put<wchar_t, ostreambuf_iterator<wchar_t, char_traits<wchar_t>>> &const num_put<wchar_t, ostreambuf_iterator<wchar_t, char_traits<wchar_t>>>const num_put<wchar_t, ostreambuf_iterator<wchar_t, char_traits<wchar_t>>> &time_get<char, istreambuf_iterator<char, char_traits<char>>> &const time_get<char, istreambuf_iterator<char, char_traits<char>>>const time_get<char, istreambuf_iterator<char, char_traits<char>>> &time_get<wchar_t, istreambuf_iterator<wchar_t, char_traits<wchar_t>>> &const time_get<wchar_t, istreambuf_iterator<wchar_t, char_traits<wchar_t>>>const time_get<wchar_t, istreambuf_iterator<wchar_t, char_traits<wchar_t>>> &time_get_byname<char, istreambuf_iterator<char, char_traits<char>>> &const time_get_byname<char, istreambuf_iterator<char, char_traits<char>>>const time_get_byname<char, istreambuf_iterator<char, char_traits<char>>> &time_get_byname<wchar_t, istreambuf_iterator<wchar_t, char_traits<wchar_t>>> &const time_get_byname<wchar_t, istreambuf_iterator<wchar_t, char_traits<wchar_t>>>const time_get_byname<wchar_t, istreambuf_iterator<wchar_t, char_traits<wchar_t>>> &time_put<char, ostreambuf_iterator<char, char_traits<char>>> &const time_put<char, ostreambuf_iterator<char, char_traits<char>>>const time_put<char, ostreambuf_iterator<char, char_traits<char>>> &time_put<wchar_t, ostreambuf_iterator<wchar_t, char_traits<wchar_t>>> &const time_put<wchar_t, ostreambuf_iterator<wchar_t, char_traits<wchar_t>>>const time_put<wchar_t, ostreambuf_iterator<wchar_t, char_traits<wchar_t>>> &time_put_byname<char, ostreambuf_iterator<char, char_traits<char>>> &const time_put_byname<char, ostreambuf_iterator<char, char_traits<char>>>const time_put_byname<char, ostreambuf_iterator<char, char_traits<char>>> &time_put_byname<wchar_t, ostreambuf_iterator<wchar_t, char_traits<wchar_t>>> &const time_put_byname<wchar_t, ostreambuf_iterator<wchar_t, char_traits<wchar_t>>>const time_put_byname<wchar_t, ostreambuf_iterator<wchar_t, char_traits<wchar_t>>> &moneypunct<char, false> &const moneypunct<char, false>const moneypunct<char, false> &moneypunct<char, true> &const moneypunct<char, true>const moneypunct<char, true> &moneypunct<wchar_t, false> &const moneypunct<wchar_t, false>const moneypunct<wchar_t, false> &moneypunct<wchar_t, true> &const moneypunct<wchar_t, true>const moneypunct<wchar_t, true> &__money_get<char> &const __money_get<char>const __money_get<char> &__money_get<wchar_t> &const __money_get<wchar_t>const __money_get<wchar_t> &money_get<char, istreambuf_iterator<char, char_traits<char>>> &const money_get<char, istreambuf_iterator<char, char_traits<char>>>const money_get<char, istreambuf_iterator<char, char_traits<char>>> &money_get<wchar_t, istreambuf_iterator<wchar_t, char_traits<wchar_t>>> &const money_get<wchar_t, istreambuf_iterator<wchar_t, char_traits<wchar_t>>>const money_get<wchar_t, istreambuf_iterator<wchar_t, char_traits<wchar_t>>> &__money_put<char> &const __money_put<char>const __money_put<char> &__money_put<wchar_t> &const __money_put<wchar_t>const __money_put<wchar_t> &money_put<char, ostreambuf_iterator<char, char_traits<char>>> &const money_put<char, ostreambuf_iterator<char, char_traits<char>>>const money_put<char, ostreambuf_iterator<char, char_traits<char>>> &money_put<wchar_t, ostreambuf_iterator<wchar_t, char_traits<wchar_t>>> &const money_put<wchar_t, ostreambuf_iterator<wchar_t, char_traits<wchar_t>>>const money_put<wchar_t, ostreambuf_iterator<wchar_t, char_traits<wchar_t>>> &messages<char> &const messages<char>const messages<char> &messages<wchar_t> &const messages<wchar_t>const messages<wchar_t> &messages_byname<char> &const messages_byname<char>const messages_byname<char> &messages_byname<wchar_t> &const messages_byname<wchar_t>const messages_byname<wchar_t> &basic_string<_CharT, char_traits<_CharT>, allocator<_CharT>>__time_get_storage<char>__time_get_storage<char> &const __time_get_storage<char>const __time_get_storage<char> &basic_string<char, char_traits<char>, allocator<char>>[2]basic_string<char, char_traits<char>, allocator<char>>[24]basic_string<char, char_traits<char>, allocator<char>>[14]__time_get_storage<wchar_t>__time_get_storage<wchar_t> &const __time_get_storage<wchar_t>const __time_get_storage<wchar_t> &basic_string<wchar_t, char_traits<wchar_t>, allocator<wchar_t>>[2]basic_string<wchar_t, char_traits<wchar_t>, allocator<wchar_t>>[24]basic_string<wchar_t, char_traits<wchar_t>, allocator<wchar_t>>[14]basic_string<char, char_traits<char>, _Byte_alloc>basic_string<_Elem, char_traits<_Elem>, _Wide_alloc>basic_streambuf<_Elem, _Tr>basic_string<_CharT, _Traits, allocator<_CharT>>istreambuf_iterator<_CharT, char_traits<_CharT>>ostreambuf_iterator<_CharT, char_traits<_CharT>>__time_get_c_storage<char>__time_get_c_storage<char> &const __time_get_c_storage<char>const __time_get_c_storage<char> &__time_get_c_storage__time_get_c_storage<wchar_t>__time_get_c_storage<wchar_t> &const __time_get_c_storage<wchar_t>const __time_get_c_storage<wchar_t> &moneypunct_byname<char, false> &const moneypunct_byname<char, false>const moneypunct_byname<char, false> &moneypunct_byname<char, true> &const moneypunct_byname<char, true>const moneypunct_byname<char, true> &moneypunct_byname<wchar_t, false> &const moneypunct_byname<wchar_t, false>const moneypunct_byname<wchar_t, false> &moneypunct_byname<wchar_t, true> &const moneypunct_byname<wchar_t, true>const moneypunct_byname<wchar_t, true> &unique_ptr<_Tp, ..(*)(..)>unique_ptr<_CharT, ..(*)(..)>allocator<_Elem>char_traits<_Elem>is_same<_CharT, char_type>codecvt_byname<char, char, __mbstate_t> &const codecvt_byname<char, char, __mbstate_t>const codecvt_byname<char, char, __mbstate_t> &codecvt_byname<wchar_t, char, __mbstate_t> &const codecvt_byname<wchar_t, char, __mbstate_t>const codecvt_byname<wchar_t, char, __mbstate_t> &codecvt_byname<char16_t, char, __mbstate_t> &const codecvt_byname<char16_t, char, __mbstate_t>const codecvt_byname<char16_t, char, __mbstate_t> &codecvt_byname<char32_t, char, __mbstate_t> &const codecvt_byname<char32_t, char, __mbstate_t>const codecvt_byname<char32_t, char, __mbstate_t> &collate<char> &const collate<char>const collate<char> &collate<wchar_t> &const collate<wchar_t>const collate<wchar_t> &duration<_Rep, _Period>time_point<_Clock, _Duration>is_nothrow_default_constructible<mutex>is_nothrow_default_constructibleis_nothrow_default_constructible<mutex> &const is_nothrow_default_constructible<mutex>const is_nothrow_default_constructible<mutex> &time_point<system_clock, duration<long long, ratio<1L, 1000000000L>>>time_point<_Clock, nanoseconds>is_floating_point<_Rep>enable_if<value, nanoseconds>enable_if<<expression>, nanoseconds>unique_lock<mutex>is_error_condition_enum<_Ep>enable_if<value, error_condition &>is_error_code_enum<_Ep>enable_if<value, error_code &>unary_function<error_code, unsigned long>unary_function<error_code, unsigned long> &const unary_function<error_code, unsigned long>const unary_function<error_code, unsigned long> &unary_function<error_condition, unsigned long>unary_function<error_condition, unsigned long> &const unary_function<error_condition, unsigned long>const unary_function<error_condition, unsigned long> &__bit_reference<__bitset<_N_words, _Size>, value>__bit_array<__bitset<_N_words, _Size>>__bit_reference<__bitset<1UL, _Size>, value>__bit_array<__bitset<1UL, _Size>>__bit_array<__bitset<0UL, 0UL>>__bit_const_reference<__bitset<_N_words, _Size>>__bit_iterator<__bitset<_N_words, _Size>, false, 0UL>__bit_iterator<__bitset<_N_words, _Size>, true, 0UL>__bit_const_reference<__bitset<1UL, _Size>>__bit_iterator<__bitset<1UL, _Size>, false, 0UL>__bit_iterator<__bitset<1UL, _Size>, true, 0UL>__bitset<__n_words, _Size>__bitset<<expression>, _Size>unary_function<bitset<_Size>, unsigned long>__bit_reference<__bitset<0UL, 0UL>, true>__bit_const_reference<__bitset<0UL, 0UL>>allocator<_CharT>__bit_iterator<__bitset<0UL, 0UL>, true, 0UL>__bit_iterator<__bitset<0UL, 0UL>, true, 0UL> *shared_ptr<_Yp>allocator<__list_node<Exifdatum, void *>>allocator<__list_node<Exifdatum, void *>> &const allocator<__list_node<Exifdatum, void *>>const allocator<__list_node<Exifdatum, void *>> &const __list_node<Exifdatum, void *>const __list_node<Exifdatum, void *> &__list_node<Exifdatum, void *> &const __list_node<Exifdatum, void *> *__allocator_traits_rebind<allocator<Exifdatum>, __list_node<Exifdatum, void *>, true>__allocator_traits_rebind<allocator<Exifdatum>, __list_node<Exifdatum, void *>, true> &const __allocator_traits_rebind<allocator<Exifdatum>, __list_node<Exifdatum, void *>, true>const __allocator_traits_rebind<allocator<Exifdatum>, __list_node<Exifdatum, void *>, true> &allocator<__list_node_base<Exifdatum, void *>>allocator<__list_node_base<Exifdatum, void *>> &const allocator<__list_node_base<Exifdatum, void *>>const allocator<__list_node_base<Exifdatum, void *>> &const __list_node_base<Exifdatum, void *>const __list_node_base<Exifdatum, void *> &__list_node_base<Exifdatum, void *> &const __list_node_base<Exifdatum, void *> *__allocator_traits_rebind<allocator<Exifdatum>, __list_node_base<Exifdatum, void *>, true>__allocator_traits_rebind<allocator<Exifdatum>, __list_node_base<Exifdatum, void *>, true> &const __allocator_traits_rebind<allocator<Exifdatum>, __list_node_base<Exifdatum, void *>, true>const __allocator_traits_rebind<allocator<Exifdatum>, __list_node_base<Exifdatum, void *>, true> &storage_type<data_type>MutableSliceBase<ContainerStorage, container>ConstSliceBase<ContainerStorage, const container>ConstSliceBase<PtrSliceStorage, const T *>MutableSliceBase<PtrSliceStorage, T *>ConstSliceBase<storage_type, const data_type>const data_type__bit_iterator<__bitset<0UL, 0UL>, false, 0UL>__promote<float, float, void>__promote__promote<float, float, void> &const __promote<float, float, void>const __promote<float, float, void> &__promote<long double, long double, void>__promote<long double, long double, void> &const __promote<long double, long double, void>const __promote<long double, long double, void> &allocator<unsigned char>const allocator<unsigned char>const allocator<unsigned char> &const unsigned char &__identity<allocator<unsigned char>>__identity<allocator<unsigned char>> &const __identity<allocator<unsigned char>>const __identity<allocator<unsigned char>> &allocator<basic_string<char, char_traits<char>, allocator<char>>>const allocator<basic_string<char, char_traits<char>, allocator<char>>>const allocator<basic_string<char, char_traits<char>, allocator<char>>> &__identity<allocator<basic_string<char, char_traits<char>, allocator<char>>>>__identity<allocator<basic_string<char, char_traits<char>, allocator<char>>>> &const __identity<allocator<basic_string<char, char_traits<char>, allocator<char>>>>const __identity<allocator<basic_string<char, char_traits<char>, allocator<char>>>> &__identity<LangAltValueComparator>__identity<LangAltValueComparator> &const __identity<LangAltValueComparator>const __identity<LangAltValueComparator> &allocator<pair<unsigned int, unsigned int>>const allocator<pair<unsigned int, unsigned int>>const allocator<pair<unsigned int, unsigned int>> &const pair<unsigned int, unsigned int> *__identity<allocator<pair<unsigned int, unsigned int>>>__identity<allocator<pair<unsigned int, unsigned int>>> &const __identity<allocator<pair<unsigned int, unsigned int>>>const __identity<allocator<pair<unsigned int, unsigned int>>> &allocator<pair<int, int>>const allocator<pair<int, int>>const allocator<pair<int, int>> &const pair<int, int> *__identity<allocator<pair<int, int>>>__identity<allocator<pair<int, int>>> &const __identity<allocator<pair<int, int>>>const __identity<allocator<pair<int, int>>> &allocator<float>const allocator<float>const allocator<float> &const float &const float *__identity<allocator<float>>__identity<allocator<float>> &const __identity<allocator<float>>const __identity<allocator<float>> &allocator<double>const allocator<double>const allocator<double> &const double *__identity<allocator<double>>__identity<allocator<double>> &const __identity<allocator<double>>const __identity<allocator<double>> &allocator<Exifdatum>const allocator<Exifdatum>const allocator<Exifdatum> &__identity<allocator<Exifdatum>>__identity<allocator<Exifdatum>> &const __identity<allocator<Exifdatum>>const __identity<allocator<Exifdatum>> &_EnableIfImpl<__promote<_A1, _A2, void>>_EnableIfImpl<__promote<_A1, _A2, _A3>>basic_ostream<char, char_traits<char>> *basic_ios<wchar_t, char_traits<wchar_t>> &const basic_ios<wchar_t, char_traits<wchar_t>>const basic_ios<wchar_t, char_traits<wchar_t>> &basic_ostream<wchar_t, char_traits<wchar_t>> *basic_iostream<char, char_traits<char>> &const basic_iostream<char, char_traits<char>>const basic_iostream<char, char_traits<char>> &basic_stringbuf<char, char_traits<char>, allocator<char>> &const basic_stringbuf<char, char_traits<char>, allocator<char>>const basic_stringbuf<char, char_traits<char>, allocator<char>> &basic_istringstream<char, char_traits<char>, allocator<char>> &const basic_istringstream<char, char_traits<char>, allocator<char>>const basic_istringstream<char, char_traits<char>, allocator<char>> &const basic_ostringstream<char, char_traits<char>, allocator<char>> &basic_stringstream<char, char_traits<char>, allocator<char>> &const basic_stringstream<char, char_traits<char>, allocator<char>> &fpos<__mbstate_t>fpos<__mbstate_t> &const fpos<__mbstate_t> &fpos<__mbstate_t> *const TagDetails(&)[2]TagDetails(&)[2]const TagDetails(&)[3]TagDetails(&)[3]const TagDetails(&)[312]TagDetails(&)[312]const TagDetails(&)[9]TagDetails(&)[9]const TagDetails(&)[10]TagDetails(&)[10]const TagDetails(&)[5]TagDetails(&)[5]const TagDetailsBitmask(&)[9]TagDetailsBitmask(&)[9]N > 0const TagDetailsBitmask(*)[9]TagDetailsBitmask(*)[9]const TagDetails(&)[8]TagDetails(&)[8]const TagDetails(&)[11]TagDetails(&)[11]const TagDetails(&)[6]TagDetails(&)[6]const TagDetails(&)[31]TagDetails(&)[31]const TagDetails(&)[71]TagDetails(&)[71]const TagDetails(&)[17]TagDetails(&)[17]const TagDetails(&)[12]TagDetails(&)[12]const TagDetailsBitmask(&)[7]TagDetailsBitmask(&)[7]const TagDetailsBitmask(*)[7]TagDetailsBitmask(*)[7]const TagDetails(&)[35]TagDetails(&)[35]const TagDetails(&)[7]TagDetails(&)[7]const TagDetails(&)[22]TagDetails(&)[22]const TagDetailsBitmask(&)[3]TagDetailsBitmask(&)[3]const TagDetailsBitmask(*)[3]TagDetailsBitmask(*)[3]const basic_ostringstream<char, char_traits<char>, allocator<char>> *const __list_const_iterator<Exifdatum, void *> *__list_imp<Exifdatum, allocator<Exifdatum>> *const list<Exifdatum, allocator<Exifdatum>> *const __list_imp<Exifdatum, allocator<Exifdatum>>const __list_imp<Exifdatum, allocator<Exifdatum>> *auto_ptr<DataValue> *operator std::__1::auto_ptr_ref<Exiv2::DataValue>auto_ptr<StringValueBase> *operator std::__1::auto_ptr_ref<Exiv2::StringValueBase>auto_ptr<StringValue> *operator std::__1::auto_ptr_ref<Exiv2::StringValue>auto_ptr<AsciiValue> *operator std::__1::auto_ptr_ref<Exiv2::AsciiValue>auto_ptr<CommentValue> *operator std::__1::auto_ptr_ref<Exiv2::CommentValue>auto_ptr<DateValue> *operator std::__1::auto_ptr_ref<Exiv2::DateValue>auto_ptr<TimeValue> *operator std::__1::auto_ptr_ref<Exiv2::TimeValue>const vector<pair<unsigned int, unsigned int>, allocator<pair<unsigned int, unsigned int>>>const vector<pair<unsigned int, unsigned int>, allocator<pair<unsigned int, unsigned int>>> *const __vector_base<pair<unsigned int, unsigned int>, allocator<pair<unsigned int, unsigned int>>> *const vector<pair<int, int>, allocator<pair<int, int>>>const vector<pair<int, int>, allocator<pair<int, int>>> *vector<pair<int, int>, allocator<pair<int, int>>> *const __vector_base<pair<int, int>, allocator<pair<int, int>>> *__vector_base<pair<int, int>, allocator<pair<int, int>>> *const vector<float, allocator<float>>const vector<float, allocator<float>> *vector<float, allocator<float>> *const __vector_base<float, allocator<float>> *__vector_base<float, allocator<float>> *const vector<double, allocator<double>>const vector<double, allocator<double>> *vector<double, allocator<double>> *const __vector_base<double, allocator<double>> *__vector_base<double, allocator<double>> *auto_ptr<Value> *operator std::__1::auto_ptr_ref<Exiv2::Value>__bit_reference<__bitset<0UL, 0UL>, true> *__bit_const_reference<__bitset<0UL, 0UL>> *__bit_iterator<__bitset<0UL, 0UL>, false, 0UL> *const allocator<char>const allocator<char> &allocator<char> &operator unsigned long *operator const unsigned long *operator const unsigned int *operator std::__1::basic_ostream<char, std::__1::char_traits<char>> *operator char *operator Exiv2::Value *operator Exiv2::DataValue *operator Exiv2::StringValueBase *operator Exiv2::StringValue *operator Exiv2::AsciiValue *operator Exiv2::CommentValue *operator Exiv2::DateValue *operator Exiv2::TimeValue *operator std::__1::basic_streambuf<char, std::__1::char_traits<char>> *conditional<false, __nat, const Exifdatum>conditional<false, __nat, const Exifdatum> &const conditional<false, __nat, const Exifdatum>const conditional<false, __nat, const Exifdatum> &basic_ostream<wchar_t, char_traits<wchar_t>> &__non_trivial_if<true, allocator<Exifdatum>>__non_trivial_if<true, allocator<Exifdatum>> &const __non_trivial_if<true, allocator<Exifdatum>>const __non_trivial_if<true, allocator<Exifdatum>> &__non_trivial_if<true, allocator<double>>__non_trivial_if<true, allocator<double>> &const __non_trivial_if<true, allocator<double>>const __non_trivial_if<true, allocator<double>> &__non_trivial_if<true, allocator<float>>__non_trivial_if<true, allocator<float>> &const __non_trivial_if<true, allocator<float>>const __non_trivial_if<true, allocator<float>> &__non_trivial_if<true, allocator<pair<int, int>>>__non_trivial_if<true, allocator<pair<int, int>>> &const __non_trivial_if<true, allocator<pair<int, int>>>const __non_trivial_if<true, allocator<pair<int, int>>> &__non_trivial_if<true, allocator<pair<unsigned int, unsigned int>>>__non_trivial_if<true, allocator<pair<unsigned int, unsigned int>>> &const __non_trivial_if<true, allocator<pair<unsigned int, unsigned int>>>const __non_trivial_if<true, allocator<pair<unsigned int, unsigned int>>> &__non_trivial_if<true, allocator<basic_string<char, char_traits<char>, allocator<char>>>>__non_trivial_if<true, allocator<basic_string<char, char_traits<char>, allocator<char>>>> &const __non_trivial_if<true, allocator<basic_string<char, char_traits<char>, allocator<char>>>>const __non_trivial_if<true, allocator<basic_string<char, char_traits<char>, allocator<char>>>> &__non_trivial_if<true, allocator<unsigned char>>__non_trivial_if<true, allocator<unsigned char>> &const __non_trivial_if<true, allocator<unsigned char>>const __non_trivial_if<true, allocator<unsigned char>> &__promote_imp<long double, long double, void, true>__promote_imp<long double, long double, void, true> &const __promote_imp<long double, long double, void, true>const __promote_imp<long double, long double, void, true> &__promote_imp<float, float, void, true>__promote_imp<float, float, void, true> &const __promote_imp<float, float, void, true>const __promote_imp<float, float, void, true> &conditional<false, const unsigned long *, unsigned long *>conditional<false, const unsigned long *, unsigned long *> &const conditional<false, const unsigned long *, unsigned long *>const conditional<false, const unsigned long *, unsigned long *> &conditional<false, __bit_const_reference<__bitset<0UL, 0UL>>, __bit_reference<__bitset<0UL, 0UL>, true>>conditional<false, __bit_const_reference<__bitset<0UL, 0UL>>, __bit_reference<__bitset<0UL, 0UL>, true>> &const conditional<false, __bit_const_reference<__bitset<0UL, 0UL>>, __bit_reference<__bitset<0UL, 0UL>, true>>const conditional<false, __bit_const_reference<__bitset<0UL, 0UL>>, __bit_reference<__bitset<0UL, 0UL>, true>> &rebind<__list_node_base<Exifdatum, void *>>rebind<__list_node_base<Exifdatum, void *>> &const rebind<__list_node_base<Exifdatum, void *>>const rebind<__list_node_base<Exifdatum, void *>> &__has_rebind_other<allocator<Exifdatum>, __list_node_base<Exifdatum, void *>, void>__has_rebind_other<allocator<Exifdatum>, __list_node_base<Exifdatum, void *>, void> &const __has_rebind_other<allocator<Exifdatum>, __list_node_base<Exifdatum, void *>, void>const __has_rebind_other<allocator<Exifdatum>, __list_node_base<Exifdatum, void *>, void> &__non_trivial_if<true, allocator<__list_node_base<Exifdatum, void *>>>__non_trivial_if<true, allocator<__list_node_base<Exifdatum, void *>>> &const __non_trivial_if<true, allocator<__list_node_base<Exifdatum, void *>>>const __non_trivial_if<true, allocator<__list_node_base<Exifdatum, void *>>> &rebind<__list_node<Exifdatum, void *>>rebind<__list_node<Exifdatum, void *>> &const rebind<__list_node<Exifdatum, void *>>const rebind<__list_node<Exifdatum, void *>> &__has_rebind_other<allocator<Exifdatum>, __list_node<Exifdatum, void *>, void>__has_rebind_other<allocator<Exifdatum>, __list_node<Exifdatum, void *>, void> &const __has_rebind_other<allocator<Exifdatum>, __list_node<Exifdatum, void *>, void>const __has_rebind_other<allocator<Exifdatum>, __list_node<Exifdatum, void *>, void> &__non_trivial_if<true, allocator<__list_node<Exifdatum, void *>>>__non_trivial_if<true, allocator<__list_node<Exifdatum, void *>>> &const __non_trivial_if<true, allocator<__list_node<Exifdatum, void *>>>const __non_trivial_if<true, allocator<__list_node<Exifdatum, void *>>> &conditional<true, const unsigned long *, unsigned long *>conditional<true, const unsigned long *, unsigned long *> &const conditional<true, const unsigned long *, unsigned long *>const conditional<true, const unsigned long *, unsigned long *> &conditional<true, __bit_const_reference<__bitset<0UL, 0UL>>, __bit_reference<__bitset<0UL, 0UL>, true>>conditional<true, __bit_const_reference<__bitset<0UL, 0UL>>, __bit_reference<__bitset<0UL, 0UL>, true>> &const conditional<true, __bit_const_reference<__bitset<0UL, 0UL>>, __bit_reference<__bitset<0UL, 0UL>, true>>const conditional<true, __bit_const_reference<__bitset<0UL, 0UL>>, __bit_reference<__bitset<0UL, 0UL>, true>> &__has_storage_type<__bitset<0UL, 0UL>>__has_storage_type<__bitset<0UL, 0UL>> &const __has_storage_type<__bitset<0UL, 0UL>>const __has_storage_type<__bitset<0UL, 0UL>> &is_nothrow_constructible<mutex>is_nothrow_constructibleis_nothrow_constructible<mutex> &const is_nothrow_constructible<mutex>const is_nothrow_constructible<mutex> &ostreambuf_iterator<wchar_t, char_traits<wchar_t>>ostreambuf_iterator<char, char_traits<char>>ostreambuf_iterator<char, char_traits<char>> &const ostreambuf_iterator<char, char_traits<char>>const ostreambuf_iterator<char, char_traits<char>> &ostreambuf_iterator<char, char_traits<char>> *istreambuf_iterator<wchar_t, char_traits<wchar_t>>istreambuf_iterator<char, char_traits<char>>allocator_traits<allocator<unsigned char>>allocator_traits<allocator<unsigned char>> &const allocator_traits<allocator<unsigned char>>const allocator_traits<allocator<unsigned char>> &reverse_iterator<__wrap_iter<unsigned char *>>reverse_iterator<__wrap_iter<const unsigned char *>>__vector_base<unsigned char, allocator<unsigned char>>__vector_base<unsigned char, allocator<unsigned char>> &const __vector_base<unsigned char, allocator<unsigned char>> &auto_ptr<ValueType<double>>auto_ptr<ValueType<float>>auto_ptr<ValueType<pair<unsigned int, unsigned int>>>auto_ptr<ValueType<pair<int, int>>>__map_value_compare<basic_string<char, char_traits<char>, allocator<char>>, __value_type<basic_string<char, char_traits<char>, allocator<char>>, basic_string<char, char_traits<char>, allocator<char>>>, LangAltValueComparator, true>__map_value_compare<basic_string<char, char_traits<char>, allocator<char>>, __value_type<basic_string<char, char_traits<char>, allocator<char>>, basic_string<char, char_traits<char>, allocator<char>>>, LangAltValueComparator, true> &const __map_value_compare<basic_string<char, char_traits<char>, allocator<char>>, __value_type<basic_string<char, char_traits<char>, allocator<char>>, basic_string<char, char_traits<char>, allocator<char>>>, LangAltValueComparator, true>const __map_value_compare<basic_string<char, char_traits<char>, allocator<char>>, __value_type<basic_string<char, char_traits<char>, allocator<char>>, basic_string<char, char_traits<char>, allocator<char>>>, LangAltValueComparator, true> &__tree<__value_type<basic_string<char, char_traits<char>, allocator<char>>, basic_string<char, char_traits<char>, allocator<char>>>, __map_value_compare<basic_string<char, char_traits<char>, allocator<char>>, __value_type<basic_string<char, char_traits<char>, allocator<char>>, basic_string<char, char_traits<char>, allocator<char>>>, LangAltValueComparator, true>, allocator<__value_type<basic_string<char, char_traits<char>, allocator<char>>, basic_string<char, char_traits<char>, allocator<char>>>>>__value_type<basic_string<char, char_traits<char>, allocator<char>>, basic_string<char, char_traits<char>, allocator<char>>> *allocator_traits<allocator<basic_string<char, char_traits<char>, allocator<char>>>>allocator_traits<allocator<basic_string<char, char_traits<char>, allocator<char>>>> &const allocator_traits<allocator<basic_string<char, char_traits<char>, allocator<char>>>>const allocator_traits<allocator<basic_string<char, char_traits<char>, allocator<char>>>> &reverse_iterator<__wrap_iter<basic_string<char, char_traits<char>, allocator<char>> *>>reverse_iterator<__wrap_iter<const basic_string<char, char_traits<char>, allocator<char>> *>>__vector_base<basic_string<char, char_traits<char>, allocator<char>>, allocator<basic_string<char, char_traits<char>, allocator<char>>>>__vector_base<basic_string<char, char_traits<char>, allocator<char>>, allocator<basic_string<char, char_traits<char>, allocator<char>>>> &const __vector_base<basic_string<char, char_traits<char>, allocator<char>>, allocator<basic_string<char, char_traits<char>, allocator<char>>>>const __vector_base<basic_string<char, char_traits<char>, allocator<char>>, allocator<basic_string<char, char_traits<char>, allocator<char>>>> &reverse_iterator<__wrap_iter<double *>>reverse_iterator<__wrap_iter<const double *>>__compressed_pair<double *, allocator<double>>__compressed_pair<double *, allocator<double>> &const __compressed_pair<double *, allocator<double>>const __compressed_pair<double *, allocator<double>> &allocator_traits<allocator<double>>allocator_traits<allocator<double>> &const allocator_traits<allocator<double>>const allocator_traits<allocator<double>> &reverse_iterator<__wrap_iter<float *>>reverse_iterator<__wrap_iter<const float *>>__compressed_pair<float *, allocator<float>>__compressed_pair<float *, allocator<float>> &const __compressed_pair<float *, allocator<float>>const __compressed_pair<float *, allocator<float>> &allocator_traits<allocator<float>>allocator_traits<allocator<float>> &const allocator_traits<allocator<float>>const allocator_traits<allocator<float>> &reverse_iterator<__wrap_iter<pair<int, int> *>>reverse_iterator<__wrap_iter<const pair<int, int> *>>__compressed_pair<pair<int, int> *, allocator<pair<int, int>>>__compressed_pair<pair<int, int> *, allocator<pair<int, int>>> &const __compressed_pair<pair<int, int> *, allocator<pair<int, int>>>const __compressed_pair<pair<int, int> *, allocator<pair<int, int>>> &allocator_traits<allocator<pair<int, int>>>allocator_traits<allocator<pair<int, int>>> &const allocator_traits<allocator<pair<int, int>>>const allocator_traits<allocator<pair<int, int>>> &reverse_iterator<__wrap_iter<pair<unsigned int, unsigned int> *>>reverse_iterator<__wrap_iter<const pair<unsigned int, unsigned int> *>>__compressed_pair<pair<unsigned int, unsigned int> *, allocator<pair<unsigned int, unsigned int>>>__compressed_pair<pair<unsigned int, unsigned int> *, allocator<pair<unsigned int, unsigned int>>> &const __compressed_pair<pair<unsigned int, unsigned int> *, allocator<pair<unsigned int, unsigned int>>>const __compressed_pair<pair<unsigned int, unsigned int> *, allocator<pair<unsigned int, unsigned int>>> &allocator_traits<allocator<pair<unsigned int, unsigned int>>>allocator_traits<allocator<pair<unsigned int, unsigned int>>> &const allocator_traits<allocator<pair<unsigned int, unsigned int>>>const allocator_traits<allocator<pair<unsigned int, unsigned int>>> &__wrap_iter<const basic_string<char, char_traits<char>, allocator<char>> *>__wrap_iter<basic_string<char, char_traits<char>, allocator<char>> *>__wrap_iter<const unsigned char *>__wrap_iter<unsigned char *>__wrap_iter<pair<int, int> *>__wrap_iter<const pair<int, int> *>__wrap_iter<pair<unsigned int, unsigned int> *>__wrap_iter<const pair<unsigned int, unsigned int> *>__wrap_iter<float *>__wrap_iter<const float *>__wrap_iter<double *>__wrap_iter<const double *>allocator<T>__deque_block_size<_Tp, difference_type>allocator<IfdId>deque<TiffPathItem, allocator<TiffPathItem>>__rebind_pointer<void *, const Exifdatum>__rebind_pointer<void *, const Exifdatum> &const __rebind_pointer<void *, const Exifdatum>const __rebind_pointer<void *, const Exifdatum> &pointer_traits<const Exifdatum *>pointer_traits<const Exifdatum *> &const pointer_traits<const Exifdatum *>const pointer_traits<const Exifdatum *> &__list_node_pointer_traits<Exifdatum, void *>__list_node_pointer_traits<Exifdatum, void *> &const __list_node_pointer_traits<Exifdatum, void *>const __list_node_pointer_traits<Exifdatum, void *> &__rebind_pointer<void *, Exifdatum>__rebind_pointer<void *, Exifdatum> &const __rebind_pointer<void *, Exifdatum>const __rebind_pointer<void *, Exifdatum> &pointer_traits<Exifdatum *>pointer_traits<Exifdatum *> &const pointer_traits<Exifdatum *>const pointer_traits<Exifdatum *> &__list_node<Exifdatum, void *>~__list_node__list_nodeallocator_traits<allocator<__list_node<Exifdatum, void *>>>allocator_traits<allocator<__list_node<Exifdatum, void *>>> &const allocator_traits<allocator<__list_node<Exifdatum, void *>>>const allocator_traits<allocator<__list_node<Exifdatum, void *>>> &__list_node_base<Exifdatum, void *>reverse_iterator<__list_iterator<Exifdatum, void *>>reverse_iterator<__list_const_iterator<Exifdatum, void *>>__allocator_destructor<allocator<__list_node<Exifdatum, void *>>>unique_ptr<__list_node<Exifdatum, void *>, __allocator_destructor<allocator<__list_node<Exifdatum, void *>>>>__list_imp<Exifdatum, allocator<Exifdatum>>const fpos<__mbstate_t> *__compressed_pair<unsigned long, allocator<__list_node<Exifdatum, void *>>>__compressed_pair<unsigned long, allocator<__list_node<Exifdatum, void *>>> &const __compressed_pair<unsigned long, allocator<__list_node<Exifdatum, void *>>>const __compressed_pair<unsigned long, allocator<__list_node<Exifdatum, void *>>> &__rebind_alloc_helper<allocator_traits<allocator<Exifdatum>>, __list_node<Exifdatum, void *>>__rebind_alloc_helper<allocator_traits<allocator<Exifdatum>>, __list_node<Exifdatum, void *>> &const __rebind_alloc_helper<allocator_traits<allocator<Exifdatum>>, __list_node<Exifdatum, void *>>const __rebind_alloc_helper<allocator_traits<allocator<Exifdatum>>, __list_node<Exifdatum, void *>> &allocator_traits<allocator<Exifdatum>>allocator_traits<allocator<Exifdatum>> &const allocator_traits<allocator<Exifdatum>>const allocator_traits<allocator<Exifdatum>> &__rebind_alloc_helper<allocator_traits<allocator<Exifdatum>>, __list_node_base<Exifdatum, void *>>__rebind_alloc_helper<allocator_traits<allocator<Exifdatum>>, __list_node_base<Exifdatum, void *>> &const __rebind_alloc_helper<allocator_traits<allocator<Exifdatum>>, __list_node_base<Exifdatum, void *>>const __rebind_alloc_helper<allocator_traits<allocator<Exifdatum>>, __list_node_base<Exifdatum, void *>> &allocator_traits<allocator<__list_node_base<Exifdatum, void *>>>allocator_traits<allocator<__list_node_base<Exifdatum, void *>>> &const allocator_traits<allocator<__list_node_base<Exifdatum, void *>>>const allocator_traits<allocator<__list_node_base<Exifdatum, void *>>> &__pointer<__list_node<Exifdatum, void *>, allocator<__list_node<Exifdatum, void *>>, allocator<__list_node<Exifdatum, void *>>, true>__pointer<__list_node<Exifdatum, void *>, allocator<__list_node<Exifdatum, void *>>, allocator<__list_node<Exifdatum, void *>>, true> &const __pointer<__list_node<Exifdatum, void *>, allocator<__list_node<Exifdatum, void *>>, allocator<__list_node<Exifdatum, void *>>, true>const __pointer<__list_node<Exifdatum, void *>, allocator<__list_node<Exifdatum, void *>>, allocator<__list_node<Exifdatum, void *>>, true> &__const_pointer<__list_node<Exifdatum, void *>, __list_node<Exifdatum, void *> *, allocator<__list_node<Exifdatum, void *>>, true>__const_pointer<__list_node<Exifdatum, void *>, __list_node<Exifdatum, void *> *, allocator<__list_node<Exifdatum, void *>>, true> &const __const_pointer<__list_node<Exifdatum, void *>, __list_node<Exifdatum, void *> *, allocator<__list_node<Exifdatum, void *>>, true>const __const_pointer<__list_node<Exifdatum, void *>, __list_node<Exifdatum, void *> *, allocator<__list_node<Exifdatum, void *>>, true> &__void_pointer<__list_node<Exifdatum, void *> *, allocator<__list_node<Exifdatum, void *>>, false>__void_pointer<__list_node<Exifdatum, void *> *, allocator<__list_node<Exifdatum, void *>>, false> &const __void_pointer<__list_node<Exifdatum, void *> *, allocator<__list_node<Exifdatum, void *>>, false>const __void_pointer<__list_node<Exifdatum, void *> *, allocator<__list_node<Exifdatum, void *>>, false> &__const_void_pointer<__list_node<Exifdatum, void *> *, allocator<__list_node<Exifdatum, void *>>, false>__const_void_pointer<__list_node<Exifdatum, void *> *, allocator<__list_node<Exifdatum, void *>>, false> &const __const_void_pointer<__list_node<Exifdatum, void *> *, allocator<__list_node<Exifdatum, void *>>, false>const __const_void_pointer<__list_node<Exifdatum, void *> *, allocator<__list_node<Exifdatum, void *>>, false> &__alloc_traits_difference_type<allocator<__list_node<Exifdatum, void *>>, __list_node<Exifdatum, void *> *, true>__alloc_traits_difference_type<allocator<__list_node<Exifdatum, void *>>, __list_node<Exifdatum, void *> *, true> &const __alloc_traits_difference_type<allocator<__list_node<Exifdatum, void *>>, __list_node<Exifdatum, void *> *, true>const __alloc_traits_difference_type<allocator<__list_node<Exifdatum, void *>>, __list_node<Exifdatum, void *> *, true> &__size_type<allocator<__list_node<Exifdatum, void *>>, long, true>__size_type<allocator<__list_node<Exifdatum, void *>>, long, true> &const __size_type<allocator<__list_node<Exifdatum, void *>>, long, true>const __size_type<allocator<__list_node<Exifdatum, void *>>, long, true> &__propagate_on_container_move_assignment<allocator<__list_node<Exifdatum, void *>>, true>__propagate_on_container_move_assignment<allocator<__list_node<Exifdatum, void *>>, true> &const __propagate_on_container_move_assignment<allocator<__list_node<Exifdatum, void *>>, true>const __propagate_on_container_move_assignment<allocator<__list_node<Exifdatum, void *>>, true> &__is_always_equal<allocator<__list_node<Exifdatum, void *>>, true>__is_always_equal<allocator<__list_node<Exifdatum, void *>>, true> &const __is_always_equal<allocator<__list_node<Exifdatum, void *>>, true>const __is_always_equal<allocator<__list_node<Exifdatum, void *>>, true> &rebind<Exifdatum>rebind<Exifdatum> &const rebind<Exifdatum>const rebind<Exifdatum> &conditional<true, __list_node_base<Exifdatum, void *> *, __list_node<Exifdatum, void *> *>conditional<true, __list_node_base<Exifdatum, void *> *, __list_node<Exifdatum, void *> *> &const conditional<true, __list_node_base<Exifdatum, void *> *, __list_node<Exifdatum, void *> *>const conditional<true, __list_node_base<Exifdatum, void *> *, __list_node<Exifdatum, void *> *> &__rebind_pointer<void *, __list_node<Exifdatum, void *>>__rebind_pointer<void *, __list_node<Exifdatum, void *>> &const __rebind_pointer<void *, __list_node<Exifdatum, void *>>const __rebind_pointer<void *, __list_node<Exifdatum, void *>> &__rebind_pointer<void *, __list_node_base<Exifdatum, void *>>__rebind_pointer<void *, __list_node_base<Exifdatum, void *>> &const __rebind_pointer<void *, __list_node_base<Exifdatum, void *>>const __rebind_pointer<void *, __list_node_base<Exifdatum, void *>> &conditional<false, __list_node_base<Exifdatum, void *> *, __list_node<Exifdatum, void *> *>conditional<false, __list_node_base<Exifdatum, void *> *, __list_node<Exifdatum, void *> *> &const conditional<false, __list_node_base<Exifdatum, void *> *, __list_node<Exifdatum, void *> *>const conditional<false, __list_node_base<Exifdatum, void *> *, __list_node<Exifdatum, void *> *> &rebind<const Exifdatum>rebind<const Exifdatum> &const rebind<const Exifdatum>const rebind<const Exifdatum> &allocator<TiffPathItem>__pointer<pair<unsigned int, unsigned int>, allocator<pair<unsigned int, unsigned int>>, allocator<pair<unsigned int, unsigned int>>, true>__pointer<pair<unsigned int, unsigned int>, allocator<pair<unsigned int, unsigned int>>, allocator<pair<unsigned int, unsigned int>>, true> &const __pointer<pair<unsigned int, unsigned int>, allocator<pair<unsigned int, unsigned int>>, allocator<pair<unsigned int, unsigned int>>, true>const __pointer<pair<unsigned int, unsigned int>, allocator<pair<unsigned int, unsigned int>>, allocator<pair<unsigned int, unsigned int>>, true> &__const_pointer<pair<unsigned int, unsigned int>, pair<unsigned int, unsigned int> *, allocator<pair<unsigned int, unsigned int>>, true>__const_pointer<pair<unsigned int, unsigned int>, pair<unsigned int, unsigned int> *, allocator<pair<unsigned int, unsigned int>>, true> &const __const_pointer<pair<unsigned int, unsigned int>, pair<unsigned int, unsigned int> *, allocator<pair<unsigned int, unsigned int>>, true>const __const_pointer<pair<unsigned int, unsigned int>, pair<unsigned int, unsigned int> *, allocator<pair<unsigned int, unsigned int>>, true> &__void_pointer<pair<unsigned int, unsigned int> *, allocator<pair<unsigned int, unsigned int>>, false>__void_pointer<pair<unsigned int, unsigned int> *, allocator<pair<unsigned int, unsigned int>>, false> &const __void_pointer<pair<unsigned int, unsigned int> *, allocator<pair<unsigned int, unsigned int>>, false>const __void_pointer<pair<unsigned int, unsigned int> *, allocator<pair<unsigned int, unsigned int>>, false> &__const_void_pointer<pair<unsigned int, unsigned int> *, allocator<pair<unsigned int, unsigned int>>, false>__const_void_pointer<pair<unsigned int, unsigned int> *, allocator<pair<unsigned int, unsigned int>>, false> &const __const_void_pointer<pair<unsigned int, unsigned int> *, allocator<pair<unsigned int, unsigned int>>, false>const __const_void_pointer<pair<unsigned int, unsigned int> *, allocator<pair<unsigned int, unsigned int>>, false> &__alloc_traits_difference_type<allocator<pair<unsigned int, unsigned int>>, pair<unsigned int, unsigned int> *, true>__alloc_traits_difference_type<allocator<pair<unsigned int, unsigned int>>, pair<unsigned int, unsigned int> *, true> &const __alloc_traits_difference_type<allocator<pair<unsigned int, unsigned int>>, pair<unsigned int, unsigned int> *, true>const __alloc_traits_difference_type<allocator<pair<unsigned int, unsigned int>>, pair<unsigned int, unsigned int> *, true> &__size_type<allocator<pair<unsigned int, unsigned int>>, long, true>__size_type<allocator<pair<unsigned int, unsigned int>>, long, true> &const __size_type<allocator<pair<unsigned int, unsigned int>>, long, true>const __size_type<allocator<pair<unsigned int, unsigned int>>, long, true> &__propagate_on_container_move_assignment<allocator<pair<unsigned int, unsigned int>>, true>__propagate_on_container_move_assignment<allocator<pair<unsigned int, unsigned int>>, true> &const __propagate_on_container_move_assignment<allocator<pair<unsigned int, unsigned int>>, true>const __propagate_on_container_move_assignment<allocator<pair<unsigned int, unsigned int>>, true> &__is_always_equal<allocator<pair<unsigned int, unsigned int>>, true>__is_always_equal<allocator<pair<unsigned int, unsigned int>>, true> &const __is_always_equal<allocator<pair<unsigned int, unsigned int>>, true>const __is_always_equal<allocator<pair<unsigned int, unsigned int>>, true> &__compressed_pair_elem<allocator<pair<unsigned int, unsigned int>>, 1, true>__compressed_pair_elem<allocator<pair<unsigned int, unsigned int>>, 1, true> &const __compressed_pair_elem<allocator<pair<unsigned int, unsigned int>>, 1, true>const __compressed_pair_elem<allocator<pair<unsigned int, unsigned int>>, 1, true> &__compressed_pair_elem<pair<unsigned int, unsigned int> *, 0, false>__compressed_pair_elem<pair<unsigned int, unsigned int> *, 0, false> &const __compressed_pair_elem<pair<unsigned int, unsigned int> *, 0, false>const __compressed_pair_elem<pair<unsigned int, unsigned int> *, 0, false> &pair<unsigned int, unsigned int> *constpair<unsigned int, unsigned int> *const &pair<unsigned int, unsigned int> *&__pointer<pair<int, int>, allocator<pair<int, int>>, allocator<pair<int, int>>, true>__pointer<pair<int, int>, allocator<pair<int, int>>, allocator<pair<int, int>>, true> &const __pointer<pair<int, int>, allocator<pair<int, int>>, allocator<pair<int, int>>, true>const __pointer<pair<int, int>, allocator<pair<int, int>>, allocator<pair<int, int>>, true> &__const_pointer<pair<int, int>, pair<int, int> *, allocator<pair<int, int>>, true>__const_pointer<pair<int, int>, pair<int, int> *, allocator<pair<int, int>>, true> &const __const_pointer<pair<int, int>, pair<int, int> *, allocator<pair<int, int>>, true>const __const_pointer<pair<int, int>, pair<int, int> *, allocator<pair<int, int>>, true> &__void_pointer<pair<int, int> *, allocator<pair<int, int>>, false>__void_pointer<pair<int, int> *, allocator<pair<int, int>>, false> &const __void_pointer<pair<int, int> *, allocator<pair<int, int>>, false>const __void_pointer<pair<int, int> *, allocator<pair<int, int>>, false> &__const_void_pointer<pair<int, int> *, allocator<pair<int, int>>, false>__const_void_pointer<pair<int, int> *, allocator<pair<int, int>>, false> &const __const_void_pointer<pair<int, int> *, allocator<pair<int, int>>, false>const __const_void_pointer<pair<int, int> *, allocator<pair<int, int>>, false> &__alloc_traits_difference_type<allocator<pair<int, int>>, pair<int, int> *, true>__alloc_traits_difference_type<allocator<pair<int, int>>, pair<int, int> *, true> &const __alloc_traits_difference_type<allocator<pair<int, int>>, pair<int, int> *, true>const __alloc_traits_difference_type<allocator<pair<int, int>>, pair<int, int> *, true> &__size_type<allocator<pair<int, int>>, long, true>__size_type<allocator<pair<int, int>>, long, true> &const __size_type<allocator<pair<int, int>>, long, true>const __size_type<allocator<pair<int, int>>, long, true> &__propagate_on_container_move_assignment<allocator<pair<int, int>>, true>__propagate_on_container_move_assignment<allocator<pair<int, int>>, true> &const __propagate_on_container_move_assignment<allocator<pair<int, int>>, true>const __propagate_on_container_move_assignment<allocator<pair<int, int>>, true> &__is_always_equal<allocator<pair<int, int>>, true>__is_always_equal<allocator<pair<int, int>>, true> &const __is_always_equal<allocator<pair<int, int>>, true>const __is_always_equal<allocator<pair<int, int>>, true> &__compressed_pair_elem<allocator<pair<int, int>>, 1, true>__compressed_pair_elem<allocator<pair<int, int>>, 1, true> &const __compressed_pair_elem<allocator<pair<int, int>>, 1, true>const __compressed_pair_elem<allocator<pair<int, int>>, 1, true> &__compressed_pair_elem<pair<int, int> *, 0, false>__compressed_pair_elem<pair<int, int> *, 0, false> &const __compressed_pair_elem<pair<int, int> *, 0, false>const __compressed_pair_elem<pair<int, int> *, 0, false> &pair<int, int> *constpair<int, int> *const &pair<int, int> *&__pointer<float, allocator<float>, allocator<float>, true>__pointer<float, allocator<float>, allocator<float>, true> &const __pointer<float, allocator<float>, allocator<float>, true>const __pointer<float, allocator<float>, allocator<float>, true> &__const_pointer<float, float *, allocator<float>, true>__const_pointer<float, float *, allocator<float>, true> &const __const_pointer<float, float *, allocator<float>, true>const __const_pointer<float, float *, allocator<float>, true> &__void_pointer<float *, allocator<float>, false>__void_pointer<float *, allocator<float>, false> &const __void_pointer<float *, allocator<float>, false>const __void_pointer<float *, allocator<float>, false> &__const_void_pointer<float *, allocator<float>, false>__const_void_pointer<float *, allocator<float>, false> &const __const_void_pointer<float *, allocator<float>, false>const __const_void_pointer<float *, allocator<float>, false> &__alloc_traits_difference_type<allocator<float>, float *, true>__alloc_traits_difference_type<allocator<float>, float *, true> &const __alloc_traits_difference_type<allocator<float>, float *, true>const __alloc_traits_difference_type<allocator<float>, float *, true> &__size_type<allocator<float>, long, true>__size_type<allocator<float>, long, true> &const __size_type<allocator<float>, long, true>const __size_type<allocator<float>, long, true> &__propagate_on_container_move_assignment<allocator<float>, true>__propagate_on_container_move_assignment<allocator<float>, true> &const __propagate_on_container_move_assignment<allocator<float>, true>const __propagate_on_container_move_assignment<allocator<float>, true> &__is_always_equal<allocator<float>, true>__is_always_equal<allocator<float>, true> &const __is_always_equal<allocator<float>, true>const __is_always_equal<allocator<float>, true> &__compressed_pair_elem<allocator<float>, 1, true>__compressed_pair_elem<allocator<float>, 1, true> &const __compressed_pair_elem<allocator<float>, 1, true>const __compressed_pair_elem<allocator<float>, 1, true> &__compressed_pair_elem<float *, 0, false>__compressed_pair_elem<float *, 0, false> &const __compressed_pair_elem<float *, 0, false>const __compressed_pair_elem<float *, 0, false> &float *constfloat *const &float *&__pointer<double, allocator<double>, allocator<double>, true>__pointer<double, allocator<double>, allocator<double>, true> &const __pointer<double, allocator<double>, allocator<double>, true>const __pointer<double, allocator<double>, allocator<double>, true> &__const_pointer<double, double *, allocator<double>, true>__const_pointer<double, double *, allocator<double>, true> &const __const_pointer<double, double *, allocator<double>, true>const __const_pointer<double, double *, allocator<double>, true> &__void_pointer<double *, allocator<double>, false>__void_pointer<double *, allocator<double>, false> &const __void_pointer<double *, allocator<double>, false>const __void_pointer<double *, allocator<double>, false> &__const_void_pointer<double *, allocator<double>, false>__const_void_pointer<double *, allocator<double>, false> &const __const_void_pointer<double *, allocator<double>, false>const __const_void_pointer<double *, allocator<double>, false> &__alloc_traits_difference_type<allocator<double>, double *, true>__alloc_traits_difference_type<allocator<double>, double *, true> &const __alloc_traits_difference_type<allocator<double>, double *, true>const __alloc_traits_difference_type<allocator<double>, double *, true> &__size_type<allocator<double>, long, true>__size_type<allocator<double>, long, true> &const __size_type<allocator<double>, long, true>const __size_type<allocator<double>, long, true> &__propagate_on_container_move_assignment<allocator<double>, true>__propagate_on_container_move_assignment<allocator<double>, true> &const __propagate_on_container_move_assignment<allocator<double>, true>const __propagate_on_container_move_assignment<allocator<double>, true> &__is_always_equal<allocator<double>, true>__is_always_equal<allocator<double>, true> &const __is_always_equal<allocator<double>, true>const __is_always_equal<allocator<double>, true> &__compressed_pair_elem<allocator<double>, 1, true>__compressed_pair_elem<allocator<double>, 1, true> &const __compressed_pair_elem<allocator<double>, 1, true>const __compressed_pair_elem<allocator<double>, 1, true> &__compressed_pair_elem<double *, 0, false>__compressed_pair_elem<double *, 0, false> &const __compressed_pair_elem<double *, 0, false>const __compressed_pair_elem<double *, 0, false> &double *constdouble *const &double *&__compressed_pair<basic_string<char, char_traits<char>, allocator<char>> *, allocator<basic_string<char, char_traits<char>, allocator<char>>>>__compressed_pair<basic_string<char, char_traits<char>, allocator<char>> *, allocator<basic_string<char, char_traits<char>, allocator<char>>>> &const __compressed_pair<basic_string<char, char_traits<char>, allocator<char>> *, allocator<basic_string<char, char_traits<char>, allocator<char>>>>const __compressed_pair<basic_string<char, char_traits<char>, allocator<char>> *, allocator<basic_string<char, char_traits<char>, allocator<char>>>> &__pointer<basic_string<char, char_traits<char>, allocator<char>>, allocator<basic_string<char, char_traits<char>, allocator<char>>>, allocator<basic_string<char, char_traits<char>, allocator<char>>>, true>__pointer<basic_string<char, char_traits<char>, allocator<char>>, allocator<basic_string<char, char_traits<char>, allocator<char>>>, allocator<basic_string<char, char_traits<char>, allocator<char>>>, true> &const __pointer<basic_string<char, char_traits<char>, allocator<char>>, allocator<basic_string<char, char_traits<char>, allocator<char>>>, allocator<basic_string<char, char_traits<char>, allocator<char>>>, true>const __pointer<basic_string<char, char_traits<char>, allocator<char>>, allocator<basic_string<char, char_traits<char>, allocator<char>>>, allocator<basic_string<char, char_traits<char>, allocator<char>>>, true> &__const_pointer<basic_string<char, char_traits<char>, allocator<char>>, basic_string<char, char_traits<char>, allocator<char>> *, allocator<basic_string<char, char_traits<char>, allocator<char>>>, true>__const_pointer<basic_string<char, char_traits<char>, allocator<char>>, basic_string<char, char_traits<char>, allocator<char>> *, allocator<basic_string<char, char_traits<char>, allocator<char>>>, true> &const __const_pointer<basic_string<char, char_traits<char>, allocator<char>>, basic_string<char, char_traits<char>, allocator<char>> *, allocator<basic_string<char, char_traits<char>, allocator<char>>>, true>const __const_pointer<basic_string<char, char_traits<char>, allocator<char>>, basic_string<char, char_traits<char>, allocator<char>> *, allocator<basic_string<char, char_traits<char>, allocator<char>>>, true> &__void_pointer<basic_string<char, char_traits<char>, allocator<char>> *, allocator<basic_string<char, char_traits<char>, allocator<char>>>, false>__void_pointer<basic_string<char, char_traits<char>, allocator<char>> *, allocator<basic_string<char, char_traits<char>, allocator<char>>>, false> &const __void_pointer<basic_string<char, char_traits<char>, allocator<char>> *, allocator<basic_string<char, char_traits<char>, allocator<char>>>, false>const __void_pointer<basic_string<char, char_traits<char>, allocator<char>> *, allocator<basic_string<char, char_traits<char>, allocator<char>>>, false> &__const_void_pointer<basic_string<char, char_traits<char>, allocator<char>> *, allocator<basic_string<char, char_traits<char>, allocator<char>>>, false>__const_void_pointer<basic_string<char, char_traits<char>, allocator<char>> *, allocator<basic_string<char, char_traits<char>, allocator<char>>>, false> &const __const_void_pointer<basic_string<char, char_traits<char>, allocator<char>> *, allocator<basic_string<char, char_traits<char>, allocator<char>>>, false>const __const_void_pointer<basic_string<char, char_traits<char>, allocator<char>> *, allocator<basic_string<char, char_traits<char>, allocator<char>>>, false> &__alloc_traits_difference_type<allocator<basic_string<char, char_traits<char>, allocator<char>>>, basic_string<char, char_traits<char>, allocator<char>> *, true>__alloc_traits_difference_type<allocator<basic_string<char, char_traits<char>, allocator<char>>>, basic_string<char, char_traits<char>, allocator<char>> *, true> &const __alloc_traits_difference_type<allocator<basic_string<char, char_traits<char>, allocator<char>>>, basic_string<char, char_traits<char>, allocator<char>> *, true>const __alloc_traits_difference_type<allocator<basic_string<char, char_traits<char>, allocator<char>>>, basic_string<char, char_traits<char>, allocator<char>> *, true> &__size_type<allocator<basic_string<char, char_traits<char>, allocator<char>>>, long, true>__size_type<allocator<basic_string<char, char_traits<char>, allocator<char>>>, long, true> &const __size_type<allocator<basic_string<char, char_traits<char>, allocator<char>>>, long, true>const __size_type<allocator<basic_string<char, char_traits<char>, allocator<char>>>, long, true> &__propagate_on_container_move_assignment<allocator<basic_string<char, char_traits<char>, allocator<char>>>, true>__propagate_on_container_move_assignment<allocator<basic_string<char, char_traits<char>, allocator<char>>>, true> &const __propagate_on_container_move_assignment<allocator<basic_string<char, char_traits<char>, allocator<char>>>, true>const __propagate_on_container_move_assignment<allocator<basic_string<char, char_traits<char>, allocator<char>>>, true> &__is_always_equal<allocator<basic_string<char, char_traits<char>, allocator<char>>>, true>__is_always_equal<allocator<basic_string<char, char_traits<char>, allocator<char>>>, true> &const __is_always_equal<allocator<basic_string<char, char_traits<char>, allocator<char>>>, true>const __is_always_equal<allocator<basic_string<char, char_traits<char>, allocator<char>>>, true> &__compressed_pair<unsigned long, __map_value_compare<basic_string<char, char_traits<char>, allocator<char>>, __value_type<basic_string<char, char_traits<char>, allocator<char>>, basic_string<char, char_traits<char>, allocator<char>>>, LangAltValueComparator, true>>__compressed_pair<unsigned long, __map_value_compare<basic_string<char, char_traits<char>, allocator<char>>, __value_type<basic_string<char, char_traits<char>, allocator<char>>, basic_string<char, char_traits<char>, allocator<char>>>, LangAltValueComparator, true>> &const __compressed_pair<unsigned long, __map_value_compare<basic_string<char, char_traits<char>, allocator<char>>, __value_type<basic_string<char, char_traits<char>, allocator<char>>, basic_string<char, char_traits<char>, allocator<char>>>, LangAltValueComparator, true>>const __compressed_pair<unsigned long, __map_value_compare<basic_string<char, char_traits<char>, allocator<char>>, __value_type<basic_string<char, char_traits<char>, allocator<char>>, basic_string<char, char_traits<char>, allocator<char>>>, LangAltValueComparator, true>> &__compressed_pair<unsigned char *, allocator<unsigned char>>__compressed_pair<unsigned char *, allocator<unsigned char>> &const __compressed_pair<unsigned char *, allocator<unsigned char>>const __compressed_pair<unsigned char *, allocator<unsigned char>> &__pointer<unsigned char, allocator<unsigned char>, allocator<unsigned char>, true>__pointer<unsigned char, allocator<unsigned char>, allocator<unsigned char>, true> &const __pointer<unsigned char, allocator<unsigned char>, allocator<unsigned char>, true>const __pointer<unsigned char, allocator<unsigned char>, allocator<unsigned char>, true> &__const_pointer<unsigned char, unsigned char *, allocator<unsigned char>, true>__const_pointer<unsigned char, unsigned char *, allocator<unsigned char>, true> &const __const_pointer<unsigned char, unsigned char *, allocator<unsigned char>, true>const __const_pointer<unsigned char, unsigned char *, allocator<unsigned char>, true> &__void_pointer<unsigned char *, allocator<unsigned char>, false>__void_pointer<unsigned char *, allocator<unsigned char>, false> &const __void_pointer<unsigned char *, allocator<unsigned char>, false>const __void_pointer<unsigned char *, allocator<unsigned char>, false> &__const_void_pointer<unsigned char *, allocator<unsigned char>, false>__const_void_pointer<unsigned char *, allocator<unsigned char>, false> &const __const_void_pointer<unsigned char *, allocator<unsigned char>, false>const __const_void_pointer<unsigned char *, allocator<unsigned char>, false> &__alloc_traits_difference_type<allocator<unsigned char>, unsigned char *, true>__alloc_traits_difference_type<allocator<unsigned char>, unsigned char *, true> &const __alloc_traits_difference_type<allocator<unsigned char>, unsigned char *, true>const __alloc_traits_difference_type<allocator<unsigned char>, unsigned char *, true> &__size_type<allocator<unsigned char>, long, true>__size_type<allocator<unsigned char>, long, true> &const __size_type<allocator<unsigned char>, long, true>const __size_type<allocator<unsigned char>, long, true> &__propagate_on_container_move_assignment<allocator<unsigned char>, true>__propagate_on_container_move_assignment<allocator<unsigned char>, true> &const __propagate_on_container_move_assignment<allocator<unsigned char>, true>const __propagate_on_container_move_assignment<allocator<unsigned char>, true> &__is_always_equal<allocator<unsigned char>, true>__is_always_equal<allocator<unsigned char>, true> &const __is_always_equal<allocator<unsigned char>, true>const __is_always_equal<allocator<unsigned char>, true> &__promote_imp<float, void, void, true>__promote_imp<float, void, void, true> &const __promote_imp<float, void, void, true>const __promote_imp<float, void, void, true> &__numeric_type<float>__numeric_type<float> &const __numeric_type<float>const __numeric_type<float> &float &&__promote_imp<long double, void, void, true>__promote_imp<long double, void, void, true> &const __promote_imp<long double, void, void, true>const __promote_imp<long double, void, void, true> &__numeric_type<long double>__numeric_type<long double> &const __numeric_type<long double>const __numeric_type<long double> &long double &&is_void<const Exifdatum>is_void<const Exifdatum> &const is_void<const Exifdatum>const is_void<const Exifdatum> &const __compressed_pair<unsigned long, allocator<__list_node<Exifdatum, void *>>> *__compressed_pair<unsigned long, allocator<__list_node<Exifdatum, void *>>> *const basic_ios<char, char_traits<char>> *const ostreambuf_iterator<char, char_traits<char>> *conditional<false, __nat, __list_node_base<Exifdatum, void *>>conditional<false, __nat, __list_node_base<Exifdatum, void *>> &const conditional<false, __nat, __list_node_base<Exifdatum, void *>>const conditional<false, __nat, __list_node_base<Exifdatum, void *>> &pointer_traits<__list_node_base<Exifdatum, void *> *>pointer_traits<__list_node_base<Exifdatum, void *> *> &const pointer_traits<__list_node_base<Exifdatum, void *> *>const pointer_traits<__list_node_base<Exifdatum, void *> *> &__compressed_pair_elem<allocator<unsigned char>, 1, true>__compressed_pair_elem<allocator<unsigned char>, 1, true> &const __compressed_pair_elem<allocator<unsigned char>, 1, true>const __compressed_pair_elem<allocator<unsigned char>, 1, true> &__compressed_pair_elem<unsigned char *, 0, false>__compressed_pair_elem<unsigned char *, 0, false> &const __compressed_pair_elem<unsigned char *, 0, false>const __compressed_pair_elem<unsigned char *, 0, false> &unsigned char *constunsigned char *const &__compressed_pair_elem<__map_value_compare<basic_string<char, char_traits<char>, allocator<char>>, __value_type<basic_string<char, char_traits<char>, allocator<char>>, basic_string<char, char_traits<char>, allocator<char>>>, LangAltValueComparator, true>, 1, true>__compressed_pair_elem<__map_value_compare<basic_string<char, char_traits<char>, allocator<char>>, __value_type<basic_string<char, char_traits<char>, allocator<char>>, basic_string<char, char_traits<char>, allocator<char>>>, LangAltValueComparator, true>, 1, true> &const __compressed_pair_elem<__map_value_compare<basic_string<char, char_traits<char>, allocator<char>>, __value_type<basic_string<char, char_traits<char>, allocator<char>>, basic_string<char, char_traits<char>, allocator<char>>>, LangAltValueComparator, true>, 1, true>const __compressed_pair_elem<__map_value_compare<basic_string<char, char_traits<char>, allocator<char>>, __value_type<basic_string<char, char_traits<char>, allocator<char>>, basic_string<char, char_traits<char>, allocator<char>>>, LangAltValueComparator, true>, 1, true> &__compressed_pair_elem<allocator<basic_string<char, char_traits<char>, allocator<char>>>, 1, true>__compressed_pair_elem<allocator<basic_string<char, char_traits<char>, allocator<char>>>, 1, true> &const __compressed_pair_elem<allocator<basic_string<char, char_traits<char>, allocator<char>>>, 1, true>const __compressed_pair_elem<allocator<basic_string<char, char_traits<char>, allocator<char>>>, 1, true> &__compressed_pair_elem<basic_string<char, char_traits<char>, allocator<char>> *, 0, false>__compressed_pair_elem<basic_string<char, char_traits<char>, allocator<char>> *, 0, false> &const __compressed_pair_elem<basic_string<char, char_traits<char>, allocator<char>> *, 0, false>const __compressed_pair_elem<basic_string<char, char_traits<char>, allocator<char>> *, 0, false> &basic_string<char, char_traits<char>, allocator<char>> *constbasic_string<char, char_traits<char>, allocator<char>> *const &is_same<__list_node_base<Exifdatum, void *> *, __list_node<Exifdatum, void *> *>is_sameis_same<__list_node_base<Exifdatum, void *> *, __list_node<Exifdatum, void *> *> &const is_same<__list_node_base<Exifdatum, void *> *, __list_node<Exifdatum, void *> *>const is_same<__list_node_base<Exifdatum, void *> *, __list_node<Exifdatum, void *> *> &is_pointer<void *>is_pointer<void *> &const is_pointer<void *>const is_pointer<void *> &__pointer<__list_node_base<Exifdatum, void *>, allocator<__list_node_base<Exifdatum, void *>>, allocator<__list_node_base<Exifdatum, void *>>, true>__pointer<__list_node_base<Exifdatum, void *>, allocator<__list_node_base<Exifdatum, void *>>, allocator<__list_node_base<Exifdatum, void *>>, true> &const __pointer<__list_node_base<Exifdatum, void *>, allocator<__list_node_base<Exifdatum, void *>>, allocator<__list_node_base<Exifdatum, void *>>, true>const __pointer<__list_node_base<Exifdatum, void *>, allocator<__list_node_base<Exifdatum, void *>>, allocator<__list_node_base<Exifdatum, void *>>, true> &__size_type<allocator<__list_node_base<Exifdatum, void *>>, long, true>__size_type<allocator<__list_node_base<Exifdatum, void *>>, long, true> &const __size_type<allocator<__list_node_base<Exifdatum, void *>>, long, true>const __size_type<allocator<__list_node_base<Exifdatum, void *>>, long, true> &__const_void_pointer<__list_node_base<Exifdatum, void *> *, allocator<__list_node_base<Exifdatum, void *>>, false>__const_void_pointer<__list_node_base<Exifdatum, void *> *, allocator<__list_node_base<Exifdatum, void *>>, false> &const __const_void_pointer<__list_node_base<Exifdatum, void *> *, allocator<__list_node_base<Exifdatum, void *>>, false>const __const_void_pointer<__list_node_base<Exifdatum, void *> *, allocator<__list_node_base<Exifdatum, void *>>, false> &__const_pointer<__list_node_base<Exifdatum, void *>, __list_node_base<Exifdatum, void *> *, allocator<__list_node_base<Exifdatum, void *>>, true>__const_pointer<__list_node_base<Exifdatum, void *>, __list_node_base<Exifdatum, void *> *, allocator<__list_node_base<Exifdatum, void *>>, true> &const __const_pointer<__list_node_base<Exifdatum, void *>, __list_node_base<Exifdatum, void *> *, allocator<__list_node_base<Exifdatum, void *>>, true>const __const_pointer<__list_node_base<Exifdatum, void *>, __list_node_base<Exifdatum, void *> *, allocator<__list_node_base<Exifdatum, void *>>, true> &__void_pointer<__list_node_base<Exifdatum, void *> *, allocator<__list_node_base<Exifdatum, void *>>, false>__void_pointer<__list_node_base<Exifdatum, void *> *, allocator<__list_node_base<Exifdatum, void *>>, false> &const __void_pointer<__list_node_base<Exifdatum, void *> *, allocator<__list_node_base<Exifdatum, void *>>, false>const __void_pointer<__list_node_base<Exifdatum, void *> *, allocator<__list_node_base<Exifdatum, void *>>, false> &__alloc_traits_difference_type<allocator<__list_node_base<Exifdatum, void *>>, __list_node_base<Exifdatum, void *> *, true>__alloc_traits_difference_type<allocator<__list_node_base<Exifdatum, void *>>, __list_node_base<Exifdatum, void *> *, true> &const __alloc_traits_difference_type<allocator<__list_node_base<Exifdatum, void *>>, __list_node_base<Exifdatum, void *> *, true>const __alloc_traits_difference_type<allocator<__list_node_base<Exifdatum, void *>>, __list_node_base<Exifdatum, void *> *, true> &__propagate_on_container_move_assignment<allocator<__list_node_base<Exifdatum, void *>>, true>__propagate_on_container_move_assignment<allocator<__list_node_base<Exifdatum, void *>>, true> &const __propagate_on_container_move_assignment<allocator<__list_node_base<Exifdatum, void *>>, true>const __propagate_on_container_move_assignment<allocator<__list_node_base<Exifdatum, void *>>, true> &__is_always_equal<allocator<__list_node_base<Exifdatum, void *>>, true>__is_always_equal<allocator<__list_node_base<Exifdatum, void *>>, true> &const __is_always_equal<allocator<__list_node_base<Exifdatum, void *>>, true>const __is_always_equal<allocator<__list_node_base<Exifdatum, void *>>, true> &__pointer<Exifdatum, allocator<Exifdatum>, allocator<Exifdatum>, true>__pointer<Exifdatum, allocator<Exifdatum>, allocator<Exifdatum>, true> &const __pointer<Exifdatum, allocator<Exifdatum>, allocator<Exifdatum>, true>const __pointer<Exifdatum, allocator<Exifdatum>, allocator<Exifdatum>, true> &__const_pointer<Exifdatum, Exifdatum *, allocator<Exifdatum>, true>__const_pointer<Exifdatum, Exifdatum *, allocator<Exifdatum>, true> &const __const_pointer<Exifdatum, Exifdatum *, allocator<Exifdatum>, true>const __const_pointer<Exifdatum, Exifdatum *, allocator<Exifdatum>, true> &__void_pointer<Exifdatum *, allocator<Exifdatum>, false>__void_pointer<Exifdatum *, allocator<Exifdatum>, false> &const __void_pointer<Exifdatum *, allocator<Exifdatum>, false>const __void_pointer<Exifdatum *, allocator<Exifdatum>, false> &__const_void_pointer<Exifdatum *, allocator<Exifdatum>, false>__const_void_pointer<Exifdatum *, allocator<Exifdatum>, false> &const __const_void_pointer<Exifdatum *, allocator<Exifdatum>, false>const __const_void_pointer<Exifdatum *, allocator<Exifdatum>, false> &__alloc_traits_difference_type<allocator<Exifdatum>, Exifdatum *, true>__alloc_traits_difference_type<allocator<Exifdatum>, Exifdatum *, true> &const __alloc_traits_difference_type<allocator<Exifdatum>, Exifdatum *, true>const __alloc_traits_difference_type<allocator<Exifdatum>, Exifdatum *, true> &__size_type<allocator<Exifdatum>, long, true>__size_type<allocator<Exifdatum>, long, true> &const __size_type<allocator<Exifdatum>, long, true>const __size_type<allocator<Exifdatum>, long, true> &__propagate_on_container_move_assignment<allocator<Exifdatum>, true>__propagate_on_container_move_assignment<allocator<Exifdatum>, true> &const __propagate_on_container_move_assignment<allocator<Exifdatum>, true>const __propagate_on_container_move_assignment<allocator<Exifdatum>, true> &__is_always_equal<allocator<Exifdatum>, true>__is_always_equal<allocator<Exifdatum>, true> &const __is_always_equal<allocator<Exifdatum>, true>const __is_always_equal<allocator<Exifdatum>, true> &rebind_alloc<__list_node_base<Exifdatum, void *>>rebind_alloc<__list_node_base<Exifdatum, void *>> &const rebind_alloc<__list_node_base<Exifdatum, void *>>const rebind_alloc<__list_node_base<Exifdatum, void *>> &rebind_alloc<__list_node<Exifdatum, void *>>rebind_alloc<__list_node<Exifdatum, void *>> &const rebind_alloc<__list_node<Exifdatum, void *>>const rebind_alloc<__list_node<Exifdatum, void *>> &__compressed_pair_elem<allocator<__list_node<Exifdatum, void *>>, 1, true>__compressed_pair_elem<allocator<__list_node<Exifdatum, void *>>, 1, true> &const __compressed_pair_elem<allocator<__list_node<Exifdatum, void *>>, 1, true>const __compressed_pair_elem<allocator<__list_node<Exifdatum, void *>>, 1, true> &value_type()remove_reference<const allocator<char> &>remove_reference<const allocator<char> &> &const remove_reference<const allocator<char> &>const remove_reference<const allocator<char> &> &pointer_traits<__list_node<Exifdatum, void *> *>pointer_traits<__list_node<Exifdatum, void *> *> &const pointer_traits<__list_node<Exifdatum, void *> *>const pointer_traits<__list_node<Exifdatum, void *> *> &pointer_traits<pair<unsigned int, unsigned int> *>pointer_traits<pair<unsigned int, unsigned int> *> &const pointer_traits<pair<unsigned int, unsigned int> *>const pointer_traits<pair<unsigned int, unsigned int> *> &pointer_traits<pair<int, int> *>pointer_traits<pair<int, int> *> &const pointer_traits<pair<int, int> *>const pointer_traits<pair<int, int> *> &pointer_traits<float *>pointer_traits<float *> &const pointer_traits<float *>const pointer_traits<float *> &pointer_traits<double *>pointer_traits<double *> &const pointer_traits<double *>const pointer_traits<double *> &pointer_traits<basic_string<char, char_traits<char>, allocator<char>> *>pointer_traits<basic_string<char, char_traits<char>, allocator<char>> *> &const pointer_traits<basic_string<char, char_traits<char>, allocator<char>> *>const pointer_traits<basic_string<char, char_traits<char>, allocator<char>> *> &pointer_traits<unsigned char *>pointer_traits<unsigned char *> &const pointer_traits<unsigned char *>const pointer_traits<unsigned char *> &allocator<char> */Users/owura/Repos/codeql_eval/proj_repos/Exiv2-exiv2-pull-962-commits-e925bc5addd881543fa503470c8a859e112cca62/exiv2/src/casiomn_int.hppCasio2MakerNote &const Casio2MakerNoteconst Casio2MakerNote &CasioMakerNote &const CasioMakerNoteconst CasioMakerNote &Casio2MakerNoteCasioMakerNoteCASIOMN_INT_HPP_print0x2022print0x2001print0x0015// #ifndef CasioMN_INT_HPP_// class Casio2MakerNote//! Makernote tag list//! Print ObjectDistance//! Print FirmwareDate//! Return read-only list of built-in Casio2 tags//! MakerNote for Casio2 cameras// class CasioMakerNote//! Return read-only list of built-in Casio tags//! MakerNote for Casio cameras/*!
  @file    casiomn_int.hpp
  @brief   Casio MakerNote implemented using the following references:
           <a href="http://gvsoft.homedns.org/exif/makernote-casio-type1.html">Casio MakerNote Information</a> by GVsoft,
           Casio.pm of <a href="http://www.sno.phy.queensu.ca/~phil/exiftool/">ExifTool</a> by Phil Harvey,
           <a href="http://www.ozhiker.com/electronics/pjmt/jpeg_info/casio_mn.html#Casio_Type_1_Tags">Casio Makernote Format Specification</a> by Evan Hunter.
  @date    30-Oct-13, ahu: created
 *//Users/owura/Repos/codeql_eval/proj_repos/Exiv2-exiv2-pull-962-commits-e925bc5addd881543fa503470c8a859e112cca62/exiv2/src/casiomn_int.cpp"casiomn_int.hpp""Inf"536870912Inf1000.0const vector<char, allocator<char>>const TagInfo[50]TagInfo[50]const TagInfo[20]TagInfo[20]"HD (720p)""Full HD (1080p)"const TagDetails[4]TagDetails[4]HD (720p)Full HD (1080p)casio2VideoQuality"Single Shot""Continuous Shooting""Continuous (2 fps)""Continuous (3 fps)""Continuous (4 fps)""Continuous (5 fps)""Continuous (6 fps)""Continuous (7 fps)""Continuous (10 fps)""Continuous (12 fps)""Continuous (15 fps)""Continuous (20 fps)""Continuous (30 fps)""Continuous (40 fps)""Continuous (60 fps)""Auto-N"const TagDetails[16]TagDetails[16]Single ShotContinuous ShootingContinuous (2 fps)Continuous (3 fps)Continuous (4 fps)Continuous (5 fps)Continuous (6 fps)Continuous (7 fps)Continuous (10 fps)Continuous (12 fps)Continuous (15 fps)Continuous (20 fps)Continuous (30 fps)Continuous (40 fps)Continuous (60 fps)Auto-Ncasio2DriveMode"Makeup""Mist Removal""Vivid Landscape""Art Shot"MakeupMist RemovalVivid LandscapeArt Shotcasio2SpecialEffectSetting"+1""+2"+1+2casio2PortraitRefiner"Shadow Enhance Low""Shadow Enhance High"Shadow Enhance LowShadow Enhance Highcasio2LightingMode"Silent Movie""HDR""Premium Auto""Painting""Crayon Drawing""Art HDR""High Speed Night Shot""Toy Camera""Pop Art""Light Tone"const TagDetails[13]TagDetails[13]Silent MovieHDRPremium AutoPaintingCrayon DrawingArt HDRHigh Speed Night ShotToy CameraPop ArtLight Tonecasio2ArtMode"Pink"Pinkcasio2ColorFilter"Scenery""Unterwater""Flesh Tones"SceneryUnterwaterFlesh Tonescasio2Enhancementcasio2ColorMode"Multi""Face Detection""Tracking""Intelligent"MultiFace DetectionTrackingIntelligentcasio2AFMode"On (high sensitiviy)""On (anti-shake)""High Speed"On (high sensitiviy)On (anti-shake)High Speedcasio2AutoISO"Focus Lock""Single-Area Auto Focus""Multi-Area Auto Focus"Focus LockSingle-Area Auto FocusMulti-Area Auto Focuscasio2FocusMode2casio2Quality"AE Bracketing""WB Bracketing""Contrast Bracketing""High Speed Burst"AE BracketingWB BracketingContrast BracketingHigh Speed Burstcasio2ReleaseModecasio2WhiteBalance2"Soft""Hard"SoftHardcasio2Sharpnesscasio2Contrastcasio2Saturationcasio2WhiteBalance"64"casio2IsoSpeedcasio2FocusMode640x480"640x480"1600x1200"1600x1200"2048x1536"2048x1536"2288x1712"2288x1712"2592x1944"2592x1944"2304x1728"2304x1728"3008x2008"3008x2008"casio2ImageSizecasio2QualityMode"+1.0""+2.0""+3.0""Normal (ISO 80 equivalent)"+1.0+2.0+3.0Normal (ISO 80 equivalent)casioCCDSensitivity"Weak""Strong"WeakStrongcasioFlashIntensity2casioColorFiltercasioEnhancementcasioSaturationcasioContrastcasioSharpness"1.2x""1.23x""1.6x""3.2x"786430x133331.2x806090x13ae11.23x1048570x199991.6x2097150x333333.2xcasioDigitalZoomcasioWhiteBalancecasioFlashIntensity"Red-eye Reduction"Red-eye ReductioncasioFlashMode"Sport AF"Sport AFcasioFocusModecasioQuality"Single Shutter"Single ShuttercasioRecordingMode"Preview Image Size""Preview Image Length""Preview Image Start""Quality Mode""ISO Speed""White Balance Setting""Print IM""PrintIM information""Preview Image""Firmware Date""White Balance Bias""AF Point Position""Object Distance""Flash Distance""Special Effect Mode""Face Info""Faces detected""Record Mode""Release Mode""Focus Mode2""Home town city""Best Shot Mode""Auto ISO""AF Mode""Color Mode""Enhancement""Color Filter""Art Mode""Sequence Number""Lighting Mode""Portrait Refiner""Portrait Refiner settings""Special Effect Level""Special Effect Setting""Art Mode Parameters""Capture Frame Rate""Video Quality""Unknown Casio2MakerNote tag"PreviewImageSize"PreviewImageSize"Preview Image SizePreviewImageLength"PreviewImageLength"Preview Image LengthPreviewImageStart"PreviewImageStart"Preview Image StartQualityMode"QualityMode"Quality ModeISO SpeedWhite Balance Setting35840x0e00PrintIM"PrintIM"Print IMPrintIM information"PreviewImage"Preview Image81930x2001FirmwareDate"FirmwareDate"Firmware Date82090x2011WhiteBalanceBias"WhiteBalanceBias"White Balance Bias82100x2012WhiteBalance2"WhiteBalance2"82250x2021AFPointPosition"AFPointPosition"AF Point Position82260x2022ObjectDistance"ObjectDistance"Object Distance82440x2034FlashDistance"FlashDistance"Flash Distance83100x2076SpecialEffectMode"SpecialEffectMode"Special Effect Mode83290x2089FaceInfo"FaceInfo"Face Info84760x211cFacesDetected"FacesDetected"Faces detectedRecordMode"RecordMode"Record ModeReleaseMode"ReleaseMode"Release ModeFocusMode2"FocusMode2"Focus Mode2122940x3006HometownCity"HometownCity"Home town city122950x3007BestShotMode"BestShotMode"Best Shot Mode122960x3008AutoISO"AutoISO"Auto ISO122970x3009AFMode"AFMode"AF Mode123050x3011Sharpness2"Sharpness2"123060x3012Contrast2"Contrast2"123070x3013Saturation2"Saturation2"123080x3014123090x3015ColorMode"ColorMode"Color Mode123100x3016Enhancement123110x3017ColorFilter"ColorFilter"Color Filter123150x301bArtMode"ArtMode"Art Mode123160x301cSequenceNumber"SequenceNumber"Sequence Number123200x3020123300x302aLightingMode"LightingMode"Lighting Mode123310x302bPortraitRefiner"PortraitRefiner"Portrait RefinerPortrait Refiner settings123360x3030SpecialEffectLevel"SpecialEffectLevel"Special Effect Level123370x3031SpecialEffectSetting"SpecialEffectSetting"Special Effect Setting125470x3103125550x310bArtModeParameters"ArtModeParameters"Art Mode ParametersCaptureFrameRate"CaptureFrameRate"Capture Frame Rate163870x4003VideoQuality"VideoQuality"Video Quality(UnknownCasio2MakerNoteTag)"(UnknownCasio2MakerNoteTag)"Unknown Casio2MakerNote tag"RecodingMode""Recording Mode""Flash Intensity""Distance to object""White balance settings""Firmware date""CCDSensitivity""Unknown CasioMakerNote tag"RecodingModeRecording ModeFlashIntensity"FlashIntensity"Flash IntensityDistance to objectWhite balance settingsFirmware dateFlashIntensity2"FlashIntensity2"CCDSensitivity(UnknownCasioMakerNoteTag)"(UnknownCasioMakerNoteTag)"Unknown CasioMakerNote tag// month, day, hour, minutes//year// format is:  "YYMM#00#00DDHH#00#00MM#00#00#00#00"// Casio2 MakerNote Tag Info//! Video Quality, tag 0x4003//! Drive Mode, tag 0x3103//! Special Effect Setting, tag 0x3031//! Portrait Refiner, tag 0x302b//! Lighting Mode, tag 0x302a//! Art Mode, tag 0x301b//! Color Filter, tag 0x3017//! Enhancement, tag 0x3016//! ColorMode, tag 0x3015//! AFMode, tag 0x3009//! AutoISO, tag 0x3008//! Focus Mode 2, tag 0x3003//! Quality, tag 0x3002//! Release Mode, tag 0x3001//! White Balance2, tag 0x2012//! Sharpness, tag 0x0021//! Contrast, tag 0x0020//! Saturation, tag 0x001f//! White Balance, tag 0x0019//! ISO Speed, tag 0x0014//! Focus Mode, tag 0x000d//! Image Size, tag 0x0009//! Quality Mode, tag 0x0004//Casio Makernotes, Type 2// optional seconds// format is:  "YYMM#00#00DDHH#00#00MM#00#00#00#00" or  "YYMM#00#00DDHH#00#00MMSS#00#00#00"// Casio MakerNote Tag Info//! CCD Sensitivity intensity, tag 0x0020//! flash intensity 2, tag 0x0019//! Color filter, tag 0x0017//! Enhancement, tag 0x0016//! Saturation, tag 0x000d//! Contrast, tag 0x000c//! Sharpness, tag 0x000b//! Flash intensity, tag 0x0005//! white balance, tag 0x0007//! Focus Mode, tag 0x0003//! Quality, tag 0x0002//! RecordingMode, tag 0x0001/*
  File:      Casiomn.cpp
  History:   30-Oct-13, ahu: created
  Credits:   See header file
 */__vector_base<char, allocator<char>>__vector_base<char, allocator<char>> &const __vector_base<char, allocator<char>>const __vector_base<char, allocator<char>> &vector<char, allocator<char>>__identity<allocator<char>>__identity<allocator<char>> &const __identity<allocator<char>>const __identity<allocator<char>> &const TagDetails(&)[4]TagDetails(&)[4]const TagDetails(&)[16]TagDetails(&)[16]const TagDetails(&)[13]TagDetails(&)[13]vector<char, allocator<char>> *const vector<char, allocator<char>> *__vector_base<char, allocator<char>> *const __vector_base<char, allocator<char>> *vector<char, allocator<char>> &__compressed_pair<char *, allocator<char>>__compressed_pair<char *, allocator<char>> &const __compressed_pair<char *, allocator<char>>const __compressed_pair<char *, allocator<char>> &const char &&char &&__split_buffer<char, allocator<char> &> &remove_reference<const char &>remove_reference<const char &> &const remove_reference<const char &>const remove_reference<const char &> &remove_reference<const char>remove_reference<const char> &const remove_reference<const char>const remove_reference<const char> &__split_buffer<char, allocator<char> &>__compressed_pair_elem<char *, 0, false>__compressed_pair_elem<char *, 0, false> &const __compressed_pair_elem<char *, 0, false>const __compressed_pair_elem<char *, 0, false> &__compressed_pair<char *, allocator<char>> *__split_buffer<char, allocator<char> &> *const __split_buffer<char, allocator<char> &>const __split_buffer<char, allocator<char> &> *__compressed_pair<char *, allocator<char> &>__compressed_pair<char *, allocator<char> &> &const __compressed_pair<char *, allocator<char> &>const __compressed_pair<char *, allocator<char> &> &remove_reference<allocator<char> &>remove_reference<allocator<char> &> &const remove_reference<allocator<char> &>const remove_reference<allocator<char> &> &add_lvalue_reference<allocator<char> &>add_lvalue_reference<allocator<char> &> &const add_lvalue_reference<allocator<char> &>const add_lvalue_reference<allocator<char> &> &char *&&__compressed_pair_elem<char *, 0, false> *remove_reference<char *&>remove_reference<char *&> &const remove_reference<char *&>const remove_reference<char *&> &__add_lvalue_reference_impl<allocator<char> &, true>__add_lvalue_reference_impl<allocator<char> &, true> &const __add_lvalue_reference_impl<allocator<char> &, true>const __add_lvalue_reference_impl<allocator<char> &, true> &__compressed_pair_elem<allocator<char> &, 1, false>__compressed_pair_elem<allocator<char> &, 1, false> &const __compressed_pair_elem<allocator<char> &, 1, false>const __compressed_pair_elem<allocator<char> &, 1, false> &const __compressed_pair<char *, allocator<char>> *__compressed_pair<char *, allocator<char> &> *__is_referenceable<allocator<char> &>__is_referenceable<allocator<char> &> &const __is_referenceable<allocator<char> &>const __is_referenceable<allocator<char> &> &const __compressed_pair_elem<allocator<char>, 1, true>const __compressed_pair<char *, allocator<char> &> *__compressed_pair_elem<allocator<char> &, 1, false> *const __compressed_pair_elem<char *, 0, false> *ios_base::eofbit | ios_base::failbitrestCONVERT_HPP_convertStringCharsetmoveXmpToIptccopyXmpToIptcmoveIptcToXmpcopyIptcToXmpsyncExifWithXmpmoveXmpToExifcopyXmpToExifmoveExifToXmpcopyExifToXmp// #ifndef CONVERT_HPP_/*!
      @brief Convert character encoding of \em str from \em from to \em to.
             If the function succeeds, \em str contains the result string.

      This function uses the iconv library, if the %Exiv2 library was compiled
      with iconv support.  Otherwise, on Windows, it uses Windows functions to
      support a limited number of conversions and fails with a warning if an
      unsupported conversion is attempted.  If the function is called but %Exiv2
      was not compiled with iconv support and can't use Windows functions, it
      fails with a warning.

      The conversions supported on Windows without iconv are:

      <TABLE>
      <TR><TD><B>from</B></TD><TD><B>to</B></TD></TR>
      <TR><TD>UTF-8</TD>     <TD>UCS-2BE</TD></TR>
      <TR><TD>UTF-8</TD>     <TD>UCS-2LE</TD></TR>
      <TR><TD>UCS-2BE</TD>   <TD>UTF-8</TD></TR>
      <TR><TD>UCS-2BE</TD>   <TD>UCS-2LE</TD></TR>
      <TR><TD>UCS-2LE</TD>   <TD>UTF-8</TD></TR>
      <TR><TD>UCS-2LE</TD>   <TD>UCS-2BE</TD></TR>
      <TR><TD>ISO-8859-1</TD><TD>UTF-8</TD></TR>
      <TR><TD>ASCII</TD>     <TD>UTF-8</TD></TR>
      </TABLE>

      @param str  The string to convert. It is updated to the converted string,
                  which may have a different size. If the function call fails,
                  the string is not modified.
      @param from Charset in which the input string is encoded as a name
                  understood by \c iconv_open(3).
      @param to   Charset to convert the string to as a name
                  understood by \c iconv_open(3).
      @return Return \c true if the conversion was successful, else \c false.
     *///! Convert (move) XMP properties to IPTC tags, remove converted XMP properties.//! Convert (copy) XMP properties to IPTC datasets.//! Convert (move) IPTC datasets to XMP properties, remove converted IPTC datasets.//! Convert (copy) IPTC datasets to XMP properties.//! Detect which metadata are newer and perform a copy in appropriate direction.//! Convert (move) XMP properties to Exif tags, remove converted XMP properties.//! Convert (copy) XMP properties to Exif tags.//! Convert (move) Exif tags to XMP properties, remove converted Exif tags.//! Convert (copy) Exif tags to XMP properties./*!
  @file    convert.hpp
  @brief   Exif and IPTC conversions to and from XMP
  @author  Andreas Huggel (ahu)
           <a href="mailto:ahuggel@gmx.net">ahuggel@gmx.net</a><BR>
           Vladimir Nadvornik (vn)
           <a href="mailto:nadvornik@suse.cz">nadvornik@suse.cz</a>
  @date    17-Mar-08, ahu: created basic converter framework<BR>
           20-May-08, vn:  added actual conversion logic
 */iptcCharseticonv_fallbacks &const iconv_fallbacksconst iconv_fallbacks &iconv_hooks &const iconv_hooksconst iconv_hooks &/Users/owura/Repos/codeql_eval/proj_repos/Exiv2-exiv2-pull-962-commits-e925bc5addd881543fa503470c8a859e112cca62/exiv2/xmpsdk/include/TXMPMeta.hppSetObjectOptionsGetObjectOptionsDumpObjectCountArrayItemsCloneSortSetObjectNametStringObjGetObjectNametStringObj *GetInternalRefSerializeToBufferParseFromBufferSetLocalizedTextconst tStringObjconst tStringObj &tStringObj &GetLocalizedTextXMP_OptionBits *SetProperty_Dateconst XMP_DateTimeconst XMP_DateTime &XMP_DateTime &SetProperty_FloatSetProperty_Int64SetProperty_IntSetProperty_BoolGetProperty_DateXMP_DateTime *GetProperty_FloatGetProperty_Int64GetProperty_IntGetProperty_Boolbool *DoesQualifierExistDoesStructFieldExistDoesArrayItemExistDoesPropertyExistDeleteQualifierDeleteStructFieldDeleteArrayItemDeletePropertySetQualifierSetStructFieldAppendArrayItemSetArrayItemSetPropertyGetQualifierGetStructFieldGetArrayItemGetPropertyRegisterStandardAliasesDeleteAliasResolveAliasRegisterAliasDeleteNamespaceGetNamespaceURIGetNamespacePrefixRegisterNamespaceDumpAliasesDumpNamespacesSetGlobalOptionsGetGlobalOptions~TXMPMetaTXMPMetaconst TXMPMeta<tStringObj>const TXMPMeta<tStringObj> &TXMPMeta<tStringObj> &TerminateInitializeGetVersionInfoXMP_VersionInfo *TXMPMeta<tStringObj>TXMPUtils<tStringObj>TXMPIterator<tStringObj>xmpRef__TXMPMeta_hpp__( ! __XMP_hpp__ )// __TXMPMeta_hpp__// class TXMPMeta// *** VS.Net and gcc seem to not handle the friend declarations properly.// *** Should be private, see below.// =============================================================================================/// @}/// \brief Not implemented// ---------------------------------------------------------------------------------------------/// @brief Not implemented/// @see Static functions \c DumpNamespaces() and \c DumpAliases()////// values are client-defined./// @return	A success-fail status value, returned from the handler. Zero is success, failure/// @param clientData A pointer to client-defined data to pass to the handler./// @param outProc The client-defined procedure to handle each line of output./// Invokes a client-defined callback for each line of output./// @brief \c DumpObject() outputs the content of an XMP object to a callback handler for debugging./// @return The number of items./// or the empty string; see \c GetProperty() for namespace prefix usage./// @param arrayName The name of the array. Can be a general path expression, must not be null/// @param schemaNS The namespace URI; see \c GetProperty()./// @brief \c CountArrayItems() reports the number of items currently defined in an array./// @return An XMP object cloned from the original./// @param options Option flags, not currently defined../// assigns the address of the temporary to \c clone3, then deletes the temporary./// The assignment to \c clone3 creates a temporary object, initializes it with the clone,/// </pre>/// SXMPMeta * clone3 = &sourceXMP.Clone();		// ! This does not work!/// <pre>/// This is an example of incorrect usage:/// This is good for local usage, protecting against memory leaks./// The \c clone2 example does not use an explicit pointer./// SXMPMeta   clone2 ( sourceXMP.Clone );  	// This works also. (Not a pointer.)/// SXMPMeta * clone1 = new SXMPMeta ( sourceXMP.Clone() );  // This works./// not a pointer. The following shows correct usage:/// increment a reference count, they do not do a deep copy. This function returns an object,/// Use this function to copy an entire XMP metadata tree. Assignment and copy constructors only/// @brief \c Clone() creates a deep copy of an XMP object./// @brief \c Erase() restores the object to a "just constructed" state./// the "x-default" item placed first./// sorted by value. Language Alternative arrays are sorted by the xml:lang qualifiers, with/// qualified name, i.e. their XML prefix:local form. Unordered arrays of simple items are/// level properties are sorted by name. Within a struct, the fields are sorted by their/// At the top level the namespaces are sorted by their prefixes. Within a namespace, the top/// be convenient when comparing data models, (e.g. by text comparison of DumpObject output)./// Use this function to sort the data model of an XMP object into a canonical order. This can/// @brief \c Sort() sorts the data model tree of an XMP object./// @param name The name as a string object./// Retrieve this client-assigned name with \c GetObjectName()./// @brief \c SetObjectName() assigns a name to this XMP object./// @param name The name as a null-terminated UTF-8 string./// @param name [out] A string object in which to return the name./// Assign this name with \c SetObjectName()./// @brief \c GetObjectName() retrieves the client-assigned name of this XMP object./// @return The reference object./// SXMPMeta calleeXMP ( xmpRef );///   \li The callee's code contains:/// CalleeMethod ( callerXMP.GetInternalRef() );/// SXMPMeta callerXMP;///   \li The caller's code contains:/// CalleeMethod ( XMPMetaRef xmpRef );///   \li The callee's header contains:/// Use this function and the associated constructor like this:/// \c SXMPMeta object./// cloned XMP tree, it is the same underlying XMP object safely wrapped in each client's/// pass, then construct a local object on the callee side. This construction does not create a/// across DLL boundaries. Use this function to obtain a safe internal reference that you can/// Because of this you should not pass \c SXMPMeta objects, or pointers to \c SXMPMeta objects,/// string type to instantiate \c TXMPMeta./// executable, as are the other \c TXMP* classes. Different clients might not use the same/// The \c TXMPMeta class is a normal C++ template, it is instantiated and local to each client/// reconstructed./// @brief Retrieves an internal reference that can be safely passed across DLL boundaries and/// @{/// \name Helper functions.// ==============================// Miscellaneous Member Functions/// If zero (the default) an appropriate amount of padding is computed./// @param padding The amount of padding to be added if a writeable XML packet is created.///   \li \c #kXMP_EncodeUTF32Little - Encode as little-endian UTF-32.///   \li \c #kXMP_EncodeUTF32Big - Encode as big-endian UTF-32.///   \li \c #kXMP_EncodeUTF16Little - Encode as little-endian UTF-16.///   \li \c #kXMP_EncodeUTF16Big - Encode as big-endian UTF-16.///   \li \c #kXMP_EncodeUTF8 - Encode as UTF-8, the default./// In addition to the above options, you can include one of the following encoding options:///   \c kXMP_OmitPacketWrapper.///   this length with no padding.	Cannot be specified together with///   The actual amount of padding is computed. An exception is thrown if the packet exceeds///   \li \c kXMP_ExactPacketLength - The padding parameter provides the overall packet length.///   padding if no \c xmp:Thumbnails property is present. Cannot be specified together with///   \li \c kXMP_IncludeThumbnailPad - Include typical space for a JPEG thumbnail in the///   \li \c kXMP_WriteAliasComments - Include XML comments for aliases.///   \li \c kXMP_UseCompactFormat - Use a highly compact RDF syntax and layout.///   together with \c kXMP_OmitPacketWrapper.///   \li \c kXMP_ReadOnlyPacket - Create a read-only XML packet wapper. Cannot be specified///   \c #kXMP_ExactPacketLength.///   specified together with \c #kXMP_ReadOnlyPacket, \c #kXMP_IncludeThumbnailPad, or///   \li \c kXMP_OmitPacketWrapper - Do not include an XML packet wrapper. This cannot be/// A logical OR of these bit-flag constants:/// The specified options must be logically consistent; an exception is thrown if they are not./// @param options An options flag that controls how the serialization operation is performed./// @param rdfString [out] A string object in which to return the serialized RDF. Must not be null./// \c baseIndent parameters./// This simpler form of the function uses default values for the \c newline, \c indent, and/// @brief \c SerializeToBuffer() serializes metadata in this XMP object into a string as RDF./// element in the serialized RDF. This is convenient when embedding the RDF in other text./// @param baseIndent The number of levels of indentation to be used for the outermost XML/// empty, defaults to two ASCII spaces, U+0020./// @param indent The string to be used for each level of indentation in the serialized RDF. If/// U+000A, the standard XML newline./// @param newline The string to be used as a line terminator. If empty, defaults to linefeed,/// zero (the default) an appropriate amount of padding is computed./// @param padding The amount of padding to be added if a writeable XML packet is created. If/// Use this to prepare metadata for storage as an XMP packet embedded in a file. See \c TXMPFiles::PutXMP()./// @see \c TXMPFiles::GetXMP()///   \li \c #kXMP_RequireXMPMeta - The \c x:xmpmeta XML element is required around \c rdf:RDF.///   \li \c #kXMP_ParseMoreBuffers - This is not the last buffer of input, more calls follow./// OR of these bit-flag constants:/// @param options An options flag that controls how the parse operation is performed. A logical/// @param bufferSize The length of the input buffer in bytes. Zero is a valid value./// @param buffer A pointer to a buffer of input. Can be null if \c bufferSize is 0./// characters./// can be any length. The buffer boundaries need not respect XML tokens or even Unicode/// real input, then make a final call with a zero length and \c #kXMP_NoOptions. The buffers/// terminate an input loop conveniently, pass  the option \c #kXMP_ParseMoreBuffers for all/// You can use this function to combine multiple buffers into a single metadata tree. To/// same as creating a new XMP object from that buffer with the constructor./// If this XMP object is empty and the input buffer contains a complete XMP packet, this is the/// packet embedded in a file) into an XMP object that you can manipulate with the XMP Toolkit./// Use this to convert metadata from serialized RDF form (as, for example, read from an XMP/// @brief \c ParseFromBuffer() parses RDF from a series of input buffers into this XMP object./// also recognized, but its use is strongly discouraged. Serialization is always as UTF-8./// object into RDF. The input for parsing can be any valid Unicode encoding. ISO Latin-1 is/// These functions support parsing serialized RDF into an XMP object, and serializing an XMP/// manipulation with the XMP Toolkit./// metadata read from a file using \c TXMPFiles) must be parsed into an XMP object for/// packet and output to a file. Similarly, metadata in the form of serialized RDF (such as/// The metadata contained in an XMP object must be serialized as RDF for storage in an XMP/// \name Creating and reading serialized RDF./// @param options Option flags, none currently defined./// @param itemValue The new value for the matching array item, specified as a string object./// Must not be null or the empty string./// @param specificLang The name of the specific language as an RFC 3066 tag, or "x-default"./// null or the empty string if no generic language is wanted./// @param genericLang The name of the generic language as an RFC 3066 primary subtag. Can be/// not be null or the empty string; see \c GetProperty() for namespace prefix usage./// @param altTextName The name of the alt-text array. Can be a general path expression, must/// @param schemaNS The namespace URI for the alt-text array; see \c GetProperty().///   x-default.///   modified. If the array was empty, items are created for the specific language and///   specific language. If the array only had an x-default item, the x-default item is also///   \li If the selected item is from the last 2 rules then a new item is created for the///   is not modified.///   other partial matches, a new item is created for the specific language. The x-default item///   \li If the selected item is from a partial match with the generic language and there are///   with the given value.///   the array only has 1 existing item (which is not x-default), an x-default item is added///   matches the existing value of the x-default item, the x-default item is also modified. If///   generic matches, the value of that item is modified. If the existing value of that item///   \li If the selected item is from a match with the generic language and there are no other///   (which is not x-default), an x-default item is added with the given value.///   x-default item, the x-default item is also modified. If the array only has 1 existing item///   item is modified. If the existing value of that item matches the existing value of the///   \li If the selected item is from a match with the specific language, the value of that/// Item values are modified according to these rules:/// are fallbacks used when the specific and generic languages fail to produce a match./// item is an exact match by the first rule, not a selection by the 3rd rule. The last 2 rules/// You can pass "x-default" as the specific language. In this case, selection of an \c x-default/// degenerate case./// the generic string and the next character is '-'. An exact match is also recognized as a/// A partial match with the generic language is where the start of the item's language matches///   \li Choose the first item.///   \li Look for an x-default item.///   \li If a generic language is given, look for a partial match.///   \li Look for an exact match with the specific language./// The array item is selected according to these rules:/// item./// Creates an appropriate array item if necessary, and handles special cases for the x-default/// a string object./// @brief \c SetLocalizedText() modifies the value of a selected item in an alt-text array using/// UTF-8 string./// @param itemValue The new value for the matching array item, specified as a null-terminated/// match./// last 2 rules are fallbacks used when the specific and generic languages fail to produce a/// \c x-default item is an exact match by the first rule, not a selection by the 3rd rule. The/// You can pass "x-default" as the specific language. In this case, selection of an/// @brief \c SetLocalizedText() modifies the value of a selected item in an alt-text array./// @return True if an appropriate array item exists./// an appropriate array item is found. Can be null if the flags are not wanted./// @param options A buffer in which to return the option flags that describe the array item, if/// appropriate array item is found. Can be null if the value is not wanted./// @param itemValue [out] A string object in which to return the value of the array item, if an/// array item, if an appropriate array item is found. Can be null if the language is not wanted./// @param actualLang [out] A string object in which to return the language of the selected/// The return value reports whether a match was successfully made./// @brief \c GetLocalizedText() retrieves information about a selected item in an alt-text array./// has several special features related to the x-default item, see its description for details./// arrays such that the x-default item is the first item. The \c SetLocalizedText() function/// explicitly denote a default item in an alt-text array. The XMP toolkit normalizes alt-text/// The XMP specification defines an artificial language, "x-default", that is used to/// 	\li All other subtags are lower case./// 	\li All 2 letter secondary subtags are upper case, the suggested practice of ISO 3166./// 	\li The primary subtag is lower case, the suggested practice of ISO 639./// does this by normalizing their capitalization:/// \note RFC 3066 language tags must be treated in a case insensitive manner. The XMP toolkit///     \li http://www.w3.org/International/articles/language-tags//// Advice from the W3C about the use of RFC 3066 language tags can be found at:/// poor practice but allowed./// used as a generic language. Passing "i" or "x" as the generic language is also considered/// RFC 3066 primary tag. For example "en" is not a good specific language, it should only be/// It is considered poor practice, but allowed, to pass a specific language that is just an/// selected by using the "en" generic language and the "en-UK" specific language./// generic language in each case. If a US document goes to England, the "en-US" title is/// language of "en-UK" should be used in England. It is also appropriate to use "en" as the/// For example, a specific language of "en-US" should be used in the US, and a specific/// primary subtag, or the empty string./// used if there is no specific language match. The generic language must be a valid RFC 3066/// match. For many languages it is also possible to define a "generic" language that can be/// these languages, the "specific" language, is preferred and selected if there is an exact/// they select an appropriate array item based on one or two RFC 3066 language tags. One of/// number of special and obscure aspects. The most important aspect of these functions is that/// These functions provide convenient support for localized text properties, including a/// languages./// localizations of a property value, for example a document title or copyright in several/// Localized text properties are stored in alt-text arrays. They allow multiple concurrent/// \name Accessing localized text (alt-text) properties./// that already exists./// constants; see \c #kXMP_PropValueIsStruct and following. Must match the type of a property/// @param options Option flags describing the property; a logical OR of allowed bit-flag/// for arrays and non-leaf levels of structs that do not have values./// @param propValue The new binary value. Can be null if creating the property. Must be null/// @param propName The name of the property. Can be a general path expression, must not be null/// Sets a property with a binary value, creating it if necessary./// @brief \c SetProperty_Date() sets the value of a date/time property using an \c #XMP_DateTime structure./// @brief \c SetProperty_Float() sets the value of a floating-point property using a C double float./// @brief \c SetProperty_Int64() sets the value of an integer property using a C long long integer./// @brief \c SetProperty_Int() sets the value of an integer property using a C long integer./// @brief \c SetProperty_Bool() sets the value of a Boolean property using a C++ bool./// @return True if the property exists./// be null if flags are not wanted./// logical OR of allowed bit-flag constants; see \c #kXMP_PropValueIsStruct and following. Can/// @param options [out] A buffer in which to return the option flags describing the property, a/// values./// value is not wanted. Must be null for arrays and non-leaf levels of structs that do not have/// @param propValue [out] A buffer in which to return the binary value. Can be null if the/// Reports whether a property exists, and retrieves its binary value and property type information./// @brief \c GetProperty_Date() retrieves the value of a date-time property as an \c #XMP_DateTime structure./// @brief \c GetProperty_Float() retrieves the value of a floating-point property as a C double float./// @brief \c GetProperty_Int64() retrieves the value of an integer property as a C long long integer./// @brief \c GetProperty_Int() retrieves the value of an integer property as a C long integer./// @brief \c GetProperty_Bool() retrieves the value of a Boolean property as a C++ bool./// for fields or items in nested structures or arrays, or for qualifiers./// Use the path composition functions in  \c TXMPUtils	to compose complex path expressions/// \c TXMPUtils provides functions for converting between binary and string values./// that the value is returned or provided in binary form instead of as a UTF-8 string./// These are very similar to \c TXMPMeta::GetProperty() and \c TXMPMeta::SetProperty(), except/// \name Accessing properties as binary values.// Specialized Get and Set functions/// @return True if the qualifier exists./// the empty string. Same namespace and prefix usage as \c GetProperty()./// @param qualName The name of the qualifier. Must be a single XML name, must not be null or/// \c GetProperty()./// @param qualNS The namespace URI for the qualifier. Same namespace and prefix usage as/// namespace prefix usage./// general path expression, must not be null or the empty string; see \c GetProperty() for/// @param propName The name of the property to which the qualifier is attached. Can be a/// @brief \c DoesQualifierExist() reports whether a qualifier currently exists./// @return True if the field exists./// empty string. Same namespace and prefix usage as \c GetProperty()./// @param fieldName The name of the field. Must be a single XML name, must not be null or the/// @param fieldNS The namespace URI for the field. Same namespace and prefix usage as/// @param structName The name of the struct. Can be a general path expression, must not be null/// Use \c TXMPUtils::ComposeStructFieldPath() to create a complex path./// @brief \c DoesStructFieldExist() reports whether a struct field currently exists./// @return True if the array item exists./// to specify the last existing array item./// @param itemIndex The 1-based index of the desired item. Use the macro \c #kXMP_ArrayLastItem/// Use \c TXMPUtils::ComposeArrayItemPath() to create a complex path./// @brief \c DoesArrayItemExist() reports whether an array item currently exists./// @param propName The name of the property; see \c GetProperty()./// @param schemaNS The namespace URI for the property; see \c GetProperty()./// @brief \c DoesPropertyExist() reports whether a property currently exists./// It is not an error if the qualifier does not exist./// @brief \c DeleteQualifier() deletes an XMP subtree rooted at a given qualifier./// @param schemaNS The namespace URI for the struct; see \c GetProperty()./// It is not an error if the field does not exist./// @brief \c DeleteStructField() deletes an XMP subtree rooted at a given struct field./// @param schemaNS The namespace URI for the array; see \c GetProperty()./// \c TXMPUtils::ComposeArrayItemPath() to create a complex path./// It is not an error if the array item does not exist. Use/// @brief \c DeleteArrayItem() deletes an XMP subtree rooted at a given array item./// It is not an error if the property does not exist./// @brief \c DeleteProperty() deletes an XMP subtree rooted at a given property./// for \c TXMPMeta::GetProperty()./// The namespace URI and prefix usage for property specifiers in these functions is the same as/// \name Detecting and deleting properties./// for the qualifier value. It is otherwise identical; see details in the canonical form./// Overloads the basic form of the function, allowing you to pass a string object/// @brief \c SetQualifier() creates or sets a qualifier attached to a property using a string object./// qualifier.	 <<??>>/// of property-type bit-flag constants. Use the macro \c #XMP_PropIsQualifier to create a/// @param options Option flags describing the <<qualified property? qualifier?>>, a logical OR/// value. Null to create a new, empty qualifier./// @param qualValue The new value, a null-terminated UTF-8 string, if the qualifier has a/// \c TXMPUtils::ComposeQualifierPath() to create a complex path./// options work? macro vs bit-flag? interaction w/XMP_PropHasQualifier?>> Use/// Use this to  set a value for an existing qualifier, or create a new qualifier. <<how do/// @brief \c SetQualifier() creates or sets a qualifier attached to a property./// return the field value. It is otherwise identical; see details in the canonical form./// Overloads the basic form of the function, allowing you to pass a string object in which to/// using a string object./// @brief \c SetStructField() creates or sets the value of a field within a nested structure,/// \c #kXMP_PropValueIsStruct must be set to create a struct./// @param options Option flags describing the property, in which the bit-flag/// Null to create a new, empty struct or empty field in an existing struct./// @param fieldValue The new value, a null-terminated UTF-8 string, if the field has a value./// does not exist, the structure is automatically created./// structure, or create an empty structure of any depth. If you set a field in a structure that/// Use this to  set a value within an existing structure, create a new field within an existing/// @brief \c SetStructField() creates or sets the value of a field within a nested structure./// return the item value. It is otherwise identical; see details in the canonical form./// the array if necessary./// @brief \c AppendArrayItem() adds an item to an array using a string object value, creating/// constants \c #kXMP_PropValueIsArray or \c #kXMP_PropValueIsStruct to create a complex array/// @param itemOptions Option flags describing the item type to create; one of the bit-flag/// value./// @param itemValue The new item value, a null-terminated UTF-8 string, if the array item has a/// null (0 or \c #kXMP_NoOptions)./// \c #kXMP_PropArrayIsAltText. If the array exists, must match the existing array type or be/// allowed bit-flag constants, \c #kXMP_PropArrayIsOrdered, \c #kXMP_PropArrayIsAlternate, or/// @param arrayOptions Option flags describing the array type to create; a logical OR of/// item to the array./// If the array exists, it must have the form specified by the options. Each call appends a new/// empty array. The array that is assigned is created automatically if it does not yet exist./// This function simplifies construction of an array by not requiring that you pre-create an/// @brief \c AppendArrayItem() adds an item to an array, creating the array if necessary./// @brief \c SetArrayItem() creates or sets the value of an item within an array using a string object./// or \c #kXMP_InsertAfterItem./// To insert a new item before or after the specified index, set flag \c #kXMP_InsertBeforeItem/// \c #kXMP_PropArrayIsAltText. Default (0 or \c #kXMP_NoOptions) matches the  existing array type./// array type, \c #kXMP_PropArrayIsOrdered, \c #kXMP_PropArrayIsAlternate, or/// a logical OR of allowed bit-flag constants. The type, if specified, must match the existing/// @param options Option flags describing the array type and insertion location for a new item;/// array size plus 1. To insert a new item before or after an existing item, use option flags./// \c AppendArrayItem() to create arrays. A new item is automatically appended if the index is the/// creates the item if necessary, but the array itself must already exist Use/// Items are accessed by an integer index, where the first item has index 1. This function/// @brief \c SetArrayItem() creates or sets the value of an item within an array./// for the item value. It is otherwise identical; see details in the canonical form./// @brief \c SetProperty() creates or sets a property value using a string object./// @param propValue The new value, a pointer to a null terminated UTF-8 string. Must be null/// the path composition functions in \c TXMPUtils./// This is the simplest property setter. Use it for top-level simple properties, or after using/// @brief \c SetProperty() creates or sets a property value./// 	be a simple property with an \c xml:lang attribute.///   \li \c #kXMP_PropArrayIsAltText - An alt-text array. Each array element must///   \li \c #kXMP_PropArrayIsAlternate - An alternative array.///   \li \c #kXMP_PropArrayIsOrdered - An ordered array.///   \li \c #kXMP_PropValueIsArray - By default, a general unordered array (bag).///		A struct is implicitly created when the first field is set.///   \li \c #kXMP_PropValueIsStruct - Can be used to create an empty struct./// The allowed option bit-flags include:/// \c TXMPMeta::AppendArrayItem() implicitly creates the named array if necessary./// value, all levels of a struct that are implicit in the assignment are created if necessary./// to create empty arrays and structs by setting appropriate option flags. When you assign a/// Each function takes an options flag that describes the property. You can use these functions/// (\c tStringObj)./// \c #XMP_StringPtr (a pointer to a null-terminated string), or as a string object/// non-leaf levels of structs do not have values. The value can be passed as an/// All of the functions take a UTF-8 encoded Unicode string for the property value. Arrays and/// discussion of path expression usage for more information./// namespace) and the basic name of the property being referenced. See the introductory/// These functions all take a property specification; the top level namespace URI (the "schema"/// \name Creating properties and setting their values/// Can be null if the flags are not wanted./// @param options [out] A buffer in which to return the option flags describing the qualifier./// if the value is not wanted./// qualifier has a value. Arrays and non-leaf levels of structs do not have values. Can be null/// @param qualValue [out] A string object in which to return the value of the qualifier, if the/// the empty string. Same URI and prefix usage as the \c schemaNS and \c propName parameters./// \c schemaNS and \c propName parameters./// @param qualNS The namespace URI for the qualifier. Same URI and prefix usage as the/// @note In this version of the Toolkit, qualifiers are supported only for simple leaf properties./// @brief \c GetQualifier() provides access to a qualifier attached to a property./// be null if the flags are not wanted./// @param options [out] A buffer in which to return the option flags describing the field. Can/// the value is not wanted./// field has a value. Arrays and non-leaf levels of structs do not have values. Can be null if/// @param fieldValue [out] A string object in which to return the value of the field, if the/// empty string. Same URI and prefix usage as the \c schemaNS and \c structName parameters./// and \c structName parameters./// @param fieldNS The namespace URI for the field. Same URI and prefix usage as the \c schemaNS/// the value./// Reports whether the field exists; if it does, and if it has a value, the function retrieves/// @brief \c GetStructField() provides access to fields within a nested structure./// @param options [out] A buffer in which to return the option flags describing the array item./// value is not wanted./// has a value. Arrays and non-leaf levels of structs do not have values. Can be null if the/// @param itemValue [out] A string object in which to return the value of the array item, if it/// the value. Items are accessed by an integer index, where the first item has index 1./// Reports whether the item exists; if it does, and if it has a value, the function retrieves/// @brief \c GetArrayItem() provides access to items within an array./// if the flags are not wanted./// @param options A buffer in which to return option flags describing the property. Can be null/// Can be null if the value is not wanted./// property exists and has a value. Arrays and non-leaf levels of structs do not have values./// @param propValue [out] A string object in which to return the value of the property, if the/// namespace./// namespace, and if a namespace URI is specified, must match the registered prefix for that/// \c schemaNS value, the prefix specifies the namespace. The prefix must be for a registered/// or the empty string. The first component can be a namespace prefix; if present without a/// contains a namespace prefix./// namespace. Can be null or the empty string if the first component of the \c propName path/// @param schemaNS The namespace URI for the property. The URI must be for a registered/// parts of a registered namespace.///   \li If both a URI and path prefix are present, they must be corresponding/// it must be a registered prefix.///   \li If the namespace is specified only by a prefix in the property name path,///   \li If a namespace URI is specified, it must be for a registered namespace./// When specifying a namespace and path (in this and all other accessors):/// properties, or after using the path composition functions in \c TXMPUtils./// This is the simplest property accessor. Use this to retrieve the values of top-level simple/// @brief \c GetProperty() reports whether a property exists, and retrieves its value./// Unicode string in UTF-8 encoding. Arrays and the non-leaf levels of structs do not have/// and following in \c XMP_Const.h. If the property exists and has a value, it is returned as a/// \c kXMP_ArrayIsXx. See \c #kXMP_PropValueIsURI and following, and macros \c #XMP_PropIsSimple/// bit-flag constants that describe properties are \c kXMP_PropXx and/// parameters return the value (if any) and option flags describing the property. The option/// The accessor functions return true if the specified property exists. If it does, output///	introductory discussion of path expression usage for more information.///	(the "schema" namespace) and the basic name of the property being referenced. See the/// The property value accessors all take a property specification; the top level namespace URI/// \name Accessing property values// *** Should add discussion of schemaNS and propName prefix usage.// =====================================// Basic property manipulation functions/// @param schemaNS The namespace URI for the aliases. Must not be null or the empty string./// This function is static; make the call directly from the concrete class (\c SXMPMeta)./// actuals in other namespaces./// aliases in the given namespace; that is, it creates the aliases from this namespace to/// The built-in aliases are documented in the XMP Specification. This function registers the/// @brief \c RegisterStandardAliases() registers all of the built-in aliases for a standard namespace./// a name that has not been registered as an alias./// and not a general path expression. It is not an error to provide/// @param aliasProp The name of the alias. Must be a simple name, not null or the empty string/// @param aliasNS The namespace URI for the alias. Must not be null or the empty string./// It deletes any view of the property through the alias name./// This deletes only the registration of the alias, it does not delete the actual property./// @brief \c DeleteAlias() deletes an alias./// @return True if the provided name is an alias./// be null if the actual's array form is not wanted./// passed to \c TXMPMeta::RegisterAlias(). Not modified if the given name is not an alias. Can/// is 0 (\c #kXMP_NoOptions) if the alias and actual forms match, otherwise it is the options/// @param arrayForm [out] A string object in which to return the array form of the actual. This/// Not modified if the given name is not an alias. Can be null if the actual's path is not wanted./// @param actualProp  [out] A string object in which to return the path of the actual./// Not modified if the given name is not an alias. Can be null if the namespace URI is not wanted./// @param actualNS  [out] A string object in which to return the namespace URI for the actual./// null or the empty string./// @param aliasProp The name of the alias. Can be an arbitrary path expression path, must not///   isAlias = SXMPMeta::ResolveAlias ( ns.c_str(), path.c_str(), &ns, &path, 0 );/// "reduce" a path to the base form as follows:/// Output strings are not written until return, so you can use this to/// @brief \c ResolveAlias() reports whether a name is an alias, and what it is aliased to.///   the 'x-default' element of the array.  *////   \li \c #kXMP_PropArrayIsAltText - The actual is an alternate text array, the alias is to///   first element of the array.///   \li \c #kXMP_PropArrayIsAlternate - The actual is an alternate array, the alias is to the///   \li \c #kXMP_PropArrayIsOrdered - The actual is an ordered array, the alias is to the///   \li \c #kXMP_PropValueIsArray - The actual is an unordered array, the alias is to the///   \li \c #kXMP_NoOptions - This is a direct mapping. The actual data type does not matter./// data type is an array or not. One of these constants:/// \c #kXMP_NoOptions, the default value, for all direct aliases regardless of whether the actual/// to know what kind of array to create if set for the first time via the simple alias. Pass/// @param arrayForm Provides the array form for simple aliases to an array item. This is needed/// and not a general path expression./// @param actualProp The name of the actual. Must be a simple name, not null or the empty string/// @param actualNS The namespace URI for the actual. Must not be null or the empty string./// reregister an alias in an identical fashion./// alias names can map to the same actual, as long as the forms match. It is a no-op to/// be to the first item in the array, or to the 'x-default' item in an alt-text array. Multiple/// data type. It is also possible to map a simple alias to an item in an array. This can either/// simple names. An alias can be a direct mapping, where the alias and actual have the same/// Defines an alias mapping from one namespace/property to another. Both property names must be/// @brief \c RegisterAlias() associates an alias name with an actual name./// item of an array of structures./// top-level structure or array to an identical top-level structure or array, or to the first/// alt-text array. This does not mean the alias can only be a simple property; you can alias a/// property name, the first element within a top-level array, or the default element in an/// not a field within a structure or an element within an array. The actual can be a top-level/// XMP restricts the names that can be aliased. The alias must be a top-level property name,/// generally the most widely recognized name./// the primary significance of the actual name is that it is the preferred name for output,/// distinction of XMP aliases is that they are ordered. An alias name points to an actual name;/// UNIX file symbolic links. The aliases are multiple names for the same property. One/// Aliases in XMP serve the same purpose as Windows file shortcuts, Mac OS file aliases, or/// \name Alias functions/// @param namespaceURI The URI for the namespace./// parameter is null or the empty string./// Deletes a namespace from the registry. Does nothing if the URI is not registered, or if the/// @brief Not implemented./// @return True if the namespace prefix is registered./// prefix. If the prefix is not registered, this string is not modified./// @param namespaceURI [out] A string object in which to return the URI registered for this/// It is not an error if the namespace prefix is not registered./// @param namespacePrefix The prefix for the namespace. Must not be null or the empty string./// whether the prefix is registered./// @brief \c GetNamespaceURI() obtains the URI for a registered namespace prefix, and reports/// @return True if the namespace URI is registered./// string is not modified./// this URI, with a terminating colon character, ':'. If the namespace is not registered, this/// @param namespacePrefix [out] A string object in which to return the prefix registered for/// not an error if the namespace URI is not registered./// @param namespaceURI The URI for the namespace. Must not be null or the empty string. It is/// reports whether the URI is registered./// @brief \c GetNamespacePrefix() obtains the prefix for a registered namespace URI, and/// @note No checking is done on either the URI or the prefix.  *//// @param prefix The prefix to be used. Must be a valid XML name./// @param namespaceURI The URI for the namespace. Must be a valid XML URI./// If the the prefix is in use, the URI of the existing prefix is overwritten./// @brief \c RegisterNamespace() registers a namespace URI with a prefix./// new URI./// because some forms of RDF shorthand catenate a namespace URI with an element name to form a/// The namespace URI should always end in an XML name separator such as '/' or '#'. This is/// namespaces encountered when parsing RDF are automatically registered./// Within the XMP Toolkit the registered namespace URIs and prefixes must be unique. Additional/// Namespaces must be registered before use in namespace URI parameters or path expressions./// \name Namespace Functions/// For debugging. Invokes a client-defined callback for each line of output./// @brief \c DumpAliases() sends the list of registered aliases and corresponding actuals to a handler./// @brief \c DumpNamespaces() sends the list of registered namespace URIs and prefixes to a handler./// @see Member function \c TXMPMeta::DumpObject()/// client-defined callback described in \c XMP_Const.h./// These are debugging utilities that dump internal data structures, to be handled by/// \name Internal data structure dump utilities/// @param options A logical OR of global option bit-flag constants./// This function is static; you can make the call from the class without instantiating it./// this function to reset the value./// \c TXMPMeta::GetGlobalOptions() to obtain the current set, modify the desired flag, then use/// The entire set is replaced with the new values. If only one flag is to be modified, use/// version of the Toolkit./// @brief \c SetGlobalOptions() updates the set of global option flags. There are none in this/// @return A logical OR of global option bit-flag constants./// this version of the Toolkit./// @brief \c GetGlobalOptions() retrieves the set of global option flags. There are none in/// will be declared in \c XMP_Const.h. There are none in this version of the Toolkit./// Global option flags affect the overall behavior of the XMP Toolkit. The available options/// \name Global option flags// ======================// Global state functions/// @brief Destructor, typical virtual destructor. *//// @return The new object./// @param xmpSize  The length in bytes of the buffer./// in this case, the function creates an empty object./// @param buffer  A pointer to the buffer of RDF to be parsed. Can be null if the length is 0;/// and use  \c TXMPMeta::ParseFromBuffer()./// must be complete. If you need to parse data from multiple buffers, create an empty object/// object then calling \c TXMPMeta::ParseFromBuffer(). To use the constructor, however, the RDF/// The result of passing serialized data to this function is identical to creating an empty/// buffer containing serialized RDF. This buffer must be a complete RDF parse stream./// This constructor creates a new \c TXMPMeta object and populates it with metadata from a/// @brief Constructs an object and parse one buffer of RDF into it./// \c TXMPMeta::GetInternalRef()./// @param xmpRef The underlying reference object, obtained from some other XMP object with/// of an existing \c TXMPMeta object. Use to safely pass XMP objects across DLL boundaries./// This constructor creates a new \c TXMPMeta object that refers to the underlying reference object/// @brief Reconstructs an XMP object from an internal reference./// reference count on the underlying internal XMP object./// The assignment operator assigns the internal ref from the rhs object and increments the/// @brief Assignment operator, assigns the internal reference and increments the reference count./// @return The new object. *//// @param original The object to copy./// object. as an existing \c TXMPMeta object./// The copy constructor creates a new \c TXMPMeta object that refers to the same internal XMP/// @brief Copy constructor, creates a client object refering to the same internal object./// The default constructor creates a new empty \c TXMPMeta object./// @brief Default constructor, creates an empty object./// \name Constructors and destructor// =========================// Constuctors and destructor/// Frees structures created on initialization./// @brief \c Terminate() explicitly terminates usage of the XMP Toolkit./// @return True on success. *//// \c TXMPMeta::GetVersionInfo()./// Call this function before making any other calls to the \c TXMPMeta functions, except/// Initializes the XMP Toolkit./// @brief \c Initialize() explicitly initializes the XMP Toolkit before use. *//// @param info [out] A buffer in which to return the version information./// function can be called before calling \c TXMPMeta::Initialize()./// This function is static; make the call directly from the concrete class (\c SXMPMeta). The/// however, compare the runtime and static versions./// as the runtime version. Do not base runtime decisions on the static version alone; you can,/// describes the version of the API used at client compile time. It is not necessarily the same/// The header \c XMPVersion.hpp defines a static version number for the XMP Toolkit, which/// @brief \c GetVersionInfo() retrieves runtime version information./// \name Initialization and termination// Initialization and termination// -------------------------------------------------------------------------------------------------// =================================================================================================/// or that you obtain from files using the XMP Toolkit's XMPFiles component; see \c TXMPFiles.hpp./// You can create \c TXMPMeta objects (also called XMP objects) from metadata that you construct,/// Access these functions through the concrete class, \c SXMPMeta./// for specific instantiation instructions./// information about the overall architecture of the XMP API, and the documentation for \c XMPSDK.hpp/// instantiated with a string class such as \c std::string. Read the Toolkit Overview for/// \c TXMPMeta is the template class providing the core services of the XMP Toolkit. It should be/// \brief API for access to the XMP Toolkit core services./// \class TXMPMeta TXMPMeta.hpp/// \c TXMPMeta is the template class providing the core services of the XMP Toolkit. It must be/// \file TXMPMeta.hpp// of the Adobe license agreement accompanying it.// NOTICE:  Adobe permits you to use, modify, and distribute this file in accordance with the terms// All Rights Reserved// Copyright 2002-2008 Adobe Systems Incorporated// ADOBE SYSTEMS INCORPORATED/Users/owura/Repos/codeql_eval/proj_repos/Exiv2-exiv2-pull-962-commits-e925bc5addd881543fa503470c8a859e112cca62/exiv2/xmpsdk/include/Users/owura/Repos/codeql_eval/proj_repos/Exiv2-exiv2-pull-962-commits-e925bc5addd881543fa503470c8a859e112cca62/exiv2/xmpsdkoutProcclientDataschemaNSarrayNamerdfStringbaseIndentbufferSizealtTextNamegenericLangspecificLangitemValueactualLangpropNamepropValuequalNSqualNamestructNamefieldNSfieldNameitemIndexqualValuefieldValuearrayOptionsitemOptionsaliasNSaliasPropactualNSactualProparrayFormnamespaceURInamespacePrefixxmpSizeoriginal/Users/owura/Repos/codeql_eval/proj_repos/Exiv2-exiv2-pull-962-commits-e925bc5addd881543fa503470c8a859e112cca62/exiv2/xmpsdk/include/TXMPIterator.hpp"client-glue/WXMPIterator.hpp"TXMPIteratorSkipNext~TXMPIteratorconst TXMPIterator<tStringObj>const TXMPIterator<tStringObj> &TXMPIterator<tStringObj> &iterRef__TXMPIterator_hpp__// __TXMPIterator_hpp__// class TXMPIterator// ! Hidden, must choose property or table iteration.///   \li \c #kXMP_IterSkipSiblings - Skip the subtree below and remaining siblings of the current node.///   \li \c #kXMP_IterSkipSubtree -  Skip the subtree below the current node./// constants:/// @param options Option flags to control the iteration, a logical OR of these bit-flag/// @brief \c Skip() skips some portion of the remaining iterations./// @return True if there was another node to visit, false if the iteration is complete./// which are a logical OR of \c #XMP_OptionBits bit-flag constants./// @param options  [out] A buffer in which to return the flags describing the current property,/// property. Can be null if the value is not wanted./// @param propValue  [out] A string object in which to return the value of the current/// @param propPath [out]  A string object in which to return the XPath name of the current/// URI of the current property. Can be null if the value is not wanted./// @param schemaNS [out] A string object in which to return the assigned the schema namespace/// simple, it also delivers the value./// delivers the schema URI, path, and option flags for the node being visited. If the node is/// Proceeds to the next node according to the options specified on creation of this object, and/// @brief \c Next() visits the next node in the iteration./// @brief Destructor, typical virtual destructor./// @brief Constructs an iterator for the global tables of the XMP toolkit.	Not implemented./// @return The new \c TXMPIterator object.///   \li \c #kXMP_IterOmitQualifiers - Omit all qualifiers.///   \li \c #kXMP_IterJustLeafName - Return just the leaf part of the path; default returns the full path.///   \li \c #kXMP_IterJustLeafNodes - Visit only the leaf nodes; default visits all nodes.///   \li \c #kXMP_IterJustChildren - Visit only the immediate children of the root; default visits subtrees./// @param options Option flags to control the iteration. A logical OR of these bit flag constants:/// @param xmpObj The XMP object over which to iterate./// properties within a specific schema./// forms are provided to iterate the entire data tree, a subtree rooted at a specific node, or/// See the class description for the general operation of an  XMP object iterator. Overloaded/// @brief Constructs an iterator for the entire data tree within an XMP object./// @return The new TXMPIterator object./// schema, pass 0 or the empty string ""./// @param schemaNS Optional schema namespace URI to restrict the iteration. To visit all of the/// @brief Constructs an iterator for a subtree of properties within an XMP object./// or the empty string ""./// expression. If provided, a schema URI must also be provided. To visit all properties, pass 0/// @param propName Optional property name to restrict the iteration. May be an arbitrary path/// a subtree rooted at a specific node, or properties within a specific schema./// Overloaded forms are provided to iterate the entire data tree,/// See the class description for the general operation of an  XMP object iterator./// @brief Constructs an iterator for properties within a schema in an XMP object./// @param original An existing iteration object to copy./// Creates a new client iterator that refers to the same underlying iterator as an existing object./// @param rhs An existing iteration object./// the underlying internal XMP iterator./// Assigns the internal reference from an existing object and increments the reference count on/// @brief Assignment operator, assigns the internal ref and increments the ref count.///   \li \c #kXMP_IterOmitQualifiers - Do not visit the qualifiers of a node.///   not actual nodes the default iteration does not visit them.///   \li \c #kXMP_IterIncludeAliases - Include aliases as part of the iteration. Since aliases are///   is to return the full path name.///   \li \c #kXMP_IterJustLeafName - Return just the leaf component of the node names. The default///   \li \c #kXMP_IterJustLeafNodes - Visit just the leaf property nodes and their qualifiers.///   children, the qualifier nodes being below what they qualify.///   itself and all nodes below the immediate children. This omits the qualifiers of the immediate///   \li \c #kXMP_IterJustChildren - Visit just the immediate children of the root. Skip the root/// performed./// You can specify options when constructing the iteration object to control how the iteration is/// of the parent./// are visited next. The fields of a struct or items of an array are visited after the qualifiers/// node being visited. If the node is simple, it also delivers the value. Qualifiers for this node/// The function \c TXMPIterator::Next() delivers the schema URI, path, and option flags for the/// manner./// By default, this visits the named root node first then all nodes beneath it in a depth-first/// schema node. You can provide a schema name or property path to select a different starting node./// it in a depth-first manner. The root node iteself is not visited; the first visited node is a/// control how it proceeds. By default, iteration starts at the root and visits all nodes beneath/// A \c TXMPIterator constructor defines a starting point for the iteration, and options that///   its type (simple, struct, or array) and whether it has qualifiers.///   \li Beneath the schema nodes are the property nodes. The nodes below a property node depend on///   namespace. They are created and destroyed implicitly.///   \li Beneath the root are schema nodes; these collect the top-level properties in the same///   \c TXMPIterator::Next().///   dump and is never visited by an iterator; that is, it is never returned from///   \li The top of the XMP data tree is a single root node. This does not explicitly appear in the/// some complex XMP and examine the output of \c TXMPMeta::DumpObject()./// tree, as described in the XMP Specification Part 1. You might also find it helpful to create/// To understand how iteration works, you should have a thorough understanding of the XMP data/// over global tables, such as registered namespaces./// @note Only XMP object iteration is currently available. Future development may include iteration/// \c SXMPIterator./// overall architecture of the XMP API. Access these functions through the concrete class,/// as \c std::string. See the instructions in XMPSDK.hpp, and the Overview for a discussion of the/// object. \c TXMPIterator is a template class which must be instantiated with a string class such/// \c TXMPIterator provides a uniform means to iterate over the schema and properties within an XMP/// @brief API for access to the XMP Toolkit iteration services./// \class TXMPIterator TXMPIterator.hpp/// the Overview for a discussion of the overall architecture of the XMP API./// be instantiated with a string class such as \c std::string. See the instructions in XMPSDK.hpp, and/// \c TXMPIterator is the template class providing iteration services for the XMP Toolkit. It must/// \brief API for access to the XMP Toolkit iteration services./// \file TXMPIterator.hpp// NOTICE: Adobe permits you to use, modify, and distribute this file in accordance with the terms// Copyright 2002-2007 Adobe Systems IncorporatedpropPathxmpObj/Users/owura/Repos/codeql_eval/proj_repos/Exiv2-exiv2-pull-962-commits-e925bc5addd881543fa503470c8a859e112cca62/exiv2/xmpsdk/include/TXMPUtils.hppDuplicateSubtreeTXMPMeta<tStringObj> *AppendPropertiesRemovePropertiesSeparateArrayItemsCatenateArrayItemsMergeFromJPEGPackageForJPEGDecodeFromBase64EncodeToBase64CompareDateTimeConvertToLocalTimeConvertToUTCTimeSetTimeZoneCurrentDateTimeConvertToDateConvertToFloatConvertToInt64ConvertToIntConvertToBoolConvertFromDateConvertFromFloatConvertFromInt64ConvertFromIntConvertFromBoolComposeFieldSelectorComposeLangSelectorComposeQualifierPathComposeStructFieldPathComposeArrayItemPath__TXMPUtils_hpp__// __TXMPUtils_hpp__// class TXMPUtils/// @param options Option flags to control the operation. <<options?>>/// Defaults to the source location./// @param destRoot The root location for the destination. Can be a general path expression./// @param destNS The schema namespace URI for the destination. Defaults to the source namespace./// must not be null or the empty string./// @param sourceRoot The root location for the source subtree. Can be a general path expression,/// @param sourceNS The schema namespace URI for the source subtree./// @param dest The destination XMP object./// @param source The source XMP object./// same or a different location in another XMP object./// The destination can be a different namespace and root location in the same object, or the/// @brief \c DuplicateSubtree() replicates a subtree from one XMP object into another.///   \li \c kXMPUtil_DeleteEmptyValues - Delete properties if the new value is empty.///   \li \c kXMPUtil_ReplaceOldValues - Replace the values of existing properties.///   \li \c kXMPUtil_DoAllProperties - Operate on internal properties in addition to external properties./// @param options Option flags to control the copying.	A logical OR of these bit-flag constants:/// without regard to field order. Arrays are compared by recursively comparing all items./// qualifier; other qualifiers are ignored. Structs are recursively compared by field names,/// without regard to order or duplicates. Simple items are compared by value and \c xml:lang/// not specified. Each source item is checked to see if it already exists in the destination,/// Array item checking is n-squared; this can be time-intensive if the replace-old options is///          copy new items by value into the destination, ignoring order and duplicates///       else if form is an array:///          copy new items by xml:lang value into the destination///       else if form is an alt-text array:///             AppendSubtree ( sourceNode.field, destNode, replaceOld )///          for each field in sourceNode:///       else if form is a struct:///          return, leave the destNode alone///       if sourceNode and destNode forms differ:///    else: // (Already exists in dest and not replacing, merge structs and arrays)///       copy sourceNode's subtree to destParent///       delete subtree from destParent///    else if replaceOld:///    else if sourceNode not in destParent (by name):///       delete the corresponding child from destParent///    if deleteEmpty and source value is empty:/// AppendSubtree ( sourceNode, destParent, replaceOld, deleteEmpty ):///       AppendSubtree ( sourceNode, destSchema, replaceOld, deleteEmpty )///    if doAll or prop is external:///    for all top level properties in sourceSchema:///    for all source schema (top level namespaces):///    deleteEmpty = options & kXMPUtil_DeleteEmptyValues///    replaceOld = options & kXMPUtil_ReplaceOldValues///    doAll = options & kXMPUtil_DoAllProperties/// AppendProperties ( sourceXMP, destXMP, options ):/// The detailed behavior is defined by the following pseudo-code:///   no items,or a struct with no fields. Qualifiers are ignored.///   the same way as non-empty values. An empty value is a simple empty string, an array with///   corresponding destination property to be deleted. By default, empty values are treated in///   \li \c #kXMPUtil_DeleteEmptyValues: An empty value in the source XMP causes the///   Do not use this option when the processing is more complicated. <<than what??>>///   match, simple properties are left unchanged, while structs and arrays are merged.<br>///   differ in form (simple/struct/array) then the destination is not modified. If the forms///   properties are added to the destination if they do not already exist. If they do exist but///   The keep-or-replace-old notion also applies within structs and arrays. Top-level///   destination that are not in the source are not modified.<br>///   the destination, replacing any existing values. The values of properties in the///   \li \c #kXMPUtil_ReplaceOldValues: Propagate all top-level properties from the source to///   values of existing top-level properties.///   internal. You can use this flag together with \c #kXMPUtil_ReplaceOldValues to replace the///   \li \c #kXMPUtil_DoAllProperties: Operate on all top-level properties, external and/// properties that exist in both the source and destination./// destination. Option flags allow you to	add internal properties, and to merge values of/// The default operation is to append only external properties that do not already exist in the/// @brief \c AppendProperties() adds or moves properties from one XMP object to another.///   \li \c #kXMPUtil_IncludeAliases - Include aliases if the schema is explicitly specified.///   \li \c #kXMPUtil_DoAllProperties - Delete internal properties in addition to external properties./// bit-flag constants:/// @param options Option flags to control the deletion operation. A logical OR of these/// @param propName Optional path expression for the property to be removed./// @param schemaNS Optional schema namespace URI for the properties to be removed./// @param xmpObj The XMP object containing the properties to be removed.///   \li It is an error to pass an empty \c schemaNS and non-empty \c propName.///   not.///   flag is set. Aliases are handled implicitly, because the associated actuals are removed or///   removed. Internal properties are also removed if the \c #kXMPUtil_DoAllProperties option///   \li Empty \c schemaNS and empty \c propName - All external properties in all schemas are///   are removed if the \c #kXMPUtil_IncludeAliases option flag is set.///   \c #kXMPUtil_DoAllProperties option flag is set. In addition, aliases from the named schema///   schema are removed. Internal properties are also removed if the///   \li Non-empty \c schemaNS and empty \c propName - All external properties in the named///   matter whether the named property is an actual property or an alias.///   external property, or if the \c #kXMPUtil_DoAllProperties option flag is set. It does not///   \li Non-empty \c schemaNS and \c propName - The named property is removed if it is an/// The operation depends on how the namespace and property are specified:/// @brief \c  RemoveProperties() removes multiple properties from an XMP object.///	to return the concatenated string. It is otherwise identical; see details for the canonical form./// Overloads the basic form of the function, allowing you to pass a string object in which/// @brief \c SeparateArrayItems() updates an array from a concatenated edit string of values./// specified as a null-terminated UTF-8 string./// @param catedStr The concatenated array items, as created by \c CatenateArrayItems(),/// @param options Option flags to control the separation. <<what options?>>/// or the empty string./// @param arrayName The name of the array. May be a general path expression, must not be null/// @param schemaNS The schema namespace URI for the array. Must not be null or the empty string./// @param xmpObj The XMP object containing the array to be updated./// be a simple string value./// from the edit string and updating the array with the new values. Each item in the array must/// This reverses the action of \c CatenateArrayItems(), separating out individual array items/// @see \c SeparateArrayItems()/// @param catedStr [out] A string object in which to return the catenated array items./// @param options Option flags to control the catenation. <<what options?>>/// separator. Defaults to the double-quote character ("), ASCII quote (U+0022)./// @param quotes The character or characters to use as quotes around array items that contain a/// Defaults to "; ", ASCII semicolon and space (U+003B, U+0020)./// @param separator The string with which to separate the items in the catenated string./// @param xmpObj The XMP object containing the array to be catenated./// separation string. Each item in the specified array must be a simple string value./// Collects the values of all items in an array into a single string, using a specified/// @brief \c CatenateArrayItems() creates a single edit string from a set of array item values./// operations on sets of metadata, such as those available from the File Info dialog box./// convert sets of property values to and from displayable and manipulable strings, and perform/// These functions are useful in implementing a user interface for editing XMP. They/// \name Editing utilities/// @see \c PackageForJPEG()/// packet in a JPEG file./// @param extendedXMP An XMP object which the caller has initialized from the extended XMP/// XMP packet in a JPEG file. The extended XMP is added to this object./// @param fullXMP [in, out] An XMP object which the caller has initialized from the standard/// those from the standard XMP packet./// of 64K bytes, this function integrates those properties back into the same XMP object with/// When an extended partition stores properties that do not fit into the JPEG file limitation/// @brief \c MergeFromJPEG() merges standard and extended XMP retrieved from a JPEG file./// @see \c MergeFromJPEG()/// extended XMP, empty if not needed./// @param extendedDigest [out] A string object in which to return an MD5 digest of the serialized/// empty if not needed./// @param extendedXMP [out] A string object in which to return the serialized extended XMP,/// @param standardXMP [out] A string object in which to return the full standard XMP packet./// @param xmpObj The XMP object containing the metadata./// extended data./// the data does not fit into the 64K byte limit, it creates a second packet string with the/// metadata in an XMP object into a string of RDF (see \c TXMPMeta::SerializeToBuffer()). If/// The standard XMP in a JPEG file is limited to 64K bytes. This function serializes the XMP/// @brief \c PackageForJPEG() creates XMP serializations appropriate for a JPEG file./// @note (Doc note) Add detail about how to write out and read back extended data/// portions in order to work around the 64KB size limit of JPEG marker segments./// These functions support the partitioning of XMP in JPEG files into standard and extended/// \name JPEG file handling/// @param rawStr [out] A string object in which to return the decoded data./// @param encodedStr An string object containing the encoded data to be converted./// It is otherwise identical./// Overloads the basic form of the function, allowing you to pass a string object as input./// @brief \c  DecodeFromBase64() Decodes a Base64-encoded string, passed as a string object, to raw data./// @param encodedLen The number of characters of raw data to be converted./// @param encodedStr An \c #XMP_StringPtr (char *) string containing the encoded data to be converted./// @brief \c  DecodeFromBase64() Decodes a Base64-encoded string to raw data./// @param encodedStr [out] A string object in which to return the encoded string./// @param rawStr A string object containing the raw data to be converted./// @brief \c EncodeToBase64() converts a raw data value passed in a string object to a Base64-encoded string./// @param rawLen The number of characters of raw data to be converted./// @param rawStr An \c #XMP_StringPtr (char *) string containing the raw data to be converted./// @brief \c EncodeToBase64() converts a raw data value to a Base64-encoded string./// These functions convert between raw data values and Base64-encoded strings./// \name Base64 encoding and decoding///   \li +1 if left is later than right///   \li 0 if left matches right///   \li -1 if left is earlier than right/// @return An integer indicating the order:/// @param right The right-side date/time value./// @param left The left-side date/time value./// @brief \c CompareDateTime() compares the order of two date/time values./// @param time	A pointer to the date-time value, which is modified in place./// If the time zone is already the local zone, the value is not modified./// If the time zone is not the local zone, the time is adjusted and the time zone set to be local./// @brief \c ConvertToLocalTime() ensures that a time is local./// time zone is already UTC, the value is not modified./// If the time zone is not UTC, the time is adjusted and the time zone set to be UTC. If the/// @brief \c ConvertToUTCTime() ensures that a time is UTC./// Any existing time zone value is replaced. The other date/time fields are not adjusted in any way./// @brief \c SetTimeZone() sets the time zone in a date/time value to the local time zone./// @param time	[out] A buffer in which to return the date/time value./// than seconds./// adjusted for the local time zone. The resolution of the time is not guaranteed to be finer/// Creates and returns a binary \c #XMP_DateTime value. The returned time is UTC, properly/// @brief \c CurrentDateTime() obtains the current date and time.///	date-time values, these functions create, manipulate, and compare date-time values.///	In addition to the type-conversion functions that convert between strings and binary/// \name Date-time manipulation/// @param binValue [out] A buffer in which to return the binary date/time value./// object./// @param strValue The ISO 8601 string representation of the date/time, specified as a string/// See details for the canonical form./// rather than a <tt>const * char</tt>. It is otherwise identical./// Overloads the basic form of the function, allowing you to pass a string object,/// @brief \c ConvertToDate() converts a string to a date/time value./// null-terminated UTF-8 string./// @param strValue The ISO 8601 string representation of the date/time, specified as a/// any year, even negative ones./// @note ISO 8601 does not allow years less than 1000 or greater than 9999. This API allows/// A missing TZD is assumed to be UTC./// "Thh:" or "hh:"; the year, month, and day are all set to zero in the \c #XMP_DateTime value./// A missing date portion or missing TZD are tolerated. A missing date value can begin with///  \c TZD	 = time zone designator (Z or +hh:mm or -hh:mm)///  \c s	 = one or more digits representing a decimal fraction of a second <br>///  \c ss	 = two digits of second (00 through 59)	<br>///  \c mm	 = two digits of minute (00 through 59)	<br>///  \c hh	 = two digits of hour (00 through 23) <br>///  \c DD	 = two-digit day of month (01 through 31) <br>///  \c MM	 = two-digit month (01=January)	<br>///  \c YYYY = four-digit year, formatted as "%.4d" <br>///   YYYY-MM-DDThh:mm:ss.sTZD///   YYYY-MM-DDThh:mm:ssTZD///   YYYY-MM-DDThh:mmTZD///   YYYY-MM-DD///   YYYY-MM///   YYYY/// Parses a date according to the ISO 8601 profile in http://www.w3.org/TR/NOTE-datetime:/// @return The floating-point value./// @param strValue The string representation of the value, specified as a string object./// @brief \c ConvertToFloat() converts a string to a floating-point value./// @param strValue The string representation of the value, specified as a null-terminated UTF-8 string./// @return The 64-bit integer value./// @brief \c ConvertToInt64() converts a string to a 64-bit integer value./// @return The 32-bit integer value./// @brief \c ConvertToInt() converts a string to a 32-bit integer value./// @return The appropriate C++ bool value for the string./// rather than a <tt>const * char</tt>. It is otherwise identical; see details in the canonical form./// @brief \c ConvertToBool() converts a string to a Boolean value./// and finally non-zero and zero integer representations./// If these do not match, the function does a case insensitive comparison, then simply 't' or 'f',/// The preferred strings are those returned by the macros \c #kXMP_TrueStr and \c #kXMP_FalseStr./// @param strValue [out] A buffer in which to return the ISO 8601 string representation of the date/time./// @param binValue The date/time value to be converted./// "0000-00-00..."./// Time-only input is allowed where the year, month, and day are all zero. This is output as/// Formats a date according to the ISO 8601 profile in http://www.w3.org/TR/NOTE-datetime:/// @brief \c ConvertFromDate() converts a date/time value to a string./// @param strValue [out] A buffer in which to return the string representation of the value./// @param format Optional. A C \c sprintf format for the conversion. Default is "%d"./// @param binValue The floating-point value to be converted./// @brief \c ConvertFromFloat() converts a floating-point value to a string./// @param binValue The integer value to be converted./// @brief \c ConvertFromInt64() converts a 64-bit integer value to a string./// @brief \c ConvertFromInt() converts a 32-bit integer value to a string./// @param binValue The Boolean value to be converted./// \c #kXMP_FalseStr in \c XMP_Const.h./// The string values of Booleans are returned by the macros \c #kXMP_TrueStr and/// @brief \c ConvertFromBool() converts a Boolean value to a string.///	\c XMPSDK.hpp. Alternate forms of each conversion function allow either type of string.///	objects (\c tStringObj) of the type declared when instantiating the XMP classes; see///	Strings can be specified as null-terminated UTF-8 (\c #XMP_StringPtr), or as string///	values.///	explicit binary data types. Use these functions to convert between binary and string///	functions, such as \c TXMPMeta::SetPropertyInt(), set and retrieve property values as///	The main accessors in \c TXMPMeta set and retrieve property values as strings. additional/// \name Conversion between binary types and strings/// @param fullPath [out] A string in which to return the composed path./// @param fieldValue The desired value of the field, specified as a string object./// not be null or the empty string. It must be the name of a field that is itself simple./// @param fieldName The name of the field used as the selector. Must be a single XML name, must/// usage as the \c schemaNS and \c arrayName parameters./// @param fieldNS The namespace URI for the field used as the selector. Same URI and prefix/// "ns" is the prefix for the schema namespace and "fNS" is the prefix for the field namespace./// The returned string is in the form <tt>ns:arrayName[fNS:fieldName='fieldValue']</tt>, where///   exists = GetStructField ( schemaNS, path, fieldNS, "URI", &uri );///   ComposeFieldSelector ( schemaNS, "Downloads", fieldNS, "City", chosenCity, &path );/// follows:/// the user a popup built from the values of the city fields, then get the corresponding URI as/// an FTP site in that city. Use this to create an array of download alternatives. You can show/// For example, consider a simple struct that has two fields, the name of a city and the URI of/// is shown in \c ComposeLangSelector()./// based on the value of one of the fields in the structs. The other form of content addressing/// alternatives. The form used in this function lets you select an item in an array of structs/// Path syntax allows two forms of "content addressing" to select an item in an array of/// @brief \c ComposeFieldSelector() composes a path expression to select an alternate item by a field's value./// @param fieldValue The desired value of the field, specified as a null-terminated UTF-8 string./// @param langName The RFC 3066 code for the desired language, as a string object./// maintain consistency with the 'x-default' value./// are preferred, because they provide extra logic to choose the appropriate language and/// language. In most cases, \c TXMPMeta::SetLocalizedText() and \c TXMPMeta::GetLocalizedText()/// This function provides a path expression that is explicitly and only for a specific/// "ns" is the prefix for the schema namespace/// The returned string is in the form <tt>ns:arrayName[\@xml:lang='langName']</tt>, where/// shown in \c ComposeFieldSelector()./// based on the value of its \c xml:lang qualifier. The other form of content addressing is/// alternatives. The form used in this function lets you select an item in an alt-text array/// @brief \c ComposeLangSelector() composes a path expression to select an alternate item by language./// @param langName The RFC 3066 code for the desired language, as a null-terminated UTF-8 string./// @brief \c ComposeLangSelector() composes the path expression to select an alternate item by language./// empty string. Same URI and prefix usage as the \c schemaNS and \c propName parameters./// @param qualName The name of the qualifier. Must be a single XML name, must not be null or the/// prefix for the schema namespace, and "qNS" is the prefix for the qualifier namespace./// The returned string is in the form <tt>ns:propName/?qNS:qualName</tt>, where "ns" is the/// @brief \c ComposeQualifierPath() composes the path expression for a qualifier./// \c schemaNS and \c structName parameters./// @param fieldNS The namespace URI for the field. Same URI and prefix usage as the/// prefix for the schema namespace, and "fNS" is the prefix for field namespace./// The returned string is in the form <tt>ns:structName/fNS:fieldName</tt>, where "ns" is the/// @brief \c ComposeStructFieldPath() composes the path expression for a field in a struct./// \c #kXMP_ArrayLastItem to specify the last existing array item./// @param itemIndex The 1-based index of the desired item. Use the macro/// If the last item was specified, the path is <tt>ns:arrayName[last()]</tt>./// the specified namespace, and "i" is the decimal representation of specified item index./// The returned string is in the form <tt>ns:arrayName[i]</tt>, where "ns" is the prefix for/// @brief \c ComposeArrayItemPath() composes the path expression for an item in an array./// the path expression./// is because the XMP Toolkit keeps the top-level "schema" namespace separate from the rest of/// \note It might look confusing that the \c schemaNS is passed in all of the calls above. This///   xmpObj.GetArrayItem ( schemaNS, path, index, &value, &options );///   SXMPUtils::ComposeStructFieldPath ( schemaNS, "Struct", fieldNS, "Array", &path );/// You could also use this code if you want the string form of the integer:///   exists = xmpObj.GetProperty_Int ( schemaNS, path, &value, &options );///   SXMPUtils::ComposeArrayItemPath ( schemaNS, path, index, &path );/// struct. You can access one of the array items like this:/// component. For example, suppose you have a property that is an array of integers within a/// You can use these functions is to compose a complete path expression, or all but the last/// \c TXMPMeta::GetProperty_Int()./// struct fields so that you can use the binary accessors such as/// to the property access functions. You can also compose	paths to top-level array items or/// struct. You can use these utility functions to compose these paths, which you can then pass/// struct, or fields within an array of structs, or items of an array that is a field of a/// not as convenient for more complex things, such as fields several levels deep in a complex/// simple properties, items in top level arrays, and fields of top level structs.	They are/// \c TXMPMeta::GetArrayItem(), and \c TXMPMeta::GetStructField() provide easy access to top level/// The functions in \c TXMPMeta such as \c TXMPMeta::GetProperty(),/// These functions provide support for composing path expressions to deeply nested properties./// \name Path composition//  ============================================================================================// ================================================// No constructors or destructor declared or needed///   \li Editing aids for creating a user interface for the XMP Toolkit///   \li JPEG file handling///   \li Encoding and decoding base-64 strings///   \li Manipulating date/time values///   \li Converting between binary and string forms of property values///   functions in \c TXMPMeta///   \li Composing complex path expressions, which you can then pass to the property access/// General categories of utilities include:/// class (\c SXMPUtils), which is never itself instantiated./// \c TXMPMeta. All of the functions are static; that is, you call them directly from the concrete/// This class defines helper functions that support the basic metadata manipulation provided by/// architecture of the XMP API./// \c std::string. See the instructions in XMPSDK.hpp, and the Overview for a discussion of the overall/// \c TXMPUtils is a template class which must be instantiated with a string class such as/// @brief API for access to the XMP Toolkit utility services./// \class TXMPUtils TXMPUtils.hpp/// instantiated with a string class such as \c std::string. See the instructions in XMPSDK.hpp, and/// \c TXMPUtils is the template class providing utility services for the XMP Toolkit. It must be/// \brief API for access to the XMP Toolkit utility services./// \file TXMPUtils.hppdestsourceNSsourceRootdestNSdestRootcatedStrseparatorquotesfullXMPextendedXMPstandardXMPextendedDigestencodedStrrawStrencodedLenrawLenstrValuebinValuefullPathlangName/Users/owura/Repos/codeql_eval/proj_repos/Exiv2-exiv2-pull-962-commits-e925bc5addd881543fa503470c8a859e112cca62/exiv2/xmpsdk/include/XMPSDK.hpp"TXMPUtils.hpp""TXMPIterator.hpp""TXMPMeta.hpp""XMP_Const.h""XMP_Version.h""XMP_Environment.h"SXMPUtilsSXMPIteratorSXMPMeta__XMP_hpp__XMP_DebugBuilddefined ( TXMP_STRING_TYPE )TXMP_EXPAND_INLINE// __XMP_hpp__// TXMP_STRING_TYPE// For client convenience.// forcing value to bool 'true' or 'false' (performance warning)// unreachable code/// /c XMP_Environment.h must be the first included header.//  ================================================================================================/// embedded 0 bytes, which \c std::string does./// for UTF-16 or UTF-32 if those serialization encodings are used. This mainly means tolerating/// values, and is the default encoding for serialized XMP. The string type must also be suitable/// The string class must be suitable for at least UTF-8. This is the encoding used for all general///  const char * c_str() const///  size_t size() const///  tStringObj& assign ( const char * str, size_t len )/// match those for \c std::string):/// The template parameter, class \c tStringObj, must have the following member functions (which/// instantiations if \c TXMP_EXPAND_INLINE is off./// the template functions. Compiling \c XMP.incl_cpp generates explicit out-of-line/// inline in your code. Leave it undefined, or defined as 0, to use out-of-line instantiations of/// \li \c TXMP_EXPAND_INLINE - Define this as 1 if you want to have the template functions expanded/// the template headers included and typedefs (\c SXMPMeta, and so on) to use in your code./// \li \c TXMP_STRING_TYPE - Define this as the string class to use with the template. You will get/// There are two C preprocessor macros that simplify use of the templates:/// This should be done by including it in exactly one client source file./// Clients must also compile \c XMP.incl_cpp to ensure that all client-side glue code is generated./// string class is used to return text strings for property values, serialized XMP, and so on./// template classes that must be instantiated with a string class such as \c std::string. The/// Read these for information, but do not include them directly. The \c TXMP... classes are C++/// The full client API is in the \c TXMPMeta.hpp, \c TXMPIterator.hpp, \c TXMPUtils.hpp headers./// This is an overall header file, the only one that C++ clients should include./// \brief Overall header file for the XMP Toolkit/// \file XMPSDK.hpp// All Rights Reserved./Users/owura/Repos/codeql_eval/proj_repos/Exiv2-exiv2-pull-962-commits-e925bc5addd881543fa503470c8a859e112cca62/exiv2/xmpsdk/include/MD5.hMD5TransformUWORD32[4]unsigned int[4]const UWORD32const UWORD32[16]unsigned int[16]MD5FinalMD5_CTX *MD5Updateconst md5byteconst md5byte *MD5InitMD5_CTX &const MD5_CTXconst MD5_CTX &MD5_CTXUWORD32md5byteUWORD32[16]UWORD32[2]unsigned int[2]__MD5_h___MSC_VER < 1600defined(EXV_HAVE_STDINT_H) || defined(__MINGW32__) || defined(__MING64__) || defined(__APPLE__)/* MSVC doesn't provide C99 types, but it has MS specific variants *///   _MSC_VER   1600 == Visual Studio 2010/*
 * This is the header file for the MD5 message-digest algorithm.
 * The algorithm is due to Ron Rivest.  This code was
 * written by Colin Plumb in 1993, no copyright is claimed.
 * This code is in the public domain; do with it what you wish.
 *
 * Equivalent code is available from RSA Data Security, Inc.
 * This code has been tested against that, and is equivalent,
 * except that you don't need to include two pages of legalese
 * with every copy.
 *
 * To compute the message digest of a chunk of bytes, declare an
 * MD5_CTX structure, pass it to MD5Init, call MD5Update as
 * needed on buffers full of bytes, and then call MD5Final, which
 * will fill a supplied 16-byte array with the digest.
 *
 * Changed so as no longer to depend on Colin Plumb's `usual.h'
 * header definitions; now uses stuff from dpkg's config.h
 *  - Ian Jackson <ian@chiark.greenend.org.uk>.
 * Still in the public domain.
 */digest/Users/owura/Repos/codeql_eval/proj_repos/Exiv2-exiv2-pull-962-commits-e925bc5addd881543fa503470c8a859e112cca62/exiv2/xmpsdk/include/XMP_Environment.h/Users/owura/Repos/codeql_eval/proj_repos/Exiv2-exiv2-pull-962-commits-e925bc5addd881543fa503470c8a859e112cca62/exiv2/xmpsdk/include/XMP_Version.h/Users/owura/Repos/codeql_eval/proj_repos/Exiv2-exiv2-pull-962-commits-e925bc5addd881543fa503470c8a859e112cca62/exiv2/xmpsdk/include/XMP_Const.h/Users/owura/Repos/codeql_eval/proj_repos/Exiv2-exiv2-pull-962-commits-e925bc5addd881543fa503470c8a859e112cca62/exiv2/xmpsdk/include/client-glue/WXMPIterator.hpp/Users/owura/Repos/codeql_eval/proj_repos/Exiv2-exiv2-pull-962-commits-e925bc5addd881543fa503470c8a859e112cca62/exiv2/xmpsdk/include/client-glue/WXMP_Common.hpp/Users/owura/Repos/codeql_eval/proj_repos/Exiv2-exiv2-pull-962-commits-e925bc5addd881543fa503470c8a859e112cca62/exiv2/src/convert.cpp<MD5.h><XMPSDK.hpp>"convert.hpp"getTextValueconst Xmpdatum *lang="lang="first_space_posconvertStringCharsetIconv(iconv_t)(-1)iconv_open: "iconv_open: "outstrinptrinbytesleftchar[256]outbufoutptroutbytesleftsizeof(outbuf)outbytesProducedsize_t(-1)iconv: "iconv: " inbytesleft = " inbytesleft = "converterISO-8859-1"ISO-8859-1"Converter &const Converterconst Converter &ConvertercomputeIptcDigestConverter *computeExifDigestconversion_char[126]char(&)[126]const Conversionconst Conversion[126]Conversion[126]const Conversion(&)[126]Conversion(&)[126]..(*)(..))[126]EXV_COUNTOF(conversion_)const Conversion &Conversion &const Conversion *Conversion *"Image"';'prepareXmpTargetprepareIptcTargettiffforceprepareExifTargetoverwriteconst Converter *Xmp.tiff.NativeDigest"Xmp.tiff.NativeDigest"Xmp.exif.NativeDigest"Xmp.exif.NativeDigest"writeExifDigestcnvXmpValueToIptcFailed to convert "Failed to convert " to " to "Iptc.Envelope.CharacterSet"Iptc.Envelope.CharacterSet"%G"\033%G"addedcnvIptcValueUTF-8"UTF-8"cnvXmpGPSCoord is empty
" is empty\n" 0.0refsep1sep2'S''E''W'rdegrminrsecRef"Ref"ref_strcnvXmpFlash/exif:Fired"/exif:Fired"fired/exif:Return"/exif:Return"/exif:Mode"/exif:Mode"/exif:Function"/exif:Function"function/exif:RedEyeMode"/exif:RedEyeMode"redcnvXmpGPSVersioncnvXmpVersioncnvXmpDatedatetimeconst XMP_Errorconst XMP_Error &XMP_Error &%4d:%02d:%02d %02d:%02d:%02d"%4d:%02d:%02d %02d:%02d:%02d"sizeof(buf) - 1subsecTagExif.Photo.SubSecTime"Exif.Photo.SubSecTime"Exif.Photo.SubSecTimeOriginal"Exif.Photo.SubSecTimeOriginal"Exif.Photo.SubSecTimeDigitized"Exif.Photo.SubSecTimeDigitized"rhour1000000000%4d:%02d:%02d"%4d:%02d:%02d"cnvXmpArraycnvXmpCommentcharset=Unicode "charset=Unicode "cnvXmpValuecnvExifGPSCoordrefPosdouble[3]zidegcnvExifFlashXmp.exif.Flash/exif:Fired"Xmp.exif.Flash/exif:Fired"Xmp.exif.Flash/exif:Return"Xmp.exif.Flash/exif:Return"Xmp.exif.Flash/exif:Mode"Xmp.exif.Flash/exif:Mode"Xmp.exif.Flash/exif:Function"Xmp.exif.Flash/exif:Function"Xmp.exif.Flash/exif:RedEyeMode"Xmp.exif.Flash/exif:RedEyeMode"cnvExifGPSVersioncnvExifVersioncnvExifDatesubsec%d:%d:%d %d:%d:%d"%d:%d:%d %d:%d:%d", unable to parse '", unable to parse '"dhourdmindsecdatePos3600.0%.9f"%.9f"%d:%d:%d"%d:%d:%d"subsec_pos%4d-%02d-%02dT%02d:%02d:%02d%s"%4d-%02d-%02dT%02d:%02d:%02d%s"cnvExifArraycnvExifCommentcvcnvExifValuecnvNonesetOverwritesetErasecnvFromXmp*thisc.key2ToKey1_cnvToXmpc.key1ToKey2_erase_(false)overwrite_(true)ConversionConvertFctkey2ToKey1_key1ToKey2_key2_key1_metadataId_iptcCharset_overwrite_erase_const Conversion[]Conversion[]Xmp.tiff.ImageWidth"Xmp.tiff.ImageWidth"Xmp.tiff.ImageLength"Xmp.tiff.ImageLength"Exif.Image.BitsPerSample"Exif.Image.BitsPerSample"Xmp.tiff.BitsPerSample"Xmp.tiff.BitsPerSample"Exif.Image.Compression"Exif.Image.Compression"Xmp.tiff.Compression"Xmp.tiff.Compression"Exif.Image.PhotometricInterpretation"Exif.Image.PhotometricInterpretation"Xmp.tiff.PhotometricInterpretation"Xmp.tiff.PhotometricInterpretation"Xmp.tiff.Orientation"Xmp.tiff.Orientation"Xmp.tiff.SamplesPerPixel"Xmp.tiff.SamplesPerPixel"Exif.Image.PlanarConfiguration"Exif.Image.PlanarConfiguration"Xmp.tiff.PlanarConfiguration"Xmp.tiff.PlanarConfiguration"Exif.Image.YCbCrSubSampling"Exif.Image.YCbCrSubSampling"Xmp.tiff.YCbCrSubSampling"Xmp.tiff.YCbCrSubSampling"Exif.Image.YCbCrPositioning"Exif.Image.YCbCrPositioning"Xmp.tiff.YCbCrPositioning"Xmp.tiff.YCbCrPositioning"Xmp.tiff.XResolution"Xmp.tiff.XResolution"Xmp.tiff.YResolution"Xmp.tiff.YResolution"Exif.Image.ResolutionUnit"Exif.Image.ResolutionUnit"Xmp.tiff.ResolutionUnit"Xmp.tiff.ResolutionUnit"Exif.Image.TransferFunction"Exif.Image.TransferFunction"Xmp.tiff.TransferFunction"Xmp.tiff.TransferFunction"Xmp.tiff.WhitePoint"Xmp.tiff.WhitePoint"Xmp.tiff.PrimaryChromaticities"Xmp.tiff.PrimaryChromaticities"Exif.Image.YCbCrCoefficients"Exif.Image.YCbCrCoefficients"Xmp.tiff.YCbCrCoefficients"Xmp.tiff.YCbCrCoefficients"Exif.Image.ReferenceBlackWhite"Exif.Image.ReferenceBlackWhite"Xmp.tiff.ReferenceBlackWhite"Xmp.tiff.ReferenceBlackWhite"Xmp.xmp.ModifyDate"Xmp.xmp.ModifyDate"Exif.Image.ImageDescription"Exif.Image.ImageDescription"Xmp.tiff.Make"Xmp.tiff.Make"Xmp.tiff.Model"Xmp.tiff.Model"Xmp.tiff.Software"Xmp.tiff.Software"Exif.Image.Artist"Exif.Image.Artist"Exif.Image.Rating"Exif.Image.Rating"Xmp.xmp.Rating"Xmp.xmp.Rating"Xmp.dc.rights"Xmp.dc.rights"Exif.Photo.ExifVersion"Exif.Photo.ExifVersion"Xmp.exif.ExifVersion"Xmp.exif.ExifVersion"Exif.Photo.FlashpixVersion"Exif.Photo.FlashpixVersion"Xmp.exif.FlashpixVersion"Xmp.exif.FlashpixVersion"Exif.Photo.ColorSpace"Exif.Photo.ColorSpace"Xmp.exif.ColorSpace"Xmp.exif.ColorSpace"Exif.Photo.ComponentsConfiguration"Exif.Photo.ComponentsConfiguration"Xmp.exif.ComponentsConfiguration"Xmp.exif.ComponentsConfiguration"Exif.Photo.CompressedBitsPerPixel"Exif.Photo.CompressedBitsPerPixel"Xmp.exif.CompressedBitsPerPixel"Xmp.exif.CompressedBitsPerPixel"Xmp.exif.PixelXDimension"Xmp.exif.PixelXDimension"Xmp.exif.PixelYDimension"Xmp.exif.PixelYDimension"Xmp.exif.UserComment"Xmp.exif.UserComment"Exif.Photo.RelatedSoundFile"Exif.Photo.RelatedSoundFile"Xmp.exif.RelatedSoundFile"Xmp.exif.RelatedSoundFile"Xmp.photoshop.DateCreated"Xmp.photoshop.DateCreated"Xmp.xmp.CreateDate"Xmp.xmp.CreateDate"Xmp.exif.ExposureTime"Xmp.exif.ExposureTime"Xmp.exif.FNumber"Xmp.exif.FNumber"Exif.Photo.ExposureProgram"Exif.Photo.ExposureProgram"Xmp.exif.ExposureProgram"Xmp.exif.ExposureProgram"Exif.Photo.SpectralSensitivity"Exif.Photo.SpectralSensitivity"Xmp.exif.SpectralSensitivity"Xmp.exif.SpectralSensitivity"Xmp.exif.ISOSpeedRatings"Xmp.exif.ISOSpeedRatings"Exif.Photo.OECF"Exif.Photo.OECF"Xmp.exif.OECF"Xmp.exif.OECF"Xmp.exif.ShutterSpeedValue"Xmp.exif.ShutterSpeedValue"Xmp.exif.ApertureValue"Xmp.exif.ApertureValue"Exif.Photo.BrightnessValue"Exif.Photo.BrightnessValue"Xmp.exif.BrightnessValue"Xmp.exif.BrightnessValue"Xmp.exif.ExposureBiasValue"Xmp.exif.ExposureBiasValue"Exif.Photo.MaxApertureValue"Exif.Photo.MaxApertureValue"Xmp.exif.MaxApertureValue"Xmp.exif.MaxApertureValue"Xmp.exif.SubjectDistance"Xmp.exif.SubjectDistance"Xmp.exif.MeteringMode"Xmp.exif.MeteringMode"Exif.Photo.LightSource"Exif.Photo.LightSource"Xmp.exif.LightSource"Xmp.exif.LightSource"Xmp.exif.Flash"Xmp.exif.Flash"Xmp.exif.FocalLength"Xmp.exif.FocalLength"Exif.Photo.SubjectArea"Exif.Photo.SubjectArea"Xmp.exif.SubjectArea"Xmp.exif.SubjectArea"Exif.Photo.FlashEnergy"Exif.Photo.FlashEnergy"Xmp.exif.FlashEnergy"Xmp.exif.FlashEnergy"Exif.Photo.SpatialFrequencyResponse"Exif.Photo.SpatialFrequencyResponse"Xmp.exif.SpatialFrequencyResponse"Xmp.exif.SpatialFrequencyResponse"Exif.Photo.FocalPlaneXResolution"Exif.Photo.FocalPlaneXResolution"Xmp.exif.FocalPlaneXResolution"Xmp.exif.FocalPlaneXResolution"Exif.Photo.FocalPlaneYResolution"Exif.Photo.FocalPlaneYResolution"Xmp.exif.FocalPlaneYResolution"Xmp.exif.FocalPlaneYResolution"Exif.Photo.FocalPlaneResolutionUnit"Exif.Photo.FocalPlaneResolutionUnit"Xmp.exif.FocalPlaneResolutionUnit"Xmp.exif.FocalPlaneResolutionUnit"Exif.Photo.SubjectLocation"Exif.Photo.SubjectLocation"Xmp.exif.SubjectLocation"Xmp.exif.SubjectLocation"Exif.Photo.ExposureIndex"Exif.Photo.ExposureIndex"Xmp.exif.ExposureIndex"Xmp.exif.ExposureIndex"Exif.Photo.SensingMethod"Exif.Photo.SensingMethod"Xmp.exif.SensingMethod"Xmp.exif.SensingMethod"Exif.Photo.FileSource"Exif.Photo.FileSource"Xmp.exif.FileSource"Xmp.exif.FileSource"Exif.Photo.SceneType"Exif.Photo.SceneType"Xmp.exif.SceneType"Xmp.exif.SceneType"Exif.Photo.CFAPattern"Exif.Photo.CFAPattern"Xmp.exif.CFAPattern"Xmp.exif.CFAPattern"Exif.Photo.CustomRendered"Exif.Photo.CustomRendered"Xmp.exif.CustomRendered"Xmp.exif.CustomRendered"Exif.Photo.ExposureMode"Exif.Photo.ExposureMode"Xmp.exif.ExposureMode"Xmp.exif.ExposureMode"Exif.Photo.WhiteBalance"Exif.Photo.WhiteBalance"Xmp.exif.WhiteBalance"Xmp.exif.WhiteBalance"Exif.Photo.DigitalZoomRatio"Exif.Photo.DigitalZoomRatio"Xmp.exif.DigitalZoomRatio"Xmp.exif.DigitalZoomRatio"Xmp.exif.FocalLengthIn35mmFilm"Xmp.exif.FocalLengthIn35mmFilm"Exif.Photo.SceneCaptureType"Exif.Photo.SceneCaptureType"Xmp.exif.SceneCaptureType"Xmp.exif.SceneCaptureType"Exif.Photo.GainControl"Exif.Photo.GainControl"Xmp.exif.GainControl"Xmp.exif.GainControl"Exif.Photo.Contrast"Exif.Photo.Contrast"Xmp.exif.Contrast"Xmp.exif.Contrast"Exif.Photo.Saturation"Exif.Photo.Saturation"Xmp.exif.Saturation"Xmp.exif.Saturation"Exif.Photo.Sharpness"Exif.Photo.Sharpness"Xmp.exif.Sharpness"Xmp.exif.Sharpness"Exif.Photo.DeviceSettingDescription"Exif.Photo.DeviceSettingDescription"Xmp.exif.DeviceSettingDescription"Xmp.exif.DeviceSettingDescription"Exif.Photo.SubjectDistanceRange"Exif.Photo.SubjectDistanceRange"Xmp.exif.SubjectDistanceRange"Xmp.exif.SubjectDistanceRange"Exif.Photo.ImageUniqueID"Exif.Photo.ImageUniqueID"Xmp.exif.ImageUniqueID"Xmp.exif.ImageUniqueID"Xmp.exif.GPSVersionID"Xmp.exif.GPSVersionID"Xmp.exif.GPSLatitude"Xmp.exif.GPSLatitude"Xmp.exif.GPSLongitude"Xmp.exif.GPSLongitude"Xmp.exif.GPSAltitudeRef"Xmp.exif.GPSAltitudeRef"Xmp.exif.GPSAltitude"Xmp.exif.GPSAltitude"Xmp.exif.GPSTimeStamp"Xmp.exif.GPSTimeStamp"Exif.GPSInfo.GPSSatellites"Exif.GPSInfo.GPSSatellites"Xmp.exif.GPSSatellites"Xmp.exif.GPSSatellites"Exif.GPSInfo.GPSStatus"Exif.GPSInfo.GPSStatus"Xmp.exif.GPSStatus"Xmp.exif.GPSStatus"Exif.GPSInfo.GPSMeasureMode"Exif.GPSInfo.GPSMeasureMode"Xmp.exif.GPSMeasureMode"Xmp.exif.GPSMeasureMode"Exif.GPSInfo.GPSDOP"Exif.GPSInfo.GPSDOP"Xmp.exif.GPSDOP"Xmp.exif.GPSDOP"Exif.GPSInfo.GPSSpeedRef"Exif.GPSInfo.GPSSpeedRef"Xmp.exif.GPSSpeedRef"Xmp.exif.GPSSpeedRef"Exif.GPSInfo.GPSSpeed"Exif.GPSInfo.GPSSpeed"Xmp.exif.GPSSpeed"Xmp.exif.GPSSpeed"Exif.GPSInfo.GPSTrackRef"Exif.GPSInfo.GPSTrackRef"Xmp.exif.GPSTrackRef"Xmp.exif.GPSTrackRef"Exif.GPSInfo.GPSTrack"Exif.GPSInfo.GPSTrack"Xmp.exif.GPSTrack"Xmp.exif.GPSTrack"Exif.GPSInfo.GPSImgDirectionRef"Exif.GPSInfo.GPSImgDirectionRef"Xmp.exif.GPSImgDirectionRef"Xmp.exif.GPSImgDirectionRef"Exif.GPSInfo.GPSImgDirection"Exif.GPSInfo.GPSImgDirection"Xmp.exif.GPSImgDirection"Xmp.exif.GPSImgDirection"Xmp.exif.GPSMapDatum"Xmp.exif.GPSMapDatum"Exif.GPSInfo.GPSDestLatitude"Exif.GPSInfo.GPSDestLatitude"Xmp.exif.GPSDestLatitude"Xmp.exif.GPSDestLatitude"Exif.GPSInfo.GPSDestLongitude"Exif.GPSInfo.GPSDestLongitude"Xmp.exif.GPSDestLongitude"Xmp.exif.GPSDestLongitude"Exif.GPSInfo.GPSDestBearingRef"Exif.GPSInfo.GPSDestBearingRef"Xmp.exif.GPSDestBearingRef"Xmp.exif.GPSDestBearingRef"Exif.GPSInfo.GPSDestBearing"Exif.GPSInfo.GPSDestBearing"Xmp.exif.GPSDestBearing"Xmp.exif.GPSDestBearing"Exif.GPSInfo.GPSDestDistanceRef"Exif.GPSInfo.GPSDestDistanceRef"Xmp.exif.GPSDestDistanceRef"Xmp.exif.GPSDestDistanceRef"Exif.GPSInfo.GPSDestDistance"Exif.GPSInfo.GPSDestDistance"Xmp.exif.GPSDestDistance"Xmp.exif.GPSDestDistance"Xmp.exif.GPSProcessingMethod"Xmp.exif.GPSProcessingMethod"Exif.GPSInfo.GPSAreaInformation"Exif.GPSInfo.GPSAreaInformation"Xmp.exif.GPSAreaInformation"Xmp.exif.GPSAreaInformation"Exif.GPSInfo.GPSDifferential"Exif.GPSInfo.GPSDifferential"Xmp.exif.GPSDifferential"Xmp.exif.GPSDifferential"Iptc.Application2.ObjectName"Iptc.Application2.ObjectName"Xmp.photoshop.Urgency"Xmp.photoshop.Urgency"onoffIptc.Application2.Category"Iptc.Application2.Category"Xmp.photoshop.Category"Xmp.photoshop.Category"Iptc.Application2.SuppCategory"Iptc.Application2.SuppCategory"Xmp.photoshop.SupplementalCategories"Xmp.photoshop.SupplementalCategories"Iptc.Application2.SubLocation"Iptc.Application2.SubLocation"Xmp.iptc.Location"Xmp.iptc.Location"Iptc.Application2.SpecialInstructions"Iptc.Application2.SpecialInstructions"Xmp.photoshop.Instructions"Xmp.photoshop.Instructions"Iptc.Application2.DigitizationDate"Iptc.Application2.DigitizationDate"Iptc.Application2.Byline"Iptc.Application2.Byline"Iptc.Application2.BylineTitle"Iptc.Application2.BylineTitle"Xmp.photoshop.AuthorsPosition"Xmp.photoshop.AuthorsPosition"Iptc.Application2.City"Iptc.Application2.City"Xmp.photoshop.City"Xmp.photoshop.City"Iptc.Application2.ProvinceState"Iptc.Application2.ProvinceState"Xmp.photoshop.State"Xmp.photoshop.State"Iptc.Application2.CountryCode"Iptc.Application2.CountryCode"Xmp.iptc.CountryCode"Xmp.iptc.CountryCode"Iptc.Application2.CountryName"Iptc.Application2.CountryName"Xmp.photoshop.Country"Xmp.photoshop.Country"Iptc.Application2.TransmissionReference"Iptc.Application2.TransmissionReference"Xmp.photoshop.TransmissionReference"Xmp.photoshop.TransmissionReference"Xmp.photoshop.Headline"Xmp.photoshop.Headline"Iptc.Application2.Credit"Iptc.Application2.Credit"Xmp.photoshop.Credit"Xmp.photoshop.Credit"Iptc.Application2.Source"Iptc.Application2.Source"Xmp.photoshop.Source"Xmp.photoshop.Source"Iptc.Application2.Copyright"Iptc.Application2.Copyright"Iptc.Application2.Caption"Iptc.Application2.Caption"Iptc.Application2.Writer"Iptc.Application2.Writer"Xmp.photoshop.CaptionWriter"Xmp.photoshop.CaptionWriter"TXMP_STRING_TYPEstd::stringEXV_ADOBE_XMPSDKdefined EXV_HAVE_ICONV// without the qualifier// If there is no default but exactly one entry, take that// get the default language entry without x-default qualifier// EXV_HAVE_ICONV// nothing to do// Update the convertStringCharset() documentation if you add more here!/*str*/// Naive byte-swapping, I'm sure this can be done more efficiently// to be safe// We don't have both digests, it is probably the first conversion to XMP// Exif was modified after XMP, we should update XMP// We have both digests and the values do not match// XMP is up-to-date, we should update Exif// We have both digests and the values match/* FIXME ? */// indicate UTF-8 encoding// !EXV_HAVE_XMP_TOOLKIT// Add the seconds to rmin so that the ns fit into rsec// Ignore the time zone, assuming the time is in UTC as it should be// "Exif.GPSInfo.GPSTimeStamp"// SUPPRESS_WARNINGS// Assumes the XMP value is encoded in UTF-8, as it should be// Todo: Escape non-ASCII characters in XMP text values// Hack: Need Value::toDouble// some locales use ','// Todo: Convert to UTF-8 if necessary// FIXME to IPTC Date and IPTC Time// FIXME ?// MWG Guidelines// Order is important for computing digests// class Converter//<! Conversion rules//! Get the value of the overwrite flag, see also setOverwrite(bool on).//! Get the value of the erase flag, see also setErase(bool on)./*!
          @brief Copies metadata in appropriate direction.

          From values of exif:NativeDigest and tiff:NativeDigest detects which of
          XMP and Exif was updated more recently and copies metadata in appropriate direction.
         *//*!
          @brief Write exif:NativeDigest and tiff:NativeDigest properties to XMP.

          Compute digests from Exif values and write them to  exif:NativeDigest
          and tiff:NativeDigest properties. This should be compatible with XMP SDK.
         *//*!
          @brief XMP to IPTC dataset conversion function.

          Each array element of an XMP array value is added as one IPTC dataset.
         *//*!
          @brief IPTC dataset to XMP conversion function.

          Multiple IPTC datasets with the same key are converted to an XMP array.
         *//*!
          @brief XMP to Exif GPS coordinate conversion function.

          Converts XmpText value to GPS coordinates tags. It sets multiple Exif tags
          as described in XMP specification.
         *//*!
          @brief XMP to Exif Flash conversion function.

          Converts XMP structure to Flash tag.
         *//*!
          @brief XMP to Exif GPS version conversion function.

          Converts XmpText value to GPSVersionID tag.
         *//*!
          @brief XMP to Exif version conversion function.

          Converts XmpText value to ExifVersion tag.
         *//*!
          @brief XMP to Exif date conversion function.

          Converts the XmpText value to Exif date and time. This function
          sets multiple Exif tags as described in XMP specification. It
          is used for DateTime, DateTimeOriginal, DateTimeDigitized and GPSTimeStamp.
         *//*!
          @brief Converts XMP array to Exif tag with multiple components.

          Converts XMP array to Exif tag with multiple components. This function is
          used for ComponentsConfiguration tag.
         *//*!
          @brief Convert the tag Xmp.exif.UserComment to Exif.
         *//*!
          @brief Simple XMP to Exif conversion function.

          Sets the Exif tag according to the XMP property.
          For LangAlt values, only the x-default entry is used.

          Todo: Escape non-ASCII characters in XMP text values
         *//*!
          @brief Exif GPS coordinate to XMP conversion function.

          Converts GPS coordinates tag to XmpText value. It combines multiple Exif tags
          as described in XMP specification.
         *//*!
          @brief Exif Flash to XMP conversion function.

          Converts Flash tag to XMP structure.
         *//*!
          @brief Exif GPS version to XMP conversion function.

          Converts GPSVersionID tag to XmpText value.
         *//*!
          @brief Exif version to XMP conversion function.

          Converts ExifVersion tag to XmpText value.
         *//*!
          @brief Exif date to XMP conversion function.

          Sets the XMP property to an XmpText value containing date and time. This function
          combines values from multiple Exif tags as described in XMP specification. It
          is used for DateTime, DateTimeOriginal, DateTimeDigitized and GPSTimeStamp.
         *//*!
          @brief Converts Exif tag with multiple components to XMP array.

          Converts Exif tag with multiple components to XMP array. This function is
          used for ComponentsConfiguration tag.
         *//*!
          @brief Convert the tag Exif.Photo.UserComment to XMP.

          Todo: Convert the Exif comment to UTF-8 if necessary.
         *//*!
          @brief Simple Exif to XMP conversion function.

          Sets the XMP property to an XmpText value containing the Exif value string.
         *//*!
          @brief Do nothing conversion function.

          Use when, for example, a one-way conversion is needed.
         *///! @name Conversion functions (manipulators)/*!
          @brief Set the overwrite flag.

          This flag indicates whether existing target records are overwritten.
         *//*!
          @brief Set the erase flag.

          This flag indicates whether successfully converted source records are erased.
         *///! Convert XMP properties to Exif tags or IPTC datasets according to the conversion table.//! Convert Exif tags or IPTC datasets to XMP properties according to the conversion table.//! Constructor for Iptc tags and XMP properties.//! Constructor for Exif tags and XMP properties.//!< Conversion from second to first key.//!< Conversion from first to second key.//!< Second metadata key (always an XMP key for now).//!< First metadata key.//!< Type of metadata for the first key.//! Structure to define conversions between two keys./*!
          @brief Type for metadata converter functions, taking two key strings,
                 \em from and \em to.

          These functions have access to both the source and destination metadata
          containers and store the result directly in the destination container.
         *///! Metadata conversions./*!
      @brief Get the text value of an XmpDatum \em pos.

      If \em pos refers to a LangAltValue, \em value is set to the default language
      entry without the x-default qualifier. If there is no default but
      exactly one entry, \em value is set to this entry, without the qualifier.
      The return code indicates if the operation was successful.
     */// Convert string charset with iconv.// Convert string charset with Windows functions.// EXV_HAVE_XMP_TOOLKIT// Adobe XMP Toolkit// for snprintf (C99)/*
  File:      convert.cpp
  Author(s): Andreas Huggel (ahu) <ahuggel@gmx.net>
             Vladimir Nadvornik (vn) <nadvornik@suse.cz>
  History:   17-Mar-08, ahu: created basic converter framework
             20-May-08, vn:  added actual conversion logic
 */TXMPMeta<basic_string<char, char_traits<char>, allocator<char>>>TXMPIterator<basic_string<char, char_traits<char>, allocator<char>>>TXMPUtils<basic_string<char, char_traits<char>, allocator<char>>>TXMPUtils<basic_string<char, char_traits<char>, allocator<char>>> &const TXMPUtils<basic_string<char, char_traits<char>, allocator<char>>>const TXMPUtils<basic_string<char, char_traits<char>, allocator<char>>> &__wrap_iter<Xmpdatum *>__wrap_iter<Iptcdatum *> *const __wrap_iter<Iptcdatum *> *const __wrap_iter<Xmpdatum *> *reverse_iterator<__wrap_iter<Xmpdatum *>>iterator_traits<Xmpdatum *>iterator_traits<Xmpdatum *> &const iterator_traits<Xmpdatum *>const iterator_traits<Xmpdatum *> &remove_cv<Xmpdatum>remove_cv<Xmpdatum> &const remove_cv<Xmpdatum>const remove_cv<Xmpdatum> &remove_volatile<Xmpdatum>remove_volatile<Xmpdatum> &const remove_volatile<Xmpdatum>const remove_volatile<Xmpdatum> &/Users/owura/Repos/codeql_eval/proj_repos/Exiv2-exiv2-pull-962-commits-e925bc5addd881543fa503470c8a859e112cca62/exiv2/src/tiffcomposite_int.hppTiffComponent &const TiffComponentconst TiffComponent &doSizeImagedoSizeDatadoCountdoSizedoWriteImagedoWriteDatadoClonedoWritedoAcceptTiffVisitor &doAddNextdoAddChilddoAddPathTiffPath &stack<TiffPathItem, deque<TiffPathItem, allocator<TiffPathItem>>> &sizeImagewriteImagewriteDataconst TiffComponent *setStartacceptaddNextaddChildaddPath~TiffComponentnewTiffImageSizedtTagdtGroupnewTiffImageDataszTagszGroupnewTiffThumbSizenewTiffThumbDatanewTiffBinaryArray2const ArraySetconst ArraySet *ArraySet *arraySetcfgSelFctnewTiffBinaryArray1const ArrayCfgconst ArrayCfg *ArrayCfg *arrayCfgnewTiffBinaryArray0const ArrayDefconst ArrayDef[]ArrayDef[]const ArrayDef(&)[]ArrayDef(&)[]arrayDefnewTiffSubIfdnewGroupnewTiffDirectorynewTiffBinaryElementnewTiffMnEntrynewTiffEntrycmpGroupLtcmpTagLtselectNikonLdTiffBinaryArray *TiffBinaryArray *consttoTiffTypetoTypeIdTiffBinaryElement &const TiffBinaryElementconst TiffBinaryElement &TiffBinaryElement *doEncodeTiffEncoder &elByteOrderconst TiffBinaryElement *const ArrayDef *ArrayDef *elDefsetElByteOrdersetElDefconst ArrayDef &ArrayDef &~TiffBinaryElementTiffBinaryArray &const TiffBinaryArrayconst TiffBinaryArray &decodedconst TiffBinaryArray *defSizecfgsetDecodedupdOrigDataBufiniOrigDataBufaddElement~TiffBinaryArrayArraySetArraySet &const ArraySet &ArrayCfg &const ArrayCfg &tagStepTiffIfdMakernote &const TiffIfdMakernoteconst TiffIfdMakernote &TiffIfdMakernote *imageByteOrderconst TiffIfdMakernote *writeHeadersizeHeadersetImageByteOrder~TiffIfdMakernoteMnHeader *TiffMnEntry &const TiffMnEntryconst TiffMnEntry &TiffMnEntry *~TiffMnEntryTiffSubIfd &const TiffSubIfdconst TiffSubIfd &TiffSubIfd *~TiffSubIfdTiffSizeEntry &const TiffSizeEntryconst TiffSizeEntry &TiffSizeEntry *const TiffSizeEntry *const IfdId~TiffSizeEntryTiffImageEntry &const TiffImageEntryconst TiffImageEntry &TiffImageEntryTiffImageEntry *setStrips~TiffImageEntryTiffDataEntry &const TiffDataEntryconst TiffDataEntry &TiffDataEntry *~TiffDataEntryTiffDataEntryBase &const TiffDataEntryBaseconst TiffDataEntryBase &TiffDataEntryBaseconst TiffDataEntryBase *TiffDataEntryBase *~TiffDataEntryBaseTiffEntry &const TiffEntryconst TiffEntry &TiffEntry *~TiffEntryTiffMappingInfo &const TiffMappingInfoconst TiffMappingInfo &const TiffMappingInfo *TiffMappingInfo *TiffEntryBase &const TiffEntryBase &writeOffsetsetCounttiffTypeupdateValuesetDatasetOffset~TiffEntryBaseconst TiffTypettUndefinedwriteDirEntryTiffDirectory &const TiffDirectoryconst TiffDirectory &TiffDirectory *const IoWrapperconst IoWrapper &setTargetOffsetWriter *pStarthasNextconst TiffDirectory *~TiffDirectoryTiffPathItem &const TiffPathItemconst TiffPathItem &const TiffPathItem *TiffPathItem *extendedTagArrayCfgArrayDefCryptFctCfgSelFctIfdsStripsTiffTypeComponentspStart_group_elByteOrder_elDef_decoded_pRoot_origSize_origData_elements_setSize_defSize_arrayDef_arrayCfg_arraySet_const CfgSelFctcfgSelFct_def_cfg_elDefaultDef_concat_hasFillers_hasSize_cryptFct_elTiffType_tiffType_imageByteOrder_mnOffset_ifd_pHeader_mn_ifds_newGroup_dtGroup_dtTag_strips_szGroup_szTag_e_m_encoderFct_decoderFct_extendedTag_pValue_offset_pow_wroteHeader_pNext_hasNext_components_0x80000pana1966080x30000nextttTiffIfdttTiffDoublettTiffFloatttSignedRationalttSignedLongttSignedShortttSignedBytettUnsignedRationalttUnsignedLongttUnsignedShortttAsciiStringttUnsignedByteTIFFCOMPOSITE_INT_HPP_Tag// #ifndef TIFFCOMPOSITE_INT_HPP_// Todo: Same as newTiffThumbSize - consolidate (rename)?//! Function to create and initialize a new TIFF entry for image data (size)//! Function to create and initialize a new TIFF entry for image data//! Function to create and initialize a new TIFF entry for a thumbnail (size)//! Function to create and initialize a new TIFF entry for a thumbnail (data)//! Function to create and initialize a new complex binary array entry//! Function to create and initialize a new simple binary array entry//! Function to create and initialize a new binary array entry//! Function to create and initialize a new TIFF sub-directory/*group*///! Function to create and initialize a new TIFF directory//! Function to create and initialize a new binary array element//! Function to create and initialize a new TIFF makernote entry//! Function to create and initialize a new TIFF entry/*!
      @brief Compare two TIFF component pointers by group. Return true if the
             group of component lhs is less than that of rhs.
     *//*!
      @brief Compare two TIFF component pointers by tag. Return true if the tag
             of component lhs is less than that of rhs.
     */// class TiffBinaryElement//!< Byte order to read/write the element//!< The array element definition// Using doSizeImage from base class// Using doSizeData from base class/*!
          @brief Implements size(). Returns count * type-size, both taken from
                 the element definition.
         */// Using doWriteImage from base class// Using doWriteData from base class/*!
          @brief Implements count(). Returns the count from the element definition.
         *///! @name Protected Accessors/*!
          @brief Implements write(). Todo: Document it!
         *///! @name Protected Manipulators/*!
          @brief Return the byte order of this element.
         *//*!
          @brief Return the array definition of this element.
         *//*!
          @brief Set the byte order of this element.
         *//*!
          @brief Set the array definition for this element.
         *//*!
      @brief Element of a TiffBinaryArray.
     */// class TiffBinaryArray//!< Flag to indicate if the array was decoded//!< Pointer to the root component of the TIFF tree. (Only used for intrusive writing.)//!< Size of the original data buffer//!< Pointer to the original data buffer (unencrypted)//!< List of elements in this composite//!< Size of the array set (may be 0)//!< Size of the array definition array (may be 0)//!< Pointer to the array definition (may be 0)//!< Pointer to the array configuration (must not be 0, except for unrecognized complex binary arrays)//!< Pointer to the array set, if any (may be 0)//!< Pointer to a function to determine which cfg to use (may be 0)/*!
          @brief Implements size(). Todo: Document it!
         *///! Implements count(). Todo: Document it!/*!
          @brief Implements addChild(). Todo: Document it!
         *//*!
          @brief Implements addPath(). Todo: Document it!
         *///! Copy constructor (used to implement clone()).//! @name Protected Creators//! Return the flag which indicates if the array was decoded//! Return the number of elements in the definition//! Return a pointer to the definition//! Return a pointer to the configuration//! Set a flag to indicate if the array was decoded//! Update the original data buffer and its size, return true if successful.//! Initialize the original data buffer and its size from the base entry./*!
          @brief Setup cfg and def for the component, in case of a complex binary array.
                 Else do nothing. Return true if the initialization succeeded, else false.

          This version of initialize() is used for reading and non-intrusive writing. It
          calls cfgSelFct_ to determine the correct settings.

          @param pRoot Pointer to the root component of the TIFF tree.
          @return true if the initialization succeeded, else false.
         *//*!
          @brief Setup cfg and def for the component, in case of a complex binary array.
                 Else do nothing. Return true if the initialization succeeded, else false.

          This version of initialize() is used during intrusive writing. It determines the
          correct settings based on the \em group passed in (which is the group of the first
          tag that is added to the array). It doesn't require cfgSelFct_.

          @param group Group to setup the binary array for.
          @return true if the initialization succeeded, else false.
         *///! Add an element to the binary array, return the size of the element//! Virtual destructor//! Constructor for a complex binary array/*!
      @brief Composite to model an array of different tags. The tag types as well
             as other aspects of the array are configurable. The elements of this
             component are of type TiffBinaryElement.
     *///!< Size of the array definition array//!< Binary array definition array//!< Binary array configuration//! Combination of array configuration and definition for arrays//!< Default element//!< If true, concatenate gaps between defined tags to single tags//!< If true, write all defined tags//!< If true, first tag is the size element//!< Crypt function, 0 if not used//!< Type for the array entry and the size element, if any//!< Byte order, invalidByteOrder to inherit//!< Group for the elements//DATA/*!
          @brief Return the size of the default tag, which is used
                 to calculate tag numbers as idx/tagStep
         *///! Additional configuration for a binary array.//!< Number of components//!< TIFF type of the element//!< Index in bytes from the start//! Get the size in bytes of a tag.//! Comparison with idx//! Defines one tag in a binary array//! Function pointer type for a crypt function used for binary arrays./*!
      @brief Function pointer type for a function to determine which cfg + def
             of a corresponding array set to use.
     */// class TiffIfdMakernote//!< Byte order for the image//!< Makernote offset//!< Makernote IFD//!< Makernote header/*!
          @name NOT implemented

          Implementing the copy constructor and assignment operator will require
          cloning the header, i.e., clone() functionality on the MnHeader
          hierarchy.
         *//*!
          @brief Implements sizeImage(). Return the total image data size of the
                 makernote IFD.
         *//*!
          @brief This class does not really implement sizeData(), it only has
                 size(). This method must not be called; it commits suicide.
         *//*!
          @brief Implements count(). Return the number of entries in the IFD
                 of the Makernote. Does not count entries which are marked as
                 deleted.
         *//*!
          @brief Implements size(). Return the size of the Makernote header,
                 TIFF directory, values and additional data.
         *//*!
          @brief Implements writeImage(). Write the image data of the IFD of
                 the Makernote. Return the number of bytes written.
         *//*!
          @brief This class does not really implement writeData(), it only has
                 write(). This method must not be called; it commits suicide.
         *//*!
          @brief Implements write(). Write the Makernote header, TIFF directory,
                 values and additional data to the \em ioWrapper, return the
                 number of bytes written.
         *//*!
          @brief Return the base offset for use with the makernote IFD entries
                 relative to the start of the TIFF header.
                 Returns 0 if there is no header.
         *//*!
          @brief Return the byte order used for the image.
         *//*!
          @brief Return the byte order for the makernote. Requires the image
                 byte order to be set (setImageByteOrder()).  Returns the byte
                 order for the image if there is no header or the byte order for
                 the header is \c invalidByteOrder.
         *//*!
          @brief Return the offset to the start of the Makernote IFD from
                 the start of the Makernote.
                 Returns 0 if there is no header.
         *//*!
          @brief Return the offset to the makernote from the start of the
                 TIFF header.
        *///! Return the size of the header in bytes./*!
          @brief Set the byte order used for the image.
         *//*!
          @brief Read the header from a data buffer, return true if successful.

          The default implementation simply returns true.
         *//*!
      @brief Tiff IFD Makernote. This is a concrete class suitable for all
             IFD makernotes.

             Contains a makernote header (which can be 0) and an IFD and
             implements child mgmt functions to deal with the IFD entries. The
             various makernote weirdnesses are taken care of in the makernote
             header (and possibly in special purpose IFD entries).
     */// class TiffMnEntry//!< The Makernote//!< New group for concrete mn/*!
          @brief Implements size() by forwarding the call to the actual
                 concrete Makernote, if there is one.
         *///! Implements count(). Return number of components in the entry./*!
          @brief Implements write() by forwarding the call to the actual
                 concrete Makernote, if there is one.
         *//*!
      @brief This class is the basis for Makernote support in TIFF. It contains
             a pointer to a concrete Makernote. The TiffReader visitor has the
             responsibility to create the correct Make/Model specific Makernote
             for a particular TIFF file. Calls to child management methods are
             forwarded to the concrete Makernote, if there is one.
     */// class TiffSubIfd//!< The subdirectories//!< Start of the range of group numbers for the sub-IFDs//! A collection of TIFF directories (IFDs)//! Implements sizeImage(). Return the sum of the image sizes of all sub-IFDs.//! Implements sizeData(). Return the sum of the sizes of all sub-IFDs.//! Implements size(). Return the size of the sub-Ifd pointers./*!
          @brief Implements writeImage(). Write the image data of each sub-IFD to
                 the \em ioWrapper. Return the number of bytes written.
         *//*!
          @brief Implements writeData(). Write the sub-IFDs to the \em ioWrapper.
                 Return the number of bytes written.
         *//*!
          @brief Implements write(). Write the sub-IFD pointers to the \em ioWrapper,
                 return the number of bytes written. The \em valueIdx and
                 \em imageIdx arguments are not used.
         *//*!
      @brief This class models a TIFF sub-directory (sub-IFD). A sub-IFD
             is an entry with one or more values that are pointers to IFD
             structures containing an IFD. The TIFF standard defines
             some important tags to be sub-IFDs, including the %Exif and
             GPS tags.
     */// class TiffDirectory//!< Pointer to the next IFD//!< True if the directory has a next pointer//!< List of components in this directory//! Write a binary directory entry for a TIFF component.//! @name Private Accessors/*!
          @brief Implements sizeImage(). Return the sum of the image sizes of
                 all components plus that of the next-IFD, if there is any.
         *//*!
          @brief Implements count(). Return the number of entries in the TIFF
                 directory. Does not count entries which are marked as deleted.
         *//*!
          @brief Implements size(). Return the size of the TIFF directory,
                 values and additional data, including the next-IFD, if any.
         *//*!
          @brief Implements writeImage(). Write the image data of the TIFF
                 directory to the \em ioWrapper by forwarding the call to each
                 component as well as the next-IFD, if there is any. Return the
                 number of bytes written.
         *//*!
          @brief Implements write(). Write the TIFF directory, values and
                 additional data, including the next-IFD, if any, to the
                 \em ioWrapper, return the number of bytes written.
         *///! Return true if the directory has a next pointer/*!
      @brief This class models a TIFF directory (%Ifd). It is a composite
             component of the TIFF tree.
     */// class TiffSizeEntry//!< Group of the entry with the data area//!< Tag of the entry with the data area//! Return the group of the related entry which has the data area/*!
      @brief A TIFF IFD entry containing the size of a data area of a related
             TiffDataEntry. This component is used, e.g. for
             \em Exif.Thumbnail.JPEGInterchangeFormatLength, which contains the
             size of \em Exif.Thumbnail.JPEGInterchangeFormat.
     */// class TiffImageEntry//!< Image strips data (never alloc'd) and sizes//! Pointers to the image data (strips) and their sizes.//! Implements sizeImage(). Return the size of the image data area.//! Implements sizeData(). Return the size of the image data area.//! Implements size(). Return the size of the strip pointers./*!
          @brief Implements writeImage(). Write the image data area to the \em ioWrapper.
                 Return the number of bytes written.
         *//*!
          @brief Implements writeData(). Write the image data area to the \em ioWrapper.
                 Return the number of bytes written.

          This function writes the image data to the data area of the current
          directory. It is used for TIFF image entries in the makernote (large
          preview images) so that the image data remains in the makernote IFD.
         *//*!
          @brief Implements write(). Write pointers into the image data area to the
                 \em ioWrapper. Return the number of bytes written. The \em valueIdx
                 and \em dataIdx  arguments are not used.
         *//*!
      @brief A standard TIFF IFD entry consisting of a value which is an array
             of offsets to image data areas. The sizes of the image data areas are
             provided in a related TiffSizeEntry, tag and group of which are set
             in the constructor.

             The data is not extracted into the higher level metadata tags, it is
             only copied to the target image when the image is written.
             This component is used, e.g., for
             \em Exif.Image.StripOffsets for which the sizes are provided in
             \em Exif.Image.StripByteCounts.
     */// class TiffDataEntry//!< Size of the data area//!< Pointer to the data area (never alloc'd)//! Implements sizeData(). Return the size of the data area.// Using doSize() from base class/*!
          @brief Implements writeData(). Write the data area to the \em ioWrapper.
                 Return the number of bytes written.
         *//*!
          @brief Implements write(). Write pointers into the data area to the
                 \em ioWrapper, relative to the offsets in the value. Return the
                 number of bytes written. The \em valueIdx argument is not used.

          The number of components in the value determines how many offsets are
          written. Set the first value to 0, the second to the size of the first
          data area, etc. when creating a new data entry. Offsets will be adjusted
          on write. The type of the value can only be signed or unsigned short or
          long.
         *//*!
      @brief A standard TIFF IFD entry consisting of a value which is an offset
             to a data area and the data area. The size of the data area is
             provided in a related TiffSizeEntry, tag and group of which are set
             in the constructor.

             This component extracts the data areas ("strips") and makes them
             available in the higher level metadata. It is used, e.g., for
             \em Exif.Thumbnail.JPEGInterchangeFormat for which the size
             is provided in \em Exif.Thumbnail.JPEGInterchangeFormatLength.
     */// class TiffDataEntryBase//!< Group of the entry with the size//!< Tag of the entry with the size//! Return the group of the entry which has the size/*!
          @brief Set the data areas ("strips").

          @param pSize Pointer to the Value holding the sizes corresponding
                       to this data entry.
          @param pData Pointer to the data area.
          @param sizeData Size of the data area.
          @param baseOffset Base offset into the data area.
         *//*!
      @brief Interface for a standard TIFF IFD entry consisting of a value
             which is a set of offsets to a data area. The sizes of these "strips"
             are provided in a related TiffSizeEntry, tag and group of which are
             set in the constructor. The implementations of this interface differ
             in whether the data areas are extracted to the higher level metadata
             (TiffDataEntry) or not (TiffImageEntry).
     */// class TiffEntry/*!
      @brief A standard TIFF IFD entry.
     */// class TiffEntryBase//!< Converted data value//!< Unique id of the entry in the image//!< True if this entry owns the value data//!< Pointer to the data area/*!
          Size of the data buffer holding the value in bytes, there is no
          minimum size.
         *///!< Offset to the data area//!< The number of values of the indicated type//!< Field TIFF type//! Helper function to write an \em offset to a preallocated binary buffer//! Implements sizeImage(). Return 0.//! Implements sizeData(). Return 0.//! Implements size(). Return the size of a standard TIFF entry/*!
          @brief Implements writeImage(). Standard TIFF entries have no image data:
                 write nothing and return 0.
         *//*!
          @brief Implements writeData(). Standard TIFF entries have no data:
                 write nothing and return 0.
         *///! Implements count()./*!
          @brief Implements write(). Write the value of a standard TIFF entry to
                 the \em ioWrapper, return the number of bytes written. Only the
                 \em ioWrapper and \em byteOrder arguments are used.
         *///! Set the unique id of the entry in the image//! Set the number of components in this entry//! Implements encode().//! Return a const pointer to the converted value of this component/*!
          @brief Return a pointer to the binary representation of the
                 value of this component.
         *//*!
          @brief Return the unique id of the entry in the image
         *//*!
          @brief Return the offset to the data area relative to the base
                 for the component (usually the start of the TIFF header)
         *///! Return the TIFF type/*!
          @brief Set tag value. Takes ownership of the pointer passed in.

          Update type, count and the pointer to the value.
        *//*!
          @brief Update the value. Takes ownership of the pointer passed in.

          Update binary value data and call setValue().
        *///! Set the entry's data buffer, taking ownership of the data buffer passed in.//! Set pointer and size of the entry's data (not taking ownership of the data).//! Set the offset/*!
          @brief Encode a TIFF component from the metadatum provided and
                 information from the \em encoder as needed.

          Implemented as double-dispatch calls back to one of the specific
          encoding functions at the \em encoder.
         *//*!
      @brief This abstract base class provides the common functionality of an
             IFD directory entry and defines an extended interface for derived
             concrete entries, which allows access to the attributes of the
             entry.
     *///!< %Group//!< Extended tag//! Search key for TIFF mapping structures.// struct TiffMappingInfo//!< Encoder function for matching tags//!< Decoder function for matching tags//!< Group that contains the tag//!< Tag (32 bit so that it can contain special tags)//!< Camera make for which these mapping functions apply//! Return the tag corresponding to the extended tag/*!
          @brief Compare a TiffMappingInfo with a TiffMappingInfo::Key.
                 The two are equal if TiffMappingInfo::make_ equals a substring
                 of the key of the same size. E.g., mapping info = "OLYMPUS",
                 key = "OLYMPUS OPTICAL CO.,LTD" (found in the image) match,
                 the extendedTag is Tag::all or equal to the extended tag of the
                 key, and the group is equal to that of the key.
         *///! TIFF mapping table for functions to decode special cases// class TiffComponent/*!
          Pointer to the start of the binary representation of the component in
          a memory buffer. The buffer is allocated and freed outside of this class.
         *///!< Group id for this component//!< Tag that identifies the component//! Implements sizeImage().//! Implements sizeData().//! Implements size().//! Implements writeImage().//! Implements writeData().//! Internal virtual copy constructor, implements clone().//! Implements write().//! Implements accept().//! Implements addNext(). The default implementation does nothing.//! Implements addChild(). The default implementation does nothing.//! Implements addPath(). The default implementation does nothing.//       we can sort components by tag and idx. Something is not quite right.// Todo: This is only implemented in TiffEntryBase. It is needed here so that/*!
          @brief Return the unique id of the entry in the image.
         *//*!
          @brief Return the size in bytes of the image data of this component
                 when written to a binary image.  This is a support function for
                 write(). TIFF components implement this method corresponding to
                 their implementation of writeImage().
         *//*!
          @brief Return the size in bytes of the IFD data of this component when
                 written to a binary image.  This is a support function for
                 write(). Components derived from TiffEntryBase implement this
                 method corresponding to their implementation of writeData().
         *//*!
          @brief Return the number of components in this component.
         *//*!
          @brief Return the size in bytes of the IFD value of this component
                 when written to a binary image.
         *//*!
          @brief Write the image data of this component to a binary image.
                 Return the number of bytes written. TIFF components implement
                 this method if needed.
         *//*!
          @brief Write the IFD data of this component to a binary image.
                 Return the number of bytes written. Components derived from
                 TiffEntryBase implement this method if needed.
         *//*!
          @brief Return an auto-pointer to a copy of itself (deep copy, but
                 without any children). The caller owns this copy and the
                 auto-pointer ensures that it will be deleted.
         *///! Return a pointer to the start of the binary representation of the component//! Return the group id of this component//! Return the tag of this entry./*!
          @brief Write a TiffComponent to a binary image.

          @param ioWrapper  IO wrapper to which the TiffComponent is written.
          @param byteOrder  Applicable byte order (little or big endian).
          @param offset     Offset from the start of the image (TIFF header) to
                            the component.
          @param valueIdx   Index of the component to be written relative to offset.
          @param dataIdx    Index of the data area of the component relative to offset.
          @param imageIdx   Index of the image data area relative to offset.
          @return           Number of bytes written to the IO wrapper including all
                            nested components.
          @throw            Error If the component cannot be written.
         *//*!
          @brief Set a pointer to the start of the binary representation of the
                 component in a memory buffer. The buffer must be allocated and
                 freed outside of this class.
         *//*!
          @brief Interface to accept visitors (Visitor pattern). Visitors
                 can perform operations on all components of the composite.

          @param visitor The visitor.
         *//*!
            @brief Add a "next" component to the component. Default is to do
                   nothing.
            @param tiffComponent Auto pointer to the component to add.
            @return Return a pointer to the newly added "next" element or 0.
         *//*!
          @brief Add a child to the component. Default is to do nothing.
          @param tiffComponent Auto pointer to the component to add.
          @return Return a pointer to the newly added child element or 0.
         *//*!
          @brief Add a TIFF entry \em tag to the component. Components on
                 the path to the entry are added if they don't exist yet.

          @param tag      The tag of the new entry
          @param tiffPath A path from the TIFF root element to a TIFF entry.
          @param pRoot    Pointer to the root component of the TIFF composite.
          @param object   TIFF component to add. If 0, the correct entry will be
                          created.

          @return A pointer to the newly added TIFF entry.
         *///! TiffComponent auto_ptr type/*!
      @brief Interface class for components of a TIFF directory hierarchy
             (Composite pattern).  Both TIFF directories as well as entries
             implement this interface.  A component can be uniquely identified
             by a tag, group tupel.  This class is implemented as a NVI
             (Non-Virtual Interface) and it has an interface for visitors
             (Visitor pattern) to perform operations on all components.
     */// class IoWrapper//! Pointer to an offset-writer, if any, or 0//! Indicates if the header has been written.//! Size of the header data.//! Pointer to the header data.//! Reference for the IO instance.//! Wrapper for OffsetWriter::setTarget(), using an int instead of the enum to reduce include deps/*!
          @brief Wraps the corresponding BasicIo::putb() method.

          Writes the TIFF header to the IO, if it hasn't been written yet, followed
          by the data passed in the argument.
         *//*!
          @brief Wraps the corresponding BasicIo::write() method.

          Writes the TIFF header to the IO, if it hasn't been written yet, followed
          by the data passed in the arguments.
         *//*!
          brief Constructor.

          The IO wrapper owns none of the objects passed in so the caller is
          responsible to keep them alive.
         *//*!
      @brief Simple IO wrapper to ensure that the header is only written if there is
             any other data at all.

      The wrapper is initialized with an IO reference and a pointer to a TIFF header.
      Subsequently the wrapper is used by all TIFF write methods. It takes care that
      the TIFF header is written to the IO first before any other output and only if
      there is any other data.
     */// class TiffPathItem//! Return the group//! Return the extended tag (32 bit so that it can contain special tags)/*!
      @brief A tupel consisting of extended Tag and group used as an item in
             TIFF paths.
    *///!< Special tag: root IFD of Panasonic RAW images//!< Special tag: all tags in a group//!< Special tag: next IFD//!< Special tag: root IFD//!< Dummy tag/*!
      Special TIFF tags for the use in TIFF structures only
    *///! Convert the %Exiv2 \em typeId to a TIFF value type.//! Convert the \em tiffType of a \em tag and \em group to an Exiv2 \em typeId.//!< TIFF IFD type//!< TIFF DOUBLE type//!< TIFF FLOAT type//!< Exif SRATIONAL type//!< Exif SLONG type//!< Exif SSHORT type//!< Exif UNDEFINED type//!< Exif SBYTE type//!< Exif RATIONAL type//!< Exif LONG type//!< Exif SHORT type//!< Exif ASCII type//!< Exif BYTE type//! TIFF value type./*!
  @file    tiffcomposite_int.hpp
  @brief   Internal classes used in a TIFF composite structure
  @author  Andreas Huggel (ahu)
           <a href="mailto:ahuggel@gmx.net">ahuggel@gmx.net</a>
  @date    11-Apr-06, ahu: created
 */valueIdxdataIdximageIdxencoderdatumvisitortiffComponenttiffPathsetSizepHeaderpTiffComponentpSizeScopedWriteLock &const ScopedWriteLockconst ScopedWriteLock &ScopedWriteLock~ScopedWriteLockScopedWriteLock *RWLock &ScopedReadLock &const ScopedReadLockconst ScopedReadLock &ScopedReadLock~ScopedReadLockScopedReadLock *const RWLockconst RWLock &RWLockwrunlockRWLock *rdunlocktryrdlockrdlocktrywrlockwrlock~RWLockrwlock_RW_LOCK_HPPdefined(MSDEV_2003) || defined(MSDEV_2005)// RW_LOCK_HPP//! object locked by the constructor (and released by destructor)//! destructor - unlocks the object used in constructor//! constructor - locks the object/*!
         @brief Class to provide a ScopedWriteLock.
         The lock is applied by the constructor and released by the destructor.
        *//*!
         @brief Class to provide a ScopedReadLock.
         The lock is applied by the constructor and released by the destructor.
        *///! the lock itself//! unlock rw lock//! unlock rd lock//! release rw lock//! test to see if the rd lock can be acquired//! acquire rd lock//! test to see if the rw lock can be acquired//! acquire rw lock//! constructor (releases lock)//! constructor (acquires the lock)// UNIX systems (including MinGW and Cygwin)/*!
         @brief Class to provide a Read-Write Lock
        */rwlockattr/Users/owura/Repos/codeql_eval/proj_repos/Exiv2-exiv2-pull-962-commits-e925bc5addd881543fa503470c8a859e112cca62/exiv2/src/tiffimage_int.hpp"tiffcomposite_int.hpp"isTiffImageTagFindExifdatum &const FindExifdatumconst FindExifdatum &FindExifdatumconst FindExifdatum *FindExifdatum *TiffMapping &const TiffMappingconst TiffMapping &findEncoderfindDecoderTiffParserWorker &const TiffParserWorkerconst TiffParserWorker &findPrimaryGroupsPrimaryGroups &vector<IfdId, allocator<IfdId>> &parseTiffHeaderBase *TiffCreator &const TiffCreatorconst TiffCreator &getPathTiffTreeStruct &const TiffTreeStructconst TiffTreeStruct &TiffGroupStruct &const TiffGroupStructconst TiffGroupStruct &const TiffGroupStruct *TiffGroupStruct *Tag::allTiffImgTagStruct &const TiffImgTagStructconst TiffImgTagStruct &const TiffImgTagStruct *TiffImgTagStruct *TiffHeader &const TiffHeaderconst TiffHeader &TiffHeaderisImageTagconst PrimaryGroupsconst PrimaryGroups *vector<IfdId, allocator<IfdId>> *~TiffHeaderTiffHeaderBase &const TiffHeaderBaseconst TiffHeaderBase &~TiffHeaderBaseOffsetWriter &const OffsetWriterconst OffsetWriter &~OffsetWriterwriteOffsetssetOriginOffsetData &const OffsetDataconst OffsetData &OffsetDataOffsetData *TiffMappingTiffParserWorkerTiffCreatorTiffTreeStructTiffGroupStructTiffImgTagStructOffsetIdcr2RawIfdOffsetOffsetListr_parentExtTag_parentGroup_root_newTiffCompFct_t_hasImageTags_offsetList_target_origin_const TiffMappingInfo[]TiffMappingInfo[]tiffMappingInfo_const TiffGroupStruct[]TiffGroupStruct[]tiffGroupStruct_const TiffTreeStruct[]TiffTreeStruct[]tiffTreeStruct_TIFFIMAGE_INT_HPP_// #ifndef TIFFIMAGE_INT_HPP_// class FindExifdatum//! Returns true if IFD id matches.//! Constructor, initializes the object with the IfdId to look for.//! Unary predicate that matches an Exifdatum with a given IfdId.// Todo: Move this class to metadatum_int.hpp or tags_int.hpp// class OffsetWriter//!< List of the offsets to replace//! Type of the list containing an identifier and an address pair.//!< Byte order to use to encode target address//!< Target address//!< Origin address//! Data structure for the offset list.//! Write the offsets to the IO instance \em io./*!
          @brief Set the \em target for offset \em id, i.e., the address to which the offset points.

          If the list doesn't contain an entry with \em id yet, this function won't do anything.
        *//*!
          @brief Set the \em origin of the offset for \em id, i.e., the location in the image where the offset is,
                 and the byte order to encode the offset.

          If the list doesn't contain an entry for \em id yet, this function will create one.
        *///!< CR2 RAW IFD offset, a pointer in the CR2 header to the 4th IFD in a CR2 image//! Identifiers for supported offsets/*!
      @brief Class to insert pointers or offsets to computed addresses at
             specific locations in an image. Used for offsets which are
             best computed during the regular write process. They are
             written in a second pass, using the writeOffsets() method.
     */// class TiffMapping//<! TIFF mapping table/*!
          @brief Find special encoder function for a key.

          If the returned pointer is 0, the tag should be encoded with the
          encoder function of the TIFF component, else the encoder function
          should be used.

          @param make Camera make
          @param extendedTag Extended tag
          @param group %Group

          @return Pointer to the encoder function
         *//*!
          @brief Find the decoder function for a key.

          If the returned pointer is 0, the tag should not be decoded,
          else the decoder function should be used.

          @param make Camera make
          @param extendedTag Extended tag
          @param group %Group

          @return Pointer to the decoder function
         *//*!
      @brief Table of TIFF decoding and encoding functions and find functions.
             This class is separated from the metadata decoder and encoder
             visitors so that the parser can be parametrized with a different
             table if needed. This is used, eg., for CR2 format, which uses a
             different decoder table.
     */// class TiffParserWorker/*!
          @brief Find primary groups in the source tree provided and populate
                 the list of primary groups.

          @param primaryGroups List of primary groups which is populated
          @param pSourceDir Pointer to the source composite tree to search (may be 0)
         *//*!
          @brief Parse TIFF metadata from a data buffer \em pData of length
                 \em size into a TIFF composite structure.

          @param pData     Pointer to the data buffer. Must point to data
                           in TIFF format; no checks are performed.
          @param size      Length of the data buffer.
          @param root      Root tag of the TIFF tree.
          @param pHeader   Pointer to a TIFF header.
          @return          An auto pointer with the root element of the TIFF
                           composite structure. If \em pData is 0 or \em size
                           is 0, the return value is a 0 pointer.
         *//*!
          @brief Encode TIFF metadata from the metadata containers into a
                 memory block \em blob.

          1) Parse the binary image, if one is provided, and
          2) attempt updating the parsed tree in-place ("non-intrusive writing")
          3) else, create a new tree and write a new TIFF structure ("intrusive
             writing"). If there is a parsed tree, it is only used to access the
             image data in this case.
         *//*!
          @brief Decode TIFF metadata from a data buffer \em pData of length
                 \em size into the provided metadata containers.

          This is the entry point to access image data in TIFF format. The
          parser uses classes TiffHeader and the TiffComponent and TiffVisitor
          hierarchies.

          @param exifData  Exif metadata container.
          @param iptcData  IPTC metadata container.
          @param xmpData   XMP metadata container.
          @param pData     Pointer to the data buffer. Must point to data
                           in TIFF format; no checks are performed.
          @param size      Length of the data buffer.
          @param root      Root tag of the TIFF tree for new TIFF components.
          @param findDecoderFct Function to access special decoding info.
          @param pHeader   Optional pointer to a TIFF header. If not provided,
                           a standard TIFF header is used.

          @return Byte order in which the data is encoded, invalidByteOrder if
                  decoding failed.
        *//*!
      @brief Stateless parser class for data in TIFF format. Images use this
             class to decode and encode TIFF-based data.
     */// class TiffCreator//<! TIFF group structure//<! TIFF tree structure/*!
          @brief Get the path, i.e., a list of extended tag and group pairs, from
                 the \em root TIFF element to the TIFF entry \em extendedTag and
                 \em group.
        *//*!
          @brief Create the TiffComponent for TIFF entry \em extendedTag and
                 \em group. The embedded lookup table is used to find the correct
                 component creation function. If the pointer that is returned
                 is 0, then the TIFF entry should be ignored.
        *//*!
      @brief TIFF component factory.
     *///!< Root//! Search key for TIFF tree structure.//!< Parent tag (32 bit so that it can contain special tags)//!< Parent group//!< Each group is a node in the tree//!< Tree root element, identifies a tree//! Comparison operator to compare a TiffTreeStruct with a TiffTreeStruct::Key/*!
      @brief Data structure used as a row of the table which describes TIFF trees.
             Multiple trees are needed as TIFF-based RAW image formats do not always
             use standard TIFF layout.
    *///!< Function to create the correct TIFF component//! Comparison operator to compare a TiffGroupStruct with a TiffGroupStruct::Key//! Search key for TIFF group structure./*!
      @brief Data structure used as a row (element) of a table (array)
             defining the TIFF component used for each tag in a group.
     */// struct TiffImgTagStruct//!< Group that contains the image tag//!< Image tag//! Comparison operator to compare a TiffImgTagStruct with a TiffImgTagStruct::Key//!< %Tag//! Search key for TIFF image tag structure./*!
      @brief Data structure used to list image tags for TIFF and TIFF-like images.
     */// class TiffHeader//!< Indicates if image tags are supported/*!
      @brief Standard TIFF header structure.
     *///! Convenience function to check if tag, group is in the list of TIFF image tags.// class TiffHeaderBase//!< Offset to the start of the root dir//!< Applicable byte order//!< Size of the header//!< Tag to identify the buffer as TIFF data/*!
          @brief Return \c true if the %Exif \em tag from \em group is an image tag.

          Certain tags of TIFF and TIFF-like images are required to correctly
          display the primary image. These image tags contain image data rather
          than metadata.

          @param tag Tag number.
          @param group Group identifier.
          @param pPrimaryGroups Pointer to a list of TIFF groups that contain
                 primary images, empty if none are marked.

          @return The default implementation returns \c false.
         *///! Return the tag value (magic number) which identifies the buffer as TIFF data.//! Return the size (in bytes) of the image header.//! Return the offset to the start of the root directory.//! Return the byte order (little or big endian)./*!
          @brief Print debug info for the image header to \em os.

          @param os Output stream to write to.
          @param prefix Prefix to be written before each line of output.
         *//*!
          @brief Return the image header in binary format.
                 The caller owns this data and %DataBuf ensures that it will be deleted.

          @return Binary header data.
         *///! Set the offset to the start of the root directory.//! Set the byte order./*!
          @brief Read the image header from a data buffer. Return false if the
                 data buffer does not contain an image header of the expected
                 format, else true.

          @param pData Pointer to the data buffer.
          @param size  Number of bytes in the data buffer.
          @return True if the TIFF header was read successfully. False if the
                 data buffer does not contain a valid TIFF header.
         *///! Constructor taking \em tag, \em size and default \em byteOrder and \em offset./*!
      @brief Abstract base class defining the interface of an image header.
             Used internally by classes for TIFF-based images.  Default
             implementation is for the regular TIFF header.
     *//*!
      @brief Contains internal objects which are not published and are not part
             of the <b>libexiv2</b> API.
     *//*!
  @file    tiffimage_int.hpp
  @brief   Internal class TiffParserWorker to parse TIFF data.
  @author  Andreas Huggel (ahu)
           <a href="mailto:ahuggel@gmx.net">ahuggel@gmx.net</a>
  @date    23-Apr-08, ahu: created
 */originprimaryGroupspSourceDirfindEncoderFctpOffsetWriterfindDecoderFctpPrimaryGroupshasImageTags/Users/owura/Repos/codeql_eval/proj_repos/Exiv2-exiv2-pull-962-commits-e925bc5addd881543fa503470c8a859e112cca62/exiv2/src/cr2header_int.hpp"tiffimage_int.hpp"Cr2Header &const Cr2Headerconst Cr2Header &Cr2Headeroffset2addroffset2_CR2IMAGE_INT_HPP_cr2sig_const Cr2Header *Cr2Header *~Cr2Header// #ifndef CR2IMAGE_INT_HPP_// class Cr2Header//!< Signature for CR2 type TIFF//!< Bytes 12-15 from the header//! Return the address of offset2 from the start of the header/// @brief Canon CR2 header structure./*!
  @file    cr2image_int.hpp
  @brief   Internal classes to support CR2 image format
  @author  Andreas Huggel (ahu)
           <a href="mailto:ahuggel@gmx.net">ahuggel@gmx.net</a>
  @date    23-Apr-08, ahu: created
 *//Users/owura/Repos/codeql_eval/proj_repos/Exiv2-exiv2-pull-962-commits-e925bc5addd881543fa503470c8a859e112cca62/exiv2/src/cr2header_int.cpp"cr2header_int.hpp"const TiffHeaderBase *0x00000000CR "CR\2\0"// ...and any (IFD0) tag that is in the TIFF image tags list// CR2 image tags are all IFD2 and IFD3 tags/*pPrimaryGroups*/// Cr2Header::write// Write a dummy value for the RAW IFD offset. The offset-writer is used to set this offset in a second pass.// Cr2Header::readmap<OffsetId, OffsetData, less<OffsetId>, allocator<pair<const OffsetId, OffsetData>>>less<OffsetId> &allocator<pair<const OffsetId, OffsetData>> &__tree_node<__value_type<OffsetId, OffsetData>, void *> *pair<const OffsetId, OffsetData> *pair<const OffsetId, OffsetData> &vector<NativePreview, allocator<NativePreview>>allocator<NativePreview> &NativePreview *map<int, basic_string<char, char_traits<char>, allocator<char>>, less<int>, allocator<pair<const int, basic_string<char, char_traits<char>, allocator<char>>>>>less<int> &allocator<pair<const int, basic_string<char, char_traits<char>, allocator<char>>>> &__tree_node<__value_type<int, basic_string<char, char_traits<char>, allocator<char>>>, void *> *pair<const int, basic_string<char, char_traits<char>, allocator<char>>> *pair<const int, basic_string<char, char_traits<char>, allocator<char>>> &__wrap_iter<const Xmpdatum *>vector<Xmpdatum, allocator<Xmpdatum>>allocator<Xmpdatum> &map<basic_string<char, char_traits<char>, allocator<char>>, XmpNsInfo, less<basic_string<char, char_traits<char>, allocator<char>>>, allocator<pair<const basic_string<char, char_traits<char>, allocator<char>>, XmpNsInfo>>>auto_ptr<XmpKey>__wrap_iter<Iptcdatum *>__wrap_iter<const Iptcdatum *>__wrap_iter<const Iptcdatum *> *vector<Iptcdatum, allocator<Iptcdatum>>allocator<Iptcdatum> &__tree_const_iterator<basic_string<char, char_traits<char>, allocator<char>>, __tree_node<basic_string<char, char_traits<char>, allocator<char>>, void *> *, long>__wrap_iter<const unsigned int *>auto_ptr<IptcKey>auto_ptr<IptcKey> &set<basic_string<char, char_traits<char>, allocator<char>>, less<basic_string<char, char_traits<char>, allocator<char>>>, allocator<basic_string<char, char_traits<char>, allocator<char>>>>vector<unsigned int, allocator<unsigned int>>allocator<unsigned int> &is_same<value_type, _Key>__tree<_Key, _Compare, type>pair<const_iterator, const_iterator>pair<const_iterator, bool>less<_Key>allocator<_Key>auto_ptr_ref<TiffComponent>auto_ptr_ref<TiffComponent> &const auto_ptr_ref<TiffComponent>const auto_ptr_ref<TiffComponent> &vector<TiffComponent *, allocator<TiffComponent *>>allocator<TiffComponent *> &TiffComponent **TiffComponent *&pair<const unsigned char *, unsigned int>const pair<const unsigned char *, unsigned int>const pair<const unsigned char *, unsigned int> &pair<const unsigned char *, unsigned int> &vector<pair<const unsigned char *, unsigned int>, allocator<pair<const unsigned char *, unsigned int>>>allocator<pair<const unsigned char *, unsigned int>> &pair<const unsigned char *, unsigned int> *vector<TiffDirectory *, allocator<TiffDirectory *>>allocator<TiffDirectory *> &TiffDirectory **TiffDirectory *&auto_ptr<TiffComponent> &allocator<__tree_node<basic_string<char, char_traits<char>, allocator<char>>, void *>>allocator<__tree_node<basic_string<char, char_traits<char>, allocator<char>>, void *>> &const allocator<__tree_node<basic_string<char, char_traits<char>, allocator<char>>, void *>>const allocator<__tree_node<basic_string<char, char_traits<char>, allocator<char>>, void *>> &const __tree_node<basic_string<char, char_traits<char>, allocator<char>>, void *>const __tree_node<basic_string<char, char_traits<char>, allocator<char>>, void *> &__tree_node<basic_string<char, char_traits<char>, allocator<char>>, void *> &const __tree_node<basic_string<char, char_traits<char>, allocator<char>>, void *> *__allocator_traits_rebind<allocator<basic_string<char, char_traits<char>, allocator<char>>>, __tree_node<basic_string<char, char_traits<char>, allocator<char>>, void *>, true>__allocator_traits_rebind<allocator<basic_string<char, char_traits<char>, allocator<char>>>, __tree_node<basic_string<char, char_traits<char>, allocator<char>>, void *>, true> &const __allocator_traits_rebind<allocator<basic_string<char, char_traits<char>, allocator<char>>>, __tree_node<basic_string<char, char_traits<char>, allocator<char>>, void *>, true>const __allocator_traits_rebind<allocator<basic_string<char, char_traits<char>, allocator<char>>>, __tree_node<basic_string<char, char_traits<char>, allocator<char>>, void *>, true> &allocator<__tree_node<__value_type<OffsetId, OffsetData>, void *>>allocator<__tree_node<__value_type<OffsetId, OffsetData>, void *>> &const allocator<__tree_node<__value_type<OffsetId, OffsetData>, void *>>const allocator<__tree_node<__value_type<OffsetId, OffsetData>, void *>> &const __tree_node<__value_type<OffsetId, OffsetData>, void *>const __tree_node<__value_type<OffsetId, OffsetData>, void *> &__tree_node<__value_type<OffsetId, OffsetData>, void *> &const __tree_node<__value_type<OffsetId, OffsetData>, void *> *__allocator_traits_rebind<allocator<__value_type<OffsetId, OffsetData>>, __tree_node<__value_type<OffsetId, OffsetData>, void *>, true>__allocator_traits_rebind<allocator<__value_type<OffsetId, OffsetData>>, __tree_node<__value_type<OffsetId, OffsetData>, void *>, true> &const __allocator_traits_rebind<allocator<__value_type<OffsetId, OffsetData>>, __tree_node<__value_type<OffsetId, OffsetData>, void *>, true>const __allocator_traits_rebind<allocator<__value_type<OffsetId, OffsetData>>, __tree_node<__value_type<OffsetId, OffsetData>, void *>, true> &__allocator_traits_rebind<allocator<__tree_node<__value_type<OffsetId, OffsetData>, void *>>, __tree_node_base<void *>, true>__allocator_traits_rebind<allocator<__tree_node<__value_type<OffsetId, OffsetData>, void *>>, __tree_node_base<void *>, true> &const __allocator_traits_rebind<allocator<__tree_node<__value_type<OffsetId, OffsetData>, void *>>, __tree_node_base<void *>, true>const __allocator_traits_rebind<allocator<__tree_node<__value_type<OffsetId, OffsetData>, void *>>, __tree_node_base<void *>, true> &allocator<__value_type<OffsetId, OffsetData>>allocator<__value_type<OffsetId, OffsetData>> &const allocator<__value_type<OffsetId, OffsetData>>const allocator<__value_type<OffsetId, OffsetData>> &const __value_type<OffsetId, OffsetData>const __value_type<OffsetId, OffsetData> &__value_type<OffsetId, OffsetData> &const __value_type<OffsetId, OffsetData> *__value_type<OffsetId, OffsetData> *__allocator_traits_rebind<allocator<pair<const OffsetId, OffsetData>>, __value_type<OffsetId, OffsetData>, true>__allocator_traits_rebind<allocator<pair<const OffsetId, OffsetData>>, __value_type<OffsetId, OffsetData>, true> &const __allocator_traits_rebind<allocator<pair<const OffsetId, OffsetData>>, __value_type<OffsetId, OffsetData>, true>const __allocator_traits_rebind<allocator<pair<const OffsetId, OffsetData>>, __value_type<OffsetId, OffsetData>, true> &__allocator_traits_rebind<allocator<__tree_node<basic_string<char, char_traits<char>, allocator<char>>, void *>>, __tree_node_base<void *>, true>__allocator_traits_rebind<allocator<__tree_node<basic_string<char, char_traits<char>, allocator<char>>, void *>>, __tree_node_base<void *>, true> &const __allocator_traits_rebind<allocator<__tree_node<basic_string<char, char_traits<char>, allocator<char>>, void *>>, __tree_node_base<void *>, true>const __allocator_traits_rebind<allocator<__tree_node<basic_string<char, char_traits<char>, allocator<char>>, void *>>, __tree_node_base<void *>, true> &allocator<__tree_node<__value_type<int, basic_string<char, char_traits<char>, allocator<char>>>, void *>>allocator<__tree_node<__value_type<int, basic_string<char, char_traits<char>, allocator<char>>>, void *>> &const allocator<__tree_node<__value_type<int, basic_string<char, char_traits<char>, allocator<char>>>, void *>>const allocator<__tree_node<__value_type<int, basic_string<char, char_traits<char>, allocator<char>>>, void *>> &const __tree_node<__value_type<int, basic_string<char, char_traits<char>, allocator<char>>>, void *>const __tree_node<__value_type<int, basic_string<char, char_traits<char>, allocator<char>>>, void *> &__tree_node<__value_type<int, basic_string<char, char_traits<char>, allocator<char>>>, void *> &const __tree_node<__value_type<int, basic_string<char, char_traits<char>, allocator<char>>>, void *> *__allocator_traits_rebind<allocator<__value_type<int, basic_string<char, char_traits<char>, allocator<char>>>>, __tree_node<__value_type<int, basic_string<char, char_traits<char>, allocator<char>>>, void *>, true>__allocator_traits_rebind<allocator<__value_type<int, basic_string<char, char_traits<char>, allocator<char>>>>, __tree_node<__value_type<int, basic_string<char, char_traits<char>, allocator<char>>>, void *>, true> &const __allocator_traits_rebind<allocator<__value_type<int, basic_string<char, char_traits<char>, allocator<char>>>>, __tree_node<__value_type<int, basic_string<char, char_traits<char>, allocator<char>>>, void *>, true>const __allocator_traits_rebind<allocator<__value_type<int, basic_string<char, char_traits<char>, allocator<char>>>>, __tree_node<__value_type<int, basic_string<char, char_traits<char>, allocator<char>>>, void *>, true> &__allocator_traits_rebind<allocator<__tree_node<__value_type<int, basic_string<char, char_traits<char>, allocator<char>>>, void *>>, __tree_node_base<void *>, true>__allocator_traits_rebind<allocator<__tree_node<__value_type<int, basic_string<char, char_traits<char>, allocator<char>>>, void *>>, __tree_node_base<void *>, true> &const __allocator_traits_rebind<allocator<__tree_node<__value_type<int, basic_string<char, char_traits<char>, allocator<char>>>, void *>>, __tree_node_base<void *>, true>const __allocator_traits_rebind<allocator<__tree_node<__value_type<int, basic_string<char, char_traits<char>, allocator<char>>>, void *>>, __tree_node_base<void *>, true> &allocator<__value_type<int, basic_string<char, char_traits<char>, allocator<char>>>>allocator<__value_type<int, basic_string<char, char_traits<char>, allocator<char>>>> &const allocator<__value_type<int, basic_string<char, char_traits<char>, allocator<char>>>>const allocator<__value_type<int, basic_string<char, char_traits<char>, allocator<char>>>> &const __value_type<int, basic_string<char, char_traits<char>, allocator<char>>>const __value_type<int, basic_string<char, char_traits<char>, allocator<char>>> &__value_type<int, basic_string<char, char_traits<char>, allocator<char>>> &const __value_type<int, basic_string<char, char_traits<char>, allocator<char>>> *__value_type<int, basic_string<char, char_traits<char>, allocator<char>>> *__allocator_traits_rebind<allocator<pair<const int, basic_string<char, char_traits<char>, allocator<char>>>>, __value_type<int, basic_string<char, char_traits<char>, allocator<char>>>, true>__allocator_traits_rebind<allocator<pair<const int, basic_string<char, char_traits<char>, allocator<char>>>>, __value_type<int, basic_string<char, char_traits<char>, allocator<char>>>, true> &const __allocator_traits_rebind<allocator<pair<const int, basic_string<char, char_traits<char>, allocator<char>>>>, __value_type<int, basic_string<char, char_traits<char>, allocator<char>>>, true>const __allocator_traits_rebind<allocator<pair<const int, basic_string<char, char_traits<char>, allocator<char>>>>, __value_type<int, basic_string<char, char_traits<char>, allocator<char>>>, true> &less<OffsetId>const less<OffsetId>const less<OffsetId> &__identity<less<OffsetId>>__identity<less<OffsetId>> &const __identity<less<OffsetId>>const __identity<less<OffsetId>> &allocator<pair<const OffsetId, OffsetData>>const allocator<pair<const OffsetId, OffsetData>>const allocator<pair<const OffsetId, OffsetData>> &const pair<const OffsetId, OffsetData>const pair<const OffsetId, OffsetData> &const pair<const OffsetId, OffsetData> *__identity<allocator<pair<const OffsetId, OffsetData>>>__identity<allocator<pair<const OffsetId, OffsetData>>> &const __identity<allocator<pair<const OffsetId, OffsetData>>>const __identity<allocator<pair<const OffsetId, OffsetData>>> &allocator<pair<const unsigned char *, unsigned int>>const allocator<pair<const unsigned char *, unsigned int>>const allocator<pair<const unsigned char *, unsigned int>> &const pair<const unsigned char *, unsigned int> *__identity<allocator<pair<const unsigned char *, unsigned int>>>__identity<allocator<pair<const unsigned char *, unsigned int>>> &const __identity<allocator<pair<const unsigned char *, unsigned int>>>const __identity<allocator<pair<const unsigned char *, unsigned int>>> &allocator<TiffComponent *>const allocator<TiffComponent *>const allocator<TiffComponent *> &TiffComponent *const &TiffComponent *const *__identity<allocator<TiffComponent *>>__identity<allocator<TiffComponent *>> &const __identity<allocator<TiffComponent *>>const __identity<allocator<TiffComponent *>> &allocator<TiffDirectory *>const allocator<TiffDirectory *>const allocator<TiffDirectory *> &TiffDirectory *constTiffDirectory *const &TiffDirectory *const *__identity<allocator<TiffDirectory *>>__identity<allocator<TiffDirectory *>> &const __identity<allocator<TiffDirectory *>>const __identity<allocator<TiffDirectory *>> &allocator<unsigned int>const allocator<unsigned int>const allocator<unsigned int> &__identity<allocator<unsigned int>>__identity<allocator<unsigned int>> &const __identity<allocator<unsigned int>>const __identity<allocator<unsigned int>> &allocator<Iptcdatum>const allocator<Iptcdatum>const allocator<Iptcdatum> &__identity<allocator<Iptcdatum>>__identity<allocator<Iptcdatum>> &const __identity<allocator<Iptcdatum>>const __identity<allocator<Iptcdatum>> &allocator<Xmpdatum>const allocator<Xmpdatum>const allocator<Xmpdatum> &__identity<allocator<Xmpdatum>>__identity<allocator<Xmpdatum>> &const __identity<allocator<Xmpdatum>>const __identity<allocator<Xmpdatum>> &allocator<NativePreview>const allocator<NativePreview>const allocator<NativePreview> &const NativePreview *__identity<allocator<NativePreview>>__identity<allocator<NativePreview>> &const __identity<allocator<NativePreview>>const __identity<allocator<NativePreview>> &less<int>const less<int>const less<int> &__identity<less<int>>__identity<less<int>> &const __identity<less<int>>const __identity<less<int>> &allocator<pair<const int, basic_string<char, char_traits<char>, allocator<char>>>>const allocator<pair<const int, basic_string<char, char_traits<char>, allocator<char>>>>const allocator<pair<const int, basic_string<char, char_traits<char>, allocator<char>>>> &const pair<const int, basic_string<char, char_traits<char>, allocator<char>>>const pair<const int, basic_string<char, char_traits<char>, allocator<char>>> &const pair<const int, basic_string<char, char_traits<char>, allocator<char>>> *__identity<allocator<pair<const int, basic_string<char, char_traits<char>, allocator<char>>>>>__identity<allocator<pair<const int, basic_string<char, char_traits<char>, allocator<char>>>>> &const __identity<allocator<pair<const int, basic_string<char, char_traits<char>, allocator<char>>>>>const __identity<allocator<pair<const int, basic_string<char, char_traits<char>, allocator<char>>>>> &vector<Xmpdatum, allocator<Xmpdatum>> *vector<Iptcdatum, allocator<Iptcdatum>> *const vector<Iptcdatum, allocator<Iptcdatum>>const vector<Iptcdatum, allocator<Iptcdatum>> *__vector_base<Iptcdatum, allocator<Iptcdatum>> *const __vector_base<Iptcdatum, allocator<Iptcdatum>>const __vector_base<Iptcdatum, allocator<Iptcdatum>> *vector<TiffComponent *, allocator<TiffComponent *>> *vector<pair<const unsigned char *, unsigned int>, allocator<pair<const unsigned char *, unsigned int>>> *operator std::__1::auto_ptr_ref<Exiv2::Internal::TiffComponent>operator std::__1::pair<const unsigned char *, unsigned int> *operator Exiv2::Internal::TiffComponent **operator Exiv2::Xmpdatum *__non_trivial_if<true, allocator<pair<const int, basic_string<char, char_traits<char>, allocator<char>>>>>__non_trivial_if<true, allocator<pair<const int, basic_string<char, char_traits<char>, allocator<char>>>>> &const __non_trivial_if<true, allocator<pair<const int, basic_string<char, char_traits<char>, allocator<char>>>>>const __non_trivial_if<true, allocator<pair<const int, basic_string<char, char_traits<char>, allocator<char>>>>> &binary_function<int, int, bool>binary_function<int, int, bool> &const binary_function<int, int, bool>const binary_function<int, int, bool> &__non_trivial_if<true, allocator<NativePreview>>__non_trivial_if<true, allocator<NativePreview>> &const __non_trivial_if<true, allocator<NativePreview>>const __non_trivial_if<true, allocator<NativePreview>> &__non_trivial_if<true, allocator<Xmpdatum>>__non_trivial_if<true, allocator<Xmpdatum>> &const __non_trivial_if<true, allocator<Xmpdatum>>const __non_trivial_if<true, allocator<Xmpdatum>> &__non_trivial_if<true, allocator<Iptcdatum>>__non_trivial_if<true, allocator<Iptcdatum>> &const __non_trivial_if<true, allocator<Iptcdatum>>const __non_trivial_if<true, allocator<Iptcdatum>> &__non_trivial_if<true, allocator<unsigned int>>__non_trivial_if<true, allocator<unsigned int>> &const __non_trivial_if<true, allocator<unsigned int>>const __non_trivial_if<true, allocator<unsigned int>> &__non_trivial_if<true, allocator<TiffDirectory *>>__non_trivial_if<true, allocator<TiffDirectory *>> &const __non_trivial_if<true, allocator<TiffDirectory *>>const __non_trivial_if<true, allocator<TiffDirectory *>> &__non_trivial_if<true, allocator<TiffComponent *>>__non_trivial_if<true, allocator<TiffComponent *>> &const __non_trivial_if<true, allocator<TiffComponent *>>const __non_trivial_if<true, allocator<TiffComponent *>> &__non_trivial_if<true, allocator<pair<const unsigned char *, unsigned int>>>__non_trivial_if<true, allocator<pair<const unsigned char *, unsigned int>>> &const __non_trivial_if<true, allocator<pair<const unsigned char *, unsigned int>>>const __non_trivial_if<true, allocator<pair<const unsigned char *, unsigned int>>> &__non_trivial_if<true, allocator<pair<const OffsetId, OffsetData>>>__non_trivial_if<true, allocator<pair<const OffsetId, OffsetData>>> &const __non_trivial_if<true, allocator<pair<const OffsetId, OffsetData>>>const __non_trivial_if<true, allocator<pair<const OffsetId, OffsetData>>> &binary_function<OffsetId, OffsetId, bool>binary_function<OffsetId, OffsetId, bool> &const binary_function<OffsetId, OffsetId, bool>const binary_function<OffsetId, OffsetId, bool> &rebind<__value_type<int, basic_string<char, char_traits<char>, allocator<char>>>>rebind<__value_type<int, basic_string<char, char_traits<char>, allocator<char>>>> &const rebind<__value_type<int, basic_string<char, char_traits<char>, allocator<char>>>>const rebind<__value_type<int, basic_string<char, char_traits<char>, allocator<char>>>> &__has_rebind_other<allocator<pair<const int, basic_string<char, char_traits<char>, allocator<char>>>>, __value_type<int, basic_string<char, char_traits<char>, allocator<char>>>, void>__has_rebind_other<allocator<pair<const int, basic_string<char, char_traits<char>, allocator<char>>>>, __value_type<int, basic_string<char, char_traits<char>, allocator<char>>>, void> &const __has_rebind_other<allocator<pair<const int, basic_string<char, char_traits<char>, allocator<char>>>>, __value_type<int, basic_string<char, char_traits<char>, allocator<char>>>, void>const __has_rebind_other<allocator<pair<const int, basic_string<char, char_traits<char>, allocator<char>>>>, __value_type<int, basic_string<char, char_traits<char>, allocator<char>>>, void> &__non_trivial_if<true, allocator<__value_type<int, basic_string<char, char_traits<char>, allocator<char>>>>>__non_trivial_if<true, allocator<__value_type<int, basic_string<char, char_traits<char>, allocator<char>>>>> &const __non_trivial_if<true, allocator<__value_type<int, basic_string<char, char_traits<char>, allocator<char>>>>>const __non_trivial_if<true, allocator<__value_type<int, basic_string<char, char_traits<char>, allocator<char>>>>> &__has_rebind_other<allocator<__tree_node<__value_type<int, basic_string<char, char_traits<char>, allocator<char>>>, void *>>, __tree_node_base<void *>, void>__has_rebind_other<allocator<__tree_node<__value_type<int, basic_string<char, char_traits<char>, allocator<char>>>, void *>>, __tree_node_base<void *>, void> &const __has_rebind_other<allocator<__tree_node<__value_type<int, basic_string<char, char_traits<char>, allocator<char>>>, void *>>, __tree_node_base<void *>, void>const __has_rebind_other<allocator<__tree_node<__value_type<int, basic_string<char, char_traits<char>, allocator<char>>>, void *>>, __tree_node_base<void *>, void> &rebind<__tree_node<__value_type<int, basic_string<char, char_traits<char>, allocator<char>>>, void *>>rebind<__tree_node<__value_type<int, basic_string<char, char_traits<char>, allocator<char>>>, void *>> &const rebind<__tree_node<__value_type<int, basic_string<char, char_traits<char>, allocator<char>>>, void *>>const rebind<__tree_node<__value_type<int, basic_string<char, char_traits<char>, allocator<char>>>, void *>> &__has_rebind_other<allocator<__value_type<int, basic_string<char, char_traits<char>, allocator<char>>>>, __tree_node<__value_type<int, basic_string<char, char_traits<char>, allocator<char>>>, void *>, void>__has_rebind_other<allocator<__value_type<int, basic_string<char, char_traits<char>, allocator<char>>>>, __tree_node<__value_type<int, basic_string<char, char_traits<char>, allocator<char>>>, void *>, void> &const __has_rebind_other<allocator<__value_type<int, basic_string<char, char_traits<char>, allocator<char>>>>, __tree_node<__value_type<int, basic_string<char, char_traits<char>, allocator<char>>>, void *>, void>const __has_rebind_other<allocator<__value_type<int, basic_string<char, char_traits<char>, allocator<char>>>>, __tree_node<__value_type<int, basic_string<char, char_traits<char>, allocator<char>>>, void *>, void> &__non_trivial_if<true, allocator<__tree_node<__value_type<int, basic_string<char, char_traits<char>, allocator<char>>>, void *>>>__non_trivial_if<true, allocator<__tree_node<__value_type<int, basic_string<char, char_traits<char>, allocator<char>>>, void *>>> &const __non_trivial_if<true, allocator<__tree_node<__value_type<int, basic_string<char, char_traits<char>, allocator<char>>>, void *>>>const __non_trivial_if<true, allocator<__tree_node<__value_type<int, basic_string<char, char_traits<char>, allocator<char>>>, void *>>> &__has_rebind_other<allocator<__tree_node<basic_string<char, char_traits<char>, allocator<char>>, void *>>, __tree_node_base<void *>, void>__has_rebind_other<allocator<__tree_node<basic_string<char, char_traits<char>, allocator<char>>, void *>>, __tree_node_base<void *>, void> &const __has_rebind_other<allocator<__tree_node<basic_string<char, char_traits<char>, allocator<char>>, void *>>, __tree_node_base<void *>, void>const __has_rebind_other<allocator<__tree_node<basic_string<char, char_traits<char>, allocator<char>>, void *>>, __tree_node_base<void *>, void> &rebind<__value_type<OffsetId, OffsetData>>rebind<__value_type<OffsetId, OffsetData>> &const rebind<__value_type<OffsetId, OffsetData>>const rebind<__value_type<OffsetId, OffsetData>> &__has_rebind_other<allocator<pair<const OffsetId, OffsetData>>, __value_type<OffsetId, OffsetData>, void>__has_rebind_other<allocator<pair<const OffsetId, OffsetData>>, __value_type<OffsetId, OffsetData>, void> &const __has_rebind_other<allocator<pair<const OffsetId, OffsetData>>, __value_type<OffsetId, OffsetData>, void>const __has_rebind_other<allocator<pair<const OffsetId, OffsetData>>, __value_type<OffsetId, OffsetData>, void> &__non_trivial_if<true, allocator<__value_type<OffsetId, OffsetData>>>__non_trivial_if<true, allocator<__value_type<OffsetId, OffsetData>>> &const __non_trivial_if<true, allocator<__value_type<OffsetId, OffsetData>>>const __non_trivial_if<true, allocator<__value_type<OffsetId, OffsetData>>> &__has_rebind_other<allocator<__tree_node<__value_type<OffsetId, OffsetData>, void *>>, __tree_node_base<void *>, void>__has_rebind_other<allocator<__tree_node<__value_type<OffsetId, OffsetData>, void *>>, __tree_node_base<void *>, void> &const __has_rebind_other<allocator<__tree_node<__value_type<OffsetId, OffsetData>, void *>>, __tree_node_base<void *>, void>const __has_rebind_other<allocator<__tree_node<__value_type<OffsetId, OffsetData>, void *>>, __tree_node_base<void *>, void> &rebind<__tree_node<__value_type<OffsetId, OffsetData>, void *>>rebind<__tree_node<__value_type<OffsetId, OffsetData>, void *>> &const rebind<__tree_node<__value_type<OffsetId, OffsetData>, void *>>const rebind<__tree_node<__value_type<OffsetId, OffsetData>, void *>> &__has_rebind_other<allocator<__value_type<OffsetId, OffsetData>>, __tree_node<__value_type<OffsetId, OffsetData>, void *>, void>__has_rebind_other<allocator<__value_type<OffsetId, OffsetData>>, __tree_node<__value_type<OffsetId, OffsetData>, void *>, void> &const __has_rebind_other<allocator<__value_type<OffsetId, OffsetData>>, __tree_node<__value_type<OffsetId, OffsetData>, void *>, void>const __has_rebind_other<allocator<__value_type<OffsetId, OffsetData>>, __tree_node<__value_type<OffsetId, OffsetData>, void *>, void> &__non_trivial_if<true, allocator<__tree_node<__value_type<OffsetId, OffsetData>, void *>>>__non_trivial_if<true, allocator<__tree_node<__value_type<OffsetId, OffsetData>, void *>>> &const __non_trivial_if<true, allocator<__tree_node<__value_type<OffsetId, OffsetData>, void *>>>const __non_trivial_if<true, allocator<__tree_node<__value_type<OffsetId, OffsetData>, void *>>> &rebind<__tree_node<basic_string<char, char_traits<char>, allocator<char>>, void *>>rebind<__tree_node<basic_string<char, char_traits<char>, allocator<char>>, void *>> &const rebind<__tree_node<basic_string<char, char_traits<char>, allocator<char>>, void *>>const rebind<__tree_node<basic_string<char, char_traits<char>, allocator<char>>, void *>> &__has_rebind_other<allocator<basic_string<char, char_traits<char>, allocator<char>>>, __tree_node<basic_string<char, char_traits<char>, allocator<char>>, void *>, void>__has_rebind_other<allocator<basic_string<char, char_traits<char>, allocator<char>>>, __tree_node<basic_string<char, char_traits<char>, allocator<char>>, void *>, void> &const __has_rebind_other<allocator<basic_string<char, char_traits<char>, allocator<char>>>, __tree_node<basic_string<char, char_traits<char>, allocator<char>>, void *>, void>const __has_rebind_other<allocator<basic_string<char, char_traits<char>, allocator<char>>>, __tree_node<basic_string<char, char_traits<char>, allocator<char>>, void *>, void> &__non_trivial_if<true, allocator<__tree_node<basic_string<char, char_traits<char>, allocator<char>>, void *>>>__non_trivial_if<true, allocator<__tree_node<basic_string<char, char_traits<char>, allocator<char>>, void *>>> &const __non_trivial_if<true, allocator<__tree_node<basic_string<char, char_traits<char>, allocator<char>>, void *>>>const __non_trivial_if<true, allocator<__tree_node<basic_string<char, char_traits<char>, allocator<char>>, void *>>> &allocator_traits<allocator<TiffDirectory *>>allocator_traits<allocator<TiffDirectory *>> &const allocator_traits<allocator<TiffDirectory *>>const allocator_traits<allocator<TiffDirectory *>> &reverse_iterator<__wrap_iter<TiffDirectory **>>reverse_iterator<__wrap_iter<TiffDirectory *const *>>__vector_base<TiffDirectory *, allocator<TiffDirectory *>>__vector_base<TiffDirectory *, allocator<TiffDirectory *>> &const __vector_base<TiffDirectory *, allocator<TiffDirectory *>>const __vector_base<TiffDirectory *, allocator<TiffDirectory *>> &allocator_traits<allocator<pair<const unsigned char *, unsigned int>>>allocator_traits<allocator<pair<const unsigned char *, unsigned int>>> &const allocator_traits<allocator<pair<const unsigned char *, unsigned int>>>const allocator_traits<allocator<pair<const unsigned char *, unsigned int>>> &reverse_iterator<__wrap_iter<pair<const unsigned char *, unsigned int> *>>reverse_iterator<__wrap_iter<const pair<const unsigned char *, unsigned int> *>>__vector_base<pair<const unsigned char *, unsigned int>, allocator<pair<const unsigned char *, unsigned int>>>__vector_base<pair<const unsigned char *, unsigned int>, allocator<pair<const unsigned char *, unsigned int>>> &const __vector_base<pair<const unsigned char *, unsigned int>, allocator<pair<const unsigned char *, unsigned int>>>const __vector_base<pair<const unsigned char *, unsigned int>, allocator<pair<const unsigned char *, unsigned int>>> &allocator_traits<allocator<TiffComponent *>>allocator_traits<allocator<TiffComponent *>> &const allocator_traits<allocator<TiffComponent *>>const allocator_traits<allocator<TiffComponent *>> &reverse_iterator<__wrap_iter<TiffComponent **>>reverse_iterator<__wrap_iter<TiffComponent *const *>>__vector_base<TiffComponent *, allocator<TiffComponent *>>__vector_base<TiffComponent *, allocator<TiffComponent *>> &const __vector_base<TiffComponent *, allocator<TiffComponent *>>const __vector_base<TiffComponent *, allocator<TiffComponent *>> &allocator_traits<allocator<unsigned int>>allocator_traits<allocator<unsigned int>> &const allocator_traits<allocator<unsigned int>>const allocator_traits<allocator<unsigned int>> &reverse_iterator<__wrap_iter<unsigned int *>>reverse_iterator<__wrap_iter<const unsigned int *>>__vector_base<unsigned int, allocator<unsigned int>>__vector_base<unsigned int, allocator<unsigned int>> &const __vector_base<unsigned int, allocator<unsigned int>>const __vector_base<unsigned int, allocator<unsigned int>> &unique_ptr<__tree_node<basic_string<char, char_traits<char>, allocator<char>>, void *>, __tree_node_destructor<allocator<__tree_node<basic_string<char, char_traits<char>, allocator<char>>, void *>>>>__tree<basic_string<char, char_traits<char>, allocator<char>>, less<basic_string<char, char_traits<char>, allocator<char>>>, allocator<basic_string<char, char_traits<char>, allocator<char>>>>reverse_iterator<__tree_const_iterator<basic_string<char, char_traits<char>, allocator<char>>, __tree_node<basic_string<char, char_traits<char>, allocator<char>>, void *> *, long>>__tree_node<basic_string<char, char_traits<char>, allocator<char>>, void *>allocator_traits<allocator<Iptcdatum>>allocator_traits<allocator<Iptcdatum>> &const allocator_traits<allocator<Iptcdatum>>const allocator_traits<allocator<Iptcdatum>> &reverse_iterator<__wrap_iter<Iptcdatum *>>reverse_iterator<__wrap_iter<const Iptcdatum *>>__vector_base<Iptcdatum, allocator<Iptcdatum>>__vector_base<Iptcdatum, allocator<Iptcdatum>> &const __vector_base<Iptcdatum, allocator<Iptcdatum>> &iterator_traits<const Iptcdatum *>iterator_traits<const Iptcdatum *> &const iterator_traits<const Iptcdatum *>const iterator_traits<const Iptcdatum *> &iterator_traits<Iptcdatum *>iterator_traits<Iptcdatum *> &const iterator_traits<Iptcdatum *>const iterator_traits<Iptcdatum *> &__wrap_iter<unsigned int *>__wrap_iter<TiffDirectory *const *>__wrap_iter<TiffDirectory **>__wrap_iter<TiffComponent *const *>__wrap_iter<TiffComponent **>__wrap_iter<const pair<const unsigned char *, unsigned int> *>__wrap_iter<pair<const unsigned char *, unsigned int> *>allocator<pair<const basic_string<char, char_traits<char>, allocator<char>>, XmpNsInfo>>allocator_traits<allocator<Xmpdatum>>allocator_traits<allocator<Xmpdatum>> &const allocator_traits<allocator<Xmpdatum>>const allocator_traits<allocator<Xmpdatum>> &reverse_iterator<__wrap_iter<const Xmpdatum *>>__vector_base<Xmpdatum, allocator<Xmpdatum>>__vector_base<Xmpdatum, allocator<Xmpdatum>> &const __vector_base<Xmpdatum, allocator<Xmpdatum>>const __vector_base<Xmpdatum, allocator<Xmpdatum>> &__value_type<int, basic_string<char, char_traits<char>, allocator<char>>>__map_value_compare<int, __value_type<int, basic_string<char, char_traits<char>, allocator<char>>>, less<int>, true>__map_value_compare<int, __value_type<int, basic_string<char, char_traits<char>, allocator<char>>>, less<int>, true> &const __map_value_compare<int, __value_type<int, basic_string<char, char_traits<char>, allocator<char>>>, less<int>, true>const __map_value_compare<int, __value_type<int, basic_string<char, char_traits<char>, allocator<char>>>, less<int>, true> &__rebind_alloc_helper<allocator_traits<allocator<pair<const int, basic_string<char, char_traits<char>, allocator<char>>>>>, __value_type<int, basic_string<char, char_traits<char>, allocator<char>>>>__rebind_alloc_helper<allocator_traits<allocator<pair<const int, basic_string<char, char_traits<char>, allocator<char>>>>>, __value_type<int, basic_string<char, char_traits<char>, allocator<char>>>> &const __rebind_alloc_helper<allocator_traits<allocator<pair<const int, basic_string<char, char_traits<char>, allocator<char>>>>>, __value_type<int, basic_string<char, char_traits<char>, allocator<char>>>>const __rebind_alloc_helper<allocator_traits<allocator<pair<const int, basic_string<char, char_traits<char>, allocator<char>>>>>, __value_type<int, basic_string<char, char_traits<char>, allocator<char>>>> &allocator_traits<allocator<__tree_node<__value_type<int, basic_string<char, char_traits<char>, allocator<char>>>, void *>>>allocator_traits<allocator<__tree_node<__value_type<int, basic_string<char, char_traits<char>, allocator<char>>>, void *>>> &const allocator_traits<allocator<__tree_node<__value_type<int, basic_string<char, char_traits<char>, allocator<char>>>, void *>>>const allocator_traits<allocator<__tree_node<__value_type<int, basic_string<char, char_traits<char>, allocator<char>>>, void *>>> &pair<const int, basic_string<char, char_traits<char>, allocator<char>>>allocator_traits<allocator<pair<const int, basic_string<char, char_traits<char>, allocator<char>>>>>allocator_traits<allocator<pair<const int, basic_string<char, char_traits<char>, allocator<char>>>>> &const allocator_traits<allocator<pair<const int, basic_string<char, char_traits<char>, allocator<char>>>>>const allocator_traits<allocator<pair<const int, basic_string<char, char_traits<char>, allocator<char>>>>> &__map_iterator<__tree_iterator<__value_type<int, basic_string<char, char_traits<char>, allocator<char>>>, __tree_node<__value_type<int, basic_string<char, char_traits<char>, allocator<char>>>, void *> *, long>>__map_const_iterator<__tree_const_iterator<__value_type<int, basic_string<char, char_traits<char>, allocator<char>>>, __tree_node<__value_type<int, basic_string<char, char_traits<char>, allocator<char>>>, void *> *, long>>reverse_iterator<__map_iterator<__tree_iterator<__value_type<int, basic_string<char, char_traits<char>, allocator<char>>>, __tree_node<__value_type<int, basic_string<char, char_traits<char>, allocator<char>>>, void *> *, long>>>reverse_iterator<__map_const_iterator<__tree_const_iterator<__value_type<int, basic_string<char, char_traits<char>, allocator<char>>>, __tree_node<__value_type<int, basic_string<char, char_traits<char>, allocator<char>>>, void *> *, long>>>__tree_node<__value_type<int, basic_string<char, char_traits<char>, allocator<char>>>, void *>__tree<__value_type<int, basic_string<char, char_traits<char>, allocator<char>>>, __map_value_compare<int, __value_type<int, basic_string<char, char_traits<char>, allocator<char>>>, less<int>, true>, allocator<__value_type<int, basic_string<char, char_traits<char>, allocator<char>>>>>__map_node_destructor<allocator<__tree_node<__value_type<int, basic_string<char, char_traits<char>, allocator<char>>>, void *>>>unique_ptr<__tree_node<__value_type<int, basic_string<char, char_traits<char>, allocator<char>>>, void *>, __map_node_destructor<allocator<__tree_node<__value_type<int, basic_string<char, char_traits<char>, allocator<char>>>, void *>>>>allocator_traits<allocator<NativePreview>>allocator_traits<allocator<NativePreview>> &const allocator_traits<allocator<NativePreview>>const allocator_traits<allocator<NativePreview>> &__wrap_iter<NativePreview *>__wrap_iter<const NativePreview *>reverse_iterator<__wrap_iter<NativePreview *>>reverse_iterator<__wrap_iter<const NativePreview *>>__vector_base<NativePreview, allocator<NativePreview>>__vector_base<NativePreview, allocator<NativePreview>> &const __vector_base<NativePreview, allocator<NativePreview>>const __vector_base<NativePreview, allocator<NativePreview>> &__value_type<OffsetId, OffsetData>__map_value_compare<OffsetId, __value_type<OffsetId, OffsetData>, less<OffsetId>, true>__map_value_compare<OffsetId, __value_type<OffsetId, OffsetData>, less<OffsetId>, true> &const __map_value_compare<OffsetId, __value_type<OffsetId, OffsetData>, less<OffsetId>, true>const __map_value_compare<OffsetId, __value_type<OffsetId, OffsetData>, less<OffsetId>, true> &__rebind_alloc_helper<allocator_traits<allocator<pair<const OffsetId, OffsetData>>>, __value_type<OffsetId, OffsetData>>__rebind_alloc_helper<allocator_traits<allocator<pair<const OffsetId, OffsetData>>>, __value_type<OffsetId, OffsetData>> &const __rebind_alloc_helper<allocator_traits<allocator<pair<const OffsetId, OffsetData>>>, __value_type<OffsetId, OffsetData>>const __rebind_alloc_helper<allocator_traits<allocator<pair<const OffsetId, OffsetData>>>, __value_type<OffsetId, OffsetData>> &allocator_traits<allocator<__tree_node<__value_type<OffsetId, OffsetData>, void *>>>allocator_traits<allocator<__tree_node<__value_type<OffsetId, OffsetData>, void *>>> &const allocator_traits<allocator<__tree_node<__value_type<OffsetId, OffsetData>, void *>>>const allocator_traits<allocator<__tree_node<__value_type<OffsetId, OffsetData>, void *>>> &pair<const OffsetId, OffsetData>const OffsetIdallocator_traits<allocator<pair<const OffsetId, OffsetData>>>allocator_traits<allocator<pair<const OffsetId, OffsetData>>> &const allocator_traits<allocator<pair<const OffsetId, OffsetData>>>const allocator_traits<allocator<pair<const OffsetId, OffsetData>>> &__map_iterator<__tree_iterator<__value_type<OffsetId, OffsetData>, __tree_node<__value_type<OffsetId, OffsetData>, void *> *, long>>__map_const_iterator<__tree_const_iterator<__value_type<OffsetId, OffsetData>, __tree_node<__value_type<OffsetId, OffsetData>, void *> *, long>>reverse_iterator<__map_iterator<__tree_iterator<__value_type<OffsetId, OffsetData>, __tree_node<__value_type<OffsetId, OffsetData>, void *> *, long>>>reverse_iterator<__map_const_iterator<__tree_const_iterator<__value_type<OffsetId, OffsetData>, __tree_node<__value_type<OffsetId, OffsetData>, void *> *, long>>>__tree_node<__value_type<OffsetId, OffsetData>, void *>__tree<__value_type<OffsetId, OffsetData>, __map_value_compare<OffsetId, __value_type<OffsetId, OffsetData>, less<OffsetId>, true>, allocator<__value_type<OffsetId, OffsetData>>>__map_node_destructor<allocator<__tree_node<__value_type<OffsetId, OffsetData>, void *>>>unique_ptr<__tree_node<__value_type<OffsetId, OffsetData>, void *>, __map_node_destructor<allocator<__tree_node<__value_type<OffsetId, OffsetData>, void *>>>>__vector_base<pair<const unsigned char *, unsigned int>, allocator<pair<const unsigned char *, unsigned int>>> *__vector_base<TiffComponent *, allocator<TiffComponent *>> *__vector_base<Xmpdatum, allocator<Xmpdatum>> *__compressed_pair<__tree_end_node<__tree_node_base<void *> *>, allocator<__tree_node<__value_type<OffsetId, OffsetData>, void *>>>__compressed_pair<__tree_end_node<__tree_node_base<void *> *>, allocator<__tree_node<__value_type<OffsetId, OffsetData>, void *>>> &const __compressed_pair<__tree_end_node<__tree_node_base<void *> *>, allocator<__tree_node<__value_type<OffsetId, OffsetData>, void *>>>const __compressed_pair<__tree_end_node<__tree_node_base<void *> *>, allocator<__tree_node<__value_type<OffsetId, OffsetData>, void *>>> &__compressed_pair<unsigned long, __map_value_compare<OffsetId, __value_type<OffsetId, OffsetData>, less<OffsetId>, true>>__compressed_pair<unsigned long, __map_value_compare<OffsetId, __value_type<OffsetId, OffsetData>, less<OffsetId>, true>> &const __compressed_pair<unsigned long, __map_value_compare<OffsetId, __value_type<OffsetId, OffsetData>, less<OffsetId>, true>>const __compressed_pair<unsigned long, __map_value_compare<OffsetId, __value_type<OffsetId, OffsetData>, less<OffsetId>, true>> &__make_tree_node_types<__value_type<OffsetId, OffsetData>, void *>__make_tree_node_types<__value_type<OffsetId, OffsetData>, void *> &const __make_tree_node_types<__value_type<OffsetId, OffsetData>, void *>const __make_tree_node_types<__value_type<OffsetId, OffsetData>, void *> &__tree_key_value_types<__value_type<OffsetId, OffsetData>>__tree_key_value_types<__value_type<OffsetId, OffsetData>> &const __tree_key_value_types<__value_type<OffsetId, OffsetData>>const __tree_key_value_types<__value_type<OffsetId, OffsetData>> &allocator_traits<allocator<__value_type<OffsetId, OffsetData>>>allocator_traits<allocator<__value_type<OffsetId, OffsetData>>> &const allocator_traits<allocator<__value_type<OffsetId, OffsetData>>>const allocator_traits<allocator<__value_type<OffsetId, OffsetData>>> &__tree_node_types<__tree_node<__value_type<OffsetId, OffsetData>, void *> *, __tree_node<__value_type<OffsetId, OffsetData>, void *>>__tree_node_types<__tree_node<__value_type<OffsetId, OffsetData>, void *> *, __tree_node<__value_type<OffsetId, OffsetData>, void *>> &const __tree_node_types<__tree_node<__value_type<OffsetId, OffsetData>, void *> *, __tree_node<__value_type<OffsetId, OffsetData>, void *>>const __tree_node_types<__tree_node<__value_type<OffsetId, OffsetData>, void *> *, __tree_node<__value_type<OffsetId, OffsetData>, void *>> &__rebind_alloc_helper<allocator_traits<allocator<__value_type<OffsetId, OffsetData>>>, __tree_node<__value_type<OffsetId, OffsetData>, void *>>__rebind_alloc_helper<allocator_traits<allocator<__value_type<OffsetId, OffsetData>>>, __tree_node<__value_type<OffsetId, OffsetData>, void *>> &const __rebind_alloc_helper<allocator_traits<allocator<__value_type<OffsetId, OffsetData>>>, __tree_node<__value_type<OffsetId, OffsetData>, void *>>const __rebind_alloc_helper<allocator_traits<allocator<__value_type<OffsetId, OffsetData>>>, __tree_node<__value_type<OffsetId, OffsetData>, void *>> &__rebind_alloc_helper<allocator_traits<allocator<__tree_node<__value_type<OffsetId, OffsetData>, void *>>>, __tree_node_base<void *>>__rebind_alloc_helper<allocator_traits<allocator<__tree_node<__value_type<OffsetId, OffsetData>, void *>>>, __tree_node_base<void *>> &const __rebind_alloc_helper<allocator_traits<allocator<__tree_node<__value_type<OffsetId, OffsetData>, void *>>>, __tree_node_base<void *>>const __rebind_alloc_helper<allocator_traits<allocator<__tree_node<__value_type<OffsetId, OffsetData>, void *>>>, __tree_node_base<void *>> &__tree_node_destructor<allocator<__tree_node<__value_type<OffsetId, OffsetData>, void *>>>unique_ptr<__tree_node<__value_type<OffsetId, OffsetData>, void *>, __tree_node_destructor<allocator<__tree_node<__value_type<OffsetId, OffsetData>, void *>>>>pair<__tree_iterator<__value_type<OffsetId, OffsetData>, __tree_node<__value_type<OffsetId, OffsetData>, void *> *, long>, bool>pair<__tree_iterator<__value_type<OffsetId, OffsetData>, __tree_node<__value_type<OffsetId, OffsetData>, void *> *, long>, __tree_iterator<__value_type<OffsetId, OffsetData>, __tree_node<__value_type<OffsetId, OffsetData>, void *> *, long>>pair<__tree_const_iterator<__value_type<OffsetId, OffsetData>, __tree_node<__value_type<OffsetId, OffsetData>, void *> *, long>, __tree_const_iterator<__value_type<OffsetId, OffsetData>, __tree_node<__value_type<OffsetId, OffsetData>, void *> *, long>>__tree_const_iterator<__value_type<OffsetId, OffsetData>, __tree_node<__value_type<OffsetId, OffsetData>, void *> *, long>__tree_iterator<__value_type<OffsetId, OffsetData>, __tree_node<__value_type<OffsetId, OffsetData>, void *> *, long>__pointer<pair<const OffsetId, OffsetData>, allocator<pair<const OffsetId, OffsetData>>, allocator<pair<const OffsetId, OffsetData>>, true>__pointer<pair<const OffsetId, OffsetData>, allocator<pair<const OffsetId, OffsetData>>, allocator<pair<const OffsetId, OffsetData>>, true> &const __pointer<pair<const OffsetId, OffsetData>, allocator<pair<const OffsetId, OffsetData>>, allocator<pair<const OffsetId, OffsetData>>, true>const __pointer<pair<const OffsetId, OffsetData>, allocator<pair<const OffsetId, OffsetData>>, allocator<pair<const OffsetId, OffsetData>>, true> &__const_pointer<pair<const OffsetId, OffsetData>, pair<const OffsetId, OffsetData> *, allocator<pair<const OffsetId, OffsetData>>, true>__const_pointer<pair<const OffsetId, OffsetData>, pair<const OffsetId, OffsetData> *, allocator<pair<const OffsetId, OffsetData>>, true> &const __const_pointer<pair<const OffsetId, OffsetData>, pair<const OffsetId, OffsetData> *, allocator<pair<const OffsetId, OffsetData>>, true>const __const_pointer<pair<const OffsetId, OffsetData>, pair<const OffsetId, OffsetData> *, allocator<pair<const OffsetId, OffsetData>>, true> &__void_pointer<pair<const OffsetId, OffsetData> *, allocator<pair<const OffsetId, OffsetData>>, false>__void_pointer<pair<const OffsetId, OffsetData> *, allocator<pair<const OffsetId, OffsetData>>, false> &const __void_pointer<pair<const OffsetId, OffsetData> *, allocator<pair<const OffsetId, OffsetData>>, false>const __void_pointer<pair<const OffsetId, OffsetData> *, allocator<pair<const OffsetId, OffsetData>>, false> &__const_void_pointer<pair<const OffsetId, OffsetData> *, allocator<pair<const OffsetId, OffsetData>>, false>__const_void_pointer<pair<const OffsetId, OffsetData> *, allocator<pair<const OffsetId, OffsetData>>, false> &const __const_void_pointer<pair<const OffsetId, OffsetData> *, allocator<pair<const OffsetId, OffsetData>>, false>const __const_void_pointer<pair<const OffsetId, OffsetData> *, allocator<pair<const OffsetId, OffsetData>>, false> &__alloc_traits_difference_type<allocator<pair<const OffsetId, OffsetData>>, pair<const OffsetId, OffsetData> *, true>__alloc_traits_difference_type<allocator<pair<const OffsetId, OffsetData>>, pair<const OffsetId, OffsetData> *, true> &const __alloc_traits_difference_type<allocator<pair<const OffsetId, OffsetData>>, pair<const OffsetId, OffsetData> *, true>const __alloc_traits_difference_type<allocator<pair<const OffsetId, OffsetData>>, pair<const OffsetId, OffsetData> *, true> &__size_type<allocator<pair<const OffsetId, OffsetData>>, long, true>__size_type<allocator<pair<const OffsetId, OffsetData>>, long, true> &const __size_type<allocator<pair<const OffsetId, OffsetData>>, long, true>const __size_type<allocator<pair<const OffsetId, OffsetData>>, long, true> &__propagate_on_container_move_assignment<allocator<pair<const OffsetId, OffsetData>>, true>__propagate_on_container_move_assignment<allocator<pair<const OffsetId, OffsetData>>, true> &const __propagate_on_container_move_assignment<allocator<pair<const OffsetId, OffsetData>>, true>const __propagate_on_container_move_assignment<allocator<pair<const OffsetId, OffsetData>>, true> &__is_always_equal<allocator<pair<const OffsetId, OffsetData>>, true>__is_always_equal<allocator<pair<const OffsetId, OffsetData>>, true> &const __is_always_equal<allocator<pair<const OffsetId, OffsetData>>, true>const __is_always_equal<allocator<pair<const OffsetId, OffsetData>>, true> &__pointer<__tree_node<__value_type<OffsetId, OffsetData>, void *>, allocator<__tree_node<__value_type<OffsetId, OffsetData>, void *>>, allocator<__tree_node<__value_type<OffsetId, OffsetData>, void *>>, true>__pointer<__tree_node<__value_type<OffsetId, OffsetData>, void *>, allocator<__tree_node<__value_type<OffsetId, OffsetData>, void *>>, allocator<__tree_node<__value_type<OffsetId, OffsetData>, void *>>, true> &const __pointer<__tree_node<__value_type<OffsetId, OffsetData>, void *>, allocator<__tree_node<__value_type<OffsetId, OffsetData>, void *>>, allocator<__tree_node<__value_type<OffsetId, OffsetData>, void *>>, true>const __pointer<__tree_node<__value_type<OffsetId, OffsetData>, void *>, allocator<__tree_node<__value_type<OffsetId, OffsetData>, void *>>, allocator<__tree_node<__value_type<OffsetId, OffsetData>, void *>>, true> &__const_pointer<__tree_node<__value_type<OffsetId, OffsetData>, void *>, __tree_node<__value_type<OffsetId, OffsetData>, void *> *, allocator<__tree_node<__value_type<OffsetId, OffsetData>, void *>>, true>__const_pointer<__tree_node<__value_type<OffsetId, OffsetData>, void *>, __tree_node<__value_type<OffsetId, OffsetData>, void *> *, allocator<__tree_node<__value_type<OffsetId, OffsetData>, void *>>, true> &const __const_pointer<__tree_node<__value_type<OffsetId, OffsetData>, void *>, __tree_node<__value_type<OffsetId, OffsetData>, void *> *, allocator<__tree_node<__value_type<OffsetId, OffsetData>, void *>>, true>const __const_pointer<__tree_node<__value_type<OffsetId, OffsetData>, void *>, __tree_node<__value_type<OffsetId, OffsetData>, void *> *, allocator<__tree_node<__value_type<OffsetId, OffsetData>, void *>>, true> &__void_pointer<__tree_node<__value_type<OffsetId, OffsetData>, void *> *, allocator<__tree_node<__value_type<OffsetId, OffsetData>, void *>>, false>__void_pointer<__tree_node<__value_type<OffsetId, OffsetData>, void *> *, allocator<__tree_node<__value_type<OffsetId, OffsetData>, void *>>, false> &const __void_pointer<__tree_node<__value_type<OffsetId, OffsetData>, void *> *, allocator<__tree_node<__value_type<OffsetId, OffsetData>, void *>>, false>const __void_pointer<__tree_node<__value_type<OffsetId, OffsetData>, void *> *, allocator<__tree_node<__value_type<OffsetId, OffsetData>, void *>>, false> &__const_void_pointer<__tree_node<__value_type<OffsetId, OffsetData>, void *> *, allocator<__tree_node<__value_type<OffsetId, OffsetData>, void *>>, false>__const_void_pointer<__tree_node<__value_type<OffsetId, OffsetData>, void *> *, allocator<__tree_node<__value_type<OffsetId, OffsetData>, void *>>, false> &const __const_void_pointer<__tree_node<__value_type<OffsetId, OffsetData>, void *> *, allocator<__tree_node<__value_type<OffsetId, OffsetData>, void *>>, false>const __const_void_pointer<__tree_node<__value_type<OffsetId, OffsetData>, void *> *, allocator<__tree_node<__value_type<OffsetId, OffsetData>, void *>>, false> &__alloc_traits_difference_type<allocator<__tree_node<__value_type<OffsetId, OffsetData>, void *>>, __tree_node<__value_type<OffsetId, OffsetData>, void *> *, true>__alloc_traits_difference_type<allocator<__tree_node<__value_type<OffsetId, OffsetData>, void *>>, __tree_node<__value_type<OffsetId, OffsetData>, void *> *, true> &const __alloc_traits_difference_type<allocator<__tree_node<__value_type<OffsetId, OffsetData>, void *>>, __tree_node<__value_type<OffsetId, OffsetData>, void *> *, true>const __alloc_traits_difference_type<allocator<__tree_node<__value_type<OffsetId, OffsetData>, void *>>, __tree_node<__value_type<OffsetId, OffsetData>, void *> *, true> &__size_type<allocator<__tree_node<__value_type<OffsetId, OffsetData>, void *>>, long, true>__size_type<allocator<__tree_node<__value_type<OffsetId, OffsetData>, void *>>, long, true> &const __size_type<allocator<__tree_node<__value_type<OffsetId, OffsetData>, void *>>, long, true>const __size_type<allocator<__tree_node<__value_type<OffsetId, OffsetData>, void *>>, long, true> &__propagate_on_container_move_assignment<allocator<__tree_node<__value_type<OffsetId, OffsetData>, void *>>, true>__propagate_on_container_move_assignment<allocator<__tree_node<__value_type<OffsetId, OffsetData>, void *>>, true> &const __propagate_on_container_move_assignment<allocator<__tree_node<__value_type<OffsetId, OffsetData>, void *>>, true>const __propagate_on_container_move_assignment<allocator<__tree_node<__value_type<OffsetId, OffsetData>, void *>>, true> &__is_always_equal<allocator<__tree_node<__value_type<OffsetId, OffsetData>, void *>>, true>__is_always_equal<allocator<__tree_node<__value_type<OffsetId, OffsetData>, void *>>, true> &const __is_always_equal<allocator<__tree_node<__value_type<OffsetId, OffsetData>, void *>>, true>const __is_always_equal<allocator<__tree_node<__value_type<OffsetId, OffsetData>, void *>>, true> &rebind_alloc<__value_type<OffsetId, OffsetData>>rebind_alloc<__value_type<OffsetId, OffsetData>> &const rebind_alloc<__value_type<OffsetId, OffsetData>>const rebind_alloc<__value_type<OffsetId, OffsetData>> &__compressed_pair<NativePreview *, allocator<NativePreview>>__compressed_pair<NativePreview *, allocator<NativePreview>> &const __compressed_pair<NativePreview *, allocator<NativePreview>>const __compressed_pair<NativePreview *, allocator<NativePreview>> &__pointer<NativePreview, allocator<NativePreview>, allocator<NativePreview>, true>__pointer<NativePreview, allocator<NativePreview>, allocator<NativePreview>, true> &const __pointer<NativePreview, allocator<NativePreview>, allocator<NativePreview>, true>const __pointer<NativePreview, allocator<NativePreview>, allocator<NativePreview>, true> &__const_pointer<NativePreview, NativePreview *, allocator<NativePreview>, true>__const_pointer<NativePreview, NativePreview *, allocator<NativePreview>, true> &const __const_pointer<NativePreview, NativePreview *, allocator<NativePreview>, true>const __const_pointer<NativePreview, NativePreview *, allocator<NativePreview>, true> &__void_pointer<NativePreview *, allocator<NativePreview>, false>__void_pointer<NativePreview *, allocator<NativePreview>, false> &const __void_pointer<NativePreview *, allocator<NativePreview>, false>const __void_pointer<NativePreview *, allocator<NativePreview>, false> &__const_void_pointer<NativePreview *, allocator<NativePreview>, false>__const_void_pointer<NativePreview *, allocator<NativePreview>, false> &const __const_void_pointer<NativePreview *, allocator<NativePreview>, false>const __const_void_pointer<NativePreview *, allocator<NativePreview>, false> &__alloc_traits_difference_type<allocator<NativePreview>, NativePreview *, true>__alloc_traits_difference_type<allocator<NativePreview>, NativePreview *, true> &const __alloc_traits_difference_type<allocator<NativePreview>, NativePreview *, true>const __alloc_traits_difference_type<allocator<NativePreview>, NativePreview *, true> &__size_type<allocator<NativePreview>, long, true>__size_type<allocator<NativePreview>, long, true> &const __size_type<allocator<NativePreview>, long, true>const __size_type<allocator<NativePreview>, long, true> &__propagate_on_container_move_assignment<allocator<NativePreview>, true>__propagate_on_container_move_assignment<allocator<NativePreview>, true> &const __propagate_on_container_move_assignment<allocator<NativePreview>, true>const __propagate_on_container_move_assignment<allocator<NativePreview>, true> &__is_always_equal<allocator<NativePreview>, true>__is_always_equal<allocator<NativePreview>, true> &const __is_always_equal<allocator<NativePreview>, true>const __is_always_equal<allocator<NativePreview>, true> &__compressed_pair<__tree_end_node<__tree_node_base<void *> *>, allocator<__tree_node<__value_type<int, basic_string<char, char_traits<char>, allocator<char>>>, void *>>>__compressed_pair<__tree_end_node<__tree_node_base<void *> *>, allocator<__tree_node<__value_type<int, basic_string<char, char_traits<char>, allocator<char>>>, void *>>> &const __compressed_pair<__tree_end_node<__tree_node_base<void *> *>, allocator<__tree_node<__value_type<int, basic_string<char, char_traits<char>, allocator<char>>>, void *>>>const __compressed_pair<__tree_end_node<__tree_node_base<void *> *>, allocator<__tree_node<__value_type<int, basic_string<char, char_traits<char>, allocator<char>>>, void *>>> &__compressed_pair<unsigned long, __map_value_compare<int, __value_type<int, basic_string<char, char_traits<char>, allocator<char>>>, less<int>, true>>__compressed_pair<unsigned long, __map_value_compare<int, __value_type<int, basic_string<char, char_traits<char>, allocator<char>>>, less<int>, true>> &const __compressed_pair<unsigned long, __map_value_compare<int, __value_type<int, basic_string<char, char_traits<char>, allocator<char>>>, less<int>, true>>const __compressed_pair<unsigned long, __map_value_compare<int, __value_type<int, basic_string<char, char_traits<char>, allocator<char>>>, less<int>, true>> &__make_tree_node_types<__value_type<int, basic_string<char, char_traits<char>, allocator<char>>>, void *>__make_tree_node_types<__value_type<int, basic_string<char, char_traits<char>, allocator<char>>>, void *> &const __make_tree_node_types<__value_type<int, basic_string<char, char_traits<char>, allocator<char>>>, void *>const __make_tree_node_types<__value_type<int, basic_string<char, char_traits<char>, allocator<char>>>, void *> &__tree_key_value_types<__value_type<int, basic_string<char, char_traits<char>, allocator<char>>>>__tree_key_value_types<__value_type<int, basic_string<char, char_traits<char>, allocator<char>>>> &const __tree_key_value_types<__value_type<int, basic_string<char, char_traits<char>, allocator<char>>>>const __tree_key_value_types<__value_type<int, basic_string<char, char_traits<char>, allocator<char>>>> &allocator_traits<allocator<__value_type<int, basic_string<char, char_traits<char>, allocator<char>>>>>allocator_traits<allocator<__value_type<int, basic_string<char, char_traits<char>, allocator<char>>>>> &const allocator_traits<allocator<__value_type<int, basic_string<char, char_traits<char>, allocator<char>>>>>const allocator_traits<allocator<__value_type<int, basic_string<char, char_traits<char>, allocator<char>>>>> &__tree_node_types<__tree_node<__value_type<int, basic_string<char, char_traits<char>, allocator<char>>>, void *> *, __tree_node<__value_type<int, basic_string<char, char_traits<char>, allocator<char>>>, void *>>__tree_node_types<__tree_node<__value_type<int, basic_string<char, char_traits<char>, allocator<char>>>, void *> *, __tree_node<__value_type<int, basic_string<char, char_traits<char>, allocator<char>>>, void *>> &const __tree_node_types<__tree_node<__value_type<int, basic_string<char, char_traits<char>, allocator<char>>>, void *> *, __tree_node<__value_type<int, basic_string<char, char_traits<char>, allocator<char>>>, void *>>const __tree_node_types<__tree_node<__value_type<int, basic_string<char, char_traits<char>, allocator<char>>>, void *> *, __tree_node<__value_type<int, basic_string<char, char_traits<char>, allocator<char>>>, void *>> &__rebind_alloc_helper<allocator_traits<allocator<__value_type<int, basic_string<char, char_traits<char>, allocator<char>>>>>, __tree_node<__value_type<int, basic_string<char, char_traits<char>, allocator<char>>>, void *>>__rebind_alloc_helper<allocator_traits<allocator<__value_type<int, basic_string<char, char_traits<char>, allocator<char>>>>>, __tree_node<__value_type<int, basic_string<char, char_traits<char>, allocator<char>>>, void *>> &const __rebind_alloc_helper<allocator_traits<allocator<__value_type<int, basic_string<char, char_traits<char>, allocator<char>>>>>, __tree_node<__value_type<int, basic_string<char, char_traits<char>, allocator<char>>>, void *>>const __rebind_alloc_helper<allocator_traits<allocator<__value_type<int, basic_string<char, char_traits<char>, allocator<char>>>>>, __tree_node<__value_type<int, basic_string<char, char_traits<char>, allocator<char>>>, void *>> &__rebind_alloc_helper<allocator_traits<allocator<__tree_node<__value_type<int, basic_string<char, char_traits<char>, allocator<char>>>, void *>>>, __tree_node_base<void *>>__rebind_alloc_helper<allocator_traits<allocator<__tree_node<__value_type<int, basic_string<char, char_traits<char>, allocator<char>>>, void *>>>, __tree_node_base<void *>> &const __rebind_alloc_helper<allocator_traits<allocator<__tree_node<__value_type<int, basic_string<char, char_traits<char>, allocator<char>>>, void *>>>, __tree_node_base<void *>>const __rebind_alloc_helper<allocator_traits<allocator<__tree_node<__value_type<int, basic_string<char, char_traits<char>, allocator<char>>>, void *>>>, __tree_node_base<void *>> &__tree_node_destructor<allocator<__tree_node<__value_type<int, basic_string<char, char_traits<char>, allocator<char>>>, void *>>>unique_ptr<__tree_node<__value_type<int, basic_string<char, char_traits<char>, allocator<char>>>, void *>, __tree_node_destructor<allocator<__tree_node<__value_type<int, basic_string<char, char_traits<char>, allocator<char>>>, void *>>>>pair<__tree_iterator<__value_type<int, basic_string<char, char_traits<char>, allocator<char>>>, __tree_node<__value_type<int, basic_string<char, char_traits<char>, allocator<char>>>, void *> *, long>, bool>pair<__tree_iterator<__value_type<int, basic_string<char, char_traits<char>, allocator<char>>>, __tree_node<__value_type<int, basic_string<char, char_traits<char>, allocator<char>>>, void *> *, long>, __tree_iterator<__value_type<int, basic_string<char, char_traits<char>, allocator<char>>>, __tree_node<__value_type<int, basic_string<char, char_traits<char>, allocator<char>>>, void *> *, long>>pair<__tree_const_iterator<__value_type<int, basic_string<char, char_traits<char>, allocator<char>>>, __tree_node<__value_type<int, basic_string<char, char_traits<char>, allocator<char>>>, void *> *, long>, __tree_const_iterator<__value_type<int, basic_string<char, char_traits<char>, allocator<char>>>, __tree_node<__value_type<int, basic_string<char, char_traits<char>, allocator<char>>>, void *> *, long>>__tree_const_iterator<__value_type<int, basic_string<char, char_traits<char>, allocator<char>>>, __tree_node<__value_type<int, basic_string<char, char_traits<char>, allocator<char>>>, void *> *, long>__tree_iterator<__value_type<int, basic_string<char, char_traits<char>, allocator<char>>>, __tree_node<__value_type<int, basic_string<char, char_traits<char>, allocator<char>>>, void *> *, long>__pointer<pair<const int, basic_string<char, char_traits<char>, allocator<char>>>, allocator<pair<const int, basic_string<char, char_traits<char>, allocator<char>>>>, allocator<pair<const int, basic_string<char, char_traits<char>, allocator<char>>>>, true>__pointer<pair<const int, basic_string<char, char_traits<char>, allocator<char>>>, allocator<pair<const int, basic_string<char, char_traits<char>, allocator<char>>>>, allocator<pair<const int, basic_string<char, char_traits<char>, allocator<char>>>>, true> &const __pointer<pair<const int, basic_string<char, char_traits<char>, allocator<char>>>, allocator<pair<const int, basic_string<char, char_traits<char>, allocator<char>>>>, allocator<pair<const int, basic_string<char, char_traits<char>, allocator<char>>>>, true>const __pointer<pair<const int, basic_string<char, char_traits<char>, allocator<char>>>, allocator<pair<const int, basic_string<char, char_traits<char>, allocator<char>>>>, allocator<pair<const int, basic_string<char, char_traits<char>, allocator<char>>>>, true> &__const_pointer<pair<const int, basic_string<char, char_traits<char>, allocator<char>>>, pair<const int, basic_string<char, char_traits<char>, allocator<char>>> *, allocator<pair<const int, basic_string<char, char_traits<char>, allocator<char>>>>, true>__const_pointer<pair<const int, basic_string<char, char_traits<char>, allocator<char>>>, pair<const int, basic_string<char, char_traits<char>, allocator<char>>> *, allocator<pair<const int, basic_string<char, char_traits<char>, allocator<char>>>>, true> &const __const_pointer<pair<const int, basic_string<char, char_traits<char>, allocator<char>>>, pair<const int, basic_string<char, char_traits<char>, allocator<char>>> *, allocator<pair<const int, basic_string<char, char_traits<char>, allocator<char>>>>, true>const __const_pointer<pair<const int, basic_string<char, char_traits<char>, allocator<char>>>, pair<const int, basic_string<char, char_traits<char>, allocator<char>>> *, allocator<pair<const int, basic_string<char, char_traits<char>, allocator<char>>>>, true> &__void_pointer<pair<const int, basic_string<char, char_traits<char>, allocator<char>>> *, allocator<pair<const int, basic_string<char, char_traits<char>, allocator<char>>>>, false>__void_pointer<pair<const int, basic_string<char, char_traits<char>, allocator<char>>> *, allocator<pair<const int, basic_string<char, char_traits<char>, allocator<char>>>>, false> &const __void_pointer<pair<const int, basic_string<char, char_traits<char>, allocator<char>>> *, allocator<pair<const int, basic_string<char, char_traits<char>, allocator<char>>>>, false>const __void_pointer<pair<const int, basic_string<char, char_traits<char>, allocator<char>>> *, allocator<pair<const int, basic_string<char, char_traits<char>, allocator<char>>>>, false> &__const_void_pointer<pair<const int, basic_string<char, char_traits<char>, allocator<char>>> *, allocator<pair<const int, basic_string<char, char_traits<char>, allocator<char>>>>, false>__const_void_pointer<pair<const int, basic_string<char, char_traits<char>, allocator<char>>> *, allocator<pair<const int, basic_string<char, char_traits<char>, allocator<char>>>>, false> &const __const_void_pointer<pair<const int, basic_string<char, char_traits<char>, allocator<char>>> *, allocator<pair<const int, basic_string<char, char_traits<char>, allocator<char>>>>, false>const __const_void_pointer<pair<const int, basic_string<char, char_traits<char>, allocator<char>>> *, allocator<pair<const int, basic_string<char, char_traits<char>, allocator<char>>>>, false> &__alloc_traits_difference_type<allocator<pair<const int, basic_string<char, char_traits<char>, allocator<char>>>>, pair<const int, basic_string<char, char_traits<char>, allocator<char>>> *, true>__alloc_traits_difference_type<allocator<pair<const int, basic_string<char, char_traits<char>, allocator<char>>>>, pair<const int, basic_string<char, char_traits<char>, allocator<char>>> *, true> &const __alloc_traits_difference_type<allocator<pair<const int, basic_string<char, char_traits<char>, allocator<char>>>>, pair<const int, basic_string<char, char_traits<char>, allocator<char>>> *, true>const __alloc_traits_difference_type<allocator<pair<const int, basic_string<char, char_traits<char>, allocator<char>>>>, pair<const int, basic_string<char, char_traits<char>, allocator<char>>> *, true> &__size_type<allocator<pair<const int, basic_string<char, char_traits<char>, allocator<char>>>>, long, true>__size_type<allocator<pair<const int, basic_string<char, char_traits<char>, allocator<char>>>>, long, true> &const __size_type<allocator<pair<const int, basic_string<char, char_traits<char>, allocator<char>>>>, long, true>const __size_type<allocator<pair<const int, basic_string<char, char_traits<char>, allocator<char>>>>, long, true> &__propagate_on_container_move_assignment<allocator<pair<const int, basic_string<char, char_traits<char>, allocator<char>>>>, true>__propagate_on_container_move_assignment<allocator<pair<const int, basic_string<char, char_traits<char>, allocator<char>>>>, true> &const __propagate_on_container_move_assignment<allocator<pair<const int, basic_string<char, char_traits<char>, allocator<char>>>>, true>const __propagate_on_container_move_assignment<allocator<pair<const int, basic_string<char, char_traits<char>, allocator<char>>>>, true> &__is_always_equal<allocator<pair<const int, basic_string<char, char_traits<char>, allocator<char>>>>, true>__is_always_equal<allocator<pair<const int, basic_string<char, char_traits<char>, allocator<char>>>>, true> &const __is_always_equal<allocator<pair<const int, basic_string<char, char_traits<char>, allocator<char>>>>, true>const __is_always_equal<allocator<pair<const int, basic_string<char, char_traits<char>, allocator<char>>>>, true> &__pointer<__tree_node<__value_type<int, basic_string<char, char_traits<char>, allocator<char>>>, void *>, allocator<__tree_node<__value_type<int, basic_string<char, char_traits<char>, allocator<char>>>, void *>>, allocator<__tree_node<__value_type<int, basic_string<char, char_traits<char>, allocator<char>>>, void *>>, true>__pointer<__tree_node<__value_type<int, basic_string<char, char_traits<char>, allocator<char>>>, void *>, allocator<__tree_node<__value_type<int, basic_string<char, char_traits<char>, allocator<char>>>, void *>>, allocator<__tree_node<__value_type<int, basic_string<char, char_traits<char>, allocator<char>>>, void *>>, true> &const __pointer<__tree_node<__value_type<int, basic_string<char, char_traits<char>, allocator<char>>>, void *>, allocator<__tree_node<__value_type<int, basic_string<char, char_traits<char>, allocator<char>>>, void *>>, allocator<__tree_node<__value_type<int, basic_string<char, char_traits<char>, allocator<char>>>, void *>>, true>const __pointer<__tree_node<__value_type<int, basic_string<char, char_traits<char>, allocator<char>>>, void *>, allocator<__tree_node<__value_type<int, basic_string<char, char_traits<char>, allocator<char>>>, void *>>, allocator<__tree_node<__value_type<int, basic_string<char, char_traits<char>, allocator<char>>>, void *>>, true> &__const_pointer<__tree_node<__value_type<int, basic_string<char, char_traits<char>, allocator<char>>>, void *>, __tree_node<__value_type<int, basic_string<char, char_traits<char>, allocator<char>>>, void *> *, allocator<__tree_node<__value_type<int, basic_string<char, char_traits<char>, allocator<char>>>, void *>>, true>__const_pointer<__tree_node<__value_type<int, basic_string<char, char_traits<char>, allocator<char>>>, void *>, __tree_node<__value_type<int, basic_string<char, char_traits<char>, allocator<char>>>, void *> *, allocator<__tree_node<__value_type<int, basic_string<char, char_traits<char>, allocator<char>>>, void *>>, true> &const __const_pointer<__tree_node<__value_type<int, basic_string<char, char_traits<char>, allocator<char>>>, void *>, __tree_node<__value_type<int, basic_string<char, char_traits<char>, allocator<char>>>, void *> *, allocator<__tree_node<__value_type<int, basic_string<char, char_traits<char>, allocator<char>>>, void *>>, true>const __const_pointer<__tree_node<__value_type<int, basic_string<char, char_traits<char>, allocator<char>>>, void *>, __tree_node<__value_type<int, basic_string<char, char_traits<char>, allocator<char>>>, void *> *, allocator<__tree_node<__value_type<int, basic_string<char, char_traits<char>, allocator<char>>>, void *>>, true> &__void_pointer<__tree_node<__value_type<int, basic_string<char, char_traits<char>, allocator<char>>>, void *> *, allocator<__tree_node<__value_type<int, basic_string<char, char_traits<char>, allocator<char>>>, void *>>, false>__void_pointer<__tree_node<__value_type<int, basic_string<char, char_traits<char>, allocator<char>>>, void *> *, allocator<__tree_node<__value_type<int, basic_string<char, char_traits<char>, allocator<char>>>, void *>>, false> &const __void_pointer<__tree_node<__value_type<int, basic_string<char, char_traits<char>, allocator<char>>>, void *> *, allocator<__tree_node<__value_type<int, basic_string<char, char_traits<char>, allocator<char>>>, void *>>, false>const __void_pointer<__tree_node<__value_type<int, basic_string<char, char_traits<char>, allocator<char>>>, void *> *, allocator<__tree_node<__value_type<int, basic_string<char, char_traits<char>, allocator<char>>>, void *>>, false> &__const_void_pointer<__tree_node<__value_type<int, basic_string<char, char_traits<char>, allocator<char>>>, void *> *, allocator<__tree_node<__value_type<int, basic_string<char, char_traits<char>, allocator<char>>>, void *>>, false>__const_void_pointer<__tree_node<__value_type<int, basic_string<char, char_traits<char>, allocator<char>>>, void *> *, allocator<__tree_node<__value_type<int, basic_string<char, char_traits<char>, allocator<char>>>, void *>>, false> &const __const_void_pointer<__tree_node<__value_type<int, basic_string<char, char_traits<char>, allocator<char>>>, void *> *, allocator<__tree_node<__value_type<int, basic_string<char, char_traits<char>, allocator<char>>>, void *>>, false>const __const_void_pointer<__tree_node<__value_type<int, basic_string<char, char_traits<char>, allocator<char>>>, void *> *, allocator<__tree_node<__value_type<int, basic_string<char, char_traits<char>, allocator<char>>>, void *>>, false> &__alloc_traits_difference_type<allocator<__tree_node<__value_type<int, basic_string<char, char_traits<char>, allocator<char>>>, void *>>, __tree_node<__value_type<int, basic_string<char, char_traits<char>, allocator<char>>>, void *> *, true>__alloc_traits_difference_type<allocator<__tree_node<__value_type<int, basic_string<char, char_traits<char>, allocator<char>>>, void *>>, __tree_node<__value_type<int, basic_string<char, char_traits<char>, allocator<char>>>, void *> *, true> &const __alloc_traits_difference_type<allocator<__tree_node<__value_type<int, basic_string<char, char_traits<char>, allocator<char>>>, void *>>, __tree_node<__value_type<int, basic_string<char, char_traits<char>, allocator<char>>>, void *> *, true>const __alloc_traits_difference_type<allocator<__tree_node<__value_type<int, basic_string<char, char_traits<char>, allocator<char>>>, void *>>, __tree_node<__value_type<int, basic_string<char, char_traits<char>, allocator<char>>>, void *> *, true> &__size_type<allocator<__tree_node<__value_type<int, basic_string<char, char_traits<char>, allocator<char>>>, void *>>, long, true>__size_type<allocator<__tree_node<__value_type<int, basic_string<char, char_traits<char>, allocator<char>>>, void *>>, long, true> &const __size_type<allocator<__tree_node<__value_type<int, basic_string<char, char_traits<char>, allocator<char>>>, void *>>, long, true>const __size_type<allocator<__tree_node<__value_type<int, basic_string<char, char_traits<char>, allocator<char>>>, void *>>, long, true> &__propagate_on_container_move_assignment<allocator<__tree_node<__value_type<int, basic_string<char, char_traits<char>, allocator<char>>>, void *>>, true>__propagate_on_container_move_assignment<allocator<__tree_node<__value_type<int, basic_string<char, char_traits<char>, allocator<char>>>, void *>>, true> &const __propagate_on_container_move_assignment<allocator<__tree_node<__value_type<int, basic_string<char, char_traits<char>, allocator<char>>>, void *>>, true>const __propagate_on_container_move_assignment<allocator<__tree_node<__value_type<int, basic_string<char, char_traits<char>, allocator<char>>>, void *>>, true> &__is_always_equal<allocator<__tree_node<__value_type<int, basic_string<char, char_traits<char>, allocator<char>>>, void *>>, true>__is_always_equal<allocator<__tree_node<__value_type<int, basic_string<char, char_traits<char>, allocator<char>>>, void *>>, true> &const __is_always_equal<allocator<__tree_node<__value_type<int, basic_string<char, char_traits<char>, allocator<char>>>, void *>>, true>const __is_always_equal<allocator<__tree_node<__value_type<int, basic_string<char, char_traits<char>, allocator<char>>>, void *>>, true> &rebind_alloc<__value_type<int, basic_string<char, char_traits<char>, allocator<char>>>>rebind_alloc<__value_type<int, basic_string<char, char_traits<char>, allocator<char>>>> &const rebind_alloc<__value_type<int, basic_string<char, char_traits<char>, allocator<char>>>>const rebind_alloc<__value_type<int, basic_string<char, char_traits<char>, allocator<char>>>> &__compressed_pair<Xmpdatum *, allocator<Xmpdatum>>__compressed_pair<Xmpdatum *, allocator<Xmpdatum>> &const __compressed_pair<Xmpdatum *, allocator<Xmpdatum>>const __compressed_pair<Xmpdatum *, allocator<Xmpdatum>> &__size_type<allocator<Xmpdatum>, long, true>__size_type<allocator<Xmpdatum>, long, true> &const __size_type<allocator<Xmpdatum>, long, true>const __size_type<allocator<Xmpdatum>, long, true> &__const_void_pointer<Xmpdatum *, allocator<Xmpdatum>, false>__const_void_pointer<Xmpdatum *, allocator<Xmpdatum>, false> &const __const_void_pointer<Xmpdatum *, allocator<Xmpdatum>, false>const __const_void_pointer<Xmpdatum *, allocator<Xmpdatum>, false> &__pointer<Xmpdatum, allocator<Xmpdatum>, allocator<Xmpdatum>, true>__pointer<Xmpdatum, allocator<Xmpdatum>, allocator<Xmpdatum>, true> &const __pointer<Xmpdatum, allocator<Xmpdatum>, allocator<Xmpdatum>, true>const __pointer<Xmpdatum, allocator<Xmpdatum>, allocator<Xmpdatum>, true> &__const_pointer<Xmpdatum, Xmpdatum *, allocator<Xmpdatum>, true>__const_pointer<Xmpdatum, Xmpdatum *, allocator<Xmpdatum>, true> &const __const_pointer<Xmpdatum, Xmpdatum *, allocator<Xmpdatum>, true>const __const_pointer<Xmpdatum, Xmpdatum *, allocator<Xmpdatum>, true> &__void_pointer<Xmpdatum *, allocator<Xmpdatum>, false>__void_pointer<Xmpdatum *, allocator<Xmpdatum>, false> &const __void_pointer<Xmpdatum *, allocator<Xmpdatum>, false>const __void_pointer<Xmpdatum *, allocator<Xmpdatum>, false> &__alloc_traits_difference_type<allocator<Xmpdatum>, Xmpdatum *, true>__alloc_traits_difference_type<allocator<Xmpdatum>, Xmpdatum *, true> &const __alloc_traits_difference_type<allocator<Xmpdatum>, Xmpdatum *, true>const __alloc_traits_difference_type<allocator<Xmpdatum>, Xmpdatum *, true> &__propagate_on_container_move_assignment<allocator<Xmpdatum>, true>__propagate_on_container_move_assignment<allocator<Xmpdatum>, true> &const __propagate_on_container_move_assignment<allocator<Xmpdatum>, true>const __propagate_on_container_move_assignment<allocator<Xmpdatum>, true> &__is_always_equal<allocator<Xmpdatum>, true>__is_always_equal<allocator<Xmpdatum>, true> &const __is_always_equal<allocator<Xmpdatum>, true>const __is_always_equal<allocator<Xmpdatum>, true> &pair<const basic_string<char, char_traits<char>, allocator<char>>, XmpNsInfo>remove_cv<Iptcdatum>remove_cv<Iptcdatum> &const remove_cv<Iptcdatum>const remove_cv<Iptcdatum> &remove_cv<const Iptcdatum>remove_cv<const Iptcdatum> &const remove_cv<const Iptcdatum>const remove_cv<const Iptcdatum> &__compressed_pair<Iptcdatum *, allocator<Iptcdatum>>__compressed_pair<Iptcdatum *, allocator<Iptcdatum>> &const __compressed_pair<Iptcdatum *, allocator<Iptcdatum>>const __compressed_pair<Iptcdatum *, allocator<Iptcdatum>> &__size_type<allocator<Iptcdatum>, long, true>__size_type<allocator<Iptcdatum>, long, true> &const __size_type<allocator<Iptcdatum>, long, true>const __size_type<allocator<Iptcdatum>, long, true> &__const_void_pointer<Iptcdatum *, allocator<Iptcdatum>, false>__const_void_pointer<Iptcdatum *, allocator<Iptcdatum>, false> &const __const_void_pointer<Iptcdatum *, allocator<Iptcdatum>, false>const __const_void_pointer<Iptcdatum *, allocator<Iptcdatum>, false> &__pointer<Iptcdatum, allocator<Iptcdatum>, allocator<Iptcdatum>, true>__pointer<Iptcdatum, allocator<Iptcdatum>, allocator<Iptcdatum>, true> &const __pointer<Iptcdatum, allocator<Iptcdatum>, allocator<Iptcdatum>, true>const __pointer<Iptcdatum, allocator<Iptcdatum>, allocator<Iptcdatum>, true> &__const_pointer<Iptcdatum, Iptcdatum *, allocator<Iptcdatum>, true>__const_pointer<Iptcdatum, Iptcdatum *, allocator<Iptcdatum>, true> &const __const_pointer<Iptcdatum, Iptcdatum *, allocator<Iptcdatum>, true>const __const_pointer<Iptcdatum, Iptcdatum *, allocator<Iptcdatum>, true> &__void_pointer<Iptcdatum *, allocator<Iptcdatum>, false>__void_pointer<Iptcdatum *, allocator<Iptcdatum>, false> &const __void_pointer<Iptcdatum *, allocator<Iptcdatum>, false>const __void_pointer<Iptcdatum *, allocator<Iptcdatum>, false> &__alloc_traits_difference_type<allocator<Iptcdatum>, Iptcdatum *, true>__alloc_traits_difference_type<allocator<Iptcdatum>, Iptcdatum *, true> &const __alloc_traits_difference_type<allocator<Iptcdatum>, Iptcdatum *, true>const __alloc_traits_difference_type<allocator<Iptcdatum>, Iptcdatum *, true> &__propagate_on_container_move_assignment<allocator<Iptcdatum>, true>__propagate_on_container_move_assignment<allocator<Iptcdatum>, true> &const __propagate_on_container_move_assignment<allocator<Iptcdatum>, true>const __propagate_on_container_move_assignment<allocator<Iptcdatum>, true> &__is_always_equal<allocator<Iptcdatum>, true>__is_always_equal<allocator<Iptcdatum>, true> &const __is_always_equal<allocator<Iptcdatum>, true>const __is_always_equal<allocator<Iptcdatum>, true> &__compressed_pair<__tree_end_node<__tree_node_base<void *> *>, allocator<__tree_node<basic_string<char, char_traits<char>, allocator<char>>, void *>>>__compressed_pair<__tree_end_node<__tree_node_base<void *> *>, allocator<__tree_node<basic_string<char, char_traits<char>, allocator<char>>, void *>>> &const __compressed_pair<__tree_end_node<__tree_node_base<void *> *>, allocator<__tree_node<basic_string<char, char_traits<char>, allocator<char>>, void *>>>const __compressed_pair<__tree_end_node<__tree_node_base<void *> *>, allocator<__tree_node<basic_string<char, char_traits<char>, allocator<char>>, void *>>> &__compressed_pair<unsigned long, less<basic_string<char, char_traits<char>, allocator<char>>>>__compressed_pair<unsigned long, less<basic_string<char, char_traits<char>, allocator<char>>>> &const __compressed_pair<unsigned long, less<basic_string<char, char_traits<char>, allocator<char>>>>const __compressed_pair<unsigned long, less<basic_string<char, char_traits<char>, allocator<char>>>> &__tree_key_value_types<basic_string<char, char_traits<char>, allocator<char>>>__tree_key_value_types<basic_string<char, char_traits<char>, allocator<char>>> &const __tree_key_value_types<basic_string<char, char_traits<char>, allocator<char>>>const __tree_key_value_types<basic_string<char, char_traits<char>, allocator<char>>> &__tree_iterator<basic_string<char, char_traits<char>, allocator<char>>, __tree_node<basic_string<char, char_traits<char>, allocator<char>>, void *> *, long>__make_tree_node_types<basic_string<char, char_traits<char>, allocator<char>>, void *>__make_tree_node_types<basic_string<char, char_traits<char>, allocator<char>>, void *> &const __make_tree_node_types<basic_string<char, char_traits<char>, allocator<char>>, void *>const __make_tree_node_types<basic_string<char, char_traits<char>, allocator<char>>, void *> &__tree_node_types<__tree_node<basic_string<char, char_traits<char>, allocator<char>>, void *> *, __tree_node<basic_string<char, char_traits<char>, allocator<char>>, void *>>__tree_node_types<__tree_node<basic_string<char, char_traits<char>, allocator<char>>, void *> *, __tree_node<basic_string<char, char_traits<char>, allocator<char>>, void *>> &const __tree_node_types<__tree_node<basic_string<char, char_traits<char>, allocator<char>>, void *> *, __tree_node<basic_string<char, char_traits<char>, allocator<char>>, void *>>const __tree_node_types<__tree_node<basic_string<char, char_traits<char>, allocator<char>>, void *> *, __tree_node<basic_string<char, char_traits<char>, allocator<char>>, void *>> &__rebind_alloc_helper<allocator_traits<allocator<basic_string<char, char_traits<char>, allocator<char>>>>, __tree_node<basic_string<char, char_traits<char>, allocator<char>>, void *>>__rebind_alloc_helper<allocator_traits<allocator<basic_string<char, char_traits<char>, allocator<char>>>>, __tree_node<basic_string<char, char_traits<char>, allocator<char>>, void *>> &const __rebind_alloc_helper<allocator_traits<allocator<basic_string<char, char_traits<char>, allocator<char>>>>, __tree_node<basic_string<char, char_traits<char>, allocator<char>>, void *>>const __rebind_alloc_helper<allocator_traits<allocator<basic_string<char, char_traits<char>, allocator<char>>>>, __tree_node<basic_string<char, char_traits<char>, allocator<char>>, void *>> &allocator_traits<allocator<__tree_node<basic_string<char, char_traits<char>, allocator<char>>, void *>>>allocator_traits<allocator<__tree_node<basic_string<char, char_traits<char>, allocator<char>>, void *>>> &const allocator_traits<allocator<__tree_node<basic_string<char, char_traits<char>, allocator<char>>, void *>>>const allocator_traits<allocator<__tree_node<basic_string<char, char_traits<char>, allocator<char>>, void *>>> &__rebind_alloc_helper<allocator_traits<allocator<__tree_node<basic_string<char, char_traits<char>, allocator<char>>, void *>>>, __tree_node_base<void *>>__rebind_alloc_helper<allocator_traits<allocator<__tree_node<basic_string<char, char_traits<char>, allocator<char>>, void *>>>, __tree_node_base<void *>> &const __rebind_alloc_helper<allocator_traits<allocator<__tree_node<basic_string<char, char_traits<char>, allocator<char>>, void *>>>, __tree_node_base<void *>>const __rebind_alloc_helper<allocator_traits<allocator<__tree_node<basic_string<char, char_traits<char>, allocator<char>>, void *>>>, __tree_node_base<void *>> &pair<__tree_iterator<basic_string<char, char_traits<char>, allocator<char>>, __tree_node<basic_string<char, char_traits<char>, allocator<char>>, void *> *, long>, bool>pair<__tree_iterator<basic_string<char, char_traits<char>, allocator<char>>, __tree_node<basic_string<char, char_traits<char>, allocator<char>>, void *> *, long>, __tree_iterator<basic_string<char, char_traits<char>, allocator<char>>, __tree_node<basic_string<char, char_traits<char>, allocator<char>>, void *> *, long>>pair<__tree_const_iterator<basic_string<char, char_traits<char>, allocator<char>>, __tree_node<basic_string<char, char_traits<char>, allocator<char>>, void *> *, long>, __tree_const_iterator<basic_string<char, char_traits<char>, allocator<char>>, __tree_node<basic_string<char, char_traits<char>, allocator<char>>, void *> *, long>>__tree_node_destructor<allocator<__tree_node<basic_string<char, char_traits<char>, allocator<char>>, void *>>>rebind_alloc<__tree_node<basic_string<char, char_traits<char>, allocator<char>>, void *>>rebind_alloc<__tree_node<basic_string<char, char_traits<char>, allocator<char>>, void *>> &const rebind_alloc<__tree_node<basic_string<char, char_traits<char>, allocator<char>>, void *>>const rebind_alloc<__tree_node<basic_string<char, char_traits<char>, allocator<char>>, void *>> &__compressed_pair<unsigned int *, allocator<unsigned int>>__compressed_pair<unsigned int *, allocator<unsigned int>> &const __compressed_pair<unsigned int *, allocator<unsigned int>>const __compressed_pair<unsigned int *, allocator<unsigned int>> &__size_type<allocator<unsigned int>, long, true>__size_type<allocator<unsigned int>, long, true> &const __size_type<allocator<unsigned int>, long, true>const __size_type<allocator<unsigned int>, long, true> &__const_void_pointer<unsigned int *, allocator<unsigned int>, false>__const_void_pointer<unsigned int *, allocator<unsigned int>, false> &const __const_void_pointer<unsigned int *, allocator<unsigned int>, false>const __const_void_pointer<unsigned int *, allocator<unsigned int>, false> &__pointer<unsigned int, allocator<unsigned int>, allocator<unsigned int>, true>__pointer<unsigned int, allocator<unsigned int>, allocator<unsigned int>, true> &const __pointer<unsigned int, allocator<unsigned int>, allocator<unsigned int>, true>const __pointer<unsigned int, allocator<unsigned int>, allocator<unsigned int>, true> &__const_pointer<unsigned int, unsigned int *, allocator<unsigned int>, true>__const_pointer<unsigned int, unsigned int *, allocator<unsigned int>, true> &const __const_pointer<unsigned int, unsigned int *, allocator<unsigned int>, true>const __const_pointer<unsigned int, unsigned int *, allocator<unsigned int>, true> &__void_pointer<unsigned int *, allocator<unsigned int>, false>__void_pointer<unsigned int *, allocator<unsigned int>, false> &const __void_pointer<unsigned int *, allocator<unsigned int>, false>const __void_pointer<unsigned int *, allocator<unsigned int>, false> &__alloc_traits_difference_type<allocator<unsigned int>, unsigned int *, true>__alloc_traits_difference_type<allocator<unsigned int>, unsigned int *, true> &const __alloc_traits_difference_type<allocator<unsigned int>, unsigned int *, true>const __alloc_traits_difference_type<allocator<unsigned int>, unsigned int *, true> &__propagate_on_container_move_assignment<allocator<unsigned int>, true>__propagate_on_container_move_assignment<allocator<unsigned int>, true> &const __propagate_on_container_move_assignment<allocator<unsigned int>, true>const __propagate_on_container_move_assignment<allocator<unsigned int>, true> &__is_always_equal<allocator<unsigned int>, true>__is_always_equal<allocator<unsigned int>, true> &const __is_always_equal<allocator<unsigned int>, true>const __is_always_equal<allocator<unsigned int>, true> &__compressed_pair<TiffComponent **, allocator<TiffComponent *>>__compressed_pair<TiffComponent **, allocator<TiffComponent *>> &const __compressed_pair<TiffComponent **, allocator<TiffComponent *>>const __compressed_pair<TiffComponent **, allocator<TiffComponent *>> &__size_type<allocator<TiffComponent *>, long, true>__size_type<allocator<TiffComponent *>, long, true> &const __size_type<allocator<TiffComponent *>, long, true>const __size_type<allocator<TiffComponent *>, long, true> &__const_void_pointer<TiffComponent **, allocator<TiffComponent *>, false>__const_void_pointer<TiffComponent **, allocator<TiffComponent *>, false> &const __const_void_pointer<TiffComponent **, allocator<TiffComponent *>, false>const __const_void_pointer<TiffComponent **, allocator<TiffComponent *>, false> &__pointer<TiffComponent *, allocator<TiffComponent *>, allocator<TiffComponent *>, true>__pointer<TiffComponent *, allocator<TiffComponent *>, allocator<TiffComponent *>, true> &const __pointer<TiffComponent *, allocator<TiffComponent *>, allocator<TiffComponent *>, true>const __pointer<TiffComponent *, allocator<TiffComponent *>, allocator<TiffComponent *>, true> &__const_pointer<TiffComponent *, TiffComponent **, allocator<TiffComponent *>, true>__const_pointer<TiffComponent *, TiffComponent **, allocator<TiffComponent *>, true> &const __const_pointer<TiffComponent *, TiffComponent **, allocator<TiffComponent *>, true>const __const_pointer<TiffComponent *, TiffComponent **, allocator<TiffComponent *>, true> &__void_pointer<TiffComponent **, allocator<TiffComponent *>, false>__void_pointer<TiffComponent **, allocator<TiffComponent *>, false> &const __void_pointer<TiffComponent **, allocator<TiffComponent *>, false>const __void_pointer<TiffComponent **, allocator<TiffComponent *>, false> &__alloc_traits_difference_type<allocator<TiffComponent *>, TiffComponent **, true>__alloc_traits_difference_type<allocator<TiffComponent *>, TiffComponent **, true> &const __alloc_traits_difference_type<allocator<TiffComponent *>, TiffComponent **, true>const __alloc_traits_difference_type<allocator<TiffComponent *>, TiffComponent **, true> &__propagate_on_container_move_assignment<allocator<TiffComponent *>, true>__propagate_on_container_move_assignment<allocator<TiffComponent *>, true> &const __propagate_on_container_move_assignment<allocator<TiffComponent *>, true>const __propagate_on_container_move_assignment<allocator<TiffComponent *>, true> &__is_always_equal<allocator<TiffComponent *>, true>__is_always_equal<allocator<TiffComponent *>, true> &const __is_always_equal<allocator<TiffComponent *>, true>const __is_always_equal<allocator<TiffComponent *>, true> &__compressed_pair<pair<const unsigned char *, unsigned int> *, allocator<pair<const unsigned char *, unsigned int>>>__compressed_pair<pair<const unsigned char *, unsigned int> *, allocator<pair<const unsigned char *, unsigned int>>> &const __compressed_pair<pair<const unsigned char *, unsigned int> *, allocator<pair<const unsigned char *, unsigned int>>>const __compressed_pair<pair<const unsigned char *, unsigned int> *, allocator<pair<const unsigned char *, unsigned int>>> &__size_type<allocator<pair<const unsigned char *, unsigned int>>, long, true>__size_type<allocator<pair<const unsigned char *, unsigned int>>, long, true> &const __size_type<allocator<pair<const unsigned char *, unsigned int>>, long, true>const __size_type<allocator<pair<const unsigned char *, unsigned int>>, long, true> &__const_void_pointer<pair<const unsigned char *, unsigned int> *, allocator<pair<const unsigned char *, unsigned int>>, false>__const_void_pointer<pair<const unsigned char *, unsigned int> *, allocator<pair<const unsigned char *, unsigned int>>, false> &const __const_void_pointer<pair<const unsigned char *, unsigned int> *, allocator<pair<const unsigned char *, unsigned int>>, false>const __const_void_pointer<pair<const unsigned char *, unsigned int> *, allocator<pair<const unsigned char *, unsigned int>>, false> &__pointer<pair<const unsigned char *, unsigned int>, allocator<pair<const unsigned char *, unsigned int>>, allocator<pair<const unsigned char *, unsigned int>>, true>__pointer<pair<const unsigned char *, unsigned int>, allocator<pair<const unsigned char *, unsigned int>>, allocator<pair<const unsigned char *, unsigned int>>, true> &const __pointer<pair<const unsigned char *, unsigned int>, allocator<pair<const unsigned char *, unsigned int>>, allocator<pair<const unsigned char *, unsigned int>>, true>const __pointer<pair<const unsigned char *, unsigned int>, allocator<pair<const unsigned char *, unsigned int>>, allocator<pair<const unsigned char *, unsigned int>>, true> &__const_pointer<pair<const unsigned char *, unsigned int>, pair<const unsigned char *, unsigned int> *, allocator<pair<const unsigned char *, unsigned int>>, true>__const_pointer<pair<const unsigned char *, unsigned int>, pair<const unsigned char *, unsigned int> *, allocator<pair<const unsigned char *, unsigned int>>, true> &const __const_pointer<pair<const unsigned char *, unsigned int>, pair<const unsigned char *, unsigned int> *, allocator<pair<const unsigned char *, unsigned int>>, true>const __const_pointer<pair<const unsigned char *, unsigned int>, pair<const unsigned char *, unsigned int> *, allocator<pair<const unsigned char *, unsigned int>>, true> &__void_pointer<pair<const unsigned char *, unsigned int> *, allocator<pair<const unsigned char *, unsigned int>>, false>__void_pointer<pair<const unsigned char *, unsigned int> *, allocator<pair<const unsigned char *, unsigned int>>, false> &const __void_pointer<pair<const unsigned char *, unsigned int> *, allocator<pair<const unsigned char *, unsigned int>>, false>const __void_pointer<pair<const unsigned char *, unsigned int> *, allocator<pair<const unsigned char *, unsigned int>>, false> &__alloc_traits_difference_type<allocator<pair<const unsigned char *, unsigned int>>, pair<const unsigned char *, unsigned int> *, true>__alloc_traits_difference_type<allocator<pair<const unsigned char *, unsigned int>>, pair<const unsigned char *, unsigned int> *, true> &const __alloc_traits_difference_type<allocator<pair<const unsigned char *, unsigned int>>, pair<const unsigned char *, unsigned int> *, true>const __alloc_traits_difference_type<allocator<pair<const unsigned char *, unsigned int>>, pair<const unsigned char *, unsigned int> *, true> &__propagate_on_container_move_assignment<allocator<pair<const unsigned char *, unsigned int>>, true>__propagate_on_container_move_assignment<allocator<pair<const unsigned char *, unsigned int>>, true> &const __propagate_on_container_move_assignment<allocator<pair<const unsigned char *, unsigned int>>, true>const __propagate_on_container_move_assignment<allocator<pair<const unsigned char *, unsigned int>>, true> &__is_always_equal<allocator<pair<const unsigned char *, unsigned int>>, true>__is_always_equal<allocator<pair<const unsigned char *, unsigned int>>, true> &const __is_always_equal<allocator<pair<const unsigned char *, unsigned int>>, true>const __is_always_equal<allocator<pair<const unsigned char *, unsigned int>>, true> &__compressed_pair<TiffDirectory **, allocator<TiffDirectory *>>__compressed_pair<TiffDirectory **, allocator<TiffDirectory *>> &const __compressed_pair<TiffDirectory **, allocator<TiffDirectory *>>const __compressed_pair<TiffDirectory **, allocator<TiffDirectory *>> &__size_type<allocator<TiffDirectory *>, long, true>__size_type<allocator<TiffDirectory *>, long, true> &const __size_type<allocator<TiffDirectory *>, long, true>const __size_type<allocator<TiffDirectory *>, long, true> &__const_void_pointer<TiffDirectory **, allocator<TiffDirectory *>, false>__const_void_pointer<TiffDirectory **, allocator<TiffDirectory *>, false> &const __const_void_pointer<TiffDirectory **, allocator<TiffDirectory *>, false>const __const_void_pointer<TiffDirectory **, allocator<TiffDirectory *>, false> &__pointer<TiffDirectory *, allocator<TiffDirectory *>, allocator<TiffDirectory *>, true>__pointer<TiffDirectory *, allocator<TiffDirectory *>, allocator<TiffDirectory *>, true> &const __pointer<TiffDirectory *, allocator<TiffDirectory *>, allocator<TiffDirectory *>, true>const __pointer<TiffDirectory *, allocator<TiffDirectory *>, allocator<TiffDirectory *>, true> &__const_pointer<TiffDirectory *, TiffDirectory **, allocator<TiffDirectory *>, true>__const_pointer<TiffDirectory *, TiffDirectory **, allocator<TiffDirectory *>, true> &const __const_pointer<TiffDirectory *, TiffDirectory **, allocator<TiffDirectory *>, true>const __const_pointer<TiffDirectory *, TiffDirectory **, allocator<TiffDirectory *>, true> &__void_pointer<TiffDirectory **, allocator<TiffDirectory *>, false>__void_pointer<TiffDirectory **, allocator<TiffDirectory *>, false> &const __void_pointer<TiffDirectory **, allocator<TiffDirectory *>, false>const __void_pointer<TiffDirectory **, allocator<TiffDirectory *>, false> &__alloc_traits_difference_type<allocator<TiffDirectory *>, TiffDirectory **, true>__alloc_traits_difference_type<allocator<TiffDirectory *>, TiffDirectory **, true> &const __alloc_traits_difference_type<allocator<TiffDirectory *>, TiffDirectory **, true>const __alloc_traits_difference_type<allocator<TiffDirectory *>, TiffDirectory **, true> &__propagate_on_container_move_assignment<allocator<TiffDirectory *>, true>__propagate_on_container_move_assignment<allocator<TiffDirectory *>, true> &const __propagate_on_container_move_assignment<allocator<TiffDirectory *>, true>const __propagate_on_container_move_assignment<allocator<TiffDirectory *>, true> &__is_always_equal<allocator<TiffDirectory *>, true>__is_always_equal<allocator<TiffDirectory *>, true> &const __is_always_equal<allocator<TiffDirectory *>, true>const __is_always_equal<allocator<TiffDirectory *>, true> &__compressed_pair_elem<allocator<TiffDirectory *>, 1, true>__compressed_pair_elem<allocator<TiffDirectory *>, 1, true> &const __compressed_pair_elem<allocator<TiffDirectory *>, 1, true>const __compressed_pair_elem<allocator<TiffDirectory *>, 1, true> &__compressed_pair_elem<TiffDirectory **, 0, false>__compressed_pair_elem<TiffDirectory **, 0, false> &const __compressed_pair_elem<TiffDirectory **, 0, false>const __compressed_pair_elem<TiffDirectory **, 0, false> &TiffDirectory **constTiffDirectory **const &TiffDirectory **&__compressed_pair_elem<allocator<pair<const unsigned char *, unsigned int>>, 1, true>__compressed_pair_elem<allocator<pair<const unsigned char *, unsigned int>>, 1, true> &const __compressed_pair_elem<allocator<pair<const unsigned char *, unsigned int>>, 1, true>const __compressed_pair_elem<allocator<pair<const unsigned char *, unsigned int>>, 1, true> &__compressed_pair_elem<pair<const unsigned char *, unsigned int> *, 0, false>__compressed_pair_elem<pair<const unsigned char *, unsigned int> *, 0, false> &const __compressed_pair_elem<pair<const unsigned char *, unsigned int> *, 0, false>const __compressed_pair_elem<pair<const unsigned char *, unsigned int> *, 0, false> &pair<const unsigned char *, unsigned int> *constpair<const unsigned char *, unsigned int> *const &pair<const unsigned char *, unsigned int> *&__compressed_pair_elem<allocator<TiffComponent *>, 1, true>__compressed_pair_elem<allocator<TiffComponent *>, 1, true> &const __compressed_pair_elem<allocator<TiffComponent *>, 1, true>const __compressed_pair_elem<allocator<TiffComponent *>, 1, true> &__compressed_pair_elem<TiffComponent **, 0, false>__compressed_pair_elem<TiffComponent **, 0, false> &const __compressed_pair_elem<TiffComponent **, 0, false>const __compressed_pair_elem<TiffComponent **, 0, false> &TiffComponent **constTiffComponent **const &TiffComponent **&__compressed_pair_elem<allocator<unsigned int>, 1, true>__compressed_pair_elem<allocator<unsigned int>, 1, true> &const __compressed_pair_elem<allocator<unsigned int>, 1, true>const __compressed_pair_elem<allocator<unsigned int>, 1, true> &__compressed_pair_elem<unsigned int *, 0, false>__compressed_pair_elem<unsigned int *, 0, false> &const __compressed_pair_elem<unsigned int *, 0, false>const __compressed_pair_elem<unsigned int *, 0, false> &unsigned int *constunsigned int *const &__size_type<allocator<__tree_node<basic_string<char, char_traits<char>, allocator<char>>, void *>>, long, true>__size_type<allocator<__tree_node<basic_string<char, char_traits<char>, allocator<char>>, void *>>, long, true> &const __size_type<allocator<__tree_node<basic_string<char, char_traits<char>, allocator<char>>, void *>>, long, true>const __size_type<allocator<__tree_node<basic_string<char, char_traits<char>, allocator<char>>, void *>>, long, true> &__const_void_pointer<__tree_node<basic_string<char, char_traits<char>, allocator<char>>, void *> *, allocator<__tree_node<basic_string<char, char_traits<char>, allocator<char>>, void *>>, false>__const_void_pointer<__tree_node<basic_string<char, char_traits<char>, allocator<char>>, void *> *, allocator<__tree_node<basic_string<char, char_traits<char>, allocator<char>>, void *>>, false> &const __const_void_pointer<__tree_node<basic_string<char, char_traits<char>, allocator<char>>, void *> *, allocator<__tree_node<basic_string<char, char_traits<char>, allocator<char>>, void *>>, false>const __const_void_pointer<__tree_node<basic_string<char, char_traits<char>, allocator<char>>, void *> *, allocator<__tree_node<basic_string<char, char_traits<char>, allocator<char>>, void *>>, false> &__pointer<__tree_node<basic_string<char, char_traits<char>, allocator<char>>, void *>, allocator<__tree_node<basic_string<char, char_traits<char>, allocator<char>>, void *>>, allocator<__tree_node<basic_string<char, char_traits<char>, allocator<char>>, void *>>, true>__pointer<__tree_node<basic_string<char, char_traits<char>, allocator<char>>, void *>, allocator<__tree_node<basic_string<char, char_traits<char>, allocator<char>>, void *>>, allocator<__tree_node<basic_string<char, char_traits<char>, allocator<char>>, void *>>, true> &const __pointer<__tree_node<basic_string<char, char_traits<char>, allocator<char>>, void *>, allocator<__tree_node<basic_string<char, char_traits<char>, allocator<char>>, void *>>, allocator<__tree_node<basic_string<char, char_traits<char>, allocator<char>>, void *>>, true>const __pointer<__tree_node<basic_string<char, char_traits<char>, allocator<char>>, void *>, allocator<__tree_node<basic_string<char, char_traits<char>, allocator<char>>, void *>>, allocator<__tree_node<basic_string<char, char_traits<char>, allocator<char>>, void *>>, true> &__const_pointer<__tree_node<basic_string<char, char_traits<char>, allocator<char>>, void *>, __tree_node<basic_string<char, char_traits<char>, allocator<char>>, void *> *, allocator<__tree_node<basic_string<char, char_traits<char>, allocator<char>>, void *>>, true>__const_pointer<__tree_node<basic_string<char, char_traits<char>, allocator<char>>, void *>, __tree_node<basic_string<char, char_traits<char>, allocator<char>>, void *> *, allocator<__tree_node<basic_string<char, char_traits<char>, allocator<char>>, void *>>, true> &const __const_pointer<__tree_node<basic_string<char, char_traits<char>, allocator<char>>, void *>, __tree_node<basic_string<char, char_traits<char>, allocator<char>>, void *> *, allocator<__tree_node<basic_string<char, char_traits<char>, allocator<char>>, void *>>, true>const __const_pointer<__tree_node<basic_string<char, char_traits<char>, allocator<char>>, void *>, __tree_node<basic_string<char, char_traits<char>, allocator<char>>, void *> *, allocator<__tree_node<basic_string<char, char_traits<char>, allocator<char>>, void *>>, true> &__void_pointer<__tree_node<basic_string<char, char_traits<char>, allocator<char>>, void *> *, allocator<__tree_node<basic_string<char, char_traits<char>, allocator<char>>, void *>>, false>__void_pointer<__tree_node<basic_string<char, char_traits<char>, allocator<char>>, void *> *, allocator<__tree_node<basic_string<char, char_traits<char>, allocator<char>>, void *>>, false> &const __void_pointer<__tree_node<basic_string<char, char_traits<char>, allocator<char>>, void *> *, allocator<__tree_node<basic_string<char, char_traits<char>, allocator<char>>, void *>>, false>const __void_pointer<__tree_node<basic_string<char, char_traits<char>, allocator<char>>, void *> *, allocator<__tree_node<basic_string<char, char_traits<char>, allocator<char>>, void *>>, false> &__alloc_traits_difference_type<allocator<__tree_node<basic_string<char, char_traits<char>, allocator<char>>, void *>>, __tree_node<basic_string<char, char_traits<char>, allocator<char>>, void *> *, true>__alloc_traits_difference_type<allocator<__tree_node<basic_string<char, char_traits<char>, allocator<char>>, void *>>, __tree_node<basic_string<char, char_traits<char>, allocator<char>>, void *> *, true> &const __alloc_traits_difference_type<allocator<__tree_node<basic_string<char, char_traits<char>, allocator<char>>, void *>>, __tree_node<basic_string<char, char_traits<char>, allocator<char>>, void *> *, true>const __alloc_traits_difference_type<allocator<__tree_node<basic_string<char, char_traits<char>, allocator<char>>, void *>>, __tree_node<basic_string<char, char_traits<char>, allocator<char>>, void *> *, true> &__propagate_on_container_move_assignment<allocator<__tree_node<basic_string<char, char_traits<char>, allocator<char>>, void *>>, true>__propagate_on_container_move_assignment<allocator<__tree_node<basic_string<char, char_traits<char>, allocator<char>>, void *>>, true> &const __propagate_on_container_move_assignment<allocator<__tree_node<basic_string<char, char_traits<char>, allocator<char>>, void *>>, true>const __propagate_on_container_move_assignment<allocator<__tree_node<basic_string<char, char_traits<char>, allocator<char>>, void *>>, true> &__is_always_equal<allocator<__tree_node<basic_string<char, char_traits<char>, allocator<char>>, void *>>, true>__is_always_equal<allocator<__tree_node<basic_string<char, char_traits<char>, allocator<char>>, void *>>, true> &const __is_always_equal<allocator<__tree_node<basic_string<char, char_traits<char>, allocator<char>>, void *>>, true>const __is_always_equal<allocator<__tree_node<basic_string<char, char_traits<char>, allocator<char>>, void *>>, true> &pointer_traits<__tree_node<basic_string<char, char_traits<char>, allocator<char>>, void *> *>pointer_traits<__tree_node<basic_string<char, char_traits<char>, allocator<char>>, void *> *> &const pointer_traits<__tree_node<basic_string<char, char_traits<char>, allocator<char>>, void *> *>const pointer_traits<__tree_node<basic_string<char, char_traits<char>, allocator<char>>, void *> *> &__rebind_pointer<void *, basic_string<char, char_traits<char>, allocator<char>>>__rebind_pointer<void *, basic_string<char, char_traits<char>, allocator<char>>> &const __rebind_pointer<void *, basic_string<char, char_traits<char>, allocator<char>>>const __rebind_pointer<void *, basic_string<char, char_traits<char>, allocator<char>>> &__rebind_pointer<void *, const basic_string<char, char_traits<char>, allocator<char>>>__rebind_pointer<void *, const basic_string<char, char_traits<char>, allocator<char>>> &const __rebind_pointer<void *, const basic_string<char, char_traits<char>, allocator<char>>>const __rebind_pointer<void *, const basic_string<char, char_traits<char>, allocator<char>>> &conditional<true, __tree_end_node<__tree_node_base<void *> *> *, __tree_node<basic_string<char, char_traits<char>, allocator<char>>, void *> *>conditional<true, __tree_end_node<__tree_node_base<void *> *> *, __tree_node<basic_string<char, char_traits<char>, allocator<char>>, void *> *> &const conditional<true, __tree_end_node<__tree_node_base<void *> *> *, __tree_node<basic_string<char, char_traits<char>, allocator<char>>, void *> *>const conditional<true, __tree_end_node<__tree_node_base<void *> *> *, __tree_node<basic_string<char, char_traits<char>, allocator<char>>, void *> *> &__tree_map_pointer_types<basic_string<char, char_traits<char>, allocator<char>>, void *, __tree_key_value_types<basic_string<char, char_traits<char>, allocator<char>>>, false>__tree_map_pointer_types<basic_string<char, char_traits<char>, allocator<char>>, void *, __tree_key_value_types<basic_string<char, char_traits<char>, allocator<char>>>, false> &const __tree_map_pointer_types<basic_string<char, char_traits<char>, allocator<char>>, void *, __tree_key_value_types<basic_string<char, char_traits<char>, allocator<char>>>, false>const __tree_map_pointer_types<basic_string<char, char_traits<char>, allocator<char>>, void *, __tree_key_value_types<basic_string<char, char_traits<char>, allocator<char>>>, false> &__rebind_pointer<void *, __tree_node<basic_string<char, char_traits<char>, allocator<char>>, void *>>__rebind_pointer<void *, __tree_node<basic_string<char, char_traits<char>, allocator<char>>, void *>> &const __rebind_pointer<void *, __tree_node<basic_string<char, char_traits<char>, allocator<char>>, void *>>const __rebind_pointer<void *, __tree_node<basic_string<char, char_traits<char>, allocator<char>>, void *>> &__compressed_pair_elem<less<basic_string<char, char_traits<char>, allocator<char>>>, 1, true>__compressed_pair_elem<less<basic_string<char, char_traits<char>, allocator<char>>>, 1, true> &const __compressed_pair_elem<less<basic_string<char, char_traits<char>, allocator<char>>>, 1, true>const __compressed_pair_elem<less<basic_string<char, char_traits<char>, allocator<char>>>, 1, true> &const less<basic_string<char, char_traits<char>, allocator<char>>> &__compressed_pair_elem<allocator<__tree_node<basic_string<char, char_traits<char>, allocator<char>>, void *>>, 1, true>__compressed_pair_elem<allocator<__tree_node<basic_string<char, char_traits<char>, allocator<char>>, void *>>, 1, true> &const __compressed_pair_elem<allocator<__tree_node<basic_string<char, char_traits<char>, allocator<char>>, void *>>, 1, true>const __compressed_pair_elem<allocator<__tree_node<basic_string<char, char_traits<char>, allocator<char>>, void *>>, 1, true> &__compressed_pair_elem<allocator<Iptcdatum>, 1, true>__compressed_pair_elem<allocator<Iptcdatum>, 1, true> &const __compressed_pair_elem<allocator<Iptcdatum>, 1, true>const __compressed_pair_elem<allocator<Iptcdatum>, 1, true> &__compressed_pair_elem<Iptcdatum *, 0, false>__compressed_pair_elem<Iptcdatum *, 0, false> &const __compressed_pair_elem<Iptcdatum *, 0, false>const __compressed_pair_elem<Iptcdatum *, 0, false> &Iptcdatum *constIptcdatum *const &Iptcdatum *&remove_volatile<Iptcdatum>remove_volatile<Iptcdatum> &const remove_volatile<Iptcdatum>const remove_volatile<Iptcdatum> &__compressed_pair_elem<allocator<Xmpdatum>, 1, true>__compressed_pair_elem<allocator<Xmpdatum>, 1, true> &const __compressed_pair_elem<allocator<Xmpdatum>, 1, true>const __compressed_pair_elem<allocator<Xmpdatum>, 1, true> &__compressed_pair_elem<Xmpdatum *, 0, false>__compressed_pair_elem<Xmpdatum *, 0, false> &const __compressed_pair_elem<Xmpdatum *, 0, false>const __compressed_pair_elem<Xmpdatum *, 0, false> &Xmpdatum *constXmpdatum *const &Xmpdatum *&conditional<true, __tree_end_node<__tree_node_base<void *> *> *, __tree_node<__value_type<int, basic_string<char, char_traits<char>, allocator<char>>>, void *> *>conditional<true, __tree_end_node<__tree_node_base<void *> *> *, __tree_node<__value_type<int, basic_string<char, char_traits<char>, allocator<char>>>, void *> *> &const conditional<true, __tree_end_node<__tree_node_base<void *> *> *, __tree_node<__value_type<int, basic_string<char, char_traits<char>, allocator<char>>>, void *> *>const conditional<true, __tree_end_node<__tree_node_base<void *> *> *, __tree_node<__value_type<int, basic_string<char, char_traits<char>, allocator<char>>>, void *> *> &pointer_traits<__tree_node<__value_type<int, basic_string<char, char_traits<char>, allocator<char>>>, void *> *>pointer_traits<__tree_node<__value_type<int, basic_string<char, char_traits<char>, allocator<char>>>, void *> *> &const pointer_traits<__tree_node<__value_type<int, basic_string<char, char_traits<char>, allocator<char>>>, void *> *>const pointer_traits<__tree_node<__value_type<int, basic_string<char, char_traits<char>, allocator<char>>>, void *> *> &__rebind_pointer<void *, __value_type<int, basic_string<char, char_traits<char>, allocator<char>>>>__rebind_pointer<void *, __value_type<int, basic_string<char, char_traits<char>, allocator<char>>>> &const __rebind_pointer<void *, __value_type<int, basic_string<char, char_traits<char>, allocator<char>>>>const __rebind_pointer<void *, __value_type<int, basic_string<char, char_traits<char>, allocator<char>>>> &__rebind_pointer<void *, const __value_type<int, basic_string<char, char_traits<char>, allocator<char>>>>__rebind_pointer<void *, const __value_type<int, basic_string<char, char_traits<char>, allocator<char>>>> &const __rebind_pointer<void *, const __value_type<int, basic_string<char, char_traits<char>, allocator<char>>>>const __rebind_pointer<void *, const __value_type<int, basic_string<char, char_traits<char>, allocator<char>>>> &__tree_map_pointer_types<__value_type<int, basic_string<char, char_traits<char>, allocator<char>>>, void *, __tree_key_value_types<__value_type<int, basic_string<char, char_traits<char>, allocator<char>>>>, true>__tree_map_pointer_types<__value_type<int, basic_string<char, char_traits<char>, allocator<char>>>, void *, __tree_key_value_types<__value_type<int, basic_string<char, char_traits<char>, allocator<char>>>>, true> &const __tree_map_pointer_types<__value_type<int, basic_string<char, char_traits<char>, allocator<char>>>, void *, __tree_key_value_types<__value_type<int, basic_string<char, char_traits<char>, allocator<char>>>>, true>const __tree_map_pointer_types<__value_type<int, basic_string<char, char_traits<char>, allocator<char>>>, void *, __tree_key_value_types<__value_type<int, basic_string<char, char_traits<char>, allocator<char>>>>, true> &__pointer<__value_type<int, basic_string<char, char_traits<char>, allocator<char>>>, allocator<__value_type<int, basic_string<char, char_traits<char>, allocator<char>>>>, allocator<__value_type<int, basic_string<char, char_traits<char>, allocator<char>>>>, true>__pointer<__value_type<int, basic_string<char, char_traits<char>, allocator<char>>>, allocator<__value_type<int, basic_string<char, char_traits<char>, allocator<char>>>>, allocator<__value_type<int, basic_string<char, char_traits<char>, allocator<char>>>>, true> &const __pointer<__value_type<int, basic_string<char, char_traits<char>, allocator<char>>>, allocator<__value_type<int, basic_string<char, char_traits<char>, allocator<char>>>>, allocator<__value_type<int, basic_string<char, char_traits<char>, allocator<char>>>>, true>const __pointer<__value_type<int, basic_string<char, char_traits<char>, allocator<char>>>, allocator<__value_type<int, basic_string<char, char_traits<char>, allocator<char>>>>, allocator<__value_type<int, basic_string<char, char_traits<char>, allocator<char>>>>, true> &__const_pointer<__value_type<int, basic_string<char, char_traits<char>, allocator<char>>>, __value_type<int, basic_string<char, char_traits<char>, allocator<char>>> *, allocator<__value_type<int, basic_string<char, char_traits<char>, allocator<char>>>>, true>__const_pointer<__value_type<int, basic_string<char, char_traits<char>, allocator<char>>>, __value_type<int, basic_string<char, char_traits<char>, allocator<char>>> *, allocator<__value_type<int, basic_string<char, char_traits<char>, allocator<char>>>>, true> &const __const_pointer<__value_type<int, basic_string<char, char_traits<char>, allocator<char>>>, __value_type<int, basic_string<char, char_traits<char>, allocator<char>>> *, allocator<__value_type<int, basic_string<char, char_traits<char>, allocator<char>>>>, true>const __const_pointer<__value_type<int, basic_string<char, char_traits<char>, allocator<char>>>, __value_type<int, basic_string<char, char_traits<char>, allocator<char>>> *, allocator<__value_type<int, basic_string<char, char_traits<char>, allocator<char>>>>, true> &__void_pointer<__value_type<int, basic_string<char, char_traits<char>, allocator<char>>> *, allocator<__value_type<int, basic_string<char, char_traits<char>, allocator<char>>>>, false>__void_pointer<__value_type<int, basic_string<char, char_traits<char>, allocator<char>>> *, allocator<__value_type<int, basic_string<char, char_traits<char>, allocator<char>>>>, false> &const __void_pointer<__value_type<int, basic_string<char, char_traits<char>, allocator<char>>> *, allocator<__value_type<int, basic_string<char, char_traits<char>, allocator<char>>>>, false>const __void_pointer<__value_type<int, basic_string<char, char_traits<char>, allocator<char>>> *, allocator<__value_type<int, basic_string<char, char_traits<char>, allocator<char>>>>, false> &__const_void_pointer<__value_type<int, basic_string<char, char_traits<char>, allocator<char>>> *, allocator<__value_type<int, basic_string<char, char_traits<char>, allocator<char>>>>, false>__const_void_pointer<__value_type<int, basic_string<char, char_traits<char>, allocator<char>>> *, allocator<__value_type<int, basic_string<char, char_traits<char>, allocator<char>>>>, false> &const __const_void_pointer<__value_type<int, basic_string<char, char_traits<char>, allocator<char>>> *, allocator<__value_type<int, basic_string<char, char_traits<char>, allocator<char>>>>, false>const __const_void_pointer<__value_type<int, basic_string<char, char_traits<char>, allocator<char>>> *, allocator<__value_type<int, basic_string<char, char_traits<char>, allocator<char>>>>, false> &__alloc_traits_difference_type<allocator<__value_type<int, basic_string<char, char_traits<char>, allocator<char>>>>, __value_type<int, basic_string<char, char_traits<char>, allocator<char>>> *, true>__alloc_traits_difference_type<allocator<__value_type<int, basic_string<char, char_traits<char>, allocator<char>>>>, __value_type<int, basic_string<char, char_traits<char>, allocator<char>>> *, true> &const __alloc_traits_difference_type<allocator<__value_type<int, basic_string<char, char_traits<char>, allocator<char>>>>, __value_type<int, basic_string<char, char_traits<char>, allocator<char>>> *, true>const __alloc_traits_difference_type<allocator<__value_type<int, basic_string<char, char_traits<char>, allocator<char>>>>, __value_type<int, basic_string<char, char_traits<char>, allocator<char>>> *, true> &__size_type<allocator<__value_type<int, basic_string<char, char_traits<char>, allocator<char>>>>, long, true>__size_type<allocator<__value_type<int, basic_string<char, char_traits<char>, allocator<char>>>>, long, true> &const __size_type<allocator<__value_type<int, basic_string<char, char_traits<char>, allocator<char>>>>, long, true>const __size_type<allocator<__value_type<int, basic_string<char, char_traits<char>, allocator<char>>>>, long, true> &__propagate_on_container_move_assignment<allocator<__value_type<int, basic_string<char, char_traits<char>, allocator<char>>>>, true>__propagate_on_container_move_assignment<allocator<__value_type<int, basic_string<char, char_traits<char>, allocator<char>>>>, true> &const __propagate_on_container_move_assignment<allocator<__value_type<int, basic_string<char, char_traits<char>, allocator<char>>>>, true>const __propagate_on_container_move_assignment<allocator<__value_type<int, basic_string<char, char_traits<char>, allocator<char>>>>, true> &__is_always_equal<allocator<__value_type<int, basic_string<char, char_traits<char>, allocator<char>>>>, true>__is_always_equal<allocator<__value_type<int, basic_string<char, char_traits<char>, allocator<char>>>>, true> &const __is_always_equal<allocator<__value_type<int, basic_string<char, char_traits<char>, allocator<char>>>>, true>const __is_always_equal<allocator<__value_type<int, basic_string<char, char_traits<char>, allocator<char>>>>, true> &rebind_alloc<__tree_node<__value_type<int, basic_string<char, char_traits<char>, allocator<char>>>, void *>>rebind_alloc<__tree_node<__value_type<int, basic_string<char, char_traits<char>, allocator<char>>>, void *>> &const rebind_alloc<__tree_node<__value_type<int, basic_string<char, char_traits<char>, allocator<char>>>, void *>>const rebind_alloc<__tree_node<__value_type<int, basic_string<char, char_traits<char>, allocator<char>>>, void *>> &__rebind_pointer<void *, __tree_node<__value_type<int, basic_string<char, char_traits<char>, allocator<char>>>, void *>>__rebind_pointer<void *, __tree_node<__value_type<int, basic_string<char, char_traits<char>, allocator<char>>>, void *>> &const __rebind_pointer<void *, __tree_node<__value_type<int, basic_string<char, char_traits<char>, allocator<char>>>, void *>>const __rebind_pointer<void *, __tree_node<__value_type<int, basic_string<char, char_traits<char>, allocator<char>>>, void *>> &__compressed_pair_elem<__map_value_compare<int, __value_type<int, basic_string<char, char_traits<char>, allocator<char>>>, less<int>, true>, 1, true>__compressed_pair_elem<__map_value_compare<int, __value_type<int, basic_string<char, char_traits<char>, allocator<char>>>, less<int>, true>, 1, true> &const __compressed_pair_elem<__map_value_compare<int, __value_type<int, basic_string<char, char_traits<char>, allocator<char>>>, less<int>, true>, 1, true>const __compressed_pair_elem<__map_value_compare<int, __value_type<int, basic_string<char, char_traits<char>, allocator<char>>>, less<int>, true>, 1, true> &__compressed_pair_elem<allocator<__tree_node<__value_type<int, basic_string<char, char_traits<char>, allocator<char>>>, void *>>, 1, true>__compressed_pair_elem<allocator<__tree_node<__value_type<int, basic_string<char, char_traits<char>, allocator<char>>>, void *>>, 1, true> &const __compressed_pair_elem<allocator<__tree_node<__value_type<int, basic_string<char, char_traits<char>, allocator<char>>>, void *>>, 1, true>const __compressed_pair_elem<allocator<__tree_node<__value_type<int, basic_string<char, char_traits<char>, allocator<char>>>, void *>>, 1, true> &__compressed_pair_elem<allocator<NativePreview>, 1, true>__compressed_pair_elem<allocator<NativePreview>, 1, true> &const __compressed_pair_elem<allocator<NativePreview>, 1, true>const __compressed_pair_elem<allocator<NativePreview>, 1, true> &__compressed_pair_elem<NativePreview *, 0, false>__compressed_pair_elem<NativePreview *, 0, false> &const __compressed_pair_elem<NativePreview *, 0, false>const __compressed_pair_elem<NativePreview *, 0, false> &NativePreview *constNativePreview *const &NativePreview *&conditional<true, __tree_end_node<__tree_node_base<void *> *> *, __tree_node<__value_type<OffsetId, OffsetData>, void *> *>conditional<true, __tree_end_node<__tree_node_base<void *> *> *, __tree_node<__value_type<OffsetId, OffsetData>, void *> *> &const conditional<true, __tree_end_node<__tree_node_base<void *> *> *, __tree_node<__value_type<OffsetId, OffsetData>, void *> *>const conditional<true, __tree_end_node<__tree_node_base<void *> *> *, __tree_node<__value_type<OffsetId, OffsetData>, void *> *> &pointer_traits<__tree_node<__value_type<OffsetId, OffsetData>, void *> *>pointer_traits<__tree_node<__value_type<OffsetId, OffsetData>, void *> *> &const pointer_traits<__tree_node<__value_type<OffsetId, OffsetData>, void *> *>const pointer_traits<__tree_node<__value_type<OffsetId, OffsetData>, void *> *> &__rebind_pointer<void *, __value_type<OffsetId, OffsetData>>__rebind_pointer<void *, __value_type<OffsetId, OffsetData>> &const __rebind_pointer<void *, __value_type<OffsetId, OffsetData>>const __rebind_pointer<void *, __value_type<OffsetId, OffsetData>> &__rebind_pointer<void *, const __value_type<OffsetId, OffsetData>>__rebind_pointer<void *, const __value_type<OffsetId, OffsetData>> &const __rebind_pointer<void *, const __value_type<OffsetId, OffsetData>>const __rebind_pointer<void *, const __value_type<OffsetId, OffsetData>> &__tree_map_pointer_types<__value_type<OffsetId, OffsetData>, void *, __tree_key_value_types<__value_type<OffsetId, OffsetData>>, true>__tree_map_pointer_types<__value_type<OffsetId, OffsetData>, void *, __tree_key_value_types<__value_type<OffsetId, OffsetData>>, true> &const __tree_map_pointer_types<__value_type<OffsetId, OffsetData>, void *, __tree_key_value_types<__value_type<OffsetId, OffsetData>>, true>const __tree_map_pointer_types<__value_type<OffsetId, OffsetData>, void *, __tree_key_value_types<__value_type<OffsetId, OffsetData>>, true> &__pointer<__value_type<OffsetId, OffsetData>, allocator<__value_type<OffsetId, OffsetData>>, allocator<__value_type<OffsetId, OffsetData>>, true>__pointer<__value_type<OffsetId, OffsetData>, allocator<__value_type<OffsetId, OffsetData>>, allocator<__value_type<OffsetId, OffsetData>>, true> &const __pointer<__value_type<OffsetId, OffsetData>, allocator<__value_type<OffsetId, OffsetData>>, allocator<__value_type<OffsetId, OffsetData>>, true>const __pointer<__value_type<OffsetId, OffsetData>, allocator<__value_type<OffsetId, OffsetData>>, allocator<__value_type<OffsetId, OffsetData>>, true> &__const_pointer<__value_type<OffsetId, OffsetData>, __value_type<OffsetId, OffsetData> *, allocator<__value_type<OffsetId, OffsetData>>, true>__const_pointer<__value_type<OffsetId, OffsetData>, __value_type<OffsetId, OffsetData> *, allocator<__value_type<OffsetId, OffsetData>>, true> &const __const_pointer<__value_type<OffsetId, OffsetData>, __value_type<OffsetId, OffsetData> *, allocator<__value_type<OffsetId, OffsetData>>, true>const __const_pointer<__value_type<OffsetId, OffsetData>, __value_type<OffsetId, OffsetData> *, allocator<__value_type<OffsetId, OffsetData>>, true> &__void_pointer<__value_type<OffsetId, OffsetData> *, allocator<__value_type<OffsetId, OffsetData>>, false>__void_pointer<__value_type<OffsetId, OffsetData> *, allocator<__value_type<OffsetId, OffsetData>>, false> &const __void_pointer<__value_type<OffsetId, OffsetData> *, allocator<__value_type<OffsetId, OffsetData>>, false>const __void_pointer<__value_type<OffsetId, OffsetData> *, allocator<__value_type<OffsetId, OffsetData>>, false> &__const_void_pointer<__value_type<OffsetId, OffsetData> *, allocator<__value_type<OffsetId, OffsetData>>, false>__const_void_pointer<__value_type<OffsetId, OffsetData> *, allocator<__value_type<OffsetId, OffsetData>>, false> &const __const_void_pointer<__value_type<OffsetId, OffsetData> *, allocator<__value_type<OffsetId, OffsetData>>, false>const __const_void_pointer<__value_type<OffsetId, OffsetData> *, allocator<__value_type<OffsetId, OffsetData>>, false> &__alloc_traits_difference_type<allocator<__value_type<OffsetId, OffsetData>>, __value_type<OffsetId, OffsetData> *, true>__alloc_traits_difference_type<allocator<__value_type<OffsetId, OffsetData>>, __value_type<OffsetId, OffsetData> *, true> &const __alloc_traits_difference_type<allocator<__value_type<OffsetId, OffsetData>>, __value_type<OffsetId, OffsetData> *, true>const __alloc_traits_difference_type<allocator<__value_type<OffsetId, OffsetData>>, __value_type<OffsetId, OffsetData> *, true> &__size_type<allocator<__value_type<OffsetId, OffsetData>>, long, true>__size_type<allocator<__value_type<OffsetId, OffsetData>>, long, true> &const __size_type<allocator<__value_type<OffsetId, OffsetData>>, long, true>const __size_type<allocator<__value_type<OffsetId, OffsetData>>, long, true> &__propagate_on_container_move_assignment<allocator<__value_type<OffsetId, OffsetData>>, true>__propagate_on_container_move_assignment<allocator<__value_type<OffsetId, OffsetData>>, true> &const __propagate_on_container_move_assignment<allocator<__value_type<OffsetId, OffsetData>>, true>const __propagate_on_container_move_assignment<allocator<__value_type<OffsetId, OffsetData>>, true> &__is_always_equal<allocator<__value_type<OffsetId, OffsetData>>, true>__is_always_equal<allocator<__value_type<OffsetId, OffsetData>>, true> &const __is_always_equal<allocator<__value_type<OffsetId, OffsetData>>, true>const __is_always_equal<allocator<__value_type<OffsetId, OffsetData>>, true> &rebind_alloc<__tree_node<__value_type<OffsetId, OffsetData>, void *>>rebind_alloc<__tree_node<__value_type<OffsetId, OffsetData>, void *>> &const rebind_alloc<__tree_node<__value_type<OffsetId, OffsetData>, void *>>const rebind_alloc<__tree_node<__value_type<OffsetId, OffsetData>, void *>> &__rebind_pointer<void *, __tree_node<__value_type<OffsetId, OffsetData>, void *>>__rebind_pointer<void *, __tree_node<__value_type<OffsetId, OffsetData>, void *>> &const __rebind_pointer<void *, __tree_node<__value_type<OffsetId, OffsetData>, void *>>const __rebind_pointer<void *, __tree_node<__value_type<OffsetId, OffsetData>, void *>> &__compressed_pair_elem<__map_value_compare<OffsetId, __value_type<OffsetId, OffsetData>, less<OffsetId>, true>, 1, true>__compressed_pair_elem<__map_value_compare<OffsetId, __value_type<OffsetId, OffsetData>, less<OffsetId>, true>, 1, true> &const __compressed_pair_elem<__map_value_compare<OffsetId, __value_type<OffsetId, OffsetData>, less<OffsetId>, true>, 1, true>const __compressed_pair_elem<__map_value_compare<OffsetId, __value_type<OffsetId, OffsetData>, less<OffsetId>, true>, 1, true> &__compressed_pair_elem<allocator<__tree_node<__value_type<OffsetId, OffsetData>, void *>>, 1, true>__compressed_pair_elem<allocator<__tree_node<__value_type<OffsetId, OffsetData>, void *>>, 1, true> &const __compressed_pair_elem<allocator<__tree_node<__value_type<OffsetId, OffsetData>, void *>>, 1, true>const __compressed_pair_elem<allocator<__tree_node<__value_type<OffsetId, OffsetData>, void *>>, 1, true> &__compressed_pair_elem<allocator<pair<const unsigned char *, unsigned int>>, 1, true> *__compressed_pair_elem<allocator<TiffComponent *>, 1, true> *__compressed_pair_elem<allocator<Xmpdatum>, 1, true> *__rebind_pointer<void *, pair<const OffsetId, OffsetData>>__rebind_pointer<void *, pair<const OffsetId, OffsetData>> &const __rebind_pointer<void *, pair<const OffsetId, OffsetData>>const __rebind_pointer<void *, pair<const OffsetId, OffsetData>> &__rebind_pointer<void *, const pair<const OffsetId, OffsetData>>__rebind_pointer<void *, const pair<const OffsetId, OffsetData>> &const __rebind_pointer<void *, const pair<const OffsetId, OffsetData>>const __rebind_pointer<void *, const pair<const OffsetId, OffsetData>> &is_pointer<__tree_node<__value_type<OffsetId, OffsetData>, void *> *>is_pointer<__tree_node<__value_type<OffsetId, OffsetData>, void *> *> &const is_pointer<__tree_node<__value_type<OffsetId, OffsetData>, void *> *>const is_pointer<__tree_node<__value_type<OffsetId, OffsetData>, void *> *> &pointer_traits<pair<const OffsetId, OffsetData> *>pointer_traits<pair<const OffsetId, OffsetData> *> &const pointer_traits<pair<const OffsetId, OffsetData> *>const pointer_traits<pair<const OffsetId, OffsetData> *> &pointer_traits<NativePreview *>pointer_traits<NativePreview *> &const pointer_traits<NativePreview *>const pointer_traits<NativePreview *> &__rebind_pointer<void *, pair<const int, basic_string<char, char_traits<char>, allocator<char>>>>__rebind_pointer<void *, pair<const int, basic_string<char, char_traits<char>, allocator<char>>>> &const __rebind_pointer<void *, pair<const int, basic_string<char, char_traits<char>, allocator<char>>>>const __rebind_pointer<void *, pair<const int, basic_string<char, char_traits<char>, allocator<char>>>> &__rebind_pointer<void *, const pair<const int, basic_string<char, char_traits<char>, allocator<char>>>>__rebind_pointer<void *, const pair<const int, basic_string<char, char_traits<char>, allocator<char>>>> &const __rebind_pointer<void *, const pair<const int, basic_string<char, char_traits<char>, allocator<char>>>>const __rebind_pointer<void *, const pair<const int, basic_string<char, char_traits<char>, allocator<char>>>> &is_pointer<__tree_node<__value_type<int, basic_string<char, char_traits<char>, allocator<char>>>, void *> *>is_pointer<__tree_node<__value_type<int, basic_string<char, char_traits<char>, allocator<char>>>, void *> *> &const is_pointer<__tree_node<__value_type<int, basic_string<char, char_traits<char>, allocator<char>>>, void *> *>const is_pointer<__tree_node<__value_type<int, basic_string<char, char_traits<char>, allocator<char>>>, void *> *> &pointer_traits<pair<const int, basic_string<char, char_traits<char>, allocator<char>>> *>pointer_traits<pair<const int, basic_string<char, char_traits<char>, allocator<char>>> *> &const pointer_traits<pair<const int, basic_string<char, char_traits<char>, allocator<char>>> *>const pointer_traits<pair<const int, basic_string<char, char_traits<char>, allocator<char>>> *> &pointer_traits<Xmpdatum *>pointer_traits<Xmpdatum *> &const pointer_traits<Xmpdatum *>const pointer_traits<Xmpdatum *> &pointer_traits<Iptcdatum *>pointer_traits<Iptcdatum *> &const pointer_traits<Iptcdatum *>const pointer_traits<Iptcdatum *> &is_pointer<__tree_node<basic_string<char, char_traits<char>, allocator<char>>, void *> *>is_pointer<__tree_node<basic_string<char, char_traits<char>, allocator<char>>, void *> *> &const is_pointer<__tree_node<basic_string<char, char_traits<char>, allocator<char>>, void *> *>const is_pointer<__tree_node<basic_string<char, char_traits<char>, allocator<char>>, void *> *> &pointer_traits<unsigned int *>pointer_traits<unsigned int *> &const pointer_traits<unsigned int *>const pointer_traits<unsigned int *> &rebind<const __value_type<OffsetId, OffsetData>>rebind<const __value_type<OffsetId, OffsetData>> &const rebind<const __value_type<OffsetId, OffsetData>>const rebind<const __value_type<OffsetId, OffsetData>> &rebind<const pair<const OffsetId, OffsetData>>rebind<const pair<const OffsetId, OffsetData>> &const rebind<const pair<const OffsetId, OffsetData>>const rebind<const pair<const OffsetId, OffsetData>> &rebind<pair<const OffsetId, OffsetData>>rebind<pair<const OffsetId, OffsetData>> &const rebind<pair<const OffsetId, OffsetData>>const rebind<pair<const OffsetId, OffsetData>> &rebind<const __value_type<int, basic_string<char, char_traits<char>, allocator<char>>>>rebind<const __value_type<int, basic_string<char, char_traits<char>, allocator<char>>>> &const rebind<const __value_type<int, basic_string<char, char_traits<char>, allocator<char>>>>const rebind<const __value_type<int, basic_string<char, char_traits<char>, allocator<char>>>> &rebind<const pair<const int, basic_string<char, char_traits<char>, allocator<char>>>>rebind<const pair<const int, basic_string<char, char_traits<char>, allocator<char>>>> &const rebind<const pair<const int, basic_string<char, char_traits<char>, allocator<char>>>>const rebind<const pair<const int, basic_string<char, char_traits<char>, allocator<char>>>> &rebind<pair<const int, basic_string<char, char_traits<char>, allocator<char>>>>rebind<pair<const int, basic_string<char, char_traits<char>, allocator<char>>>> &const rebind<pair<const int, basic_string<char, char_traits<char>, allocator<char>>>>const rebind<pair<const int, basic_string<char, char_traits<char>, allocator<char>>>> &rebind<const basic_string<char, char_traits<char>, allocator<char>>>rebind<const basic_string<char, char_traits<char>, allocator<char>>> &const rebind<const basic_string<char, char_traits<char>, allocator<char>>>const rebind<const basic_string<char, char_traits<char>, allocator<char>>> &rebind<basic_string<char, char_traits<char>, allocator<char>>>rebind<basic_string<char, char_traits<char>, allocator<char>>> &const rebind<basic_string<char, char_traits<char>, allocator<char>>>const rebind<basic_string<char, char_traits<char>, allocator<char>>> &pointer_traits<TiffComponent **>pointer_traits<TiffComponent **> &const pointer_traits<TiffComponent **>const pointer_traits<TiffComponent **> &pointer_traits<pair<const unsigned char *, unsigned int> *>pointer_traits<pair<const unsigned char *, unsigned int> *> &const pointer_traits<pair<const unsigned char *, unsigned int> *>const pointer_traits<pair<const unsigned char *, unsigned int> *> &pointer_traits<TiffDirectory **>pointer_traits<TiffDirectory **> &const pointer_traits<TiffDirectory **>const pointer_traits<TiffDirectory **> &allocator<Xmpdatum> *allocator<Iptcdatum> *__compressed_pair<Iptcdatum *, allocator<Iptcdatum>> *allocator<TiffComponent *> *allocator<pair<const unsigned char *, unsigned int>> *pointer_traits<__value_type<int, basic_string<char, char_traits<char>, allocator<char>>> *>pointer_traits<__value_type<int, basic_string<char, char_traits<char>, allocator<char>>> *> &const pointer_traits<__value_type<int, basic_string<char, char_traits<char>, allocator<char>>> *>const pointer_traits<__value_type<int, basic_string<char, char_traits<char>, allocator<char>>> *> &pointer_traits<__value_type<OffsetId, OffsetData> *>pointer_traits<__value_type<OffsetId, OffsetData> *> &const pointer_traits<__value_type<OffsetId, OffsetData> *>const pointer_traits<__value_type<OffsetId, OffsetData> *> &__non_trivial_if<true, allocator<pair<const unsigned char *, unsigned int>>> *__non_trivial_if<true, allocator<TiffComponent *>> *const __compressed_pair<Iptcdatum *, allocator<Iptcdatum>> *__compressed_pair_elem<allocator<Iptcdatum>, 1, true> *__non_trivial_if<true, allocator<Xmpdatum>> *const __compressed_pair_elem<Iptcdatum *, 0, false> *__compressed_pair_elem<Iptcdatum *, 0, false> *<__algorithm/find_if.h>_LIBCPP___ALGORITHM_REMOVE_IF_H// _LIBCPP___ALGORITHM_REMOVE_IF_HCr2Parser &const Cr2Parserconst Cr2Parser &~Cr2ImageCr2Image *Cr2Image &const Cr2Imageconst Cr2Image &Cr2ImageCr2Parsercr2CR2IMAGE_HPP_isCr2TypenewCr2Instanceconst Cr2Image *// #ifndef CR2IMAGE_HPP_//! Check if the file iIo is a CR2 image./*!
      @brief Create a new Cr2Image instance and return an auto-pointer to it.
             Caller owns the returned object and the auto-pointer ensures that
             it will be deleted.
     */// class Cr2Parser/*!
          @brief Encode metadata from the provided metadata to CR2 format.
                 See TiffParser::encode().
        *//*!
          @brief Decode metadata from a buffer \em pData of length \em size
                 with data in CR2 format to the provided metadata containers.
                 See TiffParser::decode().
        *//*!
      @brief Stateless parser class for data in CR2 format. Images use this
             class to decode and encode CR2 data.
             See class TiffParser for details.
     */// class Cr2Image/*!
          @brief Not supported. CR2 format does not contain a comment.
              Calling this function will throw an Error(kerInvalidSettingForImage).
         *//*!
          @brief Print out the structure of image file.
          @throw Error if reading of the file fails or the image data is
                not valid (does not look like data of the specific image type).
          @warning This function is not thread safe and intended for exiv2 -pS for debugging.
         *//*!
          @brief Constructor that can either open an existing CR2 image or create
              a new image from scratch. If a new image is to be created, any
              existing data is overwritten. Since the constructor can not return
              a result, callers should check the good() method after object
              construction to determine success or failure.
          @param io An auto-pointer that owns a BasicIo instance used for
              reading and writing image metadata. \b Important: The constructor
              takes ownership of the passed in BasicIo instance through the
              auto-pointer. Callers should not continue to use the BasicIo
              instance after it is passed to this method.  Use the Image::io()
              method to get a temporary reference.
          @param create Specifies if an existing image should be read (false)
              or if a new file should be created (true).
         *//*!
      @brief Class to access raw Canon CR2 images.  Exif metadata
          is supported directly, IPTC is read from the Exif data, if present.
     *///!< CR2 image type (see class Cr2Image)// Add CR2 to the supported image formats/*!
  @file    cr2image.hpp
  @brief   Class Cr2Image
  @author  Andreas Huggel (ahu)
           <a href="mailto:ahuggel@gmx.net">ahuggel@gmx.net</a>
  @date    22-Apr-06, ahu: created
 */isTiffTypenewTiffInstanceTiffParser &const TiffParserconst TiffParser &primaryGroupTiffImage &const TiffImage &TiffImageTiffParserprimaryGroup_srwsr2arwpefnefdngTIFFIMAGE_HPP_// #ifndef TIFFIMAGE_HPP_//! Check if the file iIo is a TIFF image./*!
      @brief Create a new TiffImage instance and return an auto-pointer to it.
             Caller owns the returned object and the auto-pointer ensures that
             it will be deleted.
     */// class TiffParser/*!
          @brief Encode metadata from the provided metadata to TIFF format.

          The original binary image in the memory block \em pData, \em size is
          parsed and updated in-place if possible ("non-intrusive" writing).
          If that is not possible (e.g., if new tags were added), the entire
          TIFF structure is re-written to the \em io instance ("intrusive" writing).<br>
          The return value indicates which write method was used. If it is
          \c wmNonIntrusive, the original memory \em pData, \em size contains
          the result and nothing is written to \em io. If the return value is
          \c wmIntrusive, a new TIFF structure was created and written to
          \em io. The memory block \em pData, \em size may be partly updated
          in this case and should not be used anymore.

          @note If there is no metadata to encode, i.e., all metadata
                containers are empty, then the return value is \c wmIntrusive
                and nothing is written to \em io, i.e., no TIFF header is written.

          @param io        IO instance to write the binary image to in case of
                           "intrusive" writing. Nothing is written to \em io in
                           the case of "non-intrusive" writing.
          @param pData     Pointer to the binary image data buffer. Must
                           point to data in TIFF format; no checks are
                           performed. Will be modified if "non-intrusive"
                           writing is possible.
          @param size      Length of the data buffer.
          @param byteOrder Byte order to use.
          @param exifData  Exif metadata container.
          @param iptcData  IPTC metadata container.
          @param xmpData   XMP metadata container.

          @return Write method used.
        *//*!
          @brief Decode metadata from a buffer \em pData of length \em size
                 with data in TIFF format to the provided metadata containers.

          @param exifData Exif metadata container.
          @param iptcData IPTC metadata container.
          @param xmpData  XMP metadata container.
          @param pData    Pointer to the data buffer. Must point to data in TIFF
                          format; no checks are performed.
          @param size     Length of the data buffer.

          @return Byte order in which the data is encoded.
        *//*!
      @brief Stateless parser class for data in TIFF format. Images use this
             class to decode and encode TIFF data. It is a wrapper of the
             internal class Internal::TiffParserWorker.
     */// class TiffImage//!< Height of the primary image in pixels//!< Width of the primary image in pixels//!< The MIME type//!< The primary group//! Return the group name of the group with the primary image./*!
          @brief Not supported. TIFF format does not contain a comment.
              Calling this function will throw an Error(kerInvalidSettingForImage).
         *//*!
          @brief Print out the structure of image file.
          @throw Error if reading of the file fails or the image data is
                not valid (does not look like data of the specific image type).
          @warning This function is not thread safe and intended for exiv2 -p{S|R} as a file debugging aid
         *//*!
          @brief Constructor that can either open an existing TIFF image or create
              a new image from scratch. If a new image is to be created, any
              existing data is overwritten. Since the constructor can not return
              a result, callers should check the good() method after object
              construction to determine success or failure.
          @param io An auto-pointer that owns a BasicIo instance used for
              reading and writing image metadata. \b Important: The constructor
              takes ownership of the passed in BasicIo instance through the
              auto-pointer. Callers should not continue to use the BasicIo
              instance after it is passed to this method.  Use the Image::io()
              method to get a temporary reference.
          @param create Specifies if an existing image should be read (false)
              or if a new file should be created (true).
         *//*!
      @brief Class to access TIFF images. Exif metadata is
          supported directly, IPTC is read from the Exif data, if present.
     *///!< SRW image type (see class TiffImage)//!< SR2 image type (see class TiffImage)//!< ARW image type (see class TiffImage)//!< PEF image type (see class TiffImage)//!< NEF image type (see class TiffImage)//!< DNG image type (see class TiffImage)//!< TIFF image type (see class TiffImage)// Add TIFF to the supported image formats/*
  File:      tiffimage.hpp
 *//Users/owura/Repos/codeql_eval/proj_repos/Exiv2-exiv2-pull-962-commits-e925bc5addd881543fa503470c8a859e112cca62/exiv2/src/cr2image.cpp"tiffimage.hpp""cr2image.hpp" 16byte[16]-16const IfdId[]IfdId[]filteredIfdschar(&)[1]const IfdId[1]IfdId[1]const IfdId(&)[1]IfdId(&)[1]..(*)(..))[1]EXV_COUNTOF(filteredIfds)const IfdId *IfdId *offsetWriterOffsetWriter::cr2RawIfdOffsetTag::rootconst auto_ptr<TiffHeaderBase>cr2HeaderimageHeightimageWidthimage/x-canon-cr2"image/x-canon-cr2"CR2"CR2"ImageType::cr2mdExif | mdIptcmdExif | mdIptc | mdXmp// Delete IFDs which do not occur in TIFF images// Copy to be able to modify the Exif data// Cr2Image::writeMetadata// may throw// Cr2Image::readMetadata// Cr2Image::Cr2Image/*
  File:      cr2image.cpp
 */Exifdatum &&map<OffsetId, OffsetData, less<OffsetId>, allocator<pair<const OffsetId, OffsetData>>> *remove_reference<Exifdatum &>remove_reference<Exifdatum &> &const remove_reference<Exifdatum &>const remove_reference<Exifdatum &> &__tree<__value_type<OffsetId, OffsetData>, __map_value_compare<OffsetId, __value_type<OffsetId, OffsetData>, less<OffsetId>, true>, allocator<__value_type<OffsetId, OffsetData>>> *const __tree<__value_type<OffsetId, OffsetData>, __map_value_compare<OffsetId, __value_type<OffsetId, OffsetData>, less<OffsetId>, true>, allocator<__value_type<OffsetId, OffsetData>>>const __tree<__value_type<OffsetId, OffsetData>, __map_value_compare<OffsetId, __value_type<OffsetId, OffsetData>, less<OffsetId>, true>, allocator<__value_type<OffsetId, OffsetData>>> *__map_value_compare<OffsetId, __value_type<OffsetId, OffsetData>, less<OffsetId>, true> *find_ifremove_reference<const __map_value_compare<OffsetId, __value_type<OffsetId, OffsetData>, less<OffsetId>, true> &>remove_reference<const __map_value_compare<OffsetId, __value_type<OffsetId, OffsetData>, less<OffsetId>, true> &> &const remove_reference<const __map_value_compare<OffsetId, __value_type<OffsetId, OffsetData>, less<OffsetId>, true> &>const remove_reference<const __map_value_compare<OffsetId, __value_type<OffsetId, OffsetData>, less<OffsetId>, true> &> &CrwParser &const CrwParserconst CrwParser &~CrwImageCrwImage *CrwImage &const CrwImageconst CrwImage &CrwImageCrwParsercrwCRWIMAGE_HPP_isCrwTypenewCrwInstanceconst CrwImage *// #ifndef CRWIMAGE_HPP_//! Check if the file iIo is a CRW image./*!
      @brief Create a new CrwImage instance and return an auto-pointer to it.
             Caller owns the returned object and the auto-pointer ensures that
             it will be deleted.
     */// class CrwParser/*!
          @brief Encode metadata from the CRW image into a data buffer (the
                 binary CRW image).

          @param blob      Data buffer for the binary image (target).
          @param pData     Pointer to the binary image data buffer. Must
                           point to data in CRW format; no checks are
                           performed.
          @param size      Length of the data buffer.
          @param pCrwImage Pointer to the %Exiv2 CRW image with the metadata to
                           encode.

          @throw Error If the metadata from the CRW image cannot be encoded.
         *//*!
          @brief Decode metadata from a Canon CRW image in data buffer \em pData
                 of length \em size into \em crwImage.

          This is the entry point to access image data in Ciff format. The
          parser uses classes CiffHeader, CiffEntry, CiffDirectory.

          @param pCrwImage Pointer to the %Exiv2 CRW image to hold the metadata
                           read from the buffer.
          @param pData     Pointer to the data buffer. Must point to the data of
                           a CRW image; no checks are performed.
          @param size      Length of the data buffer.

          @throw Error If the data buffer cannot be parsed.
        *//*!
      Stateless parser class for Canon CRW images (Ciff format).
    */// class CrwImage/*!
          @brief Not supported. CRW format does not contain IPTC metadata.
              Calling this function will throw an Error(kerInvalidSettingForImage).
         *//*!
          @brief Constructor that can either open an existing CRW image or create
              a new image from scratch. If a new image is to be created, any
              existing data is overwritten. Since the constructor can not return
              a result, callers should check the good() method after object
              construction to determine success or failure.
          @param io An auto-pointer that owns a BasicIo instance used for
              reading and writing image metadata. \b Important: The constructor
              takes ownership of the passed in BasicIo instance through the
              auto-pointer. Callers should not continue to use the BasicIo
              instance after it is passed to this method.  Use the Image::io()
              method to get a temporary reference.
          @param create Specifies if an existing image should be read (false)
              or if a new file should be created (true).
         *//*!
      @brief Class to access raw Canon CRW images. Only Exif metadata and a
             comment are supported. CRW format does not contain IPTC metadata.
     *///!< CRW image type (see class CrwImage)// Add CRW to the supported image formats/*!
  @file    crwimage.hpp
  @brief   Class CrwImage to access Canon CRW images.<BR>
           References:<BR>
           <a href="http://www.sno.phy.queensu.ca/~phil/exiftool/canon_raw.html">The Canon RAW (CRW) File Format</a> by Phil Harvey
  @author  Andreas Huggel (ahu)
           <a href="mailto:ahuggel@gmx.net">ahuggel@gmx.net</a>
  @date    28-Aug-05, ahu: created
 */pCrwImage/Users/owura/Repos/codeql_eval/proj_repos/Exiv2-exiv2-pull-962-commits-e925bc5addd881543fa503470c8a859e112cca62/exiv2/src/crwimage_int.hppCiffComponent &const CiffComponentconst CiffComponent &CiffComponentCiffComponent *doFindComponentdoEmptydoPrintdoDecodedoReaddoRemoveCrwDirs &stack<CrwSubDir, deque<CrwSubDir, allocator<CrwSubDir>>> &findComponentdataLocationconst CiffComponent *tagId163830x3fffsetDirwriteValueData~CiffComponentisAllocated_(false)packIfdIdCrwMap &const CrwMapconst CrwMap &CrwMapencode0x2008const CrwMappingconst CrwMapping *CrwMapping *CiffHeader *encode0x1810encode0x180eencodeArrayencode0x080aencode0x0805encodeBasicdecode0x2008decode0x1810decode0x180edecodeArraydecode0x080adecode0x0805decodeBasiccrwMappingloadStackdoAddCiffEntry &const CiffEntryconst CiffEntry &CiffEntry~CiffEntryCiffEntry *CrwMapping &const CrwMapping &CrwMappingCiffHeader &const CiffHeaderconst CiffHeader &CiffHeaderconst CiffHeader *signature~CiffHeaderCiffDirectory *0x0000001aCiffDirectory &CiffDirectoryreadDirectory~CiffDirectoryCrwSubDir &const CrwSubDirconst CrwSubDir &DataLocIdvalueDatadirectoryDatalastDataLocIdCrwDecodeFctCrwEncodeFctCrwDirsCrwSubDirfromExif_toExif_crwDir_crwTagId_padded_pPadding_pRootDir_cc_parent_isAllocated_dir_const CrwSubDir[]CrwSubDir[]crwSubDir_const CrwMapping[]CrwMapping[]crwMapping_CRWIMAGE_INT_HPP_// #ifndef CRWIMAGE_INT_HPP_/*!
      @brief Pack the tag values of all \em ifdId tags in \em exifData into a
             data buffer. This function is used to pack Canon Camera Settings1,2
             and Custom Function tags.
     */// class CrwMap//!< Ciff directory hierarchy//!< Metadata conversion table//! Encode the thumbnail image//! Encode image width and height//! Encode the date when the picture was taken//! Encode Canon Camera Settings 1, 2 and Custom Function arrays//! Encode camera Make and Model information//! Encode the user comment/*!
          @brief Standard encode function to convert Exif metadata to Crw
                 entries.

          This is the basic encode function taking one Exif key and converting
          it to one Ciff entry. Both are available in the \em pCrwMapping passed
          in.

          @param image Image with the metadata to encode
          @param pCrwMapping Pointer to an entry into the \em crwMapping_ table
                       with information on the source and target metadata entries.
          @param pHead Pointer to the head of the CIFF parse tree into which
                       the metadata from \em image is encoded.
         *///! Decode the thumbnail image//! Decode image width and height//! Decode the date when the picture was taken//! Decode Canon Camera Settings 1, 2 and Custom Function arrays//! Decode camera Make and Model information//! Decode the user comment/*!
          @brief Standard decode function to convert CRW entries to
                 Exif metadata.

          Uses the mapping defined in the conversion structure \em pCrwMapping
          to convert the data. If the \em size field in the conversion structure
          is not 0, then it is used instead of the \em size provided by the
          entry itself.
         *///! Return conversion information for one \em crwDir and \em crwTagId/*!
          @brief Load the stack: loop through the CRW subdirs hierarchy and push
                 all directories on the path from \em crwDir to root onto the
                 stack \em crwDirs. Requires the subdirs array to be arranged in
                 bottom-up order to be able to finish in only one pass.
         *//*!
          @brief Encode image metadata from \em image into the CRW parse tree.
                 This function converts all Exif metadata that %Exiv2 can
                 convert to CRW format, in a loop through the entries of the
                 mapping table.

          @param pHead         Destination parse tree.
          @param image         Source image containing the metadata.
         *//*!
          @brief Decode image metadata from a CRW entry, convert and add it
                 to the image metadata. This function converts only one CRW
                 component.

          @param ciffComponent Source CIFF entry
          @param image         Destination image for the metadata
          @param byteOrder     Byte order in which the data of the entry
                               is encoded
         *///! @name Not implemented/*!
      @brief Static class providing mapping functionality from CRW entries
             to image metadata and vice versa
     */// struct CrwMapping//!< Reverse conversion function//!< Conversion function//!< Exif Ifd id to map to//!< Exif tag to map to//!< Data size (overwrites the size from the entry)//!< CRW directory tag//!< CRW tag id/*!
      @brief Structure for a mapping table for conversion of CIFF entries to
             image metadata and vice versa.
     */// struct CrwSubDir//!< Parent directory tag//!< Directory tag//! Structure for the CIFF directory hierarchy// class CiffHeader//!< Number of padding-bytes//!< Pointer to the (unknown) remainder//!< Pointer to the root directory//!< Canon CRW signature "HEAPCCDR"/*!
          @brief Finds \em crwTagId in directory \em crwDir in the parse tree,
                 returning a pointer to the component or 0 if not found.
         *//*!
          @brief Print debug info for the CRW image to \em os.

          @param os Output stream to write to.
          @param prefix Prefix to be written before each line of output.
         *//*!
          @brief Decode the CRW image and add it to \em image.

          Walk the parse tree and convert CIFF entries to metadata
          entries which are added to \em image.

          @param image Image to add metadata to
         *//*!
          @brief Write the CRW image to the binary image \em blob, starting with
                 the Ciff header. This method appends to the blob.

          @param blob Binary image to add to.

          @throw Error If the image cannot be written.
         *///! Return a pointer to the Canon CRW signature./*!
          @brief Remove entry \em crwTagId in directory \em crwDir from the parse
                 tree. If it's the last entry in the directory, the directory is
                 removed as well, etc.

          @param crwTagId Tag id to be removed.
          @param crwDir   Parent directory of the tag.
         *//*!
          @brief Set the value of entry \em crwTagId in directory \em crwDir to
                 \em buf. If this tag doesn't exist, it is added along with all
                 directories needed.

          @param crwTagId Tag to be added.
          @param crwDir   Parent directory of the tag.
          @param buf      Value to be set.
         *//*!
          @brief Read the CRW image from a data buffer, starting with the Ciff
                 header.

          @param pData Pointer to the data buffer.
          @param size  Number of bytes in the data buffer.

          @throw Error If the image cannot be parsed.
         *///! CiffHeader auto_ptr type/*!
      @brief This class models the header of a CRW (Canon Raw data) image.  It
             is the head of a CIFF parse tree, consisting of CiffDirectory and
             CiffEntry objects. Most of its methods will walk the parse tree to
             perform the requested action.
     */// class CiffDirectory// used by recursive doAdd//!< List of components in this dir// See base class comment//! See base class comment. A directory is empty if it has no components./*!
          @brief Implements write(). Writes the complete Ciff directory to
                 the blob.
         *//*!
          @brief Parse a CIFF directory from a memory buffer

          @param pData     Pointer to the memory buffer containing the directory
          @param size      Size of the memory buffer
          @param byteOrder Applicable byte order (little or big endian)
         */// Default assignment operator is fine//! Constructor taking a tag and directory//! This class models a CIFF directory of a CRW (Canon Raw data) image.// class CiffEntry/*!
          @brief Implements write(). Writes only the value data of the entry,
                 using writeValueData().
         *//*!
      @brief This class models one directory entry of a CIFF directory of
             a CRW (Canon Raw data) image.
     */// class CiffComponent//!< Offset to the data area from start of dir//!< Tag of the entry//!< Tag of the directory containing this component//! Implements findComponent(). The default implementation checks the entry.//! Implements empty(). Default implementation returns true if size is 0.//! Implements print(). The default implementation prints the entry.//! Implements decode()//! Set the offset for this component.//! Set the size of the data area.//! Implements write()//! Implements read(). The default implementation reads a directory entry.//! Implements remove(). The default implementation does nothing.//! Implements add(). The default implementation does nothing.//! Implements add()/*!
          @brief Finds \em crwTagId in directory \em crwDir, returning a pointer to
                 the component or 0 if not found.
         *///! Return the data location for this component//! Return the type id of thi component//! Return the tag id of this component//! Return a pointer to the data area of this component//! Return the offset to the data from the start of the directory/*!
          @brief Return the data size of this component

          @note If the data is contained in the directory entry itself,
                this method returns 8, which is the maximum number
                of data bytes this component can have. The actual size,
                i.e., used data bytes, may be less than 8.
         *///! Return true if the component is empty, else false//! Return the tag of this component//! Return the tag of the directory containing this component/*!
          @brief Write a directory entry for the component to the \em blob.
                 If the size of the data is not larger than 8 bytes, the
                 data is written to the directory entry.
         *//*!
          @brief Print debug info about a component to \em os.

          @param os Output stream to write to
          @param byteOrder Byte order
          @param prefix Prefix to be written before each line of output
         *//*!
          @brief Decode metadata from the component and add it to
                 \em image.

          @param image Image to add metadata to
          @param byteOrder Byte order
         *///! Return the data location id for a tag//! Return the type id for a tag//! Set the data value of the entry.//! Set the directory tag for this component./*!
          @brief Writes the entry's value if size is larger than eight bytes. If
                 needed, the value is padded with one 0 byte to make the number
                 of bytes written to the blob even. The offset of the component
                 is set to the offset passed in.
          @param blob The binary image to write to.
          @param offset Offset from the start of the directory for this entry.

          @return New offset.
         *//*!
          @brief Write the metadata from the raw metadata component to the
                 binary image \em blob. This method may append to the blob.

          @param blob      Binary image to add metadata to
          @param byteOrder Byte order
          @param offset    Current offset

          @return New offset
         *//*!
          @brief Read a component from a data buffer

          @param pData     Pointer to the data buffer.
          @param size      Number of bytes in the data buffer.
          @param start     Component starts at \em pData + \em start.
          @param byteOrder Applicable byte order (little or big endian).

          @throw Error If the component cannot be parsed.
         *//*!
          @brief Remove \em crwTagId from the parse tree, if it exists yet. \em
                 crwDirs contains the path of subdirectories, starting with the
                 root directory, leading to \em crwTagId.

          @param crwDirs   Subdirectory path from root to the subdirectory
                           containing the tag to be removed.
          @param crwTagId  Tag to be removed.
         *//*!
          @brief Add \em crwTagId to the parse tree, if it doesn't exist
                 yet. \em crwDirs contains the path of subdirectories, starting
                 with the root directory, leading to \em crwTagId. Directories
                 that don't exist yet are added along the way. Returns a pointer
                 to the newly added component.

          @param crwDirs   Subdirectory path from root to the subdirectory
                           containing the tag to be added.
          @param crwTagId  Tag to be added.

          @return A pointer to the newly added component.
         *///! Add a component to the composition//! CiffComponent auto_ptr type/*!
      @brief Interface class for components of the CIFF directory hierarchy of a
             CRW (Canon Raw data) image. Both CIFF directories as well as
             entries implement this interface. This class is implemented as NVI
             (non-virtual interface).
     *///! Type to identify where the data is stored in a directory//! Stack to hold a path of CRW directories//! Function pointer for functions to encode CRW entries from Exif tags//! Function pointer for functions to decode Exif tags from a CRW entry/*!
  @file    crwimage_int.hpp
  @brief   Internal classes to support CRW/CIFF format.
  @author  Andreas Huggel (ahu)
           <a href="mailto:ahuggel@gmx.net">ahuggel@gmx.net</a>
  @date    28-Aug-05, ahu: created
 */crwTagIdcrwDirtoExiffromExifpCrwMappingpHeadciffComponentcrwDirscomponent/Users/owura/Repos/codeql_eval/proj_repos/Exiv2-exiv2-pull-962-commits-e925bc5addd881543fa503470c8a859e112cca62/exiv2/src/crwimage.cpp"crwimage_int.hpp""crwimage.hpp"byte[14]unsigned char[14]tmpBuf-14headconst auto_ptr<CiffHeader>pCrwImage != 0pData != 081990x2007Exif.Image2.JPEGInterchangeFormat"Exif.Image2.JPEGInterchangeFormat"Exif.Image2.JPEGInterchangeFormatLength"Exif.Image2.JPEGInterchangeFormatLength"heightIterwidthIterimage/x-canon-crw"image/x-canon-crw"CRW"CRW"tempIotempIo.get() != 0ImageType::crwmdExif | mdComment// CrwParser::encode// structure to the binary image blob// Encode Exif tags from image into the CRW parse tree and write the// Parse image, starting with a CIFF header component// CrwParser::decode// a hack to get absolute offset of preview image inside CRW structure// Parse the image, starting with a CIFF header component// CrwImage::writeMetadata// Write new buffer to file// Read the image into a memory buffer// Read existing image// CrwImage::readMetadata// CrwImage::CrwImage/*
  File:      crwimage.cpp
  Author(s): Andreas Huggel (ahu) <ahuggel@gmx.net>
  History:   28-Aug-05, ahu: created

 */stack<CrwSubDir, deque<CrwSubDir, allocator<CrwSubDir>>>auto_ptr<CiffHeader>auto_ptr<CiffHeader> &auto_ptr<CiffHeader> *const auto_ptr<CiffHeader> *__wrap_iter<CiffComponent **>CiffComponent **__wrap_iter<CiffComponent *const *>CiffComponent *constCiffComponent *const *reverse_iterator<__wrap_iter<CiffComponent **>>reverse_iterator<__wrap_iter<CiffComponent *const *>>deque<CrwSubDir, allocator<CrwSubDir>>allocator<CrwSubDir><__utility/piecewise_construct.h><__functional/unwrap_ref.h>pair<_T1, _T2> &const pair<_T1, _T2>const pair<_T1, _T2> &__get_pair<1UL> &const __get_pair<1UL>const __get_pair<1UL> &const _T2const _T2 &_T2 &__get_pair<0UL> &const __get_pair<0UL>const __get_pair<0UL> &const _T1const _T1 &_T1 &pair<_T1, _T2> *__get_pair<1UL>__get_pair<0UL>__get_pair<_Ip>tuple_element<1UL, pair<_T1, _T2>>tuple_element<0UL, pair<_T1, _T2>>tuple_element<_Ip, pair<_T1, _T2>>tuple_size<pair<_T1, _T2>>_Ip < 2, "Index out of bounds in std::tuple_element<std::pair<T1, T2>>"Index out of bounds in std::tuple_element<std::pair<T1, T2>>_LIBCPP___UTILITY_PAIR_Hdefined(_LIBCPP_DEPRECATED_ABI_DISABLE_PAIR_TRIVIAL_COPY_CTOR)(__is_nothrow_swappable<_T1>::value && __is_nothrow_swappable<_T2>::value)__is_nothrow_swappable<first_type>::value && __is_nothrow_swappable<second_type>::value// _LIBCPP___UTILITY_PAIR_H// _LIBCPP_HAS_NO_DEDUCTION_GUIDES// Use the implicitly declared copy constructor in C++03/Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX.sdk/usr/include/c++/v1/__utility_RawDest *__split_buffer<_Tp, _Allocator> &__split_buffer<_Tp, _Allocator> *const __split_buffer<_Tp, _Allocator>const __split_buffer<_Tp, _Allocator> *__split_buffer<_Tp, _Allocator> &&const __alloc_rrconst __alloc_rr &const __split_buffer<_Tp, _Allocator> &__split_buffer<_Tp, _Allocator>__split_buffer_common<<unnamed>>_LIBCPP_SPLIT_BUFFER!__alloc_traits::propagate_on_container_swap::value|| __is_nothrow_swappable<__alloc_rr>::value(__alloc_traits::propagate_on_container_move_assignment::value && is_nothrow_move_assignable<allocator_type>::value) || !__alloc_traits::propagate_on_container_move_assignment::valueis_nothrow_move_constructible<allocator_type>::value// _LIBCPP_SPLIT_BUFFERconst __deque_iterator<CrwSubDir, CrwSubDir *, CrwSubDir &, CrwSubDir **, long, 1024L>const __deque_iterator<CrwSubDir, CrwSubDir *, CrwSubDir &, CrwSubDir **, long, 1024L> &__deque_iterator<CrwSubDir, CrwSubDir *, CrwSubDir &, CrwSubDir **, long, 1024L> &stack<_Tp, _Container> *const stack<_Tp, _Container> *const CiffDirectoryconst CiffDirectory *const CiffEntry */Users/owura/Repos/codeql_eval/proj_repos/Exiv2-exiv2-pull-962-commits-e925bc5addd881543fa503470c8a859e112cca62/exiv2/src/timegm.honcedefined(__MINGW__)/* timegm is replaced with _mkgmtime on Windows (msvc && mingw) */// The UTC version of mktime/*!
  @file    timegm.h
  @brief   Declaration of timegm(). The implementation is in localtime.c
*/UNUSED(x)(void)(x)UNUSED_H// UNUSED_H/Users/owura/Repos/codeql_eval/proj_repos/Exiv2-exiv2-pull-962-commits-e925bc5addd881543fa503470c8a859e112cca62/exiv2/src/crwimage_int.cpp"timegm.h"RotationMap &const RotationMapconst RotationMap &degreesconst OmListconst OmList[8]OmList[8]const OmList *OmList *orientationOmList &const OmList &"tag""dir""type""size""offset" = 0x" = 0x"dldl == directoryData || dl == valueDatasize_ <= 8491520xc000s <= sizepCrwMapping != 0pHead != 0kXkYkOexivDataedXedYedOedEndccsizeof(tm)ifdId != ifdIdNotSetk1k2key1value1ULongValue *ValueType<unsigned int> *key2value2tms%Y:%m:%d %H:%M:%S"%Y:%m:%d %H:%M:%S"apertureshutterSpeedUShortValue *ValueType<unsigned short> *const ValueType<unsigned short>etconst CrwMapping[23]CrwMapping[23]const CrwSubDir[9]CrwSubDir[9]const CrwSubDir *CrwSubDir *cmiCiffEntry::add"CiffEntry::add""Header, offset"Header, offsetbyteOrder_ == littleEndian || byteOrder_ == bigEndianpadded_ == offset_ - orootDirectoryrootDirectory == 0x0000stack<CrwSubDir, deque<CrwSubDir, allocator<CrwSubDir>>> *deque<CrwSubDir, allocator<CrwSubDir>> *childconst __wrap_iter<CiffComponent *const *>const __wrap_iter<CiffComponent *const *> &__wrap_iter<CiffComponent *const *> &   "   "const __wrap_iter<CiffComponent **>const __wrap_iter<CiffComponent **> &__wrap_iter<CiffComponent **> &dirStartconst vector<CiffComponent *, allocator<CiffComponent *>>const stack<CrwSubDir, deque<CrwSubDir, allocator<CrwSubDir>>>csdauto_ptr<CiffComponent> &const auto_ptr<CiffComponent>CiffComponent *&143360x380061440x1800102400x2800RotationMapOmListconst OmList[]OmList[]omList_-180-270-90102470x2807122990x300b122980x300a102440x280420530x080520580x080a20590x080b20640x081020690x081541370x102941380x102a41410x102d0x10330x103842650x10a90x00a942760x10b4409610xa00142770x10b542880x10c042890x10c161510x1807373820x920661550x180b61580x180e368670x900361600x1810409620xa00261670x181762030x183b82000x2008HEAPCCDR"HEAPCCDR"// Round the size to make it even.// CrwMap::encode0x2008// CrwMap::encode0x1810// CrwMap::encode0x180e// CrwMap::encodeArray// Write the number of shorts to the beginning of buf// Try the undecoded tag// CrwMap::encode0x080a// CrwMap::encode0x0805// Just delete the value, do not remove the tag// CrwMap::encodeBasic// Set the new value or remove the entry// Determine the source Exif metadatum// CrwMap::encode// CrwMap::loadStack// CrwMap::decodeBasic// Add metadatum to exif data// by default, use the size from the directory entry// empty// determine size from the data, by looking for the first 0// size in the mapping table overrides all// create a key and value pair// CrwMap::decode0x2008/*byteOrder*//*pCrwMapping*/// CrwMap::decode0x1810// CrwMap::decode0x180e// CrwMap::decodeArray// Exif.Photo.ExposureTime// Exif.Photo.FNumber// CrwMap::decode0x080a// Model// Make// CrwMap::decode0x0805// CrwMap::crwMapping// CrwMap::decode// CiffDirectory::doRemove// Remove the entry and abort the loop// Find the tag// Recursive call to next lower level directory// Find the directory// CiffComponent::doRemove// do nothing/*crwTagId*//*crwDirs*/// CiffComponent::remove// CiffHeader::remove// CiffDirectory::doAdd// Tag doesn't exist yet, add it// Directory doesn't exist yet, add it/*
          add()
            if stack not empty
              pop from stack
              find dir among components
              if not found, create it
              add()
            else
              find tag among components
              if not found, create it
              set value
        */// CiffComponent::doAdd// CiffComponent::add// CiffHeader::add// CiffDirectory::doFindComponent// CiffComponent::doFindComponent// CiffComponent::findComponent// CiffHeader::findComponent/*!
      @brief Finds \em crwTagId in directory \em crwDir, returning a pointer to
             the component or 0 if not found.

     */// CiffComponent::dataLocation// CiffComponent::typeId// fallthrough// CiffComponent::setValue// CiffDirectory::doPrint// CiffComponent::doPrint// CiffHeader::print// CiffComponent::writeDirEntry// Pad with 0s// Copy value instead of size and offset// Only 8 bytes fit in the directory entry// CiffDirectory::doWrite// Update directory entry// Offset of directory// Directory entries// Number of directory entries// Value data// Ciff offsets are relative to the start of the directory// CiffComponent::writeValueData// Pad the value to an even number of bytes// CiffEntry::doWrite// Pad as needed// CiffDirectory::doDecode// CiffEntry::doDecode// CiffHeader::decode// Nothing to decode from the header itself, just add correct byte order// CiffDirectory::readDirectory// CiffDirectory::doRead// CiffComponent::doRead// #889// CiffHeader::read// CiffEntry::doAdd/*component*/// dir,   parent/*
      CIFF directory hierarchy

                root
                 |
                300a
                 |
       +----+----+----+----+
       |    |    |    |    |
      2804 2807 3002 3003 300b
            |
           3004

      The array is arranged bottom-up so that starting with a directory at the
      bottom, the (unique) path to root can be determined in a single loop.
    */// CrwMap::crwMapping_[]//CrwMapping(0x1818, 0x3002,   0, 0x9204, exifId, decodeBasic,  encodeBasic),//CrwMapping(0x10b4, 0x300b,   0, 0x00b4, canonId, decodeBasic,  encodeBasic),// Mapped to Exif.Photo.ColorSpace instead (see below)//         ------  ------  ---- ------- -----    ---------     ---------//         CrwTag  CrwDir  Size ExifTag IfdId    decodeFct     encodeFct/*
      Mapping table used to decode and encode CIFF tags to/from Exif tags.  Only
      a subset of the Exif tags can be mapped to known tags found in CRW files
      and not all CIFF tags in the CRW files have a corresponding Exif tag. Tags
      which are not mapped in the table below are ignored.

      When decoding, each CIFF tag/directory pair in the CRW image is looked up
      in the table and if it has an entry, the corresponding decode function is
      called (CrwMap::decode). This function may or may not make use of the
      other parameters in the structure (such as the Exif tag and Ifd id).

      Encoding is done in a loop over the mapping table (CrwMap::encode). For
      each entry, the encode function is called, which looks up the (Exif)
      metadata to encode in the image. This function may or may not make use of
      the other parameters in the mapping structure.
    */// last entry// class RotationMap//!< CRW Rotation degrees//!< Exif orientation value//! Helper structure for the mapping list//! Get the degree value for an orientation number//! Get the orientation number for a degree value//! Helper class to map Exif orientation values to CRW rotation degrees__vector_base<CiffComponent *, allocator<CiffComponent *>>__vector_base<CiffComponent *, allocator<CiffComponent *>> &const __vector_base<CiffComponent *, allocator<CiffComponent *>>const __vector_base<CiffComponent *, allocator<CiffComponent *>> &auto_ptr_ref<CiffComponent>auto_ptr_ref<CiffComponent> &const auto_ptr_ref<CiffComponent>const auto_ptr_ref<CiffComponent> &__wrap_iter<CiffComponent **> *__wrap_iter<CiffComponent *const *> *allocator<CrwSubDir> &CrwSubDir **__deque_base<CrwSubDir, allocator<CrwSubDir>>basic_string<charT, char_traits<charT>, allocator<charT>>basic_ostringstream<charT, char_traits<charT>, allocator<charT>>BasicError<char>const BasicError<char> &const stack<CrwSubDir, deque<CrwSubDir, allocator<CrwSubDir>>> &deque<CrwSubDir, allocator<CrwSubDir>> &auto_ptr<CiffComponent>vector<CiffComponent *, allocator<CiffComponent *>>allocator<CiffComponent *> &__allocator_destructor<_Allocator>unique_ptr<pointer, __allocator_destructor<_Allocator>>__split_buffer<pointer, __pointer_allocator &>__pointer_allocator &__deque_iterator<CrwSubDir, CrwSubDir *, CrwSubDir &, CrwSubDir **, long, 1024L>__deque_iterator<CrwSubDir, CrwSubDir *, CrwSubDir &, CrwSubDir **, long, 1024L> *__wrap_iter<const unsigned int *> &const __wrap_iter<const unsigned int *>const __wrap_iter<const unsigned int *> &__wrap_iter<const unsigned int *> *allocator<CrwSubDir *>allocator<CrwSubDir *> &const allocator<CrwSubDir *>const allocator<CrwSubDir *> &CrwSubDir *constCrwSubDir *const &CrwSubDir *&CrwSubDir *const *__allocator_traits_rebind<allocator<CrwSubDir>, CrwSubDir *, true>__allocator_traits_rebind<allocator<CrwSubDir>, CrwSubDir *, true> &const __allocator_traits_rebind<allocator<CrwSubDir>, CrwSubDir *, true>const __allocator_traits_rebind<allocator<CrwSubDir>, CrwSubDir *, true> &allocator<const CrwSubDir *>allocator<const CrwSubDir *> &const allocator<const CrwSubDir *>const allocator<const CrwSubDir *> &const CrwSubDir *constconst CrwSubDir *const &const CrwSubDir *&const CrwSubDir *const *const CrwSubDir **__allocator_traits_rebind<allocator<CrwSubDir>, const CrwSubDir *, true>__allocator_traits_rebind<allocator<CrwSubDir>, const CrwSubDir *, true> &const __allocator_traits_rebind<allocator<CrwSubDir>, const CrwSubDir *, true>const __allocator_traits_rebind<allocator<CrwSubDir>, const CrwSubDir *, true> &allocator<CiffComponent *>const allocator<CiffComponent *>const allocator<CiffComponent *> &CiffComponent *const &__identity<allocator<CiffComponent *>>__identity<allocator<CiffComponent *>> &const __identity<allocator<CiffComponent *>>const __identity<allocator<CiffComponent *>> &const allocator<CrwSubDir>const allocator<CrwSubDir> &__identity<allocator<CrwSubDir>>__identity<allocator<CrwSubDir>> &const __identity<allocator<CrwSubDir>>const __identity<allocator<CrwSubDir>> &allocator<unsigned short>allocator<unsigned short> &const allocator<unsigned short>const allocator<unsigned short> &allocator<unsigned short> *const unsigned short *unsigned short *__identity<allocator<unsigned short>>__identity<allocator<unsigned short>> &const __identity<allocator<unsigned short>>const __identity<allocator<unsigned short>> &const ValueType<pair<unsigned int, unsigned int>> &const __wrap_iter<const pair<unsigned int, unsigned int> *>const __wrap_iter<const pair<unsigned int, unsigned int> *> &__wrap_iter<const pair<unsigned int, unsigned int> *> &vector<pair<unsigned int, unsigned int>, allocator<pair<unsigned int, unsigned int>>> &ValueList &const ValueType<unsigned int>const ValueType<unsigned int> *const ValueType<unsigned int> &ValueType<unsigned int> &vector<unsigned int, allocator<unsigned int>> &const ValueType<unsigned short> *const ValueType<unsigned short> &ValueType<unsigned short> &const __wrap_iter<const unsigned short *>const __wrap_iter<const unsigned short *> &__wrap_iter<const unsigned short *> &vector<unsigned short, allocator<unsigned short>> &const BasicError<char> *vector<CiffComponent *, allocator<CiffComponent *>> *const vector<CiffComponent *, allocator<CiffComponent *>> *auto_ptr<CiffComponent> *const auto_ptr<CiffComponent> *__vector_base<CiffComponent *, allocator<CiffComponent *>> *CiffComponent **&operator std::__1::auto_ptr_ref<Exiv2::Internal::CiffComponent>const stack<CrwSubDir, deque<CrwSubDir, allocator<CrwSubDir>>> *const __vector_base<CiffComponent *, allocator<CiffComponent *>> *const __wrap_iter<CiffComponent **> *const __wrap_iter<CiffComponent *const *> *__deque_base<CrwSubDir, allocator<CrwSubDir>> *const auto_ptr<Value> *__vector_base<unsigned int, allocator<unsigned int>> *operator unsigned char *operator std::__1::pair<unsigned int, unsigned int> *operator Exiv2::Internal::CiffComponent **operator Exiv2::Internal::CiffComponent *operator Exiv2::Internal::CrwSubDir **operator unsigned short *operator unsigned int *__vector_base<unsigned short, allocator<unsigned short>>__vector_base<unsigned short, allocator<unsigned short>> &const __vector_base<unsigned short, allocator<unsigned short>>const __vector_base<unsigned short, allocator<unsigned short>> &__non_trivial_if<true, allocator<unsigned short>>__non_trivial_if<true, allocator<unsigned short>> &const __non_trivial_if<true, allocator<unsigned short>>const __non_trivial_if<true, allocator<unsigned short>> &__non_trivial_if<true, allocator<CrwSubDir>>__non_trivial_if<true, allocator<CrwSubDir>> &const __non_trivial_if<true, allocator<CrwSubDir>>const __non_trivial_if<true, allocator<CrwSubDir>> &__non_trivial_if<true, allocator<CiffComponent *>>__non_trivial_if<true, allocator<CiffComponent *>> &const __non_trivial_if<true, allocator<CiffComponent *>>const __non_trivial_if<true, allocator<CiffComponent *>> &rebind<const CrwSubDir *>rebind<const CrwSubDir *> &const rebind<const CrwSubDir *>const rebind<const CrwSubDir *> &__has_rebind_other<allocator<CrwSubDir>, const CrwSubDir *, void>__has_rebind_other<allocator<CrwSubDir>, const CrwSubDir *, void> &const __has_rebind_other<allocator<CrwSubDir>, const CrwSubDir *, void>const __has_rebind_other<allocator<CrwSubDir>, const CrwSubDir *, void> &__non_trivial_if<true, allocator<const CrwSubDir *>>__non_trivial_if<true, allocator<const CrwSubDir *>> &const __non_trivial_if<true, allocator<const CrwSubDir *>>const __non_trivial_if<true, allocator<const CrwSubDir *>> &rebind<CrwSubDir *>rebind<CrwSubDir *> &const rebind<CrwSubDir *>const rebind<CrwSubDir *> &__has_rebind_other<allocator<CrwSubDir>, CrwSubDir *, void>__has_rebind_other<allocator<CrwSubDir>, CrwSubDir *, void> &const __has_rebind_other<allocator<CrwSubDir>, CrwSubDir *, void>const __has_rebind_other<allocator<CrwSubDir>, CrwSubDir *, void> &__non_trivial_if<true, allocator<CrwSubDir *>>__non_trivial_if<true, allocator<CrwSubDir *>> &const __non_trivial_if<true, allocator<CrwSubDir *>>const __non_trivial_if<true, allocator<CrwSubDir *>> &auto_ptr<ValueType<unsigned int>>auto_ptr<ValueType<unsigned short>>iterator_traits<const unsigned int *>iterator_traits<const unsigned int *> &const iterator_traits<const unsigned int *>const iterator_traits<const unsigned int *> &__deque_block_size<CrwSubDir, long>__deque_block_size<CrwSubDir, long> &const __deque_block_size<CrwSubDir, long>const __deque_block_size<CrwSubDir, long> &vector<CiffComponent *, allocator<CiffComponent *>> &allocator<charT>char_traits<charT>__compressed_pair<unsigned long, allocator<CrwSubDir>>__compressed_pair<unsigned long, allocator<CrwSubDir>> &const __compressed_pair<unsigned long, allocator<CrwSubDir>>const __compressed_pair<unsigned long, allocator<CrwSubDir>> &__split_buffer<CrwSubDir *, allocator<CrwSubDir *>>__rebind_alloc_helper<allocator_traits<allocator<CrwSubDir>>, CrwSubDir *>__rebind_alloc_helper<allocator_traits<allocator<CrwSubDir>>, CrwSubDir *> &const __rebind_alloc_helper<allocator_traits<allocator<CrwSubDir>>, CrwSubDir *>const __rebind_alloc_helper<allocator_traits<allocator<CrwSubDir>>, CrwSubDir *> &allocator_traits<allocator<CrwSubDir *>>allocator_traits<allocator<CrwSubDir *>> &const allocator_traits<allocator<CrwSubDir *>>const allocator_traits<allocator<CrwSubDir *>> &__rebind_alloc_helper<allocator_traits<allocator<CrwSubDir>>, const CrwSubDir *>__rebind_alloc_helper<allocator_traits<allocator<CrwSubDir>>, const CrwSubDir *> &const __rebind_alloc_helper<allocator_traits<allocator<CrwSubDir>>, const CrwSubDir *>const __rebind_alloc_helper<allocator_traits<allocator<CrwSubDir>>, const CrwSubDir *> &allocator_traits<allocator<const CrwSubDir *>>allocator_traits<allocator<const CrwSubDir *>> &const allocator_traits<allocator<const CrwSubDir *>>const allocator_traits<allocator<const CrwSubDir *>> &allocator_traits<allocator<CrwSubDir>>allocator_traits<allocator<CrwSubDir>> &const allocator_traits<allocator<CrwSubDir>>const allocator_traits<allocator<CrwSubDir>> &__deque_iterator<CrwSubDir, const CrwSubDir *, const CrwSubDir &, const CrwSubDir *const *, long, 1024L>reverse_iterator<__deque_iterator<CrwSubDir, CrwSubDir *, CrwSubDir &, CrwSubDir **, long, 1024L>>reverse_iterator<__deque_iterator<CrwSubDir, const CrwSubDir *, const CrwSubDir &, const CrwSubDir *const *, long, 1024L>>iterator_traits<CiffComponent *const *>iterator_traits<CiffComponent *const *> &const iterator_traits<CiffComponent *const *>const iterator_traits<CiffComponent *const *> &iterator_traits<CiffComponent **>iterator_traits<CiffComponent **> &const iterator_traits<CiffComponent **>const iterator_traits<CiffComponent **> &__wrap_iter<const pair<unsigned int, unsigned int> *> *vector<unsigned short, allocator<unsigned short>>__wrap_iter<unsigned short *>__wrap_iter<const unsigned short *>__wrap_iter<const unsigned short *> *__compressed_pair<CiffComponent **, allocator<CiffComponent *>>__compressed_pair<CiffComponent **, allocator<CiffComponent *>> &const __compressed_pair<CiffComponent **, allocator<CiffComponent *>>const __compressed_pair<CiffComponent **, allocator<CiffComponent *>> &allocator_traits<allocator<CiffComponent *>>allocator_traits<allocator<CiffComponent *>> &const allocator_traits<allocator<CiffComponent *>>const allocator_traits<allocator<CiffComponent *>> &const unsigned char &&unsigned char &&__split_buffer<unsigned char, allocator<unsigned char> &> &const vector<unsigned int, allocator<unsigned int>>const vector<unsigned int, allocator<unsigned int>> *vector<unsigned short, allocator<unsigned short>> *const vector<unsigned short, allocator<unsigned short>>const vector<unsigned short, allocator<unsigned short>> *__vector_base<unsigned short, allocator<unsigned short>> *const pair<unsigned int, unsigned int> &&pair<unsigned int, unsigned int> &&__split_buffer<pair<unsigned int, unsigned int>, allocator<pair<unsigned int, unsigned int>> &> &const deque<CrwSubDir, allocator<CrwSubDir>>const deque<CrwSubDir, allocator<CrwSubDir>> *__split_buffer<CrwSubDir *, allocator<CrwSubDir *>> *const __split_buffer<CrwSubDir *, allocator<CrwSubDir *>>const __split_buffer<CrwSubDir *, allocator<CrwSubDir *>> *const __deque_base<CrwSubDir, allocator<CrwSubDir>>const __deque_base<CrwSubDir, allocator<CrwSubDir>> *CiffComponent **&&CiffComponent *const &&CiffComponent *&&__split_buffer<CiffComponent *, allocator<CiffComponent *> &> &unsigned short *&const __vector_base<unsigned short, allocator<unsigned short>> *const __wrap_iter<const unsigned short *> *const ValueListconst ValueList &const __vector_base<unsigned int, allocator<unsigned int>> *const __wrap_iter<const unsigned int *> *const __wrap_iter<const pair<unsigned int, unsigned int> *> *remove_reference<CiffComponent *const &>remove_reference<CiffComponent *const &> &const remove_reference<CiffComponent *const &>const remove_reference<CiffComponent *const &> &remove_reference<CiffComponent *const>remove_reference<CiffComponent *const> &const remove_reference<CiffComponent *const>const remove_reference<CiffComponent *const> &__split_buffer<CiffComponent *, allocator<CiffComponent *> &>__unwrap_iter_impl<CiffComponent **, true>__unwrap_iter_impl<CiffComponent **, true> &const __unwrap_iter_impl<CiffComponent **, true>const __unwrap_iter_impl<CiffComponent **, true> &enable_if<true, CiffComponent **>enable_if<true, CiffComponent **> &const enable_if<true, CiffComponent **>const enable_if<true, CiffComponent **> &remove_reference<const pair<unsigned int, unsigned int> &>remove_reference<const pair<unsigned int, unsigned int> &> &const remove_reference<const pair<unsigned int, unsigned int> &>const remove_reference<const pair<unsigned int, unsigned int> &> &remove_reference<const pair<unsigned int, unsigned int>>remove_reference<const pair<unsigned int, unsigned int>> &const remove_reference<const pair<unsigned int, unsigned int>>const remove_reference<const pair<unsigned int, unsigned int>> &__split_buffer<pair<unsigned int, unsigned int>, allocator<pair<unsigned int, unsigned int>> &>remove_reference<const unsigned char &>remove_reference<const unsigned char &> &const remove_reference<const unsigned char &>const remove_reference<const unsigned char &> &remove_reference<const unsigned char>remove_reference<const unsigned char> &const remove_reference<const unsigned char>const remove_reference<const unsigned char> &__split_buffer<unsigned char, allocator<unsigned char> &>__pointer<CiffComponent *, allocator<CiffComponent *>, allocator<CiffComponent *>, true>__pointer<CiffComponent *, allocator<CiffComponent *>, allocator<CiffComponent *>, true> &const __pointer<CiffComponent *, allocator<CiffComponent *>, allocator<CiffComponent *>, true>const __pointer<CiffComponent *, allocator<CiffComponent *>, allocator<CiffComponent *>, true> &__const_pointer<CiffComponent *, CiffComponent **, allocator<CiffComponent *>, true>__const_pointer<CiffComponent *, CiffComponent **, allocator<CiffComponent *>, true> &const __const_pointer<CiffComponent *, CiffComponent **, allocator<CiffComponent *>, true>const __const_pointer<CiffComponent *, CiffComponent **, allocator<CiffComponent *>, true> &__void_pointer<CiffComponent **, allocator<CiffComponent *>, false>__void_pointer<CiffComponent **, allocator<CiffComponent *>, false> &const __void_pointer<CiffComponent **, allocator<CiffComponent *>, false>const __void_pointer<CiffComponent **, allocator<CiffComponent *>, false> &__const_void_pointer<CiffComponent **, allocator<CiffComponent *>, false>__const_void_pointer<CiffComponent **, allocator<CiffComponent *>, false> &const __const_void_pointer<CiffComponent **, allocator<CiffComponent *>, false>const __const_void_pointer<CiffComponent **, allocator<CiffComponent *>, false> &__alloc_traits_difference_type<allocator<CiffComponent *>, CiffComponent **, true>__alloc_traits_difference_type<allocator<CiffComponent *>, CiffComponent **, true> &const __alloc_traits_difference_type<allocator<CiffComponent *>, CiffComponent **, true>const __alloc_traits_difference_type<allocator<CiffComponent *>, CiffComponent **, true> &__size_type<allocator<CiffComponent *>, long, true>__size_type<allocator<CiffComponent *>, long, true> &const __size_type<allocator<CiffComponent *>, long, true>const __size_type<allocator<CiffComponent *>, long, true> &__propagate_on_container_move_assignment<allocator<CiffComponent *>, true>__propagate_on_container_move_assignment<allocator<CiffComponent *>, true> &const __propagate_on_container_move_assignment<allocator<CiffComponent *>, true>const __propagate_on_container_move_assignment<allocator<CiffComponent *>, true> &__is_always_equal<allocator<CiffComponent *>, true>__is_always_equal<allocator<CiffComponent *>, true> &const __is_always_equal<allocator<CiffComponent *>, true>const __is_always_equal<allocator<CiffComponent *>, true> &__compressed_pair_elem<allocator<CiffComponent *>, 1, true>__compressed_pair_elem<allocator<CiffComponent *>, 1, true> &const __compressed_pair_elem<allocator<CiffComponent *>, 1, true>const __compressed_pair_elem<allocator<CiffComponent *>, 1, true> &__compressed_pair_elem<CiffComponent **, 0, false>__compressed_pair_elem<CiffComponent **, 0, false> &const __compressed_pair_elem<CiffComponent **, 0, false>const __compressed_pair_elem<CiffComponent **, 0, false> &CiffComponent **constCiffComponent **const &iterator_traits<const unsigned short *>iterator_traits<const unsigned short *> &const iterator_traits<const unsigned short *>const iterator_traits<const unsigned short *> &reverse_iterator<__wrap_iter<unsigned short *>>reverse_iterator<__wrap_iter<const unsigned short *>>iterator_traits<const pair<unsigned int, unsigned int> *>iterator_traits<const pair<unsigned int, unsigned int> *> &const iterator_traits<const pair<unsigned int, unsigned int> *>const iterator_traits<const pair<unsigned int, unsigned int> *> &remove_cv<CiffComponent *>remove_cv<CiffComponent *> &const remove_cv<CiffComponent *>const remove_cv<CiffComponent *> &remove_cv<CiffComponent *const>remove_cv<CiffComponent *const> &const remove_cv<CiffComponent *const>const remove_cv<CiffComponent *const> &__size_type<allocator<CrwSubDir>, long, true>__size_type<allocator<CrwSubDir>, long, true> &const __size_type<allocator<CrwSubDir>, long, true>const __size_type<allocator<CrwSubDir>, long, true> &__pointer<CrwSubDir, allocator<CrwSubDir>, allocator<CrwSubDir>, true>__pointer<CrwSubDir, allocator<CrwSubDir>, allocator<CrwSubDir>, true> &const __pointer<CrwSubDir, allocator<CrwSubDir>, allocator<CrwSubDir>, true>const __pointer<CrwSubDir, allocator<CrwSubDir>, allocator<CrwSubDir>, true> &__const_pointer<CrwSubDir, CrwSubDir *, allocator<CrwSubDir>, true>__const_pointer<CrwSubDir, CrwSubDir *, allocator<CrwSubDir>, true> &const __const_pointer<CrwSubDir, CrwSubDir *, allocator<CrwSubDir>, true>const __const_pointer<CrwSubDir, CrwSubDir *, allocator<CrwSubDir>, true> &__void_pointer<CrwSubDir *, allocator<CrwSubDir>, false>__void_pointer<CrwSubDir *, allocator<CrwSubDir>, false> &const __void_pointer<CrwSubDir *, allocator<CrwSubDir>, false>const __void_pointer<CrwSubDir *, allocator<CrwSubDir>, false> &__const_void_pointer<CrwSubDir *, allocator<CrwSubDir>, false>__const_void_pointer<CrwSubDir *, allocator<CrwSubDir>, false> &const __const_void_pointer<CrwSubDir *, allocator<CrwSubDir>, false>const __const_void_pointer<CrwSubDir *, allocator<CrwSubDir>, false> &__alloc_traits_difference_type<allocator<CrwSubDir>, CrwSubDir *, true>__alloc_traits_difference_type<allocator<CrwSubDir>, CrwSubDir *, true> &const __alloc_traits_difference_type<allocator<CrwSubDir>, CrwSubDir *, true>const __alloc_traits_difference_type<allocator<CrwSubDir>, CrwSubDir *, true> &__propagate_on_container_move_assignment<allocator<CrwSubDir>, true>__propagate_on_container_move_assignment<allocator<CrwSubDir>, true> &const __propagate_on_container_move_assignment<allocator<CrwSubDir>, true>const __propagate_on_container_move_assignment<allocator<CrwSubDir>, true> &__is_always_equal<allocator<CrwSubDir>, true>__is_always_equal<allocator<CrwSubDir>, true> &const __is_always_equal<allocator<CrwSubDir>, true>const __is_always_equal<allocator<CrwSubDir>, true> &__const_pointer<const CrwSubDir *, const CrwSubDir **, allocator<const CrwSubDir *>, true>__const_pointer<const CrwSubDir *, const CrwSubDir **, allocator<const CrwSubDir *>, true> &const __const_pointer<const CrwSubDir *, const CrwSubDir **, allocator<const CrwSubDir *>, true>const __const_pointer<const CrwSubDir *, const CrwSubDir **, allocator<const CrwSubDir *>, true> &__size_type<allocator<const CrwSubDir *>, long, true>__size_type<allocator<const CrwSubDir *>, long, true> &const __size_type<allocator<const CrwSubDir *>, long, true>const __size_type<allocator<const CrwSubDir *>, long, true> &__const_void_pointer<const CrwSubDir **, allocator<const CrwSubDir *>, false>__const_void_pointer<const CrwSubDir **, allocator<const CrwSubDir *>, false> &const __const_void_pointer<const CrwSubDir **, allocator<const CrwSubDir *>, false>const __const_void_pointer<const CrwSubDir **, allocator<const CrwSubDir *>, false> &__pointer<const CrwSubDir *, allocator<const CrwSubDir *>, allocator<const CrwSubDir *>, true>__pointer<const CrwSubDir *, allocator<const CrwSubDir *>, allocator<const CrwSubDir *>, true> &const __pointer<const CrwSubDir *, allocator<const CrwSubDir *>, allocator<const CrwSubDir *>, true>const __pointer<const CrwSubDir *, allocator<const CrwSubDir *>, allocator<const CrwSubDir *>, true> &__void_pointer<const CrwSubDir **, allocator<const CrwSubDir *>, false>__void_pointer<const CrwSubDir **, allocator<const CrwSubDir *>, false> &const __void_pointer<const CrwSubDir **, allocator<const CrwSubDir *>, false>const __void_pointer<const CrwSubDir **, allocator<const CrwSubDir *>, false> &__alloc_traits_difference_type<allocator<const CrwSubDir *>, const CrwSubDir **, true>__alloc_traits_difference_type<allocator<const CrwSubDir *>, const CrwSubDir **, true> &const __alloc_traits_difference_type<allocator<const CrwSubDir *>, const CrwSubDir **, true>const __alloc_traits_difference_type<allocator<const CrwSubDir *>, const CrwSubDir **, true> &__propagate_on_container_move_assignment<allocator<const CrwSubDir *>, true>__propagate_on_container_move_assignment<allocator<const CrwSubDir *>, true> &const __propagate_on_container_move_assignment<allocator<const CrwSubDir *>, true>const __propagate_on_container_move_assignment<allocator<const CrwSubDir *>, true> &__is_always_equal<allocator<const CrwSubDir *>, true>__is_always_equal<allocator<const CrwSubDir *>, true> &const __is_always_equal<allocator<const CrwSubDir *>, true>const __is_always_equal<allocator<const CrwSubDir *>, true> &rebind_alloc<const CrwSubDir *>rebind_alloc<const CrwSubDir *> &const rebind_alloc<const CrwSubDir *>const rebind_alloc<const CrwSubDir *> &__pointer<CrwSubDir *, allocator<CrwSubDir *>, allocator<CrwSubDir *>, true>__pointer<CrwSubDir *, allocator<CrwSubDir *>, allocator<CrwSubDir *>, true> &const __pointer<CrwSubDir *, allocator<CrwSubDir *>, allocator<CrwSubDir *>, true>const __pointer<CrwSubDir *, allocator<CrwSubDir *>, allocator<CrwSubDir *>, true> &__const_pointer<CrwSubDir *, CrwSubDir **, allocator<CrwSubDir *>, true>__const_pointer<CrwSubDir *, CrwSubDir **, allocator<CrwSubDir *>, true> &const __const_pointer<CrwSubDir *, CrwSubDir **, allocator<CrwSubDir *>, true>const __const_pointer<CrwSubDir *, CrwSubDir **, allocator<CrwSubDir *>, true> &__void_pointer<CrwSubDir **, allocator<CrwSubDir *>, false>__void_pointer<CrwSubDir **, allocator<CrwSubDir *>, false> &const __void_pointer<CrwSubDir **, allocator<CrwSubDir *>, false>const __void_pointer<CrwSubDir **, allocator<CrwSubDir *>, false> &__const_void_pointer<CrwSubDir **, allocator<CrwSubDir *>, false>__const_void_pointer<CrwSubDir **, allocator<CrwSubDir *>, false> &const __const_void_pointer<CrwSubDir **, allocator<CrwSubDir *>, false>const __const_void_pointer<CrwSubDir **, allocator<CrwSubDir *>, false> &__alloc_traits_difference_type<allocator<CrwSubDir *>, CrwSubDir **, true>__alloc_traits_difference_type<allocator<CrwSubDir *>, CrwSubDir **, true> &const __alloc_traits_difference_type<allocator<CrwSubDir *>, CrwSubDir **, true>const __alloc_traits_difference_type<allocator<CrwSubDir *>, CrwSubDir **, true> &__size_type<allocator<CrwSubDir *>, long, true>__size_type<allocator<CrwSubDir *>, long, true> &const __size_type<allocator<CrwSubDir *>, long, true>const __size_type<allocator<CrwSubDir *>, long, true> &__propagate_on_container_move_assignment<allocator<CrwSubDir *>, true>__propagate_on_container_move_assignment<allocator<CrwSubDir *>, true> &const __propagate_on_container_move_assignment<allocator<CrwSubDir *>, true>const __propagate_on_container_move_assignment<allocator<CrwSubDir *>, true> &__is_always_equal<allocator<CrwSubDir *>, true>__is_always_equal<allocator<CrwSubDir *>, true> &const __is_always_equal<allocator<CrwSubDir *>, true>const __is_always_equal<allocator<CrwSubDir *>, true> &rebind_alloc<CrwSubDir *>rebind_alloc<CrwSubDir *> &const rebind_alloc<CrwSubDir *>const rebind_alloc<CrwSubDir *> &__compressed_pair<CrwSubDir **, allocator<CrwSubDir *>>__compressed_pair<CrwSubDir **, allocator<CrwSubDir *>> &const __compressed_pair<CrwSubDir **, allocator<CrwSubDir *>>const __compressed_pair<CrwSubDir **, allocator<CrwSubDir *>> &remove_reference<allocator<CrwSubDir *>>remove_reference<allocator<CrwSubDir *>> &const remove_reference<allocator<CrwSubDir *>>const remove_reference<allocator<CrwSubDir *>> &add_lvalue_reference<allocator<CrwSubDir *>>add_lvalue_reference<allocator<CrwSubDir *>> &const add_lvalue_reference<allocator<CrwSubDir *>>const add_lvalue_reference<allocator<CrwSubDir *>> &__compressed_pair_elem<allocator<CrwSubDir>, 1, true>__compressed_pair_elem<allocator<CrwSubDir>, 1, true> &const __compressed_pair_elem<allocator<CrwSubDir>, 1, true>const __compressed_pair_elem<allocator<CrwSubDir>, 1, true> &remove_cv<const unsigned int>remove_cv<const unsigned int> &const remove_cv<const unsigned int>const remove_cv<const unsigned int> &__compressed_pair<unsigned short *, allocator<unsigned short>>__compressed_pair<unsigned short *, allocator<unsigned short>> &const __compressed_pair<unsigned short *, allocator<unsigned short>>const __compressed_pair<unsigned short *, allocator<unsigned short>> &allocator_traits<allocator<unsigned short>>allocator_traits<allocator<unsigned short>> &const allocator_traits<allocator<unsigned short>>const allocator_traits<allocator<unsigned short>> &const vector<pair<unsigned int, unsigned int>, allocator<pair<unsigned int, unsigned int>>> &pair<unsigned int, unsigned int> *&&const vector<unsigned int, allocator<unsigned int>> &const unsigned int &&unsigned int &&__split_buffer<unsigned int, allocator<unsigned int> &> &unsigned int *&&const vector<unsigned short, allocator<unsigned short>> &const unsigned short &&unsigned short &&__split_buffer<unsigned short, allocator<unsigned short> &> &unsigned short *&&__compressed_pair<CiffComponent **, allocator<CiffComponent *>> *__split_buffer<CiffComponent *, allocator<CiffComponent *> &> *const __split_buffer<CiffComponent *, allocator<CiffComponent *> &>const __split_buffer<CiffComponent *, allocator<CiffComponent *> &> *allocator<CrwSubDir> *__compressed_pair<unsigned long, allocator<CrwSubDir>> *CrwSubDir **&const __deque_iterator<CrwSubDir, CrwSubDir *, CrwSubDir &, CrwSubDir **, long, 1024L> *CrwSubDir *&&const unique_ptr<CrwSubDir *, __allocator_destructor<allocator<CrwSubDir>>>__compressed_pair<pair<unsigned int, unsigned int> *, allocator<pair<unsigned int, unsigned int>>> *__split_buffer<pair<unsigned int, unsigned int>, allocator<pair<unsigned int, unsigned int>> &> *const __split_buffer<pair<unsigned int, unsigned int>, allocator<pair<unsigned int, unsigned int>> &>const __split_buffer<pair<unsigned int, unsigned int>, allocator<pair<unsigned int, unsigned int>> &> *__compressed_pair<unsigned char *, allocator<unsigned char>> *__split_buffer<unsigned char, allocator<unsigned char> &> *const __split_buffer<unsigned char, allocator<unsigned char> &>const __split_buffer<unsigned char, allocator<unsigned char> &> *__allocator_destructor<allocator<CrwSubDir>>__allocator_destructor<allocator<CrwSubDir>> &const __allocator_destructor<allocator<CrwSubDir>>const __allocator_destructor<allocator<CrwSubDir>> &unique_ptr<CrwSubDir *, __allocator_destructor<allocator<CrwSubDir>>>unique_ptr<CrwSubDir *, __allocator_destructor<allocator<CrwSubDir>>> &__split_buffer<CrwSubDir *, allocator<CrwSubDir *> &>remove_reference<const CrwSubDir &>remove_reference<const CrwSubDir &> &const remove_reference<const CrwSubDir &>const remove_reference<const CrwSubDir &> &remove_reference<CiffComponent *&>remove_reference<CiffComponent *&> &const remove_reference<CiffComponent *&>const remove_reference<CiffComponent *&> &remove_reference<unsigned short *&>remove_reference<unsigned short *&> &const remove_reference<unsigned short *&>const remove_reference<unsigned short *&> &remove_reference<const unsigned short &>remove_reference<const unsigned short &> &const remove_reference<const unsigned short &>const remove_reference<const unsigned short &> &remove_reference<const unsigned short>remove_reference<const unsigned short> &const remove_reference<const unsigned short>const remove_reference<const unsigned short> &__split_buffer<unsigned short, allocator<unsigned short> &>remove_reference<unsigned int *&>remove_reference<unsigned int *&> &const remove_reference<unsigned int *&>const remove_reference<unsigned int *&> &remove_reference<const unsigned int &>remove_reference<const unsigned int &> &const remove_reference<const unsigned int &>const remove_reference<const unsigned int &> &remove_reference<const unsigned int>remove_reference<const unsigned int> &const remove_reference<const unsigned int>const remove_reference<const unsigned int> &__split_buffer<unsigned int, allocator<unsigned int> &>remove_reference<pair<unsigned int, unsigned int> *&>remove_reference<pair<unsigned int, unsigned int> *&> &const remove_reference<pair<unsigned int, unsigned int> *&>const remove_reference<pair<unsigned int, unsigned int> *&> &__pointer<unsigned short, allocator<unsigned short>, allocator<unsigned short>, true>__pointer<unsigned short, allocator<unsigned short>, allocator<unsigned short>, true> &const __pointer<unsigned short, allocator<unsigned short>, allocator<unsigned short>, true>const __pointer<unsigned short, allocator<unsigned short>, allocator<unsigned short>, true> &__const_pointer<unsigned short, unsigned short *, allocator<unsigned short>, true>__const_pointer<unsigned short, unsigned short *, allocator<unsigned short>, true> &const __const_pointer<unsigned short, unsigned short *, allocator<unsigned short>, true>const __const_pointer<unsigned short, unsigned short *, allocator<unsigned short>, true> &__void_pointer<unsigned short *, allocator<unsigned short>, false>__void_pointer<unsigned short *, allocator<unsigned short>, false> &const __void_pointer<unsigned short *, allocator<unsigned short>, false>const __void_pointer<unsigned short *, allocator<unsigned short>, false> &__const_void_pointer<unsigned short *, allocator<unsigned short>, false>__const_void_pointer<unsigned short *, allocator<unsigned short>, false> &const __const_void_pointer<unsigned short *, allocator<unsigned short>, false>const __const_void_pointer<unsigned short *, allocator<unsigned short>, false> &__alloc_traits_difference_type<allocator<unsigned short>, unsigned short *, true>__alloc_traits_difference_type<allocator<unsigned short>, unsigned short *, true> &const __alloc_traits_difference_type<allocator<unsigned short>, unsigned short *, true>const __alloc_traits_difference_type<allocator<unsigned short>, unsigned short *, true> &__size_type<allocator<unsigned short>, long, true>__size_type<allocator<unsigned short>, long, true> &const __size_type<allocator<unsigned short>, long, true>const __size_type<allocator<unsigned short>, long, true> &__propagate_on_container_move_assignment<allocator<unsigned short>, true>__propagate_on_container_move_assignment<allocator<unsigned short>, true> &const __propagate_on_container_move_assignment<allocator<unsigned short>, true>const __propagate_on_container_move_assignment<allocator<unsigned short>, true> &__is_always_equal<allocator<unsigned short>, true>__is_always_equal<allocator<unsigned short>, true> &const __is_always_equal<allocator<unsigned short>, true>const __is_always_equal<allocator<unsigned short>, true> &__compressed_pair_elem<allocator<unsigned short>, 1, true>__compressed_pair_elem<allocator<unsigned short>, 1, true> &const __compressed_pair_elem<allocator<unsigned short>, 1, true>const __compressed_pair_elem<allocator<unsigned short>, 1, true> &__compressed_pair_elem<unsigned short *, 0, false>__compressed_pair_elem<unsigned short *, 0, false> &const __compressed_pair_elem<unsigned short *, 0, false>const __compressed_pair_elem<unsigned short *, 0, false> &unsigned short *constunsigned short *const &remove_volatile<unsigned int>remove_volatile<unsigned int> &const remove_volatile<unsigned int>const remove_volatile<unsigned int> &__add_lvalue_reference_impl<allocator<CrwSubDir *>, true>__add_lvalue_reference_impl<allocator<CrwSubDir *>, true> &const __add_lvalue_reference_impl<allocator<CrwSubDir *>, true>const __add_lvalue_reference_impl<allocator<CrwSubDir *>, true> &__compressed_pair_elem<allocator<CrwSubDir *>, 1, true>__compressed_pair_elem<allocator<CrwSubDir *>, 1, true> &const __compressed_pair_elem<allocator<CrwSubDir *>, 1, true>const __compressed_pair_elem<allocator<CrwSubDir *>, 1, true> &__compressed_pair_elem<CrwSubDir **, 0, false>__compressed_pair_elem<CrwSubDir **, 0, false> &const __compressed_pair_elem<CrwSubDir **, 0, false>const __compressed_pair_elem<CrwSubDir **, 0, false> &CrwSubDir **constCrwSubDir **const &remove_volatile<CiffComponent *>remove_volatile<CiffComponent *> &const remove_volatile<CiffComponent *>const remove_volatile<CiffComponent *> &remove_cv<const pair<unsigned int, unsigned int>>remove_cv<const pair<unsigned int, unsigned int>> &const remove_cv<const pair<unsigned int, unsigned int>>const remove_cv<const pair<unsigned int, unsigned int>> &remove_cv<const unsigned short>remove_cv<const unsigned short> &const remove_cv<const unsigned short>const remove_cv<const unsigned short> &__compressed_pair<unsigned char *, allocator<unsigned char> &>__compressed_pair<unsigned char *, allocator<unsigned char> &> &const __compressed_pair<unsigned char *, allocator<unsigned char> &>const __compressed_pair<unsigned char *, allocator<unsigned char> &> &remove_reference<allocator<unsigned char> &>remove_reference<allocator<unsigned char> &> &const remove_reference<allocator<unsigned char> &>const remove_reference<allocator<unsigned char> &> &add_lvalue_reference<allocator<unsigned char> &>add_lvalue_reference<allocator<unsigned char> &> &const add_lvalue_reference<allocator<unsigned char> &>const add_lvalue_reference<allocator<unsigned char> &> &__compressed_pair<pair<unsigned int, unsigned int> *, allocator<pair<unsigned int, unsigned int>> &>__compressed_pair<pair<unsigned int, unsigned int> *, allocator<pair<unsigned int, unsigned int>> &> &const __compressed_pair<pair<unsigned int, unsigned int> *, allocator<pair<unsigned int, unsigned int>> &>const __compressed_pair<pair<unsigned int, unsigned int> *, allocator<pair<unsigned int, unsigned int>> &> &remove_reference<allocator<pair<unsigned int, unsigned int>> &>remove_reference<allocator<pair<unsigned int, unsigned int>> &> &const remove_reference<allocator<pair<unsigned int, unsigned int>> &>const remove_reference<allocator<pair<unsigned int, unsigned int>> &> &add_lvalue_reference<allocator<pair<unsigned int, unsigned int>> &>add_lvalue_reference<allocator<pair<unsigned int, unsigned int>> &> &const add_lvalue_reference<allocator<pair<unsigned int, unsigned int>> &>const add_lvalue_reference<allocator<pair<unsigned int, unsigned int>> &> &__compressed_pair<CiffComponent **, allocator<CiffComponent *> &>__compressed_pair<CiffComponent **, allocator<CiffComponent *> &> &const __compressed_pair<CiffComponent **, allocator<CiffComponent *> &>const __compressed_pair<CiffComponent **, allocator<CiffComponent *> &> &remove_reference<allocator<CiffComponent *> &>remove_reference<allocator<CiffComponent *> &> &const remove_reference<allocator<CiffComponent *> &>const remove_reference<allocator<CiffComponent *> &> &add_lvalue_reference<allocator<CiffComponent *> &>add_lvalue_reference<allocator<CiffComponent *> &> &const add_lvalue_reference<allocator<CiffComponent *> &>const add_lvalue_reference<allocator<CiffComponent *> &> &__compressed_pair_elem<allocator<CiffComponent *>, 1, true> *unsigned char *&&__compressed_pair_elem<unsigned char *, 0, false> *__compressed_pair_elem<pair<unsigned int, unsigned int> *, 0, false> *__split_buffer<CrwSubDir *, allocator<CrwSubDir *> &> *const __split_buffer<CrwSubDir *, allocator<CrwSubDir *> &>const __split_buffer<CrwSubDir *, allocator<CrwSubDir *> &> *CrwSubDir **&&unique_ptr<CrwSubDir *, __allocator_destructor<allocator<CrwSubDir>>> *const unique_ptr<CrwSubDir *, __allocator_destructor<allocator<CrwSubDir>>> *allocator<CrwSubDir *> *__compressed_pair<CrwSubDir **, allocator<CrwSubDir *>> *__compressed_pair_elem<allocator<CrwSubDir>, 1, true> *const __compressed_pair<unsigned long, allocator<CrwSubDir>> *__compressed_pair_elem<CiffComponent **, 0, false> *allocator<CiffComponent *> *__compressed_pair<unsigned short *, allocator<unsigned short>> *__split_buffer<unsigned short, allocator<unsigned short> &> *const __split_buffer<unsigned short, allocator<unsigned short> &>const __split_buffer<unsigned short, allocator<unsigned short> &> *__compressed_pair<unsigned int *, allocator<unsigned int>> *__split_buffer<unsigned int, allocator<unsigned int> &> *const __split_buffer<unsigned int, allocator<unsigned int> &>const __split_buffer<unsigned int, allocator<unsigned int> &> *remove_reference<CiffComponent **&>remove_reference<CiffComponent **&> &const remove_reference<CiffComponent **&>const remove_reference<CiffComponent **&> &is_trivially_destructible<CrwSubDir *>is_trivially_destructible<CrwSubDir *> &const is_trivially_destructible<CrwSubDir *>const is_trivially_destructible<CrwSubDir *> &remove_reference<CrwSubDir *&>remove_reference<CrwSubDir *&> &const remove_reference<CrwSubDir *&>const remove_reference<CrwSubDir *&> &__compressed_pair_elem<CrwSubDir *, 0, false>__compressed_pair_elem<CrwSubDir *, 0, false> &const __compressed_pair_elem<CrwSubDir *, 0, false>const __compressed_pair_elem<CrwSubDir *, 0, false> &move_iterator<CrwSubDir **>move_iterator<CrwSubDir **> &const move_iterator<CrwSubDir **>const move_iterator<CrwSubDir **> &move_iterator<CrwSubDir **> *remove_reference<CrwSubDir **&>remove_reference<CrwSubDir **&> &const remove_reference<CrwSubDir **&>const remove_reference<CrwSubDir **&> &remove_reference<unsigned char *&>remove_reference<unsigned char *&> &const remove_reference<unsigned char *&>const remove_reference<unsigned char *&> &__add_lvalue_reference_impl<allocator<CiffComponent *> &, true>__add_lvalue_reference_impl<allocator<CiffComponent *> &, true> &const __add_lvalue_reference_impl<allocator<CiffComponent *> &, true>const __add_lvalue_reference_impl<allocator<CiffComponent *> &, true> &__compressed_pair_elem<allocator<CiffComponent *> &, 1, false>__compressed_pair_elem<allocator<CiffComponent *> &, 1, false> &const __compressed_pair_elem<allocator<CiffComponent *> &, 1, false>const __compressed_pair_elem<allocator<CiffComponent *> &, 1, false> &__add_lvalue_reference_impl<allocator<pair<unsigned int, unsigned int>> &, true>__add_lvalue_reference_impl<allocator<pair<unsigned int, unsigned int>> &, true> &const __add_lvalue_reference_impl<allocator<pair<unsigned int, unsigned int>> &, true>const __add_lvalue_reference_impl<allocator<pair<unsigned int, unsigned int>> &, true> &__compressed_pair_elem<allocator<pair<unsigned int, unsigned int>> &, 1, false>__compressed_pair_elem<allocator<pair<unsigned int, unsigned int>> &, 1, false> &const __compressed_pair_elem<allocator<pair<unsigned int, unsigned int>> &, 1, false>const __compressed_pair_elem<allocator<pair<unsigned int, unsigned int>> &, 1, false> &__add_lvalue_reference_impl<allocator<unsigned char> &, true>__add_lvalue_reference_impl<allocator<unsigned char> &, true> &const __add_lvalue_reference_impl<allocator<unsigned char> &, true>const __add_lvalue_reference_impl<allocator<unsigned char> &, true> &__compressed_pair_elem<allocator<unsigned char> &, 1, false>__compressed_pair_elem<allocator<unsigned char> &, 1, false> &const __compressed_pair_elem<allocator<unsigned char> &, 1, false>const __compressed_pair_elem<allocator<unsigned char> &, 1, false> &pointer_traits<CiffComponent **>pointer_traits<CiffComponent **> &const pointer_traits<CiffComponent **>const pointer_traits<CiffComponent **> &remove_volatile<unsigned short>remove_volatile<unsigned short> &const remove_volatile<unsigned short>const remove_volatile<unsigned short> &remove_volatile<pair<unsigned int, unsigned int>>remove_volatile<pair<unsigned int, unsigned int>> &const remove_volatile<pair<unsigned int, unsigned int>>const remove_volatile<pair<unsigned int, unsigned int>> &pointer_traits<CrwSubDir *>pointer_traits<CrwSubDir *> &const pointer_traits<CrwSubDir *>const pointer_traits<CrwSubDir *> &pointer_traits<const CrwSubDir **>pointer_traits<const CrwSubDir **> &const pointer_traits<const CrwSubDir **>const pointer_traits<const CrwSubDir **> &pointer_traits<CrwSubDir **>pointer_traits<CrwSubDir **> &const pointer_traits<CrwSubDir **>const pointer_traits<CrwSubDir **> &__is_referenceable<allocator<CrwSubDir *>>__is_referenceable<allocator<CrwSubDir *>> &const __is_referenceable<allocator<CrwSubDir *>>const __is_referenceable<allocator<CrwSubDir *>> &__compressed_pair<unsigned int *, allocator<unsigned int> &>__compressed_pair<unsigned int *, allocator<unsigned int> &> &const __compressed_pair<unsigned int *, allocator<unsigned int> &>const __compressed_pair<unsigned int *, allocator<unsigned int> &> &remove_reference<allocator<unsigned int> &>remove_reference<allocator<unsigned int> &> &const remove_reference<allocator<unsigned int> &>const remove_reference<allocator<unsigned int> &> &add_lvalue_reference<allocator<unsigned int> &>add_lvalue_reference<allocator<unsigned int> &> &const add_lvalue_reference<allocator<unsigned int> &>const add_lvalue_reference<allocator<unsigned int> &> &__compressed_pair<unsigned short *, allocator<unsigned short> &>__compressed_pair<unsigned short *, allocator<unsigned short> &> &const __compressed_pair<unsigned short *, allocator<unsigned short> &>const __compressed_pair<unsigned short *, allocator<unsigned short> &> &remove_reference<allocator<unsigned short> &>remove_reference<allocator<unsigned short> &> &const remove_reference<allocator<unsigned short> &>const remove_reference<allocator<unsigned short> &> &add_lvalue_reference<allocator<unsigned short> &>add_lvalue_reference<allocator<unsigned short> &> &const add_lvalue_reference<allocator<unsigned short> &>const add_lvalue_reference<allocator<unsigned short> &> &__compressed_pair<CrwSubDir **, allocator<CrwSubDir *> &>__compressed_pair<CrwSubDir **, allocator<CrwSubDir *> &> &const __compressed_pair<CrwSubDir **, allocator<CrwSubDir *> &>const __compressed_pair<CrwSubDir **, allocator<CrwSubDir *> &> &remove_reference<allocator<CrwSubDir *> &>remove_reference<allocator<CrwSubDir *> &> &const remove_reference<allocator<CrwSubDir *> &>const remove_reference<allocator<CrwSubDir *> &> &add_lvalue_reference<allocator<CrwSubDir *> &>add_lvalue_reference<allocator<CrwSubDir *> &> &const add_lvalue_reference<allocator<CrwSubDir *> &>const add_lvalue_reference<allocator<CrwSubDir *> &> &CrwSubDir ***__compressed_pair<CrwSubDir *, __allocator_destructor<allocator<CrwSubDir>>>__compressed_pair<CrwSubDir *, __allocator_destructor<allocator<CrwSubDir>>> &const __compressed_pair<CrwSubDir *, __allocator_destructor<allocator<CrwSubDir>>>const __compressed_pair<CrwSubDir *, __allocator_destructor<allocator<CrwSubDir>>> &__pointer<CrwSubDir *, __allocator_destructor<allocator<CrwSubDir>>, __allocator_destructor<allocator<CrwSubDir>>, true>__pointer<CrwSubDir *, __allocator_destructor<allocator<CrwSubDir>>, __allocator_destructor<allocator<CrwSubDir>>, true> &const __pointer<CrwSubDir *, __allocator_destructor<allocator<CrwSubDir>>, __allocator_destructor<allocator<CrwSubDir>>, true>const __pointer<CrwSubDir *, __allocator_destructor<allocator<CrwSubDir>>, __allocator_destructor<allocator<CrwSubDir>>, true> &__unique_ptr_deleter_sfinae<__allocator_destructor<allocator<CrwSubDir>>>__unique_ptr_deleter_sfinae<__allocator_destructor<allocator<CrwSubDir>>> &const __unique_ptr_deleter_sfinae<__allocator_destructor<allocator<CrwSubDir>>>const __unique_ptr_deleter_sfinae<__allocator_destructor<allocator<CrwSubDir>>> &__allocator_destructor<allocator<CrwSubDir>> &&sizeof(_Dest)const __compressed_pair<pair<unsigned int, unsigned int> *, allocator<pair<unsigned int, unsigned int>>> *__compressed_pair_elem<allocator<pair<unsigned int, unsigned int>>, 1, true> *allocator<pair<unsigned int, unsigned int>> *const __compressed_pair<unsigned int *, allocator<unsigned int>> *__compressed_pair_elem<allocator<unsigned int>, 1, true> *__compressed_pair_elem<unsigned int *, 0, false> *allocator<unsigned int> *const __compressed_pair<unsigned short *, allocator<unsigned short>> *__compressed_pair_elem<allocator<unsigned short>, 1, true> *__compressed_pair_elem<unsigned short *, 0, false> *const __compressed_pair<CiffComponent **, allocator<CiffComponent *>> *__compressed_pair<CiffComponent **, allocator<CiffComponent *> &> *const __compressed_pair<CrwSubDir **, allocator<CrwSubDir *>> *__compressed_pair_elem<allocator<CrwSubDir *>, 1, true> *const __compressed_pair<CrwSubDir *, __allocator_destructor<allocator<CrwSubDir>>> *__compressed_pair<CrwSubDir *, __allocator_destructor<allocator<CrwSubDir>>> *__compressed_pair<CrwSubDir **, allocator<CrwSubDir *> &> *__compressed_pair<pair<unsigned int, unsigned int> *, allocator<pair<unsigned int, unsigned int>> &> *allocator<unsigned char> *__compressed_pair<unsigned char *, allocator<unsigned char> &> *__compressed_pair_elem<allocator<unsigned char>, 1, true> *__iterator_traits_impl<move_iterator<CrwSubDir **>, true>__iterator_traits_impl<move_iterator<CrwSubDir **>, true> &const __iterator_traits_impl<move_iterator<CrwSubDir **>, true>const __iterator_traits_impl<move_iterator<CrwSubDir **>, true> &remove_reference<CrwSubDir *const &>remove_reference<CrwSubDir *const &> &const remove_reference<CrwSubDir *const &>const remove_reference<CrwSubDir *const &> &__unwrap_iter_impl<CrwSubDir **, true>__unwrap_iter_impl<CrwSubDir **, true> &const __unwrap_iter_impl<CrwSubDir **, true>const __unwrap_iter_impl<CrwSubDir **, true> &enable_if<true, CrwSubDir **>enable_if<true, CrwSubDir **> &const enable_if<true, CrwSubDir **>const enable_if<true, CrwSubDir **> &remove_reference<CrwSubDir *>remove_reference<CrwSubDir *> &const remove_reference<CrwSubDir *>const remove_reference<CrwSubDir *> &remove_reference<const allocator<unsigned short> &>remove_reference<const allocator<unsigned short> &> &const remove_reference<const allocator<unsigned short> &>const remove_reference<const allocator<unsigned short> &> &remove_reference<const allocator<unsigned int> &>remove_reference<const allocator<unsigned int> &> &const remove_reference<const allocator<unsigned int> &>const remove_reference<const allocator<unsigned int> &> &remove_reference<const allocator<pair<unsigned int, unsigned int>> &>remove_reference<const allocator<pair<unsigned int, unsigned int>> &> &const remove_reference<const allocator<pair<unsigned int, unsigned int>> &>const remove_reference<const allocator<pair<unsigned int, unsigned int>> &> &__has_pointer<__allocator_destructor<allocator<CrwSubDir>>, void>__has_pointer<__allocator_destructor<allocator<CrwSubDir>>, void> &const __has_pointer<__allocator_destructor<allocator<CrwSubDir>>, void>const __has_pointer<__allocator_destructor<allocator<CrwSubDir>>, void> &__compressed_pair_elem<__allocator_destructor<allocator<CrwSubDir>>, 1, false>__compressed_pair_elem<__allocator_destructor<allocator<CrwSubDir>>, 1, false> &const __compressed_pair_elem<__allocator_destructor<allocator<CrwSubDir>>, 1, false>const __compressed_pair_elem<__allocator_destructor<allocator<CrwSubDir>>, 1, false> &__add_lvalue_reference_impl<allocator<CrwSubDir *> &, true>__add_lvalue_reference_impl<allocator<CrwSubDir *> &, true> &const __add_lvalue_reference_impl<allocator<CrwSubDir *> &, true>const __add_lvalue_reference_impl<allocator<CrwSubDir *> &, true> &__compressed_pair_elem<allocator<CrwSubDir *> &, 1, false>__compressed_pair_elem<allocator<CrwSubDir *> &, 1, false> &const __compressed_pair_elem<allocator<CrwSubDir *> &, 1, false>const __compressed_pair_elem<allocator<CrwSubDir *> &, 1, false> &__add_lvalue_reference_impl<allocator<unsigned short> &, true>__add_lvalue_reference_impl<allocator<unsigned short> &, true> &const __add_lvalue_reference_impl<allocator<unsigned short> &, true>const __add_lvalue_reference_impl<allocator<unsigned short> &, true> &__compressed_pair_elem<allocator<unsigned short> &, 1, false>__compressed_pair_elem<allocator<unsigned short> &, 1, false> &const __compressed_pair_elem<allocator<unsigned short> &, 1, false>const __compressed_pair_elem<allocator<unsigned short> &, 1, false> &__add_lvalue_reference_impl<allocator<unsigned int> &, true>__add_lvalue_reference_impl<allocator<unsigned int> &, true> &const __add_lvalue_reference_impl<allocator<unsigned int> &, true>const __add_lvalue_reference_impl<allocator<unsigned int> &, true> &__compressed_pair_elem<allocator<unsigned int> &, 1, false>__compressed_pair_elem<allocator<unsigned int> &, 1, false> &const __compressed_pair_elem<allocator<unsigned int> &, 1, false>const __compressed_pair_elem<allocator<unsigned int> &, 1, false> &pointer_traits<unsigned short *>pointer_traits<unsigned short *> &const pointer_traits<unsigned short *>const pointer_traits<unsigned short *> &__is_referenceable<allocator<unsigned char> &>__is_referenceable<allocator<unsigned char> &> &const __is_referenceable<allocator<unsigned char> &>const __is_referenceable<allocator<unsigned char> &> &__is_referenceable<allocator<pair<unsigned int, unsigned int>> &>__is_referenceable<allocator<pair<unsigned int, unsigned int>> &> &const __is_referenceable<allocator<pair<unsigned int, unsigned int>> &>const __is_referenceable<allocator<pair<unsigned int, unsigned int>> &> &__is_referenceable<allocator<CiffComponent *> &>__is_referenceable<allocator<CiffComponent *> &> &const __is_referenceable<allocator<CiffComponent *> &>const __is_referenceable<allocator<CiffComponent *> &> &iterator_traits<CrwSubDir **>iterator_traits<CrwSubDir **> &const iterator_traits<CrwSubDir **>const iterator_traits<CrwSubDir **> &__non_trivial_if<true, allocator<CiffComponent *>> *const allocator<unsigned char> *const __compressed_pair<unsigned char *, allocator<unsigned char>> *const __compressed_pair<unsigned char *, allocator<unsigned char> &> *__compressed_pair_elem<allocator<unsigned char> &, 1, false> *const allocator<pair<unsigned int, unsigned int>> *const __compressed_pair<pair<unsigned int, unsigned int> *, allocator<pair<unsigned int, unsigned int>> &> *__compressed_pair_elem<allocator<pair<unsigned int, unsigned int>> &, 1, false> *__compressed_pair_elem<CrwSubDir **, 0, false> *const move_iterator<CrwSubDir **> *__compressed_pair_elem<CrwSubDir *, 0, false> *const __compressed_pair_elem<CrwSubDir *, 0, false> *const __compressed_pair_elem<CrwSubDir **, 0, false> *const allocator<CiffComponent *> *const __compressed_pair<CiffComponent **, allocator<CiffComponent *> &> *__compressed_pair_elem<allocator<CiffComponent *> &, 1, false> *const __compressed_pair_elem<CiffComponent **, 0, false> *__compressed_pair<unsigned short *, allocator<unsigned short> &> *const __compressed_pair_elem<allocator<unsigned short>, 1, true> *__compressed_pair<unsigned int *, allocator<unsigned int> &> *const __compressed_pair_elem<allocator<unsigned int>, 1, true> *const __compressed_pair_elem<allocator<pair<unsigned int, unsigned int>>, 1, true> *remove_cv<CrwSubDir *>remove_cv<CrwSubDir *> &const remove_cv<CrwSubDir *>const remove_cv<CrwSubDir *> &__is_referenceable<allocator<unsigned int> &>__is_referenceable<allocator<unsigned int> &> &const __is_referenceable<allocator<unsigned int> &>const __is_referenceable<allocator<unsigned int> &> &__is_referenceable<allocator<unsigned short> &>__is_referenceable<allocator<unsigned short> &> &const __is_referenceable<allocator<unsigned short> &>const __is_referenceable<allocator<unsigned short> &> &__is_referenceable<allocator<CrwSubDir *> &>__is_referenceable<allocator<CrwSubDir *> &> &const __is_referenceable<allocator<CrwSubDir *> &>const __is_referenceable<allocator<CrwSubDir *> &> &__non_trivial_if<true, allocator<pair<unsigned int, unsigned int>>> *__non_trivial_if<true, allocator<unsigned int>> *const allocator<unsigned int> *const __compressed_pair<unsigned int *, allocator<unsigned int> &> *__compressed_pair_elem<allocator<unsigned int> &, 1, false> *const __compressed_pair_elem<unsigned int *, 0, false> *__non_trivial_if<true, allocator<unsigned short>> *const allocator<unsigned short> *const __compressed_pair<unsigned short *, allocator<unsigned short> &> *__compressed_pair_elem<allocator<unsigned short> &, 1, false> *const __compressed_pair_elem<unsigned short *, 0, false> *const __compressed_pair_elem<allocator<CiffComponent *>, 1, true> *__non_trivial_if<true, allocator<CrwSubDir>> *const allocator<CrwSubDir> *const __compressed_pair<CrwSubDir **, allocator<CrwSubDir *> &> *__compressed_pair_elem<allocator<CrwSubDir *> &, 1, false> *const __compressed_pair_elem<pair<unsigned int, unsigned int> *, 0, false> *const __compressed_pair_elem<unsigned char *, 0, false> *const __compressed_pair_elem<allocator<unsigned char>, 1, true> *remove_volatile<CrwSubDir *>remove_volatile<CrwSubDir *> &const remove_volatile<CrwSubDir *>const remove_volatile<CrwSubDir *> &const allocator<CrwSubDir *> *__non_trivial_if<true, allocator<CrwSubDir *>> *__lhs_len/Users/owura/Repos/codeql_eval/proj_repos/Exiv2-exiv2-pull-962-commits-e925bc5addd881543fa503470c8a859e112cca62/exiv2/src/datasets.cppconst IptcKey *pos1pos0recIdconst DataSet *[4]DataSet *[4]const DataSet **DataSet **sizeof(records_)sizeof(records_[0])sizeof(records_)/sizeof(records_[0])const DataSet[58]DataSet[58]const DataSet[15]DataSet[15]const RecordInfo[3]RecordInfo[3]const RecordInfo *RecordInfo *uint16_t &"Unknown dataset"Unknown dataset0xffffffffIptcDataSets::invalidRecordunknownDataSetconst DataSet[]DataSet[]"Record Version""A binary number identifying the version of the Information " "Interchange Model, Part II, utilised by the provider. " "Version numbers are assigned by IPTC and NAA organizations.""Object Type""The Object Type is used to distinguish between different types " "of objects within the IIM. The first part is a number representing " "a language independent international reference to an Object Type " "followed by a colon separator. The second part, if used, is a text " "representation of the Object Type Number consisting of graphic " "characters plus spaces either in English or in the language of the " "service as indicated in tag <LanguageIdentifier>""Object Attribute""The Object Attribute defines the nature of the object " "independent of the Subject. The first part is a number representing " "a language independent international reference to an Object Attribute " "followed by a colon separator. The second part, if used, is a text " "representation of the Object Attribute Number consisting of graphic " "characters plus spaces either in English, or in the language of the " "service as indicated in tag <LanguageIdentifier>""Object Name""Used as a shorthand reference for the object. Changes to exist-ing " "data, such as updated stories or new crops on photos, should be " "identified in tag <EditStatus>.""Document Title""Edit Status""Status of the object data, according to the practice of the provider.""Editorial Update""Indicates the type of update that this object provides to a " "previous object. The link to the previous object is made using " "the tags <ARMIdentifier> and <ARMVersion>, according to the practices of the provider.""Urgency""Specifies the editorial urgency of content and not necessarily the " "envelope handling priority (see tag <EnvelopePriority>). The \"1\" " "is most urgent, \"5\" normal and \"8\" denotes the least-urgent copy.""Subject""The Subject Reference is a structured definition of the subject matter.""Category""Identifies the subject of the object data in the opinion of the provider. " "A list of categories will be maintained by a regional registry, " "where available, otherwise by the provider.""Supplemental Category""Supplemental categories further refine the subject of an " "object data. A supplemental category may include " "any of the recognised categories as used in tag <Category>. Otherwise, " "selection of supplemental categories are left to the provider.""Supplemental Categories""Fixture Id""Identifies object data that recurs often and predictably. Enables " "users to immediately find or recall such an object.""Keywords""Used to indicate specific information retrieval words. " "It is expected that a provider of various types of data that are related " "in subject matter uses the same keyword, enabling the receiving system " "or subsystems to search across all types of data for related material.""Location Code""Indicates the code of a country/geographical location referenced " "by the content of the object. Where ISO has established an appropriate " "country code under ISO 3166, that code will be used. When ISO 3166 does not " "adequately provide for identification of a location or a country, " "e.g. ships at sea, space, IPTC will assign an appropriate three-character " "code under the provisions of ISO 3166 to avoid conflicts.""Location Name""Provides a full, publishable name of a country/geographical " "location referenced by the content of the object, according to " "guidelines of the provider.""Release Date""Designates in the form CCYYMMDD the earliest date the " "provider intends the object to be used. Follows ISO 8601 standard.""Release Time""Designates in the form HHMMSS:HHMM the earliest time the " "provider intends the object to be used. Follows ISO 8601 standard.""Expiration Date""Designates in the form CCYYMMDD the latest date the provider " "or owner intends the object data to be used. Follows ISO 8601 standard.""ExpirationTime""Designates in the form HHMMSS:HHMM the latest time the " "provider or owner intends the object data to be used. Follows ISO 8601 standard.""Special Instructions""Other editorial instructions concerning the use of the object data, " "such as embargoes and warnings.""Instructions""Action Advised""Indicates the type of action that this object provides to a " "previous object. The link to the previous object is made using " "tags <ARMIdentifier> and <ARMVersion>, according to the practices of the provider.""Reference Service""Identifies the Service Identifier of a prior envelope to which the " "current object refers.""Reference Date""Identifies the date of a prior envelope to which the current object refers.""Reference Number""Identifies the Envelope Number of a prior envelope to which the current object refers.""Date Created""Represented in the form CCYYMMDD to designate the date the " "intellectual content of the object data was created rather than the " "date of the creation of the physical representation. Follows ISO 8601 standard.""Time Created""Represented in the form HHMMSS:HHMM to designate the " "time the intellectual content of the object data current source " "material was created rather than the creation of the physical " "representation. Follows ISO 8601 standard.""Digitization Date""Represented in the form CCYYMMDD to designate the date the " "digital representation of the object data was created. Follows ISO 8601 standard.""Digitization Time""Represented in the form HHMMSS:HHMM to designate the " "time the digital representation of the object data was created. " "Follows ISO 8601 standard.""Program""Identifies the type of program used to originate the object data.""Program Version""Used to identify the version of the program mentioned in tag <Program>.""Object Cycle""Used to identify the editorial cycle of object data.""By-line""Contains name of the creator of the object data, e.g. writer, photographer " "or graphic artist.""Author""By-line Title""A by-line title is the title of the creator or creators of an " "object data. Where used, a by-line title should follow the by-line it modifies.""City""Identifies city of object data origin according to guidelines established " "by the provider.""Sub Location""Identifies the location within a city from which the object data " "originates, according to guidelines established by the provider.""Province State""Identifies Province/State of origin according to guidelines " "established by the provider.""State/Province""Country Code""Indicates the code of the country/primary location where the " "intellectual property of the object data was created, e.g. a photo " "was taken, an event occurred. Where ISO has established an appropriate " "country code under ISO 3166, that code will be used. When ISO 3166 does not " "adequately provide for identification of a location or a new " "country, e.g. ships at sea, space, IPTC will assign an " "appropriate three-character code under the provisions of " "ISO 3166 to avoid conflicts.""Country Name""Provides full, publishable, name of the country/primary location " "where the intellectual property of the object data was created, " "according to guidelines of the provider.""Country""Transmission Reference""A code representing the location of original transmission according " "to practices of the provider.""Headline""A publishable entry providing a synopsis of the contents of the object data.""Credit""Identifies the provider of the object data, not necessarily the owner/creator.""Source""Identifies the original owner of the intellectual content of the " "object data. This could be an agency, a member of an agency or an individual.""Contains any necessary copyright notice.""Copyright Notice""Contact""Identifies the person or organisation which can provide further " "background information on the object data.""Caption""A textual description of the object data.""Description""Writer""Identification of the name of the person involved in the writing, " "editing or correcting the object data or caption/abstract.""Rasterized Caption""Contains the rasterized object data description and is used " "where characters that have not been coded are required for the caption.""Indicates the color components of an image.""Image Orientation""Indicates the layout of an image.""Language""Describes the major national language of the object, according " "to the 2-letter codes of ISO 639:1988. Does not define or imply " "any coded character set, but is used for internal routing, e.g. to " "various editorial desks.""Audio Type""Indicates the type of an audio content.""Audio Rate""Indicates the sampling rate in Hertz of an audio content.""Audio Resolution""Indicates the sampling resolution of an audio content.""Audio Duration""Indicates the duration of an audio content.""Audio Outcue""Identifies the content of the end of an audio object data, " "according to guidelines established by the provider.""Preview Format""A binary number representing the file format of the object data " "preview. The file format must be registered with IPTC or NAA organizations " "with a unique number assigned to it.""Preview Version""A binary number representing the particular version of the " "object data preview file format specified in tag <PreviewFormat>.""Preview Data""Binary image preview data.""(Invalid)"IptcDataSets::RecordVersion"RecordVersion"Record VersionA binary number identifying the version of the Information Interchange Model, Part II, utilised by the provider. Version numbers are assigned by IPTC and NAA organizations.const char[173]char[173]IptcDataSets::ObjectType"ObjectType"Object TypeThe Object Type is used to distinguish between different types of objects within the IIM. The first part is a number representing a language independent international reference to an Object Type followed by a colon separator. The second part, if used, is a text representation of the Object Type Number consisting of graphic characters plus spaces either in English or in the language of the service as indicated in tag <LanguageIdentifier>const char[441]char[441]IptcDataSets::ObjectAttribute"ObjectAttribute"Object AttributeThe Object Attribute defines the nature of the object independent of the Subject. The first part is a number representing a language independent international reference to an Object Attribute followed by a colon separator. The second part, if used, is a text representation of the Object Attribute Number consisting of graphic characters plus spaces either in English, or in the language of the service as indicated in tag <LanguageIdentifier>const char[444]char[444]IptcDataSets::ObjectName"ObjectName"Object NameUsed as a shorthand reference for the object. Changes to exist-ing data, such as updated stories or new crops on photos, should be identified in tag <EditStatus>.const char[163]char[163]Document TitleIptcDataSets::EditStatus"EditStatus"Edit StatusStatus of the object data, according to the practice of the provider.const char[70]char[70]IptcDataSets::EditorialUpdate"EditorialUpdate"Editorial UpdateIndicates the type of update that this object provides to a previous object. The link to the previous object is made using the tags <ARMIdentifier> and <ARMVersion>, according to the practices of the provider.const char[210]char[210]IptcDataSets::UrgencySpecifies the editorial urgency of content and not necessarily the envelope handling priority (see tag <EnvelopePriority>). The "1" is most urgent, "5" normal and "8" denotes the least-urgent copy.const char[198]char[198]IptcDataSets::SubjectThe Subject Reference is a structured definition of the subject matter.const char[72]char[72]IptcDataSets::CategoryIdentifies the subject of the object data in the opinion of the provider. A list of categories will be maintained by a regional registry, where available, otherwise by the provider.const char[182]char[182]IptcDataSets::SuppCategory"SuppCategory"Supplemental CategorySupplemental categories further refine the subject of an object data. A supplemental category may include any of the recognised categories as used in tag <Category>. Otherwise, selection of supplemental categories are left to the provider.const char[240]char[240]Supplemental CategoriesIptcDataSets::FixtureId"FixtureId"Fixture IdIdentifies object data that recurs often and predictably. Enables users to immediately find or recall such an object.const char[118]char[118]IptcDataSets::KeywordsUsed to indicate specific information retrieval words. It is expected that a provider of various types of data that are related in subject matter uses the same keyword, enabling the receiving system or subsystems to search across all types of data for related material.const char[270]char[270]IptcDataSets::LocationCode"LocationCode"Location CodeIndicates the code of a country/geographical location referenced by the content of the object. Where ISO has established an appropriate country code under ISO 3166, that code will be used. When ISO 3166 does not adequately provide for identification of a location or a country, e.g. ships at sea, space, IPTC will assign an appropriate three-character code under the provisions of ISO 3166 to avoid conflicts.const char[410]char[410]IptcDataSets::LocationName"LocationName"Location NameProvides a full, publishable name of a country/geographical location referenced by the content of the object, according to guidelines of the provider.const char[151]char[151]IptcDataSets::ReleaseDate"ReleaseDate"Release DateDesignates in the form CCYYMMDD the earliest date the provider intends the object to be used. Follows ISO 8601 standard.const char[121]char[121]IptcDataSets::ReleaseTime"ReleaseTime"Release TimeDesignates in the form HHMMSS:HHMM the earliest time the provider intends the object to be used. Follows ISO 8601 standard.const char[124]char[124]IptcDataSets::ExpirationDate"ExpirationDate"Expiration DateDesignates in the form CCYYMMDD the latest date the provider or owner intends the object data to be used. Follows ISO 8601 standard.const char[133]char[133]IptcDataSets::ExpirationTimeDesignates in the form HHMMSS:HHMM the latest time the provider or owner intends the object data to be used. Follows ISO 8601 standard.IptcDataSets::SpecialInstructions"SpecialInstructions"Special InstructionsOther editorial instructions concerning the use of the object data, such as embargoes and warnings.const char[100]InstructionsIptcDataSets::ActionAdvised"ActionAdvised"Action AdvisedIndicates the type of action that this object provides to a previous object. The link to the previous object is made using tags <ARMIdentifier> and <ARMVersion>, according to the practices of the provider.const char[206]char[206]IptcDataSets::ReferenceService"ReferenceService"Reference ServiceIdentifies the Service Identifier of a prior envelope to which the current object refers.const char[90]char[90]IptcDataSets::ReferenceDate"ReferenceDate"Reference DateIdentifies the date of a prior envelope to which the current object refers.const char[76]char[76]IptcDataSets::ReferenceNumber"ReferenceNumber"Reference NumberIdentifies the Envelope Number of a prior envelope to which the current object refers.const char[87]char[87]IptcDataSets::DateCreated"DateCreated"Date CreatedRepresented in the form CCYYMMDD to designate the date the intellectual content of the object data was created rather than the date of the creation of the physical representation. Follows ISO 8601 standard.const char[207]char[207]IptcDataSets::TimeCreated"TimeCreated"Time CreatedRepresented in the form HHMMSS:HHMM to designate the time the intellectual content of the object data current source material was created rather than the creation of the physical representation. Follows ISO 8601 standard.const char[222]char[222]IptcDataSets::DigitizationDate"DigitizationDate"Digitization DateRepresented in the form CCYYMMDD to designate the date the digital representation of the object data was created. Follows ISO 8601 standard.const char[141]char[141]IptcDataSets::DigitizationTime"DigitizationTime"Digitization TimeRepresented in the form HHMMSS:HHMM to designate the time the digital representation of the object data was created. Follows ISO 8601 standard.const char[144]char[144]IptcDataSets::ProgramIdentifies the type of program used to originate the object data.IptcDataSets::ProgramVersion"ProgramVersion"Program VersionUsed to identify the version of the program mentioned in tag <Program>.IptcDataSets::ObjectCycle"ObjectCycle"Object CycleUsed to identify the editorial cycle of object data.IptcDataSets::Byline"Byline"By-lineContains name of the creator of the object data, e.g. writer, photographer or graphic artist.const char[94]char[94]AuthorIptcDataSets::BylineTitle"BylineTitle"By-line TitleA by-line title is the title of the creator or creators of an object data. Where used, a by-line title should follow the by-line it modifies.const char[142]char[142]Authors Position"Authors Position"IptcDataSets::CityIdentifies city of object data origin according to guidelines established by the provider.const char[91]char[91]IptcDataSets::SubLocation"SubLocation"Sub LocationIdentifies the location within a city from which the object data originates, according to guidelines established by the provider.const char[130]char[130]IptcDataSets::ProvinceState"ProvinceState"Province StateIdentifies Province/State of origin according to guidelines established by the provider.const char[89]char[89]State/ProvinceIptcDataSets::CountryCode"CountryCode"Country CodeIndicates the code of the country/primary location where the intellectual property of the object data was created, e.g. a photo was taken, an event occurred. Where ISO has established an appropriate country code under ISO 3166, that code will be used. When ISO 3166 does not adequately provide for identification of a location or a new country, e.g. ships at sea, space, IPTC will assign an appropriate three-character code under the provisions of ISO 3166 to avoid conflicts.const char[477]char[477]IptcDataSets::CountryName"CountryName"Country NameProvides full, publishable, name of the country/primary location where the intellectual property of the object data was created, according to guidelines of the provider.const char[170]char[170]CountryIptcDataSets::TransmissionReference"TransmissionReference"Transmission ReferenceA code representing the location of original transmission according to practices of the provider.const char[98]char[98]IptcDataSets::HeadlineA publishable entry providing a synopsis of the contents of the object data.const char[77]char[77]IptcDataSets::CreditIdentifies the provider of the object data, not necessarily the owner/creator.const char[79]char[79]IptcDataSets::SourceIdentifies the original owner of the intellectual content of the object data. This could be an agency, a member of an agency or an individual.const char[143]char[143]IptcDataSets::CopyrightContains any necessary copyright notice.Copyright NoticeIptcDataSets::ContactIdentifies the person or organisation which can provide further background information on the object data.const char[107]char[107]IptcDataSets::CaptionA textual description of the object data.DescriptionIptcDataSets::WriterIdentification of the name of the person involved in the writing, editing or correcting the object data or caption/abstract.const char[125]char[125]Description writer"Description writer"IptcDataSets::RasterizedCaption"RasterizedCaption"Rasterized CaptionContains the rasterized object data description and is used where characters that have not been coded are required for the caption.const char[132]char[132]7360IptcDataSets::ImageTypeIndicates the color components of an image.IptcDataSets::ImageOrientation"ImageOrientation"Image OrientationIndicates the layout of an image.IptcDataSets::LanguageDescribes the major national language of the object, according to the 2-letter codes of ISO 639:1988. Does not define or imply any coded character set, but is used for internal routing, e.g. to various editorial desks.const char[219]char[219]IptcDataSets::AudioType"AudioType"Audio TypeIndicates the type of an audio content.IptcDataSets::AudioRate"AudioRate"Audio RateIndicates the sampling rate in Hertz of an audio content.IptcDataSets::AudioResolution"AudioResolution"Audio ResolutionIndicates the sampling resolution of an audio content.IptcDataSets::AudioDuration"AudioDuration"Audio DurationIndicates the duration of an audio content.IptcDataSets::AudioOutcue"AudioOutcue"Audio OutcueIdentifies the content of the end of an audio object data, according to guidelines established by the provider.const char[112]char[112]IptcDataSets::PreviewFormat"PreviewFormat"Preview FormatA binary number representing the file format of the object data preview. The file format must be registered with IPTC or NAA organizations with a unique number assigned to it.const char[176]char[176]IptcDataSets::PreviewVersion"PreviewVersion"Preview VersionA binary number representing the particular version of the object data preview file format specified in tag <PreviewFormat>.IptcDataSets::PreviewPreview DataBinary image preview data.256000(Invalid)application2Record"Model Version""A binary number identifying the version of the Information " "Interchange Model, Part I, utilised by the provider. Version " "numbers are assigned by IPTC and NAA organizations.""This DataSet is to accommodate some providers who require " "routing information above the appropriate OSI layers.""File Format""A binary number representing the file format. The file format " "must be registered with IPTC or NAA with a unique number " "assigned to it. The information is used to route " "the data to the appropriate system and to allow the receiving " "system to perform the appropriate actions there to.""File Version""A binary number representing the particular version of the File " "Format specified by <FileFormat> tag.""Service Id""Identifies the provider and product""Envelope Number""The characters form a number that will be unique for the date " "specified in <DateSent> tag and for the Service Identifier " "specified by <ServiceIdentifier> tag. " "If identical envelope numbers appear with the same date and " "with the same Service Identifier, records 2-9 must be unchanged " "from the original. This is not intended to be a sequential serial " "number reception check.""Product Id""Allows a provider to identify subsets of its overall service. Used " "to provide receiving organisation data on which to select, route, " "or otherwise handle data.""Envelope Priority""Specifies the envelope handling priority and not the editorial " "urgency (see <Urgency> tag). \"1\" indicates the most urgent, \"5\" " "the normal urgency, and \"8\" the least urgent copy. The numeral " "\"9\" indicates a User Defined Priority. The numeral \"0\" is reserved " "for future use.""Date Sent""Uses the format CCYYMMDD (century, year, month, day) as de-fined " "in ISO 8601 to indicate year, month and day the service sent the material.""Time Sent""Uses the format HHMMSS:HHMM where HHMMSS refers to " "local hour, minute and seconds and HHMM refers to hours and " "minutes ahead (+) or behind (-) Universal Coordinated Time as " "described in ISO 8601. This is the time the service sent the material.""Character Set""This tag consisting of one or more control functions used for the announcement, " "invocation or designation of coded character sets. The control functions follow " "the ISO 2022 standard and may consist of the escape control " "character and one or more graphic characters.""Unique Name Object""This tag provide a globally unique " "identification for objects as specified in the IIM, independent of " "provider and for any media form. The provider must ensure the " "UNO is unique. Objects with the same UNO are identical.""ARM Identifier""The DataSet identifies the Abstract Relationship Method identifier (ARM) " "which is described in a document registered by the originator of " "the ARM with the IPTC and NAA organizations.""ARM Version""This tag consisting of a binary number representing the particular " "version of the ARM specified by tag <ARMId>."IptcDataSets::ModelVersion"ModelVersion"Model VersionA binary number identifying the version of the Information Interchange Model, Part I, utilised by the provider. Version numbers are assigned by IPTC and NAA organizations.const char[172]char[172]IptcDataSets::envelopeIptcDataSets::DestinationThis DataSet is to accommodate some providers who require routing information above the appropriate OSI layers.IptcDataSets::FileFormat"FileFormat"File FormatA binary number representing the file format. The file format must be registered with IPTC or NAA with a unique number assigned to it. The information is used to route the data to the appropriate system and to allow the receiving system to perform the appropriate actions there to.const char[282]char[282]IptcDataSets::FileVersion"FileVersion"File VersionA binary number representing the particular version of the File Format specified by <FileFormat> tag.const char[102]char[102]IptcDataSets::ServiceId"ServiceId"Service IdIdentifies the provider and productIptcDataSets::EnvelopeNumber"EnvelopeNumber"Envelope NumberThe characters form a number that will be unique for the date specified in <DateSent> tag and for the Service Identifier specified by <ServiceIdentifier> tag. If identical envelope numbers appear with the same date and with the same Service Identifier, records 2-9 must be unchanged from the original. This is not intended to be a sequential serial number reception check.const char[373]char[373]IptcDataSets::ProductId"ProductId"Product IdAllows a provider to identify subsets of its overall service. Used to provide receiving organisation data on which to select, route, or otherwise handle data.const char[159]char[159]IptcDataSets::EnvelopePriority"EnvelopePriority"Envelope PrioritySpecifies the envelope handling priority and not the editorial urgency (see <Urgency> tag). "1" indicates the most urgent, "5" the normal urgency, and "8" the least urgent copy. The numeral "9" indicates a User Defined Priority. The numeral "0" is reserved for future use.const char[273]char[273]IptcDataSets::DateSent"DateSent"Date SentUses the format CCYYMMDD (century, year, month, day) as de-fined in ISO 8601 to indicate year, month and day the service sent the material.const char[140]char[140]IptcDataSets::TimeSent"TimeSent"Time SentUses the format HHMMSS:HHMM where HHMMSS refers to local hour, minute and seconds and HHMM refers to hours and minutes ahead (+) or behind (-) Universal Coordinated Time as described in ISO 8601. This is the time the service sent the material.const char[244]char[244]IptcDataSets::CharacterSet"CharacterSet"Character SetThis tag consisting of one or more control functions used for the announcement, invocation or designation of coded character sets. The control functions follow the ISO 2022 standard and may consist of the escape control character and one or more graphic characters.const char[266]char[266]IptcDataSets::UNO"UNO"Unique Name ObjectThis tag provide a globally unique identification for objects as specified in the IIM, independent of provider and for any media form. The provider must ensure the UNO is unique. Objects with the same UNO are identical.const char[220]char[220]IptcDataSets::ARMId"ARMId"ARM IdentifierThe DataSet identifies the Abstract Relationship Method identifier (ARM) which is described in a document registered by the originator of the ARM with the IPTC and NAA organizations.const char[183]char[183]IptcDataSets::ARMVersion"ARMVersion"ARM VersionThis tag consisting of a binary number representing the particular version of the ARM specified by tag <ARMId>.envelopeRecord"(invalid)""IIM envelope record""IIM application record 2"(invalid)IIM envelope recordApplication2"Application2"IIM application record 2// IptcKey::decomposeKey// Possibly translate hex name parts (0xabcd) to real names// Use the parts of the key to find dataSet and recordId// Get the family name, record name and dataSet name parts of the key// IptcDataSets::dataSetList// dataSetIdx checks the range of recordId// The record id is used as the index into the array.// Dataset lookup lists.This is an array with pointers to one list per IIM4 Record./*
  File:      datasets.cpp
  Author(s): Brad Schick (brad) <brad@robotbattle.com>
             Gilles Caulier (gc) <caulier dot gilles at gmail dot com>
  History:   24-Jul-04, brad: created
 */auto_ptr_ref<IptcKey>auto_ptr_ref<IptcKey> &const auto_ptr_ref<IptcKey>const auto_ptr_ref<IptcKey> &_String::nposauto_ptr<IptcKey> *operator std::__1::auto_ptr_ref<Exiv2::IptcKey>operator Exiv2::IptcKey *EASYACCESS_HPP_afPointfocalLengthserialNumbersubjectDistancefNumbermeteringModesceneCaptureTypecontrastsharpnesssaturationlensNamewhiteBalanceimageQualitymacroModesceneModeexposureModeflashBiasisoSpeed// EASYACCESS_HPP_//! Return the AF point//! Return the focal length setting//! Return the camera serial number//! Return the subject distance//! Return the F number//! Return the exposure time//! Return the camera model//! Return the camera make//! Return the metering mode setting//! Return the scene capture type//! Return the contrast level//! Return the sharpness level//! Return the saturation level//! Return the name of the lens used//! Return the white balance setting//! Return the image quality setting//! Return the macro mode setting//! Return the scene mode setting//! Return the exposure mode setting//! Return the flash bias value//! Return the ISO speed used to shoot the image//! Return the orientation of the image/*!
  @file    easyaccess.hpp
  @brief   Provides easy (high-level) access to some Exif meta data.
  @author  Carsten Pfeiffer <pfeiffer@kde.org>
  @date    28-Feb-09, gis: created
 *//Users/owura/Repos/codeql_eval/proj_repos/Exiv2-exiv2-pull-962-commits-e925bc5addd881543fa503470c8a859e112cca62/exiv2/src/easyaccess.cppSensKeyNameListSensKeyNameList &const SensKeyNameListconst SensKeyNameList &findMetadatumconst char *[22]char *[22]const char *(&)[22]char *(&)[22]EXV_COUNTOF(keys)Exif.CanonPi.AFPointsUsed"Exif.CanonPi.AFPointsUsed"Exif.CanonPi.AFPointsUsed20D"Exif.CanonPi.AFPointsUsed20D"Exif.CanonSi.AFPointUsed"Exif.CanonSi.AFPointUsed"Exif.CanonCs.AFPoint"Exif.CanonCs.AFPoint"Exif.MinoltaCs7D.AFPoints"Exif.MinoltaCs7D.AFPoints"Exif.Nikon1.AFFocusPos"Exif.Nikon1.AFFocusPos"Exif.NikonAf.AFPoint"Exif.NikonAf.AFPoint"Exif.NikonAf.AFPointsInFocus"Exif.NikonAf.AFPointsInFocus"Exif.NikonAf2.AFPointsUsed"Exif.NikonAf2.AFPointsUsed"Exif.NikonAf2.PrimaryAFPoint"Exif.NikonAf2.PrimaryAFPoint"Exif.OlympusFi.AFPoint"Exif.OlympusFi.AFPoint"Exif.Pentax.AFPoint"Exif.Pentax.AFPoint"Exif.Pentax.AFPointInFocus"Exif.Pentax.AFPointInFocus"Exif.PentaxDng.AFPoint"Exif.PentaxDng.AFPoint"Exif.PentaxDng.AFPointInFocus"Exif.PentaxDng.AFPointInFocus"Exif.Sony1Cs.LocalAFAreaPoint"Exif.Sony1Cs.LocalAFAreaPoint"Exif.Sony2Cs.LocalAFAreaPoint"Exif.Sony2Cs.LocalAFAreaPoint"Exif.Sony1Cs2.LocalAFAreaPoint"Exif.Sony1Cs2.LocalAFAreaPoint"Exif.Sony2Cs2.LocalAFAreaPoint"Exif.Sony2Cs2.LocalAFAreaPoint"Exif.Sony1MltCsA100.LocalAFAreaPoint"Exif.Sony1MltCsA100.LocalAFAreaPoint"Exif.Casio.AFPoint"Exif.Casio.AFPoint"Exif.Casio2.AFPointPosition"Exif.Casio2.AFPointPosition"const char *(&)[9]char *(&)[9]..(*)(..))[9]Exif.Image.FocalLength"Exif.Image.FocalLength"Exif.NikonLd2.FocalLength"Exif.NikonLd2.FocalLength"Exif.NikonLd3.FocalLength"Exif.NikonLd3.FocalLength"Exif.MinoltaCsNew.FocalLength"Exif.MinoltaCsNew.FocalLength"Exif.Pentax.FocalLength"Exif.Pentax.FocalLength"Exif.PentaxDng.FocalLength"Exif.PentaxDng.FocalLength"Exif.Casio2.FocalLength"Exif.Casio2.FocalLength"const char *(&)[7]char *(&)[7]..(*)(..))[7]Exif.Image.CameraSerialNumber"Exif.Image.CameraSerialNumber"Exif.Canon.SerialNumber"Exif.Canon.SerialNumber"Exif.Nikon3.SerialNumber"Exif.Nikon3.SerialNumber"Exif.Nikon3.SerialNO"Exif.Nikon3.SerialNO"Exif.Fujifilm.SerialNumber"Exif.Fujifilm.SerialNumber"Exif.Olympus.SerialNumber2"Exif.Olympus.SerialNumber2"Exif.Sigma.SerialNumber"Exif.Sigma.SerialNumber"const char *[14]char *[14]const char *(&)[14]char *(&)[14]..(*)(..))[14]Exif.Image.SubjectDistance"Exif.Image.SubjectDistance"Exif.MinoltaCsNew.FocusDistance"Exif.MinoltaCsNew.FocusDistance"Exif.Nikon1.FocusDistance"Exif.Nikon1.FocusDistance"Exif.Nikon3.FocusDistance"Exif.Nikon3.FocusDistance"Exif.NikonLd2.FocusDistance"Exif.NikonLd2.FocusDistance"Exif.NikonLd3.FocusDistance"Exif.NikonLd3.FocusDistance"Exif.Olympus.FocusDistance"Exif.Olympus.FocusDistance"Exif.OlympusFi.FocusDistance"Exif.OlympusFi.FocusDistance"Exif.Casio.ObjectDistance"Exif.Casio.ObjectDistance"Exif.Casio2.ObjectDistance"Exif.Casio2.ObjectDistance"const char *(&)[3]char *(&)[3]..(*)(..))[3]Exif.Image.FNumber"Exif.Image.FNumber"Exif.Samsung2.FNumber"Exif.Samsung2.FNumber"Exif.Image.ExposureTime"Exif.Image.ExposureTime"Exif.Samsung2.ExposureTime"Exif.Samsung2.ExposureTime"const char *[1]char *[1]const char *(&)[1]char *(&)[1]const char *(&)[4]char *(&)[4]..(*)(..))[4]Exif.Image.MeteringMode"Exif.Image.MeteringMode"Exif.CanonCs.MeteringMode"Exif.CanonCs.MeteringMode"Exif.Sony1MltCsA100.MeteringMode"Exif.Sony1MltCsA100.MeteringMode"const char *[2]char *[2]char(&)[2]const char *(&)[2]char *(&)[2]..(*)(..))[2]Exif.Olympus.SpecialMode"Exif.Olympus.SpecialMode"const char *[15]char *[15]const char *(&)[15]char *(&)[15]..(*)(..))[15]Exif.CanonCs.Contrast"Exif.CanonCs.Contrast"Exif.Fujifilm.Tone"Exif.Fujifilm.Tone"Exif.MinoltaCsNew.Contrast"Exif.MinoltaCsNew.Contrast"Exif.MinoltaCsOld.Contrast"Exif.MinoltaCsOld.Contrast"Exif.MinoltaCs7D.Contrast"Exif.MinoltaCs7D.Contrast"Exif.MinoltaCs5D.Contrast"Exif.MinoltaCs5D.Contrast"Exif.Olympus.Contrast"Exif.Olympus.Contrast"Exif.Panasonic.Contrast"Exif.Panasonic.Contrast"Exif.Pentax.Contrast"Exif.Pentax.Contrast"Exif.PentaxDng.Contrast"Exif.PentaxDng.Contrast"Exif.Sigma.Contrast"Exif.Sigma.Contrast"Exif.Casio.Contrast"Exif.Casio.Contrast"Exif.Casio2.Contrast"Exif.Casio2.Contrast"Exif.Casio2.Contrast2"Exif.Casio2.Contrast2"Exif.CanonCs.Sharpness"Exif.CanonCs.Sharpness"Exif.Fujifilm.Sharpness"Exif.Fujifilm.Sharpness"Exif.MinoltaCsNew.Sharpness"Exif.MinoltaCsNew.Sharpness"Exif.MinoltaCsOld.Sharpness"Exif.MinoltaCsOld.Sharpness"Exif.MinoltaCs7D.Sharpness"Exif.MinoltaCs7D.Sharpness"Exif.MinoltaCs5D.Sharpness"Exif.MinoltaCs5D.Sharpness"Exif.Olympus.SharpnessFactor"Exif.Olympus.SharpnessFactor"Exif.Panasonic.Sharpness"Exif.Panasonic.Sharpness"Exif.Pentax.Sharpness"Exif.Pentax.Sharpness"Exif.PentaxDng.Sharpness"Exif.PentaxDng.Sharpness"Exif.Sigma.Sharpness"Exif.Sigma.Sharpness"Exif.Casio.Sharpness"Exif.Casio.Sharpness"Exif.Casio2.Sharpness"Exif.Casio2.Sharpness"Exif.Casio2.Sharpness2"Exif.Casio2.Sharpness2"Exif.CanonCs.Saturation"Exif.CanonCs.Saturation"Exif.MinoltaCsNew.Saturation"Exif.MinoltaCsNew.Saturation"Exif.MinoltaCsOld.Saturation"Exif.MinoltaCsOld.Saturation"Exif.MinoltaCs7D.Saturation"Exif.MinoltaCs7D.Saturation"Exif.MinoltaCs5D.Saturation"Exif.MinoltaCs5D.Saturation"Exif.Fujifilm.Color"Exif.Fujifilm.Color"Exif.Nikon3.Saturation"Exif.Nikon3.Saturation"Exif.Panasonic.Saturation"Exif.Panasonic.Saturation"Exif.Pentax.Saturation"Exif.Pentax.Saturation"Exif.PentaxDng.Saturation"Exif.PentaxDng.Saturation"Exif.Sigma.Saturation"Exif.Sigma.Saturation"Exif.Casio.Saturation"Exif.Casio.Saturation"Exif.Casio2.Saturation"Exif.Casio2.Saturation"Exif.Casio2.Saturation2"Exif.Casio2.Saturation2"Exif.Photo.LensModel"Exif.Photo.LensModel"Exif.NikonLd1.LensIDNumber"Exif.NikonLd1.LensIDNumber"Exif.NikonLd2.LensIDNumber"Exif.NikonLd2.LensIDNumber"Exif.NikonLd3.LensIDNumber"Exif.NikonLd3.LensIDNumber"Exif.Pentax.LensType"Exif.Pentax.LensType"Exif.PentaxDng.LensType"Exif.PentaxDng.LensType"Exif.Minolta.LensID"Exif.Minolta.LensID"Exif.SonyMinolta.LensID"Exif.SonyMinolta.LensID"Exif.Sony1.LensID"Exif.Sony1.LensID"Exif.Sony2.LensID"Exif.Sony2.LensID"Exif.OlympusEq.LensType"Exif.OlympusEq.LensType"Exif.Panasonic.LensType"Exif.Panasonic.LensType"Exif.Samsung2.LensType"Exif.Samsung2.LensType"const char *[24]char *[24]const char *(&)[24]char *(&)[24]..(*)(..))[24]Exif.CanonSi.WhiteBalance"Exif.CanonSi.WhiteBalance"Exif.Fujifilm.WhiteBalance"Exif.Fujifilm.WhiteBalance"Exif.Sigma.WhiteBalance"Exif.Sigma.WhiteBalance"Exif.Nikon1.WhiteBalance"Exif.Nikon1.WhiteBalance"Exif.Nikon2.WhiteBalance"Exif.Nikon2.WhiteBalance"Exif.Nikon3.WhiteBalance"Exif.Nikon3.WhiteBalance"Exif.Olympus.WhiteBalance"Exif.Olympus.WhiteBalance"Exif.OlympusCs.WhiteBalance"Exif.OlympusCs.WhiteBalance"Exif.Panasonic.WhiteBalance"Exif.Panasonic.WhiteBalance"Exif.MinoltaCsOld.WhiteBalance"Exif.MinoltaCsOld.WhiteBalance"Exif.Minolta.WhiteBalance"Exif.Minolta.WhiteBalance"Exif.Sony1MltCsA100.WhiteBalance"Exif.Sony1MltCsA100.WhiteBalance"Exif.SonyMinolta.WhiteBalance"Exif.SonyMinolta.WhiteBalance"Exif.Sony1.WhiteBalance"Exif.Sony1.WhiteBalance"Exif.Sony2.WhiteBalance"Exif.Sony2.WhiteBalance"Exif.Sony1.WhiteBalance2"Exif.Sony1.WhiteBalance2"Exif.Sony2.WhiteBalance2"Exif.Sony2.WhiteBalance2"Exif.Casio.WhiteBalance"Exif.Casio.WhiteBalance"Exif.Casio2.WhiteBalance"Exif.Casio2.WhiteBalance"Exif.Casio2.WhiteBalance2"Exif.Casio2.WhiteBalance2"Exif.CanonCs.Quality"Exif.CanonCs.Quality"Exif.Sigma.Quality"Exif.Sigma.Quality"Exif.Nikon2.Quality"Exif.Nikon2.Quality"Exif.Olympus.Quality"Exif.Olympus.Quality"Exif.OlympusCs.Quality"Exif.OlympusCs.Quality"Exif.Panasonic.Quality"Exif.Panasonic.Quality"Exif.Minolta.Quality"Exif.Minolta.Quality"Exif.MinoltaCsNew.Quality"Exif.MinoltaCsNew.Quality"Exif.MinoltaCsOld.Quality"Exif.MinoltaCsOld.Quality"Exif.MinoltaCs5D.Quality"Exif.MinoltaCs5D.Quality"Exif.MinoltaCs7D.Quality"Exif.MinoltaCs7D.Quality"Exif.Sony1MltCsA100.Quality"Exif.Sony1MltCsA100.Quality"Exif.Sony1.JPEGQuality"Exif.Sony1.JPEGQuality"Exif.Sony1.Quality"Exif.Sony1.Quality"Exif.Sony1Cs.Quality"Exif.Sony1Cs.Quality"Exif.Sony2.JPEGQuality"Exif.Sony2.JPEGQuality"Exif.Sony2.Quality"Exif.Sony2.Quality"Exif.Sony2Cs.Quality"Exif.Sony2Cs.Quality"Exif.Casio.Quality"Exif.Casio.Quality"Exif.Casio2.QualityMode"Exif.Casio2.QualityMode"Exif.Casio2.Quality"Exif.Casio2.Quality"Exif.CanonCs.Macro"Exif.CanonCs.Macro"Exif.Fujifilm.Macro"Exif.Fujifilm.Macro"Exif.Olympus.Macro"Exif.Olympus.Macro"Exif.OlympusCs.MacroMode"Exif.OlympusCs.MacroMode"Exif.Panasonic.Macro"Exif.Panasonic.Macro"Exif.MinoltaCsNew.MacroMode"Exif.MinoltaCsNew.MacroMode"Exif.MinoltaCsOld.MacroMode"Exif.MinoltaCsOld.MacroMode"Exif.Sony1.Macro"Exif.Sony1.Macro"Exif.Sony2.Macro"Exif.Sony2.Macro"Exif.CanonCs.EasyMode"Exif.CanonCs.EasyMode"Exif.Fujifilm.PictureMode"Exif.Fujifilm.PictureMode"Exif.MinoltaCsNew.SubjectProgram"Exif.MinoltaCsNew.SubjectProgram"Exif.MinoltaCsOld.SubjectProgram"Exif.MinoltaCsOld.SubjectProgram"Exif.Minolta.SceneMode"Exif.Minolta.SceneMode"Exif.SonyMinolta.SceneMode"Exif.SonyMinolta.SceneMode"Exif.Sony1.SceneMode"Exif.Sony1.SceneMode"Exif.Sony2.SceneMode"Exif.Sony2.SceneMode"Exif.OlympusCs.SceneMode"Exif.OlympusCs.SceneMode"Exif.Panasonic.ShootingMode"Exif.Panasonic.ShootingMode"Exif.Panasonic.SceneMode"Exif.Panasonic.SceneMode"Exif.Pentax.PictureMode"Exif.Pentax.PictureMode"Exif.PentaxDng.PictureMode"Exif.PentaxDng.PictureMode"const char *[11]char *[11]const char *(&)[11]char *(&)[11]..(*)(..))[11]Exif.Image.ExposureProgram"Exif.Image.ExposureProgram"Exif.CanonCs.ExposureProgram"Exif.CanonCs.ExposureProgram"Exif.MinoltaCs7D.ExposureMode"Exif.MinoltaCs7D.ExposureMode"Exif.MinoltaCs5D.ExposureMode"Exif.MinoltaCs5D.ExposureMode"Exif.MinoltaCsNew.ExposureMode"Exif.MinoltaCsNew.ExposureMode"Exif.MinoltaCsOld.ExposureMode"Exif.MinoltaCsOld.ExposureMode"Exif.Sony1MltCsA100.ExposureMode"Exif.Sony1MltCsA100.ExposureMode"Exif.Sony1Cs.ExposureProgram"Exif.Sony1Cs.ExposureProgram"Exif.Sony2Cs.ExposureProgram"Exif.Sony2Cs.ExposureProgram"Exif.Sigma.ExposureMode"Exif.Sigma.ExposureMode"const char *(&)[8]char *(&)[8]..(*)(..))[8]Exif.CanonSi.FlashBias"Exif.CanonSi.FlashBias"Exif.Panasonic.FlashBias"Exif.Panasonic.FlashBias"Exif.Olympus.FlashBias"Exif.Olympus.FlashBias"Exif.OlympusCs.FlashExposureComp"Exif.OlympusCs.FlashExposureComp"Exif.Minolta.FlashExposureComp"Exif.Minolta.FlashExposureComp"Exif.SonyMinolta.FlashExposureComp"Exif.SonyMinolta.FlashExposureComp"Exif.Sony1.FlashExposureComp"Exif.Sony1.FlashExposureComp"Exif.Sony2.FlashExposureComp"Exif.Sony2.FlashExposureComp"const SensKeyNameList[]SensKeyNameList[]sensitivityKeysensitivityTypechar(&)[25]const char *[25]char *[25]const char *(&)[25]char *(&)[25]..(*)(..))[25]iso_valiso_tmp_valmd_stst_valconst SensKeyNameList *SensKeyNameList *sensKeysconst SensKeyNameList[7]SensKeyNameList[7]os_isoExif.Photo.SensitivityType"Exif.Photo.SensitivityType"Exif.Photo.StandardOutputSensitivity"Exif.Photo.StandardOutputSensitivity"Exif.Photo.RecommendedExposureIndex"Exif.Photo.RecommendedExposureIndex"Exif.Photo.ISOSpeed"Exif.Photo.ISOSpeed"Exif.Image.ISOSpeedRatings"Exif.Image.ISOSpeedRatings"Exif.CanonSi.ISOSpeed"Exif.CanonSi.ISOSpeed"Exif.CanonCs.ISOSpeed"Exif.CanonCs.ISOSpeed"Exif.Nikon1.ISOSpeed"Exif.Nikon1.ISOSpeed"Exif.Nikon2.ISOSpeed"Exif.Nikon2.ISOSpeed"Exif.Nikon3.ISOSpeed"Exif.Nikon3.ISOSpeed"Exif.NikonIi.ISO"Exif.NikonIi.ISO"Exif.NikonIi.ISO2"Exif.NikonIi.ISO2"Exif.MinoltaCsNew.ISOSetting"Exif.MinoltaCsNew.ISOSetting"Exif.MinoltaCsOld.ISOSetting"Exif.MinoltaCsOld.ISOSetting"Exif.MinoltaCs5D.ISOSpeed"Exif.MinoltaCs5D.ISOSpeed"Exif.MinoltaCs7D.ISOSpeed"Exif.MinoltaCs7D.ISOSpeed"Exif.Sony1Cs.ISOSetting"Exif.Sony1Cs.ISOSetting"Exif.Sony2Cs.ISOSetting"Exif.Sony2Cs.ISOSetting"Exif.Sony1Cs2.ISOSetting"Exif.Sony1Cs2.ISOSetting"Exif.Sony2Cs2.ISOSetting"Exif.Sony2Cs2.ISOSetting"Exif.Sony1MltCsA100.ISOSetting"Exif.Sony1MltCsA100.ISOSetting"Exif.Pentax.ISO"Exif.Pentax.ISO"Exif.PentaxDng.ISO"Exif.PentaxDng.ISO"Exif.Olympus.ISOSpeed"Exif.Olympus.ISOSpeed"Exif.Samsung2.ISO"Exif.Samsung2.ISO"Exif.Casio.ISO"Exif.Casio.ISO"Exif.Casio2.ISO"Exif.Casio2.ISO"Exif.Casio2.ISOSpeed"Exif.Casio2.ISOSpeed"Exif.Panasonic.Rotation"Exif.Panasonic.Rotation"Exif.MinoltaCs5D.Rotation"Exif.MinoltaCs5D.Rotation"Exif.MinoltaCs5D.Rotation2"Exif.MinoltaCs5D.Rotation2"Exif.MinoltaCs7D.Rotation"Exif.MinoltaCs7D.Rotation"Exif.Sony1MltCsA100.Rotation"Exif.Sony1MltCsA100.Rotation"Exif.Sony1Cs.Rotation"Exif.Sony1Cs.Rotation"Exif.Sony2Cs.Rotation"Exif.Sony2Cs.Rotation"Exif.Sony1Cs2.Rotation"Exif.Sony1Cs2.Rotation"Exif.Sony2Cs2.Rotation"Exif.Sony2Cs2.Rotation"// Try Exif.CanonCs.LensType first.// Exif.Canon.LensModel only reports focal length.// something wrong with the value// them available.// pick up list of ISO tags, and check for at least one of// SensivityType out of range or cannot be parsed properly// otherwise pick up actual value and grab value accordingly// no SensitivityType? exit with existing data// ISO value (see EXIF 2.3 Annex G)// ISO tag at all. Check for SensitivityType tag and the referenced// there is either a possible ISO "overflow" or no legacy// Find the first ISO value which is not "0"// existing as a tag) are picked up first and used as the "ISO" value.// ISO do differ in their meaning. Values coming first in a list (and// covers Exif.Phot.SensitivityType values 1-7. Note that SOS, REI and// anonymous namespace// findMetadatum/*!
      @brief Search \em ed for a Metadatum specified by the \em keys.
             The \em keys are searched in the order of their appearance, the
             first available Metadatum is returned.

      @param ed The %Exif metadata container to search
      @param keys Array of keys to look for
      @param count Number of elements in the array
     *//*
  File:      easyaccess.cpp
 */<__utility/declval.h>_ForwardIterator1_ForwardIterator2iter_swap_LIBCPP___ALGORITHM_ITER_SWAP_H_NOEXCEPT_(swap(*declval<_ForwardIterator1>(), *declval<_ForwardIterator2>()))// _LIBCPP___ALGORITHM_ITER_SWAP_H//                                  _NOEXCEPT_(_NOEXCEPT_(swap(*__a, *__b)))<__algorithm/iter_swap.h>_BidirectionalIterator_RandomAccessIterator__reverse_LIBCPP___ALGORITHM_REVERSE_H// _LIBCPP___ALGORITHM_REVERSE_H<__algorithm/unwrap_iter.h><__algorithm/partial_sort.h><__algorithm/min_element.h><__algorithm/comp_ref_type.h><__algorithm/comp.h>_Tp **__less<_Tp *, _Tp *> &__insertion_sort_move__insertion_sort__selection_sort_LIBCPP___ALGORITHM_SORT_H_LIBCPP_FUNC_VIS unsigned __sort5<__less<long double>&, long double*>(long double*, long double*, long double*, long double*, long double*, __less<long double>&)__attribute__ ((__visibility__("default"))) unsigned __sort5<__less<long double>&, long double*>(long double*, long double*, long double*, long double*, long double*, __less<long double>&)_LIBCPP_FUNC_VIS bool __insertion_sort_incomplete<__less<long double>&, long double*>(long double*, long double*, __less<long double>&)__attribute__ ((__visibility__("default"))) bool __insertion_sort_incomplete<__less<long double>&, long double*>(long double*, long double*, __less<long double>&)_LIBCPP_FUNC_VIS bool __insertion_sort_incomplete<__less<double>&, double*>(double*, double*, __less<double>&)__attribute__ ((__visibility__("default"))) bool __insertion_sort_incomplete<__less<double>&, double*>(double*, double*, __less<double>&)_LIBCPP_FUNC_VIS bool __insertion_sort_incomplete<__less<float>&, float*>(float*, float*, __less<float>&)__attribute__ ((__visibility__("default"))) bool __insertion_sort_incomplete<__less<float>&, float*>(float*, float*, __less<float>&)_LIBCPP_FUNC_VIS bool __insertion_sort_incomplete<__less<unsigned long long>&, unsigned long long*>(unsigned long long*, unsigned long long*, __less<unsigned long long>&)__attribute__ ((__visibility__("default"))) bool __insertion_sort_incomplete<__less<unsigned long long>&, unsigned long long*>(unsigned long long*, unsigned long long*, __less<unsigned long long>&)_LIBCPP_FUNC_VIS bool __insertion_sort_incomplete<__less<long long>&, long long*>(long long*, long long*, __less<long long>&)__attribute__ ((__visibility__("default"))) bool __insertion_sort_incomplete<__less<long long>&, long long*>(long long*, long long*, __less<long long>&)_LIBCPP_FUNC_VIS bool __insertion_sort_incomplete<__less<unsigned long>&, unsigned long*>(unsigned long*, unsigned long*, __less<unsigned long>&)__attribute__ ((__visibility__("default"))) bool __insertion_sort_incomplete<__less<unsigned long>&, unsigned long*>(unsigned long*, unsigned long*, __less<unsigned long>&)_LIBCPP_FUNC_VIS bool __insertion_sort_incomplete<__less<long>&, long*>(long*, long*, __less<long>&)__attribute__ ((__visibility__("default"))) bool __insertion_sort_incomplete<__less<long>&, long*>(long*, long*, __less<long>&)_LIBCPP_FUNC_VIS bool __insertion_sort_incomplete<__less<unsigned>&, unsigned*>(unsigned*, unsigned*, __less<unsigned>&)__attribute__ ((__visibility__("default"))) bool __insertion_sort_incomplete<__less<unsigned>&, unsigned*>(unsigned*, unsigned*, __less<unsigned>&)_LIBCPP_FUNC_VIS bool __insertion_sort_incomplete<__less<int>&, int*>(int*, int*, __less<int>&)__attribute__ ((__visibility__("default"))) bool __insertion_sort_incomplete<__less<int>&, int*>(int*, int*, __less<int>&)_LIBCPP_FUNC_VIS bool __insertion_sort_incomplete<__less<unsigned short>&, unsigned short*>(unsigned short*, unsigned short*, __less<unsigned short>&)__attribute__ ((__visibility__("default"))) bool __insertion_sort_incomplete<__less<unsigned short>&, unsigned short*>(unsigned short*, unsigned short*, __less<unsigned short>&)_LIBCPP_FUNC_VIS bool __insertion_sort_incomplete<__less<short>&, short*>(short*, short*, __less<short>&)__attribute__ ((__visibility__("default"))) bool __insertion_sort_incomplete<__less<short>&, short*>(short*, short*, __less<short>&)_LIBCPP_FUNC_VIS bool __insertion_sort_incomplete<__less<unsigned char>&, unsigned char*>(unsigned char*, unsigned char*, __less<unsigned char>&)__attribute__ ((__visibility__("default"))) bool __insertion_sort_incomplete<__less<unsigned char>&, unsigned char*>(unsigned char*, unsigned char*, __less<unsigned char>&)_LIBCPP_FUNC_VIS bool __insertion_sort_incomplete<__less<signed char>&, signed char*>(signed char*, signed char*, __less<signed char>&)__attribute__ ((__visibility__("default"))) bool __insertion_sort_incomplete<__less<signed char>&, signed char*>(signed char*, signed char*, __less<signed char>&)_LIBCPP_FUNC_VIS bool __insertion_sort_incomplete<__less<wchar_t>&, wchar_t*>(wchar_t*, wchar_t*, __less<wchar_t>&)__attribute__ ((__visibility__("default"))) bool __insertion_sort_incomplete<__less<wchar_t>&, wchar_t*>(wchar_t*, wchar_t*, __less<wchar_t>&)_LIBCPP_FUNC_VIS bool __insertion_sort_incomplete<__less<char>&, char*>(char*, char*, __less<char>&)__attribute__ ((__visibility__("default"))) bool __insertion_sort_incomplete<__less<char>&, char*>(char*, char*, __less<char>&)_LIBCPP_FUNC_VIS void __sort<__less<long double>&, long double*>(long double*, long double*, __less<long double>&)__attribute__ ((__visibility__("default"))) void __sort<__less<long double>&, long double*>(long double*, long double*, __less<long double>&)_LIBCPP_FUNC_VIS void __sort<__less<double>&, double*>(double*, double*, __less<double>&)__attribute__ ((__visibility__("default"))) void __sort<__less<double>&, double*>(double*, double*, __less<double>&)_LIBCPP_FUNC_VIS void __sort<__less<float>&, float*>(float*, float*, __less<float>&)__attribute__ ((__visibility__("default"))) void __sort<__less<float>&, float*>(float*, float*, __less<float>&)_LIBCPP_FUNC_VIS void __sort<__less<unsigned long long>&, unsigned long long*>(unsigned long long*, unsigned long long*, __less<unsigned long long>&)__attribute__ ((__visibility__("default"))) void __sort<__less<unsigned long long>&, unsigned long long*>(unsigned long long*, unsigned long long*, __less<unsigned long long>&)_LIBCPP_FUNC_VIS void __sort<__less<long long>&, long long*>(long long*, long long*, __less<long long>&)__attribute__ ((__visibility__("default"))) void __sort<__less<long long>&, long long*>(long long*, long long*, __less<long long>&)_LIBCPP_FUNC_VIS void __sort<__less<unsigned long>&, unsigned long*>(unsigned long*, unsigned long*, __less<unsigned long>&)__attribute__ ((__visibility__("default"))) void __sort<__less<unsigned long>&, unsigned long*>(unsigned long*, unsigned long*, __less<unsigned long>&)_LIBCPP_FUNC_VIS void __sort<__less<long>&, long*>(long*, long*, __less<long>&)__attribute__ ((__visibility__("default"))) void __sort<__less<long>&, long*>(long*, long*, __less<long>&)_LIBCPP_FUNC_VIS void __sort<__less<unsigned>&, unsigned*>(unsigned*, unsigned*, __less<unsigned>&)__attribute__ ((__visibility__("default"))) void __sort<__less<unsigned>&, unsigned*>(unsigned*, unsigned*, __less<unsigned>&)_LIBCPP_FUNC_VIS void __sort<__less<int>&, int*>(int*, int*, __less<int>&)__attribute__ ((__visibility__("default"))) void __sort<__less<int>&, int*>(int*, int*, __less<int>&)_LIBCPP_FUNC_VIS void __sort<__less<unsigned short>&, unsigned short*>(unsigned short*, unsigned short*, __less<unsigned short>&)__attribute__ ((__visibility__("default"))) void __sort<__less<unsigned short>&, unsigned short*>(unsigned short*, unsigned short*, __less<unsigned short>&)_LIBCPP_FUNC_VIS void __sort<__less<short>&, short*>(short*, short*, __less<short>&)__attribute__ ((__visibility__("default"))) void __sort<__less<short>&, short*>(short*, short*, __less<short>&)_LIBCPP_FUNC_VIS void __sort<__less<unsigned char>&, unsigned char*>(unsigned char*, unsigned char*, __less<unsigned char>&)__attribute__ ((__visibility__("default"))) void __sort<__less<unsigned char>&, unsigned char*>(unsigned char*, unsigned char*, __less<unsigned char>&)_LIBCPP_FUNC_VIS void __sort<__less<signed char>&, signed char*>(signed char*, signed char*, __less<signed char>&)__attribute__ ((__visibility__("default"))) void __sort<__less<signed char>&, signed char*>(signed char*, signed char*, __less<signed char>&)_LIBCPP_FUNC_VIS void __sort<__less<wchar_t>&, wchar_t*>(wchar_t*, wchar_t*, __less<wchar_t>&)__attribute__ ((__visibility__("default"))) void __sort<__less<wchar_t>&, wchar_t*>(wchar_t*, wchar_t*, __less<wchar_t>&)_LIBCPP_FUNC_VIS void __sort<__less<char>&, char*>(char*, char*, __less<char>&)__attribute__ ((__visibility__("default"))) void __sort<__less<char>&, char*>(char*, char*, __less<char>&)// _LIBCPP___ALGORITHM_SORT_H// _VSTD::__sort<_Compare>(__first, __i, __comp);// _VSTD::__sort<_Compare>(__i+1, __last, __comp);// sort smaller range with recursive call and larger with tail recursion elimination// If we were given a perfect partition, see if insertion sort is quick...// [__first, __i) < *__i and *__i <= [__i+1, __last)// [__first, __i) < *__m and *__m <= [__i, __last)// If __m just moved, follow it// It is known that __m != __j// It is now known that a guard exists for downward moving __j// __m still guards upward moving __i// known that __i <= __m// known that *(__i - 1) < *__m// if not yet partitioned...// j points beyond range to be tested, *__m is known to be <= *__lm1// It is known that *__i < *__m// found guard for downward moving __j, now use unguarded partition// _VSTD::__sort<_Compare>(__i, __last, __comp);// The first part is sorted, sort the second part// [__first, __i) == *__first and *__first < [__i, __last)// [__first, __i) == *__first and *__first < [__j, __last) and __j == __last - 1// [__first, __last) all equivalent elements// we need a guard if *__first == *(__last-1)// __first + 1// Parition instead into [__first, __i) == *__first and *__first < [__i, __last)// *__first == *__m, *__m <= all other elements// manually guard downward moving __j against __i// *__first == *__m, *__first doesn't go in first part// if *__first == *__m// Prime the downward search with a guard.// The search going up is known to be guarded but the search coming down isn't.// (this inhibits tossing elements equivalent to __m around unnecessarily)// partition [__first, __m) < *__m and *__m <= [__m, __last)// *__m is median// __len > 5// Assumes size > 0// stable, 4-10 compares, 0-9 swaps// stable, 3-6 compares, 0-5 swaps// x <= y && y <= z// x <= y && y < z// if y > z// x < y && x <= z// x > y && y <= z// x < y && y < z// x > y, if y > z// x < y && y <= z// if x > y// x <= z && y < z// x <= y && y > z// if y <= z// if x <= y// stable, 2-3 compares, 0-2 swaps~EpsImageEpsImage *EpsImage &const EpsImageconst EpsImage &EpsImageepsEPSIMAGE_HPP_isEpsTypenewEpsInstanceconst EpsImage *// #ifndef EPSIMAGE_HPP_//! Check if the file iIo is a EPS image./*!
      @brief Create a new EpsImage instance and return an auto-pointer to it.
             Caller owns the returned object and the auto-pointer ensures that
             it will be deleted.
     */// class EpsImage/*!
          @brief Not supported.
              Calling this function will throw an instance of Error(kerInvalidSettingForImage).
         *//*!
          @brief Constructor to open a EPS image. Since the
              constructor can't return a result, callers should check the
              good() method after object construction to determine success
              or failure.
          @param io An auto-pointer that owns a BasicIo instance used for
              reading and writing image metadata. \b Important: The constructor
              takes ownership of the passed in BasicIo instance through the
              auto-pointer. Callers should not continue to use the BasicIo
              instance after it is passed to this method.  Use the Image::io()
              method to get a temporary reference.
          @param create Specifies if an existing image should be read (false)
              or if a new file should be created (true).
         *//*!
      @brief Class to access EPS images.
     *///!< EPS image type// Add EPS to the supported image formats/*!
  @file    epsimage.hpp
  @brief   EPS image.
           <br>References:
           <br>[1] <a href="http://partners.adobe.com/public/developer/en/ps/5001.DSC_Spec.pdf">Adobe PostScript Language Document Structuring Conventions Specification, Version 3.0</a>, September 1992
           <br>[2] <a href="http://partners.adobe.com/public/developer/en/ps/5002.EPSF_Spec.pdf">Adobe Encapsulated PostScript File Format Specification, Version 3.0</a>, May 1992
           <br>[3] <a href="http://www.adobe.com/content/dam/Adobe/en/devnet/xmp/pdfs/XMPSpecificationPart3.pdf">Adobe XMP Specification Part 3: Storage in Files</a>, July 2010
           <br>[4] <a href="http://groups.google.com/group/adobe.illustrator.windows/msg/0a9d7b1244b59062">Re: Thumbnail data format in ai file</a>, Dec 2003
  @author  Michael Ulbrich (mul)
           <a href="mailto:mul@rentapacs.de">mul@rentapacs.de</a>
  @author  Volker Grabsch (vog)
           <a href="mailto:vog@notjusthosting.com">vog@notjusthosting.com</a>
  @date    7-Mar-2011, vog: created
 */regwnexec_lregwcomp_lregncomp_lregcomp_l_XLOCALE__REGEX_H_/* _XLOCALE__REGEX_H_ */// _REGEX_H_/*
 * Copyright (c) 2011 Apple Inc. All rights reserved.
 *
 * @APPLE_LICENSE_HEADER_START@
 * 
 * This file contains Original Code and/or Modifications of Original Code
 * as defined in and that are subject to the Apple Public Source License
 * Version 2.0 (the 'License'). You may not use this file except in
 * compliance with the License. Please obtain a copy of the License at
 * http://www.opensource.apple.com/apsl/ and read it before using this
 * file.
 * 
 * The Original Code and all software distributed under the License are
 * distributed on an 'AS IS' basis, WITHOUT WARRANTY OF ANY KIND, EITHER
 * EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES,
 * INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE, QUIET ENJOYMENT OR NON-INFRINGEMENT.
 * Please see the License for the specific language governing rights and
 * limitations under the License.
 * 
 * @APPLE_LICENSE_HEADER_END@
 */<xlocale/_regex.h>/Users/owura/Repos/codeql_eval/proj_repos/Exiv2-exiv2-pull-962-commits-e925bc5addd881543fa503470c8a859e112cca62/exiv2/src/epsimage.cpp"version.hpp""epsimage.hpp"readWriteEpsMetadataNativePreviewList &posEpsposEndEpsposWmfsizeWmfposTiffsizeTiffdosEpschecksumPremature end of file after DOS EPS signature.
"Premature end of file after DOS EPS signature.\n"DOS EPS file has both WMF and TIFF section. Only one of those is allowed.
"DOS EPS file has both WMF and TIFF section. Only one of those is allowed.\n"const char[75]char[75]DOS EPS file has neither WMF nor TIFF section. Exactly one of those is required.
"DOS EPS file has neither WMF nor TIFF section. Exactly one of those is required.\n"DOS EPS file has invalid position ("DOS EPS file has invalid position (") or size (") or size (") for EPS section.
") for EPS section.\n") for WMF section.
") for WMF section.\n") for TIFF section.
") for TIFF section.\n"firstLineposSecondLineconst string[3]basic_string<char, char_traits<char>, allocator<char>>[3]sizeof epsFirstLine(sizeof epsFirstLine)sizeof *epsFirstLine(sizeof *epsFirstLine)(sizeof epsFirstLine) / (sizeof *epsFirstLine)EPS"EPS"Premature end of file after first line.
"Premature end of file after first line.\n"lineEndingposLanguageLevelposContainsXmpposPagesposExiv2VersionposExiv2WebsiteposEndCommentsposAi7ThumbnailposAi7ThumbnailEndDataposBeginPhotoshopposEndPhotoshopposPageposBeginPageSetupposEndPageSetupposPageTrailerposEofremovableEmbeddingsmaxDepth4294967294UINT_MAXillustrator8corelDrawimplicitPageimplicitPageSetupimplicitPageTrailerinDefaultsPreviewPrologSetupinRemovableEmbeddingremovableEmbeddingEndLineremovableEmbeddingsWithUnmarkedTrailer%%IncludeDocument:"%%IncludeDocument:"%%BeginDocument:"%%BeginDocument:"Nested document at invalid position: "Nested document at invalid position: "Document too deeply nested at position: "Document too deeply nested at position: "%%EndDocument"%%EndDocument"Unmatched EndDocument at position: "Unmatched EndDocument at position: "%%BeginPreview:"%%BeginPreview:"%%BeginDefaults"%%BeginDefaults"%%BeginProlog"%%BeginProlog"%%BeginSetup"%%BeginSetup"%%Page:"%%Page:"Page at position "Page at position " conflicts with implicit page at position: " conflicts with implicit page at position: "Unable to handle multiple PostScript pages. Found second page at position: "Unable to handle multiple PostScript pages. Found second page at position: "%%BeginPageSetup"%%BeginPageSetup"%Exiv2BeginXMP: Before %%EndPageSetup"%Exiv2BeginXMP: Before %%EndPageSetup"pair<unsigned long, unsigned long> &%Exiv2EndXMP"%Exiv2EndXMP"%Exiv2BeginXMP: After %%PageTrailer"%Exiv2BeginXMP: After %%PageTrailer"%ADOBeginClientInjection: PageSetup End "AI11EPS""%ADOBeginClientInjection: PageSetup End \"AI11EPS\""%ADOEndClientInjection: PageSetup End "AI11EPS""%ADOEndClientInjection: PageSetup End \"AI11EPS\""%ADOBeginClientInjection: PageTrailer Start "AI11EPS""%ADOBeginClientInjection: PageTrailer Start \"AI11EPS\""%ADOEndClientInjection: PageTrailer Start "AI11EPS""%ADOEndClientInjection: PageTrailer Start \"AI11EPS\""%begin_xml_code"%begin_xml_code"%end_xml_code"%end_xml_code"%%EOF"%%EOF"'%''\x21''\x7e'%%Trailer"%%Trailer"%%PageTrailer"%%PageTrailer"%%LanguageLevel:"%%LanguageLevel:"%ADO_ContainsXMP:"%ADO_ContainsXMP:"%%Pages:"%%Pages:"%Exiv2Version:"%Exiv2Version:"%Exiv2Website:"%Exiv2Website:"%%Creator: Adobe Illustrator"%%Creator: Adobe Illustrator"%!PS-Adobe-3.0 EPSF-3.0"%!PS-Adobe-3.0 EPSF-3.0"%AI7_Thumbnail:"%AI7_Thumbnail:"%%EndData"%%EndData"%%EndComments"%%EndComments"%%BeginResource: procset wCorel"%%BeginResource: procset wCorel"%%EndPreview"%%EndPreview"%%EndDefaults"%%EndDefaults"%%EndProlog"%%EndProlog"%%EndSetup"%%EndSetup"%%EndPageSetup"%%EndPageSetup"%BeginPhotoshop:"%BeginPhotoshop:"%EndPhotoshop"%EndPhotoshop"Unmatched BeginDocument ("Unmatched BeginDocument ("x)
"x)\n"posXmpTrailerEndline1posLine1line2posLine2posXmpTrailer[/EMC pdfmark"[/EMC pdfmark"[/NamespacePop pdfmark"[/NamespacePop pdfmark"[{nextImage} 1 dict begin /Metadata {photoshop_metadata_stream} def currentdict end /PUT pdfmark"[{nextImage} 1 dict begin /Metadata {photoshop_metadata_stream} def currentdict end /PUT pdfmark"const char[97]char[97]Unable to find XMP embedding trailer ending at position: "Unable to find XMP embedding trailer ending at position: "containsXmp%ADO_ContainsXMP: MainFirst"%ADO_ContainsXMP: MainFirst"%ADO_ContainsXMP:MainFirst"%ADO_ContainsXMP:MainFirst"%ADO_ContainsXMP: NoMain"%ADO_ContainsXMP: NoMain"%ADO_ContainsXMP:NoMain"%ADO_ContainsXMP:NoMain"Invalid line ""Invalid line \""" at position: "\" at position: "deleteXmpfixBeginXmlPacketuseFlexibleEmbeddingxmpPosposLineAfterXmpUnable to find XMP metadata as announced at position: "Unable to find XMP metadata as announced at position: "Unexpected "Unexpected " bytes of data after XMP at position: " bytes of data after XMP at position: "% &&end XMP packet marker&&"% &&end XMP packet marker&&"%  &&end XMP packet marker&&"%  &&end XMP packet marker&&"posBeginXmlPacket%begin_xml_packet:"%begin_xml_packet:"Missing %begin_xml_packet in Photoshop EPS at position: "Missing %begin_xml_packet in Photoshop EPS at position: "posOtherXmpsizeOtherXmpisRemovableEmbeddingconst __wrap_iter<pair<unsigned long, unsigned long> *>const __wrap_iter<pair<unsigned long, unsigned long> *> &__wrap_iter<pair<unsigned long, unsigned long> *> &const __wrap_iter<const pair<unsigned long, unsigned long> *>const __wrap_iter<const pair<unsigned long, unsigned long> *> &__wrap_iter<const pair<unsigned long, unsigned long> *> &XMP metadata block is not removable at position: "XMP metadata block is not removable at position: "nativePreviewdummylineAi7ThumbnailposBeginDatalineStreamAi7ThumbnaillineBeginDataposAfterBeginDatalineStreamBeginDatabeginDatahex-ai7thumbnail-pnm"hex-ai7thumbnail-pnm"image/x-portable-anymap"image/x-portable-anymap""8"Unable to handle Illustrator thumbnail depth: "Unable to handle Illustrator thumbnail depth: "%%BeginData:"%%BeginData:"Unable to handle Illustrator thumbnail data section: "Unable to handle Illustrator thumbnail data section: "Hex"Hex"Unable to handle Illustrator thumbnail data type: "Unable to handle Illustrator thumbnail data type: "hex-irb"hex-irb"image/x-wmf"image/x-wmf"positionscontainsXmpLineposEpsNewprevPosprevSkipPosposEndEpsNewUnable to write to EPS files created by Adobe Illustrator 8.0 or older.
"Unable to write to EPS files created by Adobe Illustrator 8.0 or older.\n"Unable to create temporary file for writing.
"Unable to create temporary file for writing.\n"'\x00'const __wrap_iter<unsigned long *>const __wrap_iter<unsigned long *> &__wrap_iter<unsigned long *> &const __wrap_iter<const unsigned long *>const __wrap_iter<const unsigned long *> &__wrap_iter<const unsigned long *> &posLineEndskipPosInternal error while assembling the result EPS document: Unable to continue at position "Internal error while assembling the result EPS document: "
                                   "Unable to continue at position " after skipping to position " after skipping to position "%%LanguageLevel:1"%%LanguageLevel:1"%%LanguageLevel: 1"%%LanguageLevel: 1"%%LanguageLevel: 2"%%LanguageLevel: 2"%Exiv2Version: "%Exiv2Version: "%Exiv2Website: http://www.exiv2.org/"%Exiv2Website: http://www.exiv2.org/"%%Pages: 1"%%Pages: 1"%%Page: 1 1"%%Page: 1 1"%%EndPageComments"%%EndPageComments"%begin_xml_packet: "%begin_xml_packet: "%Exiv2Notice: The following line is needed by CorelDRAW."%Exiv2Notice: The following line is needed by CorelDRAW."@rs"@rs"%Exiv2Notice: The following line is needed by Photoshop."%Exiv2Notice: The following line is needed by Photoshop."/currentdistillerparams where"/currentdistillerparams where"{pop currentdistillerparams /CoreDistVersion get 5000 lt} {true} ifelse"{pop currentdistillerparams /CoreDistVersion get 5000 lt} {true} ifelse"{userdict /Exiv2_pdfmark /cleartomark load put"{userdict /Exiv2_pdfmark /cleartomark load put"    userdict /Exiv2_metafile_pdfmark {flushfile cleartomark} bind put}"    userdict /Exiv2_metafile_pdfmark {flushfile cleartomark} bind put}"const char[71]char[71]{userdict /Exiv2_pdfmark /pdfmark load put"{userdict /Exiv2_pdfmark /pdfmark load put"    userdict /Exiv2_metafile_pdfmark {/PUT pdfmark} bind put} ifelse"    userdict /Exiv2_metafile_pdfmark {/PUT pdfmark} bind put} ifelse"[/NamespacePush Exiv2_pdfmark"[/NamespacePush Exiv2_pdfmark"[/_objdef {Exiv2_metadata_stream} /type /stream /OBJ Exiv2_pdfmark"[/_objdef {Exiv2_metadata_stream} /type /stream /OBJ Exiv2_pdfmark"[{Exiv2_metadata_stream} 2 dict begin"[{Exiv2_metadata_stream} 2 dict begin"    /Type /Metadata def /Subtype /XML def currentdict end /PUT Exiv2_pdfmark"    /Type /Metadata def /Subtype /XML def currentdict end /PUT Exiv2_pdfmark"[{Exiv2_metadata_stream}"[{Exiv2_metadata_stream}"    currentfile 0 (% &&end XMP packet marker&&)"    currentfile 0 (% &&end XMP packet marker&&)"    /SubFileDecode filter Exiv2_metafile_pdfmark"    /SubFileDecode filter Exiv2_metafile_pdfmark"%Exiv2Notice: The following line is needed by Photoshop. Parameter must be exact size of XMP metadata."%Exiv2Notice: The following line is needed by Photoshop. "
                                               "Parameter must be exact size of XMP metadata."const char[103]char[103][/Document 1 dict begin"[/Document 1 dict begin"    /Metadata {Exiv2_metadata_stream} def currentdict end /BDC Exiv2_pdfmark"    /Metadata {Exiv2_metadata_stream} def currentdict end /BDC Exiv2_pdfmark"@sv"@sv"[/EMC Exiv2_pdfmark"[/EMC Exiv2_pdfmark"[/NamespacePop Exiv2_pdfmark"[/NamespacePop Exiv2_pdfmark"byte[30]unsigned char[30]dosEpsHeaderInternal error while seeking in temporary file.
"Internal error while seeking in temporary file.\n"sizeof(dosEpsHeader)findXmpconst string[8]basic_string<char, char_traits<char>, allocator<char>>[8]sizeof xmpHeaders(sizeof xmpHeaders)sizeof *xmpHeaders(sizeof *xmpHeaders)(sizeof xmpHeaders) / (sizeof *xmpHeaders)trailerPosconst XmpTrailerconst XmpTrailer[4]XmpTrailer[4]sizeof xmpTrailers(sizeof xmpTrailers)const XmpTrailer *XmpTrailer *sizeof *xmpTrailers(sizeof *xmpTrailers)(sizeof xmpTrailers) / (sizeof *xmpTrailers)trailerreadOnlyUnable to handle read-only XMP metadata yet. Please provide your sample EPS file to the Exiv2 project: http://dev.exiv2.org/projects/exiv2
"Unable to handle read-only XMP metadata yet. Please provide your "
                                           "sample EPS file to the Exiv2 project: http://dev.exiv2.org/projects/exiv2\n"trailerEndPosFound XMP header but incomplete XMP trailer.
"Found XMP header but incomplete XMP trailer.\n"Found XMP header but no XMP trailer.
"Found XMP header but no XMP trailer.\n"readPrevLinereadLineonlyWhitespacesstartsWithposTempInternal error while determining current write position in temporary file.
"Internal error while determining current write position in temporary file.\n"writeTempFailed to write to temporary file.
"Failed to write to temporary file.\n"XmpTrailer &const XmpTrailer &~XmpTrailerXmpTrailerbufSizeapplication/postscript"application/postscript"Failed to encode XMP metadata.
"Failed to encode XMP metadata.\n"Failed to decode XMP metadata.
"Failed to decode XMP metadata.\n"Failed to write blank EPS image.
"Failed to write blank EPS image.\n"ImageType::eps?>"?>"xmpTrailerEndconst XmpTrailer[]XmpTrailer[]<?xpacket end="r""<?xpacket end=\"r\""<?xpacket end='r'"<?xpacket end='r'"<?xpacket end="w""<?xpacket end=\"w\""<?xpacket end='w'"<?xpacket end='w'"xmpTrailersconst string[]basic_string<char, char_traits<char>, allocator<char>>[]<?xpacket begin="" id="W5M0MpCehiHzreSzNTczkc9d""<?xpacket begin=\"\xef\xbb\xbf\" id=\"W5M0MpCehiHzreSzNTczkc9d\""<?xpacket begin="" id='W5M0MpCehiHzreSzNTczkc9d'"<?xpacket begin=\"\xef\xbb\xbf\" id='W5M0MpCehiHzreSzNTczkc9d'"<?xpacket begin='' id="W5M0MpCehiHzreSzNTczkc9d""<?xpacket begin='\xef\xbb\xbf' id=\"W5M0MpCehiHzreSzNTczkc9d\""<?xpacket begin='' id='W5M0MpCehiHzreSzNTczkc9d'"<?xpacket begin='\xef\xbb\xbf' id='W5M0MpCehiHzreSzNTczkc9d'"<?xpacket begin="" id="W5M0MpCehiHzreSzNTczkc9d""<?xpacket begin=\"\" id=\"W5M0MpCehiHzreSzNTczkc9d\""<?xpacket begin="" id='W5M0MpCehiHzreSzNTczkc9d'"<?xpacket begin=\"\" id='W5M0MpCehiHzreSzNTczkc9d'"<?xpacket begin='' id="W5M0MpCehiHzreSzNTczkc9d""<?xpacket begin='' id=\"W5M0MpCehiHzreSzNTczkc9d\""<?xpacket begin='' id='W5M0MpCehiHzreSzNTczkc9d'"<?xpacket begin='' id='W5M0MpCehiHzreSzNTczkc9d'"xmpHeaders%!PS-Adobe-3.0 EPSF-3.0
%%BoundingBox: 0 0 0 0
"%!PS-Adobe-3.0 EPSF-3.0\n"
                                 "%%BoundingBox: 0 0 0 0\n"epsBlank%!PS-Adobe-3.0 EPSF-3.0 "%!PS-Adobe-3.0 EPSF-3.0 "%!PS-Adobe-3.1 EPSF-3.0"%!PS-Adobe-3.1 EPSF-3.0"epsFirstLine"\xC5\xD0\xD3\xC6"dosEpsSignatureDEBUG// seek back if possible and requested// check for all possible (DOS) EPS signatures// read as many bytes as needed for the longest (DOS) EPS signature/* write = */// write metadata// encode XMP metadata if necessary// decode XMP metadata// read metadata//LogMsg::setLevel(LogMsg::debug);// namespace// copy temporary file to real output file// write DOS EPS header// write WMF and/or TIFF section if present// add EOF comment if necessary// insert XMP metadata with new flexible embedding, if necessary// remove preceding embedding(s)// insert XMP metadata into existing flexible embedding// update and complement DSC comments// add last line ending if necessary// DOS EPS header will be written afterwards// assemble result EPS document// sort all positions// create temporary output file// check for Adobe Illustrator 8.0 or older// native previews// copy XMP metadata// check if there are irremovable XMP metadata blocks before EndPageSetup// check embedding of XMP metadata// search for XMP metadata// interpret comment "%ADO_ContainsXMP:"// Photoshop style// Exiftool style// look for the unmarked trailers of some removable XMP embeddings// check for unfinished nested documents// remaining explicit comments// performance optimization// implicit comments// explicit "Begin" comments// nested documents// scan comments// determine line ending style of the first line// check first line// check for DOS EPS// default positions and sizes// read from input file via memory map// open input file//! Unified implementation of reading and writing EPS metadata// search for end of XMP trailer// search for valid XMP trailer// search for valid XMP header//! Find an XMP block// step through previous line// skip line ending of previous line, if present//! Read the previous line of a buffer, allow for changing line ending style// skip line ending, if present// step through line//! Read the next line of a buffer, allow for changing line ending style// only spaces and tabs are considered to be white space characters.// According to the DSC 3.0 specification, 4.4 Parsing Rules,//! Check whether a string contains only white space characters//! Check whether a string has a certain beginning//! Get the current write position of temp file, taking care of errors//! Write data into temp file, taking care of errors// closing part of all valid XMP trailers// permits additional attributes after end="...".// We do not enforce the trailing "?>" here, because the XMP specification// list of all valid XMP trailers// deprecated headers (empty begin attribute, UTF-8 only)// normal headers// permits additional attributes after begin="..." and id="...".// list of all valid XMP headers// blank EPS file// Illustrator// OpenOffice// first line of EPS// signature of DOS EPS/*
  File:      epsimage.cpp
  Author(s): Michael Ulbrich (mul) <mul@rentapacs.de>
             Volker Grabsch (vog) <vog@notjusthosting.com>
  History:   7-Mar-2011, vog: created
 */__wrap_iter<const unsigned long *>__wrap_iter<unsigned long *>__wrap_iter<unsigned long *> *__vector_base<unsigned long, allocator<unsigned long>>__vector_base<unsigned long, allocator<unsigned long>> &const __vector_base<unsigned long, allocator<unsigned long>>const __vector_base<unsigned long, allocator<unsigned long>> &__wrap_iter<const pair<unsigned long, unsigned long> *>const pair<unsigned long, unsigned long>const pair<unsigned long, unsigned long> *pair<unsigned long, unsigned long> *__wrap_iter<pair<unsigned long, unsigned long> *>__wrap_iter<pair<unsigned long, unsigned long> *> *__vector_base<pair<unsigned long, unsigned long>, allocator<pair<unsigned long, unsigned long>>>__vector_base<pair<unsigned long, unsigned long>, allocator<pair<unsigned long, unsigned long>>> &const __vector_base<pair<unsigned long, unsigned long>, allocator<pair<unsigned long, unsigned long>>>const __vector_base<pair<unsigned long, unsigned long>, allocator<pair<unsigned long, unsigned long>>> &vector<unsigned long, allocator<unsigned long>>allocator<unsigned long> &vector<pair<unsigned long, unsigned long>, allocator<pair<unsigned long, unsigned long>>>allocator<pair<unsigned long, unsigned long>> &vector<regex_t, allocator<regex_t>>__less<value_type, value_type>allocator<pair<unsigned long, unsigned long>>const allocator<pair<unsigned long, unsigned long>>const allocator<pair<unsigned long, unsigned long>> &const pair<unsigned long, unsigned long> &__identity<allocator<pair<unsigned long, unsigned long>>>__identity<allocator<pair<unsigned long, unsigned long>>> &const __identity<allocator<pair<unsigned long, unsigned long>>>const __identity<allocator<pair<unsigned long, unsigned long>>> &allocator<unsigned long>const allocator<unsigned long>const allocator<unsigned long> &__identity<allocator<unsigned long>>__identity<allocator<unsigned long>> &const __identity<allocator<unsigned long>>const __identity<allocator<unsigned long>> &vector<unsigned long, allocator<unsigned long>> *const vector<unsigned long, allocator<unsigned long>>const vector<unsigned long, allocator<unsigned long>> *vector<pair<unsigned long, unsigned long>, allocator<pair<unsigned long, unsigned long>>> *const vector<pair<unsigned long, unsigned long>, allocator<pair<unsigned long, unsigned long>>>const vector<pair<unsigned long, unsigned long>, allocator<pair<unsigned long, unsigned long>>> *__wrap_iter<const unsigned long *> *const __wrap_iter<const unsigned long *> *__vector_base<unsigned long, allocator<unsigned long>> *unsigned long *&vector<NativePreview, allocator<NativePreview>> *__vector_base<NativePreview, allocator<NativePreview>> *const vector<NativePreview, allocator<NativePreview>>const vector<NativePreview, allocator<NativePreview>> *__wrap_iter<const pair<unsigned long, unsigned long> *> *const __wrap_iter<const pair<unsigned long, unsigned long> *> *__vector_base<pair<unsigned long, unsigned long>, allocator<pair<unsigned long, unsigned long>>> *pair<unsigned long, unsigned long> *&__less<unsigned long, unsigned long> &operator Exiv2::NativePreview *operator std::__1::pair<unsigned long, unsigned long> *__iterator_traits_impl<__wrap_iter<char *>, true>__iterator_traits_impl<__wrap_iter<char *>, true> &const __iterator_traits_impl<__wrap_iter<char *>, true>const __iterator_traits_impl<__wrap_iter<char *>, true> &__non_trivial_if<true, allocator<unsigned long>>__non_trivial_if<true, allocator<unsigned long>> &const __non_trivial_if<true, allocator<unsigned long>>const __non_trivial_if<true, allocator<unsigned long>> &__non_trivial_if<true, allocator<pair<unsigned long, unsigned long>>>__non_trivial_if<true, allocator<pair<unsigned long, unsigned long>>> &const __non_trivial_if<true, allocator<pair<unsigned long, unsigned long>>>const __non_trivial_if<true, allocator<pair<unsigned long, unsigned long>>> &allocator<regex_t>reverse_iterator<__wrap_iter<pair<unsigned long, unsigned long> *>>reverse_iterator<__wrap_iter<const pair<unsigned long, unsigned long> *>>vector<pair<unsigned long, unsigned long>, allocator<pair<unsigned long, unsigned long>>> &reverse_iterator<__wrap_iter<unsigned long *>>reverse_iterator<__wrap_iter<const unsigned long *>>vector<unsigned long, allocator<unsigned long>> &__compressed_pair<pair<unsigned long, unsigned long> *, allocator<pair<unsigned long, unsigned long>>>__compressed_pair<pair<unsigned long, unsigned long> *, allocator<pair<unsigned long, unsigned long>>> &const __compressed_pair<pair<unsigned long, unsigned long> *, allocator<pair<unsigned long, unsigned long>>>const __compressed_pair<pair<unsigned long, unsigned long> *, allocator<pair<unsigned long, unsigned long>>> &allocator_traits<allocator<pair<unsigned long, unsigned long>>>allocator_traits<allocator<pair<unsigned long, unsigned long>>> &const allocator_traits<allocator<pair<unsigned long, unsigned long>>>const allocator_traits<allocator<pair<unsigned long, unsigned long>>> &iterator_traits<pair<unsigned long, unsigned long> *>iterator_traits<pair<unsigned long, unsigned long> *> &const iterator_traits<pair<unsigned long, unsigned long> *>const iterator_traits<pair<unsigned long, unsigned long> *> &iterator_traits<const pair<unsigned long, unsigned long> *>iterator_traits<const pair<unsigned long, unsigned long> *> &const iterator_traits<const pair<unsigned long, unsigned long> *>const iterator_traits<const pair<unsigned long, unsigned long> *> &__compressed_pair<unsigned long *, allocator<unsigned long>>__compressed_pair<unsigned long *, allocator<unsigned long>> &const __compressed_pair<unsigned long *, allocator<unsigned long>>const __compressed_pair<unsigned long *, allocator<unsigned long>> &allocator_traits<allocator<unsigned long>>allocator_traits<allocator<unsigned long>> &const allocator_traits<allocator<unsigned long>>const allocator_traits<allocator<unsigned long>> &iterator_traits<unsigned long *>iterator_traits<unsigned long *> &const iterator_traits<unsigned long *>const iterator_traits<unsigned long *> &iterator_traits<const unsigned long *>iterator_traits<const unsigned long *> &const iterator_traits<const unsigned long *>const iterator_traits<const unsigned long *> &const pair<unsigned long, unsigned long> &&pair<unsigned long, unsigned long> &&__split_buffer<pair<unsigned long, unsigned long>, allocator<pair<unsigned long, unsigned long>> &> &const __wrap_iter<pair<unsigned long, unsigned long> *> *const __vector_base<NativePreview, allocator<NativePreview>> *const NativePreview &&NativePreview &&__split_buffer<NativePreview, allocator<NativePreview> &> &const unsigned long &&unsigned long &&__split_buffer<unsigned long, allocator<unsigned long> &> &unsigned long *&&__wrap_iter<unsigned long *> &&const __wrap_iter<unsigned long *> *const __vector_base<pair<unsigned long, unsigned long>, allocator<pair<unsigned long, unsigned long>>> *const __vector_base<unsigned long, allocator<unsigned long>> *const __wrap_iter<char *> &__unwrap_iter_impl<__wrap_iter<unsigned long *>, true>__unwrap_iter_impl<__wrap_iter<unsigned long *>, true> &const __unwrap_iter_impl<__wrap_iter<unsigned long *>, true>const __unwrap_iter_impl<__wrap_iter<unsigned long *>, true> &__comp_ref_type<__less<unsigned long, unsigned long>>__comp_ref_type<__less<unsigned long, unsigned long>> &const __comp_ref_type<__less<unsigned long, unsigned long>>const __comp_ref_type<__less<unsigned long, unsigned long>> &remove_reference<const unsigned long &>remove_reference<const unsigned long &> &const remove_reference<const unsigned long &>const remove_reference<const unsigned long &> &remove_reference<const unsigned long>remove_reference<const unsigned long> &const remove_reference<const unsigned long>const remove_reference<const unsigned long> &__split_buffer<unsigned long, allocator<unsigned long> &>remove_reference<const NativePreview &>remove_reference<const NativePreview &> &const remove_reference<const NativePreview &>const remove_reference<const NativePreview &> &remove_reference<const NativePreview>remove_reference<const NativePreview> &const remove_reference<const NativePreview>const remove_reference<const NativePreview> &__split_buffer<NativePreview, allocator<NativePreview> &>remove_reference<const pair<unsigned long, unsigned long> &>remove_reference<const pair<unsigned long, unsigned long> &> &const remove_reference<const pair<unsigned long, unsigned long> &>const remove_reference<const pair<unsigned long, unsigned long> &> &remove_reference<const pair<unsigned long, unsigned long>>remove_reference<const pair<unsigned long, unsigned long>> &const remove_reference<const pair<unsigned long, unsigned long>>const remove_reference<const pair<unsigned long, unsigned long>> &__split_buffer<pair<unsigned long, unsigned long>, allocator<pair<unsigned long, unsigned long>> &>remove_cv<const unsigned long>remove_cv<const unsigned long> &const remove_cv<const unsigned long>const remove_cv<const unsigned long> &remove_cv<unsigned long>remove_cv<unsigned long> &const remove_cv<unsigned long>const remove_cv<unsigned long> &__size_type<allocator<unsigned long>, long, true>__size_type<allocator<unsigned long>, long, true> &const __size_type<allocator<unsigned long>, long, true>const __size_type<allocator<unsigned long>, long, true> &__const_void_pointer<unsigned long *, allocator<unsigned long>, false>__const_void_pointer<unsigned long *, allocator<unsigned long>, false> &const __const_void_pointer<unsigned long *, allocator<unsigned long>, false>const __const_void_pointer<unsigned long *, allocator<unsigned long>, false> &__pointer<unsigned long, allocator<unsigned long>, allocator<unsigned long>, true>__pointer<unsigned long, allocator<unsigned long>, allocator<unsigned long>, true> &const __pointer<unsigned long, allocator<unsigned long>, allocator<unsigned long>, true>const __pointer<unsigned long, allocator<unsigned long>, allocator<unsigned long>, true> &__const_pointer<unsigned long, unsigned long *, allocator<unsigned long>, true>__const_pointer<unsigned long, unsigned long *, allocator<unsigned long>, true> &const __const_pointer<unsigned long, unsigned long *, allocator<unsigned long>, true>const __const_pointer<unsigned long, unsigned long *, allocator<unsigned long>, true> &__void_pointer<unsigned long *, allocator<unsigned long>, false>__void_pointer<unsigned long *, allocator<unsigned long>, false> &const __void_pointer<unsigned long *, allocator<unsigned long>, false>const __void_pointer<unsigned long *, allocator<unsigned long>, false> &__alloc_traits_difference_type<allocator<unsigned long>, unsigned long *, true>__alloc_traits_difference_type<allocator<unsigned long>, unsigned long *, true> &const __alloc_traits_difference_type<allocator<unsigned long>, unsigned long *, true>const __alloc_traits_difference_type<allocator<unsigned long>, unsigned long *, true> &__propagate_on_container_move_assignment<allocator<unsigned long>, true>__propagate_on_container_move_assignment<allocator<unsigned long>, true> &const __propagate_on_container_move_assignment<allocator<unsigned long>, true>const __propagate_on_container_move_assignment<allocator<unsigned long>, true> &__is_always_equal<allocator<unsigned long>, true>__is_always_equal<allocator<unsigned long>, true> &const __is_always_equal<allocator<unsigned long>, true>const __is_always_equal<allocator<unsigned long>, true> &__compressed_pair_elem<allocator<unsigned long>, 1, true>__compressed_pair_elem<allocator<unsigned long>, 1, true> &const __compressed_pair_elem<allocator<unsigned long>, 1, true>const __compressed_pair_elem<allocator<unsigned long>, 1, true> &__compressed_pair_elem<unsigned long *, 0, false>__compressed_pair_elem<unsigned long *, 0, false> &const __compressed_pair_elem<unsigned long *, 0, false>const __compressed_pair_elem<unsigned long *, 0, false> &unsigned long *constunsigned long *const &remove_cv<const pair<unsigned long, unsigned long>>remove_cv<const pair<unsigned long, unsigned long>> &const remove_cv<const pair<unsigned long, unsigned long>>const remove_cv<const pair<unsigned long, unsigned long>> &remove_cv<pair<unsigned long, unsigned long>>remove_cv<pair<unsigned long, unsigned long>> &const remove_cv<pair<unsigned long, unsigned long>>const remove_cv<pair<unsigned long, unsigned long>> &__size_type<allocator<pair<unsigned long, unsigned long>>, long, true>__size_type<allocator<pair<unsigned long, unsigned long>>, long, true> &const __size_type<allocator<pair<unsigned long, unsigned long>>, long, true>const __size_type<allocator<pair<unsigned long, unsigned long>>, long, true> &__const_void_pointer<pair<unsigned long, unsigned long> *, allocator<pair<unsigned long, unsigned long>>, false>__const_void_pointer<pair<unsigned long, unsigned long> *, allocator<pair<unsigned long, unsigned long>>, false> &const __const_void_pointer<pair<unsigned long, unsigned long> *, allocator<pair<unsigned long, unsigned long>>, false>const __const_void_pointer<pair<unsigned long, unsigned long> *, allocator<pair<unsigned long, unsigned long>>, false> &__pointer<pair<unsigned long, unsigned long>, allocator<pair<unsigned long, unsigned long>>, allocator<pair<unsigned long, unsigned long>>, true>__pointer<pair<unsigned long, unsigned long>, allocator<pair<unsigned long, unsigned long>>, allocator<pair<unsigned long, unsigned long>>, true> &const __pointer<pair<unsigned long, unsigned long>, allocator<pair<unsigned long, unsigned long>>, allocator<pair<unsigned long, unsigned long>>, true>const __pointer<pair<unsigned long, unsigned long>, allocator<pair<unsigned long, unsigned long>>, allocator<pair<unsigned long, unsigned long>>, true> &__const_pointer<pair<unsigned long, unsigned long>, pair<unsigned long, unsigned long> *, allocator<pair<unsigned long, unsigned long>>, true>__const_pointer<pair<unsigned long, unsigned long>, pair<unsigned long, unsigned long> *, allocator<pair<unsigned long, unsigned long>>, true> &const __const_pointer<pair<unsigned long, unsigned long>, pair<unsigned long, unsigned long> *, allocator<pair<unsigned long, unsigned long>>, true>const __const_pointer<pair<unsigned long, unsigned long>, pair<unsigned long, unsigned long> *, allocator<pair<unsigned long, unsigned long>>, true> &__void_pointer<pair<unsigned long, unsigned long> *, allocator<pair<unsigned long, unsigned long>>, false>__void_pointer<pair<unsigned long, unsigned long> *, allocator<pair<unsigned long, unsigned long>>, false> &const __void_pointer<pair<unsigned long, unsigned long> *, allocator<pair<unsigned long, unsigned long>>, false>const __void_pointer<pair<unsigned long, unsigned long> *, allocator<pair<unsigned long, unsigned long>>, false> &__alloc_traits_difference_type<allocator<pair<unsigned long, unsigned long>>, pair<unsigned long, unsigned long> *, true>__alloc_traits_difference_type<allocator<pair<unsigned long, unsigned long>>, pair<unsigned long, unsigned long> *, true> &const __alloc_traits_difference_type<allocator<pair<unsigned long, unsigned long>>, pair<unsigned long, unsigned long> *, true>const __alloc_traits_difference_type<allocator<pair<unsigned long, unsigned long>>, pair<unsigned long, unsigned long> *, true> &__propagate_on_container_move_assignment<allocator<pair<unsigned long, unsigned long>>, true>__propagate_on_container_move_assignment<allocator<pair<unsigned long, unsigned long>>, true> &const __propagate_on_container_move_assignment<allocator<pair<unsigned long, unsigned long>>, true>const __propagate_on_container_move_assignment<allocator<pair<unsigned long, unsigned long>>, true> &__is_always_equal<allocator<pair<unsigned long, unsigned long>>, true>__is_always_equal<allocator<pair<unsigned long, unsigned long>>, true> &const __is_always_equal<allocator<pair<unsigned long, unsigned long>>, true>const __is_always_equal<allocator<pair<unsigned long, unsigned long>>, true> &__compressed_pair_elem<allocator<pair<unsigned long, unsigned long>>, 1, true>__compressed_pair_elem<allocator<pair<unsigned long, unsigned long>>, 1, true> &const __compressed_pair_elem<allocator<pair<unsigned long, unsigned long>>, 1, true>const __compressed_pair_elem<allocator<pair<unsigned long, unsigned long>>, 1, true> &__compressed_pair_elem<pair<unsigned long, unsigned long> *, 0, false>__compressed_pair_elem<pair<unsigned long, unsigned long> *, 0, false> &const __compressed_pair_elem<pair<unsigned long, unsigned long> *, 0, false>const __compressed_pair_elem<pair<unsigned long, unsigned long> *, 0, false> &pair<unsigned long, unsigned long> *constpair<unsigned long, unsigned long> *const &__wrap_iter<char *> *const __less<unsigned long, unsigned long>__compressed_pair<unsigned long *, allocator<unsigned long>> *__split_buffer<unsigned long, allocator<unsigned long> &> *const __split_buffer<unsigned long, allocator<unsigned long> &>const __split_buffer<unsigned long, allocator<unsigned long> &> *__compressed_pair<NativePreview *, allocator<NativePreview>> *__split_buffer<NativePreview, allocator<NativePreview> &> *const __split_buffer<NativePreview, allocator<NativePreview> &>const __split_buffer<NativePreview, allocator<NativePreview> &> *__compressed_pair<pair<unsigned long, unsigned long> *, allocator<pair<unsigned long, unsigned long>>> *__split_buffer<pair<unsigned long, unsigned long>, allocator<pair<unsigned long, unsigned long>> &> *const __split_buffer<pair<unsigned long, unsigned long>, allocator<pair<unsigned long, unsigned long>> &>const __split_buffer<pair<unsigned long, unsigned long>, allocator<pair<unsigned long, unsigned long>> &> *__iterator_traits_impl<__wrap_iter<unsigned long *>, true>__iterator_traits_impl<__wrap_iter<unsigned long *>, true> &const __iterator_traits_impl<__wrap_iter<unsigned long *>, true>const __iterator_traits_impl<__wrap_iter<unsigned long *>, true> &remove_volatile<pair<unsigned long, unsigned long>>remove_volatile<pair<unsigned long, unsigned long>> &const remove_volatile<pair<unsigned long, unsigned long>>const remove_volatile<pair<unsigned long, unsigned long>> &remove_volatile<unsigned long>remove_volatile<unsigned long> &const remove_volatile<unsigned long>const remove_volatile<unsigned long> &__compressed_pair<pair<unsigned long, unsigned long> *, allocator<pair<unsigned long, unsigned long>> &>__compressed_pair<pair<unsigned long, unsigned long> *, allocator<pair<unsigned long, unsigned long>> &> &const __compressed_pair<pair<unsigned long, unsigned long> *, allocator<pair<unsigned long, unsigned long>> &>const __compressed_pair<pair<unsigned long, unsigned long> *, allocator<pair<unsigned long, unsigned long>> &> &remove_reference<allocator<pair<unsigned long, unsigned long>> &>remove_reference<allocator<pair<unsigned long, unsigned long>> &> &const remove_reference<allocator<pair<unsigned long, unsigned long>> &>const remove_reference<allocator<pair<unsigned long, unsigned long>> &> &add_lvalue_reference<allocator<pair<unsigned long, unsigned long>> &>add_lvalue_reference<allocator<pair<unsigned long, unsigned long>> &> &const add_lvalue_reference<allocator<pair<unsigned long, unsigned long>> &>const add_lvalue_reference<allocator<pair<unsigned long, unsigned long>> &> &__compressed_pair<NativePreview *, allocator<NativePreview> &>__compressed_pair<NativePreview *, allocator<NativePreview> &> &const __compressed_pair<NativePreview *, allocator<NativePreview> &>const __compressed_pair<NativePreview *, allocator<NativePreview> &> &remove_reference<allocator<NativePreview> &>remove_reference<allocator<NativePreview> &> &const remove_reference<allocator<NativePreview> &>const remove_reference<allocator<NativePreview> &> &add_lvalue_reference<allocator<NativePreview> &>add_lvalue_reference<allocator<NativePreview> &> &const add_lvalue_reference<allocator<NativePreview> &>const add_lvalue_reference<allocator<NativePreview> &> &__compressed_pair<unsigned long *, allocator<unsigned long> &>__compressed_pair<unsigned long *, allocator<unsigned long> &> &const __compressed_pair<unsigned long *, allocator<unsigned long> &>const __compressed_pair<unsigned long *, allocator<unsigned long> &> &remove_reference<allocator<unsigned long> &>remove_reference<allocator<unsigned long> &> &const remove_reference<allocator<unsigned long> &>const remove_reference<allocator<unsigned long> &> &add_lvalue_reference<allocator<unsigned long> &>add_lvalue_reference<allocator<unsigned long> &> &const add_lvalue_reference<allocator<unsigned long> &>const add_lvalue_reference<allocator<unsigned long> &> &add_lvalue_reference<__less<unsigned long, unsigned long>>add_lvalue_reference<__less<unsigned long, unsigned long>> &const add_lvalue_reference<__less<unsigned long, unsigned long>>const add_lvalue_reference<__less<unsigned long, unsigned long>> &__compressed_pair_elem<allocator<pair<unsigned long, unsigned long>>, 1, true> *pair<unsigned long, unsigned long> *&&__compressed_pair_elem<pair<unsigned long, unsigned long> *, 0, false> *NativePreview *&&__compressed_pair_elem<NativePreview *, 0, false> *__compressed_pair_elem<allocator<unsigned long>, 1, true> *__compressed_pair_elem<unsigned long *, 0, false> *allocator<pair<unsigned long, unsigned long>> *allocator<unsigned long> *remove_reference<char &>remove_reference<char &> &const remove_reference<char &>const remove_reference<char &> &remove_reference<unsigned long *&>remove_reference<unsigned long *&> &const remove_reference<unsigned long *&>const remove_reference<unsigned long *&> &remove_reference<NativePreview *&>remove_reference<NativePreview *&> &const remove_reference<NativePreview *&>const remove_reference<NativePreview *&> &remove_reference<pair<unsigned long, unsigned long> *&>remove_reference<pair<unsigned long, unsigned long> *&> &const remove_reference<pair<unsigned long, unsigned long> *&>const remove_reference<pair<unsigned long, unsigned long> *&> &__add_lvalue_reference_impl<__less<unsigned long, unsigned long>, true>__add_lvalue_reference_impl<__less<unsigned long, unsigned long>, true> &const __add_lvalue_reference_impl<__less<unsigned long, unsigned long>, true>const __add_lvalue_reference_impl<__less<unsigned long, unsigned long>, true> &__add_lvalue_reference_impl<allocator<unsigned long> &, true>__add_lvalue_reference_impl<allocator<unsigned long> &, true> &const __add_lvalue_reference_impl<allocator<unsigned long> &, true>const __add_lvalue_reference_impl<allocator<unsigned long> &, true> &__compressed_pair_elem<allocator<unsigned long> &, 1, false>__compressed_pair_elem<allocator<unsigned long> &, 1, false> &const __compressed_pair_elem<allocator<unsigned long> &, 1, false>const __compressed_pair_elem<allocator<unsigned long> &, 1, false> &__add_lvalue_reference_impl<allocator<NativePreview> &, true>__add_lvalue_reference_impl<allocator<NativePreview> &, true> &const __add_lvalue_reference_impl<allocator<NativePreview> &, true>const __add_lvalue_reference_impl<allocator<NativePreview> &, true> &__compressed_pair_elem<allocator<NativePreview> &, 1, false>__compressed_pair_elem<allocator<NativePreview> &, 1, false> &const __compressed_pair_elem<allocator<NativePreview> &, 1, false>const __compressed_pair_elem<allocator<NativePreview> &, 1, false> &__add_lvalue_reference_impl<allocator<pair<unsigned long, unsigned long>> &, true>__add_lvalue_reference_impl<allocator<pair<unsigned long, unsigned long>> &, true> &const __add_lvalue_reference_impl<allocator<pair<unsigned long, unsigned long>> &, true>const __add_lvalue_reference_impl<allocator<pair<unsigned long, unsigned long>> &, true> &__compressed_pair_elem<allocator<pair<unsigned long, unsigned long>> &, 1, false>__compressed_pair_elem<allocator<pair<unsigned long, unsigned long>> &, 1, false> &const __compressed_pair_elem<allocator<pair<unsigned long, unsigned long>> &, 1, false>const __compressed_pair_elem<allocator<pair<unsigned long, unsigned long>> &, 1, false> &pointer_traits<unsigned long *>pointer_traits<unsigned long *> &const pointer_traits<unsigned long *>const pointer_traits<unsigned long *> &pointer_traits<pair<unsigned long, unsigned long> *>pointer_traits<pair<unsigned long, unsigned long> *> &const pointer_traits<pair<unsigned long, unsigned long> *>const pointer_traits<pair<unsigned long, unsigned long> *> &const __compressed_pair<unsigned long *, allocator<unsigned long>> *const __compressed_pair<pair<unsigned long, unsigned long> *, allocator<pair<unsigned long, unsigned long>>> *__compressed_pair<unsigned long *, allocator<unsigned long> &> *allocator<NativePreview> *__compressed_pair<NativePreview *, allocator<NativePreview> &> *__compressed_pair_elem<allocator<NativePreview>, 1, true> *__compressed_pair<pair<unsigned long, unsigned long> *, allocator<pair<unsigned long, unsigned long>> &> *remove_reference<NativePreview &>remove_reference<NativePreview &> &const remove_reference<NativePreview &>const remove_reference<NativePreview &> &__is_referenceable<allocator<pair<unsigned long, unsigned long>> &>__is_referenceable<allocator<pair<unsigned long, unsigned long>> &> &const __is_referenceable<allocator<pair<unsigned long, unsigned long>> &>const __is_referenceable<allocator<pair<unsigned long, unsigned long>> &> &__is_referenceable<allocator<NativePreview> &>__is_referenceable<allocator<NativePreview> &> &const __is_referenceable<allocator<NativePreview> &>const __is_referenceable<allocator<NativePreview> &> &__is_referenceable<allocator<unsigned long> &>__is_referenceable<allocator<unsigned long> &> &const __is_referenceable<allocator<unsigned long> &>const __is_referenceable<allocator<unsigned long> &> &__is_referenceable<__less<unsigned long, unsigned long>>__is_referenceable<__less<unsigned long, unsigned long>> &const __is_referenceable<__less<unsigned long, unsigned long>>const __is_referenceable<__less<unsigned long, unsigned long>> &__non_trivial_if<true, allocator<pair<unsigned long, unsigned long>>> *const allocator<pair<unsigned long, unsigned long>> *1152921504606846975const __compressed_pair<pair<unsigned long, unsigned long> *, allocator<pair<unsigned long, unsigned long>> &> *__compressed_pair_elem<allocator<pair<unsigned long, unsigned long>> &, 1, false> *const __compressed_pair<NativePreview *, allocator<NativePreview>> *const allocator<NativePreview> *256204778801521550const __compressed_pair<NativePreview *, allocator<NativePreview> &> *__compressed_pair_elem<allocator<NativePreview> &, 1, false> *__non_trivial_if<true, allocator<unsigned long>> *const allocator<unsigned long> *const __compressed_pair<unsigned long *, allocator<unsigned long> &> *__compressed_pair_elem<allocator<unsigned long> &, 1, false> *const __compressed_pair_elem<pair<unsigned long, unsigned long> *, 0, false> *const __compressed_pair_elem<unsigned long *, 0, false> *const __compressed_pair_elem<allocator<unsigned long>, 1, true> *const __compressed_pair_elem<allocator<NativePreview>, 1, true> *const __compressed_pair_elem<NativePreview *, 0, false> *const __compressed_pair_elem<allocator<pair<unsigned long, unsigned long>>, 1, true> *AnyError *LogMsg */Users/owura/Repos/codeql_eval/proj_repos/Exiv2-exiv2-pull-962-commits-e925bc5addd881543fa503470c8a859e112cca62/exiv2/src/error.cppErrMsg &const ErrMsgconst ErrMsg &const ErrMsg *ErrMsg *emconst ErrMsg[62]ErrMsg[62]const ErrMsg(&)[62]ErrMsg(&)[62]errMsg(code_)msg%0"%0"const ErrorCodeconst ErrorCode &ErrorCode &%1"%1"%2"%2"%3"%3"const exception &LogMsg::debugDebug: "Debug: "LogMsg::infoInfo: "Info: "LogMsg::warnWarning: "Warning: "LogMsg::errorError: "Error: "LogMsg::muteErrMsgmessage_const ErrMsg[]ErrMsg[]"Error %0: arg2=%2, arg3=%3, arg1=%1.""Success""This does not look like a %1 image""Invalid dataset name `%1'""Invalid record name `%1'""Invalid key `%1'""Invalid tag name or ifdId `%1', ifdId %2""Value not set""%1: Failed to open the data source: %2""%1: Failed to open file (%2): %3""%1: The file contains data of an unknown image type""The memory contains data of an unknown image type""Image type %1 is not supported""Failed to read image data""This does not look like a JPEG image""%1: Failed to map file for reading and writing: %2""%1: Failed to rename file to %2: %3""%1: Transfer failed: %2""Memory transfer failed: %1""Failed to read input data""Failed to write image""Input data does not contain a valid image""Invalid ifdId %1""Entry::setValue: Value too large (tag=%1, size=%2, requested=%3)""Entry::setDataArea: Value too large (tag=%1, size=%2, requested=%3)""Offset out of range""Unsupported data area offset type""Invalid charset: `%1'""Unsupported date format""Unsupported time format""Writing to %1 images is not supported""Setting %1 in %2 images is not supported""This does not look like a CRW image""%1: Not supported""No namespace info available for XMP prefix `%1'""No prefix registered for namespace `%2', needed for property path `%1'""Size of %1 JPEG segment is larger than 65535 bytes""Unhandled Xmpdatum %1 of type %2""Unhandled XMP node %1 with opt=%2""XMP Toolkit error %1: %2""Failed to decode Lang Alt property %1 with opt=%2""Failed to decode Lang Alt qualifier %1 with opt=%2""Failed to encode Lang Alt property %1""Failed to determine property name from path %1, namespace %2""Schema namespace %1 is not registered with the XMP Toolkit""No namespace registered for prefix `%1'""Aliases are not supported. Please send this XMP packet to ahuggel@gmx.net `%1', `%2', `%3'""Invalid XmpText type `%1'""TIFF directory %1 has too many entries""Multiple TIFF array element tags %1 in one directory""TIFF array element tag %1 has wrong type""%1 has invalid XMP value type `%2'""Not a valid ICC Profile""Not valid XMP""tiff directory length is too large""invalid type value detected in Image::printIFDStructure""invalid memory allocation request""corrupted image metadata""Arithmetic operation overflow""Memory allocation failed"Error %0: arg2=%2, arg3=%3, arg1=%1.Exiv2::kerSuccessSuccess%1: Call to `%3' failed: %2"%1: Call to `%3' failed: %2"Exiv2::kerNotAnImageThis does not look like a %1 imageExiv2::kerInvalidDatasetInvalid dataset name `%1'Exiv2::kerInvalidRecordInvalid record name `%1'Exiv2::kerInvalidKeyInvalid key `%1'Exiv2::kerInvalidTagInvalid tag name or ifdId `%1', ifdId %2Exiv2::kerValueNotSetValue not set%1: Failed to open the data source: %2%1: Failed to open file (%2): %3Exiv2::kerFileContainsUnknownImageType%1: The file contains data of an unknown image typeExiv2::kerMemoryContainsUnknownImageTypeThe memory contains data of an unknown image typeExiv2::kerUnsupportedImageTypeImage type %1 is not supportedFailed to read image dataExiv2::kerNotAJpegThis does not look like a JPEG imageExiv2::kerFailedToMapFileForReadWrite%1: Failed to map file for reading and writing: %2Exiv2::kerFileRenameFailed%1: Failed to rename file to %2: %3Exiv2::kerTransferFailed%1: Transfer failed: %2Exiv2::kerMemoryTransferFailedMemory transfer failed: %1Exiv2::kerInputDataReadFailedFailed to read input dataExiv2::kerImageWriteFailedFailed to write imageExiv2::kerNoImageInInputDataInput data does not contain a valid imageExiv2::kerInvalidIfdIdInvalid ifdId %1Exiv2::kerValueTooLargeEntry::setValue: Value too large (tag=%1, size=%2, requested=%3)Exiv2::kerDataAreaValueTooLargeEntry::setDataArea: Value too large (tag=%1, size=%2, requested=%3)Exiv2::kerOffsetOutOfRangeOffset out of rangeExiv2::kerUnsupportedDataAreaOffsetTypeUnsupported data area offset typeExiv2::kerInvalidCharsetInvalid charset: `%1'Exiv2::kerUnsupportedDateFormatUnsupported date formatExiv2::kerUnsupportedTimeFormatUnsupported time formatExiv2::kerWritingImageFormatUnsupportedWriting to %1 images is not supportedExiv2::kerInvalidSettingForImageSetting %1 in %2 images is not supportedExiv2::kerNotACrwImageThis does not look like a CRW imageExiv2::kerFunctionNotSupported%1: Not supportedExiv2::kerNoNamespaceInfoForXmpPrefixNo namespace info available for XMP prefix `%1'Exiv2::kerNoPrefixForNamespaceNo prefix registered for namespace `%2', needed for property path `%1'Exiv2::kerTooLargeJpegSegmentSize of %1 JPEG segment is larger than 65535 bytesExiv2::kerUnhandledXmpdatumUnhandled Xmpdatum %1 of type %2Exiv2::kerUnhandledXmpNodeUnhandled XMP node %1 with opt=%2Exiv2::kerXMPToolkitErrorXMP Toolkit error %1: %2Exiv2::kerDecodeLangAltPropertyFailedFailed to decode Lang Alt property %1 with opt=%2Exiv2::kerDecodeLangAltQualifierFailedFailed to decode Lang Alt qualifier %1 with opt=%2Exiv2::kerEncodeLangAltPropertyFailedFailed to encode Lang Alt property %1Exiv2::kerPropertyNameIdentificationFailedFailed to determine property name from path %1, namespace %2Exiv2::kerSchemaNamespaceNotRegisteredSchema namespace %1 is not registered with the XMP ToolkitExiv2::kerNoNamespaceForPrefixNo namespace registered for prefix `%1'Exiv2::kerAliasesNotSupportedAliases are not supported. Please send this XMP packet to ahuggel@gmx.net `%1', `%2', `%3'Exiv2::kerInvalidXmpTextInvalid XmpText type `%1'Exiv2::kerTooManyTiffDirectoryEntriesTIFF directory %1 has too many entriesExiv2::kerMultipleTiffArrayElementTagsInDirectoryMultiple TIFF array element tags %1 in one directoryExiv2::kerWrongTiffArrayElementTagTypeTIFF array element tag %1 has wrong typeExiv2::kerInvalidKeyXmpValue%1 has invalid XMP value type `%2'Exiv2::kerInvalidIccProfileNot a valid ICC ProfileExiv2::kerInvalidXMPNot valid XMPtiff directory length is too largeExiv2::kerInvalidTypeValueinvalid type value detected in Image::printIFDStructureExiv2::kerInvalidMallocinvalid memory allocation requestExiv2::kerCorruptedMetadatacorrupted image metadataExiv2::kerArithmeticOverflowArithmetic operation overflowExiv2::kerMallocFailedMemory allocation failederrList// Default output level// %1=key, %2=value type// %1=tag number// %1=TIFF directory name// %1=type// %1=namespace, %2=property path, %3=value// %1=prefix// %1=namespace// %1=property path, %2=namespace// %1=key// %1=qualifier path, %3=XMP Toolkit option flags// %1=property path, %3=XMP Toolkit option flags// %1=XMP_Error::GetID(), %2=XMP_Error::GetErrMsg()// %1=key, %2=XMP Toolkit option flags// %1=type of metadata (Exif, IPTC, JPEG comment)// %1=function// %1=metadata type, %2=image format// %1=image format// %1=charset name// %1=tag, %2=dataAreaSize, %3=required size// %1=tag, %2=dataSize, %3=required size// %1=ifdId// %1=strerror// %1=path, %2=strerror// %1=old path, %2=new path, %3=strerror// %1=image type// %1=path// %1=path, %2=mode, %3=strerror// %1=tag name, %2=ifdId// %1=record name// %1=dataset name// %1=Image type// %1=path, %2=strerror, %3=function that failed// %1=error message//! Complete list of Exiv2 exception error messages//!< Error message//! Comparison operator//! Helper structure defining an error message./*
  File:      error.cpp
 */<concepts><__iterator/incrementable_traits.h><__iterator/concepts.h><__function_like.h>_Difference_Distance__n >= 0 || __is_cpp17_bidirectional_iterator<_InputIter>::value"Attempt to advance(it, n) with negative n on a non-bidirectional iterator"_InputIter &_IntegralDistance_RandIter_RandIter &_BiDirIter_BiDirIter &_LIBCPP___ITERATOR_ADVANCE_H!defined(_LIBCPP_HAS_NO_RANGES)_VSTD::__convert_to_integral(declval<_Distance>())std::__1::__convert_to_integral(declval<_Distance>())// _LIBCPP___ITERATOR_ADVANCE_H// !defined(_LIBCPP_HAS_NO_RANGES)// namespace ranges// Otherwise, while `bool(i != bound)` is true, decrements `i` but at most `-n` times.// most `n` times.// Otherwise, if `n` is non-negative, while `bool(i != bound)` is true, increments `i` but at// Otherwise, equivalent to `ranges::advance(i, n)`.// If |n| >= |bound - i|, equivalent to `ranges::advance(i, bound)`.// If `S` and `I` model `sized_sentinel_for<S, I>`:// Returns: `n - M`, where `M` is the difference between the the ending and starting position.//   * If `n < 0`, [bound, i) denotes a range, `I` models `bidirectional_iterator`, and `I` and `S` model `same_as<I, S>`.//   * If `n == 0`, [i, bound) or [bound, i) denotes a range.//   * If `n > 0`, [i, bound) denotes a range.// Preconditions:// Otherwise, while `bool(i != bound)` is true, increments `i`.// Otherwise, if `S` and `I` model `sized_sentinel_for<S, I>`, equivalent to `ranges::advance(i, bound - i)`.// If `I` and `S` model `assignable_from<I&, S>`, equivalent to `i = std::move(bound)`.// Preconditions: Either `assignable_from<I&, S> || sized_sentinel_for<S, I>` is modeled, or [i, bound) denotes a range.// Otherwise, if `n` is non-negative, increments `i` by `n`.// Otherwise, decrements `i` by `-n`.// If `I` models `random_access_iterator`, equivalent to `i += n`.// Preconditions: If `I` does not model `bidirectional_iterator`, `n` is not negative.// [range.iter.op.advance]__orig_n__e1__m2/Users/owura/Repos/codeql_eval/proj_repos/Exiv2-exiv2-pull-962-commits-e925bc5addd881543fa503470c8a859e112cca62/exiv2/src/exif.cpperaseIfdsumToLongsumfctconst ExifKey *const auto_ptr<ExifKey>const shortconst short &PreviewTags &const PreviewTagsconst PreviewTags &filteredIfd0TagsEXV_COUNTOF(filteredIfd0Tags)const IfdId[13]IfdId[13]const IfdId(&)[13]IfdId(&)[13]..(*)(..))[13]emptyIptcemptyXmpmio1TiffHeader *65527const PreviewTags[]PreviewTags[]filteredPvTagsdelTagschar(&)[28]const PreviewTags[28]PreviewTags[28]const PreviewTags(&)[28]PreviewTags(&)[28]..(*)(..))[28]EXV_COUNTOF(filteredPvTags)const PreviewTags *PreviewTags *pttLenExif tag "Exif tag " not encoded
" not encoded\n"pttTagpttIfdExif IFD "Exif IFD "tag_iter20480mio2Exif.Minolta.ThumbnailLength"Exif.Minolta.ThumbnailLength"Exif.Minolta.Thumbnail"Exif.Minolta.Thumbnail"Exif.NikonPreview.JPEGInterchangeFormatLength"Exif.NikonPreview.JPEGInterchangeFormatLength"NikonPreview"NikonPreview"Exif.Olympus.ThumbnailLength"Exif.Olympus.ThumbnailLength"Exif.Olympus.ThumbnailOffset"Exif.Olympus.ThumbnailOffset"Exif.Olympus.ThumbnailImage"Exif.Olympus.ThumbnailImage"Exif.Olympus.Thumbnail"Exif.Olympus.Thumbnail"Exif.Olympus2.ThumbnailLength"Exif.Olympus2.ThumbnailLength"Exif.Olympus2.ThumbnailOffset"Exif.Olympus2.ThumbnailOffset"Exif.Olympus2.ThumbnailImage"Exif.Olympus2.ThumbnailImage"Exif.Olympus2.Thumbnail"Exif.Olympus2.Thumbnail"Exif.OlympusCs.PreviewImageLength"Exif.OlympusCs.PreviewImageLength"Exif.OlympusCs.PreviewImageStart"Exif.OlympusCs.PreviewImageStart"Exif.OlympusCs.PreviewImageValid"Exif.OlympusCs.PreviewImageValid"Exif.Pentax.PreviewLength"Exif.Pentax.PreviewLength"Exif.Pentax.PreviewOffset"Exif.Pentax.PreviewOffset"Exif.Pentax.PreviewResolution"Exif.Pentax.PreviewResolution"Exif.PentaxDng.PreviewLength"Exif.PentaxDng.PreviewLength"Exif.PentaxDng.PreviewOffset"Exif.PentaxDng.PreviewOffset"Exif.PentaxDng.PreviewResolution"Exif.PentaxDng.PreviewResolution"Exif.SamsungPreview.JPEGInterchangeFormatLength"Exif.SamsungPreview.JPEGInterchangeFormatLength"SamsungPreview"SamsungPreview"Exif.Thumbnail.StripByteCounts"Exif.Thumbnail.StripByteCounts"Exif.Thumbnail.JPEGInterchangeFormatLength"Exif.Thumbnail.JPEGInterchangeFormatLength"Exif.Image.StripOffsets"Exif.Image.StripOffsets"Exif.Image.RowsPerStrip"Exif.Image.RowsPerStrip"Exif.Image.StripByteCounts"Exif.Image.StripByteCounts"Exif.Image.JPEGInterchangeFormat"Exif.Image.JPEGInterchangeFormat"Exif.Image.JPEGInterchangeFormatLength"Exif.Image.JPEGInterchangeFormatLength"Exif.Image.SubIFDs"Exif.Image.SubIFDs"Ignoring IPTC information encoded in the Exif data.
"Ignoring IPTC information encoded in the Exif data.\n"Ignoring XMP information encoded in the Exif data.
"Ignoring XMP information encoded in the Exif data.\n"ExifThumb *Exif.Thumbnail.Compression"Exif.Thumbnail.Compression"uint16_t(6)Exif.Thumbnail.JPEGInterchangeFormat"Exif.Thumbnail.JPEGInterchangeFormat"uint32_t(0)Exif.Thumbnail.XResolution"Exif.Thumbnail.XResolution"Exif.Thumbnail.YResolution"Exif.Thumbnail.YResolution"Exif.Thumbnail.ResolutionUnit"Exif.Thumbnail.ResolutionUnit"const ExifThumbC *ExifThumbC *thumbnailThumbnail *const auto_ptr<Thumbnail>const Thumbnailconst Thumbnail *FindExifdatumByKey &const FindExifdatumByKeyconst FindExifdatumByKey &FindExifdatumByKeyFindExifdatumByKey *const FindExifdatumByKey *~JpegThumbnailJpegThumbnail *JpegThumbnailconst JpegThumbnailconst JpegThumbnail &JpegThumbnail &const JpegThumbnail *.jpg".jpg"~TiffThumbnailTiffThumbnail *TiffThumbnailconst TiffThumbnailconst TiffThumbnail &TiffThumbnail &const TiffThumbnail *.tif".tif"Exif.Image."Exif.Image."Exiv2::littleEndianThumbnail &const Thumbnail &compressionauto_ptr<Thumbnail> &~ThumbnailPreviewTagsPttptt_// Copy all Thumbnail (IFD1) tags from exifData to Image (IFD0) tags in thumb// ExifParser::encode// Encode the remaining Exif tags again, don't care if it fits this time// Delete unknown tags larger than 4kB and known tags larger than 20kB.// Table must be sorted by preview, the first tag in each group is the size// Todo: Enhance preview classes to be able to write and delete previews and use that instead.// Delete preview tags if the preview is larger than 32kB.// If it doesn't fit, remove additional tags// Encode and check if the result fits into a JPEG Exif APP1 segment// IPTC and XMP are stored elsewhere, not in the Exif APP1 segment.// Delete IFDs which do not occur in JPEGs// Reference: Exif 2.2 specs, 4.6.8 Tag Support Levels, section A// Delete IFD0 tags that are "not recorded" in compressed images// ExifParser::decode// allow duplicates// Exifdatum::operator=// deep copy/*!
      @brief Set the value of \em exifDatum to \em value. If the object already
             has a value, it is replaced. Otherwise a new ValueType\<T\> value
             is created and set to \em value.

      This is a helper function, called from Exifdatum members. It is meant to
      be used with T = (u)int16_t, (u)int32_t or (U)Rational. Do not use directly.
    *///! Helper function to delete all tags of a specific IFD from the metadata.//! Helper function to sum all components of the value of a metadatum// class JpegThumbnail//! Shortcut for a %JpegThumbnail auto pointer.//! Exif thumbnail image in JPEG format// class TiffThumbnail//! Shortcut for a %TiffThumbnail auto pointer.//! Exif thumbnail image in TIFF format// class Thumbnail/*!
          @brief Return the file extension for the format of the thumbnail
                 (".tif", ".jpg").
         *//*!
          @brief Return the MIME type of the thumbnail ("image/tiff" or
                 "image/jpeg").
         *///! Factory function to create a thumbnail for the Exif metadata provided.//! Shortcut for a %Thumbnail auto pointer./*!
      @brief Exif %Thumbnail image. This abstract base class provides the
             interface for the thumbnail image that is optionally embedded in
             the Exif data. This class is used internally by ExifData, it is
             probably not useful for a client as a standalone class.  Instead,
             use an instance of ExifData to access the Exif thumbnail image.
     */// class FindExifdatumByKey/*!
          @brief Returns true if the key of \em exifdatum is equal
                 to that of the object.
        *///! Constructor, initializes the object with the key to look for//! Unary predicate that matches a Exifdatum with a given key// for Tag::root/*
  File:      exif.cpp
  Author(s): Andreas Huggel (ahu) <ahuggel@gmx.net>
  History:   26-Jan-04, ahu: created
             11-Feb-04, ahu: isolated as a component
 */exifDatumauto_ptr_ref<Thumbnail>auto_ptr_ref<Thumbnail> &const auto_ptr_ref<Thumbnail>const auto_ptr_ref<Thumbnail> &auto_ptr_ref<ExifKey>auto_ptr_ref<ExifKey> &const auto_ptr_ref<ExifKey>const auto_ptr_ref<ExifKey> &auto_ptr<Thumbnail>auto_ptr<TiffThumbnail>auto_ptr<JpegThumbnail>allocator<short>allocator<short> &const allocator<short>const allocator<short> &allocator<short> *const short *short *__identity<allocator<short>>__identity<allocator<short>> &const __identity<allocator<short>>const __identity<allocator<short>> &allocator<int>allocator<int> &const allocator<int>const allocator<int> &allocator<int> *const int *__identity<allocator<int>>__identity<allocator<int>> &const __identity<allocator<int>>const __identity<allocator<int>> &const ValueType<pair<int, int>> &ValueType<pair<int, int>> &const __wrap_iter<const pair<int, int> *>const __wrap_iter<const pair<int, int> *> &__wrap_iter<const pair<int, int> *> &vector<pair<int, int>, allocator<pair<int, int>>> &ValueType<int> *const ValueType<int>const ValueType<int> *const ValueType<int> &ValueType<int> &const __wrap_iter<const int *>const __wrap_iter<const int *> &__wrap_iter<const int *> &vector<int, allocator<int>> &ValueType<short> *const ValueType<short>const ValueType<short> *const ValueType<short> &ValueType<short> &const __wrap_iter<const short *>const __wrap_iter<const short *> &__wrap_iter<const short *> &vector<short, allocator<short>> &auto_ptr<Thumbnail> *const auto_ptr<Thumbnail> *operator std::__1::auto_ptr_ref<<unnamed>::Thumbnail>auto_ptr<ExifKey> *operator std::__1::auto_ptr_ref<Exiv2::ExifKey>const auto_ptr<ValueType<unsigned short>>auto_ptr<ValueType<unsigned short>> &const auto_ptr<ValueType<unsigned int>>auto_ptr<ValueType<unsigned int>> &const auto_ptr<ValueType<short>>auto_ptr<ValueType<short>> &const auto_ptr<ValueType<int>>auto_ptr<ValueType<int>> &const auto_ptr<ValueType<pair<int, int>>>auto_ptr<ValueType<pair<int, int>>> &const auto_ptr<ExifKey> *const vector<Xmpdatum, allocator<Xmpdatum>>const vector<Xmpdatum, allocator<Xmpdatum>> *operator Exiv2::Iptcdatum *operator Exiv2::ExifKey *operator Exiv2::ValueType<unsigned short> *operator Exiv2::ValueType<unsigned int> *operator Exiv2::ValueType<std::__1::pair<unsigned int, unsigned int>> *operator short *operator Exiv2::ValueType<short> *operator int *operator Exiv2::ValueType<int> *operator std::__1::pair<int, int> *operator Exiv2::ValueType<std::__1::pair<int, int>> *operator <unnamed>::Thumbnail *bidirectional_iterator_tag *operator std::__1::bidirectional_iterator_tag *auto_ptr_ref<ValueType<pair<int, int>>>auto_ptr_ref<ValueType<pair<int, int>>> &const auto_ptr_ref<ValueType<pair<int, int>>>const auto_ptr_ref<ValueType<pair<int, int>>> &auto_ptr_ref<ValueType<int>>auto_ptr_ref<ValueType<int>> &const auto_ptr_ref<ValueType<int>>const auto_ptr_ref<ValueType<int>> &auto_ptr_ref<ValueType<short>>auto_ptr_ref<ValueType<short>> &const auto_ptr_ref<ValueType<short>>const auto_ptr_ref<ValueType<short>> &auto_ptr_ref<ValueType<pair<unsigned int, unsigned int>>>auto_ptr_ref<ValueType<pair<unsigned int, unsigned int>>> &const auto_ptr_ref<ValueType<pair<unsigned int, unsigned int>>>const auto_ptr_ref<ValueType<pair<unsigned int, unsigned int>>> &auto_ptr_ref<ValueType<unsigned int>>auto_ptr_ref<ValueType<unsigned int>> &const auto_ptr_ref<ValueType<unsigned int>>const auto_ptr_ref<ValueType<unsigned int>> &auto_ptr_ref<ValueType<unsigned short>>auto_ptr_ref<ValueType<unsigned short>> &const auto_ptr_ref<ValueType<unsigned short>>const auto_ptr_ref<ValueType<unsigned short>> &__vector_base<short, allocator<short>>__vector_base<short, allocator<short>> &const __vector_base<short, allocator<short>>const __vector_base<short, allocator<short>> &__vector_base<int, allocator<int>>__vector_base<int, allocator<int>> &const __vector_base<int, allocator<int>>const __vector_base<int, allocator<int>> &__non_trivial_if<true, allocator<int>>__non_trivial_if<true, allocator<int>> &const __non_trivial_if<true, allocator<int>>const __non_trivial_if<true, allocator<int>> &__non_trivial_if<true, allocator<short>>__non_trivial_if<true, allocator<short>> &const __non_trivial_if<true, allocator<short>>const __non_trivial_if<true, allocator<short>> &auto_ptr<ValueType<int>>auto_ptr<ValueType<short>>__wrap_iter<const pair<int, int> *> *vector<short, allocator<short>>__wrap_iter<short *>__wrap_iter<const short *>__wrap_iter<const short *> *vector<int, allocator<int>>__wrap_iter<int *>__wrap_iter<const int *>__wrap_iter<const int *> *const __vector_base<Xmpdatum, allocator<Xmpdatum>> *auto_ptr<ValueType<pair<int, int>>> *const auto_ptr<ValueType<pair<int, int>>> *operator std::__1::auto_ptr_ref<Exiv2::ValueType<std::__1::pair<int, int>>>auto_ptr<ValueType<int>> *const auto_ptr<ValueType<int>> *operator std::__1::auto_ptr_ref<Exiv2::ValueType<int>>auto_ptr<ValueType<short>> *const auto_ptr<ValueType<short>> *operator std::__1::auto_ptr_ref<Exiv2::ValueType<short>>operator std::__1::auto_ptr_ref<Exiv2::ValueType<std::__1::pair<unsigned int, unsigned int>>>auto_ptr<ValueType<unsigned int>> *const auto_ptr<ValueType<unsigned int>> *operator std::__1::auto_ptr_ref<Exiv2::ValueType<unsigned int>>auto_ptr<ValueType<unsigned short>> *const auto_ptr<ValueType<unsigned short>> *operator std::__1::auto_ptr_ref<Exiv2::ValueType<unsigned short>>vector<short, allocator<short>> *const vector<short, allocator<short>>const vector<short, allocator<short>> *__vector_base<short, allocator<short>> *short *&const __vector_base<short, allocator<short>> *const __wrap_iter<const short *> *vector<int, allocator<int>> *const vector<int, allocator<int>>const vector<int, allocator<int>> *__vector_base<int, allocator<int>> *int *&const __vector_base<int, allocator<int>> *const __wrap_iter<const int *> *const __wrap_iter<const pair<int, int> *> *__iterator_traits_impl<__list_iterator<Exifdatum, void *>, true>__iterator_traits_impl<__list_iterator<Exifdatum, void *>, true> &const __iterator_traits_impl<__list_iterator<Exifdatum, void *>, true>const __iterator_traits_impl<__list_iterator<Exifdatum, void *>, true> &enable_if<true, __list_iterator<Exifdatum, void *>>enable_if<true, __list_iterator<Exifdatum, void *>> &const enable_if<true, __list_iterator<Exifdatum, void *>>const enable_if<true, __list_iterator<Exifdatum, void *>> &iterator_traits<const int *>iterator_traits<const int *> &const iterator_traits<const int *>const iterator_traits<const int *> &reverse_iterator<__wrap_iter<int *>>reverse_iterator<__wrap_iter<const int *>>iterator_traits<const short *>iterator_traits<const short *> &const iterator_traits<const short *>const iterator_traits<const short *> &reverse_iterator<__wrap_iter<short *>>reverse_iterator<__wrap_iter<const short *>>iterator_traits<const pair<int, int> *>iterator_traits<const pair<int, int> *> &const iterator_traits<const pair<int, int> *>const iterator_traits<const pair<int, int> *> &__compressed_pair<int *, allocator<int>>__compressed_pair<int *, allocator<int>> &const __compressed_pair<int *, allocator<int>>const __compressed_pair<int *, allocator<int>> &allocator_traits<allocator<int>>allocator_traits<allocator<int>> &const allocator_traits<allocator<int>>const allocator_traits<allocator<int>> &__compressed_pair<short *, allocator<short>>__compressed_pair<short *, allocator<short>> &const __compressed_pair<short *, allocator<short>>const __compressed_pair<short *, allocator<short>> &allocator_traits<allocator<short>>allocator_traits<allocator<short>> &const allocator_traits<allocator<short>>const allocator_traits<allocator<short>> &const vector<pair<int, int>, allocator<pair<int, int>>> &const pair<int, int> &&pair<int, int> &&__split_buffer<pair<int, int>, allocator<pair<int, int>> &> &pair<int, int> *&&const vector<int, allocator<int>> &const int &&__split_buffer<int, allocator<int> &> &int *&&const vector<short, allocator<short>> &const short &&short &&__split_buffer<short, allocator<short> &> &short *&&"Attempt to next(it, n) with negative n on a non-bidirectional iterator"remove_reference<short *&>remove_reference<short *&> &const remove_reference<short *&>const remove_reference<short *&> &remove_reference<const short &>remove_reference<const short &> &const remove_reference<const short &>const remove_reference<const short &> &remove_reference<const short>remove_reference<const short> &const remove_reference<const short>const remove_reference<const short> &__split_buffer<short, allocator<short> &>remove_reference<int *&>remove_reference<int *&> &const remove_reference<int *&>const remove_reference<int *&> &remove_reference<const int &>remove_reference<const int &> &const remove_reference<const int &>const remove_reference<const int &> &remove_reference<const int>remove_reference<const int> &const remove_reference<const int>const remove_reference<const int> &__split_buffer<int, allocator<int> &>remove_reference<pair<int, int> *&>remove_reference<pair<int, int> *&> &const remove_reference<pair<int, int> *&>const remove_reference<pair<int, int> *&> &remove_reference<const pair<int, int> &>remove_reference<const pair<int, int> &> &const remove_reference<const pair<int, int> &>const remove_reference<const pair<int, int> &> &remove_reference<const pair<int, int>>remove_reference<const pair<int, int>> &const remove_reference<const pair<int, int>>const remove_reference<const pair<int, int>> &__split_buffer<pair<int, int>, allocator<pair<int, int>> &>__pointer<short, allocator<short>, allocator<short>, true>__pointer<short, allocator<short>, allocator<short>, true> &const __pointer<short, allocator<short>, allocator<short>, true>const __pointer<short, allocator<short>, allocator<short>, true> &__const_pointer<short, short *, allocator<short>, true>__const_pointer<short, short *, allocator<short>, true> &const __const_pointer<short, short *, allocator<short>, true>const __const_pointer<short, short *, allocator<short>, true> &__void_pointer<short *, allocator<short>, false>__void_pointer<short *, allocator<short>, false> &const __void_pointer<short *, allocator<short>, false>const __void_pointer<short *, allocator<short>, false> &__const_void_pointer<short *, allocator<short>, false>__const_void_pointer<short *, allocator<short>, false> &const __const_void_pointer<short *, allocator<short>, false>const __const_void_pointer<short *, allocator<short>, false> &__alloc_traits_difference_type<allocator<short>, short *, true>__alloc_traits_difference_type<allocator<short>, short *, true> &const __alloc_traits_difference_type<allocator<short>, short *, true>const __alloc_traits_difference_type<allocator<short>, short *, true> &__size_type<allocator<short>, long, true>__size_type<allocator<short>, long, true> &const __size_type<allocator<short>, long, true>const __size_type<allocator<short>, long, true> &__propagate_on_container_move_assignment<allocator<short>, true>__propagate_on_container_move_assignment<allocator<short>, true> &const __propagate_on_container_move_assignment<allocator<short>, true>const __propagate_on_container_move_assignment<allocator<short>, true> &__is_always_equal<allocator<short>, true>__is_always_equal<allocator<short>, true> &const __is_always_equal<allocator<short>, true>const __is_always_equal<allocator<short>, true> &__compressed_pair_elem<allocator<short>, 1, true>__compressed_pair_elem<allocator<short>, 1, true> &const __compressed_pair_elem<allocator<short>, 1, true>const __compressed_pair_elem<allocator<short>, 1, true> &__compressed_pair_elem<short *, 0, false>__compressed_pair_elem<short *, 0, false> &const __compressed_pair_elem<short *, 0, false>const __compressed_pair_elem<short *, 0, false> &short *constshort *const &__pointer<int, allocator<int>, allocator<int>, true>__pointer<int, allocator<int>, allocator<int>, true> &const __pointer<int, allocator<int>, allocator<int>, true>const __pointer<int, allocator<int>, allocator<int>, true> &__const_pointer<int, int *, allocator<int>, true>__const_pointer<int, int *, allocator<int>, true> &const __const_pointer<int, int *, allocator<int>, true>const __const_pointer<int, int *, allocator<int>, true> &__void_pointer<int *, allocator<int>, false>__void_pointer<int *, allocator<int>, false> &const __void_pointer<int *, allocator<int>, false>const __void_pointer<int *, allocator<int>, false> &__const_void_pointer<int *, allocator<int>, false>__const_void_pointer<int *, allocator<int>, false> &const __const_void_pointer<int *, allocator<int>, false>const __const_void_pointer<int *, allocator<int>, false> &__alloc_traits_difference_type<allocator<int>, int *, true>__alloc_traits_difference_type<allocator<int>, int *, true> &const __alloc_traits_difference_type<allocator<int>, int *, true>const __alloc_traits_difference_type<allocator<int>, int *, true> &__size_type<allocator<int>, long, true>__size_type<allocator<int>, long, true> &const __size_type<allocator<int>, long, true>const __size_type<allocator<int>, long, true> &__propagate_on_container_move_assignment<allocator<int>, true>__propagate_on_container_move_assignment<allocator<int>, true> &const __propagate_on_container_move_assignment<allocator<int>, true>const __propagate_on_container_move_assignment<allocator<int>, true> &__is_always_equal<allocator<int>, true>__is_always_equal<allocator<int>, true> &const __is_always_equal<allocator<int>, true>const __is_always_equal<allocator<int>, true> &__compressed_pair_elem<allocator<int>, 1, true>__compressed_pair_elem<allocator<int>, 1, true> &const __compressed_pair_elem<allocator<int>, 1, true>const __compressed_pair_elem<allocator<int>, 1, true> &__compressed_pair_elem<int *, 0, false>__compressed_pair_elem<int *, 0, false> &const __compressed_pair_elem<int *, 0, false>const __compressed_pair_elem<int *, 0, false> &int *constint *const &remove_cv<const pair<int, int>>remove_cv<const pair<int, int>> &const remove_cv<const pair<int, int>>const remove_cv<const pair<int, int>> &remove_cv<const short>remove_cv<const short> &const remove_cv<const short>const remove_cv<const short> &remove_cv<const int>remove_cv<const int> &const remove_cv<const int>const remove_cv<const int> &__compressed_pair_elem<allocator<__list_node<Exifdatum, void *>>, 1, true> *__compressed_pair<Xmpdatum *, allocator<Xmpdatum>> *__compressed_pair<short *, allocator<short>> *__split_buffer<short, allocator<short> &> *const __split_buffer<short, allocator<short> &>const __split_buffer<short, allocator<short> &> *__compressed_pair<int *, allocator<int>> *__split_buffer<int, allocator<int> &> *const __split_buffer<int, allocator<int> &>const __split_buffer<int, allocator<int> &> *__compressed_pair<pair<int, int> *, allocator<pair<int, int>>> *__split_buffer<pair<int, int>, allocator<pair<int, int>> &> *const __split_buffer<pair<int, int>, allocator<pair<int, int>> &>const __split_buffer<pair<int, int>, allocator<pair<int, int>> &> *remove_volatile<int>remove_volatile<int> &const remove_volatile<int>const remove_volatile<int> &remove_volatile<short>remove_volatile<short> &const remove_volatile<short>const remove_volatile<short> &remove_volatile<pair<int, int>>remove_volatile<pair<int, int>> &const remove_volatile<pair<int, int>>const remove_volatile<pair<int, int>> &__compressed_pair<pair<int, int> *, allocator<pair<int, int>> &>__compressed_pair<pair<int, int> *, allocator<pair<int, int>> &> &const __compressed_pair<pair<int, int> *, allocator<pair<int, int>> &>const __compressed_pair<pair<int, int> *, allocator<pair<int, int>> &> &remove_reference<allocator<pair<int, int>> &>remove_reference<allocator<pair<int, int>> &> &const remove_reference<allocator<pair<int, int>> &>const remove_reference<allocator<pair<int, int>> &> &add_lvalue_reference<allocator<pair<int, int>> &>add_lvalue_reference<allocator<pair<int, int>> &> &const add_lvalue_reference<allocator<pair<int, int>> &>const add_lvalue_reference<allocator<pair<int, int>> &> &__compressed_pair<int *, allocator<int> &>__compressed_pair<int *, allocator<int> &> &const __compressed_pair<int *, allocator<int> &>const __compressed_pair<int *, allocator<int> &> &remove_reference<allocator<int> &>remove_reference<allocator<int> &> &const remove_reference<allocator<int> &>const remove_reference<allocator<int> &> &add_lvalue_reference<allocator<int> &>add_lvalue_reference<allocator<int> &> &const add_lvalue_reference<allocator<int> &>const add_lvalue_reference<allocator<int> &> &__compressed_pair<short *, allocator<short> &>__compressed_pair<short *, allocator<short> &> &const __compressed_pair<short *, allocator<short> &>const __compressed_pair<short *, allocator<short> &> &remove_reference<allocator<short> &>remove_reference<allocator<short> &> &const remove_reference<allocator<short> &>const remove_reference<allocator<short> &> &add_lvalue_reference<allocator<short> &>add_lvalue_reference<allocator<short> &> &const add_lvalue_reference<allocator<short> &>const add_lvalue_reference<allocator<short> &> &const __compressed_pair<pair<int, int> *, allocator<pair<int, int>>> *__compressed_pair_elem<allocator<pair<int, int>>, 1, true> *__compressed_pair_elem<pair<int, int> *, 0, false> *allocator<pair<int, int>> *const __compressed_pair<int *, allocator<int>> *__compressed_pair_elem<allocator<int>, 1, true> *__compressed_pair_elem<int *, 0, false> *const __compressed_pair<short *, allocator<short>> *__compressed_pair_elem<allocator<short>, 1, true> *__compressed_pair_elem<short *, 0, false> *const __compressed_pair<Xmpdatum *, allocator<Xmpdatum>> *allocator<__list_node<Exifdatum, void *>> *remove_reference<const allocator<short> &>remove_reference<const allocator<short> &> &const remove_reference<const allocator<short> &>const remove_reference<const allocator<short> &> &remove_reference<const allocator<int> &>remove_reference<const allocator<int> &> &const remove_reference<const allocator<int> &>const remove_reference<const allocator<int> &> &remove_reference<const allocator<pair<int, int>> &>remove_reference<const allocator<pair<int, int>> &> &const remove_reference<const allocator<pair<int, int>> &>const remove_reference<const allocator<pair<int, int>> &> &__add_lvalue_reference_impl<allocator<short> &, true>__add_lvalue_reference_impl<allocator<short> &, true> &const __add_lvalue_reference_impl<allocator<short> &, true>const __add_lvalue_reference_impl<allocator<short> &, true> &__compressed_pair_elem<allocator<short> &, 1, false>__compressed_pair_elem<allocator<short> &, 1, false> &const __compressed_pair_elem<allocator<short> &, 1, false>const __compressed_pair_elem<allocator<short> &, 1, false> &__add_lvalue_reference_impl<allocator<int> &, true>__add_lvalue_reference_impl<allocator<int> &, true> &const __add_lvalue_reference_impl<allocator<int> &, true>const __add_lvalue_reference_impl<allocator<int> &, true> &__compressed_pair_elem<allocator<int> &, 1, false>__compressed_pair_elem<allocator<int> &, 1, false> &const __compressed_pair_elem<allocator<int> &, 1, false>const __compressed_pair_elem<allocator<int> &, 1, false> &__add_lvalue_reference_impl<allocator<pair<int, int>> &, true>__add_lvalue_reference_impl<allocator<pair<int, int>> &, true> &const __add_lvalue_reference_impl<allocator<pair<int, int>> &, true>const __add_lvalue_reference_impl<allocator<pair<int, int>> &, true> &__compressed_pair_elem<allocator<pair<int, int>> &, 1, false>__compressed_pair_elem<allocator<pair<int, int>> &, 1, false> &const __compressed_pair_elem<allocator<pair<int, int>> &, 1, false>const __compressed_pair_elem<allocator<pair<int, int>> &, 1, false> &pointer_traits<short *>pointer_traits<short *> &const pointer_traits<short *>const pointer_traits<short *> &pointer_traits<int *>pointer_traits<int *> &const pointer_traits<int *>const pointer_traits<int *> &__non_trivial_if<true, allocator<__list_node<Exifdatum, void *>>> *__non_trivial_if<true, allocator<Iptcdatum>> *const __compressed_pair_elem<Xmpdatum *, 0, false> *__compressed_pair_elem<Xmpdatum *, 0, false> *__compressed_pair<short *, allocator<short> &> *const __compressed_pair_elem<allocator<short>, 1, true> *__compressed_pair<int *, allocator<int> &> *const __compressed_pair_elem<allocator<int>, 1, true> *__compressed_pair<pair<int, int> *, allocator<pair<int, int>> &> *const __compressed_pair_elem<allocator<pair<int, int>>, 1, true> *__is_referenceable<allocator<pair<int, int>> &>__is_referenceable<allocator<pair<int, int>> &> &const __is_referenceable<allocator<pair<int, int>> &>const __is_referenceable<allocator<pair<int, int>> &> &__is_referenceable<allocator<int> &>__is_referenceable<allocator<int> &> &const __is_referenceable<allocator<int> &>const __is_referenceable<allocator<int> &> &__is_referenceable<allocator<short> &>__is_referenceable<allocator<short> &> &const __is_referenceable<allocator<short> &>const __is_referenceable<allocator<short> &> &__non_trivial_if<true, allocator<pair<int, int>>> *const allocator<pair<int, int>> *const __compressed_pair<pair<int, int> *, allocator<pair<int, int>> &> *__compressed_pair_elem<allocator<pair<int, int>> &, 1, false> *const __compressed_pair_elem<pair<int, int> *, 0, false> *__non_trivial_if<true, allocator<int>> *const allocator<int> *const __compressed_pair<int *, allocator<int> &> *__compressed_pair_elem<allocator<int> &, 1, false> *const __compressed_pair_elem<int *, 0, false> *__non_trivial_if<true, allocator<short>> *const allocator<short> *const __compressed_pair<short *, allocator<short> &> *__compressed_pair_elem<allocator<short> &, 1, false> *const __compressed_pair_elem<short *, 0, false> *const reverse_iterator<_Iter>const reverse_iterator<_Iter> &reverse_iterator<_Iter> &const reverse_iterator<_Iter1>const reverse_iterator<_Iter1> &reverse_iterator<_Iter1> &const reverse_iterator<_Iter2>const reverse_iterator<_Iter2> &reverse_iterator<_Iter2> &reverse_iterator<_Iter> *const reverse_iterator<_Iter> *const reverse_iterator<_Up>const reverse_iterator<_Up> &reverse_iterator<_Up> &reverse_iterator<_Iter>__is_stashing_iterator<_Tp, type>__is_stashing_iterator<_Tp, <unnamed>>current!__is_stashing_iterator<_Iter>::value, "The specified iterator type cannot be used with reverse_iterator; " "Using stashing iterators with reverse_iterator causes undefined behavior"The specified iterator type cannot be used with reverse_iterator; Using stashing iterators with reverse_iterator causes undefined behavior_LIBCPP___ITERATOR_REVERSE_ITERATOR_H_LIBCPP_ABI_NO_ITERATOR_BASES// _LIBCPP___ITERATOR_REVERSE_ITERATOR_H// no longer used as of LWG #2360, not removed due to ABI breakconst __less<_T1, _T1>const __less<_T1, _T1> *__less<_T1, _T1> *const __equal_to<_T1, _T1>const __equal_to<_T1, _T1> *__equal_to<_T1, _T1> *__less<_T1, const _T1>__less<const _T1, _T1>__less<_T1, _T1>__less<_T1, _T2>__equal_to<_T1, const _T1>__equal_to<const _T1, _T1>__equal_to<_T1, _T1>__equal_to<_T1, _T2>_LIBCPP___ALGORITHM_COMP_H// _LIBCPP___ALGORITHM_COMP_H//   * We haven't included <functional> here.//   * That only works with C++14 and later, and// I'd like to replace these with _VSTD::equal_to<void>, but can't because:__v1__v2_InputIterator1_InputIterator2_BinaryPredicate_LIBCPP___ALGORITHM_EQUAL_H// _LIBCPP___ALGORITHM_EQUAL_H// FIXME: replace with <__iterator/distance.h> when it lands__find_first_of_ce_LIBCPP___ALGORITHM_FIND_FIRST_OF_H// _LIBCPP___ALGORITHM_FIND_FIRST_OF_H__csisGifTypenewGifInstance~GifImageGifImageGifImage &const GifImageconst GifImage &gifGIFIMAGE_HPP_// #ifndef GIFIMAGE_HPP_//! Check if the file iIo is a GIF image./*!
      @brief Create a new GifImage instance and return an auto-pointer to it.
             Caller owns the returned object and the auto-pointer ensures that
             it will be deleted.
     */// class GifImage/*!
          @brief Constructor to open a GIF image. Since the
              constructor can not return a result, callers should check the
              good() method after object construction to determine success
              or failure.
          @param io An auto-pointer that owns a BasicIo instance used for
              reading and writing image metadata. \b Important: The constructor
              takes ownership of the passed in BasicIo instance through the
              auto-pointer. Callers should not continue to use the BasicIo
              instance after it is passed to this method.  Use the Image::io()
              method to get a temporary reference.
         *//*!
      @brief Class to access raw GIF images. Exif/IPTC metadata are supported
             directly.
     *///!< GIF image type (see class GifImage)// Add GIF to the supported image formats/*!
  @file    gifimage.hpp
  @brief   GIF image, implemented using the following references:
           <a href="http://www.w3.org/Graphics/GIF/spec-gif89a.txt">GIF89 specification</a> by W3C<br>
  @author  Marco Piovanelli, Ovolab (marco)
           <a href="mailto:marco.piovanelli@pobox.com">marco.piovanelli@pobox.com</a>
  @date    26-Feb-2007, marco: created
 */isJp2TypenewJp2Instance~Jp2ImageencodeJp2HeaderdoWriteMetadataJp2Image &const Jp2Imageconst Jp2Image &Jp2Imagejp2JP2IMAGE_HPP_// #ifndef JP2IMAGE_HPP_//! Check if the file iIo is a JPEG-2000 image./*!
      @brief Create a new Jp2Image instance and return an auto-pointer to it.
             Caller owns the returned object and the auto-pointer ensures that
             it will be deleted.
     */// class Jp2Image/*!
         @brief reformats the Jp2Header to store iccProfile
         @param oldData DataBufRef to data in the file.
         @param newData DataBufRef with updated data
         *//*!
          @brief Provides the main implementation of writeMetadata() by
                writing all buffered metadata to the provided BasicIo.
          @param oIo BasicIo instance to write to (a temporary location).

          @return 4 if opening or writing to the associated BasicIo fails
         *//*!
          @brief Constructor to open a JPEG-2000 image. Since the
              constructor can not return a result, callers should check the
              good() method after object construction to determine success
              or failure.
          @param io An auto-pointer that owns a BasicIo instance used for
              reading and writing image metadata. \b Important: The constructor
              takes ownership of the passed in BasicIo instance through the
              auto-pointer. Callers should not continue to use the BasicIo
              instance after it is passed to this method.  Use the Image::io()
              method to get a temporary reference.
          @param create Specifies if an existing image should be read (false)
              or if a new file should be created (true).
         *//*!
      @brief Class to access JPEG-2000 images.
     *///!< JPEG-2000 image type// Add JPEG-2000 to the supported image formats/*
  File:      jp2image.cpp
*/oldDatanewDataoIonewExvInstancenewJpegInstanceisExvTypeisJpegType~ExvImageExvImage &const ExvImageconst ExvImage &ExvImageisThisType~JpegImageJpegImage &const JpegImageconst JpegImage &JpegImage~JpegBaseadvanceToMarkerinitImageJpegBase &const JpegBaseconst JpegBase &JpegBasePhotoshop &const Photoshopconst Photoshop &setIptcIrblocatePreviewIrbuint32_t *constlocateIptcIrblocateIrbisIrbPhotoshopexvjpegblank_exiv2Id_soi_iccId_xmpId_jfifId_exifId_sof15_sof14_sof13_sof11_sof10_sof9_sof7_sof6_sof5_sof3_sof2_sof1_sof0_com_app13_app2_app1_app0_eoi_sos_dri_dqt_dht_preview_bimId_irbId_ps3Id_JPGIMAGE_HPP_// #ifndef JPGIMAGE_HPP_//! Check if the file iIo is an EXV file/*!
      @brief Create a new ExvImage instance and return an auto-pointer to it.
             Caller owns the returned object and the auto-pointer ensures that
             it will be deleted.
     *///! Check if the file iIo is a JPEG image./*!
      @brief Create a new JpegImage instance and return an auto-pointer to it.
             Caller owns the returned object and the auto-pointer ensures that
             it will be deleted.
     */// class ExvImage// NOT Implemented// Minimal exiv2 file// EXV identifier/*!
          @brief Constructor that can either open an existing EXV image or create
              a new image from scratch. If a new image is to be created, any
              existing data is overwritten. Since the constructor can not return
              a result, callers should check the good() method after object
              construction to determine success or failure.
          @param io An auto-pointer that owns a BasicIo instance used for
              reading and writing image metadata. \b Important: The constructor
              takes ownership of the passed in BasicIo instance through the
              auto-pointer. Callers should not continue to use the BasicIo
              instance after it is passed to this method.  Use the Image::io()
              method to get a temporary reference.
          @param create Specifies if an existing image should be read (false)
                 or if a new file should be created (true).
         *///! Helper class to access %Exiv2 files// class JpegImage// Minimal Jpeg image// SOI marker/*!
          @brief Writes a Jpeg header (aka signature) to the BasicIo instance.
          @param oIo BasicIo instance that the header is written to.
          @return 0 if successful;<BR>
                 2 if the input image is invalid or can not be read;<BR>
                 4 if the temporary image can not be written to;<BR>
                -3 other temporary errors
         *//*!
          @brief Constructor that can either open an existing Jpeg image or create
              a new image from scratch. If a new image is to be created, any
              existing data is overwritten. Since the constructor can not return
              a result, callers should check the good() method after object
              construction to determine success or failure.
          @param io An auto-pointer that owns a BasicIo instance used for
              reading and writing image metadata. \b Important: The constructor
              takes ownership of the passed in BasicIo instance through the
              auto-pointer. Callers should not continue to use the BasicIo
              instance after it is passed to this method.  Use the Image::io()
              method to get a temporary reference.
          @param create Specifies if an existing image should be read (false)
              or if a new file should be created (true).
         *//*!
      @brief Class to access JPEG images
     */// class JpegBase/*!
          @brief Advances associated io instance to one byte past the next
              Jpeg marker and returns the marker. This method should be called
              when the BasicIo instance is positioned one byte past the end of a
              Jpeg segment.
          @return the next Jpeg segment marker if successful;<BR>
                 -1 if a maker was not found before EOF
         *//*!
          @brief Initialize the image with the provided data.
          @param initData Data to be written to the associated BasicIo
          @param dataSize Size in bytes of data to be written
          @return 0 if successful;<BR>
                  4 if the image can not be written to.
         *///!< ICC profile identifier//!< XMP packet identifier//!< JFIF identifier//!< Exif identifier//!< JPEG Start-Of-Frame marker//!< JPEG Comment marker//!< JPEG APP13 marker//!< JPEG APP2 marker//!< JPEG APP1 marker//!< JPEG APP0 marker//!< JPEG EOI marker//!< JPEG SOS marker//!< JPEG DRI marker//!< JPEG DQT marker//!< JPEG DHT marker// Constant Data/*!
          @brief Writes the image header (aka signature) to the BasicIo instance.
          @param oIo BasicIo instance that the header is written to.
          @return 0 if successful;<BR>
                  4 if the output file can not be written to
         *//*!
          @brief Determine if the content of the BasicIo instance is of the
              type supported by this class.

          The advance flag determines if the read position in the stream is
          moved (see below). This applies only if the type matches and the
          function returns true. If the type does not match, the stream
          position is not changed. However, if reading from the stream fails,
          the stream position is undefined. Consult the stream state to obtain
          more information in this case.

          @param iIo BasicIo instance to read from.
          @param advance Flag indicating whether the position of the io
              should be advanced by the number of characters read to
              analyse the data (true) or left at its original
              position (false). This applies only if the type matches.
          @return  true  if the data matches the type of this class;<BR>
                   false if the data does not match
         *//*!
          @brief Constructor that can either open an existing image or create
              a new image from scratch. If a new image is to be created, any
              existing data is overwritten.
          @param type Image type.
          @param io An auto-pointer that owns a BasicIo instance used for
              reading and writing image metadata. \b Important: The constructor
              takes ownership of the passed in BasicIo instance through the
              auto-pointer. Callers should not continue to use the BasicIo
              instance after it is passed to this method.  Use the Image::io()
              method to get a temporary reference.
          @param create Specifies if an existing image should be read (false)
              or if a new image should be created (true).
          @param initData Data to initialize newly created images. Only used
              when \em create is true. Should contain data for the smallest
              valid image of the calling subclass.
          @param dataSize Size of initData in bytes.
         *//*!
      @brief Abstract helper base class to access JPEG images.
     */// class Photoshop/*!
          @brief Set the new IPTC IRB, keeps existing IRBs but removes the
                 IPTC block if there is no new IPTC data to write.

          @param pPsData    Existing IRB buffer
          @param sizePsData Size of the IRB buffer, may be 0
          @param iptcData   Iptc data to embed, may be empty
          @return A data buffer containing the new IRB buffer, may have 0 size
        *//*!
          @brief Forwards to locatePreviewIrb() with \em psTag = \em preview_
         *//*!
          @brief Forwards to locateIrb() with \em psTag = \em iptc_
         *//*!
          @brief Locates the data for a %Photoshop tag in a %Photoshop formated memory
              buffer. Operates on raw data to simplify reuse.
          @param pPsData Pointer to buffer containing entire payload of
              %Photoshop formated data, e.g., from APP13 Jpeg segment.
          @param sizePsData Size in bytes of pPsData.
          @param psTag %Tag number of the block to look for.
          @param record Output value that is set to the start of the
              data block within pPsData (may not be null).
          @param sizeHdr Output value that is set to the size of the header
              within the data block pointed to by record (may not be null).
          @param sizeData Output value that is set to the size of the actual
              data within the data block pointed to by record (may not be null).
          @return 0 if successful;<BR>
                  3 if no data for psTag was found in pPsData;<BR>
                 -2 if the pPsData buffer does not contain valid data.
        *//*!
          @brief Validates all IRBs

          @param pPsData        Existing IRB buffer
          @param sizePsData     Size of the IRB buffer, may be 0
          @return true  if all IRBs are valid;<BR>
                  false otherwise
        *//*!
          @brief Checks an IRB

          @param pPsData        Existing IRB buffer
          @param sizePsData     Size of the IRB buffer
          @return true  if the IRB marker is known and the buffer is big enough to check this;<BR>
                  false otherwise
        *///!< %Photoshop preview marker//!< %Photoshop IPTC marker//!< %Photoshop IRB marker (deprecated)//!< %Photoshop IRB markers//!< %Photoshop marker// Todo: Public for now/*!
      @brief Helper class, has methods to deal with %Photoshop "Information
             Resource Blocks" (IRBs).
     *///!< EXV image type (see class ExvImage)//!< JPEG image type (see class JpegImage)// Supported JPEG image formats/*!
  @file    jpgimage.hpp
  @brief   Class JpegImage to access JPEG images
  @author  Andreas Huggel (ahu)
           <a href="mailto:ahuggel@gmx.net">ahuggel@gmx.net</a>
  @author  Brad Schick (brad)
           <a href="mailto:brad@robotbattle.com">brad@robotbattle.com</a>
  @author  Volker Grabsch (vog)
           <a href="mailto:vog@notjusthosting.com">vog@notjusthosting.com</a>
  @author  Michael Ulbrich (mul)
           <a href="mailto:mul@rentapacs.de">mul@rentapacs.de</a>
  @date    15-Jan-05, brad: split out from image.cpp
 */initDatapPsDatasizePsDatapsTagisMrwTypenewMrwInstance~MrwImageMrwImage &const MrwImageconst MrwImage &MrwImagemrwMRWIMAGE_HPP_// #ifndef MRWIMAGE_HPP_//! Check if the file iIo is a MRW image./*!
      @brief Create a new MrwImage instance and return an auto-pointer to it.
             Caller owns the returned object and the auto-pointer ensures that
             it will be deleted.
     */// class MrwImage/*!
          @brief Not supported. MRW format does not contain a comment.
              Calling this function will throw an Error(kerInvalidSettingForImage).
         *//*!
          @brief Todo: Not supported yet, requires writeMetadata(). Calling
              this function will throw an Error(kerInvalidSettingForImage).
         *//*!
          @brief Todo: Write metadata back to the image. This method is not
              yet implemented. Calling it will throw an Error(kerWritingImageFormatUnsupported).
         *//*!
          @brief Constructor that can either open an existing MRW image or create
              a new image from scratch. If a new image is to be created, any
              existing data is overwritten. Since the constructor can not return
              a result, callers should check the good() method after object
              construction to determine success or failure.
          @param io An auto-pointer that owns a BasicIo instance used for
              reading and writing image metadata. \b Important: The constructor
              takes ownership of the passed in BasicIo instance through the
              auto-pointer. Callers should not continue to use the BasicIo
              instance after it is passed to this method.  Use the Image::io()
              method to get a temporary reference.
          @param create Specifies if an existing image should be read (false)
              or if a new file should be created (true).
         *//*!
      @brief Class to access raw Minolta MRW images. Exif metadata is supported
             directly, IPTC is read from the Exif data, if present.
     *///!< MRW image type (see class MrwImage)// Add MRW to the supported image formats/*!
  @file    mrwimage.hpp
  @brief   Minolta RAW image, implemented using the following references:
           <a href="http://www.dalibor.cz/minolta/raw_file_format.htm">Minolta Raw file format</a> by Dalibor Jelinek
  @author  Andreas Huggel (ahu)
           <a href="mailto:ahuggel@gmx.net">ahuggel@gmx.net</a>
  @date    13-May-06, ahu: created
 */isOrfTypenewOrfInstanceOrfParser &const OrfParserconst OrfParser &~OrfImageOrfImage &const OrfImageconst OrfImage &OrfImageOrfParserorfORFIMAGE_HPP_// #ifndef ORFIMAGE_HPP_//! Check if the file iIo is an ORF image./*!
      @brief Create a new OrfImage instance and return an auto-pointer to it.
             Caller owns the returned object and the auto-pointer ensures that
             it will be deleted.
     */// class OrfParser/*!
          @brief Encode metadata from the provided metadata to ORF format.
                 See TiffParser::encode().
        *//*!
          @brief Decode metadata from a buffer \em pData of length \em size
                 with data in ORF format to the provided metadata containers.
                 See TiffParser::decode().
        *//*!
      @brief Stateless parser class for data in ORF format. Images use this
             class to decode and encode ORF data.
             See class TiffParser for details.
     */// class OrfImage/*!
          @brief Not supported. ORF format does not contain a comment.
              Calling this function will throw an Error(kerInvalidSettingForImage).
         *//*!
          @brief Constructor that can either open an existing ORF image or create
              a new image from scratch. If a new image is to be created, any
              existing data is overwritten. Since the constructor can not return
              a result, callers should check the good() method after object
              construction to determine success or failure.
          @param io An auto-pointer that owns a BasicIo instance used for
              reading and writing image metadata. \b Important: The constructor
              takes ownership of the passed in BasicIo instance through the
              auto-pointer. Callers should not continue to use the BasicIo
              instance after it is passed to this method.  Use the Image::io()
              method to get a temporary reference.
          @param create Specifies if an existing image should be read (false)
              or if a new file should be created (true).
         *//*!
      @brief Class to access raw Olympus ORF images. Exif metadata is supported
             directly, IPTC is read from the Exif data, if present.
     *///!< ORF image type (see class OrfImage)// Add ORF to the supported image formats/*!
  @file    orfimage.hpp
  @brief   Olympus RAW image
  @author  Jeff Costlow
           <a href="mailto:costlow@gmail.com">costlow@gmail.com</a>
  @date    31-Jul-07, costlow: created
 */isPgfTypenewPgfInstance~PgfImagereadPgfHeaderStructurereadPgfHeaderSizereadPgfMagicNumberPgfImage &const PgfImageconst PgfImage &PgfImageconst PgfImage *PgfImage *image/pgf"image/pgf"bSwap_pgfPGFIMAGE_HPP_// #ifndef PGFIMAGE_HPP_//! Check if the file iIo is a PGF image./*!
      @brief Create a new PgfImage instance and return an auto-pointer to it.
             Caller owns the returned object and the auto-pointer ensures that
             it will be deleted.
     */// class PgfImage//! Read header structure.//! Read PGF Header size encoded in 32 bits integer.//! Read Magick number. Only version >= 6 is supported.// true for bigEndian hardware, else false/*!
          @brief Constructor that can either open an existing PGF image or create
              a new image from scratch. If a new image is to be created, any
              existing data is overwritten. Since the constructor can not return
              a result, callers should check the good() method after object
              construction to determine success or failure.
          @param io An auto-pointer that owns a BasicIo instance used for
              reading and writing image metadata. \b Important: The constructor
              takes ownership of the passed in BasicIo instance through the
              auto-pointer. Callers should not continue to use the BasicIo
              instance after it is passed to this method.  Use the Image::io()
              method to get a temporary reference.
          @param create Specifies if an existing image should be read (false)
              or if a new file should be created (true).
         *//*!
      @brief Class to access PGF images. Exif and IPTC metadata are supported
          directly.
     *///!< PGF image type (see class PgfImage)// Add PGF to the supported image formats/*!
  @file    pgfimage.hpp
  @brief   PGF image, implemented using the following references:
           <a href="http://www.libpgf.org/uploads/media/PGF_stamm_wscg02.pdf">PGF specification</a> from libpgf web site<br>
  @author  Andreas Huggel (ahu)
           <a href="mailto:ahuggel@gmx.net">ahuggel@gmx.net</a>
  @author  Gilles Caulier (cgilles)
           <a href="mailto:caulier dot gilles at gmail dot com">caulier dot gilles at gmail dot com</a>
  @date    16-Jun-09, gc: submitted
 */isPngTypenewPngInstance~PngImagePngImage &const PngImageconst PngImage &PngImageprofileName_pngPNGIMAGE_HPP_// #ifndef PNGIMAGE_HPP_//! Check if the file iIo is a PNG image./*!
      @brief Create a new PngImage instance and return an auto-pointer to it.
             Caller owns the returned object and the auto-pointer ensures that
             it will be deleted.
     */// class PngImage/*!
          @brief Provides the main implementation of writeMetadata() by
                writing all buffered metadata to the provided BasicIo.
          @throw Error on input-output errors or when the image data is not valid.
          @param oIo BasicIo instance to write to (a temporary location).

         *//*!
          @brief Constructor that can either open an existing PNG image or create
              a new image from scratch. If a new image is to be created, any
              existing data is overwritten. Since the constructor can not return
              a result, callers should check the good() method after object
              construction to determine success or failure.
          @param io An auto-pointer that owns a BasicIo instance used for
              reading and writing image metadata. \b Important: The constructor
              takes ownership of the passed in BasicIo instance through the
              auto-pointer. Callers should not continue to use the BasicIo
              instance after it is passed to this method.  Use the Image::io()
              method to get a temporary reference.
          @param create Specifies if an existing image should be read (false)
              or if a new file should be created (true).
         *//*!
      @brief Class to access PNG images. Exif and IPTC metadata are supported
          directly.
     *///!< PNG image type (see class PngImage)// Add PNG to the supported image formats/*!
  @file    pngimage.hpp
  @brief   PNG image, implemented using the following references:
           <a href="http://www.w3.org/TR/PNG/">PNG specification</a> by W3C<br>
           <a href="http://www.sno.phy.queensu.ca/~phil/exiftool/TagNames/PNG.html">PNG tags list</a> by Phil Harvey<br>
  @author  Andreas Huggel (ahu)
           <a href="mailto:ahuggel@gmx.net">ahuggel@gmx.net</a>
  @author  Gilles Caulier (cgilles)
           <a href="mailto:caulier dot gilles at gmail dot com">caulier dot gilles at gmail dot com</a>
  @date    12-Jun-06, gc: submitted
 */isPsdTypenewPsdInstance~PsdImagewriteXmpDatawriteIptcDatawriteExifDatareadResourceBlockPsdImagePsdImage &const PsdImageconst PsdImage &psdPSDIMAGE_HPP_// #ifndef PSDIMAGE_HPP_//! Check if the file iIo is a Photoshop image./*!
      @brief Create a new PsdImage instance and return an auto-pointer to it.
             Caller owns the returned object and the auto-pointer ensures that
             it will be deleted.
     */// class PsdImage/*!
          @brief Return the MIME type of the image.

          The MIME type returned for Photoshop images is "image/x-photoshop".

          @note This should really be "image/vnd.adobe.photoshop"
              (officially registered with IANA in December 2005 -- see
              http://www.iana.org/assignments/media-types/image/vnd.adobe.photoshop)
              but Apple, as of Tiger (10.4.8), maps this official MIME type to a
              dynamic UTI, rather than "com.adobe.photoshop-image" as it should.
         *//*!
          @brief Not supported. Calling this function will throw an Error(kerInvalidSettingForImage).
         *//*!
          @brief Constructor to open a Photoshop image. Since the
              constructor can not return a result, callers should check the
              good() method after object construction to determine success
              or failure.
          @param io An auto-pointer that owns a BasicIo instance used for
              reading and writing image metadata. \b Important: The constructor
              takes ownership of the passed in BasicIo instance through the
              auto-pointer. Callers should not continue to use the BasicIo
              instance after it is passed to this method.  Use the Image::io()
              method to get a temporary reference.
         *//*!
      @brief Class to access raw Photoshop images.
     *///!< Photoshop (PSD) image type (see class PsdImage)// Add PSD to the supported image formats/*!
  @file    psdimage.hpp
  @brief   Photoshop image, implemented using the following references:
           <a href="http://www.fine-view.com/jp/lab/doc/ps6ffspecsv2.pdf">Adobe Photoshop 6.0 File Format Specification</a> by Adobe<br>
  @author  Marco Piovanelli, Ovolab (marco)
           <a href="mailto:marco.piovanelli@pobox.com">marco.piovanelli@pobox.com</a>
  @author  Michael Ulbrich
           <a href="mailto:mul@rentapacs.de">mul@rentapacs.de</a>
  @date    05-Mar-2007, marco: created
 */resourceIdresourceSizeisRafTypenewRafInstance~RafImageRafImage &const RafImageconst RafImage &RafImagerafRAFIMAGE_HPP_// #ifndef RAFIMAGE_HPP_//! Check if the file iIo is a RAF image./*!
      @brief Create a new RafImage instance and return an auto-pointer to it.
             Caller owns the returned object and the auto-pointer ensures that
             it will be deleted.
     */// class RafImage/*!
          @brief Not supported. RAF format does not contain a comment.
              Calling this function will throw an Error(kerInvalidSettingForImage).
         *//*!
          @brief Constructor that can either open an existing RAF image or create
              a new image from scratch. If a new image is to be created, any
              existing data is overwritten. Since the constructor can not return
              a result, callers should check the good() method after object
              construction to determine success or failure.
          @param io An auto-pointer that owns a BasicIo instance used for
              reading and writing image metadata. \b Important: The constructor
              takes ownership of the passed in BasicIo instance through the
              auto-pointer. Callers should not continue to use the BasicIo
              instance after it is passed to this method.  Use the Image::io()
              method to get a temporary reference.
          @param create Specifies if an existing image should be read (false)
              or if a new file should be created (true).
         *//*!
      @brief Class to access raw Fujifilm RAF images. Exif metadata is
          supported directly, IPTC is read from the Exif data, if present.
     *///!< RAF image type (see class RafImage)// Add RAF to the supported image formats/*!
  @file    rafimage.hpp
  @brief   Fujifilm RAW image
  @author  Andreas Huggel (ahu)
           <a href="mailto:ahuggel@gmx.net">ahuggel@gmx.net</a>
  @date    05-Feb-07, ahu: created
 */isRw2TypenewRw2InstanceRw2Parser &const Rw2Parserconst Rw2Parser &~Rw2ImageRw2Image &const Rw2Imageconst Rw2Image &Rw2ImageRw2Parserrw2RW2IMAGE_HPP_// #ifndef RW2IMAGE_HPP_//! Check if the file iIo is a RW2 image./*!
      @brief Create a new Rw2Image instance and return an auto-pointer to it.
             Caller owns the returned object and the auto-pointer ensures that
             it will be deleted.
     */// class Rw2Parser/*!
          @brief Decode metadata from a buffer \em pData of length \em size
                 with data in RW2 format to the provided metadata containers.
                 See TiffParser::decode().
        *//*!
      @brief Stateless parser class for data in RW2 format. Images use this
             class to decode and encode RW2 data. Only decoding is currently
             implemented. See class TiffParser for details.
     */// class Rw2Image/*!
          @brief Not supported. RW2 format does not contain a comment.
              Calling this function will throw an Error(kerInvalidSettingForImage).
         *//*!
          @brief Constructor to open an existing RW2 image. Since the
              constructor can not return a result, callers should check the
              good() method after object construction to determine success or
              failure.
          @param io An auto-pointer that owns a BasicIo instance used for
              reading and writing image metadata. \b Important: The constructor
              takes ownership of the passed in BasicIo instance through the
              auto-pointer. Callers should not continue to use the BasicIo
              instance after it is passed to this method.  Use the Image::io()
              method to get a temporary reference.
         *//*!
      @brief Class to access raw Panasonic RW2 images.  Exif metadata is
          supported directly, IPTC and XMP are read from the Exif data, if
          present.
     *///!< RW2 image type (see class Rw2Image)// Add RW2 to the supported image formats/*!
  @file    rw2image.hpp
  @brief   Class Rw2Image
  @author  Andreas Huggel (ahu)
           <a href="mailto:ahuggel@gmx.net">ahuggel@gmx.net</a>
  @date    06-Jan-09, ahu: created
 */isTgaTypenewTgaInstance~TgaImageTgaImageTgaImage &const TgaImageconst TgaImage &tgaTGAIMAGE_HPP_// #ifndef TGAIMAGE_HPP_//! Check if the file iIo is a Targa v2 image./*!
      @brief Create a new TgaImage instance and return an auto-pointer to it.
             Caller owns the returned object and the auto-pointer ensures that
             it will be deleted.
     */// class TgaImage/*!
          @brief Constructor to open a Targa image. Since the
              constructor can not return a result, callers should check the
              good() method after object construction to determine success
              or failure.
          @param io An auto-pointer that owns a BasicIo instance used for
              reading and writing image metadata. \b Important: The constructor
              takes ownership of the passed in BasicIo instance through the
              auto-pointer. Callers should not continue to use the BasicIo
              instance after it is passed to this method.  Use the Image::io()
              method to get a temporary reference.
         *//*!
      @brief Class to access raw TARGA images. This is just a stub - we only
          read width and height.
     *///!< Truevision TARGA (tga) image type (see class TgaImage)// Add TARGA to the supported image formats/*!
  @file    tgaimage.hpp
  @brief   Truevision TARGA v2 image, implemented using the following references:
           <a href="http://en.wikipedia.org/wiki/Truevision_TGA">Truevision TGA page on Wikipedia</a><br>
           <a href="http://www.gamers.org/dEngine/quake3/TGA.ps.gz">TGA(tm) File Format Specification</a>
  @author  Marco Piovanelli, Ovolab (marco)
           <a href="mailto:marco.piovanelli@pobox.com">marco.piovanelli@pobox.com</a>
  @date    05-Mar-2007, marco: created
 */isXmpTypenewXmpInstance~XmpSidecarXmpSidecar &const XmpSidecarconst XmpSidecar &XmpSidecardates_XMPSIDECAR_HPP_// #ifndef XMPSIDECAR_HPP_//! Check if the file iIo is an XMP sidecar file./*!
      @brief Create a new XmpSidecar instance and return an auto-pointer to it.
             Caller owns the returned object and the auto-pointer ensures that
             it will be deleted.
     */// class XmpSidecar/*!
          @brief Not supported. XMP sidecar files do not contain a comment.
              Calling this function will throw an instance of Error(kerInvalidSettingForImage).
         *//*!
          @brief Constructor for an XMP sidecar file. Since the constructor
              can not return a result, callers should check the good() method
              after object construction to determine success or failure.
          @param io An auto-pointer that owns a BasicIo instance used for
              reading and writing image metadata. \b Important: The constructor
              takes ownership of the passed in BasicIo instance through the
              auto-pointer. Callers should not continue to use the BasicIo
              instance after it is passed to this method. Use the Image::io()
              method to get a temporary reference.
          @param create Specifies if an existing image should be read (false)
              or if a new image should be created (true).
         *//*!
      @brief Class to access XMP sidecar files. They contain only XMP metadata.
     *///!< XMP sidecar files (see class XmpSidecar)// Add XMP to the supported image formats/*!
  @file    xmpsidecar.hpp
  @brief   An Image subclass to support XMP sidecar files
  @author  Andreas Huggel
           <a href="mailto:ahuggel@gmx.net">ahuggel@gmx.net</a>
  @date    07-Mar-08, ahu: created
 */"exiv2/xmpsidecar.hpp""exiv2/xmp_exiv2.hpp""exiv2/version.hpp""exiv2/value.hpp""exiv2/types.hpp""exiv2/tiffimage.hpp""exiv2/tgaimage.hpp""exiv2/tags.hpp""exiv2/rw2image.hpp""exiv2/rafimage.hpp""exiv2/psdimage.hpp""exiv2/properties.hpp""exiv2/preview.hpp""exiv2/pngimage.hpp""exiv2/pgfimage.hpp""exiv2/orfimage.hpp""exiv2/mrwimage.hpp""exiv2/metadatum.hpp""exiv2/jpgimage.hpp""exiv2/jp2image.hpp""exiv2/iptc.hpp""exiv2/ini.hpp""exiv2/image.hpp""exiv2/http.hpp""exiv2/gifimage.hpp""exiv2/futils.hpp""exiv2/exif.hpp""exiv2/error.hpp""exiv2/epsimage.hpp""exiv2/easyaccess.hpp""exiv2/crwimage.hpp""exiv2/cr2image.hpp""exiv2/convert.hpp""exiv2/bmpimage.hpp""exiv2/basicio.hpp""exiv2/datasets.hpp""exiv2/config.h"EXIV2_HPP_// #ifndef EXIV2_HPP_/*!
  @file    exiv2.hpp
  @brief   Include all Exiv2 header files.
  @author  Andreas Huggel (ahu)
           <a href="mailto:ahuggel@gmx.net">ahuggel@gmx.net</a>
  @date    21-Jun-10, ahu: created
 */strtoldirnameUTILS_HPP_// #ifndef UTILS_HPP_/*!
      @brief Replaces all occurrences of \em searchText in the \em text string
             by \em replaceText.
     *//*!
      @brief Convert a C string to a long value, which is returned in n.
             Returns true if the conversion is successful, else false.
             n is not modified if the conversion is unsuccessful. See strtol(2).
     *//*!
      @brief Get the suffix from the path string. Normally, the suffix
             is the substring of the basename of path from the last '.'
             to the end of the string.
     *//*!
      @brief Get the filename component from the \em path string.
             See %basename(3). If the \em delsuffix parameter is true,
             the suffix will be removed.

      This function can handle Windows paths to some extent: c:\\bar should
      be fine, \\\\bigsrv\\foo also, but \\\\bigsrv alone doesn't work.
     *//*!
      @brief Get the directory component from the \em path string.
             See %dirname(3).

      This function can handle Windows paths to some extent: c:\\bar should
      be fine, \\\\bigsrv\\foo also, but \\\\bigsrv alone doesn't work.
     *//*!
  @brief Contains utility classes and functions. Most of these are
         wrappers for common C functions that do not require pointers
         and memory considerations.
*//*!
  @file    utils.hpp
  @brief   A collection of utility functions
  @author  Andreas Huggel (ahu)
           <a href="mailto:ahuggel@gmx.net">ahuggel@gmx.net</a>
  @date    12-Dec-03, ahu: created
 */searchTextreplaceTextnptrdelsuffixyodYearconst YodAdjustconst YodAdjust[]YodAdjust[]const YodAdjust *yodMonthyodDayversion_(false)verbose_(false)force_(false)binary_(true)unknown_(true)timestamp_(false)timestampOnly_(false)askPolicyadjust_(false)pmSummaryaction_(0)ctExifctIptcctExif|ctIptcctCommentctExif|ctIptc|ctCommentctXmpctExif|ctIptc|ctComment|ctXmp%Y%m%d_%H%M%S"%Y%m%d_%H%M%S"formatSet_(false)YodAdjust &const YodAdjust &CmdIdAndString &const CmdIdAndStringconst CmdIdAndString &~CmdIdAndStringCmdIdAndString *CmdIdAndString~ModifyCmdModifyCmdinvalidMetadataIdExiv2::invalidTypeIdexplicitType_(false)FileExistsPolicyoverwritePolicyrenamePolicyYodAdjustYodCommonTargetctThumbctXmpSidecarctPreviewctIccProfilectXmpRawctStdInOutctIptcRawPrintItemprTagprGroupprKeyprNameprLabelprTypeprCountprSizeprValueprTransprHexprSetPrintModepmListpmCommentpmPreviewpmStructurepmXMPpmIccProfilepmRecursiveKeysGrepsPreviewNumbersFilesCmdLinesCmdFilesModifyCmdsCmdIdfileExistsPolicy_printMode_printItems_printTags_action_yodAdjust_format_formatSet_cmdFiles_cmdLines_modifyCmds_jpegComment_directory_suffix_files_previewNumbers_greps_keys_charset_stdinBufoption_flag_timestampOnly_timestamp_unknown_binary_force_verbose_cmdString_explicitType_cmdId_EXIV2APP_HPP_defined(__CYGWIN__) || defined(__MINGW__)defined(_WIN32) || defined(__CYGWIN__) || defined(__MINGW__) || defined(_MSC_VER)getStdinprintTargetevalModifyevalInsertevalExtractevalDeleteevalPrintFlagsevalPrintevalYodAdjustconst Yodconst Yod &Yod &evalAdjustevalRenameevalKeyevalGrepsetLogLevelemptyYodAdjust_// #ifndef EXIV2APP_HPP_/*
        stdin can be used by multiple images in the exiv2 command line:
        For example: $ cat foo.icc | exiv2 -iC- a.jpg b.jpg c.jpg will modify the ICC profile in several images.
    *///! getStdin binary data read from stdin to DataBuf//! Print target_//! Print version information to an output stream.//! @name Helpers//! Destructor, frees any allocated regexes in greps_/*!
      @brief Default constructor. Note that optstring_ is initialized here.
             The c'tor is private to force instantiation through instance().
     *///! Initializer for year, month and day adjustment info.//! Pointer to the global Params object.//!< DataBuf with the binary bytes from stdin//!< Charset to use for UNICODE Exif user comment//!< List of keys to match from the metadata//!< List of keys to 'grep' from the metadata//!< List of preview numbers//!< List of non-option arguments.//!< File extension of the file to insert//!< Location for files to extract/insert//!< Jpeg comment to set in the image//!< Parsed modification commands//!< Commands from the command line//!< Names of the modification command files//!< Whether the format is set with -r//!< Filename format (-r option arg).//!< Year, month and day adjustment info.//!< Adjustment in seconds.//!< What common target to process.//! %Action (integer rather than TaskType to avoid dependency).//!< Print tags (bitmap of MetadataId flags).//!< Print items.//!< Print mode.//!< Adjustment flag.//!< What to do if file to rename exists.//!< Rename only sets the file timestamp.//!< Rename also sets the file timestamp.//!< Preserve timestamps flag.//!< Suppress unknown tags.//!< Suppress long binary values.//!< Force overwrites flag.//!< Verbose (talkative) option flag.//!< Version option flag.//!< Adjustment value.//!< Adjustment option string.//! Structure for year, month and day adjustment command line arguments.//! Enumerates year, month and day adjustments.//! Enumerates the policies to handle existing files in rename action//! Enumerates common targets, bitmap//! Individual items to print, bitmap//! Enumerates print modes/*!
      @brief Controls all access to the global Params instance.
      @return Reference to the global Params instance.
    *///! Container for keys//! Container for greps//! Container for preview image numbers//! Container to store filenames.//! Container for commands from the command line//! Container for command files/*!
  @brief Implements the command line handling for the program.

  Derives from Util::Getopt to use the command line argument parsing
  functionality provided there. This class is implemented as a singleton,
  i.e., there is only one global instance of it, which can be accessed
  from everywhere.

  <b>Usage example:</b> <br>
  @code
  #include "params.h"

  int main(int argc, char* const argv[])
  {
      Params& params = Params::instance();
      if (params.getopt(argc, argv)) {
          params.usage();
          return 1;
      }
      if (params.help_) {
          params.help();
          return 0;
      }
      if (params.version_) {
          params.version();
          return 0;
      }

      // do something useful here...

      return 0;
  }
  @endcode
 *///!< Command string//!< Commands identifier//! Structure to link command identifiers to strings//! Container for modification commands//!< Data//! Flag to indicate if the type was explicitly specified (true)//!< Exiv2 type identifier//!< Metadata identifier//!< Exiv2 key string//!< Command identifier//! Structure for one parsed modification command// mdNone=0, mdExif=1, mdIptc=2, mdComment=4, mdXmp=8//! Metadata identifiers// enum MetadataId { invalidMetadataId, iptc, exif, xmp };//! Command identifiers// stdin handler includes/*!
  @file    exiv2app.hpp
  @brief   Defines class Params, used for the command line handling of exiv2
  @author  Andreas Huggel (ahu)
           <a href="mailto:ahuggel@gmx.net">ahuggel@gmx.net</a>
  @date    08-Dec-03, ahu: created
 */yodbasic_ifstream<_CharT, _Traits> */Users/owura/Repos/codeql_eval/proj_repos/Exiv2-exiv2-pull-962-commits-e925bc5addd881543fa503470c8a859e112cca62/exiv2/src/exiv2.cppparseEscapeschescapeStart't''u'accucs2toUtf8652800xff000x00ffUCS-2BE"UCS-2BE"commandIdconst CmdIdAndString[5]CmdIdAndString[5]const CmdIdAndString *parseLinedelimcmdStart'#'cmdEnd"Invalid command line:"cmdLineInvalid command line:cmdcmdId"Invalid command"Invalid commanddefaultType"Invalid key"Invalid keyexplicitType"Invalid command line"typeStarttypeEndvalStartvalEndInvalid command linetypeStrtmpTypecmdStringlast'\''parseCmdLinesconst CmdLinesconst CmdLines &vector<basic_string<char, char_traits<char>, allocator<char>>, allocator<basic_string<char, char_traits<char>, allocator<char>>>> &"-M option"-M optionparseCmdFilesconst CmdFilesconst CmdFiles &"Failed to open command file for reading\n""line"Failed to open command file for reading
parsePreviewNumbersPreviewNumbers &"Invalid preview number"Invalid preview numberparseCommonTargetsParams::ctExif | Params::ctIptcParams::ctExif | Params::ctIptc | Params::ctCommentParams::ctExif | Params::ctIptc | Params::ctComment | Params::ctXmpextraParams::ctXmpSidecar | Params::ctExifParams::ctXmpSidecar | Params::ctExif | Params::ctIptcParams::ctXmpSidecar | Params::ctExif | Params::ctIptc | Params::ctXmp'C''X'"extract"printUnrecognizedArgument"Unrecognized ""target"Unrecognized hstrmstrctscmdLinescmdFilespreviewNumbersactionhhreadFileToBufbuff_size102841124*1028nBytesmorechar[4112]ends_withLC_ALLlocaleDir/../share/localeexiv2task.get()taskFactorywconst auto_ptr<Task>excUncaught exception: "Uncaught exception: "&readfdsreadfds__builtin_bzero :" :"exiv2 0.27.2.2"This program is free software; you can redistribute it and/or\n" "modify it under the terms of the GNU General Public License\n" "as published by the Free Software Foundation; either version 2\n" "of the License, or (at your option) any later version.\n""This program is distributed in the hope that it will be useful,\n" "but WITHOUT ANY WARRANTY; without even the implied warranty of\n" "MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n" "GNU General Public License for more details.\n""You should have received a copy of the GNU General Public\n" "License along with this program; if not, write to the Free\n" "Software Foundation, Inc., 51 Franklin Street, Fifth Floor,\n" "Boston, MA 02110-1301 USA\n"This program is free software; you can redistribute it and/or
modify it under the terms of the GNU General Public License
as published by the Free Software Foundation; either version 2
of the License, or (at your option) any later version.
const char[241]char[241]This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.
const char[235]char[235]You should have received a copy of the GNU General Public
License along with this program; if not, write to the Free
Software Foundation, Inc., 51 Franklin Street, Fifth Floor,
Boston, MA 02110-1301 USA
const char[204]char[204]"\nActions:\n""  ad | adjust   Adjust Exif timestamps by the given time. This action\n" "                requires at least one of the -a, -Y, -O or -D options.\n""  pr | print    Print image metadata.\n""  rm | delete   Delete image metadata from the files.\n""  in | insert   Insert metadata from corresponding *.exv files.\n" "                Use option -S to change the suffix of the input files.\n""  ex | extract  Extract metadata to *.exv, *.xmp and thumbnail image files.\n""  mv | rename   Rename files and/or set file timestamps according to the\n" "                Exif create timestamp. The filename format can be set with\n" "                -r format, timestamp options are controlled with -t and -T.\n""  mo | modify   Apply commands to modify (add, set, delete) the Exif and\n" "                IPTC metadata of image files or set the JPEG comment.\n" "                Requires option -c, -m or -M.\n""  fi | fixiso   Copy ISO setting from the Nikon Makernote to the regular\n" "                Exif tag.\n""  fc | fixcom   Convert the UNICODE Exif user comment to UCS-2. Its current\n" "                character encoding can be specified with the -n option.\n""   -h      Display this help and exit.\n""   -V      Show the program version and exit.\n""   -v      Be verbose during the program run.\n""   -q      Silence warnings and error messages during the program run (quiet).\n""   -Q lvl  Set log-level to d(ebug), i(nfo), w(arning), e(rror) or m(ute).\n""   -b      Show large binary values.\n""   -u      Show unknown tags.\n""   -g key  Only output info for this key (grep).\n""   -K key  Only output info for this key (exact match).\n""   -n enc  Charset to use to decode UNICODE Exif user comments.\n""   -k      Preserve file timestamps (keep).\n""   -t      Also set the file timestamp in 'rename' action (overrides -k).\n""   -T      Only set the file timestamp in 'rename' action, do not rename\n" "           the file (overrides -k).\n""   -f      Do not prompt before overwriting existing files (force).\n""   -F      Do not prompt before renaming files (Force).\n""   -a time Time adjustment in the format [-]HH[:MM[:SS]]. This option\n" "           is only used with the 'adjust' action.\n""   -Y yrs  Year adjustment with the 'adjust' action.\n""   -O mon  Month adjustment with the 'adjust' action.\n""   -D day  Day adjustment with the 'adjust' action.\n""   -p mode Print mode for the 'print' action. Possible modes are:\n""             s : print a summary of the Exif metadata (the default)\n""             a : print Exif, IPTC and XMP metadata (shortcut for -Pkyct)\n""             e : print Exif metadata (shortcut for -PEkycv)\n""             t : interpreted (translated) Exif data (-PEkyct)\n""             v : plain Exif data values (-PExgnycv)\n""             h : hexdump of the Exif data (-PExgnycsh)\n""             i : IPTC data values (-PIkyct)\n""             x : XMP properties (-PXkyct)\n""             c : JPEG comment\n""             p : list available previews\n""             C : print ICC profile embedded in image\n""             R : recursive print structure of image\n""             S : print structure of image\n""             X : extract XMP from image\n""   -P flgs Print flags for fine control of tag lists ('print' action):\n""             E : include Exif tags in the list\n""             I : IPTC datasets\n""             X : XMP properties\n""             x : print a column with the tag number\n""             g : group name\n""             k : key\n""             l : tag label\n""             n : tag name\n""             y : type\n""             c : number of components (count)\n""             s : size in bytes\n""             v : plain data value\n""             t : interpreted (translated) data\n""             h : hexdump of the data\n""   -d tgt  Delete target(s) for the 'delete' action. Possible targets are:\n""             a : all supported metadata (the default)\n""             e : Exif section\n""             t : Exif thumbnail only\n""             i : IPTC data\n""             x : XMP packet\n""   -i tgt  Insert target(s) for the 'insert' action. Possible targets are\n" "           the same as those for the -d option, plus a modifier:\n" "             X : Insert metadata from an XMP sidecar file <file>.xmp\n" "           Only JPEG thumbnails can be inserted, they need to be named\n" "           <file>-thumb.jpg\n""   -e tgt  Extract target(s) for the 'extract' action. Possible targets\n" "           are the same as those for the -d option, plus a target to extract\n" "           preview images and a modifier to generate an XMP sidecar file:\n" "             p[<n>[,<m> ...]] : Extract preview images.\n" "             X : Extract metadata to an XMP sidecar file <file>.xmp\n""   -r fmt  Filename format for the 'rename' action. The format string\n" "           follows strftime(3). The following keywords are supported:\n""             :basename:   - original filename without extension\n""             :dirname:    - name of the directory holding the original file\n""             :parentname: - name of parent directory\n""           Default filename format is ""   -c txt  JPEG comment string to set in the image.\n""   -m file Command file for the modify action. The format for commands is\n" "           set|add|del <key> [[<type>] <value>].\n""   -M cmd  Command line for the modify action. The format for the\n" "           commands is the same as that of the lines of a command file.\n""   -l dir  Location (directory) for files to be inserted from or extracted to.\n""   -S .suf Use suffix .suf for source files for insert command.\n\n"endingstub
Actions:
  ad | adjust   Adjust Exif timestamps by the given time. This action
                requires at least one of the -a, -Y, -O or -D options.
  pr | print    Print image metadata.
  rm | delete   Delete image metadata from the files.
  in | insert   Insert metadata from corresponding *.exv files.
                Use option -S to change the suffix of the input files.
  ex | extract  Extract metadata to *.exv, *.xmp and thumbnail image files.
  mv | rename   Rename files and/or set file timestamps according to the
                Exif create timestamp. The filename format can be set with
                -r format, timestamp options are controlled with -t and -T.
const char[225]char[225]  mo | modify   Apply commands to modify (add, set, delete) the Exif and
                IPTC metadata of image files or set the JPEG comment.
                Requires option -c, -m or -M.
const char[190]char[190]  fi | fixiso   Copy ISO setting from the Nikon Makernote to the regular
                Exif tag.
  fc | fixcom   Convert the UNICODE Exif user comment to UCS-2. Its current
                character encoding can be specified with the -n option.
const char[149]char[149]   -h      Display this help and exit.
   -V      Show the program version and exit.
   -v      Be verbose during the program run.
   -q      Silence warnings and error messages during the program run (quiet).
const char[80]char[80]   -Q lvl  Set log-level to d(ebug), i(nfo), w(arning), e(rror) or m(ute).
   -b      Show large binary values.
   -u      Show unknown tags.
   -g key  Only output info for this key (grep).
   -K key  Only output info for this key (exact match).
   -n enc  Charset to use to decode UNICODE Exif user comments.
   -k      Preserve file timestamps (keep).
   -t      Also set the file timestamp in 'rename' action (overrides -k).
   -T      Only set the file timestamp in 'rename' action, do not rename
           the file (overrides -k).
const char[110]char[110]   -f      Do not prompt before overwriting existing files (force).
   -F      Do not prompt before renaming files (Force).
   -a time Time adjustment in the format [-]HH[:MM[:SS]]. This option
           is only used with the 'adjust' action.
   -Y yrs  Year adjustment with the 'adjust' action.
   -O mon  Month adjustment with the 'adjust' action.
   -D day  Day adjustment with the 'adjust' action.
   -p mode Print mode for the 'print' action. Possible modes are:
             s : print a summary of the Exif metadata (the default)
             a : print Exif, IPTC and XMP metadata (shortcut for -Pkyct)
const char[74]char[74]             e : print Exif metadata (shortcut for -PEkycv)
             t : interpreted (translated) Exif data (-PEkyct)
             v : plain Exif data values (-PExgnycv)
             h : hexdump of the Exif data (-PExgnycsh)
             i : IPTC data values (-PIkyct)
             x : XMP properties (-PXkyct)
             c : JPEG comment
             p : list available previews
             C : print ICC profile embedded in image
             R : recursive print structure of image
             S : print structure of image
             X : extract XMP from image
   -P flgs Print flags for fine control of tag lists ('print' action):
             E : include Exif tags in the list
             I : IPTC datasets
             X : XMP properties
             x : print a column with the tag number
             g : group name
             k : key
             l : tag label
             n : tag name
             y : type
             c : number of components (count)
             s : size in bytes
             v : plain data value
             t : interpreted (translated) data
             h : hexdump of the data
   -d tgt  Delete target(s) for the 'delete' action. Possible targets are:
             a : all supported metadata (the default)
             e : Exif section
             t : Exif thumbnail only
             i : IPTC data
             x : XMP packet
   -i tgt  Insert target(s) for the 'insert' action. Possible targets are
           the same as those for the -d option, plus a modifier:
             X : Insert metadata from an XMP sidecar file <file>.xmp
           Only JPEG thumbnails can be inserted, they need to be named
           <file>-thumb.jpg
const char[308]char[308]   -e tgt  Extract target(s) for the 'extract' action. Possible targets
           are the same as those for the -d option, plus a target to extract
           preview images and a modifier to generate an XMP sidecar file:
             p[<n>[,<m> ...]] : Extract preview images.
             X : Extract metadata to an XMP sidecar file <file>.xmp
const char[348]char[348]   -r fmt  Filename format for the 'rename' action. The format string
           follows strftime(3). The following keywords are supported:
             :basename:   - original filename without extension
             :dirname:    - name of the directory holding the original file
             :parentname: - name of parent directory
           Default filename format is .
".\n"   -c txt  JPEG comment string to set in the image.
   -m file Command file for the modify action. The format for commands is
           set|add|del <key> [[<type>] <value>].
   -M cmd  Command line for the modify action. The format for the
           commands is the same as that of the lines of a command file.
const char[139]char[139]   -l dir  Location (directory) for files to be inserted from or extracted to.
   -S .suf Use suffix .suf for source files for insert command.

"Usage:""[ options ] [ action ] file ...\n\n""Manipulate the Exif metadata of images.\n"Usage:[ options ] [ action ] file ...

Manipulate the Exif metadata of images.
"Action adjust is not compatible with the given options\n""Action print is not compatible with the given options\n""Action delete is not compatible with the given options\n""Action extract is not compatible with the given options\n""Action insert is not compatible with the given options\n""Action rename is not compatible with the given options\n""Action modify is not compatible with the given options\n""Action fixiso is not compatible with the given options\n""Action fixcom is not compatible with the given options\n"ad"ad"Action::noneAction::adjustAction adjust is not compatible with the given options
pr"pr""print"Action::printAction print is not compatible with the given options
rm"rm"delete"delete"Action::eraseAction delete is not compatible with the given options
ex"ex"Action::extractAction::modifyAction extract is not compatible with the given options
"in""insert"Action::insertAction insert is not compatible with the given options
mv"mv""rename"Action::renameAction rename is not compatible with the given options
mo"mo""modify"Action modify is not compatible with the given options
"fi""fixiso"Action::fixisoAction fixiso is not compatible with the given options
fc"fc""fixcom"fixcomment"fixcomment"Action::fixcomAction fixcom is not compatible with the given options
"Option""requires an argument\n""Unrecognized option""getopt returned unexpected character code"'V'Exiv2::LogMsg::mute'k''b''g''K''T''D''P''d'Option -" -"requires an argument
Unrecognized optiongetopt returned unexpected character codelongs--adjust"--adjust"--binary"--binary"-b"-b"--comment"--comment"-c"-c"--delete"--delete"--days"--days"--force"--force"-f"-f"--Force"--Force"-F"-F"--grep"--grep"-g"-g"--help"--help"--insert"--insert"-i"-i"--keep"--keep"-k"-k"--key"--key"-K"-K"--location"--location"-l"-l"--modify"--modify"-m"-m"--Modify"--Modify"-M"-M"--encode"--encode"-n"-n"--months"--months"-O"-O"--print"--print"-p"-p"--Print"--Print"-P"-P"--quiet"--quiet"-q"-q"--log"--log"-Q"-Q"--rename"--rename"-r"-r"--suffix"--suffix"-S"-S"--timestamp"--timestamp"--Timestamp"--Timestamp"-T"-T"--unknown"--unknown"-u"-u"--verbose"--verbose"--Version"--Version"--years"--years"-Y"-Y""An action must be specified\n"An action must be specified
"Adjust action requires at least one -a, -Y, -O or -D option\n"Adjust action requires at least one -a, -Y, -O or -D option
"Modify action requires at least one -c, -m or -M option\n"Modify action requires at least one -c, -m or -M option
"At least one file is required\n"At least one file is required
"Error parsing -m option arguments\n"Error parsing -m option arguments
"Error parsing -M option arguments\n"Error parsing -M option arguments
"-l option can only be used with extract or insert actions\n"-l option can only be used with extract or insert actions
"-S option can only be used with insert action\n"-S option can only be used with insert action
"-t option can only be used with rename action\n"-t option can only be used with rename action
"-T option can only be used with rename action\n"-T option can only be used with rename action
"is not compatible with a previous option\n"is not compatible with a previous option
"Option -i is not compatible with a previous option\n"Option -i is not compatible with a previous option
"Option -e is not compatible with a previous option\n"ArgvOption -e is not compatible with a previous option
"Option -d is not compatible with a previous option\n""erase"Option -d is not compatible with a previous option
"Unrecognized print item""Ignoring surplus option -P""Option -P is not compatible with a previous option\n"2304prSet|prValueUnrecognized print itemIgnoring surplus option -POption -P is not compatible with a previous option
"Action not available in Release mode""Unrecognized print mode""Ignoring surplus option -p""Option -p is not compatible with a previous option\n"kyct"kyct"Ekycv"Ekycv"Ekyct"Ekyct"Exgnycv"Exgnycv"Exgnycsh"Exgnycsh"Ikyct"Ikyct"Xkyct"Xkyct"Action not available in Release mode: '": '"Unrecognized print modeIgnoring surplus option -pOption -p is not compatible with a previous option
"Ignoring surplus option""Error parsing""option argument"Ignoring surplus optionError parsingoption argument"Ignoring surplus option -a""Error parsing -a option argument""Option -a is not compatible with a previous option\n"Ignoring surplus option -aError parsing -a option argumentOption -a is not compatible with a previous option
 -r "" -r \""ignoreCase/i"/i"bIgnoreCasepRegexerrcode"Invalid regexp" -g: " -g: "Invalid regexp": "\": "logLevel"Invalid argument"Exiv2::LogMsg::debugExiv2::LogMsg::info'w'Exiv2::LogMsg::warnExiv2::LogMsg::error -Q: " -Q: "Invalid argumentlong_tconst CmdIdAndString[]CmdIdAndString[]"add""del""reg"invalidCmd"invalidCmd"cmdIdAndStringconst YodAdjust[3]NDEBUGEXV_LOCALEDIR"/../share/locale"// Escaping of unicode// Escaping of tab// Escaping of newline// Escaping of carriage return// Escaping of backslash// parseLine// looked up during parsing of subsequent lines (to validate XMP keys).// Registration needs to be done immediately as the new namespaces are// Get type and value// Get command and key// Skip empty lines and comments// parseCmdLines// parseCmdFile// parsePreviewNumbers// turn off those bits// -eXX or -iXX// -eX// parseTime// SS part, if there is one// MM part, if there is one// check for the -0 special case// [-]HH part// local implementations// cleanup the argument vector// We'll set them again, after reading the file// Parse command lines// Parse command files// This shouldn't happen since print is taken as default action// Params::getStdin()// copy stdinBuf to buf//             exiv2 -pX foo.jpg > ~/temp/stdin ; exiv2 -iXX- bar.jpg// to simulate exiv2 -pX foo.jpg                | exiv2 -iXX- bar.jpg// this is only used to simulate reading from stdin when debugging// if we have something in the pipe, read it// yes: set timeout seconds,microseconds// http://stackoverflow.com/questions/34479795/make-c-not-wait-for-user-input/34479916#34479916// failed: stdin has bytes!// copy stdin to stdinBuf//#define DEBUG// Params::nonoption// if everything else fails, assume print as the default action// The first non-option argument must be the action// Params::evalModify// parse the commands later// parse the files later// Params::evalInsert// Params::evalExtract// Params::evalDelete// Params::evalPrintFlags// Params::evalPrint// Params::evalYodAdjust// fall-through// Params::evalAdjust// Params::evalRename// Params::evalKey// Params::evalGrep// free the memory and drop the regexp// there was an error compiling the regexp// try to compile a reg-exp from the input argument and store it in the vector// http://stackoverflow.com/questions/874134/find-if-string-ends-with-another-string-in-c// Params::setLogLevel// Params::option// main// Return a positive one byte code for better consistency across platforms// Process all files// Create the required action class/*!
      @brief Parses a string containing backslash-escapes
      @param input Input string, assumed to be UTF-8
     *//*!
      @brief Parse one line of the command file
      @param modifyCmd Reference to a command structure to store the parsed
             command
      @param line Input line
      @param num Line number (used for error output)
     *//*!
      @brief Parse metadata modification commands from a container of commands
      @param modifyCmds Reference to a structure to store the parsed commands
      @param cmdLines Container with the commands
     *//*!
      @brief Parse metadata modification commands from multiple files
      @param modifyCmds Reference to a structure to store the parsed commands
      @param cmdFiles Container with the file names
     *//*!
      @brief Parse numbers separated by commas into container
      @param previewNumbers Container for the numbers
      @param optarg Option arguments
      @param j Starting index into optarg
      @return Number of characters processed
     *//*!
      @brief Parse the oparg string into a bitmap of common targets.
      @param optarg Option arguments
      @param action Action being processed
      @return A bitmap of common targets or -1 in case of a parse error
     */// in seconds if successful, else returns false.// Evaluate [-]HH[:MM[:SS]], returns true and sets time to the value// Return a command Id for a command string//! List of all command identifiers and corresponding strings/*
  Abstract:  Command line program to display and manipulate image metadata.

  File:      exiv2.cpp
  Author(s): Andreas Huggel (ahu) <ahuggel@gmx.net>
  History:   10-Dec-03, ahu: created
 */auto_ptr_ref<Task>auto_ptr_ref<Task> &const auto_ptr_ref<Task>const auto_ptr_ref<Task> &reverse_iterator<__wrap_iter<const char *>>reverse_iterator<__wrap_iter<const char *>> &const reverse_iterator<__wrap_iter<const char *>>const reverse_iterator<__wrap_iter<const char *>> &reverse_iterator<__wrap_iter<const char *>> *pair<__tree_const_iterator<int, __tree_node<int, void *> *, long>, bool>const pair<__tree_const_iterator<int, __tree_node<int, void *> *, long>, bool>const pair<__tree_const_iterator<int, __tree_node<int, void *> *, long>, bool> &pair<__tree_const_iterator<int, __tree_node<int, void *> *, long>, bool> &__vector_base<ModifyCmd, allocator<ModifyCmd>>__vector_base<ModifyCmd, allocator<ModifyCmd>> &const __vector_base<ModifyCmd, allocator<ModifyCmd>>const __vector_base<ModifyCmd, allocator<ModifyCmd>> &auto_ptr<Task>auto_ptr<Task> &vector<ModifyCmd, allocator<ModifyCmd>>allocator<ModifyCmd> &set<int, less<int>, allocator<int>>vector<PreviewProperties, allocator<PreviewProperties>>__tree_const_iterator<int, __tree_node<int, void *> *, long>__tree_iterator<int, __tree_node<int, void *> *, long>__tree_iterator<int, __tree_node<int, void *> *, long> *__equal_to<value_type, value_type>allocator<__tree_node<int, void *>>allocator<__tree_node<int, void *>> &const allocator<__tree_node<int, void *>>const allocator<__tree_node<int, void *>> &const __tree_node<int, void *>const __tree_node<int, void *> &__tree_node<int, void *> &const __tree_node<int, void *> *__allocator_traits_rebind<allocator<int>, __tree_node<int, void *>, true>__allocator_traits_rebind<allocator<int>, __tree_node<int, void *>, true> &const __allocator_traits_rebind<allocator<int>, __tree_node<int, void *>, true>const __allocator_traits_rebind<allocator<int>, __tree_node<int, void *>, true> &__allocator_traits_rebind<allocator<__tree_node<int, void *>>, __tree_node_base<void *>, true>__allocator_traits_rebind<allocator<__tree_node<int, void *>>, __tree_node_base<void *>, true> &const __allocator_traits_rebind<allocator<__tree_node<int, void *>>, __tree_node_base<void *>, true>const __allocator_traits_rebind<allocator<__tree_node<int, void *>>, __tree_node_base<void *>, true> &less<TaskType>const less<TaskType> &__identity<less<TaskType>>__identity<less<TaskType>> &const __identity<less<TaskType>>const __identity<less<TaskType>> &allocator<ModifyCmd>const allocator<ModifyCmd>const allocator<ModifyCmd> &__identity<allocator<ModifyCmd>>__identity<allocator<ModifyCmd>> &const __identity<allocator<ModifyCmd>>const __identity<allocator<ModifyCmd>> &const vector<ModifyCmd, allocator<ModifyCmd>> *const vector<regex_t, allocator<regex_t>> *const __vector_base<regex_t, allocator<regex_t>>const __vector_base<regex_t, allocator<regex_t>> *const vector<basic_string<char, char_traits<char>, allocator<char>>, allocator<basic_string<char, char_traits<char>, allocator<char>>>> *const __vector_base<basic_string<char, char_traits<char>, allocator<char>>, allocator<basic_string<char, char_traits<char>, allocator<char>>>> *__vector_base<basic_string<char, char_traits<char>, allocator<char>>, allocator<basic_string<char, char_traits<char>, allocator<char>>>> *const auto_ptr<Task> *operator std::__1::auto_ptr_ref<Action::Task>const pair<__tree_iterator<int, __tree_node<int, void *> *, long>, bool>const pair<__tree_iterator<int, __tree_node<int, void *> *, long>, bool> &pair<__tree_iterator<int, __tree_node<int, void *> *, long>, bool> &const __wrap_iter<const basic_string<char, char_traits<char>, allocator<char>> *> *__wrap_iter<const basic_string<char, char_traits<char>, allocator<char>> *> *ModifyCmd *&__tree_node<int, void *> *&__tree_node_destructor<allocator<__tree_node<int, void *>>> &allocator<regex_t> &operator ModifyCmd *operator std::__1::__tree_node<int, void *> *operator regex_t *operator Action::Task *pair<__tree_iterator<int, __tree_node<int, void *> *, long>, bool> *__equal_to<char, char>__equal_to<char, char> &const __equal_to<char, char>const __equal_to<char, char> &__iterator_traits_impl<reverse_iterator<__wrap_iter<const char *>>, true>__iterator_traits_impl<reverse_iterator<__wrap_iter<const char *>>, true> &const __iterator_traits_impl<reverse_iterator<__wrap_iter<const char *>>, true>const __iterator_traits_impl<reverse_iterator<__wrap_iter<const char *>>, true> &__non_trivial_if<true, allocator<ModifyCmd>>__non_trivial_if<true, allocator<ModifyCmd>> &const __non_trivial_if<true, allocator<ModifyCmd>>const __non_trivial_if<true, allocator<ModifyCmd>> &binary_function<TaskType, TaskType, bool>binary_function<TaskType, TaskType, bool> &const binary_function<TaskType, TaskType, bool>const binary_function<TaskType, TaskType, bool> &__has_rebind_other<allocator<__tree_node<int, void *>>, __tree_node_base<void *>, void>__has_rebind_other<allocator<__tree_node<int, void *>>, __tree_node_base<void *>, void> &const __has_rebind_other<allocator<__tree_node<int, void *>>, __tree_node_base<void *>, void>const __has_rebind_other<allocator<__tree_node<int, void *>>, __tree_node_base<void *>, void> &rebind<__tree_node<int, void *>>rebind<__tree_node<int, void *>> &const rebind<__tree_node<int, void *>>const rebind<__tree_node<int, void *>> &__has_rebind_other<allocator<int>, __tree_node<int, void *>, void>__has_rebind_other<allocator<int>, __tree_node<int, void *>, void> &const __has_rebind_other<allocator<int>, __tree_node<int, void *>, void>const __has_rebind_other<allocator<int>, __tree_node<int, void *>, void> &__non_trivial_if<true, allocator<__tree_node<int, void *>>>__non_trivial_if<true, allocator<__tree_node<int, void *>>> &const __non_trivial_if<true, allocator<__tree_node<int, void *>>>const __non_trivial_if<true, allocator<__tree_node<int, void *>>> &pointer_traits<__tree_node<int, void *> *>pointer_traits<__tree_node<int, void *> *> &const pointer_traits<__tree_node<int, void *> *>const pointer_traits<__tree_node<int, void *> *> &__tree_node_types<__tree_node<int, void *> *, __tree_node<int, void *>>__tree_node_types<__tree_node<int, void *> *, __tree_node<int, void *>> &const __tree_node_types<__tree_node<int, void *> *, __tree_node<int, void *>>const __tree_node_types<__tree_node<int, void *> *, __tree_node<int, void *>> &__tree_node<int, void *>allocator<PreviewProperties>reverse_iterator<__wrap_iter<const regex_t *>>unique_ptr<__tree_node<int, void *>, __tree_node_destructor<allocator<__tree_node<int, void *>>>> &__tree<int, less<int>, allocator<int>>reverse_iterator<__tree_const_iterator<int, __tree_node<int, void *> *, long>>__compressed_pair<ModifyCmd *, allocator<ModifyCmd>>__compressed_pair<ModifyCmd *, allocator<ModifyCmd>> &const __compressed_pair<ModifyCmd *, allocator<ModifyCmd>>const __compressed_pair<ModifyCmd *, allocator<ModifyCmd>> &allocator_traits<allocator<ModifyCmd>>allocator_traits<allocator<ModifyCmd>> &const allocator_traits<allocator<ModifyCmd>>const allocator_traits<allocator<ModifyCmd>> &iterator<random_access_iterator_tag, char, long, const char *, const char &>iterator<random_access_iterator_tag, char, long, const char *, const char &> &const iterator<random_access_iterator_tag, char, long, const char *, const char &>const iterator<random_access_iterator_tag, char, long, const char *, const char &> &__wrap_iter<const regex_t *>const ModifyCmd &&ModifyCmd &&__split_buffer<ModifyCmd, allocator<ModifyCmd> &> &regex_t *&__split_buffer<regex_t, allocator<regex_t> &> &const __vector_base<ModifyCmd, allocator<ModifyCmd>> *__split_buffer<regex_t, allocator<regex_t> &>remove_reference<const ModifyCmd &>remove_reference<const ModifyCmd &> &const remove_reference<const ModifyCmd &>const remove_reference<const ModifyCmd &> &remove_reference<const ModifyCmd>remove_reference<const ModifyCmd> &const remove_reference<const ModifyCmd>const remove_reference<const ModifyCmd> &__split_buffer<ModifyCmd, allocator<ModifyCmd> &>__size_type<allocator<ModifyCmd>, long, true>__size_type<allocator<ModifyCmd>, long, true> &const __size_type<allocator<ModifyCmd>, long, true>const __size_type<allocator<ModifyCmd>, long, true> &__const_void_pointer<ModifyCmd *, allocator<ModifyCmd>, false>__const_void_pointer<ModifyCmd *, allocator<ModifyCmd>, false> &const __const_void_pointer<ModifyCmd *, allocator<ModifyCmd>, false>const __const_void_pointer<ModifyCmd *, allocator<ModifyCmd>, false> &__pointer<ModifyCmd, allocator<ModifyCmd>, allocator<ModifyCmd>, true>__pointer<ModifyCmd, allocator<ModifyCmd>, allocator<ModifyCmd>, true> &const __pointer<ModifyCmd, allocator<ModifyCmd>, allocator<ModifyCmd>, true>const __pointer<ModifyCmd, allocator<ModifyCmd>, allocator<ModifyCmd>, true> &__const_pointer<ModifyCmd, ModifyCmd *, allocator<ModifyCmd>, true>__const_pointer<ModifyCmd, ModifyCmd *, allocator<ModifyCmd>, true> &const __const_pointer<ModifyCmd, ModifyCmd *, allocator<ModifyCmd>, true>const __const_pointer<ModifyCmd, ModifyCmd *, allocator<ModifyCmd>, true> &__void_pointer<ModifyCmd *, allocator<ModifyCmd>, false>__void_pointer<ModifyCmd *, allocator<ModifyCmd>, false> &const __void_pointer<ModifyCmd *, allocator<ModifyCmd>, false>const __void_pointer<ModifyCmd *, allocator<ModifyCmd>, false> &__alloc_traits_difference_type<allocator<ModifyCmd>, ModifyCmd *, true>__alloc_traits_difference_type<allocator<ModifyCmd>, ModifyCmd *, true> &const __alloc_traits_difference_type<allocator<ModifyCmd>, ModifyCmd *, true>const __alloc_traits_difference_type<allocator<ModifyCmd>, ModifyCmd *, true> &__propagate_on_container_move_assignment<allocator<ModifyCmd>, true>__propagate_on_container_move_assignment<allocator<ModifyCmd>, true> &const __propagate_on_container_move_assignment<allocator<ModifyCmd>, true>const __propagate_on_container_move_assignment<allocator<ModifyCmd>, true> &__is_always_equal<allocator<ModifyCmd>, true>__is_always_equal<allocator<ModifyCmd>, true> &const __is_always_equal<allocator<ModifyCmd>, true>const __is_always_equal<allocator<ModifyCmd>, true> &__compressed_pair_elem<allocator<ModifyCmd>, 1, true>__compressed_pair_elem<allocator<ModifyCmd>, 1, true> &const __compressed_pair_elem<allocator<ModifyCmd>, 1, true>const __compressed_pair_elem<allocator<ModifyCmd>, 1, true> &__compressed_pair_elem<ModifyCmd *, 0, false>__compressed_pair_elem<ModifyCmd *, 0, false> &const __compressed_pair_elem<ModifyCmd *, 0, false>const __compressed_pair_elem<ModifyCmd *, 0, false> &ModifyCmd *constModifyCmd *const &__compressed_pair<__tree_end_node<__tree_node_base<void *> *>, allocator<__tree_node<int, void *>>>__compressed_pair<__tree_end_node<__tree_node_base<void *> *>, allocator<__tree_node<int, void *>>> &const __compressed_pair<__tree_end_node<__tree_node_base<void *> *>, allocator<__tree_node<int, void *>>>const __compressed_pair<__tree_end_node<__tree_node_base<void *> *>, allocator<__tree_node<int, void *>>> &__compressed_pair<unsigned long, less<int>>__compressed_pair<unsigned long, less<int>> &const __compressed_pair<unsigned long, less<int>>const __compressed_pair<unsigned long, less<int>> &__make_tree_node_types<int, void *>__make_tree_node_types<int, void *> &const __make_tree_node_types<int, void *>const __make_tree_node_types<int, void *> &__rebind_alloc_helper<allocator_traits<allocator<int>>, __tree_node<int, void *>>__rebind_alloc_helper<allocator_traits<allocator<int>>, __tree_node<int, void *>> &const __rebind_alloc_helper<allocator_traits<allocator<int>>, __tree_node<int, void *>>const __rebind_alloc_helper<allocator_traits<allocator<int>>, __tree_node<int, void *>> &__rebind_alloc_helper<allocator_traits<allocator<__tree_node<int, void *>>>, __tree_node_base<void *>>__rebind_alloc_helper<allocator_traits<allocator<__tree_node<int, void *>>>, __tree_node_base<void *>> &const __rebind_alloc_helper<allocator_traits<allocator<__tree_node<int, void *>>>, __tree_node_base<void *>>const __rebind_alloc_helper<allocator_traits<allocator<__tree_node<int, void *>>>, __tree_node_base<void *>> &pair<__tree_iterator<int, __tree_node<int, void *> *, long>, __tree_iterator<int, __tree_node<int, void *> *, long>>pair<__tree_const_iterator<int, __tree_node<int, void *> *, long>, __tree_const_iterator<int, __tree_node<int, void *> *, long>>__compressed_pair<__tree_node<int, void *> *, __tree_node_destructor<allocator<__tree_node<int, void *>>>>__compressed_pair<__tree_node<int, void *> *, __tree_node_destructor<allocator<__tree_node<int, void *>>>> &const __compressed_pair<__tree_node<int, void *> *, __tree_node_destructor<allocator<__tree_node<int, void *>>>>const __compressed_pair<__tree_node<int, void *> *, __tree_node_destructor<allocator<__tree_node<int, void *>>>> &__pointer<__tree_node<int, void *>, __tree_node_destructor<allocator<__tree_node<int, void *>>>, __tree_node_destructor<allocator<__tree_node<int, void *>>>, true>__pointer<__tree_node<int, void *>, __tree_node_destructor<allocator<__tree_node<int, void *>>>, __tree_node_destructor<allocator<__tree_node<int, void *>>>, true> &const __pointer<__tree_node<int, void *>, __tree_node_destructor<allocator<__tree_node<int, void *>>>, __tree_node_destructor<allocator<__tree_node<int, void *>>>, true>const __pointer<__tree_node<int, void *>, __tree_node_destructor<allocator<__tree_node<int, void *>>>, __tree_node_destructor<allocator<__tree_node<int, void *>>>, true> &__unique_ptr_deleter_sfinae<__tree_node_destructor<allocator<__tree_node<int, void *>>>>__unique_ptr_deleter_sfinae<__tree_node_destructor<allocator<__tree_node<int, void *>>>> &const __unique_ptr_deleter_sfinae<__tree_node_destructor<allocator<__tree_node<int, void *>>>>const __unique_ptr_deleter_sfinae<__tree_node_destructor<allocator<__tree_node<int, void *>>>> &__tree_node_destructor<allocator<__tree_node<int, void *>>> &&const __tree_node_destructor<allocator<__tree_node<int, void *>>>const __tree_node_destructor<allocator<__tree_node<int, void *>>> &rebind_alloc<__tree_node<int, void *>>rebind_alloc<__tree_node<int, void *>> &const rebind_alloc<__tree_node<int, void *>>const rebind_alloc<__tree_node<int, void *>> &__rebind_pointer<void *, int>__rebind_pointer<void *, int> &const __rebind_pointer<void *, int>const __rebind_pointer<void *, int> &__rebind_pointer<void *, const int>__rebind_pointer<void *, const int> &const __rebind_pointer<void *, const int>const __rebind_pointer<void *, const int> &conditional<true, __tree_end_node<__tree_node_base<void *> *> *, __tree_node<int, void *> *>conditional<true, __tree_end_node<__tree_node_base<void *> *> *, __tree_node<int, void *> *> &const conditional<true, __tree_end_node<__tree_node_base<void *> *> *, __tree_node<int, void *> *>const conditional<true, __tree_end_node<__tree_node_base<void *> *> *, __tree_node<int, void *> *> &__tree_map_pointer_types<int, void *, __tree_key_value_types<int>, false>__tree_map_pointer_types<int, void *, __tree_key_value_types<int>, false> &const __tree_map_pointer_types<int, void *, __tree_key_value_types<int>, false>const __tree_map_pointer_types<int, void *, __tree_key_value_types<int>, false> &__tree_key_value_types<int>__tree_key_value_types<int> &const __tree_key_value_types<int>const __tree_key_value_types<int> &allocator_traits<allocator<__tree_node<int, void *>>>allocator_traits<allocator<__tree_node<int, void *>>> &const allocator_traits<allocator<__tree_node<int, void *>>>const allocator_traits<allocator<__tree_node<int, void *>>> &__split_buffer<regex_t, allocator<regex_t> &> *const __split_buffer<regex_t, allocator<regex_t> &>const __split_buffer<regex_t, allocator<regex_t> &> *regex_t **const reverse_iterator<__wrap_iter<const char *>> *const __equal_to<char, char> *__equal_to<char, char> *const unique_ptr<__tree_node<int, void *>, __tree_node_destructor<allocator<__tree_node<int, void *>>>>__compressed_pair<ModifyCmd *, allocator<ModifyCmd>> *__split_buffer<ModifyCmd, allocator<ModifyCmd> &> *const __split_buffer<ModifyCmd, allocator<ModifyCmd> &>const __split_buffer<ModifyCmd, allocator<ModifyCmd> &> *remove_reference<const less<int> &>remove_reference<const less<int> &> &const remove_reference<const less<int> &>const remove_reference<const less<int> &> &__pointer<__tree_node<int, void *>, allocator<__tree_node<int, void *>>, allocator<__tree_node<int, void *>>, true>__pointer<__tree_node<int, void *>, allocator<__tree_node<int, void *>>, allocator<__tree_node<int, void *>>, true> &const __pointer<__tree_node<int, void *>, allocator<__tree_node<int, void *>>, allocator<__tree_node<int, void *>>, true>const __pointer<__tree_node<int, void *>, allocator<__tree_node<int, void *>>, allocator<__tree_node<int, void *>>, true> &__const_pointer<__tree_node<int, void *>, __tree_node<int, void *> *, allocator<__tree_node<int, void *>>, true>__const_pointer<__tree_node<int, void *>, __tree_node<int, void *> *, allocator<__tree_node<int, void *>>, true> &const __const_pointer<__tree_node<int, void *>, __tree_node<int, void *> *, allocator<__tree_node<int, void *>>, true>const __const_pointer<__tree_node<int, void *>, __tree_node<int, void *> *, allocator<__tree_node<int, void *>>, true> &__void_pointer<__tree_node<int, void *> *, allocator<__tree_node<int, void *>>, false>__void_pointer<__tree_node<int, void *> *, allocator<__tree_node<int, void *>>, false> &const __void_pointer<__tree_node<int, void *> *, allocator<__tree_node<int, void *>>, false>const __void_pointer<__tree_node<int, void *> *, allocator<__tree_node<int, void *>>, false> &__const_void_pointer<__tree_node<int, void *> *, allocator<__tree_node<int, void *>>, false>__const_void_pointer<__tree_node<int, void *> *, allocator<__tree_node<int, void *>>, false> &const __const_void_pointer<__tree_node<int, void *> *, allocator<__tree_node<int, void *>>, false>const __const_void_pointer<__tree_node<int, void *> *, allocator<__tree_node<int, void *>>, false> &__alloc_traits_difference_type<allocator<__tree_node<int, void *>>, __tree_node<int, void *> *, true>__alloc_traits_difference_type<allocator<__tree_node<int, void *>>, __tree_node<int, void *> *, true> &const __alloc_traits_difference_type<allocator<__tree_node<int, void *>>, __tree_node<int, void *> *, true>const __alloc_traits_difference_type<allocator<__tree_node<int, void *>>, __tree_node<int, void *> *, true> &__size_type<allocator<__tree_node<int, void *>>, long, true>__size_type<allocator<__tree_node<int, void *>>, long, true> &const __size_type<allocator<__tree_node<int, void *>>, long, true>const __size_type<allocator<__tree_node<int, void *>>, long, true> &__propagate_on_container_move_assignment<allocator<__tree_node<int, void *>>, true>__propagate_on_container_move_assignment<allocator<__tree_node<int, void *>>, true> &const __propagate_on_container_move_assignment<allocator<__tree_node<int, void *>>, true>const __propagate_on_container_move_assignment<allocator<__tree_node<int, void *>>, true> &__is_always_equal<allocator<__tree_node<int, void *>>, true>__is_always_equal<allocator<__tree_node<int, void *>>, true> &const __is_always_equal<allocator<__tree_node<int, void *>>, true>const __is_always_equal<allocator<__tree_node<int, void *>>, true> &is_pointer<__tree_node<int, void *> *>is_pointer<__tree_node<int, void *> *> &const is_pointer<__tree_node<int, void *> *>const is_pointer<__tree_node<int, void *> *> &rebind<const int>rebind<const int> &const rebind<const int>const rebind<const int> &rebind<int>rebind<int> &const rebind<int>const rebind<int> &__has_pointer<__tree_node_destructor<allocator<__tree_node<int, void *>>>, void>__has_pointer<__tree_node_destructor<allocator<__tree_node<int, void *>>>, void> &const __has_pointer<__tree_node_destructor<allocator<__tree_node<int, void *>>>, void>const __has_pointer<__tree_node_destructor<allocator<__tree_node<int, void *>>>, void> &__compressed_pair_elem<__tree_node_destructor<allocator<__tree_node<int, void *>>>, 1, false>__compressed_pair_elem<__tree_node_destructor<allocator<__tree_node<int, void *>>>, 1, false> &const __compressed_pair_elem<__tree_node_destructor<allocator<__tree_node<int, void *>>>, 1, false>const __compressed_pair_elem<__tree_node_destructor<allocator<__tree_node<int, void *>>>, 1, false> &__compressed_pair_elem<__tree_node<int, void *> *, 0, false>__compressed_pair_elem<__tree_node<int, void *> *, 0, false> &const __compressed_pair_elem<__tree_node<int, void *> *, 0, false>const __compressed_pair_elem<__tree_node<int, void *> *, 0, false> &__tree_node<int, void *> *const__tree_node<int, void *> *const &__rebind_pointer<void *, __tree_node<int, void *>>__rebind_pointer<void *, __tree_node<int, void *>> &const __rebind_pointer<void *, __tree_node<int, void *>>const __rebind_pointer<void *, __tree_node<int, void *>> &__compressed_pair_elem<less<int>, 1, true>__compressed_pair_elem<less<int>, 1, true> &const __compressed_pair_elem<less<int>, 1, true>const __compressed_pair_elem<less<int>, 1, true> &__compressed_pair_elem<allocator<__tree_node<int, void *>>, 1, true>__compressed_pair_elem<allocator<__tree_node<int, void *>>, 1, true> &const __compressed_pair_elem<allocator<__tree_node<int, void *>>, 1, true>const __compressed_pair_elem<allocator<__tree_node<int, void *>>, 1, true> &__compressed_pair<ModifyCmd *, allocator<ModifyCmd> &>__compressed_pair<ModifyCmd *, allocator<ModifyCmd> &> &const __compressed_pair<ModifyCmd *, allocator<ModifyCmd> &>const __compressed_pair<ModifyCmd *, allocator<ModifyCmd> &> &remove_reference<allocator<ModifyCmd> &>remove_reference<allocator<ModifyCmd> &> &const remove_reference<allocator<ModifyCmd> &>const remove_reference<allocator<ModifyCmd> &> &add_lvalue_reference<allocator<ModifyCmd> &>add_lvalue_reference<allocator<ModifyCmd> &> &const add_lvalue_reference<allocator<ModifyCmd> &>const add_lvalue_reference<allocator<ModifyCmd> &> &__compressed_pair<regex_t *, allocator<regex_t> &>__compressed_pair<regex_t *, allocator<regex_t> &> &const __compressed_pair<regex_t *, allocator<regex_t> &>const __compressed_pair<regex_t *, allocator<regex_t> &> &remove_reference<allocator<regex_t> &>remove_reference<allocator<regex_t> &> &const remove_reference<allocator<regex_t> &>const remove_reference<allocator<regex_t> &> &add_lvalue_reference<allocator<regex_t> &>add_lvalue_reference<allocator<regex_t> &> &const add_lvalue_reference<allocator<regex_t> &>const add_lvalue_reference<allocator<regex_t> &> &__compressed_pair_elem<allocator<ModifyCmd>, 1, true> *__compressed_pair<__tree_end_node<__tree_node_base<void *> *>, allocator<__tree_node<int, void *>>> *__compressed_pair_elem<allocator<regex_t>, 1, true> *ModifyCmd *&&__compressed_pair_elem<ModifyCmd *, 0, false> *unique_ptr<__tree_node<int, void *>, __tree_node_destructor<allocator<__tree_node<int, void *>>>> *const unique_ptr<__tree_node<int, void *>, __tree_node_destructor<allocator<__tree_node<int, void *>>>> *__compressed_pair<regex_t *, allocator<regex_t>> *regex_t *&&allocator<regex_t> *regex_t *constregex_t *const &allocator<ModifyCmd> *remove_reference<regex_t *&>remove_reference<regex_t *&> &const remove_reference<regex_t *&>const remove_reference<regex_t *&> &remove_reference<ModifyCmd *&>remove_reference<ModifyCmd *&> &const remove_reference<ModifyCmd *&>const remove_reference<ModifyCmd *&> &__add_lvalue_reference_impl<allocator<regex_t> &, true>__add_lvalue_reference_impl<allocator<regex_t> &, true> &const __add_lvalue_reference_impl<allocator<regex_t> &, true>const __add_lvalue_reference_impl<allocator<regex_t> &, true> &__compressed_pair_elem<allocator<regex_t> &, 1, false>__compressed_pair_elem<allocator<regex_t> &, 1, false> &const __compressed_pair_elem<allocator<regex_t> &, 1, false>const __compressed_pair_elem<allocator<regex_t> &, 1, false> &__add_lvalue_reference_impl<allocator<ModifyCmd> &, true>__add_lvalue_reference_impl<allocator<ModifyCmd> &, true> &const __add_lvalue_reference_impl<allocator<ModifyCmd> &, true>const __add_lvalue_reference_impl<allocator<ModifyCmd> &, true> &__compressed_pair_elem<allocator<ModifyCmd> &, 1, false>__compressed_pair_elem<allocator<ModifyCmd> &, 1, false> &const __compressed_pair_elem<allocator<ModifyCmd> &, 1, false>const __compressed_pair_elem<allocator<ModifyCmd> &, 1, false> &pointer_traits<ModifyCmd *>pointer_traits<ModifyCmd *> &const pointer_traits<ModifyCmd *>const pointer_traits<ModifyCmd *> &const __compressed_pair<ModifyCmd *, allocator<ModifyCmd>> *const __compressed_pair<__tree_end_node<__tree_node_base<void *> *>, allocator<__tree_node<int, void *>>> *allocator<__tree_node<int, void *>> *const __compressed_pair<regex_t *, allocator<regex_t>>const __compressed_pair<regex_t *, allocator<regex_t>> *const __compressed_pair_elem<regex_t *, 0, false>__compressed_pair<regex_t *, allocator<regex_t> &> *const allocator<regex_t>const allocator<regex_t> &__compressed_pair_elem<regex_t *, 0, false> *unique_ptr<__tree_node<int, void *>, __tree_node_destructor<allocator<__tree_node<int, void *>>>> &&const __compressed_pair<__tree_node<int, void *> *, __tree_node_destructor<allocator<__tree_node<int, void *>>>> *__compressed_pair<__tree_node<int, void *> *, __tree_node_destructor<allocator<__tree_node<int, void *>>>> *__compressed_pair<ModifyCmd *, allocator<ModifyCmd> &> *remove_reference<ModifyCmd &>remove_reference<ModifyCmd &> &const remove_reference<ModifyCmd &>const remove_reference<ModifyCmd &> &remove_reference<__tree_node_destructor<allocator<__tree_node<int, void *>>>>remove_reference<__tree_node_destructor<allocator<__tree_node<int, void *>>>> &const remove_reference<__tree_node_destructor<allocator<__tree_node<int, void *>>>>const remove_reference<__tree_node_destructor<allocator<__tree_node<int, void *>>>> &__is_referenceable<allocator<ModifyCmd> &>__is_referenceable<allocator<ModifyCmd> &> &const __is_referenceable<allocator<ModifyCmd> &>const __is_referenceable<allocator<ModifyCmd> &> &__is_referenceable<allocator<regex_t> &>__is_referenceable<allocator<regex_t> &> &const __is_referenceable<allocator<regex_t> &>const __is_referenceable<allocator<regex_t> &> &__non_trivial_if<true, allocator<ModifyCmd>> *__non_trivial_if<true, allocator<regex_t>> *const allocator<ModifyCmd> *const __compressed_pair<ModifyCmd *, allocator<ModifyCmd> &> *__compressed_pair_elem<allocator<ModifyCmd> &, 1, false> *__tree_node_destructor<allocator<__tree_node<int, void *>>> *__compressed_pair_elem<__tree_node<int, void *> *, 0, false> *const __compressed_pair_elem<__tree_node<int, void *> *, 0, false> *__compressed_pair<unsigned long, less<int>> *__tree_node<int, void *> *&&const allocator<regex_t> *const __compressed_pair_elem<allocator<regex_t>, 1, true>const __compressed_pair<regex_t *, allocator<regex_t> &> *__compressed_pair_elem<allocator<regex_t> &, 1, false> *const __compressed_pair_elem<regex_t *, 0, false> *__compressed_pair_elem<allocator<__tree_node<int, void *>>, 1, true> *const __compressed_pair_elem<ModifyCmd *, 0, false> *remove_reference<__tree_node<int, void *> *>remove_reference<__tree_node<int, void *> *> &const remove_reference<__tree_node<int, void *> *>const remove_reference<__tree_node<int, void *> *> &const __compressed_pair_elem<allocator<regex_t>, 1, true> *__compressed_pair_elem<less<int>, 1, true> *__compressed_pair_elem<__tree_node_destructor<allocator<__tree_node<int, void *>>>, 1, false> *const __compressed_pair_elem<allocator<ModifyCmd>, 1, true> */Users/owura/Repos/codeql_eval/proj_repos/Exiv2-exiv2-pull-962-commits-e925bc5addd881543fa503470c8a859e112cca62/exiv2/src/fujimn_int.hppFujiMakerNote &const FujiMakerNoteconst FujiMakerNote &FujiMakerNoteFUJIMN_INT_HPP_// #ifndef FUJIMN_INT_HPP_// class FujiMakerNote//! Return read-only list of built-in Fujifilm tags//! MakerNote for Fujifilm cameras/*!
  @file    fujimn_int.hpp
  @brief   Fujifilm MakerNote implemented according to the specification
           in Appendix 4: Makernote of Fujifilm of the document
           <a href="http://park2.wakwak.com/%7Etsuruzoh/Computer/Digicams/exif-e.html">
           Exif file format</a> by TsuruZoh Tachibanaya<br>
           <a href="http://www.sno.phy.queensu.ca/~phil/exiftool/TagNames/Fuji.html">Fuji Makernote list</a> by Phil Harvey<br>
  @author  Andreas Huggel (ahu)
           <a href="mailto:ahuggel@gmx.net">ahuggel@gmx.net</a>
  @author  Gilles Caulier (gc)
           <a href="mailto:caulier dot gilles at gmail dot com">caulier dot gilles at gmail dot com</a>
  @date    11-Feb-04, ahu: created
 *//Users/owura/Repos/codeql_eval/proj_repos/Exiv2-exiv2-pull-962-commits-e925bc5addd881543fa503470c8a859e112cca62/exiv2/src/fujimn_int.cpp"fujimn_int.hpp"const TagInfo[34]TagInfo[34]"Auto (100-400%)""Raw""Standard (100%)""Wide mode 1 (230%)""Wide mode 2 (400%)""Film simulation mode"Auto (100-400%)RawStandard (100%)Wide mode 1 (230%)Wide mode 2 (400%)Film simulation modefujiDynamicRangeSetting"F0/Standard (Provia)""F1/Studio Portrait""F1a/Studio Portrait Enhanced Saturation""F1b/Studio Portrait Smooth Skin Tone (Astia)""F1c/Studio Portrait Increased Sharpness""F2/Fujichrome (Velvia)""F3/Studio Portrait Ex""F4/Velvia""Pro Neg. Std""Pro Neg. Hi""Classic Chrome"F0/Standard (Provia)F1/Studio PortraitF1a/Studio Portrait Enhanced SaturationF1b/Studio Portrait Smooth Skin Tone (Astia)F1c/Studio Portrait Increased SharpnessF2/Fujichrome (Velvia)F3/Studio Portrait ExF4/VelviaPro Neg. Std1281Pro Neg. Hi1536Classic ChromefujiFilmMode"Wide"WidefujiDynamicRange"Chrome""Black & white"ChromeBlack & whitefujiFinePixColor"No flash & flash"No flash & flashfujiContinuous"Night scene""Program AE""Natural light""Anti-blur""Museum""Party""Flower""Text""Natural light & flash""Aperture-priority AE""Shutter speed priority AE"const TagDetails[21]TagDetails[21]Night sceneProgram AENatural lightAnti-blurMuseumPartyFlowerTextNatural light & flashAperture-priority AEShutter speed priority AEfujiPictureModefujiFocusMode"Red-eye reduction""Commander"Red-eye reductionCommanderfujiFlashModefujiTone"Monochrome + R Filter""Monochrome + Ye Filter""Monochrome + G Filter"Monochrome + R FilterMonochrome + Ye FilterMonochrome + G FilterfujiColor"Fluorescent (daylight)""Fluorescent (warm white)""Fluorescent (cool white)""Incandescent"Fluorescent (daylight)Fluorescent (warm white)Fluorescent (cool white)Incandescent3480fujiWhiteBalance"Soft mode 1""Soft mode 2""Hard mode 1""Hard mode 2"Soft mode 1Soft mode 2Hard mode 1Hard mode 2fujiSharpnessfujiOffOn"Version""Fujifilm Makernote version""This number is unique, and contains the date of manufacture, " "but is not the same as the number printed on the camera body.""Image quality setting""Color""Chroma saturation setting""Tone""Flash firing mode setting""Flash Strength""Flash firing strength compensation setting""Macro mode setting""Focusing mode setting""Slow Sync""Slow synchro mode setting""Picture Mode""Picture mode setting""Continuous shooting or auto bracketing setting""Sequence number""FinePix Color""Fuji FinePix color setting""Blur Warning""Blur warning status""Focus Warning""Auto Focus warning status""Exposure Warning""Auto exposure warning status""Dynamic Range""Dynamic range""Film Mode""Film mode""Dynamic Range Setting""Dynamic range settings""Development Dynamic Range""Development dynamic range""Minimum Focal Length""Minimum focal length""Maximum Focal Length""Maximum focal length""Maximum Aperture at Minimum Focal""Maximum aperture at minimum focal""Maximum Aperture at Maximum Focal""Maximum aperture at maximum focal""File Source""File source""Order Number""Order number""Frame Number""Frame number""Unknown FujiMakerNote tag"VersionFujifilm Makernote versionThis number is unique, and contains the date of manufacture, but is not the same as the number printed on the camera body.const char[123]char[123]Image quality setting40970x100140980x100240990x1003ColorChroma saturation setting41000x1004Tone0x1010Flash firing mode setting41130x1011FlashStrength"FlashStrength"Flash StrengthFlash firing strength compensation setting41280x1020Macro mode setting41290x1021Focusing mode setting41300x1022"0x1022"0x1030SlowSync"SlowSync"Slow SyncSlow synchro mode setting0x1031PictureMode"PictureMode"Picture ModePicture mode setting0x1032"0x1032"43520x1100Continuous shooting or auto bracketing setting43530x1101Sequence number46080x1200"0x1200"46240x1210FinePixColor"FinePixColor"FinePix ColorFuji FinePix color setting48640x1300BlurWarning"BlurWarning"Blur WarningBlur warning status48650x1301FocusWarning"FocusWarning"Focus WarningAuto Focus warning status48660x1302ExposureWarning"ExposureWarning"Exposure WarningAuto exposure warning status51200x1400DynamicRange"DynamicRange"Dynamic RangeDynamic range51210x1401FilmMode"FilmMode"Film ModeFilm mode51220x1402DynamicRangeSetting"DynamicRangeSetting"Dynamic Range SettingDynamic range settings51230x1403DevelopmentDynamicRange"DevelopmentDynamicRange"Development Dynamic RangeDevelopment dynamic range51240x1404MinFocalLength"MinFocalLength"Minimum Focal LengthMinimum focal length51250x1405MaxFocalLength"MaxFocalLength"Maximum Focal LengthMaximum focal length51260x1406MaxApertureAtMinFocal"MaxApertureAtMinFocal"Maximum Aperture at Minimum FocalMaximum aperture at minimum focal51270x1407MaxApertureAtMaxFocal"MaxApertureAtMaxFocal"Maximum Aperture at Maximum FocalMaximum aperture at maximum focalFileSource"FileSource"File SourceFile source327700x8002OrderNumber"OrderNumber"Order NumberOrder number327710x8003FrameNumber"FrameNumber"Frame NumberFrame number(UnknownFujiMakerNoteTag)"(UnknownFujiMakerNoteTag)"Unknown FujiMakerNote tag// Fujifilm MakerNote Tag Info//! DynamicRange, tag 0x1402//! FilmMode, tag 0x1401//! DynamicRange, tag 0x1400//! FinePixColor, tag 0x1210//! Continuous, tag 0x1100//! PictureMode, tag 0x1031//! FocusMode, tag 0x1021//! FlashMode, tag 0x1010//! Tone, tag 0x1004//! Color, tag 0x1003//! WhiteBalance, tag 0x1002//! Sharpness, tag 0x1001/*
  File:      fujimn.cpp
  Author(s): Andreas Huggel (ahu) <ahuggel@gmx.net>
             Gilles Caulier (gc) <caulier dot gilles at gmail dot com>
  History:   18-Feb-04, ahu: created
             07-Mar-04, ahu: isolated as a separate component
  Credits:   See header file.
 */const TagDetails(&)[21]TagDetails(&)[21]__DARWIN_ALIGN32(p)((__darwin_size_t)((__darwin_size_t)(p) + __DARWIN_ALIGNBYTES32) &~ __DARWIN_ALIGNBYTES32)__DARWIN_ALIGNBYTES32(sizeof(__uint32_t) - 1)__DARWIN_ALIGN(p)((__darwin_size_t)((__darwin_size_t)(p) + __DARWIN_ALIGNBYTES) &~ __DARWIN_ALIGNBYTES)__DARWIN_ALIGNBYTES(sizeof(__darwin_size_t) - 1)_I386__PARAM_H_/* _I386__PARAM_H_ *//*
 * Round p (pointer or byte index) up to a correctly-aligned value for all
 * data types (int, long, ...).   The result is unsigned int and must be
 * cast to any desired pointer type.
 *//*
 * Copyright (c) 2008 Apple Computer, Inc. All rights reserved.
 *
 * @APPLE_OSREFERENCE_LICENSE_HEADER_START@
 *
 * This file contains Original Code and/or Modifications of Original Code
 * as defined in and that are subject to the Apple Public Source License
 * Version 2.0 (the 'License'). You may not use this file except in
 * compliance with the License. The rights granted to you under the License
 * may not be used to create, or enable the creation or redistribution of,
 * unlawful or unlicensed copies of an Apple operating system, or to
 * circumvent, violate, or enable the circumvention or violation of, any
 * terms of an Apple operating system software license agreement.
 *
 * Please obtain a copy of the License at
 * http://www.opensource.apple.com/apsl/ and read it before using this file.
 *
 * The Original Code and all software distributed under the License are
 * distributed on an 'AS IS' basis, WITHOUT WARRANTY OF ANY KIND, EITHER
 * EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES,
 * INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE, QUIET ENJOYMENT OR NON-INFRINGEMENT.
 * Please see the License for the specific language governing rights and
 * limitations under the License.
 *
 * @APPLE_OSREFERENCE_LICENSE_HEADER_END@
 */<i386/_param.h>DELAY(n){ int N = (n); while (--N > 0); }BASEPRI(x)(((x) & (255 << 8)) == 0)USERMODE(x)(((x) & 3) == 3)STATUS_WORD(rpl,ipl)(((ipl) << 8) | (rpl))bdbtofsb(bn)((bn) / (BLKDEV_IOSIZE/DEV_BSIZE))dbtob(db,devBlockSize)((unsigned)(db) * devBlockSize)btodb(bytes,devBlockSize)((unsigned)(bytes) / devBlockSize)btoc(x)(((unsigned)(x)+(NBPG-1))>>PGSHIFT)ctob(x)((x)<<PGSHIFT)dtob(x)((x)<<DEV_BSHIFT)dtoc(x)((x)>>(PGSHIFT-DEV_BSHIFT))ctod(x)((x)<<(PGSHIFT-DEV_BSHIFT))stoc(x)(x)ctos(x)NMBCLUSTERS((1024 * 1024) / MCLBYTES)MCLOFSET(MCLBYTES - 1)M16KCLBYTES(1 << M16KCLSHIFT)M16KCLSHIFTMBIGCLBYTES(1 << MBIGCLSHIFT)MBIGCLSHIFTMCLBYTES(1 << MCLSHIFT)MCLSHIFTMSIZE(1 << MSIZESHIFT)MSIZESHIFTCLSIZELOG2CLSIZEMAXPHYS(128 * 1024)BLKDEV_IOSIZEDEV_BSHIFTDEV_BSIZEPGSHIFTPGOFSET(NBPG-1)NBPGALIGN(p)ALIGNBYTES_I386_PARAM_H_defined(KERNEL) || defined(STANDALONE)/* _I386_PARAM_H_ *//* defined(KERNEL) || defined(STANDALONE) *//*
 * Macros to decode (and encode) processor status word.
 *//*
 * Map a ``block device block'' to a file system block.
 * This should be device dependent, and will be if we
 * add an entry to cdevsw/bdevsw for that purpose.
 * For now though just use DEV_BSIZE.
 *//* calculates (db * DEV_BSIZE) *//* calculates (bytes / DEV_BSIZE) *//* bytes to clicks *//* clicks to bytes *//* Core clicks (4096 bytes) to disk blocks *//* Core clicks (NeXT_page_size bytes) to segments and vice versa *//*
 * Some macros for units conversion
 *//* cl map size: 1MB *//* size of a jumbo cluster *//* 16384 *//* size of a big cluster *//* 4096 *//* size of an mbuf cluster *//* 2048 *//* size of an mbuf *//* 256 *//*
 * Constants related to network buffer management.
 * MCLBYTES must be no larger than CLBYTES (the software page size), and,
 * on machines that exchange pages of input or output buffers with mbuf
 * clusters (MAPPED_MBUFS), MCLBYTES must also be an integral multiple
 * of the hardware page size.
 *//* max raw I/O transfer size *//* log2(DEV_BSIZE) *//* LOG2(NBPG) *//* byte offset into page *//* bytes/page *//*
 * Machine dependent constants for Intel 386.
 *//*-
 * Copyright (c) 1990, 1993
 *	The Regents of the University of California.  All rights reserved.
 * (c) UNIX System Laboratories, Inc.
 * All or some portions of this file are derived from material licensed
 * to the University of California by American Telephone and Telegraph
 * Co. or Unix System Laboratories, Inc. and are reproduced herein with
 * the permission of UNIX System Laboratories, Inc.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *	This product includes software developed by the University of
 *	California, Berkeley and its contributors.
 * 4. Neither the name of the University nor the names of its contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 *
 *	@(#)param.h	8.1 (Berkeley) 4/4/95
 *//*
 * Copyright (c) 2000-2010 Apple Inc. All rights reserved.
 *
 * @APPLE_OSREFERENCE_LICENSE_HEADER_START@
 *
 * This file contains Original Code and/or Modifications of Original Code
 * as defined in and that are subject to the Apple Public Source License
 * Version 2.0 (the 'License'). You may not use this file except in
 * compliance with the License. The rights granted to you under the License
 * may not be used to create, or enable the creation or redistribution of,
 * unlawful or unlicensed copies of an Apple operating system, or to
 * circumvent, violate, or enable the circumvention or violation of, any
 * terms of an Apple operating system software license agreement.
 *
 * Please obtain a copy of the License at
 * http://www.opensource.apple.com/apsl/ and read it before using this file.
 *
 * The Original Code and all software distributed under the License are
 * distributed on an 'AS IS' basis, WITHOUT WARRANTY OF ANY KIND, EITHER
 * EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES,
 * INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE, QUIET ENJOYMENT OR NON-INFRINGEMENT.
 * Please see the License for the specific language governing rights and
 * limitations under the License.
 *
 * @APPLE_OSREFERENCE_LICENSE_HEADER_END@
 */<i386/param.h>_BSD_MACHINE_PARAM_H_/* _BSD_MACHINE_PARAM_H_ */<sys/signal.h><machine/param.h><sys/syslimits.h>FSCALE(1<<FSHIFT)FSHIFTMAX(a,b)(((a)>(b))?(a):(b))MIN(a,b)(((a)<(b))?(a):(b))powerof2(x)((((x)-1)&(x))==0)roundup(x,y)((((x) % (y)) == 0) ? (x) : ((x) + ((y) - ((x) % (y)))))isclr(a,i)((((unsigned char *)(a))[(i)/NBBY] & (1u<<((i)%NBBY))) == 0)isset(a,i)(((unsigned char *)(a))[(i)/NBBY] & (1u<<((i)%NBBY)))clrbit(a,i)(((unsigned char *)(a))[(i)/NBBY] &= ~(1u<<((i)%NBBY)))setbit(a,i)(((unsigned char *)(a))[(i)/NBBY] |= 1u<<((i)%NBBY))MAXSYMLINKSMAXPATHLENMAXPHYSIO_WIRED(16 * 1024 * 1024)MAXFRAGMAXPHYSIOMAXBSIZE(256 * 4096)CROUND(CBLOCK - 1)CBSIZE(CBLOCK - sizeof(struct cblock *) - CBQSIZE)CBQSIZE(CBLOCK/NBBY)CBLOCKclrnd(i)(i)clbase(i)CLSHIFT(PGSHIFT+CLSIZELOG2)CLOFFCLOFSETclaligned(x)((((int)(x))&CLOFSET)==0)(CLSIZE*NBPG-1)CLBYTES(CLSIZE*NBPG)NODEV(dev_t)(-1)CMASK022NBPWsizeof(int)PSPINPDROPPTTYBLOCKPCATCHPRIMASK0x0ffMAXPRIPUSERPPAUSEPLOCKPWAITPSOCKPZEROPVFSPRIBIOPINODPVMPSWPMAXDOMNAMELENMAXHOSTNAMELENNOGROUPNOFILENGROUPSNGROUPS_MAXNCARGSARG_MAXMAXUPRCCHILD_MAXMAXLOGNAMEMAXINTERPMAXCOMLENNeXTBSD4_0NeXTBSD1995064BSD4_4BSD4_3BSD199506_SYS_PARAM_H_LOCORECLSIZE == 1howmanyMINMAX/* _SYS_PARAM_H_ *//* bits to right of fixed binary point *//*
 * Scale factor for scaled integers used to count %cpu time and load avgs.
 *
 * The number of CPU `tick's that map to a unique `%age' can be expressed
 * by the formula (1 / (2 ^ (FSHIFT - 11))).  The maximum load average that
 * can be calculated (assuming 32 bits) can be closely approximated using
 * the formula (2 ^ (2 * (16 - FSHIFT))) for (FSHIFT < 15).
 *
 * For the scheduler to maintain a 1:1 mapping of CPU `tick' to `%age',
 * FSHIFT must be at least 11; this gives us a maximum load avg of ~1024.
 *//* MAX *//* MIN *//* Macros for min/max. *//* Macros for counting and rounding. *//* Bit map related macros. *//*
 * MAXPATHLEN defines the longest permissable path length after expanding
 * symbolic links. It is used to allocate a temporary buffer from the buffer
 * pool in which to do the name expansion, hence should be a power of two,
 * and must be less than or equal to MAXBSIZE.  MAXSYMLINKS defines the
 * maximum number of symbolic links that may be expanded in a path name.
 * It should be set high enough to allow all legitimate uses, but halt
 * infinite loops reasonably quickly.
 *//*
 * File system parameters and macros.
 *
 * The file system is made out of blocks of at most MAXPHYS units, with
 * smaller units (fragments) only in the last direct block.  MAXBSIZE
 * primarily determines the size of buffers in the buffer pool.  It may be
 * made larger than MAXPHYS without any effect on existing file systems;
 * however making it smaller may make some file systems unmountable.
 * We set this to track the value of MAX_UPL_TRANSFER_BYTES from
 * osfmk/mach/memory_object_types.h to bound it at the maximum UPL size.
 *//* Clist rounding. *//* Data chars/clist. *//* Quote bytes/cblock - can do better. *//* Clist block size, must be a power of 2. *//* Round a number of clicks up to a whole cluster. *//* Give the base virtual address (first of CLSIZE). *//* for clusters, like PGOFSET *//*
 * Clustering of hardware pages on machines with ridiculously small
 * page sizes is done here.  The paging subsystem deals with units of
 * CLSIZE pte's describing NBPG (from machine/param.h) pages each.
 *//* non-existent device *//* default file mask: S_IWGRP|S_IWOTH *//* number of bytes per word (integer) *//* OR'd with pri to require mutex in spin mode upon wakeup *//* OR'd with pri to stop re-aquistion of mutex upon wakeup *//* for tty SIGTTOU and SIGTTIN blocking *//* OR'd with pri for tsleep to check signals *//* Priorities range from 0 through MAXPRI. *//* No longer magic, shouldn't be here.  XXX *//*
 * Priorities.  Note that with 32 run queues, differences less than 4 are
 * insignificant.
 *//* Signals. *//* More types and definitions used throughout the kernel. *//* maximum domain name length *//* max hostname size *//* marker for empty group set member *//* default max open files per process *//* max number groups *//* max bytes for an exec function *//* max simultaneous processes *//* max login name length *//* max interpreter file name length *//* max command name remembered *//*
 * Machine-independent constants (some used in following include files).
 * Redefined constants are from POSIX 1003.1 limits file.
 *
 * MAXCOMLEN should be >= sizeof(ac_comm) (see <acct.h>)
 * MAXLOGNAME should be >= UT_NAMESIZE (see <utmp.h>)
 *//* NeXTBSD 4.0 *//* NeXTBSD version (year, month, release) *//* System version (year & month). *//*-
 * Copyright (c) 1982, 1986, 1989, 1993
 *	The Regents of the University of California.  All rights reserved.
 * (c) UNIX System Laboratories, Inc.
 * All or some portions of this file are derived from material licensed
 * to the University of California by American Telephone and Telegraph
 * Co. or Unix System Laboratories, Inc. and are reproduced herein with
 * the permission of UNIX System Laboratories, Inc.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *	This product includes software developed by the University of
 *	California, Berkeley and its contributors.
 * 4. Neither the name of the University nor the names of its contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 *
 *	@(#)param.h	8.3 (Berkeley) 4/4/95
 *//* Copyright (c) 1995, 1997 Apple Computer, Inc. All Rights Reserved *//*
 * Copyright (c) 2000 Apple Computer, Inc. All rights reserved.
 *
 * @APPLE_OSREFERENCE_LICENSE_HEADER_START@
 *
 * This file contains Original Code and/or Modifications of Original Code
 * as defined in and that are subject to the Apple Public Source License
 * Version 2.0 (the 'License'). You may not use this file except in
 * compliance with the License. The rights granted to you under the License
 * may not be used to create, or enable the creation or redistribution of,
 * unlawful or unlicensed copies of an Apple operating system, or to
 * circumvent, violate, or enable the circumvention or violation of, any
 * terms of an Apple operating system software license agreement.
 *
 * Please obtain a copy of the License at
 * http://www.opensource.apple.com/apsl/ and read it before using this file.
 *
 * The Original Code and all software distributed under the License are
 * distributed on an 'AS IS' basis, WITHOUT WARRANTY OF ANY KIND, EITHER
 * EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES,
 * INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE, QUIET ENJOYMENT OR NON-INFRINGEMENT.
 * Please see the License for the specific language governing rights and
 * limitations under the License.
 *
 * @APPLE_OSREFERENCE_LICENSE_HEADER_END@
 *//Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX.sdk/usr/include/mach/i386/boolean.hboolean_t_MACH_I386_BOOLEAN_H_defined(__x86_64__) && !defined(KERNEL)/* _MACH_I386_BOOLEAN_H_ *//*
 *	File:	boolean.h
 *
 *	Boolean type, for I386.
 *//*
 *//*
 * Mach Operating System
 * Copyright (c) 1991,1990,1989 Carnegie Mellon University
 * All Rights Reserved.
 *
 * Permission to use, copy, modify and distribute this software and its
 * documentation is hereby granted, provided that both the copyright
 * notice and this permission notice appear in all copies of the
 * software, derivative works or modified versions, and any portions
 * thereof, and that both notices appear in supporting documentation.
 *
 * CARNEGIE MELLON ALLOWS FREE USE OF THIS SOFTWARE IN ITS "AS IS"
 * CONDITION.  CARNEGIE MELLON DISCLAIMS ANY LIABILITY OF ANY KIND FOR
 * ANY DAMAGES WHATSOEVER RESULTING FROM THE USE OF THIS SOFTWARE.
 *
 * Carnegie Mellon requests users of this software to return to
 *
 *  Software Distribution Coordinator  or  Software.Distribution@CS.CMU.EDU
 *  School of Computer Science
 *  Carnegie Mellon University
 *  Pittsburgh PA 15213-3890
 *
 * any improvements or extensions that they make and grant Carnegie Mellon
 * the rights to redistribute these changes.
 *//*
 * @OSF_COPYRIGHT@
 *//*
 * Copyright (c) 2000-2006 Apple Computer, Inc. All rights reserved.
 *
 * @APPLE_OSREFERENCE_LICENSE_HEADER_START@
 *
 * This file contains Original Code and/or Modifications of Original Code
 * as defined in and that are subject to the Apple Public Source License
 * Version 2.0 (the 'License'). You may not use this file except in
 * compliance with the License. The rights granted to you under the License
 * may not be used to create, or enable the creation or redistribution of,
 * unlawful or unlicensed copies of an Apple operating system, or to
 * circumvent, violate, or enable the circumvention or violation of, any
 * terms of an Apple operating system software license agreement.
 *
 * Please obtain a copy of the License at
 * http://www.opensource.apple.com/apsl/ and read it before using this file.
 *
 * The Original Code and all software distributed under the License are
 * distributed on an 'AS IS' basis, WITHOUT WARRANTY OF ANY KIND, EITHER
 * EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES,
 * INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE, QUIET ENJOYMENT OR NON-INFRINGEMENT.
 * Please see the License for the specific language governing rights and
 * limitations under the License.
 *
 * @APPLE_OSREFERENCE_LICENSE_HEADER_END@
 *//Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX.sdk/usr/include/mach/i386/Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX.sdk/usr/include/mach/Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX.sdk/usr/include/mach/machine/boolean.h"mach/i386/boolean.h"_MACH_MACHINE_BOOLEAN_H_/* _MACH_MACHINE_BOOLEAN_H_ *//Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX.sdk/usr/include/mach/machine/Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX.sdk/usr/include/mach/boolean.h<mach/machine/boolean.h>_MACH_BOOLEAN_H_ASSEMBLER/* _MACH_BOOLEAN_H_ *//* FALSE *//* TRUE *//*
 *	Define TRUE and FALSE if not defined.
 *//* ASSEMBLER *//*
 *	Pick up "boolean_t" type definition
 *//*
 *	File:	mach/boolean.h
 *
 *	Boolean data type.
 *
 *//*
 * Mach Operating System
 * Copyright (c) 1991,1990,1989,1988,1987 Carnegie Mellon University
 * All Rights Reserved.
 *
 * Permission to use, copy, modify and distribute this software and its
 * documentation is hereby granted, provided that both the copyright
 * notice and this permission notice appear in all copies of the
 * software, derivative works or modified versions, and any portions
 * thereof, and that both notices appear in supporting documentation.
 *
 * CARNEGIE MELLON ALLOWS FREE USE OF THIS SOFTWARE IN ITS "AS IS"
 * CONDITION.  CARNEGIE MELLON DISCLAIMS ANY LIABILITY OF ANY KIND FOR
 * ANY DAMAGES WHATSOEVER RESULTING FROM THE USE OF THIS SOFTWARE.
 *
 * Carnegie Mellon requests users of this software to return to
 *
 *  Software Distribution Coordinator  or  Software.Distribution@CS.CMU.EDU
 *  School of Computer Science
 *  Carnegie Mellon University
 *  Pittsburgh PA 15213-3890
 *
 * any improvements or extensions that they make and grant Carnegie Mellon
 * the rights to redistribute these changes.
 *//Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX.sdk/usr/include/mach/i386/vm_types.hmach_port_context_tvm_map_size_tvm_map_address_tvm_map_offset_tmach_vm_size_tmach_vm_offset_tmach_vm_address_tvm_size_tvm_offset_tinteger_tnatural_tMACH_MSG_TYPE_INTEGER_TMACH_MSG_TYPE_INTEGER_32_MACH_I386_VM_TYPES_H_/* _MACH_I386_VM_TYPES_H_ *//*
 * If composing messages by hand (please do not)
 *//*
 * This new type is independent of a particular vm map's
 * implementation size - and represents appropriate types
 * for all possible maps.  This is used for interfaces
 * where the size of the map is not known - or we don't
 * want to have to distinguish.
 *//*
 * A vm_size_t is the proper type for e.g.
 * expressing the difference between two
 * vm_offset_t entities.
 *//*
 * A vm_offset_t is a type-neutral pointer,
 * e.g. an offset into a virtual memory space.
 *//*
 * natural_t and integer_t are Mach's legacy types for machine-
 * independent integer types (unsigned, and signed, respectively).
 * Their original purpose was to define other types in a machine/
 * compiler independent way.
 *
 * They also had an implicit "same size as pointer" characteristic
 * to them (i.e. Mach's traditional types are very ILP32 or ILP64
 * centric).  We support x86 ABIs that do not follow either of
 * these models (specifically LP64).  Therefore, we had to make a
 * choice between making these types scale with pointers or stay
 * tied to integers.  Because their use is predominantly tied to
 * to the size of an integer, we are keeping that association and
 * breaking free from pointer size guarantees.
 *
 * New use of these types is discouraged.
 *//*
 *	File:	vm_types.h
 *	Author:	Avadis Tevanian, Jr.
 *	Date: 1985
 *
 *	Header file for VM data types.  I386 version.
 *//*
 * Mach Operating System
 * Copyright (c) 1991,1990,1989,1988 Carnegie Mellon University
 * All Rights Reserved.
 *
 * Permission to use, copy, modify and distribute this software and its
 * documentation is hereby granted, provided that both the copyright
 * notice and this permission notice appear in all copies of the
 * software, derivative works or modified versions, and any portions
 * thereof, and that both notices appear in supporting documentation.
 *
 * CARNEGIE MELLON ALLOWS FREE USE OF THIS SOFTWARE IN ITS "AS IS"
 * CONDITION.  CARNEGIE MELLON DISCLAIMS ANY LIABILITY OF ANY KIND FOR
 * ANY DAMAGES WHATSOEVER RESULTING FROM THE USE OF THIS SOFTWARE.
 *
 * Carnegie Mellon requests users of this software to return to
 *
 *  Software Distribution Coordinator  or  Software.Distribution@CS.CMU.EDU
 *  School of Computer Science
 *  Carnegie Mellon University
 *  Pittsburgh PA 15213-3890
 *
 * any improvements or extensions that they make and grant Carnegie Mellon
 * the rights to redistribute these changes.
 *//*
 * Copyright (c) 2000-2016 Apple Computer, Inc. All rights reserved.
 *
 * @APPLE_OSREFERENCE_LICENSE_HEADER_START@
 *
 * This file contains Original Code and/or Modifications of Original Code
 * as defined in and that are subject to the Apple Public Source License
 * Version 2.0 (the 'License'). You may not use this file except in
 * compliance with the License. The rights granted to you under the License
 * may not be used to create, or enable the creation or redistribution of,
 * unlawful or unlicensed copies of an Apple operating system, or to
 * circumvent, violate, or enable the circumvention or violation of, any
 * terms of an Apple operating system software license agreement.
 *
 * Please obtain a copy of the License at
 * http://www.opensource.apple.com/apsl/ and read it before using this file.
 *
 * The Original Code and all software distributed under the License are
 * distributed on an 'AS IS' basis, WITHOUT WARRANTY OF ANY KIND, EITHER
 * EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES,
 * INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE, QUIET ENJOYMENT OR NON-INFRINGEMENT.
 * Please see the License for the specific language governing rights and
 * limitations under the License.
 *
 * @APPLE_OSREFERENCE_LICENSE_HEADER_END@
 *//Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX.sdk/usr/include/mach/machine/vm_types.h"mach/i386/vm_types.h"_MACH_MACHINE_VM_TYPES_H_/* _MACH_MACHINE_VM_TYPES_H_ *//Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX.sdk/usr/include/mach/port.h<mach/machine/vm_types.h><mach/boolean.h>mach_port_options &const mach_port_optionsconst mach_port_options &mach_service_port_info &const mach_service_port_infoconst mach_service_port_info &mach_port_qos &const mach_port_qosconst mach_port_qos &mach_port_guard_info &const mach_port_guard_infoconst mach_port_guard_info &mach_port_info_ext &const mach_port_info_extconst mach_port_info_ext &mach_port_limits &const mach_port_limitsconst mach_port_limits &mach_port_status &const mach_port_statusconst mach_port_status &mach_port_guard_exception_codeskGUARD_EXC_DESTROY1u1u << 0kGUARD_EXC_MOD_REFS1u << 1kGUARD_EXC_SET_CONTEXT1u << 2kGUARD_EXC_UNGUARDED1u << 3kGUARD_EXC_INCORRECT_GUARD1u << 4kGUARD_EXC_IMMOVABLE1u << 5kGUARD_EXC_STRICT_REPLY1u << 6kGUARD_EXC_MSG_FILTERED1u << 7kGUARD_EXC_INVALID_RIGHT1u << 8kGUARD_EXC_INVALID_NAME1u << 9kGUARD_EXC_INVALID_VALUE1u << 10kGUARD_EXC_INVALID_ARGUMENT1u << 11kGUARD_EXC_RIGHT_EXISTS1u << 12kGUARD_EXC_KERN_NO_SPACE1u << 13kGUARD_EXC_KERN_FAILURE1u << 14kGUARD_EXC_KERN_RESOURCE1u << 15kGUARD_EXC_SEND_INVALID_REPLY1u << 16kGUARD_EXC_SEND_INVALID_VOUCHER1u << 17kGUARD_EXC_SEND_INVALID_RIGHT1u << 18kGUARD_EXC_RCV_INVALID_NAME1u << 19kGUARD_EXC_RCV_GUARDED_DESC1u << 20kGUARD_EXC_MOD_REFS_NON_FATAL1u << 21kGUARD_EXC_IMMOVABLE_NON_FATAL1u << 22mach_port_options_t *mach_port_options *mach_port_options_ptr_tmach_port_options_tmach_port_optionsmach_service_port_info *mach_service_port_info_tmach_service_port_info_data_tmach_service_port_infomach_port_qos_tmach_port_qosmach_port_flavor_tinteger_t *mach_port_info_tmach_port_guard_info_tmach_port_guard_infomach_port_info_ext_tmach_port_info_extmach_port_limits_tmach_port_limitsmach_port_status_tmach_port_statusmach_port_srights_tmach_port_rights_tmach_port_msgcount_tmach_port_mscount_tmach_port_seqno_tmach_port_delta_tmach_port_urefs_tmach_port_type_t *mach_port_type_array_tmach_port_type_tmach_port_right_tmach_port_t *mach_port_array_tmach_port_name_t *mach_port_name_array_tmach_port_name_tservice_port_nameservice_port_infowork_interval_portuint64_t[2]unsigned long long[2]mplmspi_domain_typechar[255]MACH_SERVICE_PORT_INFO_STRING_NAME_MAX_BUF_LENmspi_string_namepad1preallocmpgi_guarduint32_t[6]unsigned int[6]mpie_boost_cntmpie_statusmpl_qlimitmps_flagsmps_nsrequestmps_pdrequestmps_srightsmps_sorightsmps_msgcountmps_qlimitmps_mscountmps_seqnomps_psetMPG_IMMOVABLE_RECEIVEMPG_STRICTMPG_FLAGS_IMMOVABLE_PINNED(0x01ull << 56)MPG_FLAGS_MOD_REFS_PINNED_COPYIN(0x04ull << 56)MPG_FLAGS_MOD_REFS_PINNED_DESTROY(0x02ull << 56)MPG_FLAGS_MOD_REFS_PINNED_DEALLOCMPG_FLAGS_STRICT_REPLY_MASK(0xffull << 56)MPG_FLAGS_STRICT_REPLY_MISMATCHED_PERSONA(0x10ull << 56)MPG_FLAGS_STRICT_REPLY_NO_BANK_ATTR(0x08ull << 56)MPG_FLAGS_STRICT_REPLY_INVALID_VOUCHERMPG_FLAGS_STRICT_REPLY_INVALID_REPLY_PORTMPG_FLAGS_STRICT_REPLY_INVALID_REPLY_DISPMAX_OPTIONAL_kGUARD_EXC_CODE(1u << 19)MPG_FLAGS_NONE(0x00ull)MAX_FATAL_kGUARD_EXC_CODE(1u << 7)GUARD_TYPE_MACH_PORTMPO_CONNECTION_PORTMPO_SERVICE_PORTMPO_TG_BLOCK_TRACKINGMPO_FILTER_MSGMPO_IMMOVABLE_RECEIVEMPO_DENAP_RECEIVERMPO_STRICTMPO_INSERT_SEND_RIGHTMPO_IMPORTANCE_RECEIVERMPO_TEMPOWNERMPO_QLIMITMPO_CONTEXT_AS_GUARDMACH_SERVICE_PORT_INFO_COUNT((char) (sizeof(mach_service_port_info_data_t)/sizeof(char)))MACH_PORT_GUARD_INFO_COUNT((natural_t) (sizeof(mach_port_guard_info_t)/sizeof(natural_t)))MACH_PORT_INFO_EXT_COUNT((natural_t) (sizeof(mach_port_info_ext_t)/sizeof(natural_t)))MACH_PORT_DNREQUESTS_SIZE_COUNTMACH_PORT_RECEIVE_STATUS_COUNT((natural_t) (sizeof(mach_port_status_t)/sizeof(natural_t)))MACH_PORT_LIMITS_INFO_COUNT((natural_t) (sizeof(mach_port_limits_t)/sizeof(natural_t)))MACH_PORT_GUARD_INFOMACH_PORT_INFO_EXTMACH_PORT_DENAP_RECEIVERMACH_PORT_IMPORTANCE_RECEIVERMACH_PORT_TEMPOWNERMACH_PORT_DNREQUESTS_SIZEMACH_PORT_RECEIVE_STATUSMACH_PORT_LIMITS_INFOMACH_PORT_STATUS_FLAG_NO_GRANTMACH_PORT_STATUS_FLAG_GUARD_IMMOVABLE_RECEIVEMACH_PORT_STATUS_FLAG_TASKPTRMACH_PORT_STATUS_FLAG_REVIVEMACH_PORT_STATUS_FLAG_IMP_DONATIONMACH_PORT_STATUS_FLAG_STRICT_GUARDMACH_PORT_STATUS_FLAG_GUARDEDMACH_PORT_STATUS_FLAG_TEMPOWNERMACH_PORT_QLIMIT_MAXMACH_PORT_QLIMIT_LARGEMACH_PORT_QLIMIT_DEFAULTMACH_PORT_QLIMIT_BASICMACH_PORT_QLIMIT_MINMACH_PORT_QLIMIT_ZEROMACH_PORT_QLIMIT_KERNEL(65534)(1024)MACH_PORT_QLIMIT_SMALL(16)(5)MACH_PORT_SRIGHTS_PRESENTMACH_PORT_SRIGHTS_NONEMACH_PORT_TYPE_SPREQUEST_DELAYEDMACH_PORT_TYPE_SPREQUESTMACH_PORT_TYPE_DNREQUESTMACH_PORT_TYPE_ALL_RIGHTS(MACH_PORT_TYPE_PORT_OR_DEAD|MACH_PORT_TYPE_PORT_SET)MACH_PORT_TYPE_PORT_OR_DEAD(MACH_PORT_TYPE_PORT_RIGHTS|MACH_PORT_TYPE_DEAD_NAME)MACH_PORT_TYPE_PORT_RIGHTS(MACH_PORT_TYPE_SEND_RIGHTS|MACH_PORT_TYPE_RECEIVE)MACH_PORT_TYPE_SEND_RIGHTS(MACH_PORT_TYPE_SEND|MACH_PORT_TYPE_SEND_ONCE)MACH_PORT_TYPE_SEND_RECEIVE(MACH_PORT_TYPE_SEND|MACH_PORT_TYPE_RECEIVE)MACH_PORT_TYPE_LABELHMACH_PORT_TYPE(MACH_PORT_RIGHT_LABELH)MACH_PORT_TYPE_DEAD_NAMEMACH_PORT_TYPE(MACH_PORT_RIGHT_DEAD_NAME)MACH_PORT_TYPE_PORT_SETMACH_PORT_TYPE(MACH_PORT_RIGHT_PORT_SET)MACH_PORT_TYPE_SEND_ONCEMACH_PORT_TYPE(MACH_PORT_RIGHT_SEND_ONCE)MACH_PORT_TYPE_RECEIVEMACH_PORT_TYPE(MACH_PORT_RIGHT_RECEIVE)MACH_PORT_TYPE_SENDMACH_PORT_TYPE(MACH_PORT_RIGHT_SEND)MACH_PORT_TYPE_NONE((mach_port_type_t) 0L)MACH_PORT_TYPE(right)((mach_port_type_t)(((mach_port_type_t) 1) << ((right) + ((mach_port_right_t) 16))))MACH_PORT_RIGHT_NUMBER((mach_port_right_t) 6)MACH_PORT_RIGHT_LABELH((mach_port_right_t) 5)MACH_PORT_RIGHT_DEAD_NAME((mach_port_right_t) 4)MACH_PORT_RIGHT_PORT_SET((mach_port_right_t) 3)MACH_PORT_RIGHT_SEND_ONCE((mach_port_right_t) 2)MACH_PORT_RIGHT_RECEIVE((mach_port_right_t) 1)MACH_PORT_RIGHT_SEND((mach_port_right_t) 0)MACH_PORT_MAKE(index,gen)(((index) << 8) | (gen) >> 24)MACH_PORT_GEN(name)(((name) & 0xff) << 24)MACH_PORT_INDEX(name)((name) >> 8)MACH_PORT_VALID(name)(((name) != MACH_PORT_NULL) && ((name) != MACH_PORT_DEAD))MACH_PORT_DEAD((mach_port_name_t) ~0)MACH_PORT_NULL_MACH_PORT_H_NO_PORT_GEN!__DARWIN_UNIX03 && !defined(_NO_PORT_T_FROM_MACH)/* _MACH_PORT_H_ *//* !__DARWIN_UNIX03 && !_NO_PORT_T_FROM_MACH *//*
 *  Mach 3.0 renamed everything to have mach_ in front of it.
 *  These types and macros are provided for backward compatibility
 *	but are deprecated.
 *//* Receive right cannot be moved out of the space *//* Apply strict guarding for a port *//*
 * Flags for mach_port_guard_with_flags. These flags extend
 * the attributes associated with a guarded port.
 *//*
 * These flags are used as bits in the subcode of kGUARD_EXC_IMMOVABLE exceptions.
 *//*
 * These flags are used as bits in the subcode of kGUARD_EXC_MOD_REFS exceptions.
 *//*
 * These flags are used as bits in the subcode of kGUARD_EXC_STRICT_REPLY exceptions.
 *//*
 * Mach port guard flags.
 *//* for development only *//* start of always non-fatal guards *//* start of [optionally] non-fatal guards *//* Reasons for exception for a guarded mach port *//*
 * EXC_GUARD represents a guard violation for both
 * mach ports and file descriptors. GUARD_TYPE_ is used
 * to differentiate among them.
 *//* Mach Port Guarding definitions *//* Service port (MPO_CONNECTION_PORT) *//* Service port (MPO_SERVICE_PORT) *//* Work interval port *//* Message queue limit for port *//* Flags defining attributes for port *//*
 * Structure to define optional attributes for a newly
 * constructed port.
 *//* Derive new peer connection port from a given service port *//* Create a service port with the given name; should be used only by launchd *//* Track blocking relationship for thread group during sync IPC *//* Allow message filtering *//* Mark the port as immovable; protected by the guard context *//* Mark the port as App de-nap receiver *//* Apply strict guarding for port *//* Insert a send right for the port *//* Mark the port as importance receiver *//* Set the tempowner bit of the port *//* Set qlimit for the port msg queue *//* Add guard to the port *//*
 * Flags for mach_port_options (used for
 * invocation of mach_port_construct).
 * Indicates attributes to be set for the newly
 * allocated port.
 *//* Service port domain *//* Service port's string name *//* Maximum length of the port string name buffer *//*
 * Structure used to pass information about the service port
 *//* prealloced message *//* name given *//*
 * Structure used to pass information about port allocation requests.
 * Must be padded to 64-bits total length.
 *//* asserts if the strict guard value is correct *//* uses mach_port_info_ext_t *//* indicates receive right accepts de-nap donation *//* indicates recieve right accepts priority donation *//* indicates receive right will be reassigned to another task *//* info is int *//* uses mach_port_status_t *//* uses mach_port_limits_t *//* Flavors for mach_port_get/set/assert_attributes() *//* varying array of natural_t *//* guard value *//* Possible values for mps_flags (part of mach_port_status_t) *//* number of msgs *//* System-wide values for setting queue limits on a port *//* port flags *//* no-senders requested? *//* port-deleted requested? *//* do send rights exist? *//* how many send-once rights *//* number in the queue *//* queue limit *//* make-send count *//* sequence number *//* count of containing port sets *//* status of send rights *//* srights *//* no srights *//*
 *	Are there outstanding send rights for a given port?
 *//* number of rights *//* Attributes of ports.  (See mach_port_get_receive_status.) *//* change in urefs *//* User-references for capabilities. *//* Dummy type bits that mach_port_type/mach_port_names can return. *//* Convenient combinations. *//* obsolete *//* right not implemented *//* obsolete right *//*
 *  These are the different rights a task may have for a port.
 *  The MACH_PORT_RIGHT_* definitions are used as arguments
 *  to mach_port_allocate, mach_port_get_refs, etc, to specify
 *  a particular right to act upon.  The mach_port_names and
 *  mach_port_type calls return bitmasks using the MACH_PORT_TYPE_*
 *  definitions.  This is because a single name may denote
 *  multiple rights.
 *//* NO_PORT_GEN *//*
 *	For kernel-selected [assigned] port names, the name is
 *	comprised of two parts: a generation number and an index.
 *	This approach keeps the exact same name from being generated
 *	and reused too quickly [to catch right/reference counting bugs].
 *	The dividing line between the constituent parts is exposed so
 *	that efficient "mach_port_name_t to data structure pointer"
 *	conversion implementation can be made.  But it is possible
 *	for user-level code to assign their own names to Mach ports.
 *	These are not required to participate in this algorithm.  So
 *	care should be taken before "assuming" this model.
 *
 *//* intentional loose typing *//*
 *  MACH_PORT_NULL is a legal value that can be carried in messages.
 *  It indicates the absence of any port or port rights.  (A port
 *  argument keeps the message from being "simple", even if the
 *  value is MACH_PORT_NULL.)  The value MACH_PORT_DEAD is also a legal
 *  value that can be carried in messages.  It indicates
 *  that a port right was present, but it died.
 *//*
 *	mach_port_t - a named port right
 *
 *	In user-space, "rights" are represented by the name of the
 *	right in the Mach port namespace.  Even so, this type is
 *	presented as a unique one to more clearly denote the presence
 *	of a right coming along with the name.
 *
 *	Often, various rights for a port held in a single name space
 *	will coalesce and are, therefore, be identified by a single name
 *	[this is the case for send and receive rights].  But not
 *	always [send-once rights currently get a unique name for
 *	each right].
 *
 *//*
 *	mach_port_name_t - the local identity for a Mach port
 *
 *	The name is Mach port namespace specific.  It is used to
 *	identify the rights held for that port by the task whose
 *	namespace is implied [or specifically provided].
 *
 *	Use of this type usually implies just a name - no rights.
 *	See mach_port_t for a type that implies a "named right."
 *
 *//*
 *	File:	mach/port.h
 *
 *	Definition of a Mach port
 *
 *	Mach ports are the endpoints to Mach-implemented communications
 *	channels (usually uni-directional message queues, but other types
 *	also exist).
 *
 *	Unique collections of these endpoints are maintained for each
 *	Mach task.  Each Mach port in the task's collection is given a
 *	[task-local] name to identify it - and the the various "rights"
 *	held by the task for that specific endpoint.
 *
 *	This header defines the types used to identify these Mach ports
 *	and the various rights associated with them.  For more info see:
 *
 *	<mach/mach_port.h> - manipulation of port rights in a given space
 *	<mach/message.h> - message queue [and port right passing] mechanism
 *
 *//*
 * NOTICE: This file was modified by McAfee Research in 2004 to introduce
 * support for mandatory and extensible security protections.  This notice
 * is included in support of clause 2.2 (b) of the Apple Public License,
 * Version 2.0.
 *//Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX.sdk/usr/include/bsm/audit.h<mach/port.h>audit_session_portaudit_session_joinaudit_session_selfsetauditconst auditinfoconst auditinfo *auditinfo *getauditsetaudit_addrconst auditinfo_addrconst auditinfo_addr *auditinfo_addr *getaudit_addrsetauidconst au_id_tconst au_id_t *getauidau_id_t *auditctlauditonauditau_evclass_map &const au_evclass_mapconst au_evclass_map &audit_fstat &const audit_fstatconst audit_fstat &audit_stat &const audit_statconst audit_stat &au_qctrl &const au_qctrlconst au_qctrl &au_expire_after &const au_expire_afterconst au_expire_after &au_session &const au_sessionconst au_session &auditpinfo_addr &const auditpinfo_addrconst auditpinfo_addr &auditpinfo &const auditpinfoconst auditpinfo &auditinfo_addr &const auditinfo_addr &auditinfo &const auditinfo &au_mask &const au_maskconst au_mask &au_tid_addr &const au_tid_addrconst au_tid_addr &au_tid &const au_tidconst au_tid &au_evclass_map_tau_evclass_mapau_fstat_taudit_fstatau_stat_taudit_statau_qctrl_tau_qctrltoken_tau_tokenau_expire_after_tau_expire_afterau_session_tau_sessionauditpinfo_addr_tauditpinfo_addrauditpinfo_tauditpinfoauditinfo_addr_tauditinfo_addrauditinfo_tauditinfoau_mask_tau_maskau_tid_addr_tau_tid_addrau_tid_tau_tidau_ctlmode_tau_asflgs_tau_class_tau_emod_tau_event_tau_asid_tau_id_tec_classec_numberaf_currszaf_fileszas_memusedas_totalsizeas_droppedas_rblockedas_wblockedas_writtenas_enqueueas_auditctlas_auditas_kernelas_nonattribas_generatedas_numeventas_versionaq_minfreeaq_delayaq_bufszaq_lowateraq_hiwaterop_typeageas_maskauditinfo_addr_t *as_aia_pap_flagsap_asidap_termidap_maskap_auidap_pidai_flagsai_asidai_termidai_maskai_auidam_failuream_successu_int32_t[4]at_addrat_typeat_portmachine__AUDIT_API_DEPRECATED__API_DEPRECATED("audit is deprecated", macos(10.4, 11.0))AUDIT_EXPIRE_OP_OR((unsigned char)1)AUDIT_EXPIRE_OP_AND((unsigned char)0)AUDIT_CTLMODE_EXTERNAL((unsigned char)2)AUDIT_CTLMODE_NORMALAU_CLASS_MASK_RESERVED0x10000000AU_IPv6AU_IPv4AU_FS_MINFREEAQ_MAXBUFSZAQ_BUFSZMAXAUDITDATAAQ_LOWATERAQ_MAXHIGHAQ_HIWATERAUDIT_PERZONEAUDIT_ZONENAMEAUDIT_PUBLICAUDIT_SCNTAUDIT_PATHAUDIT_TRAILAUDIT_GROUPAUDIT_USERAUDIT_WINDATAAUDIT_SEQAUDIT_ARGEAUDIT_ARGVAUDIT_AHLTAUDIT_CNTA_SETEXPAFTERA_GETEXPAFTERA_SETCTLMODEA_GETCTLMODEA_SETSFLAGSA_GETSFLAGSA_SETCONDA_GETCONDA_SETQCTRLA_GETQCTRLA_SETPOLICYA_GETPOLICYA_GETSINFO_ADDRA_SENDTRIGGERA_SETKAUDITA_GETKAUDITA_GETPINFO_ADDRA_GETFSIZEA_SETFSIZEA_SETPMASKA_GETPINFOA_SETCLASSA_GETCLASSA_OLDSETCONDA_OLDGETCONDA_SETSMASKA_SETUMASKA_SETSTATA_GETSTATA_GETCARA_GETCWDA_OLDSETQCTRLA_OLDGETQCTRLA_SETKMASKA_GETKMASKA_OLDSETPOLICYA_OLDGETPOLICYAUC_DISABLEDAUC_NOAUDITAUC_AUDITINGAUC_UNSETAT_IPC_SHM((unsigned char)3)AT_IPC_SEMAT_IPC_MSGAU_ASSIGN_ASIDAU_DEFAUDITSIDAU_DEFAUDITID(uid_t)(-1)AUDIT_TRIGGER_FILE("/dev/" AUDITDEV_FILENAME)AUDITDEV_FILENAME"audit"AUDIT_TRIGGER_MAXAUDIT_TRIGGER_EXPIRE_TRAILSAUDIT_TRIGGER_INITIALIZEAUDIT_TRIGGER_ROTATE_USERAUDIT_TRIGGER_NO_SPACEAUDIT_TRIGGER_CLOSE_AND_DIEAUDIT_TRIGGER_READ_FILEAUDIT_TRIGGER_ROTATE_KERNELAUDIT_TRIGGER_LOW_SPACEAUDIT_TRIGGER_MINAUDIT_HARD_LIMIT_FREE_BLOCKSMIN_AUDIT_FILE_SIZE(512 * 1024)MAX_AUDIT_RECORD_SIZE(0x8000 - 1)MAX_AUDIT_RECORDSAUDIT_RECORD_MAGIC0x828a0f1b_BSM_AUDIT_H!defined(_KERNEL) && !defined(KERNEL)"audit is deprecated""audit is deprecated", macos(10.4, 11.0)macos(10.4, 11.0)/* !_BSM_AUDIT_H *//* defined(_KERNEL) || defined(KERNEL) *//* !__APPLE__ *//*
 * getaudit()/setaudit() are deprecated and have been replaced with
 * wrappers to the getaudit_addr()/setaudit_addr() syscalls above.
 *//*
 * Audit system calls.
 *//*
 * Audit to event class mapping.
 *//*
 * Structure for the audit file statistics.
 *//*
 * Structure for the audit statistics.
 *//* Minimum filesystem percent free space. *//* Queue delay (not used). *//* Max size of audit record for audit(2). *//* blocked threads get unblocked. *//* # of audit recs in queue when *//* threads with new ARs get blocked. *//* Max # of audit recs in queue when *//*
 * Kernel audit queue control parameters:
 *                      Default:		Maximum:
 *      aq_hiwater:	AQ_HIWATER (100)	AQ_MAXHIGH (10000)
 *      aq_lowater:	AQ_LOWATER (10)		<aq_hiwater
 *      aq_bufsz:	AQ_BUFSZ (32767)	AQ_MAXBUFSZ (1048576)
 *      aq_delay:	20			20000 (not used)
 *//*
 * Contents of token_t are opaque outside of libbsm.
 *//* Operator used with the above values to determine when files should be expired *//* Aggregate trail size when files should be expired *//* Age after which trail files should be expired *//* Process Audit Masks. *//* Ptr to full audit info. *//* Audit session flags. *//* Audit session ID. *//* Terminal ID. *//* Audit masks. *//* Audit user ID. *//* ID of target process. *//* Failure bits. *//* Success bits. *//*
 * Audit file expire_after op modes
 *//*
 * Audit control modes
 *//*
 * Reserved audit class mask indicating which classes are unable to have
 * events added or removed by unentitled processes.
 *//*
 * Type definitions used indicating the length of variable length addresses
 * in tokens containing addresses, such as header fields.
 *//*
 * Default minimum percentage free space on file system.
 *//*
 * Default audit queue control parameters.
 *//*
 * Audit policy controls.
 *//*
 * auditon(2) commands.
 *//*
 * Audit conditions.
 *//* Shared mem IPC id. *//* Semaphore IPC id. *//* Message IPC id. *//*
 * IPC types.
 *//*
 * Pre-defined audit IDs
 *//*
 * The special device filename (FreeBSD).
 *//* User expiration of trails. *//* User initialize of auditd. *//* User requests rotate. *//* Below min free space. *//* Terminate audit. *//* Re-read config file. *//* Kernel requests rotate. *//* Below low watermark. *//*
 * Triggers for the audit daemon.
 *//*
 * Minimum noumber of free blocks on the filesystem containing the audit
 * log necessary to avoid a hard log rotation. DO NOT SET THIS VALUE TO 0
 * as the kernel does an unsigned compare, plus we want to leave a few blocks
 * free so userspace can terminate the log, etc.
 *//*-
 * Copyright (c) 2005-2009 Apple Inc.
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 *
 * 1.  Redistributions of source code must retain the above copyright
 *     notice, this list of conditions and the following disclaimer.
 * 2.  Redistributions in binary form must reproduce the above copyright
 *     notice, this list of conditions and the following disclaimer in the
 *     documentation and/or other materials provided with the distribution.
 * 3.  Neither the name of Apple Inc. ("Apple") nor the names of
 *     its contributors may be used to endorse or promote products derived
 *     from this software without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY APPLE AND ITS CONTRIBUTORS "AS IS" AND ANY
 * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
 * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED. IN NO EVENT SHALL APPLE OR ITS CONTRIBUTORS BE LIABLE FOR ANY
 * DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
 * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
 * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
 * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
 * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 *
 * $P4: //depot/projects/trustedbsd/openbsm/sys/bsm/audit.h#10 $
 *//Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX.sdk/usr/include/bsmasidportname/Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX.sdk/usr/include/sys/ucred.h<bsm/audit.h>xucred &const xucredconst xucred &xucredposix_cred *posix_cred_tucred *kauth_cred_tposix_creducredgid_t[16]cr_groupscr_ngroupscr_uidcr_versionIS_VALID_CRED(_cr)((_cr) != NOCRED && (_cr) != FSCRED)FSCRED((kauth_cred_t )-1)NOCRED((kauth_cred_t )0)cr_gidcr_groups[0]XUCRED_VERSIONCRF_MAC_ENFORCECRF_NOMEMBERD_KAUTH_CRED_T_SYS_UCRED_H_/* !_SYS_UCRED_H_ *//* filesystem credential *//* no credential available *//* advisory group list *//* number of advisory groups *//* effective user id *//* structure layout version *//*
 * This is the external representation of struct ucred.
 *//* also forces credential cache miss *//* force entry through MAC Framework *//* memberd opt out by setgroups() *//*
 * Credential flags that can be set on a credential
 *//* !_KAUTH_CRED_T *//*
 * NOTICE: This file was modified by SPARTA, Inc. in 2005 to introduce
 * support for mandatory and extensible security protections.  This notice
 * is included in support of clause 2.2 (b) of the Apple Public License,
 * Version 2.0.
 *//*
 * Copyright (c) 1989, 1993
 *	The Regents of the University of California.  All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *	This product includes software developed by the University of
 *	California, Berkeley and its contributors.
 * 4. Neither the name of the University nor the names of its contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 *
 *	@(#)ucred.h	8.4 (Berkeley) 1/9/95
 *//*
 * Copyright (c) 2000-2004 Apple Computer, Inc. All rights reserved.
 *
 * @APPLE_OSREFERENCE_LICENSE_HEADER_START@
 *
 * This file contains Original Code and/or Modifications of Original Code
 * as defined in and that are subject to the Apple Public Source License
 * Version 2.0 (the 'License'). You may not use this file except in
 * compliance with the License. The rights granted to you under the License
 * may not be used to create, or enable the creation or redistribution of,
 * unlawful or unlicensed copies of an Apple operating system, or to
 * circumvent, violate, or enable the circumvention or violation of, any
 * terms of an Apple operating system software license agreement.
 *
 * Please obtain a copy of the License at
 * http://www.opensource.apple.com/apsl/ and read it before using this file.
 *
 * The Original Code and all software distributed under the License are
 * distributed on an 'AS IS' basis, WITHOUT WARRANTY OF ANY KIND, EITHER
 * EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES,
 * INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE, QUIET ENJOYMENT OR NON-INFRINGEMENT.
 * Please see the License for the specific language governing rights and
 * limitations under the License.
 *
 * @APPLE_OSREFERENCE_LICENSE_HEADER_END@
 *//Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX.sdk/usr/include/sys/_types/_timeval64.htimeval64 &const timeval64const timeval64 &timeval64_STRUCT_TIMEVAL64/* _STRUCT_TIMEVAL32 *//* __int64_t *//*
 * Copyright (c) 2015 Apple Inc. All rights reserved.
 *
 * @APPLE_OSREFERENCE_LICENSE_HEADER_START@
 *
 * This file contains Original Code and/or Modifications of Original Code
 * as defined in and that are subject to the Apple Public Source License
 * Version 2.0 (the 'License'). You may not use this file except in
 * compliance with the License. The rights granted to you under the License
 * may not be used to create, or enable the creation or redistribution of,
 * unlawful or unlicensed copies of an Apple operating system, or to
 * circumvent, violate, or enable the circumvention or violation of, any
 * terms of an Apple operating system software license agreement.
 *
 * Please obtain a copy of the License at
 * http://www.opensource.apple.com/apsl/ and read it before using this file.
 *
 * The Original Code and all software distributed under the License are
 * distributed on an 'AS IS' basis, WITHOUT WARRANTY OF ANY KIND, EITHER
 * EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES,
 * INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE, QUIET ENJOYMENT OR NON-INFRINGEMENT.
 * Please see the License for the specific language governing rights and
 * limitations under the License.
 *
 * @APPLE_OSREFERENCE_LICENSE_HEADER_END@
 *//Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX.sdk/usr/include/sys/time.h<sys/_types/_timeval64.h>utimesconst timeval *setitimerconst itimervalconst itimerval *itimerval *gettimeofdaygetitimersettimeofdayconst timezoneconst timezone *timezone *lutimesfutimesadjtimeclockinfo &const clockinfoconst clockinfo &timezone &const timezone &itimerval &const itimerval &clockinfoitimervalprofhzstathztickadjtickhztz_dsttimetz_minuteswestit_valueit_intervaltimevalcmp(l,r,cmp)timercmp(l, r, cmp)timersub(tvp,uvp,vvp)do { (vvp)->tv_sec = (tvp)->tv_sec - (uvp)->tv_sec; (vvp)->tv_usec = (tvp)->tv_usec - (uvp)->tv_usec; if ((vvp)->tv_usec < 0) { (vvp)->tv_sec--; (vvp)->tv_usec += 1000000; } } while (0)timeradd(tvp,uvp,vvp)do { (vvp)->tv_sec = (tvp)->tv_sec + (uvp)->tv_sec; (vvp)->tv_usec = (tvp)->tv_usec + (uvp)->tv_usec; if ((vvp)->tv_usec >= 1000000) { (vvp)->tv_sec++; (vvp)->tv_usec -= 1000000; } } while (0)timercmp(tvp,uvp,cmp)(((tvp)->tv_sec == (uvp)->tv_sec) ? ((tvp)->tv_usec cmp (uvp)->tv_usec) : ((tvp)->tv_sec cmp (uvp)->tv_sec))timerisset(tvp)((tvp)->tv_sec || (tvp)->tv_usec)timerclear(tvp)(tvp)->tv_sec = (tvp)->tv_usec = 0DST_CANDST_EETDST_METDST_WETDST_AUSTDST_USADST_NONETIMESPEC_TO_TIMEVAL(tv,ts){ (tv)->tv_sec = (ts)->tv_sec; (tv)->tv_usec = (ts)->tv_nsec / 1000; }TIMEVAL_TO_TIMESPEC(tv,ts){ (ts)->tv_sec = (tv)->tv_sec; (ts)->tv_nsec = (tv)->tv_usec * 1000; }ITIMER_PROFITIMER_VIRTUALITIMER_REAL_SYS_TIME_H_/* !_SYS_TIME_H_ *//* profiling clock frequency *//* statistics clock frequency *//* clock skew rate for adjtime() *//* micro-seconds per hz tick *//* clock frequency *//*
 * Getkerninfo clock information structure
 *//* freebsd *//* Operations on timevals. *//* Canada *//* Eastern European dst *//* Middle European dst *//* Western European dst *//* Australian style dst *//* USA style dst *//* not on dst *//* type of dst correction *//* minutes west of Greenwich *//*
 * Names of the interval timers, and structure
 * defining a timer setting.
 *//* current value *//* timer interval *//*
 * Structure used as a parameter by getitimer(2) and setitimer(2) system
 * calls.
 *//*
 * [XSI] The fd_set type shall be defined as described in <sys/select.h>.
 * The timespec structure shall be defined as described in <time.h>
 *//*
 * Copyright (c) 1982, 1986, 1993
 *	The Regents of the University of California.  All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *	This product includes software developed by the University of
 *	California, Berkeley and its contributors.
 * 4. Neither the name of the University nor the names of its contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 *
 *	@(#)time.h	8.2 (Berkeley) 7/10/94
 *//Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX.sdk/usr/include/sys/_types/_fsobj_id_t.hfsobj_id &const fsobj_idconst fsobj_id &fsobj_id_tfsobj_idfid_generationfid_objno_FSOBJ_ID_T/* _FSOBJ_ID_T *//* u_int32_t *//Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX.sdk/usr/include/sys/attr.h<sys/_types/_fsobj_id_t.h><sys/time.h><sys/ucred.h>searchstate &const searchstateconst searchstate &fssearchblock &const fssearchblockconst fssearchblock &vol_attributes_attr &const vol_attributes_attrconst vol_attributes_attr &vol_capabilities_attr &const vol_capabilities_attrconst vol_capabilities_attr &diskextent &const diskextentconst diskextent &attrreference &const attrreferenceconst attrreference &attribute_set &const attribute_setconst attribute_set &attrlist &const attrlistconst attrlist &packedvol_attributes_attr_tvol_attributes_attrvol_capabilities_attr_tvol_capabilities_attrvol_capabilities_set_tdiskextent[8]extentrecorddiskextentattrreference_tattrreferenceattribute_set_tattribute_setattrlistattrgroup_tfsvolid_tfsfile_type_tfsobj_tag_tfsobj_type_ttext_encoding_tu_char[548]unsigned char[548]ss_fsstatess_union_layerss_union_flagssearchattrssizeofsearchparams2searchparams2sizeofsearchparams1searchparams1timelimitmaxmatchesreturnbuffersizereturnbufferattrlist *returnattrsnativeattrvalidattrcapabilitiesblockcountstartblockattr_lengthattr_dataoffsetforkattrfileattrdirattrvolattrcommonattrbitmapcountFST_EOFSRCHFS_VALIDOPTIONSMASK0x800000FFSRCHFS_NEGATEPARAMSSRCHFS_SKIPINAPPROPRIATESRCHFS_SKIPPACKAGESSRCHFS_SKIPINVISIBLESRCHFS_SKIPLINKSSRCHFS_MATCHFILESSRCHFS_MATCHDIRSSRCHFS_MATCHPARTIALNAMESSRCHFS_STARTATTR_BULK_REQUIRED(ATTR_CMN_NAME | ATTR_CMN_RETURNED_ATTRS)ATTR_FILE_RSRCEXTENTS0x00004000ATTR_FILE_DATAEXTENTSATTR_FILE_FILETYPEATTR_FILE_CLUMPSIZEATTR_CMN_NAMEDATTRLISTATTR_CMN_NAMEDATTRCOUNTATTR_FORK_SETMASKATTR_FORK_VALIDMASK0x00000003ATTR_FORK_RESERVEDATTR_FORK_ALLOCSIZEATTR_FORK_TOTALSIZEATTR_CMNEXT_SETMASKATTR_CMNEXT_VALIDMASK0x000007fcATTR_CMNEXT_RECURSIVE_GENCOUNTATTR_CMNEXT_EXT_FLAGSATTR_CMNEXT_CLONEIDATTR_CMNEXT_REALFSIDATTR_CMNEXT_REALDEVIDATTR_CMNEXT_NOFIRMLINKPATHATTR_CMNEXT_LINKIDATTR_CMNEXT_PRIVATESIZEATTR_CMNEXT_RELPATHATTR_FILE_SETMASKATTR_FILE_VALIDMASK0x000037FFATTR_FILE_RSRCALLOCSIZE0x00002000ATTR_FILE_RSRCLENGTH0x00001000ATTR_FILE_DATAALLOCSIZEATTR_FILE_DATALENGTHATTR_FILE_FORKLISTATTR_FILE_FORKCOUNTATTR_FILE_DEVTYPEATTR_FILE_IOBLOCKSIZEATTR_FILE_ALLOCSIZEATTR_FILE_TOTALSIZEATTR_FILE_LINKCOUNTATTR_DIR_SETMASKATTR_DIR_VALIDMASK0x0000003fDIR_MNTSTATUS_TRIGGERDIR_MNTSTATUS_MNTPOINTATTR_DIR_DATALENGTHATTR_DIR_IOBLOCKSIZEATTR_DIR_ALLOCSIZEATTR_DIR_MOUNTSTATUSATTR_DIR_ENTRYCOUNTATTR_DIR_LINKCOUNTATTR_VOL_SETMASK0x80002000ATTR_VOL_VALIDMASK0xF087FFFFATTR_VOL_INFOATTR_VOL_ATTRIBUTESATTR_VOL_RESERVED_SIZEATTR_VOL_QUOTA_SIZEATTR_VOL_SPACEUSEDATTR_VOL_UUIDATTR_VOL_CAPABILITIESATTR_VOL_ENCODINGSUSEDATTR_VOL_MOUNTEDDEVICEATTR_VOL_MOUNTFLAGSATTR_VOL_NAMEATTR_VOL_MOUNTPOINTATTR_VOL_MAXOBJCOUNTATTR_VOL_DIRCOUNTATTR_VOL_FILECOUNTATTR_VOL_OBJCOUNTATTR_VOL_IOBLOCKSIZEATTR_VOL_ALLOCATIONCLUMPATTR_VOL_MINALLOCATIONATTR_VOL_SPACEAVAILATTR_VOL_SPACEFREEATTR_VOL_SIZEATTR_VOL_SIGNATUREATTR_VOL_FSTYPEATTR_CMN_VOLSETMASK0x00006700ATTR_CMN_SETMASK0x51C7FF00ATTR_CMN_VALIDMASKATTR_CMN_RETURNED_ATTRSATTR_CMN_DATA_PROTECT_FLAGSATTR_CMN_ERRORATTR_CMN_ADDEDTIMEATTR_CMN_FULLPATH0x08000000ATTR_CMN_PARENTID0x04000000ATTR_CMN_FILEID0x02000000ATTR_CMN_GRPUUIDATTR_CMN_UUIDATTR_CMN_EXTENDED_SECURITY0x00400000ATTR_CMN_USERACCESSATTR_CMN_DOCUMENT_IDATTR_CMN_GEN_COUNTATTR_CMN_FLAGSATTR_CMN_ACCESSMASKATTR_CMN_GRPIDATTR_CMN_OWNERIDATTR_CMN_FNDRINFOATTR_CMN_BKUPTIMEATTR_CMN_ACCTIMEATTR_CMN_CHGTIMEATTR_CMN_MODTIMEATTR_CMN_CRTIMEATTR_CMN_SCRIPTATTR_CMN_PAROBJIDATTR_CMN_OBJPERMANENTIDATTR_CMN_OBJIDATTR_CMN_OBJTAGATTR_CMN_OBJTYPEATTR_CMN_FSIDATTR_CMN_DEVIDATTR_CMN_NAMEVOL_CAP_INT_RENAME_OPENFAILVOL_CAP_INT_RENAME_EXCLVOL_CAP_INT_RENAME_SWAPVOL_CAP_INT_SNAPSHOTVOL_CAP_INT_CLONEVOL_CAP_INT_EXTENDED_ATTRVOL_CAP_INT_NAMEDSTREAMSVOL_CAP_INT_MANLOCKVOL_CAP_INT_USERACCESSVOL_CAP_INT_EXTENDED_SECURITYVOL_CAP_INT_FLOCKVOL_CAP_INT_ADVLOCKVOL_CAP_INT_VOL_RENAMEVOL_CAP_INT_ALLOCATEVOL_CAP_INT_COPYFILEVOL_CAP_INT_EXCHANGEDATAVOL_CAP_INT_READDIRATTRVOL_CAP_INT_NFSEXPORTVOL_CAP_INT_ATTRLISTVOL_CAP_INT_SEARCHFSVOL_CAP_FMT_SEALEDVOL_CAP_FMT_VOL_GROUPSVOL_CAP_FMT_SHARED_SPACEVOL_CAP_FMT_NO_PERMISSIONSVOL_CAP_FMT_NO_IMMUTABLE_FILESVOL_CAP_FMT_WRITE_GENERATION_COUNTVOL_CAP_FMT_DOCUMENT_IDVOL_CAP_FMT_DIR_HARDLINKSVOL_CAP_FMT_64BIT_OBJECT_IDSVOL_CAP_FMT_DECMPFS_COMPRESSIONVOL_CAP_FMT_NO_VOLUME_SIZESVOL_CAP_FMT_PATH_FROM_IDVOL_CAP_FMT_HIDDEN_FILESVOL_CAP_FMT_OPENDENYMODESVOL_CAP_FMT_2TB_FILESIZEVOL_CAP_FMT_FAST_STATFSVOL_CAP_FMT_CASE_PRESERVINGVOL_CAP_FMT_CASE_SENSITIVEVOL_CAP_FMT_ZERO_RUNSVOL_CAP_FMT_SPARSE_FILESVOL_CAP_FMT_NO_ROOT_TIMESVOL_CAP_FMT_JOURNAL_ACTIVEVOL_CAP_FMT_JOURNALVOL_CAP_FMT_HARDLINKSVOL_CAP_FMT_SYMBOLICLINKSVOL_CAP_FMT_PERSISTENTOBJECTIDSATTR_MAX_BUFFERVOL_CAPABILITIES_RESERVED2VOL_CAPABILITIES_RESERVED1VOL_CAPABILITIES_INTERFACESVOL_CAPABILITIES_FORMATATTRIBUTE_SET_INIT(a)do {(a)->commonattr = (a)->volattr = (a)->dirattr = (a)->fileattr = (a)->forkattr = 0; } while(0)ATTR_BIT_MAP_COUNTSEARCHFS_MAX_SEARCHPARMSFSOPT_NOFOLLOW_ANYFSOPT_RETURN_REALDEVFSOPT_ATTR_CMN_EXTENDEDFSOPT_PACK_INVAL_ATTRSFSOPT_REPORT_FULLSIZEFSOPT_NOINMEMUPDATEFSOPT_NOFOLLOW_SYS_ATTR_H_/* !_SYS_ATTR_H_ *//* end-of-file offset */// fs private// 0 = top// for SRCHFS_START/*
 * Searchfs
 *//* Required attributes for getattrlistbulk(2) *//* obsolete, HFS-specific *//* always zero *//* Obsolete, implemented, not supported *//* Deprecated fork attributes *//* CMNEXT attributes extend the common attributes, but in the forkattr field *//*
 * Settable ATTR_FILE_* attributes include:
 * ATTR_FILE_DEVTYPE
 *//* ATTR_DIR_MOUNTSTATUS Flags: *//* File/directory attributes: *//*
 * The list of settable ATTR_VOL_* attributes include the following:
 * ATTR_VOL_NAME
 * ATTR_VOL_INFO
 *//*
 * The settable ATTR_CMN_* attributes include the following:
 * ATTR_CMN_SCRIPT
 * ATTR_CMN_CRTIME
 * ATTR_CMN_MODTIME
 * ATTR_CMN_CHGTIME
 *
 * ATTR_CMN_ACCTIME
 * ATTR_CMN_BKUPTIME
 * ATTR_CMN_FNDRINFO
 * ATTR_CMN_OWNERID
 *
 * ATTR_CMN_GRPID
 * ATTR_CMN_ACCESSMASK
 * ATTR_CMN_FLAGS
 *
 * ATTR_CMN_EXTENDED_SECURITY
 * ATTR_CMN_UUID
 *
 * ATTR_CMN_GRPUUID
 *
 * ATTR_CMN_DATA_PROTECT_FLAGS
 *//*
 * ATTR_CMN_RETURNED_ATTRS is only valid with getattrlist(2) and
 * getattrlistbulk(2). It is always the first attribute in the return buffer.
 *//* option flag.                                                 *//* They can only be used with the  FSOPT_ATTR_CMN_EXTENDED	*//*	#define ATTR_CMN_DOCUMENT_ID		0x00100000	*//*	#define ATTR_CMN_GEN_COUNT		0x00080000	*//* These bits have been salvaged for use as:			*//*      #define ATTR_CMN_NAMEDATTRLIST		0x00100000	*//*      #define ATTR_CMN_NAMEDATTRCOUNT		0x00080000	*//* The following were defined as:				*//*
 * VOL_CAP_INT_SEARCHFS: When set, the volume implements the
 * searchfs() system call (the vnop_searchfs vnode operation).
 *
 * VOL_CAP_INT_ATTRLIST: When set, the volume implements the
 * getattrlist() and setattrlist() system calls (vnop_getattrlist
 * and vnop_setattrlist vnode operations) for the volume, files,
 * and directories.  The volume may or may not implement the
 * readdirattr() system call.  XXX Is there any minimum set
 * of attributes that should be supported?  To determine the
 * set of supported attributes, get the ATTR_VOL_ATTRIBUTES
 * attribute of the volume.
 *
 * VOL_CAP_INT_NFSEXPORT: When set, the volume implements exporting
 * of NFS volumes.
 *
 * VOL_CAP_INT_READDIRATTR: When set, the volume implements the
 * readdirattr() system call (vnop_readdirattr vnode operation).
 *
 * VOL_CAP_INT_EXCHANGEDATA: When set, the volume implements the
 * exchangedata() system call (VNOP_EXCHANGE vnode operation).
 *
 * VOL_CAP_INT_COPYFILE: When set, the volume implements the
 * VOP_COPYFILE vnode operation.  (XXX There should be a copyfile()
 * system call in <unistd.h>.)
 *
 * VOL_CAP_INT_ALLOCATE: When set, the volume implements the
 * VNOP_ALLOCATE vnode operation, which means it implements the
 * F_PREALLOCATE selector of fcntl(2).
 *
 * VOL_CAP_INT_VOL_RENAME: When set, the volume implements the
 * ATTR_VOL_NAME attribute for both getattrlist() and setattrlist().
 * The volume can be renamed by setting ATTR_VOL_NAME with setattrlist().
 *
 * VOL_CAP_INT_ADVLOCK: When set, the volume implements POSIX style
 * byte range locks via vnop_advlock (accessible from fcntl(2)).
 *
 * VOL_CAP_INT_FLOCK: When set, the volume implements whole-file flock(2)
 * style locks via vnop_advlock.  This includes the O_EXLOCK and O_SHLOCK
 * flags of the open(2) call.
 *
 * VOL_CAP_INT_EXTENDED_SECURITY: When set, the volume implements
 * extended security (ACLs).
 *
 * VOL_CAP_INT_USERACCESS:  When set, the volume supports the
 * ATTR_CMN_USERACCESS attribute (used to get the user's access
 * mode to the file).
 *
 * VOL_CAP_INT_MANLOCK: When set, the volume supports AFP-style
 * mandatory byte range locks via an ioctl().
 *
 * VOL_CAP_INT_EXTENDED_ATTR: When set, the volume implements
 * native extended attribues.
 *
 * VOL_CAP_INT_NAMEDSTREAMS: When set, the volume supports
 * native named streams.
 *
 * VOL_CAP_INT_CLONE: When set, the volume supports clones.
 *
 * VOL_CAP_INT_SNAPSHOT: When set, the volume supports snapshots.
 *
 * VOL_CAP_INT_RENAME_SWAP: When set, the volume supports swapping
 * file system objects.
 *
 * VOL_CAP_INT_RENAME_EXCL: When set, the volume supports an
 * exclusive rename operation.
 *
 * VOL_CAP_INT_RENAME_OPENFAIL: When set, the volume may fail rename
 * operations on files that are open.
 *//*
 * VOL_CAP_FMT_PERSISTENTOBJECTIDS: When set, the volume has object IDs
 * that are persistent (retain their values even when the volume is
 * unmounted and remounted), and a file or directory can be looked up
 * by ID.  Volumes that support VolFS and can support Carbon File ID
 * references should set this bit.
 *
 * VOL_CAP_FMT_SYMBOLICLINKS: When set, the volume supports symbolic
 * links.  The symlink(), readlink(), and lstat() calls all use this
 * symbolic link.
 *
 * VOL_CAP_FMT_HARDLINKS: When set, the volume supports hard links.
 * The link() call creates hard links.
 *
 * VOL_CAP_FMT_JOURNAL: When set, the volume is capable of supporting
 * a journal used to speed recovery in case of unplanned shutdown
 * (such as a power outage or crash).  This bit does not necessarily
 * mean the volume is actively using a journal for recovery.
 *
 * VOL_CAP_FMT_JOURNAL_ACTIVE: When set, the volume is currently using
 * a journal for use in speeding recovery after an unplanned shutdown.
 * This bit can be set only if VOL_CAP_FMT_JOURNAL is also set.
 *
 * VOL_CAP_FMT_NO_ROOT_TIMES: When set, the volume format does not
 * store reliable times for the root directory, so you should not
 * depend on them to detect changes, etc.
 *
 * VOL_CAP_FMT_SPARSE_FILES: When set, the volume supports sparse files.
 * That is, files which can have "holes" that have never been written
 * to, and are not allocated on disk.  Sparse files may have an
 * allocated size that is less than the file's logical length.
 *
 * VOL_CAP_FMT_ZERO_RUNS: For security reasons, parts of a file (runs)
 * that have never been written to must appear to contain zeroes.  When
 * this bit is set, the volume keeps track of allocated but unwritten
 * runs of a file so that it can substitute zeroes without actually
 * writing zeroes to the media.  This provides performance similar to
 * sparse files, but not the space savings.
 *
 * VOL_CAP_FMT_CASE_SENSITIVE: When set, file and directory names are
 * case sensitive (upper and lower case are different).  When clear,
 * an upper case character is equivalent to a lower case character,
 * and you can't have two names that differ solely in the case of
 * the characters.
 *
 * VOL_CAP_FMT_CASE_PRESERVING: When set, file and directory names
 * preserve the difference between upper and lower case.  If clear,
 * the volume may change the case of some characters (typically
 * making them all upper or all lower case).  A volume that sets
 * VOL_CAP_FMT_CASE_SENSITIVE should also set VOL_CAP_FMT_CASE_PRESERVING.
 *
 * VOL_CAP_FMT_FAST_STATFS: This bit is used as a hint to upper layers
 * (especially Carbon) that statfs() is fast enough that its results
 * need not be cached by those upper layers.  A volume that caches
 * the statfs information in its in-memory structures should set this bit.
 * A volume that must always read from disk or always perform a network
 * transaction should not set this bit.
 *
 * VOL_CAP_FMT_2TB_FILESIZE: If this bit is set the volume format supports
 * file sizes larger than 4GB, and potentially up to 2TB; it does not
 * indicate whether the filesystem supports files larger than that.
 *
 * VOL_CAP_FMT_OPENDENYMODES: When set, the volume supports open deny
 * modes (e.g. "open for read write, deny write"; effectively, mandatory
 * file locking based on open modes).
 *
 * VOL_CAP_FMT_HIDDEN_FILES: When set, the volume supports the UF_HIDDEN
 * file flag, and the UF_HIDDEN flag is mapped to that volume's native
 * "hidden" or "invisible" bit (which may be the invisible bit from the
 * Finder Info extended attribute).
 *
 * VOL_CAP_FMT_PATH_FROM_ID:  When set, the volume supports the ability
 * to derive a pathname to the root of the file system given only the
 * id of an object.  This also implies that object ids on this file
 * system are persistent and not recycled.  This is a very specialized
 * capability and it is assumed that most file systems will not support
 * it.  Its use is for legacy non-posix APIs like ResolveFileIDRef.
 *
 * VOL_CAP_FMT_NO_VOLUME_SIZES: When set, the volume does not support
 * returning values for total data blocks, available blocks, or free blocks
 * (as in f_blocks, f_bavail, or f_bfree in "struct statfs").  Historically,
 * those values were set to 0xFFFFFFFF for volumes that did not support them.
 *
 * VOL_CAP_FMT_DECMPFS_COMPRESSION: When set, the volume supports transparent
 * decompression of compressed files using decmpfs.
 *
 * VOL_CAP_FMT_64BIT_OBJECT_IDS: When set, the volume uses object IDs that
 * are 64-bit. This means that ATTR_CMN_FILEID and ATTR_CMN_PARENTID are the
 * only legitimate attributes for obtaining object IDs from this volume and the
 * 32-bit fid_objno fields of the fsobj_id_t returned by ATTR_CMN_OBJID,
 * ATTR_CMN_OBJPERMID, and ATTR_CMN_PAROBJID are undefined.
 *
 * VOL_CAP_FMT_DIR_HARDLINKS: When set, the volume supports directory
 * hard links.
 *
 * VOL_CAP_FMT_DOCUMENT_ID: When set, the volume supports document IDs
 * (an ID which persists across object ID changes) for document revisions.
 *
 * VOL_CAP_FMT_WRITE_GENERATION_COUNT: When set, the volume supports write
 * generation counts (a count of how many times an object has been modified)
 *
 * VOL_CAP_FMT_NO_IMMUTABLE_FILES: When set, the volume does not support
 * setting the UF_IMMUTABLE flag.
 *
 * VOL_CAP_FMT_NO_PERMISSIONS: When set, the volume does not support setting
 * permissions.
 *
 * VOL_CAP_FMT_SHARED_SPACE: When set, the volume supports sharing space with
 * other filesystems i.e. multiple logical filesystems can exist in the same
 * "partition". An implication of this is that the filesystem which sets
 * this capability treats waitfor arguments to VFS_SYNC as bit flags.
 *
 * VOL_CAP_FMT_VOL_GROUPS: When set, this volume is part of a volume-group
 * that implies multiple volumes must be mounted in order to boot and root the
 * operating system. Typically, this means a read-only system volume and a
 * writable data volume.
 *
 * VOL_CAP_FMT_SEALED: When set, this volume is cryptographically sealed.
 * Any modifications to volume data or metadata will be detected and may
 * render the volume unusable.
 *//*
 * XXX this value needs to be raised - 3893388
 *//* number of blocks allocated *//* first block allocated *//* XXX PPD This is derived from HFSVolumePriv.h and should perhaps be referenced from there? *//* fork attribute group *//* file attribute group *//* directory attribute group *//* Volume attribute group *//* common attribute group *//* (to maintain 4-byte alignment) *//* number of attr. bit sets in list (should be 5) *//* file object id type *//* we currently aren't anywhere near this amount for a valid
 * fssearchblock.sizeofsearchparams1 or fssearchblock.sizeofsearchparams2
 * but we put a sanity check in to avoid abuse of the value passed in from
 * user land.
 *//* The following option only valid when requesting ATTR_CMN_RETURNED_ATTRS *//*
 * attr.h - attribute data structures and interfaces
 *
 * Copyright (c) 1998, Apple Computer, Inc.  All Rights Reserved.
 *//*
 * Copyright (c) 2000-2018 Apple Computer, Inc. All rights reserved.
 *
 * @APPLE_OSREFERENCE_LICENSE_HEADER_START@
 *
 * This file contains Original Code and/or Modifications of Original Code
 * as defined in and that are subject to the Apple Public Source License
 * Version 2.0 (the 'License'). You may not use this file except in
 * compliance with the License. The rights granted to you under the License
 * may not be used to create, or enable the creation or redistribution of,
 * unlawful or unlicensed copies of an Apple operating system, or to
 * circumvent, violate, or enable the circumvention or violation of, any
 * terms of an Apple operating system software license agreement.
 *
 * Please obtain a copy of the License at
 * http://www.opensource.apple.com/apsl/ and read it before using this file.
 *
 * The Original Code and all software distributed under the License are
 * distributed on an 'AS IS' basis, WITHOUT WARRANTY OF ANY KIND, EITHER
 * EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES,
 * INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE, QUIET ENJOYMENT OR NON-INFRINGEMENT.
 * Please see the License for the specific language governing rights and
 * limitations under the License.
 *
 * @APPLE_OSREFERENCE_LICENSE_HEADER_END@
 *//Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX.sdk/usr/include/os/base.hos_block_tos_function_tOS_NOT_TAIL_CALLEDos_compiler_barrier()os_is_compile_time_constant(expr)__builtin_constant_p(expr)os_prevent_tail_call_optimization()__asm__("")OS_CONCAT(x,y)__OS_CONCAT(x, y)__OS_CONCAT(x,y)OS_STRINGIFY(s)__OS_STRINGIFY(s)#sOS_SWIFT_NAME(_name)OS_REFINED_FOR_SWIFTOS_SWIFT_UNAVAILABLE(_msg)OS_CLOSED_OPTIONS(_name,_type,__VA_ARGS__...)__OS_ENUM_C_FALLBACK(_name, _type, ## __VA_ARGS__) __OS_ENUM_ATTR_CLOSED __OS_OPTIONS_ATTROS_OPTIONS(_name,_type,__VA_ARGS__...)__OS_ENUM_C_FALLBACK(_name, _type, ## __VA_ARGS__) __OS_ENUM_ATTR __OS_OPTIONS_ATTROS_CLOSED_ENUM(_name,_type,__VA_ARGS__...)__OS_ENUM_C_FALLBACK(_name, _type, ## __VA_ARGS__) __OS_ENUM_ATTR_CLOSEDOS_ENUM(_name,_type,__VA_ARGS__...)typedef _type _name ## _t; enum { __VA_ARGS__ }__OS_ENUM_C_FALLBACK(_name,_type,__VA_ARGS__...)typedef _type _name ## _t; enum _name { __VA_ARGS__ }__OS_OPTIONS_ATTR__OS_ENUM_ATTR_CLOSED__OS_ENUM_ATTROS_ANALYZER_SUPPRESS(RADAR)OS_OVERLOADABLEOS_COMPILER_CAN_ASSUME(expr)__builtin_assume(expr)OS_ASSUME_NONNULL_ENDOS_ASSUME_NONNULL_BEGINOS_FALLTHROUGHOS_NOESCAPEOS_EXPECT(x,v)__builtin_expect((x), (v))OS_INLINEstatic __inline__OS_EXPORTextern __attribute__((__visibility__("default")))OS_FORMAT_PRINTF(x,y)__attribute__((__format__(printf,x,y)))OS_ALIGNED(n)__attribute__((__aligned__((n))))OS_TRANSPARENT_UNION__attribute__((__transparent_union__))OS_ALWAYS_INLINE__attribute__((__always_inline__))OS_NOINLINE__attribute__((__noinline__))OS_WEAK_IMPORT__attribute__((__weak_import__))OS_WEAKOS_COLDOS_UNUSEDOS_USEDOS_MALLOCOS_WARN_RESULTOS_CONSTOS_PUREOS_SENTINEL__attribute__((__sentinel__))OS_NONNULL_ALL__attribute__((__nonnull__))OS_NONNULL15__attribute__((__nonnull__(15)))OS_NONNULL14__attribute__((__nonnull__(14)))OS_NONNULL13__attribute__((__nonnull__(13)))OS_NONNULL12__attribute__((__nonnull__(12)))OS_NONNULL11__attribute__((__nonnull__(11)))OS_NONNULL10__attribute__((__nonnull__(10)))OS_NONNULL9__attribute__((__nonnull__(9)))OS_NONNULL8__attribute__((__nonnull__(8)))OS_NONNULL7__attribute__((__nonnull__(7)))OS_NONNULL6__attribute__((__nonnull__(6)))OS_NONNULL5__attribute__((__nonnull__(5)))OS_NONNULL4__attribute__((__nonnull__(4)))OS_NONNULL3__attribute__((__nonnull__(3)))OS_NONNULL2__attribute__((__nonnull__(2)))OS_NONNULL1__attribute__((__nonnull__(1)))OS_NOTHROW__attribute__((__nothrow__))OS_NORETURN__OS_BASE__defined(__cplusplus) && defined(__clang__)__has_attribute(fallthrough)__has_builtin(__builtin_assume)__has_extension(attribute_overloadable)__has_attribute(analyzer_suppress)__has_attribute(swift_private)__has_attribute(swift_name)// __OS_BASE__/*!
 * @typedef os_block_t
 *
 * @abstract
 * Generic type for a block taking no arguments and returning no value.
 *
 * @discussion
 * When not building with Objective-C ARC, a block object allocated on or
 * copied to the heap must be released with a -[release] message or the
 * Block_release() function.
 *
 * The declaration of a block literal allocates storage on the stack.
 * Therefore, this is an invalid construct:
 * <code>
 * os_block_t block;
 * if (x) {
 *     block = ^{ printf("true\n"); };
 * } else {
 *     block = ^{ printf("false\n"); };
 * }
 * block(); // unsafe!!!
 * </code>
 *
 * What is happening behind the scenes:
 * <code>
 * if (x) {
 *     struct Block __tmp_1 = ...; // setup details
 *     block = &__tmp_1;
 * } else {
 *     struct Block __tmp_2 = ...; // setup details
 *     block = &__tmp_2;
 * }
 * </code>
 *
 * As the example demonstrates, the address of a stack variable is escaping the
 * scope in which it is allocated. That is a classic C bug.
 *
 * Instead, the block literal must be copied to the heap with the Block_copy()
 * function or by sending it a -[copy] message.
 */// equivalent to __SWIFT_UNAVAILABLE from Availability.h// __has_feature(objc_fixed_enum) || __has_extension(cxx_strong_enums)/*!
 * There is unfortunately no good way in plain C to have both fixed-type enums
 * and enforcement for clang's enum_extensibility extensions. The primary goal
 * of these macros is to allow you to define an enum and specify its width in a
 * single statement, and for plain C that is accomplished by defining an
 * anonymous enum and then separately typedef'ing the requested type name to the
 * requested underlying integer type. So the type emitted actually has no
 * relationship at all to the enum, and therefore while the compiler could
 * enforce enum extensibility if you used the enum type, it cannot do so if you
 * use the "_t" type resulting from this expression.
 *
 * But we still define a named enum type and decorate it appropriately for you,
 * so if you really want the enum extensibility enforcement, you can use the
 * enum type yourself, i.e. when compiling with a C compiler:
 *
 *     OS_CLOSED_ENUM(my_type, uint64_t,
 *         FOO,
 *         BAR,
 *         BAZ,
 *     );
 *
 *     my_type_t mt = 98; // legal
 *     enum my_type emt = 98; // illegal
 *
 * But be aware that the underlying enum type's width is subject only to the C
 * language's guarantees -- namely that it will be compatible with int, char,
 * and unsigned char. It is not safe to rely on the size of this type.
 *
 * When compiling in ObjC or C++, both of the above assignments are illegal.
 */// __has_attribute(flag_enum)/*!
 * Compile with -Wflag-enum and -Wassign-enum to enforce at definition and
 * assignment, respectively, i.e. -Wflag-enum prevents you from creating new
 * enumeration values from illegal values within the enum definition, and
 * -Wassign-enum prevents you from assigning illegal values to a variable of the
 * enum type.
 */// <sys/_types/_os_inline.h>/*
 * Copyright (c) 2008-2020 Apple Inc. All rights reserved.
 *
 * @APPLE_APACHE_LICENSE_HEADER_START@
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 * @APPLE_APACHE_LICENSE_HEADER_END@
 *//Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX.sdk/usr/include/os/Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX.sdk/usr/include/sys/queue.hCIRCLEQ_REMOVE(head,elm,field)do { CIRCLEQ_CHECK_NEXT(head, elm, field); CIRCLEQ_CHECK_PREV(head, elm, field); if ((elm)->field.cqe_next == (void *)(head)) (head)->cqh_last = (elm)->field.cqe_prev; else (elm)->field.cqe_next->field.cqe_prev = (elm)->field.cqe_prev; if ((elm)->field.cqe_prev == (void *)(head)) (head)->cqh_first = (elm)->field.cqe_next; else (elm)->field.cqe_prev->field.cqe_next = (elm)->field.cqe_next; } while (0)CIRCLEQ_PREV(elm,field)((elm)->field.cqe_prev)CIRCLEQ_NEXT(elm,field)((elm)->field.cqe_next)CIRCLEQ_LAST(head)((head)->cqh_last)CIRCLEQ_INSERT_TAIL(head,elm,field)do { (elm)->field.cqe_next = (void *)(head); (elm)->field.cqe_prev = (head)->cqh_last; if ((head)->cqh_first == (void *)(head)) (head)->cqh_first = (elm); else (head)->cqh_last->field.cqe_next = (elm); (head)->cqh_last = (elm); } while (0)CIRCLEQ_INSERT_HEAD(head,elm,field)do { CIRCLEQ_CHECK_HEAD(head, field); (elm)->field.cqe_next = (head)->cqh_first; (elm)->field.cqe_prev = (void *)(head); if ((head)->cqh_last == (void *)(head)) (head)->cqh_last = (elm); else (head)->cqh_first->field.cqe_prev = (elm); (head)->cqh_first = (elm); } while (0)CIRCLEQ_INSERT_BEFORE(head,listelm,elm,field)do { CIRCLEQ_CHECK_PREV(head, listelm, field); (elm)->field.cqe_next = (listelm); (elm)->field.cqe_prev = (listelm)->field.cqe_prev; if ((listelm)->field.cqe_prev == (void *)(head)) (head)->cqh_first = (elm); else (listelm)->field.cqe_prev->field.cqe_next = (elm); (listelm)->field.cqe_prev = (elm); } while (0)CIRCLEQ_INSERT_AFTER(head,listelm,elm,field)do { CIRCLEQ_CHECK_NEXT(head, listelm, field); (elm)->field.cqe_next = (listelm)->field.cqe_next; (elm)->field.cqe_prev = (listelm); if ((listelm)->field.cqe_next == (void *)(head)) (head)->cqh_last = (elm); else (listelm)->field.cqe_next->field.cqe_prev = (elm); (listelm)->field.cqe_next = (elm); } while (0)CIRCLEQ_INIT(head)do { (head)->cqh_first = (void *)(head); (head)->cqh_last = (void *)(head); } while (0)CIRCLEQ_FOREACH(var,head,field)for((var) = (head)->cqh_first; (var) != (void *)(head); (var) = (var)->field.cqe_next)CIRCLEQ_FIRST(head)((head)->cqh_first)CIRCLEQ_EMPTY(head)((head)->cqh_first == (void *)(head))CIRCLEQ_CHECK_PREV(head,elm,field)CIRCLEQ_CHECK_NEXT(head,elm,field)CIRCLEQ_CHECK_HEAD(head,field)CIRCLEQ_ENTRY(type)__MISMATCH_TAGS_PUSH __NULLABILITY_COMPLETENESS_PUSH struct { struct type *cqe_next; struct type *cqe_prev; } __NULLABILITY_COMPLETENESS_POP __MISMATCH_TAGS_POPCIRCLEQ_HEAD(name,type)__MISMATCH_TAGS_PUSH __NULLABILITY_COMPLETENESS_PUSH struct name { struct type *cqh_first; struct type *cqh_last; } __NULLABILITY_COMPLETENESS_POP __MISMATCH_TAGS_POPTAILQ_SWAP(head1,head2,type,field)__MISMATCH_TAGS_PUSH __NULLABILITY_COMPLETENESS_PUSH do { struct type *swap_first = (head1)->tqh_first; struct type **swap_last = (head1)->tqh_last; (head1)->tqh_first = (head2)->tqh_first; (head1)->tqh_last = (head2)->tqh_last; (head2)->tqh_first = swap_first; (head2)->tqh_last = swap_last; if ((swap_first = (head1)->tqh_first) != NULL) swap_first->field.tqe_prev = &(head1)->tqh_first; else (head1)->tqh_last = &(head1)->tqh_first; if ((swap_first = (head2)->tqh_first) != NULL) swap_first->field.tqe_prev = &(head2)->tqh_first; else (head2)->tqh_last = &(head2)->tqh_first; } while (0) __NULLABILITY_COMPLETENESS_POP __MISMATCH_TAGS_POPTAILQ_REMOVE(head,elm,field)do { TAILQ_CHECK_NEXT(elm, field); TAILQ_CHECK_PREV(elm, field); if ((TAILQ_NEXT((elm), field)) != NULL) TAILQ_NEXT((elm), field)->field.tqe_prev = (elm)->field.tqe_prev; else { (head)->tqh_last = (elm)->field.tqe_prev; QMD_TRACE_HEAD(head); } *(elm)->field.tqe_prev = TAILQ_NEXT((elm), field); TRASHIT((elm)->field.tqe_next); TRASHIT((elm)->field.tqe_prev); QMD_TRACE_ELEM(&(elm)->field); } while (0)TAILQ_PREV(elm,headname,field)__MISMATCH_TAGS_PUSH __NULLABILITY_COMPLETENESS_PUSH (*(((struct headname *)((elm)->field.tqe_prev))->tqh_last)) __NULLABILITY_COMPLETENESS_POP __MISMATCH_TAGS_POPTAILQ_NEXT(elm,field)((elm)->field.tqe_next)TAILQ_LAST(head,headname)__MISMATCH_TAGS_PUSH __NULLABILITY_COMPLETENESS_PUSH (*(((struct headname *)((head)->tqh_last))->tqh_last)) __NULLABILITY_COMPLETENESS_POP __MISMATCH_TAGS_POPTAILQ_INSERT_TAIL(head,elm,field)do { TAILQ_NEXT((elm), field) = NULL; (elm)->field.tqe_prev = (head)->tqh_last; *(head)->tqh_last = (elm); (head)->tqh_last = &TAILQ_NEXT((elm), field); QMD_TRACE_HEAD(head); QMD_TRACE_ELEM(&(elm)->field); } while (0)TAILQ_INSERT_HEAD(head,elm,field)do { TAILQ_CHECK_HEAD(head, field); if ((TAILQ_NEXT((elm), field) = TAILQ_FIRST((head))) != NULL) TAILQ_FIRST((head))->field.tqe_prev = &TAILQ_NEXT((elm), field); else (head)->tqh_last = &TAILQ_NEXT((elm), field); TAILQ_FIRST((head)) = (elm); (elm)->field.tqe_prev = &TAILQ_FIRST((head)); QMD_TRACE_HEAD(head); QMD_TRACE_ELEM(&(elm)->field); } while (0)TAILQ_INSERT_BEFORE(listelm,elm,field)do { TAILQ_CHECK_PREV(listelm, field); (elm)->field.tqe_prev = (listelm)->field.tqe_prev; TAILQ_NEXT((elm), field) = (listelm); *(listelm)->field.tqe_prev = (elm); (listelm)->field.tqe_prev = &TAILQ_NEXT((elm), field); QMD_TRACE_ELEM(&(elm)->field); QMD_TRACE_ELEM(&listelm->field); } while (0)TAILQ_INSERT_AFTER(head,listelm,elm,field)do { TAILQ_CHECK_NEXT(listelm, field); if ((TAILQ_NEXT((elm), field) = TAILQ_NEXT((listelm), field)) != NULL) TAILQ_NEXT((elm), field)->field.tqe_prev = &TAILQ_NEXT((elm), field); else { (head)->tqh_last = &TAILQ_NEXT((elm), field); QMD_TRACE_HEAD(head); } TAILQ_NEXT((listelm), field) = (elm); (elm)->field.tqe_prev = &TAILQ_NEXT((listelm), field); QMD_TRACE_ELEM(&(elm)->field); QMD_TRACE_ELEM(&listelm->field); } while (0)TAILQ_INIT(head)do { TAILQ_FIRST((head)) = NULL; (head)->tqh_last = &TAILQ_FIRST((head)); QMD_TRACE_HEAD(head); } while (0)TAILQ_FOREACH_REVERSE_SAFE(var,head,headname,field,tvar)for ((var) = TAILQ_LAST((head), headname); (var) && ((tvar) = TAILQ_PREV((var), headname, field), 1); (var) = (tvar))TAILQ_FOREACH_REVERSE(var,head,headname,field)for ((var) = TAILQ_LAST((head), headname); (var); (var) = TAILQ_PREV((var), headname, field))TAILQ_FOREACH_SAFE(var,head,field,tvar)for ((var) = TAILQ_FIRST((head)); (var) && ((tvar) = TAILQ_NEXT((var), field), 1); (var) = (tvar))TAILQ_FOREACH(var,head,field)for ((var) = TAILQ_FIRST((head)); (var); (var) = TAILQ_NEXT((var), field))TAILQ_FIRST(head)((head)->tqh_first)TAILQ_EMPTY(head)((head)->tqh_first == NULL)TAILQ_CONCAT(head1,head2,field)do { if (!TAILQ_EMPTY(head2)) { *(head1)->tqh_last = (head2)->tqh_first; (head2)->tqh_first->field.tqe_prev = (head1)->tqh_last; (head1)->tqh_last = (head2)->tqh_last; TAILQ_INIT((head2)); QMD_TRACE_HEAD(head1); QMD_TRACE_HEAD(head2); } } while (0)TAILQ_CHECK_PREV(elm,field)TAILQ_CHECK_NEXT(elm,field)TAILQ_CHECK_HEAD(head,field)TAILQ_ENTRY(type)__MISMATCH_TAGS_PUSH __NULLABILITY_COMPLETENESS_PUSH struct { struct type *tqe_next; struct type **tqe_prev; TRACEBUF } __NULLABILITY_COMPLETENESS_POP __MISMATCH_TAGS_POPTAILQ_HEAD_INITIALIZER(head){ NULL, &(head).tqh_first }TAILQ_HEAD(name,type)__MISMATCH_TAGS_PUSH __NULLABILITY_COMPLETENESS_PUSH struct name { struct type *tqh_first; struct type **tqh_last; TRACEBUF } __NULLABILITY_COMPLETENESS_POP __MISMATCH_TAGS_POPLIST_SWAP(head1,head2,type,field)__MISMATCH_TAGS_PUSH __NULLABILITY_COMPLETENESS_PUSH do { struct type *swap_tmp = LIST_FIRST((head1)); LIST_FIRST((head1)) = LIST_FIRST((head2)); LIST_FIRST((head2)) = swap_tmp; if ((swap_tmp = LIST_FIRST((head1))) != NULL) swap_tmp->field.le_prev = &LIST_FIRST((head1)); if ((swap_tmp = LIST_FIRST((head2))) != NULL) swap_tmp->field.le_prev = &LIST_FIRST((head2)); } while (0) __NULLABILITY_COMPLETENESS_POP __MISMATCH_TAGS_POPLIST_REMOVE(elm,field)do { LIST_CHECK_NEXT(elm, field); LIST_CHECK_PREV(elm, field); if (LIST_NEXT((elm), field) != NULL) LIST_NEXT((elm), field)->field.le_prev = (elm)->field.le_prev; *(elm)->field.le_prev = LIST_NEXT((elm), field); TRASHIT((elm)->field.le_next); TRASHIT((elm)->field.le_prev); } while (0)LIST_NEXT(elm,field)((elm)->field.le_next)LIST_INSERT_HEAD(head,elm,field)do { LIST_CHECK_HEAD((head), field); if ((LIST_NEXT((elm), field) = LIST_FIRST((head))) != NULL) LIST_FIRST((head))->field.le_prev = &LIST_NEXT((elm), field); LIST_FIRST((head)) = (elm); (elm)->field.le_prev = &LIST_FIRST((head)); } while (0)LIST_INSERT_BEFORE(listelm,elm,field)do { LIST_CHECK_PREV(listelm, field); (elm)->field.le_prev = (listelm)->field.le_prev; LIST_NEXT((elm), field) = (listelm); *(listelm)->field.le_prev = (elm); (listelm)->field.le_prev = &LIST_NEXT((elm), field); } while (0)LIST_INSERT_AFTER(listelm,elm,field)do { LIST_CHECK_NEXT(listelm, field); if ((LIST_NEXT((elm), field) = LIST_NEXT((listelm), field)) != NULL) LIST_NEXT((listelm), field)->field.le_prev = &LIST_NEXT((elm), field); LIST_NEXT((listelm), field) = (elm); (elm)->field.le_prev = &LIST_NEXT((listelm), field); } while (0)LIST_INIT(head)do { LIST_FIRST((head)) = NULL; } while (0)LIST_FOREACH_SAFE(var,head,field,tvar)for ((var) = LIST_FIRST((head)); (var) && ((tvar) = LIST_NEXT((var), field), 1); (var) = (tvar))LIST_FOREACH(var,head,field)for ((var) = LIST_FIRST((head)); (var); (var) = LIST_NEXT((var), field))LIST_FIRST(head)((head)->lh_first)LIST_EMPTY(head)((head)->lh_first == NULL)LIST_CHECK_PREV(elm,field)LIST_CHECK_NEXT(elm,field)LIST_CHECK_HEAD(head,field)LIST_ENTRY(type)__MISMATCH_TAGS_PUSH __NULLABILITY_COMPLETENESS_PUSH struct { struct type *le_next; struct type **le_prev; } __NULLABILITY_COMPLETENESS_POP __MISMATCH_TAGS_POPLIST_HEAD_INITIALIZER(head){ NULL }LIST_HEAD(name,type)__MISMATCH_TAGS_PUSH __NULLABILITY_COMPLETENESS_PUSH struct name { struct type *lh_first; } __NULLABILITY_COMPLETENESS_POP __MISMATCH_TAGS_POPSTAILQ_SWAP(head1,head2,type)__MISMATCH_TAGS_PUSH __NULLABILITY_COMPLETENESS_PUSH do { struct type *swap_first = STAILQ_FIRST(head1); struct type **swap_last = (head1)->stqh_last; STAILQ_FIRST(head1) = STAILQ_FIRST(head2); (head1)->stqh_last = (head2)->stqh_last; STAILQ_FIRST(head2) = swap_first; (head2)->stqh_last = swap_last; if (STAILQ_EMPTY(head1)) (head1)->stqh_last = &STAILQ_FIRST(head1); if (STAILQ_EMPTY(head2)) (head2)->stqh_last = &STAILQ_FIRST(head2); } while (0) __NULLABILITY_COMPLETENESS_POP __MISMATCH_TAGS_POPSTAILQ_REMOVE_AFTER(head,elm,field)do { if ((STAILQ_NEXT(elm, field) = STAILQ_NEXT(STAILQ_NEXT(elm, field), field)) == NULL) (head)->stqh_last = &STAILQ_NEXT((elm), field); } while (0)STAILQ_REMOVE_HEAD_UNTIL(head,elm,field)do { if ((STAILQ_FIRST((head)) = STAILQ_NEXT((elm), field)) == NULL) (head)->stqh_last = &STAILQ_FIRST((head)); } while (0)STAILQ_REMOVE_HEAD(head,field)do { if ((STAILQ_FIRST((head)) = STAILQ_NEXT(STAILQ_FIRST((head)), field)) == NULL) (head)->stqh_last = &STAILQ_FIRST((head)); } while (0)STAILQ_REMOVE(head,elm,type,field)__MISMATCH_TAGS_PUSH __NULLABILITY_COMPLETENESS_PUSH do { if (STAILQ_FIRST((head)) == (elm)) { STAILQ_REMOVE_HEAD((head), field); } else { struct type *curelm = STAILQ_FIRST((head)); while (STAILQ_NEXT(curelm, field) != (elm)) curelm = STAILQ_NEXT(curelm, field); STAILQ_REMOVE_AFTER(head, curelm, field); } TRASHIT((elm)->field.stqe_next); } while (0) __NULLABILITY_COMPLETENESS_POP __MISMATCH_TAGS_POPSTAILQ_NEXT(elm,field)((elm)->field.stqe_next)STAILQ_LAST(head,type,field)__MISMATCH_TAGS_PUSH __NULLABILITY_COMPLETENESS_PUSH (STAILQ_EMPTY((head)) ? NULL : ((struct type *)(void *) ((char *)((head)->stqh_last) - __offsetof(struct type, field))))__NULLABILITY_COMPLETENESS_POP __MISMATCH_TAGS_POPSTAILQ_INSERT_TAIL(head,elm,field)do { STAILQ_NEXT((elm), field) = NULL; *(head)->stqh_last = (elm); (head)->stqh_last = &STAILQ_NEXT((elm), field); } while (0)STAILQ_INSERT_HEAD(head,elm,field)do { if ((STAILQ_NEXT((elm), field) = STAILQ_FIRST((head))) == NULL) (head)->stqh_last = &STAILQ_NEXT((elm), field); STAILQ_FIRST((head)) = (elm); } while (0)STAILQ_INSERT_AFTER(head,tqelm,elm,field)do { if ((STAILQ_NEXT((elm), field) = STAILQ_NEXT((tqelm), field)) == NULL) (head)->stqh_last = &STAILQ_NEXT((elm), field); STAILQ_NEXT((tqelm), field) = (elm); } while (0)STAILQ_INIT(head)do { STAILQ_FIRST((head)) = NULL; (head)->stqh_last = &STAILQ_FIRST((head)); } while (0)STAILQ_FOREACH_SAFE(var,head,field,tvar)for ((var) = STAILQ_FIRST((head)); (var) && ((tvar) = STAILQ_NEXT((var), field), 1); (var) = (tvar))STAILQ_FOREACH(var,head,field)for((var) = STAILQ_FIRST((head)); (var); (var) = STAILQ_NEXT((var), field))STAILQ_FIRST(head)((head)->stqh_first)STAILQ_EMPTY(head)((head)->stqh_first == NULL)STAILQ_CONCAT(head1,head2)do { if (!STAILQ_EMPTY((head2))) { *(head1)->stqh_last = (head2)->stqh_first; (head1)->stqh_last = (head2)->stqh_last; STAILQ_INIT((head2)); } } while (0)STAILQ_ENTRY(type)__MISMATCH_TAGS_PUSH __NULLABILITY_COMPLETENESS_PUSH struct { struct type *stqe_next; } __NULLABILITY_COMPLETENESS_POP __MISMATCH_TAGS_POPSTAILQ_HEAD_INITIALIZER(head){ NULL, &(head).stqh_first }STAILQ_HEAD(name,type)__MISMATCH_TAGS_PUSH __NULLABILITY_COMPLETENESS_PUSH struct name { struct type *stqh_first; struct type **stqh_last; } __NULLABILITY_COMPLETENESS_POP __MISMATCH_TAGS_POPSLIST_REMOVE_HEAD(head,field)do { SLIST_FIRST((head)) = SLIST_NEXT(SLIST_FIRST((head)), field); } while (0)SLIST_REMOVE_AFTER(elm,field)do { SLIST_NEXT(elm, field) = SLIST_NEXT(SLIST_NEXT(elm, field), field); } while (0)SLIST_REMOVE(head,elm,type,field)__MISMATCH_TAGS_PUSH __NULLABILITY_COMPLETENESS_PUSH do { if (SLIST_FIRST((head)) == (elm)) { SLIST_REMOVE_HEAD((head), field); } else { struct type *curelm = SLIST_FIRST((head)); while (SLIST_NEXT(curelm, field) != (elm)) curelm = SLIST_NEXT(curelm, field); SLIST_REMOVE_AFTER(curelm, field); } TRASHIT((elm)->field.sle_next); } while (0) __NULLABILITY_COMPLETENESS_POP __MISMATCH_TAGS_POPSLIST_NEXT(elm,field)((elm)->field.sle_next)SLIST_INSERT_HEAD(head,elm,field)do { SLIST_NEXT((elm), field) = SLIST_FIRST((head)); SLIST_FIRST((head)) = (elm); } while (0)SLIST_INSERT_AFTER(slistelm,elm,field)do { SLIST_NEXT((elm), field) = SLIST_NEXT((slistelm), field); SLIST_NEXT((slistelm), field) = (elm); } while (0)SLIST_INIT(head)do { SLIST_FIRST((head)) = NULL; } while (0)SLIST_FOREACH_PREVPTR(var,varp,head,field)for ((varp) = &SLIST_FIRST((head)); ((var) = *(varp)) != NULL; (varp) = &SLIST_NEXT((var), field))SLIST_FOREACH_SAFE(var,head,field,tvar)for ((var) = SLIST_FIRST((head)); (var) && ((tvar) = SLIST_NEXT((var), field), 1); (var) = (tvar))SLIST_FOREACH(var,head,field)for ((var) = SLIST_FIRST((head)); (var); (var) = SLIST_NEXT((var), field))SLIST_FIRST(head)((head)->slh_first)SLIST_EMPTY(head)((head)->slh_first == NULL)SLIST_ENTRY(type)__MISMATCH_TAGS_PUSH __NULLABILITY_COMPLETENESS_PUSH struct { struct type *sle_next; } __NULLABILITY_COMPLETENESS_POP __MISMATCH_TAGS_POPSLIST_HEAD_INITIALIZER(head)SLIST_HEAD(name,type)__MISMATCH_TAGS_PUSH __NULLABILITY_COMPLETENESS_PUSH struct name { struct type *slh_first; } __NULLABILITY_COMPLETENESS_POP __MISMATCH_TAGS_POP__NULLABILITY_COMPLETENESS_POP__NULLABILITY_COMPLETENESS_PUSH_Pragma("clang diagnostic push") _Pragma("clang diagnostic ignored \"-Wnullability-completeness\"")__MISMATCH_TAGS_POP__MISMATCH_TAGS_PUSH_Pragma("clang diagnostic push") _Pragma("clang diagnostic ignored \"-Wmismatched-tags\"")TRASHIT(x)TRACEBUFQMD_TRACE_HEAD(head)QMD_TRACE_ELEM(elem)__improbable(x)_SYS_QUEUE_H___improbableQUEUE_MACRO_DEBUGdefined(__clang__) && defined(__cplusplus)_KERNELNOTFB31/* !_SYS_QUEUE_H_ *//* _KERNEL *//* NOTFB31 *//*
 * XXX insque() and remque() are an old way of handling certain queues.
 * They bogusly assumes that all queue heads look alike.
 *//*
 * Circular queue functions.
 *//* previous element *//* next element *//* last element *//* first element *//*
 * Circular queue definitions.
 *//*
 * Why did they switch to spaces for this one macro?
 *//*
 * Tail queue functions.
 *//* address of previous next element *//* addr of last next element *//*
 * Tail queue declarations.
 *//*
 * List functions.
 *//*
 * List declarations.
 *//*
 * Singly-linked Tail queue functions.
 *//*
 * Singly-linked Tail queue declarations.
 *//*
 * Singly-linked List functions.
 *//*
 * Singly-linked List declarations.
 *//*!
 * Ensures that these macros can safely be used in structs when compiling with
 * clang. The macros do not allow for nullability attributes to be specified due
 * to how they are expanded. For example:
 *
 *     SLIST_HEAD(, foo _Nullable) bar;
 *
 * expands to
 *
 *     struct {
 *         struct foo _Nullable *slh_first;
 *     }
 *
 * which is not valid because the nullability specifier has to apply to the
 * pointer. So just ignore nullability completeness in all the places where this
 * is an issue.
 *//*
 * Horrible macros to enable use of code that was meant to be C-specific
 *   (and which push struct onto type) in C++; without these, C++ code
 *   that uses these macros in the context of a class will blow up
 *   due to "struct" being preprended to "type" by the macros, causing
 *   inconsistent use of tags.
 *
 * This approach is necessary because these are macros; we have to use
 *   these on a per-macro basis (because the queues are implemented as
 *   macros, disabling this warning in the scope of the header file is
 *   insufficient), whuch means we can't use #pragma, and have to use
 *   _Pragma.  We only need to use these for the queue macros that
 *   prepend "struct" to "type" and will cause C++ to blow up.
 *//* QUEUE_MACRO_DEBUG *//* Store the last 2 places the queue element or head was altered *//*
 * This file defines five types of data structures: singly-linked lists,
 * singly-linked tail queues, lists, tail queues, and circular queues.
 *
 * A singly-linked list is headed by a single forward pointer. The elements
 * are singly linked for minimum space and pointer manipulation overhead at
 * the expense of O(n) removal for arbitrary elements. New elements can be
 * added to the list after an existing element or at the head of the list.
 * Elements being removed from the head of the list should use the explicit
 * macro for this purpose for optimum efficiency. A singly-linked list may
 * only be traversed in the forward direction.  Singly-linked lists are ideal
 * for applications with large datasets and few or no removals or for
 * implementing a LIFO queue.
 *
 * A singly-linked tail queue is headed by a pair of pointers, one to the
 * head of the list and the other to the tail of the list. The elements are
 * singly linked for minimum space and pointer manipulation overhead at the
 * expense of O(n) removal for arbitrary elements. New elements can be added
 * to the list after an existing element, at the head of the list, or at the
 * end of the list. Elements being removed from the head of the tail queue
 * should use the explicit macro for this purpose for optimum efficiency.
 * A singly-linked tail queue may only be traversed in the forward direction.
 * Singly-linked tail queues are ideal for applications with large datasets
 * and few or no removals or for implementing a FIFO queue.
 *
 * A list is headed by a single forward pointer (or an array of forward
 * pointers for a hash table header). The elements are doubly linked
 * so that an arbitrary element can be removed without a need to
 * traverse the list. New elements can be added to the list before
 * or after an existing element or at the head of the list. A list
 * may only be traversed in the forward direction.
 *
 * A tail queue is headed by a pair of pointers, one to the head of the
 * list and the other to the tail of the list. The elements are doubly
 * linked so that an arbitrary element can be removed without a need to
 * traverse the list. New elements can be added to the list before or
 * after an existing element, at the head of the list, or at the end of
 * the list. A tail queue may be traversed in either direction.
 *
 * A circle queue is headed by a pair of pointers, one to the head of the
 * list and the other to the tail of the list. The elements are doubly
 * linked so that an arbitrary element can be removed without a need to
 * traverse the list. New elements can be added to the list before or after
 * an existing element, at the head of the list, or at the end of the list.
 * A circle queue may be traversed in either direction, but has a more
 * complex end of list detection.
 * Note that circle queues are deprecated, because, as the removal log
 * in FreeBSD states, "CIRCLEQs are a disgrace to everything Knuth taught
 * us in Volume 1 Chapter 2. [...] Use TAILQ instead, it provides the same
 * functionality." Code using them will continue to compile, but they
 * are no longer documented on the man page.
 *
 * For details on the use of these macros, see the queue(3) manual page.
 *
 *
 *				SLIST	LIST	STAILQ	TAILQ	CIRCLEQ
 * _HEAD			+	+	+	+	+
 * _HEAD_INITIALIZER		+	+	+	+	-
 * _ENTRY			+	+	+	+	+
 * _INIT			+	+	+	+	+
 * _EMPTY			+	+	+	+	+
 * _FIRST			+	+	+	+	+
 * _NEXT			+	+	+	+	+
 * _PREV			-	-	-	+	+
 * _LAST			-	-	+	+	+
 * _FOREACH			+	+	+	+	+
 * _FOREACH_SAFE		+	+	+	+	-
 * _FOREACH_REVERSE		-	-	-	+	-
 * _FOREACH_REVERSE_SAFE	-	-	-	+	-
 * _INSERT_HEAD			+	+	+	+	+
 * _INSERT_BEFORE		-	+	-	+	+
 * _INSERT_AFTER		+	+	+	+	+
 * _INSERT_TAIL			-	-	+	+	+
 * _CONCAT			-	-	+	+	-
 * _REMOVE_AFTER		+	-	+	-	-
 * _REMOVE_HEAD			+	-	+	-	-
 * _REMOVE_HEAD_UNTIL		-	-	+	-	-
 * _REMOVE			+	+	+	+	+
 * _SWAP			-	+	+	+	-
 *
 *//* __improbable *//* noop in userspace *//*-
 * Copyright (c) 1991, 1993
 *	The Regents of the University of California.  All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 4. Neither the name of the University nor the names of its contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 *
 *	@(#)queue.h	8.5 (Berkeley) 8/20/94
 *//Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX.sdk/usr/include/sys/_types/_fsid_t.hfsid &const fsidconst fsid &fsid_tfsidint32_t[2]_FSID_T/* _FSID_T *//* file system id type *//* int32_t *//*
 * Copyright (c) 2014 Apple Inc. All rights reserved.
 *
 * @APPLE_OSREFERENCE_LICENSE_HEADER_START@
 *
 * This file contains Original Code and/or Modifications of Original Code
 * as defined in and that are subject to the Apple Public Source License
 * Version 2.0 (the 'License'). You may not use this file except in
 * compliance with the License. The rights granted to you under the License
 * may not be used to create, or enable the creation or redistribution of,
 * unlawful or unlicensed copies of an Apple operating system, or to
 * circumvent, violate, or enable the circumvention or violation of, any
 * terms of an Apple operating system software license agreement.
 *
 * Please obtain a copy of the License at
 * http://www.opensource.apple.com/apsl/ and read it before using this file.
 *
 * The Original Code and all software distributed under the License are
 * distributed on an 'AS IS' basis, WITHOUT WARRANTY OF ANY KIND, EITHER
 * EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES,
 * INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE, QUIET ENJOYMENT OR NON-INFRINGEMENT.
 * Please see the License for the specific language governing rights and
 * limitations under the License.
 *
 * @APPLE_OSREFERENCE_LICENSE_HEADER_END@
 *//Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX.sdk/usr/include/sys/mount.h<sys/_types/_fsid_t.h><sys/queue.h><os/base.h><sys/attr.h>getvfsbynamevfsconf *unmountstatfs64statfs64 *statfsstatfs *fmountmountgetmntinfo64statfs64 **getmntinfo_r_npstatfs **getmntinfogetfsstat64getfsstatgetfhfhandle_t *fhandle *fstatfs64fstatfsfhopenconst fhandleconst fhandle *fhandle &const fhandle &netfs_status &const netfs_statusconst netfs_status &vfs_server &const vfs_serverconst vfs_server &vfsquery &const vfsqueryconst vfsquery &vfsidctl &const vfsidctlconst vfsidctl &vfsconf &const vfsconfconst vfsconf &vfsstatfs &const vfsstatfsconst vfsstatfs &statfs &const statfsconst statfs &statfs64 &const statfs64const statfs64 &fhandle_tfhandlenetfs_statusvfs_servervfsqueryvfsidctlvfsconfvnode *vnode_tvnodemount *mount_tvfsstatfsunsigned char[128]fh_datafh_lenuint64_t[0]unsigned long long[0]ns_threadidsns_threadcountns_waittimechar[512]ns_mountoptsns_statusu_int8_t[768]unsigned char[768]vs_server_namevs_minutesu_int32_t[31]unsigned int[31]vq_sparevq_flagsu_int32_t[12]unsigned int[12]vc_sparevc_lenvc_ptrvc_fsidvc_versvfc_reserved3vfc_reserved2vfc_flagsvfc_refcountvfc_typenumMFSNAMELENvfc_namevfc_reserved1void *[2]f_reservedf_fssubtypef_mntfromnamef_mntonnameMFSTYPENAMELENf_fstypenamef_flagsf_ownerf_fsidf_ffreef_filesf_busedf_bavailf_bfreef_blocksf_iosizef_bsizeuint32_t[7]unsigned int[7]f_flags_extf_typeNFSV2_MAX_FH_SIZENFSV3_MAX_FH_SIZENFSV4_MAX_FH_SIZENFS_MAX_FH_SIZEVQ_FLAG10000VQ_FREE_SPACE_CHANGEVQ_DESIRED_DISKVQ_NEARLOWDISKVQ_QUOTAVQ_SERVEREVENTVQ_SYNCEVENTVQ_VERYLOWDISKVQ_UPDATEVQ_NOTRESPLOCKVQ_ASSISTVQ_DEADVQ_UNMOUNTVQ_MOUNTVQ_LOWDISKVQ_NEEDAUTHVQ_NOTRESPVFS_CTL_STATFSVFS_CTL_STATFS640x0001000BVFS_CTL_NSTATUS0x0001000AVFS_CTL_SERVERINFO0x00010009VFS_CTL_DISC0x00010008VFS_CTL_SADDR0x00010007VFS_CTL_NOLOCKS0x00010006VFS_CTL_TIMEO0x00010005VFS_CTL_NEWADDR0x00010004VFS_CTL_QUERY0x00010003VFS_CTL_UMOUNT0x00010002VFS_CTL_OSTATFS0x00010001VFS_CTL_VERS1MNT_DWAITMNT_NOWAITMNT_WAITVFS_CONFVFS_MAXTYPENUMVFS_NUMMNTOPSVFS_GENERICMNT_CMDFLAGS(MNT_UPDATE|MNT_NOBLOCK|MNT_RELOAD|MNT_FORCE)MNT_FORCEMNT_RELOADMNT_NOBLOCKMNT_UPDATEMNT_VISFLAGMASK(MNT_RDONLY | MNT_SYNCHRONOUS | MNT_NOEXEC | MNT_NOSUID | MNT_NODEV | MNT_UNION | MNT_ASYNC | MNT_EXPORTED | MNT_QUARANTINE | MNT_LOCAL | MNT_QUOTA | MNT_REMOVABLE | MNT_ROOTFS | MNT_DOVOLFS | MNT_DONTBROWSE | MNT_IGNORE_OWNERSHIP | MNT_AUTOMOUNTED | MNT_JOURNALED | MNT_NOUSERXATTR | MNT_DEFWRITE | MNT_MULTILABEL | MNT_NOFOLLOW | MNT_NOATIME | MNT_STRICTATIME | MNT_SNAPSHOT | MNT_CPROTECT)MNT_UNKNOWNPERMISSIONSMNT_IGNORE_OWNERSHIPMNT_STRICTATIMEMNT_SNAPSHOTMNT_NOATIMEMNT_NOFOLLOWMNT_MULTILABELMNT_DEFWRITEMNT_NOUSERXATTRMNT_JOURNALEDMNT_AUTOMOUNTEDMNT_DONTBROWSEMNT_DOVOLFSMNT_ROOTFSMNT_QUOTAMNT_LOCALMNT_QUARANTINEMNT_REMOVABLEMNT_EXPORTEDMNT_CPROTECTMNT_ASYNCMNT_UNIONMNT_NODEVMNT_NOSUIDMNT_NOEXECMNT_SYNCHRONOUSMNT_RDONLY__DARWIN_STRUCT_STATFS64{ uint32_t f_bsize; int32_t f_iosize; uint64_t f_blocks; uint64_t f_bfree; uint64_t f_bavail; uint64_t f_files; uint64_t f_ffree; fsid_t f_fsid; uid_t f_owner; uint32_t f_type; uint32_t f_flags; uint32_t f_fssubtype; char f_fstypename[MFSTYPENAMELEN]; char f_mntonname[MAXPATHLEN]; char f_mntfromname[MAXPATHLEN]; uint32_t f_flags_ext; uint32_t f_reserved[7]; }MNT_EXT_ROOT_DATA_VOLMNAMELEN_SYS_MOUNT_H_!defined(KERNEL) && !defined(_KERN_SYS_KERNELTYPES_H_)/* !_SYS_MOUNT_H_ *//* file handle value *//* length of file handle *//*
 * Generic file handle
 *//* placeholder *//* free disk space has significantly changed *//* the desired disk space *//* Above lowdisk and below desired disk space *//* a user quota has been hit *//* server issued notification/warning *//* a sync just happened (not set by kernel starting Mac OS X 10.9) *//* file system has *very* little disk space left *//* filesystem information has changed *//* server lockd down *//* filesystem needs assistance from external program *//* filesystem is dead, needs force unmount *//* filesystem has left *//* new filesystem arrived *//* we're low on space *//* server bad auth *//* server down *//* vfsquery flags */// Thread IDs of those blocked threads// Number of threads blocked on network calls// Time waiting for reply (sec)// Significant mount options// Current status of mount (vfsquery flags)/*
 * NetFS mount status - returned by VFS_CTL_NSTATUS
 *//* UTF8 server name to display (null terminated) *//* minutes until server goes down. *//*
 * Automatically select the correct VFS_CTL_*STATFS* flavor based
 * on what "struct statfs" layout the client will use.
 *//* statfs64 *//* netfs mount status *//* information about fs server *//* server disconnected *//* get server address *//* disable file locking *//* set timeout for vfs notification *//* reconnect to new address *//* anything wrong? (vfsquery) *//* unmount *//* old legacy statfs *//*
 * New style VFS sysctls, do not reuse/conflict with the namespace for
 * private sysctls.
 *//* vfsidctl API version. *//* spare (must be zero). *//* sizeof said structure. *//* pointer to data structure. *//* fsid to operate on. *//* should be VFSIDCTL_VERS1 (below) *//* opaque *//* permanent flags *//* number mounted of this type *//* historic filesystem type number *//* filesystem type name *//* Reserved fields preserve binary compatibility *//* also defined in kernel_types.h *//* synchronized I/O data integrity completion *//* start all I/O, but do not wait for it *//* synchronized I/O file integrity completion *//*
 * Flags for various system call interfaces.
 *
 * waitfor flags to vfs_sync() and getfsstat()
 *//* struct: vfsconf for filesystem given
	                         *  as next argument *//* int: highest defined filesystem type *//*
 * Third level identifiers for VFS_GENERIC are given below; third
 * level identifiers for specific filesystems are given in their
 * mount specific header files.
 *//* int: total num of vfs mount/unmount operations *//* generic filesystem information *//*
 * Sysctl CTL_VFS definitions.
 *
 * Second level identifier specifies which filesystem. Second level
 * identifier VFS_GENERIC returns information about all filesystems.
 *//* force unmount or readonly change *//* reload filesystem data *//* don't block unmount if not responding *//* not a real mount, just an update *//*
 * External filesystem command modifier flags.
 * Unmount can use the MNT_FORCE flag.
 * XXX These are not STATES and really should be somewhere else.
 * External filesystem control flags.
 *//*
 * XXX I think that this could now become (~(MNT_CMDFLAGS))
 * but the 'mount' program may need changing to handle this.
 *//* backwards compatibility only *//* enable strict update of file access time *//* The mount is a snapshot *//* disable update of file access time *//* don't follow symlink when resolving mount point *//* MAC support for individual labels *//* filesystem should defer writes *//* Don't allow user extended attributes *//* filesystem is journaled *//* filesystem was mounted by automounter *//* VFS will ignore ownership information on filesystem objects *//* file system is not appropriate path to user data *//* FS supports volfs (deprecated flag in Mac OS X 10.5) *//* identifies the root filesystem *//* quotas are enabled on filesystem *//* filesystem is stored locally *//*
 * Flags set by internal operations.
 *//* file system is quarantined *//*
 * MAC labeled / "quarantined" flag
 *//*
 * Denotes storage which can be removed from the system by the user.
 *//* file system is exported *//*
 * NFS export related mount flags.
 *//* file system supports content protection *//* file system written asynchronously *//* union with underlying filesystem *//* don't interpret special files *//* don't honor setuid bits on fs *//* can't exec from filesystem *//* file system written synchronously *//* read only filesystem *//*
 * User specifiable flags.
 *
 * Unmount uses MNT_FORCE flag.
 *//* For future use == 0 *//* fs sub-type (flavor) *//* mounted filesystem *//* directory on which mounted *//* fs type name inclus *//* copy of mount exported flags *//* user that mounted the filesystem *//* file system id *//* free file nodes in fs *//* total file nodes in file system *//* free blocks avail to non-superuser *//* free blocks in fs *//* total data blocks in file system *//* optimal transfer block size *//* fundamental file system block size *//* For future use *//* For alignment *//* fs type name *//* reserved for future use *//* type of filesystem *//* spare for later *//* TEMPORARY SHADOW COPY OF f_flags *//* TEMPORARY SHADOW COPY OF f_type *//*
 * LP64 - WARNING - must be kept in sync with struct user_statfs in mount_internal.h.
 *//* extended flags *//* Data volume of root volume group *//* length of buffer for returned name *//* ! __DARWIN_64_BIT_INO_T *//* length of fs type name including null *//* length of fs type name, not inc. null *//*
 * file system statistics
 *//* XXX needed for user builds *//* needed for vol_capabilities_attr_t *//*
 * Copyright (c) 1989, 1991, 1993
 *	The Regents of the University of California.  All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *	This product includes software developed by the University of
 *	California, Berkeley and its contributors.
 * 4. Neither the name of the University nor the names of its contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 *
 *	@(#)mount.h	8.21 (Berkeley) 5/20/95
 *//Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX.sdk/usr/include/mach/i386/kern_return.hkern_return_t_MACH_I386_KERN_RETURN_H_/* _MACH_I386_KERN_RETURN_H_ *//*
 *	File:	kern_return.h
 *	Author:	Avadis Tevanian, Jr., Michael Wayne Young
 *	Date:	1985
 *
 *	Machine-dependent kernel return definitions.
 *//Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX.sdk/usr/include/mach/machine/kern_return.h"mach/i386/kern_return.h"_MACH_MACHINE_KERN_RETURN_H_/* _MACH_MACHINE_KERN_RETURN_H_ *//Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX.sdk/usr/include/mach/kern_return.h<mach/machine/kern_return.h>KERN_RETURN_MAXKERN_NOT_FOUNDKERN_INVALID_KCKERN_MISSING_KCKERN_DENIEDKERN_INSUFFICIENT_BUFFER_SIZEKERN_POLICY_STATICKERN_CODESIGN_ERRORKERN_OPERATION_TIMED_OUTKERN_NOT_WAITINGKERN_NODE_DOWNKERN_NOT_SUPPORTEDKERN_RPC_CONTINUE_ORPHANKERN_RPC_TERMINATE_ORPHANKERN_RPC_SERVER_TERMINATEDKERN_SEMAPHORE_DESTROYEDKERN_LOCK_OWNED_SELFKERN_LOCK_OWNEDKERN_LOCK_UNSTABLEKERN_LOCK_SET_DESTROYEDKERN_TERMINATEDKERN_NOT_DEPRESSEDKERN_INVALID_SECURITYKERN_INVALID_MEMORY_CONTROLKERN_INVALID_LEDGERKERN_EXCEPTION_PROTECTEDKERN_DEFAULT_SETKERN_ALREADY_WAITINGKERN_INVALID_OBJECTKERN_INVALID_POLICYKERN_POLICY_LIMITKERN_INVALID_PROCESSOR_SETKERN_MEMORY_RESTART_COPYKERN_MEMORY_DATA_MOVEDKERN_MEMORY_PRESENTKERN_INVALID_HOSTKERN_RIGHT_EXISTSKERN_INVALID_CAPABILITYKERN_UREFS_OVERFLOWKERN_INVALID_VALUEKERN_INVALID_RIGHTKERN_INVALID_TASKKERN_INVALID_NAMEKERN_ABORTEDKERN_NAME_EXISTSKERN_NOT_IN_SETKERN_ALREADY_IN_SETKERN_MEMORY_ERRORKERN_MEMORY_FAILUREKERN_NO_ACCESSKERN_NOT_RECEIVERKERN_RESOURCE_SHORTAGEKERN_FAILUREKERN_INVALID_ARGUMENTKERN_NO_SPACEKERN_PROTECTION_FAILUREKERN_INVALID_ADDRESSKERN_SUCCESS_MACH_KERN_RETURN_H_/* _MACH_KERN_RETURN_H_ *//* Maximum return value allowable
 *//* A search or query operation did not return a result
 *//* The KC on which the function is operating is invalid
 *//* The KC on which the function is operating is missing
 *//* Denied by security policy
 *//* The provided buffer is of insufficient size for the requested data.
 *//* The requested property cannot be changed at this time.
 *//* During a page fault, indicates that the page was rejected
 * as a result of a signature check.
 *//* Some thread-oriented operation (semaphore_wait) timed out
 *//* A signalled thread was not actually waiting. *//* Remote node down or inaccessible.
 *//* Empty thread activation (No thread linked to it)
 *//* Allow an orphaned activation to continue executing.
 *//* Terminate an orphaned activation.
 *//* Return from RPC indicating the target server was
 * terminated before it successfully replied
 *//* Semaphore has been destroyed and is no longer available.
 *//* The lock is already owned by the calling thread
 *//* The lock is already owned by another thread
 *//* The thread holding the lock terminated before releasing
 * the lock
 *//* Lock set has been destroyed and is no longer available.
 *//* Object has been terminated and is no longer available
 *//* thread_depress_abort was called on a thread which
 * was not currently depressed.
 *//* An argument supplied to assert security privilege
 * was not a host security port.
 *//* The port was not a memory cache control port.
 *//* A ledger was required but not supplied.
 *//* An attempt was made to fetch an exception port that is
 * protected, or to abort a thread while processing a
 * protected exception.
 *//* An attempt was made to destroy the default processor
 * set.
 *//* A thread is attempting to wait for an event for which
 * there is already a waiting thread.
 *//* The external memory manager failed to initialize the
 * memory object.
 *//* The specified scheduling policy is not currently
 * enabled for the processor set.
 *//* The specified scheduling attributes exceed the thread's
 * limits.
 *//* An argument applied to assert processor set privilege
 * was not a processor set control port.
 *//* A strategic copy was attempted of an object
 * upon which a quicker copy is now possible.
 * The caller should retry the copy using
 * vm_object_copy_quickly. This error code
 * is seen only by the kernel.
 *//* A page was requested of a memory manager via
 * memory_object_data_request for an object using
 * a MEMORY_OBJECT_COPY_CALL strategy, with the
 * VM_PROT_WANTS_COPY flag being used to specify
 * that the page desired is for a copy of the
 * object, and the memory manager has detected
 * the page was pushed into a copy of the object
 * while the kernel was walking the shadow chain
 * from the copy to the object. This error code
 * is delivered via memory_object_data_error
 * and is handled by the kernel (it forces the
 * kernel to restart the fault). It will not be
 * seen by users.
 *//* An attempt was made to supply "precious" data
 * for memory that is already present in a
 * memory object.
 *//* Target host isn't actually a host.
 *//* The task already has send or receive rights
 * for the port under another name.
 *//* The supplied (port) capability is improper.
 *//* Operation would overflow limit on user-references.
 *//* A blatant range error.
 *//* The name denotes a right, but not an appropriate right.
 *//* Target task isn't an active task.
 *//* The name doesn't denote a right in the task.
 *//* The operation was aborted.  Ipc code will
 * catch this and reflect it as a message error.
 *//* The name already denotes a right in the task.
 *//* The receive right is not a member of a port set.
 *//* The receive right is already a member of the portset.
 *//* During a page fault, the memory object indicated
 * that the data could not be returned.  This failure
 * may be temporary; future attempts to access this
 * same data may succeed, as defined by the memory
 * object.
 *//* During a page fault, the target address refers to a
 * memory object that has been destroyed.  This
 * failure is permanent.
 *//* Bogus access restriction.
 *//* The task in question does not hold receive rights
 * for the port argument.
 *//* A system resource could not be allocated to fulfill
 * this request.  This failure may not be permanent.
 *//* The function could not be performed.  A catch-all.
 *//* The function requested was not applicable to this
 * type of argument, or an argument is invalid
 *//* The address range specified is already in use, or
 * no address range of the size specified could be
 * found.
 *//* Specified memory is valid, but does not permit the
 * required forms of access.
 *//* Specified address is not currently valid.
 *//*
 *	File:	h/kern_return.h
 *	Author:	Avadis Tevanian, Jr.
 *	Date:	1985
 *
 *	Kernel return codes.
 *
 *//Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX.sdk/usr/include/mach/message.h<mach/kern_return.h>mach_voucher_deallocatemach_msgmach_msg_header_t *mach_msg_overwritemach_msg_empty_t &const mach_msg_empty_tconst mach_msg_empty_t &mach_msg_empty_rcv_t &const mach_msg_empty_rcv_tconst mach_msg_empty_rcv_t &mach_msg_empty_send_t &const mach_msg_empty_send_tconst mach_msg_empty_send_t &mach_msg_mac_trailer_t &const mach_msg_mac_trailer_tconst mach_msg_mac_trailer_t &msg_labels_t &const msg_labels_tconst msg_labels_t &mach_msg_context_trailer_t &const mach_msg_context_trailer_tconst mach_msg_context_trailer_t &mach_msg_audit_trailer_t &const mach_msg_audit_trailer_tconst mach_msg_audit_trailer_t &audit_token_t &const audit_token_tconst audit_token_t &mach_msg_security_trailer_t &const mach_msg_security_trailer_tconst mach_msg_security_trailer_t &security_token_t &const security_token_tconst security_token_t &mach_msg_seqno_trailer_t &const mach_msg_seqno_trailer_tconst mach_msg_seqno_trailer_t &mach_msg_trailer_t &const mach_msg_trailer_tconst mach_msg_trailer_t &mach_msg_base_t &const mach_msg_base_tconst mach_msg_base_t &mach_msg_header_t &const mach_msg_header_tconst mach_msg_header_t &mach_msg_body_t &const mach_msg_body_tconst mach_msg_body_t &mach_msg_descriptor_t &const mach_msg_descriptor_tconst mach_msg_descriptor_t &mach_msg_guarded_port_descriptor_t &const mach_msg_guarded_port_descriptor_tconst mach_msg_guarded_port_descriptor_t &mach_msg_guarded_port_descriptor64_t &const mach_msg_guarded_port_descriptor64_tconst mach_msg_guarded_port_descriptor64_t &mach_msg_guarded_port_descriptor32_t &const mach_msg_guarded_port_descriptor32_tconst mach_msg_guarded_port_descriptor32_t &mach_msg_ool_ports_descriptor_t &const mach_msg_ool_ports_descriptor_tconst mach_msg_ool_ports_descriptor_t &mach_msg_ool_ports_descriptor64_t &const mach_msg_ool_ports_descriptor64_tconst mach_msg_ool_ports_descriptor64_t &mach_msg_ool_ports_descriptor32_t &const mach_msg_ool_ports_descriptor32_tconst mach_msg_ool_ports_descriptor32_t &mach_msg_ool_descriptor_t &const mach_msg_ool_descriptor_tconst mach_msg_ool_descriptor_t &mach_msg_ool_descriptor64_t &const mach_msg_ool_descriptor64_tconst mach_msg_ool_descriptor64_t &mach_msg_ool_descriptor32_t &const mach_msg_ool_descriptor32_tconst mach_msg_ool_descriptor32_t &mach_msg_port_descriptor_t &const mach_msg_port_descriptor_tconst mach_msg_port_descriptor_t &mach_msg_type_descriptor_t &const mach_msg_type_descriptor_tconst mach_msg_type_descriptor_t &mach_msg_return_tmach_msg_option_tmach_msg_type_number_tmach_msg_type_size_tmach_msg_empty_tmach_msg_empty_rcv_tmach_msg_empty_send_tmach_msg_options_tmach_msg_format_0_trailer_tmach_msg_max_trailer_tmach_msg_mac_trailer_tmach_msg_filter_idmsg_labels_tmach_msg_context_trailer_tmach_msg_audit_trailer_taudit_token_tmach_msg_security_trailer_tsecurity_token_tmach_msg_seqno_trailer_tmach_msg_trailer_tmach_msg_trailer_info_tmach_msg_trailer_size_tmach_msg_trailer_type_tmach_msg_base_tmach_msg_header_tmach_msg_body_tmach_msg_descriptor_tmach_msg_guarded_port_descriptor_tmach_msg_guarded_port_descriptor64_tmach_msg_guarded_port_descriptor32_tmach_msg_ool_ports_descriptor_tmach_msg_ool_ports_descriptor64_tmach_msg_ool_ports_descriptor32_tmach_msg_ool_descriptor_tmach_msg_ool_descriptor64_tmach_msg_ool_descriptor32_tmach_msg_port_descriptor_tmach_msg_type_descriptor_tmach_msg_descriptor_type_tmach_msg_guard_flags_tmach_msg_copy_options_tmach_msg_type_name_tmach_msg_priority_tmach_msg_id_tmach_msg_size_tmach_msg_bits_tmach_msg_timeout_trcvsendmsgh_labelsmsgh_admsgh_contextmsgh_auditmsgh_sendermsgh_seqnomsgh_trailer_sizemsgh_trailer_typesenderunsigned int[8]msgh_idmsgh_voucher_portmsgh_local_portmsgh_remote_portmsgh_sizemsgh_bitsmsgh_descriptor_countguarded_portool_portsout_of_linedispositionpad2pad3KERNEL_AUDIT_TOKENKERNEL_SECURITY_TOKENMACH_RCV_INVALID_REPLY0x10004012MACH_RCV_IN_PROGRESS_TIMED0x10004011MACH_RCV_INVALID_TRAILER0x1000400fMACH_RCV_SCATTER_SMALL0x1000400eMACH_RCV_INVALID_TYPE0x1000400dMACH_RCV_BODY_ERROR0x1000400cMACH_RCV_HEADER_ERROR0x1000400bMACH_RCV_IN_SET0x1000400aMACH_RCV_PORT_DIED0x10004009MACH_RCV_INVALID_DATA0x10004008MACH_RCV_INVALID_NOTIFY0x10004007MACH_RCV_PORT_CHANGED0x10004006MACH_RCV_INTERRUPTED0x10004005MACH_RCV_TOO_LARGE0x10004004MACH_RCV_TIMED_OUT0x10004003MACH_RCV_INVALID_NAME0x10004002MACH_RCV_IN_PROGRESS0x10004001MACH_SEND_MSG_FILTERED0x10000017MACH_SEND_NO_GRANT_DEST0x10000016MACH_SEND_INVALID_RT_OOL_SIZE0x10000015MACH_SEND_INVALID_CONTEXT0x10000012MACH_SEND_INVALID_TRAILER0x10000011MACH_SEND_INVALID_HEADER0x10000010MACH_SEND_INVALID_TYPE0x1000000fMACH_SEND_TOO_LARGE0x1000000eMACH_SEND_NO_BUFFER0x1000000dMACH_SEND_INVALID_MEMORY0x1000000cMACH_SEND_INVALID_NOTIFY0x1000000bMACH_SEND_INVALID_RIGHT0x1000000aMACH_SEND_INVALID_REPLY0x10000009MACH_SEND_MSG_TOO_SMALL0x10000008MACH_SEND_INTERRUPTED0x10000007MACH_SEND_INVALID_VOUCHER0x10000005MACH_SEND_TIMED_OUT0x10000004MACH_SEND_INVALID_DEST0x10000003MACH_SEND_INVALID_DATA0x10000002MACH_SEND_IN_PROGRESS0x10000001MACH_MSG_VM_KERNELMACH_MSG_IPC_KERNELMACH_MSG_VM_SPACEMACH_MSG_IPC_SPACEMACH_MSG_MASK0x00003e00MACH_MSG_SUCCESSREQUESTED_TRAILER_SIZE(y)REQUESTED_TRAILER_SIZE_NATIVE(y)((mach_msg_trailer_size_t) ((GET_RCV_ELEMENTS(y) == MACH_RCV_TRAILER_NULL) ? sizeof(mach_msg_trailer_t) : ((GET_RCV_ELEMENTS(y) == MACH_RCV_TRAILER_SEQNO) ? sizeof(mach_msg_seqno_trailer_t) : ((GET_RCV_ELEMENTS(y) == MACH_RCV_TRAILER_SENDER) ? sizeof(mach_msg_security_trailer_t) : ((GET_RCV_ELEMENTS(y) == MACH_RCV_TRAILER_AUDIT) ? sizeof(mach_msg_audit_trailer_t) : ((GET_RCV_ELEMENTS(y) == MACH_RCV_TRAILER_CTX) ? sizeof(mach_msg_context_trailer_t) : ((GET_RCV_ELEMENTS(y) == MACH_RCV_TRAILER_AV) ? sizeof(mach_msg_mac_trailer_t) : sizeof(mach_msg_max_trailer_t))))))))GET_RCV_ELEMENTS(y)(((y) >> 24) & 0xf)MACH_RCV_TRAILER_MASK((0xf << 24))MACH_RCV_TRAILER_ELEMENTS(x)(((x) & 0xf) << 24)MACH_RCV_TRAILER_TYPE(x)(((x) & 0xf) << 28)MACH_RCV_TRAILER_LABELSMACH_RCV_TRAILER_AVMACH_RCV_TRAILER_CTXMACH_RCV_TRAILER_AUDITMACH_RCV_TRAILER_SENDERMACH_RCV_TRAILER_SEQNOMACH_RCV_TRAILER_NULLMACH_MSG_STRICT_REPLYMACH_RCV_SYNC_PEEKMACH_RCV_SYNC_WAITMACH_RCV_GUARDED_DESCMACH_RCV_OVERWRITEMACH_RCV_VOUCHERMACH_RCV_INTERRUPTMACH_RCV_NOTIFYMACH_RCV_TIMEOUTMACH_SEND_SYNC_BOOTSTRAP_CHECKINMACH_SEND_KERNELMACH_SEND_SYNC_USE_THRPRIMACH_SEND_PROPAGATE_QOSMACH_SEND_SYNC_OVERRIDEMACH_SEND_IMPORTANCEMACH_SEND_NODENAPMACH_SEND_NOIMPORTANCEMACH_SEND_TRAILERMACH_SEND_FILTER_NONFATALMACH_SEND_ALWAYSMACH_SEND_NOTIFYMACH_SEND_INTERRUPTMACH_SEND_OVERRIDEMACH_SEND_TIMEOUTMACH_RCV_LARGE_IDENTITYMACH_RCV_LARGEMACH_RCV_MSGMACH_SEND_MSGMACH_MSG_OPTION_NONEMACH_MSG_TYPE_PORT_ANY_RIGHT(x)(((x) >= MACH_MSG_TYPE_MOVE_RECEIVE) && ((x) <= MACH_MSG_TYPE_MOVE_SEND_ONCE))MACH_MSG_TYPE_PORT_ANY_SEND(x)(((x) >= MACH_MSG_TYPE_MOVE_SEND) && ((x) <= MACH_MSG_TYPE_MAKE_SEND_ONCE))MACH_MSG_TYPE_PORT_ANY(x)(((x) >= MACH_MSG_TYPE_MOVE_RECEIVE) && ((x) <= MACH_MSG_TYPE_MAKE_SEND_ONCE))MACH_MSG_TYPE_POLYMORPHIC((mach_msg_type_name_t) -1)MACH_MSG_TYPE_LASTMACH_MSG_TYPE_PORT_SEND_ONCEMACH_MSG_TYPE_MOVE_SEND_ONCEMACH_MSG_TYPE_PORT_SENDMACH_MSG_TYPE_MOVE_SENDMACH_MSG_TYPE_PORT_RECEIVEMACH_MSG_TYPE_MOVE_RECEIVEMACH_MSG_TYPE_PORT_NAMEMACH_MSG_TYPE_PORT_NONEmach_msg_kind_tmsgh_kindMACH_MSGH_KIND_NOTIFICATIONMACH_MSGH_KIND_NORMALMACH_MSG_SIZE_RELIABLE((mach_msg_size_t) 256 * 1024)MACH_MSG_SIZE_MAX((mach_msg_size_t) ~0)round_msg(x)(((mach_msg_size_t)(x) + sizeof (natural_t) - 1) & ~(sizeof (natural_t) - 1))KERNEL_AUDIT_TOKEN_VALUE{ {0, 0, 0, 0, 0, 0, 0, 0} }KERNEL_SECURITY_TOKEN_VALUE{ {0, 1} }MACH_MSG_TRAILER_FORMAT_0_SIZEsizeof(mach_msg_format_0_trailer_t)MAX_TRAILER_SIZE((mach_msg_size_t)sizeof(mach_msg_max_trailer_t))MACH_MSG_TRAILER_MINIMUM_SIZEsizeof(mach_msg_trailer_t)MACH_MSG_FILTER_POLICY_ALLOW(mach_msg_filter_id)0MACH_MSG_TRAILER_FORMAT_0MACH_MSG_NULL((mach_msg_header_t *) 0)msgh_reservedMACH_MSG_DESCRIPTOR_NULL((mach_msg_descriptor_t *) 0)MACH_MSG_BODY_NULL((mach_msg_body_t *) 0)MACH_MSG_GUARDED_PORT_DESCRIPTORMACH_MSG_OOL_VOLATILE_DESCRIPTORMACH_MSG_OOL_PORTS_DESCRIPTORMACH_MSG_OOL_DESCRIPTORMACH_MSG_PORT_DESCRIPTORMACH_MSG_GUARD_FLAGS_MASKMACH_MSG_GUARD_FLAGS_UNGUARDED_ON_SENDMACH_MSG_GUARD_FLAGS_IMMOVABLE_RECEIVEMACH_MSG_GUARD_FLAGS_NONEMACH_MSG_OVERWRITEMACH_MSG_ALLOCATEMACH_MSG_VIRTUAL_COPYMACH_MSG_PHYSICAL_COPYMACH_MSG_TYPE_DISPOSE_SEND_ONCEMACH_MSG_TYPE_DISPOSE_SENDMACH_MSG_TYPE_DISPOSE_RECEIVEMACH_MSG_TYPE_COPY_RECEIVEMACH_MSG_TYPE_MAKE_SEND_ONCEMACH_MSG_TYPE_MAKE_SENDMACH_MSG_TYPE_COPY_SENDMACH_MSG_PRIORITY_UNSPECIFIED(mach_msg_priority_t) 0MACH_MSG_SIZE_NULL(mach_msg_size_t *) 0MACH_MSGH_BITS_HOLDS_IMPORTANCE_ASSERTION(bits)(((bits) & MACH_MSGH_BITS_IMPHOLDASRT) != MACH_MSGH_BITS_ZERO)MACH_MSGH_BITS_RAISED_IMPORTANCE(bits)(((bits) & MACH_MSGH_BITS_RAISEIMP) != MACH_MSGH_BITS_ZERO)MACH_MSGH_BITS_IS_COMPLEX(bits)(((bits) & MACH_MSGH_BITS_COMPLEX) != MACH_MSGH_BITS_ZERO)MACH_MSGH_BITS_HAS_VOUCHER(bits)(MACH_MSGH_BITS_VOUCHER(bits) != MACH_MSGH_BITS_ZERO)MACH_MSGH_BITS_HAS_LOCAL(bits)(MACH_MSGH_BITS_LOCAL(bits) != MACH_MSGH_BITS_ZERO)MACH_MSGH_BITS_HAS_REMOTE(bits)(MACH_MSGH_BITS_REMOTE(bits) != MACH_MSGH_BITS_ZERO)MACH_MSGH_BITS_OTHER(bits)((bits) &~ MACH_MSGH_BITS_PORTS_MASK)MACH_MSGH_BITS_PORTS(bits)((bits) & MACH_MSGH_BITS_PORTS_MASK)MACH_MSGH_BITS_VOUCHER(bits)(((bits) & MACH_MSGH_BITS_VOUCHER_MASK) >> 16)MACH_MSGH_BITS_LOCAL(bits)(((bits) & MACH_MSGH_BITS_LOCAL_MASK) >> 8)MACH_MSGH_BITS_REMOTE(bits)((bits) & MACH_MSGH_BITS_REMOTE_MASK)MACH_MSGH_BITS_SET(remote,local,voucher,other)(MACH_MSGH_BITS_SET_PORTS((remote), (local), (voucher)) | ((other) &~ MACH_MSGH_BITS_PORTS_MASK))MACH_MSGH_BITS_SET_PORTS(remote,local,voucher)(((remote) & MACH_MSGH_BITS_REMOTE_MASK) | (((local) << 8) & MACH_MSGH_BITS_LOCAL_MASK) | (((voucher) << 16) & MACH_MSGH_BITS_VOUCHER_MASK))MACH_MSGH_BITS(remote,local)((remote) | ((local) << 8))MACH_MSGH_BITS_USED0xb01f1f1fUMACH_MSGH_BITS_CIRCULAR0x10000000UMACH_MSGH_BITS_DENAPHOLDASRTMACH_MSGH_BITS_IMPHOLDASRTMACH_MSGH_BITS_DENAPMACH_MSGH_BITS_RAISEIMP0x20000000UMACH_MSGH_BITS_USER0x801f1f1fUMACH_MSGH_BITS_COMPLEX0x80000000UMACH_MSGH_BITS_PORTS_MASK(MACH_MSGH_BITS_REMOTE_MASK | MACH_MSGH_BITS_LOCAL_MASK | MACH_MSGH_BITS_VOUCHER_MASK)MACH_MSGH_BITS_VOUCHER_MASK0x001f0000MACH_MSGH_BITS_LOCAL_MASK0x00001f00MACH_MSGH_BITS_REMOTE_MASK0x0000001fMACH_MSGH_BITS_ZEROMACH_MSG_TIMEOUT_NONE((mach_msg_timeout_t) 0)_MACH_MESSAGE_H_MACH_KERNELpack(push, 4)!defined(__LP64__)pack(pop)defined(__APPLE_API_PRIVATE)/* _MACH_MESSAGE_H_ *//*
 *	Routine:	mach_voucher_deallocate
 *	Purpose:
 *		Deallocate a mach voucher created or received in a message.  Drops
 *		one (send right) reference to the voucher.
 *//*
 *	Routine:	mach_msg
 *	Purpose:
 *		Send and/or receive a message.  If the message operation
 *		is interrupted, and the user did not request an indication
 *		of that fact, then restart the appropriate parts of the
 *		operation silently (trap version does not restart).
 *//*
 *	Routine:	mach_msg_overwrite
 *	Purpose:
 *		Send and/or receive a message.  If the message operation
 *		is interrupted, and the user did not request an indication
 *		of that fact, then restart the appropriate parts of the
 *		operation silently (trap version does not restart).
 *
 *		Distinct send and receive buffers may be specified.  If
 *		no separate receive buffer is specified, the msg parameter
 *		will be used for both send and receive operations.
 *
 *		In addition to a distinct receive buffer, that buffer may
 *		already contain scatter control information to direct the
 *		receiving of the message.
 *//* invalid reply port used in a STRICT_REPLY message *//* Waiting for receive with timeout. (Internal use only.) *//* trailer type or number of trailer elements not supported *//* Out-of-line overwrite region is not large enough *//* Invalid msg-type specification in scatter list. *//* Error receiving message body.  See special bits. *//* Error receiving message header.  See special bits. *//* compatibility: no longer a returned error *//* Port/set was sent away/died during receive. *//* Bogus message buffer for inline data. *//* Bogus notify port argument. *//* Software interrupt. *//* Message buffer is not large enough for inline data. *//* Didn't get a message within the timeout value. *//* Bogus name for receive port/port-set. *//* Thread is waiting for receive.  (Internal use only.) *//* Message send was rejected by message filter *//* The destination port doesn't accept ports in body *//* The sending thread context did not match the context on the dest port *//* The trailer to be sent does not match kernel format. *//* A field in the header had a bad value. *//* Invalid msg-type specification. *//* Send is too large for port *//* No message buffer is available. *//* Invalid out-of-line memory pointer. *//* Bogus port rights in the message body. *//* Bogus reply port. *//* Data doesn't contain a complete message. *//* Bogus voucher port. *//* Message not sent before timeout expired. *//* Bogus destination port. *//* Bogus in-line data. *//* Thread is waiting to send.  (Internal use only.) *//* Kernel resource shortage handling out-of-line memory. *//* Kernel resource shortage handling an IPC capability. *//* No room in VM address space for out-of-line memory. *//* No room in IPC name space for another capability name. *//* All special error code bits defined below. *//*
 *  Much code assumes that mach_msg_return_t == kern_return_t.
 *  This definition is useful for descriptive purposes.
 *
 *  See <mach/error.h> for the format of error codes.
 *  IPC errors are system 4.  Send errors are subsystem 0;
 *  receive errors are subsystem 1.  The code field is always non-zero.
 *  The high bits of the code field communicate extra information
 *  for some error codes.  MACH_MSG_MASK masks off these special bits.
 *//*
 * XXXMAC: note that in the case of MACH_RCV_TRAILER_LABELS,
 * we just fall through to mach_msg_max_trailer_t.
 * This is correct behavior since mach_msg_max_trailer_t is defined as
 * mac_msg_mac_trailer_t which is used for the LABELS trailer.
 * It also makes things work properly if MACH_RCV_TRAILER_LABELS is ORed
 * with one of the other options.
 *//*
 * NOTE: a 0x00------ RCV mask implies to ask for
 * a MACH_MSG_TRAILER_FORMAT_0 with 0 Elements,
 * which is equivalent to a mach_msg_trailer_t.
 *
 * XXXMAC: unlike the rest of the MACH_RCV_* flags, MACH_RCV_TRAILER_LABELS
 * needs its own private bit since we only calculate its fields when absolutely
 * required.
 *//* Enforce specific properties about the reply port, and
	                                         * the context in which a thread replies to a message.
	                                         * This flag must be passed on both the SEND and RCV *//* sync waiter waiting to peek *//* sync waiter waiting for rcv *//* Can receive new guarded descriptor *//* scatter receive (deprecated) *//* willing to receive voucher port *//* don't restart interrupted receive *//* legacy name (value was: 0x00000200) *//* timeout value applies to receive *//* special reply port should boost thread doing sync bootstrap checkin *//* full send from kernel space - kernel only *//* obsolete name *//* IPC should propagate the caller's QoS *//* msg should do sync IPC override (on legacy kernels) *//* msg carries importance - kernel only *//* msg won't carry importance *//* sender-provided trailer *//* rejection by message filter should return failure - user only *//* ignore qlimits - kernel only *//* arm send-possible notify *//* don't restart interrupted sends *//* priority override for send *//* timeout value applies to send *//* identify source of large messages *//* report large message sizes *//*
 *	Is a given item a port type?
 *//*
 *  A dummy value.  Mostly used to indicate that the actual value
 *  will be filled in later, dynamically.
 *//* Last assigned *//*
 *  Values received/carried in messages.  Tells the receiver what
 *  sort of port right he now has.
 *
 *  MACH_MSG_TYPE_PORT_NAME is used to transfer a port name
 *  which should remain uninterpreted by the kernel.  (Port rights
 *  are not transferred, just the port name.)
 *//*
 *  Compatibility definitions, for code written
 *  when there was a msgh_kind instead of msgh_seqno.
 *//*
 *  But architectural limits of a given implementation, or
 *  temporal conditions may cause unpredictable send failures
 *  for messages larger than MACH_MSG_SIZE_RELIABLE.
 *
 *  In either case, waiting for memory is [currently] outside
 *  the scope of send timeout values provided to IPC.
 *//*
 *  There is no fixed upper bound to the size of Mach messages.
 *//* utility to round the message size - will become machine dependent *//*typedef mach_msg_mac_trailer_t mach_msg_format_0_trailer_t;
 *//*
 * Legacy requirements keep us from ever updating these defines (even
 * when the format_0 trailers gain new option data fields in the future).
 * Therefore, they shouldn't be used going forward.  Instead, the sizes
 * should be compared against the specific element size requested using
 * REQUESTED_TRAILER_SIZE.
 *//*
 * These values can change from release to release - but clearly
 * code cannot request additional trailer elements one was not
 * compiled to understand.  Therefore, it is safe to use this
 * constant when the same module specified the receive options.
 * Otherwise, you run the risk that the options requested by
 * another module may exceed the local modules notion of
 * MAX_TRAILER_SIZE.
 *//*
 *  Trailer type to pass MAC policy label info as a mach message trailer.
 *
 *//*
 * The audit token is an opaque token which identifies
 * Mach tasks and senders of Mach messages as subjects
 * to the BSM audit system.  Only the appropriate BSM
 * library routines should be used to interpret the
 * contents of the audit token as the representation
 * of the subject identity within the token may change
 * over time.
 *//*
 *  The msgh_seqno field carries a sequence number
 *  associated with the received-from port.  A port's
 *  sequence number is incremented every time a message
 *  is received from it and included in the received
 *  trailer to help put messages back in sequence if
 *  multiple threads receive and/or process received
 *  messages.
 *//*
 * LP64support - This union definition is not really
 * appropriate in LP64 mode because not all descriptors
 * are of the same size in that environment.
 *//* defined(__LP64__) */// Pad to 8 bytes everywhere except the K64 kernel where mach_port_t is 8 bytes/*
 * In a complex mach message, the mach_msg_header_t is followed by
 * a descriptor count, then an array of that number of descriptors
 * (mach_msg_*_descriptor_t). The type field of mach_msg_type_descriptor_t
 * (which any descriptor can be cast to) indicates the flavor of the
 * descriptor.
 *
 * Note that in LP64, the various types of descriptors are no longer all
 * the same size as mach_msg_descriptor_t, so the array cannot be indexed
 * as expected.
 *//* Valid flag bits *//* Verify that the port is unguarded *//* Move the receive right and mark it as immovable *//* MACH_KERNEL *//* deprecated *//* must hold sendonce right *//* must hold send right(s) *//* must hold receive right *//* NOT VALID *//* Must hold receive right *//* Must hold send right(s) *//* Must hold sendonce right *//*
 *  Every message starts with a message header.
 *  Following the message header, if the message is complex, are a count
 *  of type descriptors and the type descriptors themselves
 *  (mach_msg_descriptor_t). The size of the message must be specified in
 *  bytes, and includes the message header, descriptor count, descriptors,
 *  and inline data.
 *
 *  The msgh_remote_port field specifies the destination of the message.
 *  It must specify a valid send or send-once right for a port.
 *
 *  The msgh_local_port field specifies a "reply port".  Normally,
 *  This field carries a send-once right that the receiver will use
 *  to reply to the message.  It may carry the values MACH_PORT_NULL,
 *  MACH_PORT_DEAD, a send-once right, or a send right.
 *
 *  The msgh_voucher_port field specifies a Mach voucher port. Only
 *  send rights to kernel-implemented Mach Voucher kernel objects in
 *  addition to MACH_PORT_NULL or MACH_PORT_DEAD may be passed.
 *
 *  The msgh_id field is uninterpreted by the message primitives.
 *  It normally carries information specifying the format
 *  or meaning of the message.
 *//* importance checking macros *//* checking macros *//* getter macros for pulling values out of the bits field *//* legacy *//* setter macros for the bits *//* message circular, kernel private *//* assertion help, userland private *//* importance raised due to msg *//* allowed bits user->kernel *//* message is complex *//*
 *  The kernel uses MACH_MSGH_BITS_COMPLEX as a hint.  If it isn't on, it
 *  assumes the body of the message doesn't contain port rights or OOL
 *  data.  The field is set in received messages.  A user task must
 *  use caution in interpreting the body of a message if the bit isn't
 *  on, because the mach_msg_type's in the body might "lie" about the
 *  contents.  If the bit isn't on, but the mach_msg_types
 *  in the body specify rights or OOL data, the behavior is undefined.
 *  (Ie, an error may or may not be produced.)
 *
 *  The value of MACH_MSGH_BITS_REMOTE determines the interpretation
 *  of the msgh_remote_port field.  It is handled like a msgt_name,
 *  but must result in a send or send-once type right.
 *
 *  The value of MACH_MSGH_BITS_LOCAL determines the interpretation
 *  of the msgh_local_port field.  It is handled like a msgt_name,
 *  and also must result in a send or send-once type right.
 *
 *  The value of MACH_MSGH_BITS_VOUCHER determines the interpretation
 *  of the msgh_voucher_port field.  It is handled like a msgt_name,
 *  but must result in a send right (and the msgh_voucher_port field
 *  must be the name of a send right to a Mach voucher kernel object.
 *
 *  MACH_MSGH_BITS() combines two MACH_MSG_TYPE_* values, for the remote
 *  and local fields, into a single value suitable for msgh_bits.
 *
 *  MACH_MSGH_BITS_CIRCULAR should be zero; is is used internally.
 *
 *  The unused bits should be zero and are reserved for the kernel
 *  or for future interface expansion.
 *//*
 *  The value to be used when there is no timeout.
 *  (No MACH_SEND_TIMEOUT/MACH_RCV_TIMEOUT option.)
 *//*
 *  The timeout mechanism uses mach_msg_timeout_t values,
 *  passed by value.  The timeout units are milliseconds.
 *  It is controlled with the MACH_SEND_TIMEOUT
 *  and MACH_RCV_TIMEOUT options.
 *//*
 *	File:	mach/message.h
 *
 *	Mach IPC message and primitive function definitions.
 *//*
 * NOTICE: This file was modified by McAfee Research in 2004 to introduce
 * support for mandatory and extensible security protections.  This notice
 * is included in support of clause 2.2 (b) of the Apple Public License,
 * Version 2.0.
 * Copyright (c) 2005 SPARTA, Inc.
 */vouchersend_sizercv_sizercv_namenotifyrcv_msgrcv_limit/Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX.sdk/usr/include/machine/_param.h_BSD_MACHINE__PARAM_H_/* _BSD_MACHINE__PARAM_H_ *//*
 * Copyright (c) 2004-2007 Apple Inc. All rights reserved.
 *
 * @APPLE_OSREFERENCE_LICENSE_HEADER_START@
 *
 * This file contains Original Code and/or Modifications of Original Code
 * as defined in and that are subject to the Apple Public Source License
 * Version 2.0 (the 'License'). You may not use this file except in
 * compliance with the License. The rights granted to you under the License
 * may not be used to create, or enable the creation or redistribution of,
 * unlawful or unlicensed copies of an Apple operating system, or to
 * circumvent, violate, or enable the circumvention or violation of, any
 * terms of an Apple operating system software license agreement.
 *
 * Please obtain a copy of the License at
 * http://www.opensource.apple.com/apsl/ and read it before using this file.
 *
 * The Original Code and all software distributed under the License are
 * distributed on an 'AS IS' basis, WITHOUT WARRANTY OF ANY KIND, EITHER
 * EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES,
 * INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE, QUIET ENJOYMENT OR NON-INFRINGEMENT.
 * Please see the License for the specific language governing rights and
 * limitations under the License.
 *
 * @APPLE_OSREFERENCE_LICENSE_HEADER_END@
 *//Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX.sdk/usr/include/net/net_kev.hKEV_INET6_REQUEST_NAT64_PREFIXKEV_INET6_DEFROUTERKEV_INET6_NEW_RTADV_ADDRKEV_INET6_NEW_LL_ADDRKEV_INET6_ADDR_DELETEDKEV_INET6_CHANGED_ADDRKEV_INET6_NEW_USER_ADDRKEV_INET6_SUBCLASSKEV_DL_MASTER_ELECTED(_Pragma("gcc warn Use KEV_DL_PRIMARY_ELECTED instead") KEV_DL_PRIMARY_ELECTED)KEV_DL_LOW_POWER_MODE_CHANGEDKEV_DL_QOS_MODE_CHANGEDKEV_DL_RRC_STATE_CHANGEDKEV_DL_AWDL_UNRESTRICTEDKEV_DL_AWDL_RESTRICTEDKEV_DL_IFDELEGATE_CHANGEDKEV_DL_ISSUESKEV_DL_PRIMARY_ELECTEDKEV_DL_NODE_ABSENCEKEV_DL_NODE_PRESENCEKEV_DL_LINK_QUALITY_METRIC_CHANGEDKEV_DL_IFCAP_CHANGEDKEV_DL_IF_IDLE_ROUTE_REFCNTKEV_DL_WAKEFLAGS_CHANGEDKEV_DL_LINK_ADDRESS_CHANGEDKEV_DL_PROTO_DETACHEDKEV_DL_PROTO_ATTACHEDKEV_DL_LINK_ONKEV_DL_LINK_OFFKEV_DL_IF_DETACHEDKEV_DL_IF_DETACHINGKEV_DL_IF_ATTACHEDKEV_DL_DELMULTIKEV_DL_ADDMULTIKEV_DL_SIFGENERICKEV_DL_SIFMEDIAKEV_DL_SIFPHYSKEV_DL_SIFMTUKEV_DL_SIFMETRICSKEV_DL_SIFFLAGSKEV_DL_SUBCLASSKEV_INET_ARPRTRALIVEKEV_INET_ARPRTRFAILUREKEV_INET_PORTINUSEKEV_INET_ARPCOLLISIONKEV_INET_SIFNETMASKKEV_INET_SIFBRDADDRKEV_INET_SIFDSTADDRKEV_INET_ADDR_DELETEDKEV_INET_CHANGED_ADDRKEV_INET_NEW_ADDRKEV_INET_SUBCLASS_NET_NETKEV_H_/* _NET_NETKEV_H_ *//* Asking for the NAT64-prefix *//* Default router detected *//* Autoconf address has appeared *//* Autoconf LL address appeared *//* IPv6 address was deleted *//* Address changed event (future) *//* Userland configured IPv6 address *//* KEV_INET6_SUBCLASS event codes *//* inet6 subclass *//*
 * Define Data-Link event subclass, and associated
 * events.
 *//* Data Link subclass *//* ARP resolution succeeded for router *//* ARP resolution failed for router *//* use ken_in_portinuse *//* ARP collision detected *//* Netmask was set *//* Broadcast address was set *//* Dest. address was set *//* Address changed event *//* Userland configured IP address *//* KEV_INET_SUBCLASS event codes *//* inet subclass *//* Kernel event subclass identifiers for KEV_NETWORK_CLASS *//*
 * Copyright (c) 2016-2018 Apple Inc. All rights reserved.
 *
 * @APPLE_OSREFERENCE_LICENSE_HEADER_START@
 *
 * This file contains Original Code and/or Modifications of Original Code
 * as defined in and that are subject to the Apple Public Source License
 * Version 2.0 (the 'License'). You may not use this file except in
 * compliance with the License. The rights granted to you under the License
 * may not be used to create, or enable the creation or redistribution of,
 * unlawful or unlicensed copies of an Apple operating system, or to
 * circumvent, violate, or enable the circumvention or violation of, any
 * terms of an Apple operating system software license agreement.
 *
 * Please obtain a copy of the License at
 * http://www.opensource.apple.com/apsl/ and read it before using this file.
 *
 * The Original Code and all software distributed under the License are
 * distributed on an 'AS IS' basis, WITHOUT WARRANTY OF ANY KIND, EITHER
 * EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES,
 * INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE, QUIET ENJOYMENT OR NON-INFRINGEMENT.
 * Please see the License for the specific language governing rights and
 * limitations under the License.
 *
 * @APPLE_OSREFERENCE_LICENSE_HEADER_END@
 *//Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX.sdk/usr/include/net/Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX.sdk/usr/include/sys/_types/_sa_family_t.hsa_family_t_SA_FAMILY_T/* _SA_FAMILY_T *//* __uint8_t *//Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX.sdk/usr/include/sys/_types/_socklen_t.hsocklen_t_SOCKLEN_T/* __darwin_socklen_t *//Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX.sdk/usr/include/sys/_types/_iovec_t.hiovec &const iovecconst iovec &ioveciov_leniov_base_STRUCT_IOVEC/* _STRUCT_IOVEC *//* [XSI] Size of region iov_base points to *//* [XSI] Base address of I/O memory region *//* size_t *//Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX.sdk/usr/include/sys/socket.h<sys/_types/_iovec_t.h><sys/_types/_socklen_t.h><sys/_types/_sa_family_t.h><net/net_kev.h><machine/_param.h>disconnectxconnectxconst sa_endpoints_tconst sa_endpoints_t *sa_endpoints *const iovec *iovec *sae_connid_t *pfctlinputsockaddr *sendfileoff_t *sf_hdtr *socketpairsocketsockatmarkshutdownsetsockoptsendtoconst sockaddrconst sockaddr *sendmsgconst msghdrconst msghdr *msghdr *recvmsgrecvfromsocklen_t *recvlistengetsockoptgetsocknamegetpeernameconnectbindsf_hdtr &const sf_hdtrconst sf_hdtr &cmsghdr &const cmsghdrconst cmsghdr &msghdr &const msghdr &sockaddr_storage &const sockaddr_storageconst sockaddr_storage &sockproto &const sockprotoconst sockproto &so_np_extensions &const so_np_extensionsconst so_np_extensions &linger &const lingerconst linger &sa_endpoints &const sa_endpointsconst sa_endpoints &sockaddr &const sockaddr &sf_hdtrcmsghdrmsghdrsockaddr_storagesockprotoso_np_extensionslingersa_endpoints_tsa_endpointssockaddrsae_connid_tsae_associd_ttrl_cnttrailershdr_cntheaderscmsg_typecmsg_levelcmsg_lenmsg_flagsmsg_controllenmsg_controlmsg_iovlenmsg_iovmsg_namelenmsg_name_SS_PAD2SIZE__ss_pad2__ss_align_SS_PAD1SIZE__ss_pad1ss_familyss_lensp_protocolsp_familynpx_masknpx_flagsl_lingerl_onoffsae_dstaddrlensae_dstaddrsae_srcaddrlensae_srcaddrsa_datasa_familysa_lensae_srcifSHUT_RDWRSHUT_WRSHUT_RDSCM_TIMESTAMP_MONOTONICSCM_CREDSSCM_TIMESTAMPSCM_RIGHTSCMSG_LEN(l)(__DARWIN_ALIGN32(sizeof(struct cmsghdr)) + (l))CMSG_SPACE(l)(__DARWIN_ALIGN32(sizeof(struct cmsghdr)) + __DARWIN_ALIGN32(l))CMSG_NXTHDR(mhdr,cmsg)((char *)(cmsg) == (char *)0L ? CMSG_FIRSTHDR(mhdr) : ((((unsigned char *)(cmsg) + __DARWIN_ALIGN32((__uint32_t)(cmsg)->cmsg_len) + __DARWIN_ALIGN32(sizeof(struct cmsghdr))) > ((unsigned char *)(mhdr)->msg_control + (mhdr)->msg_controllen)) ? (struct cmsghdr *)0L : (struct cmsghdr *)(void *)((unsigned char *)(cmsg) + __DARWIN_ALIGN32((__uint32_t)(cmsg)->cmsg_len))))CMSG_FIRSTHDR(mhdr)((mhdr)->msg_controllen >= sizeof(struct cmsghdr) ? (struct cmsghdr *)(mhdr)->msg_control : (struct cmsghdr *)0L)CMSG_DATA(cmsg)((unsigned char *)(cmsg) + __DARWIN_ALIGN32(sizeof(struct cmsghdr)))MSG_NOSIGNALMSG_NEEDSAMSG_RCVMOREMSG_HAVEMOREMSG_SENDMSG_HOLDMSG_FLUSHMSG_WAITSTREAMMSG_EOFMSG_DONTWAITMSG_WAITALLMSG_CTRUNCMSG_TRUNCMSG_EORMSG_DONTROUTEMSG_PEEKMSG_OOBSOMAXCONNNET_RT_MAXIDNET_RT_FLAGS_PRIVNET_RT_DUMP2NET_RT_IFLIST2NET_RT_TRASHNET_RT_STATNET_RT_IFLISTNET_RT_FLAGSNET_RT_DUMPNET_MAXIDAF_MAXPF_BOND((uint32_t)0x626f6e64)PF_VLAN((uint32_t)0x766c616e)PF_MAXPF_VSOCKAF_VSOCKPF_UTUNAF_UTUNPF_RESERVED_36AF_RESERVED_36PF_PPPAF_PPPPF_NETBIOSAF_NETBIOSPF_SYSTEMAF_SYSTEMPF_NATMAF_NATMPF_INET6AF_INET6PF_KEYpseudo_AF_KEYPF_ISDNAF_ISDNPF_NDRVAF_NDRVPF_PIPpseudo_AF_PIPPF_RTIPpseudo_AF_RTIPPF_IPXAF_IPXPF_SIPAF_SIPPF_CNTAF_CNTPF_COIPAF_COIPPF_XTPpseudo_AF_XTPPF_LINKAF_LINKPF_ROUTEAF_ROUTEPF_APPLETALKAF_APPLETALKPF_HYLINKAF_HYLINKPF_LATAF_LATPF_DLIAF_DLIPF_DECnetAF_DECnetPF_SNAAF_SNAPF_CCITTAF_CCITTPF_DATAKITAF_DATAKITPF_ECMAAF_ECMAPF_OSIAF_ISOPF_ISOPF_NSAF_NSPF_CHAOSAF_CHAOSPF_PUPAF_PUPPF_IMPLINKAF_IMPLINKPF_INETAF_INETPF_UNIXPF_LOCALAF_LOCALPF_UNSPECAF_UNSPEC(_SS_MAXSIZE - sizeof(__uint8_t) - sizeof(sa_family_t) - _SS_PAD1SIZE - _SS_ALIGNSIZE)(_SS_ALIGNSIZE - sizeof(__uint8_t) - sizeof(sa_family_t))_SS_ALIGNSIZE(sizeof(__int64_t))_SS_MAXSIZESOCK_MAXADDRLENAF_IEEE80211pseudo_AF_HDRCMPLTAF_E164AF_OSIAF_UNIXSOL_SOCKETSONPX_SETOPTSHUT0x000000001CONNECT_DATA_AUTHENTICATEDCONNECT_DATA_IDEMPOTENTCONNECT_RESUME_ON_READ_WRITESAE_CONNID_ALL((sae_connid_t)(-1ULL))SAE_CONNID_ANYSAE_ASSOCID_ALL((sae_associd_t)(-1ULL))SAE_ASSOCID_ANYNETSVC_MRKNG_LVL_L3L2_BKNETSVC_MRKNG_LVL_L3L2_ALLNETSVC_MRKNG_LVL_L2NETSVC_MRKNG_UNKNOWNNET_SERVICE_TYPE_RDNET_SERVICE_TYPE_OAMNET_SERVICE_TYPE_AVNET_SERVICE_TYPE_RVNET_SERVICE_TYPE_VONET_SERVICE_TYPE_VINET_SERVICE_TYPE_SIGNET_SERVICE_TYPE_BKNET_SERVICE_TYPE_BESO_NETSVC_MARKING_LEVEL0x1119SO_NET_SERVICE_TYPE0x1116SO_NUMRCVPKT0x1112SO_NP_EXTENSIONS0x1083SO_RANDOMPORT0x1082SO_LINGER_SEC0x1080SO_UPCALLCLOSEWAIT0x1027SO_NOTIFYCONFLICT0x1026SO_REUSESHAREUID0x1025SO_NWRITE0x1024SO_NOADDRERR0x1023SO_NOSIGPIPESO_NKESO_NREADSO_PEERLABELSO_LABELSO_TYPE0x1008SO_ERROR0x1007SO_RCVTIMEO0x1006SO_SNDTIMEO0x1005SO_RCVLOWATSO_SNDLOWATSO_RCVBUFSO_SNDBUFSO_WANTOOBFLAGSO_WANTMORESO_DONTTRUNCSO_TIMESTAMP_MONOTONICSO_TIMESTAMPSO_REUSEPORTSO_OOBINLINESO_LINGERSO_USELOOPBACKSO_BROADCASTSO_DONTROUTESO_KEEPALIVESO_REUSEADDRSO_ACCEPTCONNSO_DEBUGSOCK_SEQPACKETSOCK_RDMSOCK_RAWSOCK_DGRAMSOCK_STREAM_SYS_SOCKET_H_10.119.0macosx(10.11), ios(9.0), tvos(9.0), watchos(2.0)macosx(10.11)ios(9.0)tvos(9.0)watchos(2.0)/* !_SYS_SOCKET_H_ *//* number of trailer iovec's *//* pointer to an array of trailer struct iovec's *//* number of header iovec's *//* pointer to an array of header struct iovec's *//*
 * sendfile(2) header/trailer struct
 *//* shut down both sides *//* shut down the writing side *//* shut down the reading side *//*
 * howto arguments for shutdown(2), specified by Posix.1g.
 *//* timestamp (uint64_t) *//* process creds (struct cmsgcred) *//* timestamp (struct timeval) *//* access rights (array of int) *//* "Socket"-level control message types: *//* RFC 2292 additions *//*
 * Given pointer to struct cmsghdr, return pointer to next cmsghdr
 * RFC 2292 says that CMSG_NXTHDR(mhdr, NULL) is equivalent to CMSG_FIRSTHDR(mhdr)
 *//*
 * RFC 2292 requires to check msg_controllen, in case that the kernel returns
 * an empty list for some reasons.
 *//* given pointer to struct cmsghdr, return pointer to data *//* groups *//* number or groups *//* real GID of sending process *//* effective UID of sending process *//* real UID of sending process *//* PID of sending process *//*
 * Credentials structure, used to verify the identity of a peer
 * process that has sent us a message. This is allocated by the
 * peer process but filled in by the kernel. This prevents the
 * peer from lying about its identity. (Note that cmcred_groups[0]
 * is the effective GID.)
 *//*
 * While we may have more groups than this, the cmsgcred struct must
 * be able to fit in an mbuf, and NGROUPS_MAX is too large to allow
 * this.
 *//* followed by	unsigned char  cmsg_data[]; *//* [XSI] protocol-specific type *//* [XSI] originating protocol *//* [XSI] data byte count, including hdr *//*
 * Header for ancillary data objects in msg_control buffer.
 * Used for additional information with/about a datagram
 * not expressible by flags.  The format is a sequence
 * of message elements headed by cmsghdr structures.
 *//* do not generate SIGPIPE on EOF *//* Fail receive if socket address cannot be allocated *//* Data remains in current pkt *//* Data ready to be read *//* Send the packet in so_temp, deprecated *//* Hold frag in so_temp, deprecated *//* Start of 'hold' seq; dump so_temp, deprecated *//* wait up to full request.. may return partial *//* data completes connection *//* this message should be nonblocking *//* wait for full request or error *//* control data lost before delivery *//* data discarded before delivery *//* data completes record *//* send without using routing tables *//* peek at incoming message *//* process out-of-band data *//* [XSI] flags on received message *//* [XSI] ancillary data buffer len *//* [XSI] ancillary data, see below *//* [XSI] # elements in msg_iov *//* [XSI] scatter/gather array *//* [XSI] size of address *//* [XSI] optional address *//*
 * [XSI] Message header for recvmsg and sendmsg calls.
 * Used value-result for recvmsg, value only for sendmsg.
 *//*
 * Maximum queue length specifiable by listen.
 *//*
 * Allows read access non-local host's MAC address
 * if the process has neighbor cache entitlement.
 *//* dump; may limit to a.f. *//* interface list with addresses *//* routes not in table but not freed *//* routing statistics *//* survey interface list *//* by flags, e.g. RESOLVING *//*
 * PF_ROUTE - Routing table
 *
 * Three additional levels are defined:
 *	Fourth: address family, 0 is wildcard
 *	Fifth: type of info, defined below
 *	Sixth: flag(s) to mask with for NET_RT_FLAGS
 *//*
 * Definitions for network related sysctl, CTL_NET.
 *
 * Second level is protocol family.
 * Third level is protocol number.
 *
 * Further levels are defined by the individual families below.
 *//* 'bond' *//* 'vlan' *//*
 * These do not have socket-layer support:
 *//* same format as AF_INET *//* same format as AF_NS *//* really just proto family, no AF *//*
 * Protocol families, same as address families for now.
 *//* force structure storage alignment *//* [XSI] address family *//* address length *//*
 * [XSI] sockaddr_storage
 *//*
 * RFC 2553: protocol-independent placeholder for socket addresses
 *//* protocol *//* address family *//*
 * Structure used by kernel to pass protocol
 * information in raw sockets.
 *//* longest possible addresses *//* [XSI] addr value (actually larger) *//* total length *//*
 * [XSI] Structure used by kernel to store most addresses.
 *//* VM Sockets *//* IEEE 802.11 protocol *//* Reserved for internal usage *//* Used by BPF to not rewrite headers
	                                 *  in interface output routine *//* PPP communication protocol *//* NetBIOS *//* Kernel event messages *//* native ATM access *//* IPv6 *//* Internal key-management function *//* CCITT E.164 recommendation *//* Integrated Services Digital Network *//* Network Driver 'raw' access *//* Help Identify PIP packets *//* Simple Internet Protocol *//* Novell Internet Protocol *//* Help Identify RTIP packets *//* Computer Network Technology *//* connection-oriented IP, aka ST II *//* eXpress Transfer Protocol (no AF) *//* Link layer interface *//* Internal Routing Protocol *//* Apple Talk *//* NSC Hyperchannel *//* LAT *//* DEC Direct data link interface *//* DECnet *//* IBM SNA *//* CCITT protocols, X.25 etc *//* datakit protocols *//* European computer manufacturers *//* ISO protocols *//* XEROX NS protocols *//* mit CHAOS protocols *//* pup protocols: e.g. BSP *//* arpanet imp addresses *//* internetwork: UDP, TCP, etc. *//* local to host (pipes) *//* unspecified *//*
 * Address families.
 *//* options for socket level *//*
 * Level number for (get/set)sockopt() to apply to socket itself.
 *//* flag for allowing setsockopt after shutdown *//*
 * Structure to control non-portable Sockets extension to POSIX
 *//* linger time *//* option on/off *//*
 * Structure used for manipulating linger option.
 *//* size of destination address *//* destination address *//* size of source address *//* optional source address *//* optional source interface *//* sockaddr endpoints *//* data includes security that replaces the TFO-cookie *//* data is idempotent *//* resume connect() on read/write *//* connectx() flag parameters *//* The system policy limits layer 3 DSCP marking and layer 2 marking
	                                         * to background Network Service Types *//* Layer 3 DSCP marking and layer 2 marking for all Network Service Types *//* Default marking at layer 2 (for example Wi-Fi WMM) *//* The outgoing network interface is not known *//* These are supported values for SO_NETSVC_MARKING_LEVEL *//* Responsive Data *//* Operations, Administration, and Management *//* Multimedia Audio/Video Streaming *//* Responsive Multimedia Audio/Video *//* Interactive Voice *//* Interactive Video *//* Signaling *//* Background system initiated *//* Best effort *//*
 * Network Service Type for option SO_NET_SERVICE_TYPE
 *
 * The vast majority of sockets should use Best Effort that is the default
 * Network Service Type. Other Network Service Types have to be used only if
 * the traffic actually matches the description of the Network Service Type.
 *
 * Network Service Types do not represent priorities but rather describe
 * different categories of delay, jitter and loss parameters.
 * Those parameters may influence protocols from layer 4 protocols like TCP
 * to layer 2 protocols like Wi-Fi. The Network Service Type can determine
 * how the traffic is queued and scheduled by the host networking stack and
 * by other entities on the network like switches and routers. For example
 * for Wi-Fi, the Network Service Type can select the marking of the
 * layer 2 packet with the appropriate WMM Access Category.
 *
 * There is no point in attempting to game the system and use
 * a Network Service Type that does not correspond to the actual
 * traffic characteristic but one that seems to have a higher precedence.
 * The reason is that for service classes that have lower tolerance
 * for delay and jitter, the queues size is lower than for service
 * classes that are more tolerant to delay and jitter.
 *
 * For example using a voice service type for bulk data transfer will lead
 * to disastrous results as soon as congestion happens because the voice
 * queue overflows and packets get dropped. This is not only bad for the bulk
 * data transfer but it is also bad for VoIP apps that legitimately are using
 * the voice  service type.
 *
 * The characteristics of the Network Service Types are based on the service
 * classes defined in RFC 4594 "Configuration Guidelines for DiffServ Service
 * Classes"
 *
 * When system detects the outgoing interface belongs to a DiffServ domain
 * that follows the recommendation of the IETF draft "Guidelines for DiffServ to
 * IEEE 802.11 Mapping", the packet will marked at layer 3 with a DSCP value
 * that corresponds to Network Service Type.
 *
 * NET_SERVICE_TYPE_BE
 *	"Best Effort", unclassified/standard.  This is the default service
 *	class and cover the majority of the traffic.
 *
 * NET_SERVICE_TYPE_BK
 *	"Background", high delay tolerant, loss tolerant. elastic flow,
 *	variable size & long-lived. E.g: non-interactive network bulk transfer
 *	like synching or backup.
 *
 * NET_SERVICE_TYPE_RD
 *	"Responsive Data", a notch higher than "Best Effort", medium delay
 *	tolerant, elastic & inelastic flow, bursty, long-lived. E.g. email,
 *	instant messaging, for which there is a sense of interactivity and
 *	urgency (user waiting for output).
 *
 * NET_SERVICE_TYPE_OAM
 *	"Operations, Administration, and Management", medium delay tolerant,
 *	low-medium loss tolerant, elastic & inelastic flows, variable size.
 *	E.g. VPN tunnels.
 *
 * NET_SERVICE_TYPE_AV
 *	"Multimedia Audio/Video Streaming", medium delay tolerant, low-medium
 *	loss tolerant, elastic flow, constant packet interval, variable rate
 *	and size. E.g. video and audio playback with buffering.
 *
 * NET_SERVICE_TYPE_RV
 *	"Responsive Multimedia Audio/Video", low delay tolerant, low-medium
 *	loss tolerant, elastic flow, variable packet interval, rate and size.
 *	E.g. screen sharing.
 *
 * NET_SERVICE_TYPE_VI
 *	"Interactive Video", low delay tolerant, low-medium loss tolerant,
 *	elastic flow, constant packet interval, variable rate & size. E.g.
 *	video telephony.
 *
 * NET_SERVICE_TYPE_SIG
 *	"Signaling", low delay tolerant, low loss tolerant, inelastic flow,
 *	jitter tolerant, rate is bursty but short, variable size. E.g. SIP.
 *
 * NET_SERVICE_TYPE_VO
 *	"Interactive Voice", very low delay tolerant, very low loss tolerant,
 *	inelastic flow, constant packet rate, somewhat fixed size.
 *	E.g. VoIP.
 *//* When adding new socket-options, you need to make sure MPTCP supports these as well! *//* Get QoS marking in effect for socket *//* Network service type *//* number of datagrams in receive socket buffer *//* To turn off some POSIX behavior *//* APPLE: request local port randomization *//* linger on close if data present (in seconds) *//* APPLE: block on close until an upcall returns *//* APPLE: send notification if there is a bind on a port which is already in use *//* APPLE: Allow reuse of port/socket by different userids *//* APPLE: Get number of bytes currently in send socket buffer *//* APPLE: Returns EADDRNOTAVAIL when src is not available anymore *//* APPLE: No SIGPIPE on EPIPE *//* APPLE: Install socket-level NKE *//* APPLE: get 1st-packet byte count *//* get socket type *//* get error status and clear *//* receive timeout *//* send timeout *//* receive low-water mark *//* send low-water mark *//* receive buffer size *//* send buffer size *//*
 * Additional options, not kept in so_options.
 *//* (!__APPLE__) *//* APPLE: Want OOB in MSG_FLAG on receive *//* APPLE: Give hint when more data ready *//*  (ATOMIC proto) *//* APPLE: Retain unread data *//* there is an accept filter *//* Monotonically increasing timestamp on rcvd dgram *//* timestamp received dgram traffic *//* allow local address & port reuse *//* leave received OOB data in line *//* linger on close if data present (in ticks) *//* bypass hardware when possible *//* permit sending of broadcast msgs *//* just use interface addresses *//* keep connections alive *//* allow local address reuse *//* socket has had listen() *//* turn on debugging info recording *//*
 * Option flags per-socket.
 *//* sequenced packet stream *//* reliably-delivered message *//* raw-protocol interface *//* datagram socket *//* stream socket *//*
 * Types
 *//*
 * [XSI] The iovec structure shall be defined as described in <sys/uio.h>.
 *//* XXX Not explicitly defined by POSIX, but function return types are *//*
 * Data types.
 *//*
 * Definitions related to sockets: types, address families, options.
 *//*
 * Copyright (c) 1982, 1985, 1986, 1988, 1993, 1994
 *	The Regents of the University of California.  All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *	This product includes software developed by the University of
 *	California, Berkeley and its contributors.
 * 4. Neither the name of the University nor the names of its contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 *
 *	@(#)socket.h	8.4 (Berkeley) 2/21/94
 * $FreeBSD: src/sys/sys/socket.h,v 1.39.2.7 2001/07/03 11:02:01 ume Exp $
 *//* Copyright (c) 1998, 1999 Apple Computer, Inc. All Rights Reserved *//*
 * Copyright (c) 2000-2019 Apple Inc. All rights reserved.
 *
 * @APPLE_OSREFERENCE_LICENSE_HEADER_START@
 *
 * This file contains Original Code and/or Modifications of Original Code
 * as defined in and that are subject to the Apple Public Source License
 * Version 2.0 (the 'License'). You may not use this file except in
 * compliance with the License. The rights granted to you under the License
 * may not be used to create, or enable the creation or redistribution of,
 * unlawful or unlicensed copies of an Apple operating system, or to
 * circumvent, violate, or enable the circumvention or violation of, any
 * terms of an Apple operating system software license agreement.
 *
 * Please obtain a copy of the License at
 * http://www.opensource.apple.com/apsl/ and read it before using this file.
 *
 * The Original Code and all software distributed under the License are
 * distributed on an 'AS IS' basis, WITHOUT WARRANTY OF ANY KIND, EITHER
 * EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES,
 * INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE, QUIET ENJOYMENT OR NON-INFRINGEMENT.
 * Please see the License for the specific language governing rights and
 * limitations under the License.
 *
 * @APPLE_OSREFERENCE_LICENSE_HEADER_END@
 *//Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX.sdk/usr/include/sys/un.hsockaddr_un &const sockaddr_unconst sockaddr_un &sockaddr_unchar[104]sun_pathsun_familysun_lenSUN_LEN(su)(sizeof(*(su)) - sizeof((su)->sun_path) + strlen((su)->sun_path))LOCAL_PEERTOKEN0x006LOCAL_PEEREUUID0x005LOCAL_PEERUUIDLOCAL_PEEREPID0x003LOCAL_PEERPIDLOCAL_PEERCREDSOL_LOCAL_SYS_UN_H_/* !_SYS_UN_H_ *//* actual length of an initialized sockaddr_un *//* retrieve peer audit token *//* retrieve eff. peer UUID *//* retrieve peer UUID *//* retrieve eff. peer pid *//* retrieve peer pid *//* retrieve peer credentials *//* Socket options. *//* Level number of get/setsockopt for local domain sockets *//* [XSI] path name (gag) *//* [XSI] AF_UNIX *//* sockaddr len including null *//*
 * [XSI] Definitions for UNIX IPC domain.
 *//* [XSI] The sa_family_t type shall be defined as described in <sys/socket.h> *//*
 * Copyright (c) 1982, 1986, 1993
 *	The Regents of the University of California.  All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *	This product includes software developed by the University of
 *	California, Berkeley and its contributors.
 * 4. Neither the name of the University nor the names of its contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 *
 *	@(#)un.h	8.3 (Berkeley) 2/19/95
 *//Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX.sdk/usr/include/sys/kern_control.hsockaddr_ctl &const sockaddr_ctlconst sockaddr_ctl &ctl_info &const ctl_infoconst ctl_info &ctl_event_data &const ctl_event_dataconst ctl_event_data &sockaddr_ctlctl_infoctl_event_datau_int32_t[5]unsigned int[5]sc_reservedsc_unitsc_idss_sysaddrsc_familysc_lenchar[96]MAX_KCTL_NAMEctl_namectl_idctl_unitCTLIOCGINFO_IOWR('N', 3, struct ctl_info)CTLIOCGCOUNT_IOR('N', 2, int)KEV_CTL_DEREGISTEREDKEV_CTL_REGISTEREDKEV_CTL_SUBCLASSKPI_KERN_CONTROL_H/* KPI_KERN_CONTROL_H *//* Developer private unit number *//* Controller unique identifier  *//* AF_SYS_KERNCONTROL *//* AF_SYSTEM *//* depends on size of bundle ID string *//*!
 *       @struct sockaddr_ctl
 *       @discussion The controller address structure is used to establish
 *               contact between a user client and a kernel controller. The
 *               sc_id/sc_unit uniquely identify each controller. sc_id is a
 *               unique identifier assigned to the controller. The identifier can
 *               be assigned by the system at registration time or be a 32-bit
 *               creator code obtained from Apple Computer. sc_unit is a unit
 *               number for this sc_id, and is privately used by the kernel
 *               controller to identify several instances of the controller.
 *       @field sc_len The length of the structure.
 *       @field sc_family AF_SYSTEM.
 *       @field ss_sysaddr AF_SYS_KERNCONTROL.
 *       @field sc_id Controller unique identifier.
 *       @field sc_unit Kernel controller private unit number.
 *       @field sc_reserved Reserved, must be set to zero.
 *//* Kernel Controller Name (a C string) *//* Kernel Controller ID  *//*!
 *       @struct ctl_info
 *       @discussion This structure is used with the CTLIOCGINFO ioctl to
 *               translate from a kernel control name to a control id.
 *       @field ctl_id The kernel control id, filled out upon return.
 *       @field ctl_name The kernel control name to find.
 *//*
 * Controls destined to the Controller Manager.
 *//*!
 *       @defined MAX_KCTL_NAME
 *   @discussion Kernel control names must be no longer than
 *       MAX_KCTL_NAME.
 *//* get id from name *//*!
 *       @defined CTLIOCGINFO
 *   @discussion The CTLIOCGINFO ioctl can be used to convert a kernel
 *       control name to a kernel control id.
 *//* get number of control structures registered *//*!
 *       @defined CTLIOCGCOUNT
 *   @discussion The CTLIOCGCOUNT ioctl can be used to determine the
 *       number of kernel controllers registered.
 *//* Kernel Controller ID *//*!
 *       @struct ctl_event_data
 *       @discussion This structure is used for KEV_CTL_SUBCLASS kernel
 *               events.
 *       @field ctl_id The kernel control id.
 *       @field ctl_unit The kernel control unit.
 *//* a controller disappears *//*!
 *       @defined KEV_CTL_DEREGISTERED
 *   @discussion The event code indicating a controller was unregistered.
 *       The data portion will contain a ctl_event_data.
 *//* a new controller appears *//*!
 *       @defined KEV_CTL_REGISTERED
 *   @discussion The event code indicating a new controller was
 *       registered. The data portion will contain a ctl_event_data.
 *//*!
 *       @defined KEV_CTL_SUBCLASS
 *   @discussion The kernel event subclass for kernel control events.
 *//*
 * Define Controller event subclass, and associated events.
 * Subclass of KEV_SYSTEM_CLASS
 *//*!
 *       @header kern_control.h
 *       This header defines an API to communicate between a kernel
 *       extension and a process outside of the kernel.
 *//*
 * Copyright (c) 2000-2004, 2012-2016 Apple Inc. All rights reserved.
 *
 * @APPLE_OSREFERENCE_LICENSE_HEADER_START@
 *
 * This file contains Original Code and/or Modifications of Original Code
 * as defined in and that are subject to the Apple Public Source License
 * Version 2.0 (the 'License'). You may not use this file except in
 * compliance with the License. The rights granted to you under the License
 * may not be used to create, or enable the creation or redistribution of,
 * unlawful or unlicensed copies of an Apple operating system, or to
 * circumvent, violate, or enable the circumvention or violation of, any
 * terms of an Apple operating system software license agreement.
 *
 * Please obtain a copy of the License at
 * http://www.opensource.apple.com/apsl/ and read it before using this file.
 *
 * The Original Code and all software distributed under the License are
 * distributed on an 'AS IS' basis, WITHOUT WARRANTY OF ANY KIND, EITHER
 * EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES,
 * INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE, QUIET ENJOYMENT OR NON-INFRINGEMENT.
 * Please see the License for the specific language governing rights and
 * limitations under the License.
 *
 * @APPLE_OSREFERENCE_LICENSE_HEADER_END@
 *//Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX.sdk/usr/include/sys/event.hkevent64const kevent64_sconst kevent64_s *kevent64_s *keventconst keventconst kevent *kevent *kqueueklist &const klistconst klist &kevent64_s &const kevent64_s &kevent &const kevent &klistknoteeNoteExitReparentedDeprecatedThis kqueue(2) EVFILT_PROC flag is no longer senteNoteReapDeprecatedThis kqueue(2) EVFILT_PROC flag is deprecated268435456kevent64_sknote *slh_firstudatafflagsfilteridentNOTE_CHILDNOTE_TRACKERRNOTE_TRACKNOTE_MACHTIMENOTE_MACH_CONTINUOUS_TIMENOTE_BACKGROUNDNOTE_CRITICALNOTE_LEEWAYNOTE_ABSOLUTENOTE_NSECONDSNOTE_USECONDSNOTE_SECONDSNOTE_VM_ERRORNOTE_VM_PRESSURE_SUDDEN_TERMINATENOTE_VM_PRESSURE_TERMINATENOTE_VM_PRESSURENOTE_EXIT_CSERRORNOTE_EXIT_MEMORYNOTE_EXIT_DECRYPTFAILNOTE_EXIT_DETAIL_MASK0x00070000NOTE_EXIT_REPARENTED((unsigned int)eNoteExitReparentedDeprecated)NOTE_PCTRLMASK(~NOTE_PDATAMASK)NOTE_PDATAMASK0x000fffffNOTE_EXIT_DETAILNOTE_EXITSTATUSNOTE_SIGNALNOTE_REAP((unsigned int)eNoteReapDeprecated )NOTE_EXECNOTE_FORKNOTE_EXITNOTE_FUNLOCKNOTE_NONENOTE_REVOKENOTE_RENAMENOTE_LINKNOTE_ATTRIBNOTE_EXTENDNOTE_WRITENOTE_DELETENOTE_OOBNOTE_LOWATNOTE_FFLAGSMASK0x00ffffffNOTE_FFCTRLMASKNOTE_FFCOPYNOTE_FFORNOTE_FFANDNOTE_FFNOPNOTE_TRIGGEREV_OOBANDEV_FLAG1EV_POLLEV_FLAG0EV_ERROREV_EOFEV_SYSFLAGS0xF000EV_VANISHEDEV_DISPATCH2(EV_DISPATCH | EV_UDATA_SPECIFIC)EV_UDATA_SPECIFICEV_DISPATCHEV_RECEIPTEV_CLEAREV_ONESHOTEV_DISABLEEV_ENABLEEV_DELETEEV_ADDKEVENT_FLAG_ERROR_EVENTS0x000002KEVENT_FLAG_IMMEDIATE0x000001KEVENT_FLAG_NONE0x000000EV_SET64(kevp,a,b,c,d,e,f,g,h)do { struct kevent64_s *__kevp__ = (kevp); __kevp__->ident = (a); __kevp__->filter = (b); __kevp__->flags = (c); __kevp__->fflags = (d); __kevp__->data = (e); __kevp__->udata = (f); __kevp__->ext[0] = (g); __kevp__->ext[1] = (h); } while(0)EV_SET(kevp,a,b,c,d,e,f)do { struct kevent *__kevp__ = (kevp); __kevp__->ident = (a); __kevp__->filter = (b); __kevp__->flags = (c); __kevp__->fflags = (d); __kevp__->data = (e); __kevp__->udata = (f); } while(0)EVFILT_THREADMARKEREVFILT_SYSCOUNTEVFILT_EXCEPTEVFILT_VM(-12)EVFILT_USER(-10)EVFILT_FS(-9)EVFILT_MACHPORT(-8)EVFILT_TIMER(-7)EVFILT_SIGNAL(-6)EVFILT_PROC(-5)EVFILT_VNODE(-4)EVFILT_AIO(-3)EVFILT_WRITE(-2)EVFILT_READ_SYS_EVENT_H_"This kqueue(2) EVFILT_PROC flag is no longer sent""This kqueue(2) EVFILT_PROC flag is deprecated"/* !_SYS_EVENT_H_ *//* Temporay solution for BootX to use inode.h till kqueue moves to vfs layer *//* am a child process *//* could not track child *//* follow across forks *//* additional flags for EVFILT_PROC *//*
 * DEPRECATED!!!!!!!!!
 * NOTE_TRACK, NOTE_TRACKERR, and NOTE_CHILD are no longer supported as of 10.5
 *//*
 * data/hint fflags for EVFILT_MACHPORT, shared with userspace.
 *
 * Only portsets are supported at this time.
 *
 * The fflags field can optionally contain the MACH_RCV_MSG, MACH_RCV_LARGE,
 * and related trailer receive options as defined in <mach/message.h>.
 * The presence of these flags directs the kevent64() call to attempt to receive
 * the message during kevent delivery, rather than just indicate that a message exists.
 * On setup, The ext[0] field contains the receive buffer pointer and ext[1] contains
 * the receive buffer length.  Upon event delivery, the actual received message size
 * is returned in ext[1].  As with mach_msg(), the buffer must be large enough to
 * receive the message and the requested (or default) message trailers.  In addition,
 * the fflags field contains the return code normally returned by mach_msg().
 *
 * If MACH_RCV_MSG is specified, and the ext[1] field specifies a zero length, the
 * system call argument specifying an ouput area (kevent_qos) will be consulted. If
 * the system call specified an output data area, the user-space address
 * of the received message is carved from that provided output data area (if enough
 * space remains there). The address and length of each received message is
 * returned in the ext[0] and ext[1] fields (respectively) of the corresponding kevent.
 *
 * IF_MACH_RCV_VOUCHER_CONTENT is specified, the contents of the message voucher is
 * extracted (as specified in the xflags field) and stored in ext[2] up to ext[3]
 * length.  If the input length is zero, and the system call provided a data area,
 * the space for the voucher content is carved from the provided space and its
 * address and length is returned in ext[2] and ext[3] respectively.
 *
 * If no message receipt options were provided in the fflags field on setup, no
 * message is received by this call. Instead, on output, the data field simply
 * contains the name of the actual port detected with a message waiting.
 *//* timeout uses the mach absolute time epoch *//* data is mach absolute time units *//*
 * NOTE_MACH_CONTINUOUS_TIME:
 * with NOTE_ABSOLUTE: causes the timer to continue to tick across sleep,
 *      still uses gettimeofday epoch
 * with NOTE_MACHTIME and NOTE_ABSOLUTE: uses mach continuous time epoch
 * without NOTE_ABSOLUTE (interval timer mode): continues to tick across sleep
 *//* system does maximum timer coalescing *//* system does minimal timer coalescing *//* ext[1] holds leeway for power aware timers *//* ... implicit EV_ONESHOT, timeout uses the gettimeofday epoch *//* absolute timeout        *//* data is nanoseconds     *//* data is microseconds    *//* data is seconds         *//*
 * data/hint fflags for EVFILT_TIMER, shared with userspace.
 * The default is a (repeating) interval timer with the data
 * specifying the timeout interval in milliseconds.
 *
 * All timeouts are implicitly EV_CLEAR events.
 *//* there was an error *//* will quit immediately on memory pressure *//* will quit on memory pressure, possibly after cleaning up dirty state *//* will react on memory pressure *//*
 * data/hint fflags for EVFILT_VM, shared with userspace.
 *//*
 * If NOTE_EXIT_DETAIL is present, these bits indicate specific reasons for exiting.
 *//* exited while reparented *//*
 * If NOTE_EXITSTATUS is present, provide additional info about exiting process.
 *//* mask for signal & exit status *//* provide details on reasons for exit *//* exit status to be returned, valid for child process or when allowed to signal target pid *//* shared with EVFILT_SIGNAL *//* process reaped *//* 0x10000000 *//* process exec'd *//* process forked *//* process exited *//*
 * data/hint fflags for EVFILT_PROC, shared with userspace
 *
 * Please note that EVFILT_PROC and EVFILT_SIGNAL share the same knote list
 * that hangs off the proc structure. They also both play games with the hint
 * passed to KNOTE(). If NOTE_SIGNAL is passed as a hint, then the lower bits
 * of the hint contain the signal. IF NOTE_FORK is passed, then the lower bits
 * contain the PID of the child (but the pid does not get passed through in
 * the actual kevent).
 *//* vnode was unlocked by flock(2) *//* No specific vnode event: to test for EVFILT_READ activation*//* vnode access was revoked *//* vnode was renamed *//* link count changed *//* attributes changed *//* size increased *//* data contents changed *//* vnode was removed *//*
 * data/hint fflags for EVFILT_VNODE, shared with userspace
 *//* OOB data *//* data/hint flags for EVFILT_EXCEPT, shared with userspace *//* low water mark *//*
 * data/hint fflags for EVFILT_{READ|WRITE}, shared with userspace
 *
 * The default behavior for EVFILT_READ is to make the determination
 * realtive to the current file descriptor read pointer.
 *//* mask for operations *//* copy fflags *//* or fflags *//* and fflags *//* ignore input fflags *//*
 * On input, the top two bits of fflags specifies how the lower twenty four
 * bits should be applied to the stored value of fflags.
 *
 * On output, the top two bits will always be set to NOTE_FFNOP and the
 * remaining twenty four bits will contain the stored fflags value.
 *//*
 * On input, NOTE_TRIGGER causes the event to be triggered for output.
 *//*
 * data/hint fflags for EVFILT_USER, shared with userspace
 *//*
 * Filter specific flags for EVFILT_READ
 *
 * The default behavior for EVFILT_READ is to make the "read" determination
 * relative to the current file descriptor read pointer.
 *
 * The EV_POLL flag indicates the determination should be made via poll(2)
 * semantics. These semantics dictate always returning true for regular files,
 * regardless of the amount of unread data in the file.
 *
 * On input, EV_OOBAND specifies that filter should actively return in the
 * presence of OOB on the descriptor. It implies that filter will return
 * if there is OOB data available to read OR when any other condition
 * for the read are met (for example number of bytes regular data becomes >=
 * low-watermark).
 * If EV_OOBAND is not set on input, it implies that the filter should not actively
 * return for out of band data on the descriptor. The filter will then only return
 * when some other condition for read is met (ex: when number of regular data bytes
 * >=low-watermark OR when socket can't receive more data (SS_CANTRCVMORE)).
 *
 * On output, EV_OOBAND indicates the presence of OOB data on the descriptor.
 * If it was not specified as an input parameter, then the data count is the
 * number of bytes before the current OOB marker, else data count is the number
 * of bytes beyond OOB marker.
 *//* error, data contains errno *//* EOF detected *//* returned values *//* filter-specific flag *//* reserved by system *//* ... only valid with EV_DISPATCH2 *//* report that source has vanished  *//* returned to indicate the deferral *//* event enabled. EINPROGRESS will be *//* will defer delete until udata-specific *//* ... in combination with EV_DELETE *//* unique kevent per udata value *//* disable event after reporting *//*     on syscalls supporting flags *//* ... use KEVENT_FLAG_ERROR_EVENTS *//* ... with or without EV_ERROR *//* force immediate event output *//* clear event state after reporting *//* only report one occurrence *//* flags *//* disable event (not reported) *//* enable event *//* delete event from kq *//* add event to kq (implies enable) *//* actions *//* output events only include change errors *//* immediate timeout *//* no flag value *//* kevent system call flags *//* filter-specific extensions *//* opaque user data identifier *//* filter-specific data *//* filter-specific flags *//* general flags *//* filter for event *//* identifier for this event *//* Internal use only *//* Exception events *//* Virtual memory events *//* User events *//* Filesystem events *//* Mach portsets *//* timers *//* attached to struct proc *//* attached to vnodes *//* attached to aio requests *//*
 * Filter types
 *//*-
 * Copyright (c) 1999,2000,2001 Jonathan Lemon <jlemon@FreeBSD.org>
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE AUTHOR AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 *
 *	$FreeBSD: src/sys/sys/event.h,v 1.5.2.5 2001/12/14 19:21:22 jlemon Exp $
 *//*
 * Copyright (c) 2003-2021 Apple Inc. All rights reserved.
 *
 * @APPLE_OSREFERENCE_LICENSE_HEADER_START@
 *
 * This file contains Original Code and/or Modifications of Original Code
 * as defined in and that are subject to the Apple Public Source License
 * Version 2.0 (the 'License'). You may not use this file except in
 * compliance with the License. The rights granted to you under the License
 * may not be used to create, or enable the creation or redistribution of,
 * unlawful or unlicensed copies of an Apple operating system, or to
 * circumvent, violate, or enable the circumvention or violation of, any
 * terms of an Apple operating system software license agreement.
 *
 * Please obtain a copy of the License at
 * http://www.opensource.apple.com/apsl/ and read it before using this file.
 *
 * The Original Code and all software distributed under the License are
 * distributed on an 'AS IS' basis, WITHOUT WARRANTY OF ANY KIND, EITHER
 * EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES,
 * INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE, QUIET ENJOYMENT OR NON-INFRINGEMENT.
 * Please see the License for the specific language governing rights and
 * limitations under the License.
 *
 * @APPLE_OSREFERENCE_LICENSE_HEADER_END@
 */kqchangelistnchangeseventlistnevents/Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX.sdk/usr/include/sys/_types/_timeval32.htimeval32 &const timeval32const timeval32 &timeval32_STRUCT_TIMEVAL32struct timeval32/Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX.sdk/usr/include/net/if_var.h<sys/_types/_timeval32.h>ifqueue &const ifqueueconst ifqueue &if_data64 &const if_data64const if_data64 &if_data &const if_dataconst if_data &net_event_data &const net_event_dataconst net_event_data &ifqueueifnet_interface_advisoryif_data64if_datanet_event_dataifq_dropsifq_maxlenifq_lenifq_tailifq_headifi_lastchangeifi_xmittimingifi_recvtimingifi_noprotoifi_iqdropsifi_omcastsifi_imcastsifi_obytesifi_ibytesifi_collisionsifi_oerrorsifi_opacketsifi_ierrorsifi_ipacketsifi_baudrateifi_metricifi_mtuifi_unused1ifi_xmitquotaifi_recvquotaifi_hdrlenifi_addrlenifi_physicalifi_typelenifi_typeifi_reserved2ifi_reserved1ifi_hwassistifi_unused2IFNAMSIZif_nameif_unitif_familyIF_DATA_TIMEVALIF_MAXMTUIF_MINMTUAPPLE_IF_FAM_IPSECAPPLE_IF_FAM_UTUNAPPLE_IF_FAM_6LOWPANAPPLE_IF_FAM_CELLULARAPPLE_IF_FAM_BONDAPPLE_IF_FAM_FIREWIREAPPLE_IF_FAM_STFAPPLE_IF_FAM_FAITHAPPLE_IF_FAM_GIFAPPLE_IF_FAM_MDECAPAPPLE_IF_FAM_DISCAPPLE_IF_FAM_PVCAPPLE_IF_FAM_PPPAPPLE_IF_FAM_VLANAPPLE_IF_FAM_TUNAPPLE_IF_FAM_SLIPAPPLE_IF_FAM_ETHERNETAPPLE_IF_FAM_LOOPBACK_NET_IF_VAR_H_BSD_KERN_PRIVATEdefined (PRIVATE) || defined (DRIVERKIT_PRIVATE)/* !_NET_IF_VAR_H_ *//*
 * Structure defining a queue for a network interface.
 *//* defined (PRIVATE) || defined (DRIVERKIT_PRIVATE) *//*
	 * on scale of 1 to 5
	 *//*
	 * WiFi-BT coexistence, 1-ON, 0-OFF
	 *//*
	 * Expected wifi outage period during intermittent state
	 * 1 tick -> 1 ms UNDEF => UINT16_MAX
	 *//*
	 * Estimated period for which intermittent state is expected to last.
	 * 1 tick -> 1 ms UNDEF => UINT16_MAX
	 *//*
	 * Intermittent WiFi state [true(1)/false(0)]
	 *//*
	 * Current frequency band (enumeration).
	 *//*
	 * average delay observed at the interface.
	 * unit: milliseconds (ms)
	 *//*
	 * non flushable queue size at the driver.
	 * should be set to UINT32_MAX if not available.
	 * unit: byte
	 *//*
	 * flushable queue size at the driver.
	 * should be set to UINT32_MAX if not available.
	 * unit: byte
	 *//*
	 * average throughput observed at the driver stack.
	 * unit: bits per second (bps)
	 *//*
	 * Total bytes sent or received on the interface.
	 * wrap around possible and the application should account for that.
	 * unit: byte
	 *//*
	 * Maximum theoretical bandwidth of the interface.
	 * unit: bits per second (bps)
	 *//*
	 * Time of the issue of advisory.
	 * Timestamp should be in the host domain.
	 * unit: mach absolute time
	 *//*
	 * suggestion for data rate change to keep the latency low.
	 * unit: bits per second (bps)
	 * NOTE: if the interface cannot provide suggestions in terms of bps,
	 * it should use the following values:
	 * INT32_MAX : ramp up
	 * INT32_MIN : ramp down
	 * 0         : neutral
	 *//*  Specifies if the advisory is for transmit or receive path *//* The current structure version *//*
 * This structure is used to define the parameters for advisory notifications
 * on an interface.
 *//* time of last administrative change *//* usec spent xmitting when timing *//* usec spent receiving when timing *//* destined for unsupported protocol *//* dropped on input, this interface *//* packets sent via multicast *//* packets received via multicast *//* total number of octets sent *//* total number of octets received *//* collisions on csma interfaces *//* output errors on interface *//* packets sent on interface *//* input errors on interface *//* packets received on interface *//* volatile statistics *//* linespeed *//* routing metric (external only) *//* maximum transmission unit *//* for future use *//* polling quota for xmit intrs *//* polling quota for receive intrs *//* media header length *//* media address length *//* e.g., AUI, Thinnet, 10base-T, etc *//* Length of frame type id *//* ethernet, tokenring, etc *//* generic interface information *//*
 * Structure describing information about an interface
 * which may be of interest to management entities.
 *//* HW offload capabilities *//* used to be the default_proto *//* This belongs up in socket.h or socketvar.h, depending on how far the
 *   event bubbles up.
 *//*
 * Structures defining a network interface, providing a packet
 * transport mechanism (ala level 0 of the PUP protocols).
 *
 * Each interface accepts output datagrams of a specified maximum
 * length, and provides higher level routines with input datagrams
 * received from its medium.
 *
 * Output occurs when the routine if_output is called, with three parameters:
 *	(*ifp->if_output)(ifp, m, dst, rt)
 * Here m is the mbuf chain to be sent and dst is the destination address.
 * The output routine encapsulates the supplied datagram if necessary,
 * and then transmits it on its medium.
 *
 * On input, each interface unwraps the data received by it, and either
 * places it on the input queue of a internetwork datagram routine
 * and posts the associated software interrupt, or passes the datagram to a raw
 * packet input routine.
 *
 * Routines exist for locating interfaces by their addresses
 * or for locating a interface on a certain network, as well as more general
 * routing and gateway routines maintaining information used to locate
 * interfaces.  These routines live in the files if.c and route.c
 *//*
 * 72 was chosen below because it is the size of a TCP/IP
 * header (40) + the minimum mss (32).
 *//* __APPLE__ *//* get TAILQ macros *//*
 * Copyright (c) 1982, 1986, 1989, 1993
 *	The Regents of the University of California.  All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *	This product includes software developed by the University of
 *	California, Berkeley and its contributors.
 * 4. Neither the name of the University nor the names of its contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 *
 *	From: @(#)if.h	8.1 (Berkeley) 6/10/93
 * $FreeBSD: src/sys/net/if_var.h,v 1.18.2.7 2001/07/24 19:10:18 brooks Exp $
 *//*
 * Copyright (c) 2000-2022 Apple Inc. All rights reserved.
 *
 * @APPLE_OSREFERENCE_LICENSE_HEADER_START@
 *
 * This file contains Original Code and/or Modifications of Original Code
 * as defined in and that are subject to the Apple Public Source License
 * Version 2.0 (the 'License'). You may not use this file except in
 * compliance with the License. The rights granted to you under the License
 * may not be used to create, or enable the creation or redistribution of,
 * unlawful or unlicensed copies of an Apple operating system, or to
 * circumvent, violate, or enable the circumvention or violation of, any
 * terms of an Apple operating system software license agreement.
 *
 * Please obtain a copy of the License at
 * http://www.opensource.apple.com/apsl/ and read it before using this file.
 *
 * The Original Code and all software distributed under the License are
 * distributed on an 'AS IS' basis, WITHOUT WARRANTY OF ANY KIND, EITHER
 * EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES,
 * INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE, QUIET ENJOYMENT OR NON-INFRINGEMENT.
 * Please see the License for the specific language governing rights and
 * limitations under the License.
 *
 * @APPLE_OSREFERENCE_LICENSE_HEADER_END@
 *//Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX.sdk/usr/include/net/if.h<sys/socket.h><net/if_var.h>if_freenameindexif_nameindex *if_nameindexif_indextonameif_nametoindexif_nameindex &const if_nameindexconst if_nameindex &kev_dl_proto_data &const kev_dl_proto_dataconst kev_dl_proto_data &ifconf &const ifconfconst ifconf &ifstat &const ifstatconst ifstat &ifdrv &const ifdrvconst ifdrv &ifmediareq &const ifmediareqconst ifmediareq &rslvmulti_req &const rslvmulti_reqconst rslvmulti_req &ifaliasreq &const ifaliasreqconst ifaliasreq &ifreq &const ifreqconst ifreq &ifkpi &const ifkpiconst ifkpi &ifdevmtu &const ifdevmtuconst ifdevmtu &ifma_msghdr2 &const ifma_msghdr2const ifma_msghdr2 &if_msghdr2 &const if_msghdr2const if_msghdr2 &ifma_msghdr &const ifma_msghdrconst ifma_msghdr &ifa_msghdr &const ifa_msghdrconst ifa_msghdr &if_msghdr &const if_msghdrconst if_msghdr &if_clonereq &const if_clonereqconst if_clonereq &kev_dl_proto_dataifconfifstatifdrvifmediareqrslvmulti_reqifaliasreqifreqifkpiifdevmtuifma_msghdr2if_msghdr2ifma_msghdrifa_msghdrif_msghdrif_clonereqif_indexproto_remaining_countproto_familylink_dataifc_ifcuifreq *ifcu_reqifcu_bufifc_lenchar[801]IFSTATMAXifs_nameifd_dataifd_lenifd_cmdifd_nameifm_ulistifm_countifm_activeifm_statusifm_maskifm_currentifm_namesockaddr **llsasaifra_maskifra_broadaddrifra_addrifra_nameifr_ifruifru_functional_typeifru_capifru_route_refcntifru_wake_flagsifru_kpiifru_devmtuifru_dataifru_intvalifru_mediaifru_physifru_mtuifru_metricifru_flagsifru_broadaddrifru_dstaddrifru_addrifr_nameifk_dataifk_valueifk_ptrifk_typeifk_module_idifdm_maxifdm_minifdm_currentifmam_refcountifmam_indexifmam_flagsifmam_addrsifmam_typeifmam_versionifmam_msglenifm_dataifm_timerifm_snd_dropsifm_snd_maxlenifm_snd_lenifm_indexifm_flagsifm_addrsifm_typeifm_versionifm_msglenifam_metricifam_indexifam_flagsifam_addrsifam_typeifam_versionifam_msglenifcr_bufferifcr_countifcr_totalifc_reqifc_ifcu.ifcu_reqifc_bufifc_ifcu.ifcu_buf_SIZEOF_ADDR_IFREQ(ifr)((ifr).ifr_addr.sa_len > sizeof (struct sockaddr) ? (sizeof (struct ifreq) - sizeof (struct sockaddr) + (ifr).ifr_addr.sa_len) : sizeof (struct ifreq))ifr_curcapifr_ifru.ifru_cap[1]ifr_reqcapifr_ifru.ifru_cap[0]ifr_route_refcntifr_ifru.ifru_route_refcntifr_wake_flagsifr_ifru.ifru_wake_flagsifr_kpiifr_ifru.ifru_kpiifr_intvalifr_ifru.ifru_intvalifr_devmtuifr_ifru.ifru_devmtuifr_dataifr_ifru.ifru_dataifr_mediaifr_ifru.ifru_mediaifr_physifr_ifru.ifru_physifr_mtuifr_ifru.ifru_mtuifr_metricifr_ifru.ifru_metricifr_flagsifr_ifru.ifru_flagsifr_broadaddrifr_ifru.ifru_broadaddrifr_dstaddrifr_ifru.ifru_dstaddrifr_addrifr_ifru.ifru_addrIFRTYPE_FUNCTIONAL_LASTIFRTYPE_FUNCTIONAL_COMPANIONLINKIFRTYPE_FUNCTIONAL_INTCOPROCIFRTYPE_FUNCTIONAL_CELLULARIFRTYPE_FUNCTIONAL_WIFI_AWDLIFRTYPE_FUNCTIONAL_WIFI_INFRAIFRTYPE_FUNCTIONAL_WIREDIFRTYPE_FUNCTIONAL_LOOPBACKIFRTYPE_FUNCTIONAL_UNKNOWNIF_WAKE_ON_MAGIC_PACKETIFQ_UPDATE_INTERVAL(100ULL * 1000 * 1000)IFQ_TARGET_DELAY(10ULL * 1000 * 1000)IFNET_SLOWHZIFQ_MAXLENIFCAP_VALID(IFCAP_HWCSUM | IFCAP_TSO | IFCAP_LRO | IFCAP_VLAN_MTU | IFCAP_VLAN_HWTAGGING | IFCAP_JUMBO_MTU | IFCAP_AV | IFCAP_TXSTATUS | IFCAP_SKYWALK | IFCAP_SW_TIMESTAMP | IFCAP_HW_TIMESTAMP | IFCAP_CSUM_PARTIAL | IFCAP_CSUM_ZERO_INVERT)IFCAP_TSO(IFCAP_TSO4 | IFCAP_TSO6)IFCAP_HWCSUM(IFCAP_RXCSUM | IFCAP_TXCSUM)IFCAP_CSUM_ZERO_INVERT0x04000IFCAP_CSUM_PARTIAL0x02000IFCAP_SW_TIMESTAMP0x01000IFCAP_HW_TIMESTAMP0x00800IFCAP_SKYWALK0x00400IFCAP_TXSTATUS0x00200IFCAP_AV0x00100IFCAP_LRO0x00080IFCAP_TSO60x00040IFCAP_TSO40x00020IFCAP_JUMBO_MTU0x00010IFCAP_VLAN_HWTAGGING0x00008IFCAP_VLAN_MTU0x00004IFCAP_TXCSUM0x00002IFCAP_RXCSUM0x00001IFF_MULTICASTIFF_ALTPHYSIFF_LINK2IFF_LINK1IFF_LINK0IFF_SIMPLEXIFF_OACTIVEIFF_ALLMULTIIFF_PROMISCIFF_NOARPIFF_RUNNINGIFF_NOTRAILERSIFF_POINTOPOINTIFF_LOOPBACKIFF_DEBUGIFF_BROADCASTIFF_UPIF_NAMESIZE_NET_IF_H_/* !_NET_IF_H_ *//* null terminated name: "le0", ... *//* 1, 2, ... *//*
 * DLIL KEV_DL_PROTO_ATTACHED/DETACHED structure
 *//* array of structures returned *//* buffer address *//* size of associated buffer *//*
 * Structure used in SIOCGIFCONF request.
 * Used to retrieve interface configuration
 * for machine (useful for programs which
 * must know all networks accessible).
 *//* if name, e.g. "en0" *//* 10 lines of text *//*
 * Structure used to retrieve aux status data from interfaces.
 * Kernel suppliers to this interface should respect the formatting
 * needed by ifconfig(8): each line starts with a TAB and ends with
 * a newline.
 *//* length of ifd_data buffer *//* media words *//* # entries in ifm_ulist array *//* active options *//* media status *//* don't care mask *//* current media options *//* current capabilities *//* requested capabilities *//* route references count *//* wake capabilities *//* integer value *//* for use by interface *//* physical media *//* physical wire *//* mtu *//* metric *//* broadcast address *//* other end of p-to-p link *//* address *//*
 * Interface request structure used for socket
 * ioctl's.  All interface ioctl's must have parameter
 * definitions which begin with ifr_name.  The
 * remainder may be interface specific.
 *//* Wake capabilities of a interface *//*
 *  ifkpi: interface kpi ioctl
 *  Used with SIOCSIFKPI and SIOCGIFKPI.
 *
 *  ifk_module_id - From in the kernel, a value from kev_vendor_code_find. From
 *       user space, a value from SIOCGKEVVENDOR ioctl on a kernel event socket.
 *  ifk_type - The type. Types are specific to each module id.
 *  ifk_data - The data. ifk_ptr may be a 64bit pointer for 64 bit processes.
 *
 *  Copying data between user space and kernel space is done using copyin
 *  and copyout. A process may be running in 64bit mode. In such a case,
 *  the pointer will be a 64bit pointer, not a 32bit pointer. The following
 *  sample is a safe way to copy the data in to the kernel from either a
 *  32bit or 64bit process:
 *
 *  user_addr_t tmp_ptr;
 *  if (IS_64BIT_PROCESS(current_proc())) {
 *       tmp_ptr = CAST_USER_ADDR_T(ifkpi.ifk_data.ifk_ptr64);
 *  }
 *  else {
 *       tmp_ptr = CAST_USER_ADDR_T(ifkpi.ifk_data.ifk_ptr);
 *  }
 *  error = copyin(tmp_ptr, allocated_dst_buffer, size of allocated_dst_buffer);
 *//*
 * ifdevmtu: interface device mtu
 *    Used with SIOCGIFDEVMTU to get the current mtu in use by the device,
 *    as well as the minimum and maximum mtu allowed by the device.
 *//* index for associated ifp *//* value of ifa_flags *//* like rtm_addrs *//* message type *//* future binary compatability *//* to skip over non-understood messages *//*
 * Message format for use in obtaining information about multicast addresses
 * from sysctl
 *//* statistics and other data *//* time until if_watchdog called *//* number of drops in send queue *//* maximum length of send queue *//* instantaneous length of send queue *//* value of if_flags *//*
 * Message format for use in obtaining information about interfaces
 * from sysctl
 *//* to skip non-understood messages *//*
 * Message format for use in obtaining information about multicast addresses
 * from the routing socket
 *//* value of ifa_metric *//*
 * Message format for use in obtaining information about interface addresses
 * from sysctl and the routing socket
 *//* statistics and other data about if *//*
 * Message format for use in obtaining information about interfaces
 * from sysctl and the routing socket
 *//* 100 ms *//* 10 ms *//* granularity is 1 second *//* can invert 0 to -0 (0xffff) *//* can offload partial checksum *//* Time stamping in software *//* Time stamping in hardware *//* Skywalk mode supported/enabled *//* can return linklevel xmit status *//* can do 802.1 AV Bridging *//* can do Large Receive Offload *//* can do TCP6 Segmentation Offload *//* can do TCP Segmentation Offload *//* 9000 byte MTU supported *//* hardware VLAN tag support *//* VLAN-compatible MTU *//* can offload checksum on TX *//* can offload checksum on RX *//*
 * Capabilities that interfaces can advertise.
 *
 * struct ifnet.if_capabilities
 *   contains the optional features & capabilities a particular interface
 *   supports (not only the driver but also the detected hw revision).
 *   Capabilities are defined by IFCAP_* below.
 * struct ifnet.if_capenable
 *   contains the enabled (either by default or through ifconfig) optional
 *   features & capabilities on this interface.
 *   Capabilities are defined by IFCAP_* below.
 * struct if_data.ifi_hwassist in IFNET_* form, defined in net/kpi_interface.h,
 *   contains the enabled optional features & capabilites that can be used
 *   individually per packet and are specified in the mbuf pkthdr.csum_flags
 *   field.  IFCAP_* and IFNET_* do not match one to one and IFNET_* may be
 *   more detailed or differentiated than IFCAP_*.
 *   IFNET_* hwassist flags have corresponding CSUM_* in sys/mbuf.h
 *//* supports multicast *//* use alternate physical connection *//* per link layer defined bit *//* can't hear own transmissions *//* transmission in progress *//* receive all multicast packets *//* receive all packets *//* no address resolution protocol *//* resources allocated *//* obsolete: avoid use of trailers *//* interface is point-to-point link *//* is a loopback net *//* turn on debugging *//* broadcast address valid *//* interface is up *//* buffer for cloner names *//* room for this many in user buffer *//* total cloners (out) *//*
 * Copyright (c) 1982, 1986, 1989, 1993
 *	The Regents of the University of California.  All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *	This product includes software developed by the University of
 *	California, Berkeley and its contributors.
 * 4. Neither the name of the University nor the names of its contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 *
 *	@(#)if.h	8.1 (Berkeley) 6/10/93
 *//*
 * Copyright (c) 2000-2021 Apple Inc. All rights reserved.
 *
 * @APPLE_OSREFERENCE_LICENSE_HEADER_START@
 *
 * This file contains Original Code and/or Modifications of Original Code
 * as defined in and that are subject to the Apple Public Source License
 * Version 2.0 (the 'License'). You may not use this file except in
 * compliance with the License. The rights granted to you under the License
 * may not be used to create, or enable the creation or redistribution of,
 * unlawful or unlicensed copies of an Apple operating system, or to
 * circumvent, violate, or enable the circumvention or violation of, any
 * terms of an Apple operating system software license agreement.
 *
 * Please obtain a copy of the License at
 * http://www.opensource.apple.com/apsl/ and read it before using this file.
 *
 * The Original Code and all software distributed under the License are
 * distributed on an 'AS IS' basis, WITHOUT WARRANTY OF ANY KIND, EITHER
 * EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES,
 * INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE, QUIET ENJOYMENT OR NON-INFRINGEMENT.
 * Please see the License for the specific language governing rights and
 * limitations under the License.
 *
 * @APPLE_OSREFERENCE_LICENSE_HEADER_END@
 *//Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX.sdk/usr/include/net/route.hrt_addrinfo &const rt_addrinfoconst rt_addrinfo &rt_msghdr2 &const rt_msghdr2const rt_msghdr2 &rt_msghdr &const rt_msghdrconst rt_msghdr &rtstat &const rtstatconst rtstat &rt_metrics &const rt_metricsconst rt_metrics &rt_addrinfort_msghdr2rt_msghdrrtstatrt_metricssockaddr *[8]RTAX_MAXrti_inforti_addrsrtm_rmxrtm_initsrtm_usertm_reservedrtm_parentflagsrtm_refcntrtm_addrsrtm_flagsrtm_indexrtm_typertm_versionrtm_msglenrtm_errnortm_seqrtm_pidrts_badrtgwrouterts_wildcardrts_unreachrts_newgatewayrts_dynamicrts_badredirectu_int32_t[3]unsigned int[3]rmx_fillerrmx_statermx_pksentrmx_rttvarrmx_rttrmx_ssthreshrmx_sendpipermx_recvpipermx_expirermx_hopcountrmx_mturmx_locksRTAX_BRDRTAX_AUTHORRTAX_IFARTAX_IFPRTAX_GENMASKRTAX_NETMASKRTAX_GATEWAYRTAX_DSTRTA_BRDRTA_AUTHORRTA_IFARTA_IFPRTA_GENMASKRTA_NETMASKRTA_GATEWAYRTA_DSTRTV_RTTVARRTV_RTTRTV_SSTHRESHRTV_SPIPERTV_RPIPERTV_EXPIRERTV_HOPCOUNTRTV_MTURTM_GET2RTM_NEWMADDR20x13RTM_IFINFO20x12RTM_DELMADDRRTM_NEWMADDR0xfRTM_IFINFO0xeRTM_DELADDR0xdRTM_NEWADDR0xcRTM_RESOLVE0xbRTM_OLDDEL0xaRTM_OLDADD0x9RTM_LOCKRTM_MISS0x7RTM_REDIRECT0x6RTM_LOSING0x5RTM_GETRTM_CHANGE0x3RTM_DELETERTM_ADDRTM_VERSIONIS_DYNAMIC_DIRECT_HOSTROUTE(rt)(((rt)->rt_flags & (RTF_CLONING | RTF_PRCLONING | RTF_HOST | RTF_LLINFO | RTF_WASCLONED | RTF_GATEWAY)) == (RTF_HOST | RTF_LLINFO | RTF_WASCLONED))IS_DIRECT_HOSTROUTE(rt)(((rt)->rt_flags & (RTF_HOST | RTF_GATEWAY)) == RTF_HOST)RTF_BITS"\020\1UP\2GATEWAY\3HOST\4REJECT\5DYNAMIC\6MODIFIED\7DONE" "\10DELCLONE\11CLONING\12XRESOLVE\13LLINFO\14STATIC\15BLACKHOLE" "\16NOIFREF\17PROTO2\20PROTO1\21PRCLONING\22WASCLONED\23PROTO3" "\25PINNED\26LOCAL\27BROADCAST\30MULTICAST\31IFSCOPE\32CONDEMNED" "\33IFREF\34PROXY\35ROUTER\37GLOBAL"RTPRF_OURSRTF_PROTO3RTF_GLOBALRTF_DEADRTF_ROUTERRTF_PROXY0x8000000RTF_IFREF0x4000000RTF_CONDEMNEDRTF_IFSCOPE0x1000000RTF_MULTICAST0x800000RTF_BROADCASTRTF_LOCAL0x200000RTF_PINNED0x100000RTF_WASCLONEDRTF_PRCLONINGRTF_PROTO1RTF_PROTO2RTF_NOIFREFRTF_BLACKHOLERTF_STATICRTF_LLDATARTF_LLINFORTF_XRESOLVERTF_CLONINGRTF_DELCLONERTF_DONERTF_MODIFIEDRTF_DYNAMICRTF_REJECTRTF_HOSTRTF_GATEWAYRTF_UPRTM_RTTUNIT_NET_ROUTE_H_/* _NET_ROUTE_H_ *//* size of array to allocate *//* for NEWADDR, broadcast or p-p dest addr *//* sockaddr for author of redirect *//* interface addr sockaddr present *//* interface name sockaddr present *//* cloning mask sockaddr present *//* netmask sockaddr present *//* gateway sockaddr present *//* destination sockaddr present *//*
 * Index offsets for sockaddr array for alternate internal encoding.
 *//*
 * Bitmask values for rtm_addrs.
 *//* init or lock _rttvar *//* init or lock _rtt *//* init or lock _ssthresh *//* init or lock _sendpipe *//* init or lock _recvpipe *//* init or lock _expire *//* init or lock _hopcount *//* init or lock _mtu *//*
 * Bitmask values for rtm_inits and rmx_locks.
 *//* mcast group membership being deleted *//* mcast group membership being added to if *//* iface going up/down etc. *//* address being removed from iface *//* address being added to iface *//* req to resolve dst to LL addr *//* caused by SIOCDELRT *//* caused by SIOCADDRT *//* fix specified metrics *//* Lookup failed on this address *//* Told to use different route *//* RTM_LOSING is no longer generated by xnu
	                         *  and is deprecated *//* Report Metrics *//* Change Metrics or flags *//* Delete Route *//* Add Route *//*
 * Message types.
 *//* Up the ante and ignore older versions *//* metrics themselves *//* which metrics we are initializing *//* from rtentry *//* reserved field set to 0 *//* flags of the parent route *//* reference count *//* bitmask identifying sockaddrs in msg *//* flags, incl. kern & message, e.g. DONE *//* future binary compatibility *//* why failed *//* for sender to identify action *//* identify sender *//*
 * Structures for routing messages.
 *//* route to gateway is not direct *//* lookups satisfied by a wildcard *//* lookups which failed *//* routes modified by redirects *//* routes created by redirects *//* bogus redirect calls *//*
 * Routing statistics.
 *//* set on routes we manage *//* 0x80000000 unassigned *//* route to destination of the global internet *//* Route entry is being freed *//* host is a router *//* proxying, no interface scope *//* route holds a ref to interface *//* defunct; no longer modifiable *//* has valid interface scope *//* route represents a mcast address *//* route represents a bcast address *//* route represents a local address *//* future use *//* 0x80000 unused *//* protocol specific routing flag *//* route generated through cloning *//* protocol requires cloning *//* not eligible for RTF_IFREF *//* just discard pkts (during updates) *//* manually added *//* used by apps to add/del L2 entries *//* DEPRECATED - exists ONLY for backward
	                                 *  compatibility *//* external daemon resolves name *//* generate new routes on use *//* delete cloned route *//* message confirmed *//* modified dynamically (by redirect) *//* created dynamically (by redirect) *//* host or net unreachable *//* host entry (net otherwise) *//* destination is a gateway *//* route usable *//* units for rtt, rttvar, as units per sec *//*
 * rmx_rtt and rmx_rttvar are stored as microseconds;
 *//* will be used for TCP's peer-MSS cache *//* route state *//* packets sent using this route *//* estimated rtt variance *//* estimated round trip time *//* outbound gateway buffer limit *//* outbound delay-bandwidth product *//* inbound delay-bandwidth product *//* lifetime for route, e.g. redirect *//* max hops expected *//* MTU for this path *//* Kernel leaves these values alone *//*
 * These numbers are used by reliable protocols for determining
 * retransmission behavior and are included in the routing structure.
 *//*
 * Copyright (c) 1980, 1986, 1993
 *	The Regents of the University of California.  All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *	This product includes software developed by the University of
 *	California, Berkeley and its contributors.
 * 4. Neither the name of the University nor the names of its contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 *
 *	@(#)route.h	8.3 (Berkeley) 4/19/94
 * $FreeBSD: src/sys/net/route.h,v 1.36.2.1 2000/08/16 06:14:23 jayanth Exp $
 *//*
 * Copyright (c) 2000-2017 Apple Inc. All rights reserved.
 *
 * @APPLE_OSREFERENCE_LICENSE_HEADER_START@
 *
 * This file contains Original Code and/or Modifications of Original Code
 * as defined in and that are subject to the Apple Public Source License
 * Version 2.0 (the 'License'). You may not use this file except in
 * compliance with the License. The rights granted to you under the License
 * may not be used to create, or enable the creation or redistribution of,
 * unlawful or unlicensed copies of an Apple operating system, or to
 * circumvent, violate, or enable the circumvention or violation of, any
 * terms of an Apple operating system software license agreement.
 *
 * Please obtain a copy of the License at
 * http://www.opensource.apple.com/apsl/ and read it before using this file.
 *
 * The Original Code and all software distributed under the License are
 * distributed on an 'AS IS' basis, WITHOUT WARRANTY OF ANY KIND, EITHER
 * EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES,
 * INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE, QUIET ENJOYMENT OR NON-INFRINGEMENT.
 * Please see the License for the specific language governing rights and
 * limitations under the License.
 *
 * @APPLE_OSREFERENCE_LICENSE_HEADER_END@
 *//Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX.sdk/usr/include/netinet6/in6.hin6_addr *inet6_rth_getaddrinet6_rth_segmentsinet6_rth_reverseinet6_rth_addconst in6_addrconst in6_addr *inet6_rth_initinet6_rth_spaceinet6_opt_get_valinet6_opt_findinet6_opt_next__uint8_t *inet6_opt_set_valinet6_opt_finishinet6_opt_appendinet6_opt_initinet6_rthdr_getflagsconst cmsghdr *cmsghdr *inet6_rthdr_getaddrinet6_rthdr_segmentsinet6_rthdr_lasthopinet6_rthdr_addinet6_rthdr_initinet6_rthdr_spaceinet6_option_find__uint8_t **inet6_option_nextinet6_option_allocinet6_option_appendconst __uint8_tconst __uint8_t *inet6_option_initcmsghdr **inet6_option_spaceip6_mtuinfo &const ip6_mtuinfoconst ip6_mtuinfo &in6_pktinfo &const in6_pktinfoconst in6_pktinfo &ipv6_mreq &const ipv6_mreqconst ipv6_mreq &sockaddr_in6 &const sockaddr_in6const sockaddr_in6 &in6_addr &const in6_addr &ip6_mtuinfoin6_pktinfoipv6_mreqsockaddr_in6in6_addr_tin6_addrip6m_mtuip6m_addripi6_ifindexipi6_addripv6mr_interfaceipv6mr_multiaddrsin6_scope_idsin6_addrsin6_flowinfosin6_portsin6_familysin6_len__u6_addr__uint32_t[4]__u6_addr32__uint16_t[8]unsigned short[8]__u6_addr16__uint8_t[16]__u6_addr8in6addr_linklocal_allv2routersin6addr_linklocal_allroutersin6addr_linklocal_allnodesin6addr_nodelocal_allnodesin6addr_loopbackin6addr_anyIPV6CTL_MAXIDIPV6CTL_ULA_USETEMPADDRICMPV6CTL_ND6_ONLINKNSRFC4861IPV6CTL_MAXDYNROUTESIPV6CTL_MAXIFDEFROUTERSIPV6CTL_MAXIFPREFIXESIPV6CTL_NEIGHBORGCTHRESHIPV6CTL_MCAST_PMTUIPV6CTL_MAXFRAGSIPV6CTL_USE_DEFAULTZONEIPV6CTL_ADDRCTLPOLICYIPV6CTL_PREFER_TEMPADDRIPV6CTL_RIP6STATSIPV6CTL_AUTO_LINKLOCALIPV6CTL_TEMPVLTIMEIPV6CTL_TEMPPLTIMEIPV6CTL_USETEMPADDRIPV6CTL_RTMAXCACHEIPV6CTL_RTMINEXPIREIPV6CTL_RTEXPIREIPV6CTL_V6ONLYIPV6CTL_RR_PRUNEIPV6CTL_USE_DEPRECATEDIPV6CTL_KAME_VERSIONIPV6CTL_GIF_HLIMIPV6CTL_DEFMCASTHLIMIPV6CTL_AUTO_FLOWLABELIPV6CTL_DAD_COUNTIPV6CTL_HDRNESTLIMITIPV6CTL_LOG_INTERVALIPV6CTL_KEEPFAITHIPV6CTL_ACCEPT_RTADVIPV6CTL_SOURCECHECK_LOGINTIPV6CTL_SOURCECHECKIPV6CTL_MAXFRAGPACKETSIPV6CTL_MRTPROTOIPV6CTL_MRTSTATSIPV6CTL_STATSIPV6CTL_FORWSRCRTIPV6CTL_DEFHLIMIPV6CTL_SENDREDIRECTSIPV6CTL_FORWARDINGIPV6PROTO_MAXID(IPPROTO_PIM + 1)IPV6_PORTRANGE_LOWIPV6_PORTRANGE_HIGHIPV6_PORTRANGE_DEFAULTIPV6_MAX_SOCK_SRC_FILTERIPV6_MAX_GROUP_SRC_FILTERIPV6_MAX_MEMBERSHIPSIPV6_MIN_MEMBERSHIPSIPV6_DEFAULT_MULTICAST_LOOPIPV6_DEFAULT_MULTICAST_HOPSIPV6_RTHDR_TYPE_0IPV6_RTHDR_STRICTIPV6_RTHDR_LOOSEIPV6_BOUND_IFIPV6_TCLASSIPV6_RECVTCLASSIPV6_FW_GETIPV6_FW_ZEROIPV6_FW_FLUSHIPV6_FW_DELIPV6_FW_ADDIPV6_FAITHIPV6_IPSEC_POLICYIPV6_BINDV6ONLYIPV6_V6ONLYIPV6_CHECKSUMIPV6_2292PKTOPTIONSIPV6_2292RTHDRIPV6_2292DSTOPTSIPV6_2292HOPOPTSIPV6_2292NEXTHOPIPV6_2292HOPLIMITIPV6_2292PKTINFOICMP6_FILTERIPV6_PORTRANGEIPV6_LEAVE_GROUPIPV6_JOIN_GROUPIPV6_MULTICAST_LOOPIPV6_MULTICAST_HOPSIPV6_MULTICAST_IFIPV6_UNICAST_HOPSIPV6_SOCKOPT_RESERVED1IN6_IS_ADDR_MC_GLOBAL(a)(IN6_IS_ADDR_MULTICAST(a) && (__IPV6_ADDR_MC_SCOPE(a) == __IPV6_ADDR_SCOPE_GLOBAL))IN6_IS_ADDR_MC_ORGLOCAL(a)(IN6_IS_ADDR_MULTICAST(a) && (__IPV6_ADDR_MC_SCOPE(a) == __IPV6_ADDR_SCOPE_ORGLOCAL))IN6_IS_ADDR_MC_SITELOCAL(a)(IN6_IS_ADDR_MULTICAST(a) && (__IPV6_ADDR_MC_SCOPE(a) == __IPV6_ADDR_SCOPE_SITELOCAL))IN6_IS_ADDR_MC_LINKLOCAL(a)(IN6_IS_ADDR_MULTICAST(a) && (IPV6_ADDR_MC_FLAGS(a) != IPV6_ADDR_MC_FLAGS_UNICAST_BASED) && (__IPV6_ADDR_MC_SCOPE(a) == __IPV6_ADDR_SCOPE_LINKLOCAL))IN6_IS_ADDR_MC_NODELOCAL(a)(IN6_IS_ADDR_MULTICAST(a) && (__IPV6_ADDR_MC_SCOPE(a) == __IPV6_ADDR_SCOPE_NODELOCAL))__IPV6_ADDR_MC_SCOPE(a)((a)->s6_addr[1] & 0x0f)IN6_IS_ADDR_UNIQUE_LOCAL(a)(((a)->s6_addr[0] == 0xfc) || ((a)->s6_addr[0] == 0xfd))IN6_IS_ADDR_UNICAST_BASED_MULTICAST(a)(IN6_IS_ADDR_MULTICAST(a) && (IPV6_ADDR_MC_FLAGS(a) == IPV6_ADDR_MC_FLAGS_UNICAST_BASED))IPV6_ADDR_MC_FLAGS_UNICAST_BASED(IPV6_ADDR_MC_FLAGS_TRANSIENT | IPV6_ADDR_MC_FLAGS_PREFIX)IPV6_ADDR_MC_FLAGS_PREFIXIPV6_ADDR_MC_FLAGS_TRANSIENTIPV6_ADDR_MC_FLAGS(a)((a)->s6_addr[1] & 0xf0)IN6_IS_ADDR_MULTICAST(a)((a)->s6_addr[0] == 0xff)IN6_IS_ADDR_SITELOCAL(a)(((a)->s6_addr[0] == 0xfe) && (((a)->s6_addr[1] & 0xc0) == 0xc0))IN6_IS_ADDR_LINKLOCAL(a)(((a)->s6_addr[0] == 0xfe) && (((a)->s6_addr[1] & 0xc0) == 0x80))__IPV6_ADDR_SCOPE_GLOBAL0x0e__IPV6_ADDR_SCOPE_ORGLOCAL__IPV6_ADDR_SCOPE_SITELOCAL__IPV6_ADDR_SCOPE_LINKLOCAL__IPV6_ADDR_SCOPE_INTFACELOCAL__IPV6_ADDR_SCOPE_NODELOCALIN6_IS_ADDR_6TO4(x)(ntohs((x)->s6_addr16[0]) == 0x2002)IN6_IS_ADDR_V4MAPPED(a)((*(const __uint32_t *)(const void *)(&(a)->s6_addr[0]) == 0) && (*(const __uint32_t *)(const void *)(&(a)->s6_addr[4]) == 0) && (*(const __uint32_t *)(const void *)(&(a)->s6_addr[8]) == ntohl(0x0000ffff)))IN6_IS_ADDR_V4COMPAT(a)((*(const __uint32_t *)(const void *)(&(a)->s6_addr[0]) == 0) && (*(const __uint32_t *)(const void *)(&(a)->s6_addr[4]) == 0) && (*(const __uint32_t *)(const void *)(&(a)->s6_addr[8]) == 0) && (*(const __uint32_t *)(const void *)(&(a)->s6_addr[12]) != 0) && (*(const __uint32_t *)(const void *)(&(a)->s6_addr[12]) != ntohl(1)))IN6_IS_ADDR_LOOPBACK(a)((*(const __uint32_t *)(const void *)(&(a)->s6_addr[0]) == 0) && (*(const __uint32_t *)(const void *)(&(a)->s6_addr[4]) == 0) && (*(const __uint32_t *)(const void *)(&(a)->s6_addr[8]) == 0) && (*(const __uint32_t *)(const void *)(&(a)->s6_addr[12]) == ntohl(1)))IN6_IS_ADDR_UNSPECIFIED(a)((*(const __uint32_t *)(const void *)(&(a)->s6_addr[0]) == 0) && (*(const __uint32_t *)(const void *)(&(a)->s6_addr[4]) == 0) && (*(const __uint32_t *)(const void *)(&(a)->s6_addr[8]) == 0) && (*(const __uint32_t *)(const void *)(&(a)->s6_addr[12]) == 0))IN6_ARE_ADDR_EQUAL(a,b)(memcmp(&(a)->s6_addr[0], &(b)->s6_addr[0], sizeof (struct in6_addr)) == 0)IN6ADDR_MULTICAST_PREFIXIN6MASK8IN6ADDR_V4MAPPED_INIT{{{ 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xff, 0xff, 0x00, 0x00, 0x00, 0x00 }}}IN6ADDR_LINKLOCAL_ALLV2ROUTERS_INIT{{{ 0xff, 0x02, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x16 }}}IN6ADDR_LINKLOCAL_ALLROUTERS_INIT{{{ 0xff, 0x02, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02 }}}IN6ADDR_LINKLOCAL_ALLNODES_INIT{{{ 0xff, 0x02, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01 }}}IN6ADDR_INTFACELOCAL_ALLNODES_INIT{{{ 0xff, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01 }}}IN6ADDR_NODELOCAL_ALLNODES_INITIN6ADDR_LOOPBACK_INIT{{{ 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01 }}}IN6ADDR_ANY_INIT{{{ 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 }}}SIN6_LENINET6_ADDRSTRLENs6_addr__u6_addr.__u6_addr8IPV6PORT_RESERVEDMAX(IPV6PORT_RESERVED-1)IPV6PORT_RESERVEDMINIPV6PORT_ANONMAXIPV6PORT_ANONMINIPV6PORT_RESERVED__KAME_VERSION"2009/apple-darwin"__KAME___NETINET6_IN6_H___KAME_NETINET_IN_H_INCLUDED_defined(__APPLE_USE_RFC_3542) && defined(__APPLE_USE_RFC_2292)__APPLE_USE_RFC_2292__APPLE_USE_RFC_3542notyet/* !_NETINET6_IN6_H_ *//* PLATFORM_DriverKit *//* not implemented yet *//* to define items, should talk with KAME guys first, for *BSD compatibility *//* New entries should be added here from current IPV6CTL_MAXID value. *//* enable pMTU discovery for mcast? *//* max fragments *//* use default scope zone *//* get/set address selection policy *//* prefer temporary addr as src *//* raw_ip6 stats *//* automatic link-local addr assign *//* valid lifetime for tmpaddrs *//* preferred lifetime for tmpaddrs *//* use temporary addresses [RFC 4941] *//* trigger level for dynamic expire *//* min value for expiration time *//* cloned route expiration time *//* walk timer for router renumbering *//* use deprec addr (RFC2462 5.5.4) *//* default HLIM for gif encap packet *//* minimume logging interval *//* verify source route and intf *//* max packets reassembly queue *//* multicast routing protocol *//* multicast forwarding stats *//* stats *//* forward source-routed dgrams *//* default MTU *//* default Hop-Limit *//* may send redirects when forwarding *//* act as router *//*
 * Names for IP sysctl objects
 *//* don't list to IPV6PROTO_MAX *//*
 * Definitions for inet6 sysctl operations.
 *
 * Third level is protocol number.
 * Fourth level is desired variable within that protocol.
 *//* "low" - vouchsafe security *//* "high" - request firewall bypass *//* default range *//*
 * Argument for IPV6_PORTRANGE:
 * - which range to search when port is unspecified at bind() or connect()
 *//* or sockaddr_storage? *//*
 * Control structure for IPV6_RECVPATHMTU socket option.
 *//* send/recv interface index *//* src/dst IPv6 address *//*
 * IPV6_2292PKTINFO: Packet information(RFC2292 sec 5)
 *//*
 * Argument structure for IPV6_JOIN_GROUP and IPV6_LEAVE_GROUP.
 *//* sources per socket/group *//* sources per group *//*
 * Default resource limits for IPv6 multicast source filtering.
 * These may be modified by sysctl.
 *//*
 * The im6o_membership vector for each socket is now dynamically allocated at
 * run-time, bounded by USHRT_MAX, and is reallocated when needed, sized
 * according to a power-of-two increment.
 *//* normally hear sends if a member  *//* normally limit m'casts to 1 hop  *//*
 * Defaults and limits for options
 *//* IPv6 routing header type 0 *//* this hop must be a neighbor. *//* this hop need not be a neighbor. *//* int; set/get bound interface *//* __APPLE_USE_RFC_3542 *//* struct __msfilterreq; *//*
 * The following option is private; do not use it from user applications.
 * It is deliberately defined to the same value as IP_MSFILTER.
 *//* int; prefer temporary addresses as the source address. *//* bool; disable IPv6 fragmentation *//* bool; attach flowlabel automagically *//* ip6_rthdr; send routing header *//* ip6_dest; send dst option befor rthdr *//* ip6_hbh; send hop-by-hop option *//* sockaddr; next hop addr *//* int; send hop limit *//* in6_pktinfo; send if, src addr *//* more new socket options introduced in RFC3542 *//* no data; ND reachability confirm (cmsg only/not in of RFC3542) *//* obsoleted during 2292bis -> 3542 *//*
 * mtuinfo; get the current path MTU (sopt), 4 bytes int;
 * MTU notification (cmsg)
 *//* bool; notify an according MTU *//* bool; send packets at the minimum MTU *//* bool; recv dst option after rthdr *//* bool; recv hop-by-hop option *//* bool; recv routing header *//* bool; recv hop limit *//*
 * bool; recv if, dst addr
 * APPLE: Value purposely different than FreeBSD(36) to avoid
 * collision with definition of IPV6_TCLASS in previous
 * darwin implementations
 *//*
 * ip6_dest; send dst option before rthdr
 * APPLE: Value purposely different than FreeBSD (35) to avoid
 * collision with definition of IPV6_RECVTCLASS in previous
 * darwin implementations
 *//* new socket options introduced in RFC3542 *//* int; send traffic class value *//* bool; recv traffic class values *//*
 * APPLE: NOTE the value of those 2 options is kept unchanged from
 *   previous version of darwin/OS X for binary compatibility reasons
 *   and differ from FreeBSD (values 57 and 61). See below.
 *//* 1 *//* get entire firewall rule chain *//* clear single/all firewall counter(s) *//* flush firewall rule chain *//* delete a firewall rule from chain *//* add a firewall rule to chain *//* IPV6FIREWALL *//* struct; get/set security policy *//* IPSEC *//* bool; only bind INET6 at wildcard bind *//* int; checksum offset for raw socket *//* __APPLE_USE_RFC_2292 *//* buf/cmsghdr; set/get IPv6 options [obsoleted by RFC3542] *//* ip6_rthdr: routing header *//* bool; destinaion option *//* bool; hop-by-hop option *//* bool; next hop addr *//* bool; hop limit *//* bool; send/recv if, src/dst addr *//* icmp6_filter; icmp6 filter *//* int; range to choose for unspec port *//* ip6_mreq; leave a group membership *//* ip6_mreq; join a group membership *//* u_int; set/get IP6 mcast loopback *//* int; set/get IP6 multicast hops *//* u_int; set/get IP6 multicast i/f  *//* int; IP6 hops *//* 0 *//* ip6_opts; set/get IP6 options *//* bool; receive IP6 dst addr w/dgram *//* bool; receive IP6 opts for response *//* bool; receive all IP6 opts w/dgram *//* buf/ip6_opts; set/get IP6 options *//* the followings are relic in IPv4 and hence are disabled *//*
 * RFC 3542 define the following socket options in a manner incompatible
 * with RFC 2292:
 *   IPV6_PKTINFO
 *   IPV6_HOPLIMIT
 *   IPV6_NEXTHOP
 *   IPV6_HOPOPTS
 *   IPV6_DSTOPTS
 *   IPV6_RTHDR
 *
 * To use the new IPv6 Sockets options introduced by RFC 3542
 * the constant __APPLE_USE_RFC_3542 must be defined before
 * including <netinet/in.h>
 *
 * To use the old IPv6 Sockets options from RFC 2292
 * the constant __APPLE_USE_RFC_2292 must be defined before
 * including <netinet/in.h>
 *
 * Note that eventually RFC 3542 is going to be the
 * default and RFC 2292 will be obsolete.
 *//* no hdrincl *//*
 * Options for use with [gs]etsockopt at the IPV6 level.
 * First word of comment is data type; bool is stored in int.
 *//*
 * Multicast Scope
 *//*
 * Unique Local IPv6 Unicast Addresses (per RFC 4193)
 *//*
 * Multicast
 *//*
 * Unicast Scope
 * Note that we must check topmost 10 bits only, not 16 bits (see RFC2373).
 *//* just used in this file *//*
 * KAME Scope Values
 *//*
 * 6to4
 *//*
 * Mapped
 *//*
 * IPv4 compatible
 *//*
 * Loopback
 *//*
 * Unspecified
 *//*
 * Equality
 * NOTE: Some of kernel programming environment (for example, openbsd/sparc)
 * does not supply memcmp().  For userland memcmp() is preferred as it is
 * in ANSI standard.
 *//*
 * Definition of some useful macros to handle IP6 addresses
 *//* scope zone index *//* IP6 address *//* IP6 flow information *//* Transport layer port # (in_port_t) *//* AF_INET6 (sa_family_t) *//* length of this struct(sa_family_t) *//*
 * Socket address for IPv6
 *//* 128-bit IP6 address *//*
 * IPv6 address
 *//*
 * Local port number conventions:
 *
 * Ports < IPPORT_RESERVED are reserved for privileged processes (e.g. root),
 * unless a kernel is compiled with IPNOPRIVPORTS defined.
 *
 * When a user does a bind(2) or connect(2) with a port number of zero,
 * a non-conflicting local port address is chosen.
 *
 * The default range is IPPORT_ANONMIN to IPPORT_ANONMAX, although
 * that is settable by sysctl(3); net.inet.ip.anonportmin and
 * net.inet.ip.anonportmax respectively.
 *
 * A user may set the IPPROTO_IP option IP_PORTRANGE to change this
 * default assignment range.
 *
 * The value IP_PORTRANGE_DEFAULT causes the default behavior.
 *
 * The value IP_PORTRANGE_HIGH is the same as IP_PORTRANGE_DEFAULT,
 * and exists only for FreeBSD compatibility purposes.
 *
 * The value IP_PORTRANGE_LOW changes the range to the "low" are
 * that is (by convention) restricted to privileged processes.
 * This convention is based on "vouchsafe" principles only.
 * It is only secure if you trust the remote host to restrict these ports.
 * The range is IPPORT_RESERVEDMIN to IPPORT_RESERVEDMAX.
 *//*
 * Identification of the network protocol stack
 * for *BSD-current/release: http://www.kame.net/dev/cvsweb.cgi/kame/COVERAGE
 * has the table of implementation/integration differences.
 *//*
 * Copyright (c) 1982, 1986, 1990, 1993
 *	The Regents of the University of California.  All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *	This product includes software developed by the University of
 *	California, Berkeley and its contributors.
 * 4. Neither the name of the University nor the names of its contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 *
 *	@(#)in.h	8.3 (Berkeley) 1/3/94
 *//*
 * Copyright (C) 1995, 1996, 1997, and 1998 WIDE Project.
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. Neither the name of the project nor the names of its contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE PROJECT AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE PROJECT OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 *//*
 * Copyright (c) 2008-2020 Apple Inc. All rights reserved.
 *
 * @APPLE_OSREFERENCE_LICENSE_HEADER_START@
 *
 * This file contains Original Code and/or Modifications of Original Code
 * as defined in and that are subject to the Apple Public Source License
 * Version 2.0 (the 'License'). You may not use this file except in
 * compliance with the License. The rights granted to you under the License
 * may not be used to create, or enable the creation or redistribution of,
 * unlawful or unlicensed copies of an Apple operating system, or to
 * circumvent, violate, or enable the circumvention or violation of, any
 * terms of an Apple operating system software license agreement.
 *
 * Please obtain a copy of the License at
 * http://www.opensource.apple.com/apsl/ and read it before using this file.
 *
 * The Original Code and all software distributed under the License are
 * distributed on an 'AS IS' basis, WITHOUT WARRANTY OF ANY KIND, EITHER
 * EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES,
 * INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE, QUIET ENJOYMENT OR NON-INFRINGEMENT.
 * Please see the License for the specific language governing rights and
 * limitations under the License.
 *
 * @APPLE_OSREFERENCE_LICENSE_HEADER_END@
 *//Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX.sdk/usr/include/netinet6/Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX.sdk/usr/include/netinet/in.h<netinet6/in6.h>bindresvport_sabindresvportsockaddr_in *getsourcefiltersockaddr_storage *setsourcefiltergetipv4sourcefilterin_addr *setipv4sourcefilterin_pktinfo &const in_pktinfoconst in_pktinfo &__msfilterreq &const __msfilterreqconst __msfilterreq &group_source_req &const group_source_reqconst group_source_req &group_req &const group_reqconst group_req &ip_mreq_source &const ip_mreq_sourceconst ip_mreq_source &ip_mreqn &const ip_mreqnconst ip_mreqn &ip_mreq &const ip_mreqconst ip_mreq &ip_opts &const ip_optsconst ip_opts &sockaddr_in &const sockaddr_inconst sockaddr_in &in_addr &const in_addrconst in_addr &in_pktinfo__msfilterreqgroup_source_reqgroup_reqip_mreq_sourceip_mreqnip_mreqip_optssockaddr_inin_addripi_addripi_spec_dstipi_ifindexmsfr_srcsmsfr_group__msfr_alignmsfr_nsrcsmsfr_fmodemsfr_ifindexgsr_sourcegsr_groupgsr_interfacegr_groupgr_interfaceimr_interfaceimr_sourceaddrimr_multiaddrimr_ifindeximr_addressip_dstsin_zerosin_addrsin_portsin_familysin_lens_addrIPCTL_MAXIDIPCTL_GIF_TTLIPCTL_KEEPFAITHIPCTL_FASTFORWARDINGIPCTL_ACCEPTSOURCEROUTEIPCTL_STATSIPCTL_INTRQDROPSIPCTL_INTRQMAXLENIPCTL_DIRECTEDBROADCASTIPCTL_SOURCEROUTEIPCTL_RTMAXCACHEIPCTL_RTMINEXPIREIPCTL_RTEXPIREIPCTL_DEFTTLIPCTL_SENDREDIRECTSIPCTL_FORWARDINGIPPROTO_MAXID(IPPROTO_AH + 1)IP_PORTRANGE_LOWIP_PORTRANGE_HIGHIP_PORTRANGE_DEFAULTMCAST_EXCLUDEMCAST_INCLUDEMCAST_UNDEFINED__MSFILTERREQ_DEFINEDIP_MAX_SOCK_MUTE_FILTERIP_MAX_SOCK_SRC_FILTERIP_MAX_GROUP_SRC_FILTERIP_MAX_MEMBERSHIPSIP_MIN_MEMBERSHIPSIP_DEFAULT_MULTICAST_LOOPIP_DEFAULT_MULTICAST_TTLMCAST_UNBLOCK_SOURCEMCAST_BLOCK_SOURCEMCAST_LEAVE_SOURCE_GROUPMCAST_JOIN_SOURCE_GROUPMCAST_LEAVE_GROUPMCAST_JOIN_GROUPIP_MSFILTERIP_UNBLOCK_SOURCEIP_BLOCK_SOURCEIP_DROP_SOURCE_MEMBERSHIPIP_ADD_SOURCE_MEMBERSHIPIP_MULTICAST_IFINDEXIP_TRAFFIC_MGT_BACKGROUNDIP_DUMMYNET_GETIP_DUMMYNET_FLUSHIP_DUMMYNET_DELIP_DUMMYNET_CONFIGUREIP_OLD_FW_RESETLOGIP_NAT__XXXIP_OLD_FW_GETIP_OLD_FW_ZEROIP_OLD_FW_FLUSHIP_OLD_FW_DELIP_OLD_FW_ADDIP_FW_RESETLOGIP_FW_GETIP_FW_ZEROIP_FW_FLUSHIP_FW_DELIP_FW_ADDIP_DONTFRAGIP_RECVTOSIP_RECVPKTINFOIP_PKTINFOIP_BOUND_IFIP_RECVTTLIP_STRIPHDRIP_FAITHIP_IPSEC_POLICYIP_RECVIFIP_PORTRANGEIP_RSVP_VIF_OFFIP_RSVP_VIF_ONIP_RSVP_OFFIP_RSVP_ONIP_MULTICAST_VIFIP_DROP_MEMBERSHIPIP_ADD_MEMBERSHIPIP_MULTICAST_LOOPIP_MULTICAST_TTLIP_MULTICAST_IFIP_RETOPTSIP_RECVDSTADDRIP_RECVRETOPTSIP_RECVOPTSIP_TTLIP_TOSIP_HDRINCLIP_OPTIONSINET_ADDRSTRLENIN_ARE_ADDR_EQUAL(a,b)(bcmp(&(a)->s_addr, &(b)->s_addr, sizeof (struct in_addr)) == 0)IN_LOOPBACKNETIN_ANY_LOCAL(i)(IN_LINKLOCAL(i) || IN_LOCAL_GROUP(i))IN_LOCAL_GROUP(i)(((u_int32_t)(i) & 0xffffff00) == 0xe0000000)IN_PRIVATE(i)((((u_int32_t)(i) & 0xff000000) == 0x0a000000) || (((u_int32_t)(i) & 0xfff00000) == 0xac100000) || (((u_int32_t)(i) & 0xffff0000) == 0xc0a80000))IN_ZERONET(i)(((u_int32_t)(i) & 0xff000000) == 0)IN_LOOPBACK(i)(((u_int32_t)(i) & 0xff000000) == 0x7f000000)IN_LINKLOCAL(i)(((u_int32_t)(i) & IN_CLASSB_NET) == IN_LINKLOCALNETNUM)IN_LINKLOCALNETNUM(u_int32_t)0xA9FE0000INADDR_MAX_LOCAL_GROUP(u_int32_t)0xe00000ffINADDR_ALLMDNS_GROUP(u_int32_t)0xe00000fbINADDR_PFSYNC_GROUP(u_int32_t)0xe00000f0INADDR_CARP_GROUP(u_int32_t)0xe0000012INADDR_ALLRPTS_GROUP(u_int32_t)0xe0000016INADDR_ALLRTRS_GROUP(u_int32_t)0xe0000002INADDR_ALLHOSTS_GROUP(u_int32_t)0xe0000001INADDR_UNSPEC_GROUP(u_int32_t)0xe0000000INADDR_NONEINADDR_LOOPBACK(u_int32_t)0x7f000001IN_BADCLASS(i)(((u_int32_t)(i) & 0xf0000000) == 0xf0000000)IN_EXPERIMENTAL(i)IN_MULTICAST(i)IN_CLASSD(i)IN_CLASSD_HOST0x0fffffffIN_CLASSD_NSHIFTIN_CLASSD_NET0xf0000000(((u_int32_t)(i) & 0xf0000000) == 0xe0000000)IN_CLASSC_HOST0x000000ffIN_CLASSC_NSHIFTIN_CLASSC_NET0xffffff00IN_CLASSC(i)(((u_int32_t)(i) & 0xe0000000) == 0xc0000000)IN_CLASSB_MAXIN_CLASSB_HOSTIN_CLASSB_NSHIFTIN_CLASSB_NETIN_CLASSB(i)(((u_int32_t)(i) & 0xc0000000) == 0x80000000)IN_CLASSA_MAXIN_CLASSA_HOSTIN_CLASSA_NSHIFTIN_CLASSA_NET0xff000000IN_CLASSA(i)(((u_int32_t)(i) & 0x80000000) == 0)INADDR_BROADCAST(u_int32_t)0xffffffffINADDR_ANY(u_int32_t)0x00000000IPPORT_RESERVEDSTARTIPPORT_HILASTAUTOIPPORT_HIFIRSTAUTOIPPORT_USERRESERVEDIPPORT_RESERVED__DARWIN_IPPORT_RESERVEDIPPROTO_DONEIPPROTO_MAXIPPROTO_RAWIPPROTO_DIVERTIPPROTO_SCTPIPPROTO_PGMIPPROTO_IPCOMPIPPROTO_PIMIPPROTO_GMTPIPPROTO_APESIPPROTO_ENCAPIPPROTO_ETHERIPIPPROTO_SCCSPIPPROTO_MICPIPPROTO_IPEIPIPPROTO_AX25IPPROTO_MTPIPPROTO_LARPIPPROTO_SRPCIPPROTO_OSPFIGPIPPROTO_IGRPIPPROTO_TCFIPPROTO_DGPIPPROTO_IGPIPPROTO_TTPIPPROTO_VINESIPPROTO_SVMTPIPPROTO_VMTPIPPROTO_EONIPPROTO_WBEXPAKIPPROTO_WBMONIPPROTO_NDIPPROTO_BRSATMONIPPROTO_PVPIPPROTO_WSNIPPROTO_CPHBIPPROTO_CPNXIPPROTO_IPCVIPPROTO_VISAIPPROTO_SATMONIPPROTO_ADFSIPPROTO_IPPCIPPROTO_RVDIPPROTO_KRYPTOLANIPPROTO_SATEXPAKIPPROTO_HELLOIPPROTO_CFTPIPPROTO_AHIPIPPROTO_DSTOPTSIPPROTO_NONEIPPROTO_ICMPV6IPPROTO_NHRPIPPROTO_SWIPEIPPROTO_INLSPIPPROTO_AHIPPROTO_ESPIPPROTO_BHAIPPROTO_MHRPIPPROTO_GREIPPROTO_RSVPIPPROTO_IDRPIPPROTO_FRAGMENTIPPROTO_ROUTINGIPPROTO_SDRPIPPROTO_IPV6IPPROTO_ILIPPROTO_TPXXIPPROTO_CMTPIPPROTO_DDPIPPROTO_XTPIPPROTO_IDPRIPPROTO_3PCIPPROTO_SEPIPPROTO_INPIPPROTO_NSPIPPROTO_BLTIPPROTO_TPIPPROTO_IRTPIPPROTO_RDPIPPROTO_LEAF2IPPROTO_LEAF1IPPROTO_TRUNK2IPPROTO_TRUNK1IPPROTO_IDPIPPROTO_PRMIPPROTO_HMPIPPROTO_MEASIPPROTO_MUXIPPROTO_UDPIPPROTO_CHAOSIPPROTO_XNETIPPROTO_EMCONIPPROTO_ARGUSIPPROTO_PUPIPPROTO_NVPIIIPPROTO_RCCMONIPPROTO_PIGPIPPROTO_EGPIPPROTO_STIPPROTO_TCPIPPROTO_IPIPIPPROTO_IPV4IPPROTO_GGPIPPROTO_IGMPIPPROTO_ICMPIPPROTO_HOPOPTSIPPROTO_IP_NETINET_IN_H_/* _NETINET_IN_H_ *//* INET6 stuff *//* default TTL for gif encap packet *//* use fast IP forwarding code *//* may accept source routed packets *//* ipstat structure *//* number of netisr q drops *//* max length of netisr queue *//* may re-broadcast received packets *//* may perform source routes *//* default TTL *//* don't list to IPPROTO_MAX *//*
 * Definitions for inet sysctl operations.
 *
 * Third level is protocol number.
 * Fourth level is desired variable within that protocol.
 *//* IP Header dst address *//* Local address *//*
 * IP_PKTINFO: Packet information (equivalent to  RFC2292 sec 5 for IPv4)
 * This structure is used for
 *
 * 1) Receiving ancilliary data about the datagram if IP_PKTINFO sockopt is
 *    set on the socket. In this case ipi_ifindex will contain the interface
 *    index the datagram was received on, ipi_addr is the IP address the
 *    datagram was received to.
 *
 * 2) Sending a datagram using a specific interface or IP source address.
 *    if ipi_ifindex is set to non-zero when in_pktinfo is passed as
 *    ancilliary data of type IP_PKTINFO, this will be used as the source
 *    interface to send the datagram from. If ipi_ifindex is null, ip_spec_dst
 *    will be used for the source address.
 *
 *    Note: if IP_BOUND_IF is set on the socket, ipi_ifindex in the ancillary
 *    IP_PKTINFO option silently overrides the bound interface when it is
 *    specified during send time.
 *//*
 * Argument for IP_PORTRANGE:
 * - which range to search when port is unspecified at bind() or connect()
 *//* fmode: exclude these source(s) *//* fmode: include these source(s) *//* fmode: not yet defined *//*
 * Filter modes; also used to represent per-socket filter mode internally.
 *//*
 * Advanced (Full-state) APIs [RFC3678]
 * The RFC specifies uint_t for the 6th argument to [sg]etsourcefilter().
 * We use uint32_t here to be consistent.
 *//* __MSFILTERREQ_DEFINED *//* group address *//* # of sources in msfr_srcs *//* filter mode for group *//* interface index *//*
 * The following structure is private; do not use it from user applications.
 * It is used to communicate IP_MSFILTER/IPV6_MSFILTER information between
 * the RFC 3678 libc functions and the kernel.
 *//* source address *//*
 * Argument structures for Protocol-Independent Multicast Source
 * Filter APIs. [RFC3678]
 *//* local IP address of interface *//* IP address of source *//* IP multicast address of group *//*
 * Argument structure for IPv4 Multicast Source Filter APIs. [RFC3678]
 *//* Interface index; cast to uint32_t *//*
 * Modified argument structure for IP_MULTICAST_IF, obtained from Linux.
 * This is used to specify an interface index for multicast sends, as
 * the IPv4 legacy APIs do not support this (unless IP_SENDIF is available).
 *//*
 * Argument structure for IP_ADD_MEMBERSHIP and IP_DROP_MEMBERSHIP.
 *//* XXX no longer used *//*
 * Default resource limits for IPv4 multicast source filtering.
 * These may be modified by sysctl.
 *//*
 * The imo_membership vector for each socket is now dynamically allocated at
 * run-time, bounded by USHRT_MAX, and is reallocated when needed, sized
 * according to a power-of-two increment.
 *//* unblock a source *//* block a source *//* leave a single source *//* join a source-specific group *//* leave all sources for group *//* join an any-source group *//* Protocol Independent Multicast API [RFC3678] *//* set/get filter list *//* The following option is private; do not use it from user applications. *//* drop a single source *//* IPv4 Source Filter Multicast API [RFC3678] *//* int*; set/get IP multicast i/f index *//* int*; get background IO flags; set background IO *//* get entire dummynet pipes *//* flush dummynet *//* delete a dummynet pipe from chain *//* add/configure a dummynet pipe *//* reset logging counters *//* set/get NAT opts XXX Deprecated, do not use *//* These older firewall socket option codes are maintained for backward compatibility. *//* don't fragment packet *//* bool; receive IP TOS w/dgram *//* receive pktinfo w/dgram *//* get pktinfo on recv socket, set src on sent dgram  *//* bool; receive reception TTL w/dgram *//* bool: drop receive of raw IP header *//* int; set/get security policy *//* for IPSEC *//* bool; receive reception if w/dgram *//* unset RSVP per-vif socket *//* set RSVP per-vif socket *//* disable RSVP in kernel *//* enable RSVP in kernel *//* set/get IP mcast virt. iface *//* ip_mreq; drop an IP group membership *//* ip_mreq; add an IP group membership *//* u_char; set/get IP multicast loopback *//* u_char; set/get IP multicast ttl *//* u_char; set/get IP multicast i/f  *//* ip_opts; set/get IP options *//* bool; receive IP dst addr w/dgram *//* bool; receive IP opts for response *//* bool; receive all IP opts w/dgram *//* int; IP time to live *//* int; IP type of service and preced. *//* int; header is included with data *//* buf/ip_opts; set/get IP options *//*
 * Options for use with [gs]etsockopt at the IP level.
 * First word of comment is data type; bool is stored in int.
 *//* actually variable in size *//* first hop, 0 w/o src rt *//*
 * Structure used to describe IP options.
 * Used to store options internally, to pass them to a process,
 * or to restore options retrieved earlier.
 * The ip_dst is used for the first-hop gateway when using a source route
 * (this gets put into the header proper).
 *//*
 * Socket address, internet style.
 *//* official! *//* 169.254.0.0 *//* 224.0.0.255 *//* 224.0.0.251 *//* 224.0.0.240 *//* 224.0.0.18 *//* 224.0.0.22, IGMPv3 *//* 224.0.0.2 *//* 224.0.0.1 *//* 224.0.0.0 *//* -1 return *//* routing needn't know.    *//* net and host fields, but *//* These ones aren't really *//* must be masked *//*
 * Definitions of bits in internet address integers.
 * On subnets, the decomposition of addresses to host and net parts
 * is done according to subnet mask, not the masks here.
 *//*
 * Internet address (a structure for historical reasons)
 *//*
 * Scanning for a free reserved port return a value below IPPORT_RESERVED,
 * but higher than IPPORT_RESERVEDSTART.  Traditionally the start value was
 * 512, but that conflicts with some well-known-services that firewalls may
 * have a fit if we use.
 *//*
 * Default local port range to use by setting IP_PORTRANGE_HIGH
 *//*
 * Ports < IPPORT_RESERVED are reserved for
 * privileged processes (e.g. root).         (IP_PORTRANGE_LOW)
 * Ports > IPPORT_USERRESERVED are reserved
 * for servers, not necessarily privileged.  (IP_PORTRANGE_DEFAULT)
 *//*
 * Local port number conventions:
 *
 * When a user does a bind(2) or connect(2) with a port number of zero,
 * a non-conflicting local port address is chosen.
 * The default range is IPPORT_RESERVED through
 * IPPORT_USERRESERVED, although that is settable by sysctl.
 *
 * A user may set the IPPROTO_IP option IP_PORTRANGE to change this
 * default assignment range.
 *
 * The value IP_PORTRANGE_DEFAULT causes the default behavior.
 *
 * The value IP_PORTRANGE_HIGH changes the range of candidate port numbers
 * into the "high" range.  These are reserved for client outbound connections
 * which do not want to be filtered by any firewalls.
 *
 * The value IP_PORTRANGE_LOW changes the range to the "low" are
 * that is (by convention) restricted to privileged processes.  This
 * convention is based on "vouchsafe" principles only.  It is only secure
 * if you trust the remote host to restrict these ports.
 *
 * The default range of ports and the high range can be changed by
 * sysctl(3).  (net.inet.ip.port{hi,low}{first,last}_auto)
 *
 * Changing those values has bad security implications if you are
 * using a a stateless firewall that is allowing packets outside of that
 * range in order to allow transparent outgoing connections.
 *
 * Such a firewall configuration will generally depend on the use of these
 * default values.  If you change them, you may find your Security
 * Administrator looking for you with a heavy object.
 *
 * For a slightly more orthodox text view on this:
 *
 *            ftp://ftp.isi.edu/in-notes/iana/assignments/port-numbers
 *
 *    port numbers are divided into three ranges:
 *
 *                0 -  1023 Well Known Ports
 *             1024 - 49151 Registered Ports
 *            49152 - 65535 Dynamic and/or Private Ports
 *
 *//* last return value of *_input(), meaning "all job for this pkt is done".  *//* raw IP packet *//* divert pseudo-protocol *//* BSD Private, local use, namespace incursion *//* 253-254: Experimentation and testing; 255: Reserved (RFC3692) *//* SCTP *//* PGM *//* payload compression (IPComp) *//* Protocol Independent Mcast *//* 101-252: Partly Unassigned *//* GMTP*//* any private encr. scheme *//* encapsulation header *//* Ethernet IP encapsulation *//* Semaphore Comm. security *//* Mobile Int.ing control *//* IP encapsulated in IP *//* AX.25 Frames *//* Multicast Transport *//* Locus Address Resoloution *//* Strite RPC protocol *//* OSPFIGP *//* Cisco/GXS IGRP *//* TCF *//* dissimilar gateway prot. *//* NSFNET-IGP *//* TTP *//* Banyon VINES *//* Secure VMTP *//* VMTP *//* ISO cnlp *//* WIDEBAND EXPAK *//* WIDEBAND Monitoring *//* Sun net disk proto (temp.) *//* BackRoom SATNET Monitoring *//* Packet Video Protocol *//* Wang Span Network *//* Comp. Prot. HeartBeat *//* Comp. Prot. Net. Executive *//* Packet Core Utility *//* VISA Protocol *//* Satnet Monitoring *//* Any distributed FS *//* Pluribus Packet Core *//* Remote Virtual Disk *//* Kryptolan *//* SATNET/Backroom EXPAK *//* "hello" routing protocol *//* CFTP *//* any host internal protocol *//* IP6 destination option *//* IP6 no next header *//* ICMP6 *//* 55-57: Unassigned *//* Next Hop Resolution *//* IP with encryption *//* Integ. Net Layer Security *//* IP6 Auth Header *//* IP6 Encap Sec. Payload *//* BHA *//* Mobile Host Routing *//* General Routing Encap. *//* resource reservation *//* InterDomain Routing*//* IP6 fragmentation header *//* IP6 routing header *//* Source Demand Routing *//* IP6 header *//* IL transport protocol *//* TP++ Transport *//* Control Message Transport *//* Datagram Delivery *//* XTP *//* InterDomain Policy Routing *//* Third Party Connect *//* Sequential Exchange *//* Merit Internodal *//* Network Services *//* Bulk Data Transfer *//* tp-4 w/ class negotiation *//* Reliable Transaction *//* Reliable Data *//* Leaf-2 *//* Leaf-1 *//* Trunk-2 *//* Trunk-1 *//* xns idp *//* Packet Radio Measurement *//* Host Monitoring *//* DCN Measurement Subsystems *//* Multiplexing *//* user datagram protocol *//* Chaos*//* Cross Net Debugger *//* EMCON *//* Argus *//* pup *//* network voice protocol*//* BBN RCC Monitoring *//* private interior gateway *//* exterior gateway protocol *//* Stream protocol II *//* tcp *//* for compatibility *//* IPv4 encapsulation *//* gateway^2 (deprecated) *//* group mgmt protocol *//* control message protocol *//* IP6 hop-by-hop options *//* dummy for IP *//*
 * Protocols (RFC 1700)
 *//*
 * Constants and structures defined by the internet system,
 * Per RFC 790, September 1981, and numerous additions.
 *//*
 * The following two #includes insure htonl and family are defined
 *//*
 * POSIX 1003.1-2003
 * "Inclusion of the <netinet/in.h> header may also make visible all
 *  symbols from <inttypes.h> and <sys/socket.h>".
 *//* uint(8|16|32)_t *//*
 * Copyright (c) 1982, 1986, 1990, 1993
 *	The Regents of the University of California.  All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *	This product includes software developed by the University of
 *	California, Berkeley and its contributors.
 * 4. Neither the name of the University nor the names of its contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 *
 *	@(#)in.h	8.3 (Berkeley) 1/3/94
 * $FreeBSD: src/sys/netinet/in.h,v 1.48.2.2 2001/04/21 14:53:06 ume Exp $
 *//Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX.sdk/usr/include/netinet/Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX.sdk/usr/include/netinet/tcp.htcp_connection_info &const tcp_connection_infoconst tcp_connection_info &tcphdr &const tcphdrconst tcphdr &tcp_connection_infotcphdrtcp_cctcp_seqtcpi_txretransmitpacketstcpi_rxoutoforderbytestcpi_rxbytestcpi_rxpacketstcpi_txretransmitbytestcpi_txbytestcpi_txpackets__pad2tcpi_tfo_onebyte_proxytcpi_tfo_recv_blackholetcpi_tfo_send_blackholetcpi_tfo_heuristics_disabletcpi_tfo_no_cookie_rcvtcpi_tfo_cookie_wrongtcpi_tfo_cookie_invalidtcpi_tfo_cookie_senttcpi_tfo_cookie_req_rcvtcpi_tfo_syn_data_rcvtcpi_tfo_syn_data_ackedtcpi_tfo_syn_data_senttcpi_tfo_syn_losstcpi_tfo_cookie_rcvtcpi_tfo_cookie_reqtcpi_rttvartcpi_srtttcpi_rttcurtcpi_rcv_wndtcpi_snd_sbbytestcpi_snd_wndtcpi_snd_cwndtcpi_snd_ssthreshtcpi_maxsegtcpi_rtotcpi_flagstcpi_options__pad1tcpi_rcv_wscaletcpi_snd_wscaletcpi_stateth_urpth_sumth_winth_flagsth_offth_x2th_ackth_seqth_dportth_sportTCPCI_FLAG_REORDERING_DETECTEDTCPCI_FLAG_LOSSRECOVERYTCPCI_OPT_ECNTCPCI_OPT_WSCALETCPCI_OPT_SACKTCPCI_OPT_TIMESTAMPSTCP_NOTSENT_LOWAT0x201TCP_CONNECTION_INFO0x106TCP_FASTOPEN0x105TCP_ENABLE_ECN0x104TCP_SENDMOREACKS0x103TCP_KEEPCNT0x102TCP_KEEPINTVL0x101TCP_RXT_FINDROPTCP_RXT_CONNDROPTIMEPERSIST_TIMEOUTTCP_CONNECTIONTIMEOUTTCP_KEEPALIVETCP_NOOPTTCP_NOPUSHTCP_MAXSEGTCP_NODELAYTCP_MAXOLEN(TCP_MAXHLEN - sizeof(struct tcphdr))TCP_MAXHLEN(0xf<<2)TCP_MAX_WINSHIFTTTCP_CLIENT_SND_WNDTCP_MAXWINTCP6_MSSTCP_MINMSSTCP_MSSTCP_MAX_SACKMAX_SACK_BLKSTCPOPT_SACK_HDR(TCPOPT_NOP<<24|TCPOPT_NOP<<16|TCPOPT_SACK<<8)TCPOPT_SACK_PERMIT_HDR(TCPOPT_NOP<<24|TCPOPT_NOP<<16|TCPOPT_SACK_PERMITTED<<8|TCPOLEN_SACK_PERMITTED)TCPOLEN_FASTOPEN_REQTCPOPT_FASTOPENTCPOLEN_SIGNATURETCPOPT_SIGNATURETCPOPT_CC_HDR(ccopt)(TCPOPT_NOP<<24|TCPOPT_NOP<<16|(ccopt)<<8|TCPOLEN_CC)TCPOLEN_CC_APPA(TCPOLEN_CC+2)TCPOLEN_CCTCPOPT_CCECHOTCPOPT_CCNEWTCPOPT_CCMAX_TCPOPTLENTCPOPT_TSTAMP_HDR(TCPOPT_NOP<<24|TCPOPT_NOP<<16|TCPOPT_TIMESTAMP<<8|TCPOLEN_TIMESTAMP)TCPOLEN_TSTAMP_APPA(TCPOLEN_TIMESTAMP+2)TCPOLEN_TIMESTAMPTCPOPT_TIMESTAMPTCPOLEN_SACKTCPOPT_SACKTCPOLEN_SACK_PERMITTEDTCPOPT_SACK_PERMITTEDTCPOLEN_WINDOWTCPOPT_WINDOWTCPOLEN_MAXSEGTCPOPT_MAXSEGTCPOPT_NOPTCPOPT_EOLTH_ACCEPT(TH_FIN|TH_SYN|TH_RST|TH_ACK)TH_FLAGS(TH_FIN|TH_SYN|TH_RST|TH_ACK|TH_URG|TH_ECE|TH_CWR)TH_CWRTH_ECETH_URGTH_ACKTH_PUSHTH_RSTTH_SYNTH_FINtcp6hdrtcp6_seq_NETINET_TCP_H___DARWIN_BYTE_ORDER == __DARWIN_LITTLE_ENDIANMPTCP/* A proxy acknowledges all but one byte of the SYN *//* A receiver-blackhole got detected *//* A sending-blackhole got detected *//* TFO-heuristics disabled it *//* We did not receive a cookie upon our request *//* Our sent cookie was wrong *//* Server received an invalid cookie *//* Server announced cookie *//* Server received cookie-request *//* Server received SYN+data with a valid cookie *//* SYN+data has been fully acknowledged *//* SYN+data has been sent out *//* Fallback to reg. TCP after SYN-loss *//* Cookie received? *//* Cookie requested? *//* RTT variance *//* average RTT in ms *//* most recent RTT in ms *//* receive window in bytes*//* bytes in send socket buffer, including in-flight data *//* send widnow in bytes *//* send congestion window in bytes *//* slow start threshold in bytes *//* maximum segment size supported *//* retransmit timeout in ms *//* ECN enabled *//* Window scaling enabled *//* SACK enabled *//* Timestamps enabled *//* TCP options supported *//* Window scale for receive window *//* Window scale for send window *//* connection state *//* Low water mark for TCP unsent data *//* State of TCP connection *//* Enable/Disable TCP Fastopen on this socket *//* Enable ECN on a connection *//* always ack every other packet *//* number of keepalives before close *//* interval between keepalives *//* when this option is set, drop a connection
	                                 * after retransmitting the FIN 3 times. It will
	                                 * prevent holding too many mbufs in socket
	                                 * buffer queues.
	                                 *//* time after which tcp retransmissions will be
	                                 * stopped and the connection will be dropped
	                                 *//* time after which a connection in
	                                 *  persist timeout will terminate.
	                                 *  see draft-ananth-tcpm-persist-02.txt
	                                 *//* connection timeout *//* idle time used when SO_KEEPALIVE is enabled *//* don't use TCP options *//* don't push last block of write *//* set maximum segment size *//* don't delay send to coalesce packets *//*
 * User-settable options (used with setsockopt).
 *//* max space left for options *//* max length of header in bytes *//* maximum window shift *//* dflt send window for T/TCP client *//* largest value for (unscaled) window *//*
 * Default maximum segment size for TCP6.
 * With an IP6 MSS of 1280, this is 1220,
 * but 1024 is probably more convenient. (xxx kazu in doubt)
 * This should be defined as MIN(1024, IP6_MSS - sizeof (struct tcpip6hdr))
 *//*
 * TCP_MINMSS is defined to be 216 which is fine for the smallest
 * link MTU (256 bytes, SLIP interface) in the Internet.
 * However it is very unlikely to come across such low MTU interfaces
 * these days (anno dato 2004).
 * Probably it can be set to 512 without ill effects. But we play safe.
 * See tcp_subr.c tcp_minmss SYSCTL declaration for more comments.
 * Setting this to "0" disables the minmss check.
 *//*
 * Default maximum segment size for TCP.
 * With an IP MTU of 576, this is 536,
 * but 512 is probably more convenient.
 * This should be defined as MIN(512, IP_MSS - sizeof (struct tcpiphdr)).
 *//* MAX # SACKs sent in any segment *//*
 * A SACK option that specifies n blocks will have a length of (8*n + 2)
 * bytes, so the 40 bytes available for TCP options can specify a
 * maximum of 4 blocks.
 *//* Max # SACK blocks stored at sender side *//* Miscellaneous constants *//* Option definitions *//* Keyed MD5: RFC 2385 *//* CC options: RFC-1644 *//* Absolute maximum TCP options len *//* appendix A *//* len of sack block *//* Experimental *//* urgent pointer *//* checksum *//* window *//* (unused) *//* data offset *//* acknowledgement number *//* destination port *//* source port *//*
 * TCP header.
 * Per RFC 793, September, 1981.
 *//* for KAME src sync over BSD*'s *//* connection count per rfc1644 *//*
 * Copyright (c) 1982, 1986, 1993
 *	The Regents of the University of California.  All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *	This product includes software developed by the University of
 *	California, Berkeley and its contributors.
 * 4. Neither the name of the University nor the names of its contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 *
 *	@(#)tcp.h	8.1 (Berkeley) 6/10/93
 * $FreeBSD: src/sys/netinet/tcp.h,v 1.13.2.3 2001/03/01 22:08:42 jlemon Exp $
 *//Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX.sdk/usr/include/mach/machine.hcpu_threadtype_tcpu_subtype_tcpu_type_tCPUFAMILY_INTEL_6_26CPUFAMILY_INTEL_NEHALEMCPUFAMILY_INTEL_6_23CPUFAMILY_INTEL_PENRYNCPUSUBFAMILY_ARM_HC_HDCPUSUBFAMILY_ARM_HSCPUSUBFAMILY_ARM_MCPUSUBFAMILY_ARM_HGCPUSUBFAMILY_ARM_HPCPUSUBFAMILY_UNKNOWNCPUFAMILY_ARM_BLIZZARD_AVALANCHE0xda33d83dCPUFAMILY_ARM_FIRESTORM_ICESTORM0x1b588bb3CPUFAMILY_ARM_LIGHTNING_THUNDER0x462504d2CPUFAMILY_ARM_VORTEX_TEMPEST0x07d34b9fCPUFAMILY_ARM_MONSOON_MISTRAL0xe81e7ef6CPUFAMILY_ARM_HURRICANE0x67ceee93CPUFAMILY_ARM_TWISTER0x92fb37c8CPUFAMILY_ARM_TYPHOON0x2c91a47eCPUFAMILY_ARM_CYCLONE0x37a09642CPUFAMILY_ARM_SWIFT0x1e2d6381CPUFAMILY_ARM_150xa8511bcaCPUFAMILY_ARM_140x96077ef1CPUFAMILY_ARM_130x0cc90e64CPUFAMILY_ARM_120xbd1b0ae9CPUFAMILY_ARM_XSCALE0x53b005f5CPUFAMILY_ARM_110x8ff620d8CPUFAMILY_ARM_90xe73283aeCPUFAMILY_INTEL_COMETLAKE0x1cf8a03eCPUFAMILY_INTEL_ICELAKE0x38435547CPUFAMILY_INTEL_KABYLAKE0x0f817246CPUFAMILY_INTEL_SKYLAKE0x37fc219fCPUFAMILY_INTEL_BROADWELL0x582ed09cCPUFAMILY_INTEL_HASWELL0x10b282dcCPUFAMILY_INTEL_IVYBRIDGE0x1f65e835CPUFAMILY_INTEL_SANDYBRIDGE0x5490b78cCPUFAMILY_INTEL_WESTMERE0x573b5eec0x6b5a4cd20x78ea4fbcCPUFAMILY_INTEL_6_130xaa33392bCPUFAMILY_POWERPC_G50xed76d8aaCPUFAMILY_POWERPC_G40x77c184aeCPUFAMILY_POWERPC_G30xcee41549CPUFAMILY_UNKNOWNCPU_SUBTYPE_ARM64_32_V8((cpu_subtype_t) 1)CPU_SUBTYPE_ARM64_32_ALL((cpu_subtype_t) 0)CPU_SUBTYPE_ARM64_PTR_AUTH_VERSION(x)(((x) & CPU_SUBTYPE_ARM64_PTR_AUTH_MASK) >> 24)CPU_SUBTYPE_ARM64_PTR_AUTH_MASK0x0f000000CPU_SUBTYPE_ARM64E((cpu_subtype_t) 2)CPU_SUBTYPE_ARM64_V8CPU_SUBTYPE_ARM64_ALLCPU_SUBTYPE_ARM_V8M((cpu_subtype_t) 17)CPU_SUBTYPE_ARM_V7EM((cpu_subtype_t) 16)CPU_SUBTYPE_ARM_V7M((cpu_subtype_t) 15)CPU_SUBTYPE_ARM_V6M((cpu_subtype_t) 14)CPU_SUBTYPE_ARM_V8((cpu_subtype_t) 13)CPU_SUBTYPE_ARM_V7K((cpu_subtype_t) 12)CPU_SUBTYPE_ARM_V7S((cpu_subtype_t) 11)CPU_SUBTYPE_ARM_V7F((cpu_subtype_t) 10)CPU_SUBTYPE_ARM_V7((cpu_subtype_t) 9)CPU_SUBTYPE_ARM_XSCALE((cpu_subtype_t) 8)CPU_SUBTYPE_ARM_V5TEJ((cpu_subtype_t) 7)CPU_SUBTYPE_ARM_V6((cpu_subtype_t) 6)CPU_SUBTYPE_ARM_V4T((cpu_subtype_t) 5)CPU_SUBTYPE_ARM_ALLCPU_SUBTYPE_POWERPC_970((cpu_subtype_t) 100)CPU_SUBTYPE_POWERPC_7450CPU_SUBTYPE_POWERPC_7400CPU_SUBTYPE_POWERPC_750CPU_SUBTYPE_POWERPC_620CPU_SUBTYPE_POWERPC_604eCPU_SUBTYPE_POWERPC_604CPU_SUBTYPE_POWERPC_603evCPU_SUBTYPE_POWERPC_603e((cpu_subtype_t) 4)CPU_SUBTYPE_POWERPC_603((cpu_subtype_t) 3)CPU_SUBTYPE_POWERPC_602CPU_SUBTYPE_POWERPC_601CPU_SUBTYPE_POWERPC_ALLCPU_SUBTYPE_I860_860CPU_SUBTYPE_I860_ALLCPU_SUBTYPE_SPARC_ALLCPU_SUBTYPE_MC88110CPU_SUBTYPE_MC88100CPU_SUBTYPE_MC88000_ALLCPU_SUBTYPE_HPPA_7100LCCPU_SUBTYPE_HPPA_7100CPU_SUBTYPE_HPPA_ALLCPU_SUBTYPE_MC98601CPU_SUBTYPE_MC98000_ALLCPU_SUBTYPE_MIPS_R3000CPU_SUBTYPE_MIPS_R3000aCPU_SUBTYPE_MIPS_R2000CPU_SUBTYPE_MIPS_R2000aCPU_SUBTYPE_MIPS_R2800CPU_SUBTYPE_MIPS_R2600CPU_SUBTYPE_MIPS_R2300CPU_SUBTYPE_MIPS_ALLCPU_THREADTYPE_INTEL_HTT((cpu_threadtype_t) 1)CPU_SUBTYPE_X86_64_H((cpu_subtype_t)8)CPU_SUBTYPE_X86_ARCH1((cpu_subtype_t)4)CPU_SUBTYPE_X86_64_ALL((cpu_subtype_t)3)CPU_SUBTYPE_X86_ALLCPU_SUBTYPE_INTEL_MODEL_ALLCPU_SUBTYPE_INTEL_MODEL(x)((x) >> 4)CPU_SUBTYPE_INTEL_FAMILY_MAXCPU_SUBTYPE_INTEL_FAMILY(x)((x) & 15)CPU_SUBTYPE_XEON_MPCPU_SUBTYPE_INTEL(12, 1)CPU_SUBTYPE_XEONCPU_SUBTYPE_INTEL(12, 0)CPU_SUBTYPE_ITANIUM_2CPU_SUBTYPE_INTEL(11, 1)CPU_SUBTYPE_ITANIUMCPU_SUBTYPE_INTEL(11, 0)CPU_SUBTYPE_PENTIUM_4_MCPU_SUBTYPE_INTEL(10, 1)CPU_SUBTYPE_PENTIUM_4CPU_SUBTYPE_INTEL(10, 0)CPU_SUBTYPE_PENTIUM_MCPU_SUBTYPE_INTEL(9, 0)CPU_SUBTYPE_PENTIUM_3_XEONCPU_SUBTYPE_INTEL(8, 2)CPU_SUBTYPE_PENTIUM_3_MCPU_SUBTYPE_INTEL(8, 1)CPU_SUBTYPE_PENTIUM_3CPU_SUBTYPE_INTEL(8, 0)CPU_SUBTYPE_CELERON_MOBILECPU_SUBTYPE_INTEL(7, 7)CPU_SUBTYPE_CELERONCPU_SUBTYPE_INTEL(7, 6)CPU_SUBTYPE_PENTII_M5CPU_SUBTYPE_INTEL(6, 5)CPU_SUBTYPE_PENTII_M3CPU_SUBTYPE_INTEL(6, 3)CPU_SUBTYPE_PENTPROCPU_SUBTYPE_INTEL(6, 1)CPU_SUBTYPE_PENTCPU_SUBTYPE_INTEL(5, 0)CPU_SUBTYPE_586CPU_SUBTYPE_486SXCPU_SUBTYPE_INTEL(4, 8)CPU_SUBTYPE_486CPU_SUBTYPE_INTEL(4, 0)CPU_SUBTYPE_386CPU_SUBTYPE_INTEL(3, 0)CPU_SUBTYPE_I386_ALLCPU_SUBTYPE_INTEL(f,m)((cpu_subtype_t) (f) + ((m) << 4))CPU_SUBTYPE_MC68030_ONLYCPU_SUBTYPE_MC68040CPU_SUBTYPE_MC68030CPU_SUBTYPE_MC680x0_ALLCPU_SUBTYPE_UVAXIIICPU_SUBTYPE_VAX8800CPU_SUBTYPE_VAX8650CPU_SUBTYPE_VAX8600CPU_SUBTYPE_VAX8500CPU_SUBTYPE_VAX8200CPU_SUBTYPE_UVAXIICPU_SUBTYPE_UVAXICPU_SUBTYPE_VAX730CPU_SUBTYPE_VAX750CPU_SUBTYPE_VAX785CPU_SUBTYPE_VAX780CPU_SUBTYPE_VAX_ALLCPU_THREADTYPE_NONE((cpu_threadtype_t) 0)CPU_SUBTYPE_BIG_ENDIANCPU_SUBTYPE_LITTLE_ENDIANCPU_SUBTYPE_MULTIPLE((cpu_subtype_t) -1)CPU_SUBTYPE_ANYCPU_SUBTYPE_PTRAUTH_ABICPU_SUBTYPE_LIB64CPU_SUBTYPE_MASKCPU_TYPE_POWERPC64(CPU_TYPE_POWERPC | CPU_ARCH_ABI64)CPU_TYPE_POWERPC((cpu_type_t) 18)CPU_TYPE_I860((cpu_type_t) 15)CPU_TYPE_SPARC((cpu_type_t) 14)CPU_TYPE_MC88000((cpu_type_t) 13)CPU_TYPE_ARM64_32(CPU_TYPE_ARM | CPU_ARCH_ABI64_32)CPU_TYPE_ARM64(CPU_TYPE_ARM | CPU_ARCH_ABI64)CPU_TYPE_ARM((cpu_type_t) 12)CPU_TYPE_HPPA((cpu_type_t) 11)CPU_TYPE_MC98000((cpu_type_t) 10)CPU_TYPE_X86_64(CPU_TYPE_X86 | CPU_ARCH_ABI64)CPU_TYPE_I386CPU_TYPE_X86((cpu_type_t) 7)CPU_TYPE_MC680x0((cpu_type_t) 6)CPU_TYPE_VAX((cpu_type_t) 1)CPU_TYPE_ANY((cpu_type_t) -1)CPU_ARCH_ABI64_32CPU_ARCH_ABI64CPU_ARCH_MASKCPU_STATE_NICECPU_STATE_IDLECPU_STATE_SYSTEMCPU_STATE_USERCPU_STATE_MAX_MACH_MACHINE_H_/* _MACH_MACHINE_H_ *//* The following synonyms are deprecated: *//*
 *	CPU families (sysctl hw.cpufamily)
 *
 * These are meant to identify the CPU's marketing name - an
 * application can map these to (possibly) localized strings.
 * NB: the encodings of the CPU families are intentionally arbitrary.
 * There is no ordering, and you should never try to deduce whether
 * or not some feature is available based on the family.
 * Use feature flags (eg, hw.optional.altivec) to test for optional
 * functionality.
 *//* !__ASSEMBLER__ *//*
 *  ARM64_32 subtypes
 *//* CPU subtype feature flags for ptrauth on arm64e platforms *//*
 *  ARM64 subtypes
 *//* Not meant to be run under xnu *//* Swift *//* Cortex A9 *//* ARMv7-A and ARMv7-R *//*
 *	ARM subtypes
 *//*
 *	PowerPC subtypes
 *//*
 *	I860 subtypes
 *//*
 *	SPARC subtypes
 *//*
 *	MC88000 subtypes.
 *//*
 *	HPPA subtypes for Hewlett-Packard HP-PA family of
 *	risc processors. Port by NeXT to 700 series.
 *//*
 *	MC98000 (PowerPC) subtypes
 *//* 3max *//* pmax *//*
 *	Mips subtypes.
 *//* Haswell feature subset *//*
 *	X86 subtypes.
 */// 8 << 4 = 128/*
 *	I386 subtypes
 *//*
 *      680x0 subtypes
 *
 * The subtype definitions here are unusual for historical reasons.
 * NeXT used to consider 68030 code as generic 68000 code.  For
 * backwards compatability:
 *
 *	CPU_SUBTYPE_MC68030 symbol has been preserved for source code
 *	compatability.
 *
 *	CPU_SUBTYPE_MC680x0_ALL has been defined to be the same
 *	subtype as CPU_SUBTYPE_MC68030 for binary comatability.
 *
 *	CPU_SUBTYPE_MC68030_ONLY has been added to allow new object
 *	files to be tagged as containing 68030-specific instructions.
 *//*
 *	VAX subtypes (these do *not* necessary conform to the actual cpu
 *	ID assigned by DEC available via the SID register).
 *//*
 *     Machine threadtypes.
 *     This is none - not defined - for most machine types/subtypes.
 *//*
 *	Object files that are hand-crafted to run on any
 *	implementation of an architecture are tagged with
 *	CPU_SUBTYPE_MULTIPLE.  This functions essentially the same as
 *	the "ALL" subtype of an architecture except that it allows us
 *	to easily find object files that may need to be modified
 *	whenever a new implementation of an architecture comes out.
 *
 *	It is the responsibility of the implementor to make sure the
 *	software handles unsupported implementations elegantly.
 *//*
 *      When selecting a slice, ANY will pick the slice with the best
 *      grading for the selected cpu_type_t, unlike the "ALL" subtypes,
 *      which are the slices that can run on any hardware for that cpu type.
 *//* pointer authentication with versioned ABI *//* 64 bit libraries *//* mask for feature flags *//*
 * Capability bits used in the definition of cpu_subtype.
 *//*
 *	Machine subtypes (these are defined here, instead of in a machine
 *	dependent directory, so that any program can get all definitions
 *	regardless of where is it compiled).
 *//* skip				((cpu_type_t) 22 *//* skip				((cpu_type_t) 21 *//* skip				((cpu_type_t) 20 *//* skip				((cpu_type_t) 19)	*//* skip				((cpu_type_t) 17)	*//* skip	CPU_TYPE_ALPHA		((cpu_type_t) 16)	*//* skip                         ((cpu_type_t) 9)	*//* skip CPU_TYPE_MIPS		((cpu_type_t) 8)	*//* compatibility *//* skip				((cpu_type_t) 5)	*//* skip				((cpu_type_t) 4)	*//* skip				((cpu_type_t) 3)	*//* skip				((cpu_type_t) 2)	*//*
 *	Machine types known by all.
 *//* ABI for 64-bit hardware with 32-bit types; LP32 *//* 64 bit ABI *//* mask for architecture bits *//*
 * Capability bits used in the definition of cpu_type.
 *//*	File:	machine.h
 *	Author:	Avadis Tevanian, Jr.
 *	Date:	1986
 *
 *	Machine independent machine abstraction.
 *//*
 * Copyright (c) 2007-2016 Apple, Inc. All rights reserved.
 * Copyright (c) 2000 Apple Computer, Inc. All rights reserved.
 *
 * @APPLE_OSREFERENCE_LICENSE_HEADER_START@
 *
 * This file contains Original Code and/or Modifications of Original Code
 * as defined in and that are subject to the Apple Public Source License
 * Version 2.0 (the 'License'). You may not use this file except in
 * compliance with the License. The rights granted to you under the License
 * may not be used to create, or enable the creation or redistribution of,
 * unlawful or unlicensed copies of an Apple operating system, or to
 * circumvent, violate, or enable the circumvention or violation of, any
 * terms of an Apple operating system software license agreement.
 *
 * Please obtain a copy of the License at
 * http://www.opensource.apple.com/apsl/ and read it before using this file.
 *
 * The Original Code and all software distributed under the License are
 * distributed on an 'AS IS' basis, WITHOUT WARRANTY OF ANY KIND, EITHER
 * EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES,
 * INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE, QUIET ENJOYMENT OR NON-INFRINGEMENT.
 * Please see the License for the specific language governing rights and
 * limitations under the License.
 *
 * @APPLE_OSREFERENCE_LICENSE_HEADER_END@
 *//Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX.sdk/usr/include/sys/proc_info.h<uuid/uuid.h><mach/machine.h><netinet/tcp.h><netinet/in.h><net/route.h><net/if.h><sys/event.h><sys/kern_control.h><sys/un.h><sys/mount.h>channel_fdinfo &const channel_fdinfoconst channel_fdinfo &proc_channel_info &const proc_channel_infoconst proc_channel_info &proc_fileportinfo &const proc_fileportinfoconst proc_fileportinfo &proc_fdinfo &const proc_fdinfoconst proc_fdinfo &appletalk_fdinfo &const appletalk_fdinfoconst appletalk_fdinfo &appletalk_info &const appletalk_infoconst appletalk_info &kqueue_fdinfo &const kqueue_fdinfoconst kqueue_fdinfo &kqueue_dyninfo &const kqueue_dyninfoconst kqueue_dyninfo &kqueue_info &const kqueue_infoconst kqueue_info &pipe_fdinfo &const pipe_fdinfoconst pipe_fdinfo &pipe_info &const pipe_infoconst pipe_info &pshm_fdinfo &const pshm_fdinfoconst pshm_fdinfo &pshm_info &const pshm_infoconst pshm_info &psem_fdinfo &const psem_fdinfoconst psem_fdinfo &psem_info &const psem_infoconst psem_info &socket_fdinfo &const socket_fdinfoconst socket_fdinfo &socket_info &const socket_infoconst socket_info &sockbuf_info &const sockbuf_infoconst sockbuf_info &vsock_sockinfo &const vsock_sockinfoconst vsock_sockinfo &kern_ctl_info &const kern_ctl_infoconst kern_ctl_info &kern_event_info &const kern_event_infoconst kern_event_info &ndrv_info &const ndrv_infoconst ndrv_info &un_sockinfo &const un_sockinfoconst un_sockinfo &tcp_sockinfo &const tcp_sockinfoconst tcp_sockinfo &in_sockinfo &const in_sockinfoconst in_sockinfo &in4in6_addr &const in4in6_addrconst in4in6_addr &proc_threadwithpathinfo &const proc_threadwithpathinfoconst proc_threadwithpathinfo &proc_vnodepathinfo &const proc_vnodepathinfoconst proc_vnodepathinfo &proc_regionpath &const proc_regionpathconst proc_regionpath &proc_regionwithpathinfo &const proc_regionwithpathinfoconst proc_regionwithpathinfo &vnode_fdinfowithpath &const vnode_fdinfowithpathconst vnode_fdinfowithpath &vnode_fdinfo &const vnode_fdinfoconst vnode_fdinfo &vnode_info_path &const vnode_info_pathconst vnode_info_path &vnode_info &const vnode_infoconst vnode_info &vinfo_stat &const vinfo_statconst vinfo_stat &proc_exitreasoninfo &const proc_exitreasoninfoconst proc_exitreasoninfo &proc_exitreasonbasicinfo &const proc_exitreasonbasicinfoconst proc_exitreasonbasicinfo &proc_fileinfo &const proc_fileinfoconst proc_fileinfo &proc_workqueueinfo &const proc_workqueueinfoconst proc_workqueueinfo &proc_regioninfo &const proc_regioninfoconst proc_regioninfo &proc_threadinfo &const proc_threadinfoconst proc_threadinfo &proc_taskallinfo &const proc_taskallinfoconst proc_taskallinfo &proc_taskinfo &const proc_taskinfoconst proc_taskinfo &proc_bsdshortinfo &const proc_bsdshortinfoconst proc_bsdshortinfo &proc_bsdinfo &const proc_bsdinfoconst proc_bsdinfo &channel_fdinfoproc_channel_infoproc_fileportinfoproc_fdinfoproc_info_udata_tappletalk_fdinfoappletalk_infokqueue_fdinfokqueue_dyninfokqueue_infopipe_fdinfopipe_infopshm_fdinfopshm_infopsem_fdinfopsem_infosocket_fdinfosocket_infoSOCKINFO_GENERICSOCKINFO_INSOCKINFO_TCPSOCKINFO_UNSOCKINFO_NDRVSOCKINFO_KERN_EVENTSOCKINFO_KERN_CTLSOCKINFO_VSOCKsockbuf_infovsock_sockinfokern_ctl_infokern_event_infondrv_infoun_sockinfotcp_sockinfoin_sockinfoin4in6_addrproc_threadwithpathinfoproc_vnodepathinfoproc_regionpathproc_regionwithpathinfovnode_fdinfowithpathvnode_fdinfovnode_info_pathvnode_infovinfo_statproc_exitreasoninfoproc_exitreasonbasicinfoproc_fileinfoproc_workqueueinfoproc_regioninfoproc_threadinfoproc_taskallinfoproc_taskinfoproc_bsdshortinfoproc_bsdinfochannelinfopfirfu_1chi_flagschi_typechi_portchi_instanceproc_fdtypeproc_fileportproc_fdappletalkinfoatalk_statkqueueinfouint64_t[4]unsigned long long[4]_kqdi_reserved1uint8_t[4]_kqdi_reserved0kqdi_cpupercentkqdi_polkqdi_prikqdi_events_qoskqdi_request_statekqdi_async_qoskqdi_sync_waiter_qoskqdi_sync_waiterskqdi_ownerkqdi_servicerkqdi_infokq_statekq_statpipeinfopipe_statuspipe_peerhandlepipe_handlepipe_statpshminfopshm_namepshm_mappaddrpshm_statpseminfopsem_namepsem_statpsisoi_protopri_vsockpri_kern_ctlpri_kern_eventpri_ndrvpri_unpri_tcppri_insoi_kindsoi_sndsoi_rcvsoi_oobmarksoi_errorsoi_timeosoi_qlimitsoi_incqlensoi_qlensoi_statesoi_lingersoi_optionssoi_familysoi_protocolsoi_typesoi_pcbsoi_sosoi_statsbi_timeosbi_flagssbi_lowatsbi_mbmaxsbi_mbcntsbi_hiwatsbi_ccremote_portremote_cidlocal_portlocal_cidkcsi_namekcsi_unitkcsi_sendbufsizekcsi_recvbufsizekcsi_flagskcsi_reg_unitkcsi_idkesi_subclass_filterkesi_class_filterkesi_vendor_code_filterndrvsi_if_namendrvsi_if_unitndrvsi_if_familyunsi_caddrua_dummyua_sununsi_addrunsi_conn_pcbunsi_conn_sotcpsi_tptcpsi_flagstcpsi_mssint[4]TSI_T_NTIMERStcpsi_timertcpsi_statetcpsi_iniinsi_v6in6_hopsin6_ifindexin6_cksumin6_hliminsi_v4in4_tosinsi_laddrina_6ina_46insi_faddrinsi_ip_ttlinsi_vflaginsi_flowinsi_flagsinsi_gencntinsi_lportinsi_fporti46a_addr4i46a_pad32pvipptpvi_rdirpvi_cdirprpo_pathprpo_regionlengthprpo_addrprp_vipprp_prinfopvivip_pathvip_vivi_fsidvi_padvi_typevi_statint64_t[2]vst_qsparevst_rdevvst_genvst_flagsvst_blksizevst_blocksvst_sizevst_birthtimensecvst_birthtimevst_ctimensecvst_ctimevst_mtimensecvst_mtimevst_atimensecvst_atimevst_gidvst_uidvst_inovst_nlinkvst_modevst_deveri_kcd_buferi_reason_buf_sizeeri_flagseri_codeeri_namespaceberi_reason_buf_sizeberi_flagsberi_codeberi_namespacefi_guardflagsfi_typefi_offsetfi_statusfi_openflagspwq_statepwq_blockedthreadspwq_runthreadspwq_nthreadspri_sizepri_addresspri_depthpri_obj_idpri_shared_pages_residentpri_private_pages_residentpri_share_modepri_shadow_depthpri_ref_countpri_pages_dirtiedpri_pages_swapped_outpri_pages_shared_now_privatepri_pages_residentpri_user_tagpri_user_wired_countpri_behaviorpri_offsetpri_flagspri_inheritancepri_max_protectionpri_protectionMAXTHREADNAMESIZEpth_namepth_maxprioritypth_prioritypth_curpripth_sleep_timepth_flagspth_run_statepth_policypth_cpu_usagepth_system_timepth_user_timeptinfopbsdpti_prioritypti_numrunningpti_threadnumpti_cswpti_syscalls_unixpti_syscalls_machpti_messages_receivedpti_messages_sentpti_cow_faultspti_pageinspti_faultspti_policypti_threads_systempti_threads_userpti_total_systempti_total_userpti_resident_sizepti_virtual_sizepbsi_rfupbsi_svgidpbsi_svuidpbsi_rgidpbsi_ruidpbsi_gidpbsi_uidpbsi_flagspbsi_commpbsi_statuspbsi_pgidpbsi_ppidpbsi_pidpbi_start_tvusecpbi_start_tvsecpbi_nicee_tpgide_tdevpbi_pjobcpbi_pgidpbi_nfiles2 * MAXCOMLENpbi_namepbi_commpbi_svgidpbi_svuidpbi_rgidpbi_ruidpbi_gidpbi_uidpbi_ppidpbi_pidpbi_xstatuspbi_statuspbi_flagsPROC_UDATA_INFO_SETPROC_UDATA_INFO_GETPROC_DIRTY_LAUNCH_IS_IN_PROGRESSPROC_DIRTY_IS_DIRTYPROC_DIRTY_ALLOWS_IDLE_EXITPROC_DIRTY_TRACKEDPROC_DIRTY_DEFER_ALWAYSPROC_DIRTY_LAUNCH_IN_PROGRESSPROC_DIRTY_DEFERPROC_DIRTY_ALLOW_IDLE_EXITPROC_DIRTY_TRACKPROC_DIRTYCONTROL_CLEARPROC_DIRTYCONTROL_GETPROC_DIRTYCONTROL_SETPROC_DIRTYCONTROL_TRACKPROC_SELFSET_DELAYIDLESLEEPPROC_SELFSET_VMRSRCOWNERPROC_SELFSET_THREADNAME_SIZE(MAXTHREADNAMESIZE -1)PROC_SELFSET_THREADNAMEPROC_SELFSET_PCONTROLPROC_PIDFILEPORTPIPEINFO_SIZEPROC_PIDFDPIPEINFO_SIZEPROC_PIDFILEPORTPIPEINFOPROC_PIDFILEPORTPSHMINFO_SIZEPROC_PIDFDPSHMINFO_SIZEPROC_PIDFILEPORTPSHMINFOPROC_PIDFILEPORTSOCKETINFO_SIZEPROC_PIDFDSOCKETINFO_SIZEPROC_PIDFILEPORTSOCKETINFOPROC_PIDFILEPORTVNODEPATHINFO_SIZEPROC_PIDFDVNODEPATHINFO_SIZEPROC_PIDFILEPORTVNODEPATHINFOPROC_PIDFDCHANNELINFO_SIZE(sizeof(struct channel_fdinfo))PROC_PIDFDCHANNELINFOPROC_PIDFDATALKINFO_SIZE(sizeof(struct appletalk_fdinfo))PROC_PIDFDATALKINFOPROC_PIDFDKQUEUEINFO_SIZE(sizeof(struct kqueue_fdinfo))PROC_PIDFDKQUEUEINFO(sizeof(struct pipe_fdinfo))PROC_PIDFDPIPEINFO(sizeof(struct pshm_fdinfo))PROC_PIDFDPSHMINFOPROC_PIDFDPSEMINFO_SIZE(sizeof(struct psem_fdinfo))PROC_PIDFDPSEMINFO(sizeof(struct socket_fdinfo))PROC_PIDFDSOCKETINFO(sizeof(struct vnode_fdinfowithpath))PROC_PIDFDVNODEPATHINFOPROC_PIDFDVNODEINFO_SIZE(sizeof(struct vnode_fdinfo))PROC_PIDFDVNODEINFOPROC_PID_RUSAGE_SIZEPROC_PID_RUSAGEPROC_PIDTHREADID64INFO_SIZE(sizeof(struct proc_threadinfo))PROC_PIDTHREADID64INFOPROC_PIDLISTFILEPORTS_SIZE(sizeof(struct proc_fileportinfo))PROC_PIDLISTFILEPORTSPROC_PIDT_SHORTBSDINFO_SIZE(sizeof(struct proc_bsdshortinfo))PROC_PIDT_SHORTBSDINFOPROC_PIDWORKQUEUEINFO_SIZE(sizeof(struct proc_workqueueinfo))PROC_PIDWORKQUEUEINFOPROC_PIDPATHINFO_MAXSIZE(4*MAXPATHLEN)PROC_PIDPATHINFO_SIZE(MAXPATHLEN)PROC_PIDPATHINFOPROC_PIDTHREADPATHINFO_SIZE(sizeof(struct proc_threadwithpathinfo))PROC_PIDTHREADPATHINFOPROC_PIDVNODEPATHINFO_SIZE(sizeof(struct proc_vnodepathinfo))PROC_PIDVNODEPATHINFOPROC_PIDREGIONPATHINFO_SIZE(sizeof(struct proc_regionwithpathinfo))PROC_PIDREGIONPATHINFOPROC_PIDREGIONINFO_SIZE(sizeof(struct proc_regioninfo))PROC_PIDREGIONINFOPROC_PIDLISTTHREADS_SIZE(2* sizeof(uint32_t))PROC_PIDLISTTHREADSPROC_PIDTHREADINFO_SIZEPROC_PIDTHREADINFOPROC_PIDTASKINFO_SIZE(sizeof(struct proc_taskinfo))PROC_PIDTASKINFOPROC_PIDTBSDINFO_SIZE(sizeof(struct proc_bsdinfo))PROC_PIDTBSDINFOPROC_PIDTASKALLINFO_SIZE(sizeof(struct proc_taskallinfo))PROC_PIDTASKALLINFOPROC_PIDLISTFD_SIZE(sizeof(struct proc_fdinfo))PROC_PIDLISTFDSPROC_CHANNEL_FLAGS_MONITOR(PROC_CHANNEL_FLAGS_MONITOR_TX | PROC_CHANNEL_FLAGS_MONITOR_RX)PROC_CHANNEL_FLAGS_LOW_LATENCYPROC_CHANNEL_FLAGS_DEFUNCT_OKPROC_CHANNEL_FLAGS_USER_PACKET_POOLPROC_CHANNEL_FLAGS_EXCLUSIVEPROC_CHANNEL_FLAGS_MONITOR_NO_COPYPROC_CHANNEL_FLAGS_MONITOR_RXPROC_CHANNEL_FLAGS_MONITOR_TXPROC_CHANNEL_TYPE_FLOW_SWITCHPROC_CHANNEL_TYPE_NET_IFPROC_CHANNEL_TYPE_KERNEL_PIPEPROC_CHANNEL_TYPE_USER_PIPEPROX_FDTYPE_NEXUSPROX_FDTYPE_CHANNELPROX_FDTYPE_NETPOLICYPROX_FDTYPE_FSEVENTSPROX_FDTYPE_PIPEPROX_FDTYPE_KQUEUEPROX_FDTYPE_PSEMPROX_FDTYPE_PSHMPROX_FDTYPE_SOCKETPROX_FDTYPE_VNODEPROX_FDTYPE_ATALKPROC_KQUEUE_QOSPROC_KQUEUE_64PROC_KQUEUE_32PROC_KQUEUE_SLEEPPROC_KQUEUE_SELECTSOI_S_DRAININGSOI_S_ISDISCONNECTEDSOI_S_COMPSOI_S_INCOMPSOI_S_ASYNCSOI_S_NBIOSOI_S_PRIVSOI_S_RCVATMARKSOI_S_CANTRCVMORESOI_S_CANTSENDMORESOI_S_ISDISCONNECTINGSOI_S_ISCONNECTINGSOI_S_ISCONNECTEDSOI_S_NOFDREFTSI_S_RESERVEDTSI_S_TIME_WAITTSI_S_FIN_WAIT_2TSI_S_LAST_ACKTSI_S_CLOSINGTSI_S_FIN_WAIT_1TSI_S__CLOSE_WAITTSI_S_ESTABLISHEDTSI_S_SYN_RECEIVEDTSI_S_SYN_SENTTSI_S_LISTENTSI_S_CLOSEDTSI_T_2MSLTSI_T_KEEPTSI_T_PERSISTTSI_T_REXMTINI_IPV6INI_IPV4PROC_FI_GUARD_FILEPORT(1u << 3)PROC_FI_GUARD_SOCKET_IPC(1u << 2)PROC_FI_GUARD_DUP(1u << 1)PROC_FI_GUARD_CLOSE(1u << 0)PROC_FP_CLFORKPROC_FP_GUARDEDPROC_FP_CLEXECPROC_FP_SHAREDWQ_FLAGS_AVAILABLEWQ_EXCEEDED_TOTAL_THREAD_LIMITWQ_EXCEEDED_CONSTRAINED_THREAD_LIMITTH_FLAGS_IDLETH_FLAGS_SWAPPEDTH_STATE_HALTEDTH_STATE_UNINTERRUPTIBLETH_STATE_WAITINGTH_STATE_STOPPEDTH_STATE_RUNNINGSM_LARGE_PAGESM_SHARED_ALIASEDSM_PRIVATE_ALIASEDSM_TRUESHAREDSM_SHAREDSM_EMPTYSM_PRIVATESM_COWPROC_REGION_SHAREDPROC_REGION_SUBMAPPROC_FLAG_EXECPROC_FLAG_PSUGIDPROC_FLAG_PA_SUSPPROC_FLAG_PA_THROTTLEPROC_FLAG_PC_MASK0x600PROC_FLAG_PC_KILLPROC_FLAG_PC_SUSPPROC_FLAG_PC_THROTTLEPROC_FLAG_THCWDPROC_FLAG_CONTROLTPROC_FLAG_CTTYPROC_FLAG_SLEADERPROC_FLAG_LP64PROC_FLAG_PPWAITPROC_FLAG_INEXITPROC_FLAG_TRACEDPROC_FLAG_SYSTEMPROC_KDBG_ONLYPROC_PPID_ONLYPROC_RUID_ONLYPROC_UID_ONLYPROC_TTY_ONLYPROC_PGRP_ONLYPROC_ALL_PIDS_SYS_PROC_INFO_H/*_SYS_PROC_INFO_H *//* Flavors for proc_udata_info *//* proc_get_dirty() flags *//* proc_track_dirty() flags *//* used for proc_dirtycontrol *//* used for proc_setcontrol *//* out: pipe_fdinfo *//* out: pshm_fdinfo *//* out: socket_fdinfo *//* out: vnode_fdinfowithpath *//* Flavors for proc_pidfileportinfo *//* Flavors for proc_pidfdinfo *//* Flavors for proc_pidinfo() *//* reserved *//* type *//*
 * Channel
 *//* defns of process file desc type *//* keep in sync with KQ_* in sys/eventvar.h *//* SOCKINFO_VSOCK *//* SOCKINFO_KERN_CTL *//* SOCKINFO_KERN_EVENT *//* SOCKINFO_NDRV *//* SOCKINFO_UN *//* SOCKINFO_TCP *//* SOCKINFO_IN *//* opaque handle of protocol control block *//* opaque handle of socket *//* SO_RCVBUF, SO_SNDBUF *//* close waiting for blocked system calls to drain *//* socket disconnected from peer *//* unaccepted, complete connection *//* Unaccepted, incomplete connection *//* async i/o notify *//* non-blocking ops *//* privileged for broadcast, raw... *//* at mark on input *//* can't receive more data from peer *//* can't send more data to peer *//* in process of disconnecting *//* in process of connecting to peer *//* socket connected to a peer *//* no file table ref any more *//* soi_state *//*
 * VSock Sockets
 *//* unique nke identifier, provided by DTS *//* request more than the default buffer size *//* support flags *//*
 * Kernel Control Sockets
 *//*
 * Kernel Event Sockets
 *//*
 * PF_NDRV Sockets
 *//* address of socket connected to *//* bound address *//* opaque handle of connected protocol control block *//* opaque handle of connected socket *//*
 * Unix Domain Sockets
 *//* opaque handle of TCP protocol control block *//* pseudo state: reserved *//* in 2*msl quiet wait after close *//* have closed, fin is acked *//* had fin and close; await FIN ACK *//* closed xchd FIN; await FIN ACK *//* have closed, sent fin *//* rcvd fin, waiting for close *//* established *//* have send and received syn *//* active, have sent syn *//* listening for connection *//* closed *//* 2*msl quiet time timer *//* keep alive *//* retransmit persistence *//* retransmit *//*
 * TCP Sockets
 *//* type of service *//* local host table entry *//* foreign host table entry *//* protocol dependent part *//* time to live proto *//* ini_IPV4 or ini_IPV6 *//* generic IP/datagram flags *//* generation count of this instance *//* local port *//* foreign port *//*
 * IPv4 and IPv6 Sockets
 *//*
 *  Socket
 *//* tail end of it  *//*
 * A copy of stat64 with static sized fields.
 *//* close on fork *//* guarded fd *//* close on exec *//* shared by more than one fd *//* stats flags in proc_fileinfo *//*
 *	workqueue state (pwq_state field)
 *//* total number of blocked workqueue threads *//* total number of running workqueue threads *//* total number of workqueue threads *//* thread is an idle thread *//* thread is swapped out *//*
 *	Thread flags (flags field).
 *//* thread is halted at a
	                                 *  clean point *//* thread is in an uninterruptible
	                                 *  wait *//* thread is waiting normally *//* thread is stopped *//* thread is running normally *//*
 *	Thread run states (state field).
 *//* shared, external pager, is submap *//* thread name, if any *//* max priority*//*  priority*//* cur priority*//* number of seconds that thread *//* various flags (see below) *//* run state (see below) *//* scheduling policy in effect *//* scaled cpu usage percentage *//* system run time *//* user run time *//* task priority*//* number of running threads *//* number of threads in the task *//* number of context switches *//* number of unix system calls *//* number of mach system calls *//* number of messages received *//* number of messages sent *//* number of copy-on-write faults *//* number of actual pageins *//* number of page faults *//* default policy for new threads *//* existing threads only *//* total time *//* resident memory size (bytes) *//* virtual memory size (bytes) *//* process has called exec  *//* process has set privileges since last exec *//* The process is currently suspended due to resource starvation *//* The process is currently throttled due to resource starvation *//* process action bits for resource starvation *//* In resource starvation situations, this process is to be terminated *//* In resource starvation situations, this process is to be suspended *//* In resource starvation situations, this process is to be throttled *//* process control bits for resource starvation *//* process has a thread with cwd *//* Has a controlling terminal *//* process has a control tty *//* The process is the session leader *//* 64bit process *//* process is working its way in exit() *//* process currently being traced, possibly by gdb *//*  System process *//* pbi_flags values *//* reserved for future use*//* current svgid on process *//* current svuid on process *//* current tgid on process *//* current ruid on process *//* current gid on process *//* current uid on process *//* 64bit; emulated etc *//* upto 16 characters of process name *//* p_stat value, SZOMB, SRUN, etc *//* process perp id *//* process parent id *//* process id *//* tty process group id *//* controlling tty dev *//* empty if no name is registered *//*
 * Copyright (c) 2005-2021 Apple Inc. All rights reserved.
 *
 * @APPLE_OSREFERENCE_LICENSE_HEADER_START@
 *
 * This file contains Original Code and/or Modifications of Original Code
 * as defined in and that are subject to the Apple Public Source License
 * Version 2.0 (the 'License'). You may not use this file except in
 * compliance with the License. The rights granted to you under the License
 * may not be used to create, or enable the creation or redistribution of,
 * unlawful or unlicensed copies of an Apple operating system, or to
 * circumvent, violate, or enable the circumvention or violation of, any
 * terms of an Apple operating system software license agreement.
 *
 * Please obtain a copy of the License at
 * http://www.opensource.apple.com/apsl/ and read it before using this file.
 *
 * The Original Code and all software distributed under the License are
 * distributed on an 'AS IS' basis, WITHOUT WARRANTY OF ANY KIND, EITHER
 * EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES,
 * INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE, QUIET ENJOYMENT OR NON-INFRINGEMENT.
 * Please see the License for the specific language governing rights and
 * limitations under the License.
 *
 * @APPLE_OSREFERENCE_LICENSE_HEADER_END@
 *//Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX.sdk/usr/include/libproc.h<sys/proc_info.h><mach/message.h><sys/resource.h>proc_udata_infoproc_setthread_csmproc_set_csmproc_setthread_no_smtproc_set_no_smtproc_terminateproc_clear_dirtyproc_get_dirtyproc_set_dirtyproc_track_dirtyproc_setpcontrolproc_pid_rusagerusage_info_t *proc_libversionproc_pidpath_audittokenaudit_token_t *proc_pidpathproc_kmsgbufproc_regionfilenameproc_nameproc_pidfileportinfoproc_pidfdinfoproc_pidinfoproc_listchildpidsproc_listpgrppidsproc_listallpidsproc_listpidsproc_listpidspathPROC_CSM_TECSPROC_CSM_NOSMTPROC_CSM_ALLPROC_SETPC_TERMINATEPROC_SETPC_SUSPENDPROC_SETPC_THROTTLEMEMPROC_SETPC_NONEPROC_LISTPIDSPATH_EXCLUDE_EVTONLYPROC_LISTPIDSPATH_PATH_IS_VOLUME_LIBPROC_H___has_include(<libproc_private.h>)macos(11.0), ios(14.0), watchos(7.0), tvos(14.0)/*_LIBPROC_H_ *//* Execute VERW on every return to user mode *//* Set NO_SMT - see above *//* Set all available mitigations *//*
 * flags for CPU Security Mitigation APIs
 * PROC_CSM_ALL should be used in most cases,
 * the individual flags are provided only for performance evaluation etc
 *//* Set CPU security mitigation on the current thread *//*
 * CPU Security Mitigation APIs
 *
 * Set CPU security mitigation on the current proc (all existing and future threads)
 * This attribute is inherited on fork and exec
 *//* Set NO_SMT on the current thread *//*
 * NO_SMT means that on an SMT CPU, this thread must be scheduled alone,
 * with the paired CPU idle.
 *
 * Set NO_SMT on the current proc (all existing and future threads)
 * This attribute is inherited on fork and exec
 *//*
 * A process can use the following api to set its own process control
 * state on resoure starvation. The argument can have one of the PROC_SETPC_XX values
 *//*
 * Return resource usage information for the given pid, which can be a live process or a zombie.
 *
 * Returns 0 on success; or -1 on failure, with errno set to indicate the specific error.
 *//*!
 *       @function proc_listpidspath
 *       @discussion A function which will search through the current
 *               processes looking for open file references which match
 *               a specified path or volume.
 *       @param type types of processes to be searched (see proc_listpids)
 *       @param typeinfo adjunct information for type
 *       @param path file or volume path
 *       @param pathflags flags to control which files should be considered
 *               during the process search.
 *       @param buffer a C array of int-sized values to be filled with
 *               process identifiers that hold an open file reference
 *               matching the specified path or volume.  Pass NULL to
 *               obtain the minimum buffer size needed to hold the
 *               currently active processes.
 *       @param buffersize the size (in bytes) of the provided buffer.
 *       @result the number of bytes of data returned in the provided buffer;
 *               -1 if an error was encountered;
 *//*!
 *       @define PROC_LISTPIDSPATH_EXCLUDE_EVTONLY
 *       @discussion This flag indicates that file references that were opened
 *               with the O_EVTONLY flag should be excluded from the matching
 *               criteria.
 *//*!
 *       @define PROC_LISTPIDSPATH_PATH_IS_VOLUME
 *       @discussion This flag indicates that all processes that hold open
 *               file references on the volume associated with the specified
 *               path should be returned.
 *//*
 * This header file contains private interfaces to obtain process information.
 * These interfaces are subject to change in future releases.
 *//* for audit_token_t *//*
 * Copyright (c) 2006, 2007, 2010 Apple Inc. All rights reserved.
 *
 * @APPLE_LICENSE_HEADER_START@
 *
 * This file contains Original Code and/or Modifications of Original Code
 * as defined in and that are subject to the Apple Public Source License
 * Version 2.0 (the 'License'). You may not use this file except in
 * compliance with the License. Please obtain a copy of the License at
 * http://www.opensource.apple.com/apsl/ and read it before using this
 * file.
 *
 * The Original Code and all software distributed under the License are
 * distributed on an 'AS IS' basis, WITHOUT WARRANTY OF ANY KIND, EITHER
 * EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES,
 * INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE, QUIET ENJOYMENT OR NON-INFRINGEMENT.
 * Please see the License for the specific language governing rights and
 * limitations under the License.
 *
 * @APPLE_LICENSE_HEADER_END@
 */flavorbuffersizesigdirtycontrolaudittokenfileportppidpgrpidtypeinfopathflags/Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX.sdk/usr/include/uuid/uuid.h/Users/owura/Repos/codeql_eval/proj_repos/Exiv2-exiv2-pull-962-commits-e925bc5addd881543fa503470c8a859e112cca62/exiv2/src/futils.cpp<libproc.h>iterator_t~<unnamed>struct <unnamed> *(unnamed constructor)char[4096]pathbufsizeof(pathbuf)idxLastSeparator (errno = " (errno = "foundbuf.st_modestruct <unnamed>[]protsstruct <unnamed>[8]http://"http://"https://"https://"ftp://"ftp://"sftp://"sftp://"ssh://"ssh://"file://"file://"data://"data://"sizeof(prots)sizeof(prots[0])sizeof(prots)/sizeof(prots[0])|$$$}rstuvwxyz{$$$$$$$>?@ABCDEFGHIJKLMNOPQRSTUVW$$$$$$XYZ[\]^_`abcdefghijklmnopq"|$$$}rstuvwxyz{$$$$$$$>?@ABCDEFGHIJKLMNOPQRSTUVW"
                         "$$$$$$XYZ[\\]^_`abcdefghijklmnopq"const char[81]char[81]quad'$'0xc0base64charsABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/"const uint8_tconst uint8_t *resultIndexpadCountn0n1n2n3'='decodeStrpstrpbuf'~'from_hexto_hex0123456789abcdef"0123456789abcdef"Unexpected env variable"Unexpected env variable"uriEndqueryStartprotocolStartprotocolEndauthStartauthEnd'@'userStartuserEndhostStartpathStarthostEndportEnd"http"isUrlEXIV2_HTTP_POST"EXIV2_HTTP_POST"EXIV2_TIMEOUT"EXIV2_TIMEOUT"ENVARKEY/exiv2.php"/exiv2.php""40"ENVARDEFdefined(WIN32)EXV_STRERROR_R_CHAR_Pdefined(__unix__)// http://stackoverflow.com/questions/606041/how-do-i-get-the-path-of-a-process-in-unix-linux// release resources// path// we have a port// port// check for port// get pathStart// host//username & password// no protocol//      :////"://");// protocol// get query start// strError// report strerror() if strerror_r() returns empty// Issue# 908.// fileExists// special case: accept "-" (means stdin)// fileProtocol// URL's require data.  Stdin == "-" and no further data// path.size() > name.size()// base64decode/* out buffer is too small */// base64encode/* indicate success *//* indicate failure: buffer too small *//*
        * create and add padding that is required if we did not have a multiple of 3
        * number of characters available
        *//*
            * if we have all three bytes available, then their encoding is spread
            * out over four characters
            *//*
            * if we have only two bytes available, then their encoding is
            * spread out over three chars
            *//*
            * if we have one byte available, then its encoding is spread
            * out over two characters
            *//* this 24-bit number gets separated into four 6-bit numbers *//* these three 8-bit (ASCII) characters become one 24-bit number *//* increment over the length of the string, three characters at a time */// returning the final value// \todo try to use std::string for buf and avoid the creation of another string for just/// @brief Convert a hex character to its integer value./// @brief Convert an integer value to its hex character.// this check is relying on undefined behavior and might not be effective//!< @brief request keys for http exiv2 handler and time-out//!< @brief default URL for http exiv2 handler and time-out// For access to GetModuleFileNameEx__iterator_traits_impl<__wrap_iter<const char *>, true>__iterator_traits_impl<__wrap_iter<const char *>, true> &const __iterator_traits_impl<__wrap_iter<const char *>, true>const __iterator_traits_impl<__wrap_iter<const char *>, true> &/Users/owura/Repos/codeql_eval/proj_repos/Exiv2-exiv2-pull-962-commits-e925bc5addd881543fa503470c8a859e112cca62/exiv2/src/getopt.cpp<stdarg.h><assert.h>--"--"%s: illegal option: %c
"%s: illegal option: %c\n"%s: option requires an argument: %c
"%s: option requires an argument: %c\n"errcnt_(0)/*argv*/// reset the Util::Getopt scanner// class Getopt/* Reset? *//* A minimal POSIX getopt() implementation in ANSI C
	 *
	 * This is free and unencumbered software released into the public domain.
	 *
	 * This implementation supports the convention of resetting the option
	 * parser by assigning optind to 0. This resets the internal state
	 * appropriately.
	 *
	 * Ref: http://pubs.opengroup.org/onlinepubs/9699919799/functions/getopt.html
	 */// https://raw.githubusercontent.com/skeeto/getopt/master/getopt.hGifImage *const GifImage */Users/owura/Repos/codeql_eval/proj_repos/Exiv2-exiv2-pull-962-commits-e925bc5addd881543fa503470c8a859e112cca62/exiv2/src/gifimage.cpp"gifimage.hpp" 6const unsigned char[8]Gif87aId'G''8''7'Gif89aIdbyte[6]unsigned char[6]-6image/gif"image/gif"GIF"GIF"ImageType::gif// GifImage::writeMetadata// GifImage::readMetadata// GifImage::GifImage/*
  File:      gifimage.cpp
  Author(s): Marco Piovanelli, Ovolab (marco)
  History:   26-Feb-2007, marco: created
 */<_wctype.h><sys/_types/_rune_t.h><sys/_types/_ct_rune_t.h>wcslcpywcslcatfgetwlnopen_wmemstreamwcsnrtombswcsnlenwcsncasecmpwcscasecmpwcsdupwcpncpywcpcpymbsnrtowcswcwidthwcswidthwprintfvwprintfputwcharwscanfvwscanfgetwcharwcsrtombsmbsrtowcswcrtombmbrtowcmbrlenmbsinitwctobbtowcwcsftimewmemsetwmemmovewmemcpywmemcmpwcstokwcsspnwcslenwcscspnwcsxfrmwcsncmpwcscollwcscmpwcsncatwcscatwcsncpywcscpywcstoullwcstoulwcstollwcstolwcstoldwcstofwcstodungetwcputwcgetwcfwidefputwsfputwcfgetwsfgetwcvswscanfvfwscanfswscanfvswprintfvfwprintfswprintffwscanffwprintf__DARWIN_C_LEVEL >= 200112L || defined(_C99_SOURCE) || defined(__cplusplus)macos(10.13), ios(11.0), tvos(11.0), watchos(4.0)macos(10.13)/* !_WCHAR_H_ *//*-
 * Copyright (c) 1999, 2000 The NetBSD Foundation, Inc.
 * All rights reserved.
 *
 * This code is derived from software contributed to The NetBSD Foundation
 * by Julian Coleman.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *        This product includes software developed by the NetBSD
 *        Foundation, Inc. and its contributors.
 * 4. Neither the name of The NetBSD Foundation nor the names of its
 *    contributors may be used to endorse or promote products derived
 *    from this software without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE NETBSD FOUNDATION, INC. AND CONTRIBUTORS
 * ``AS IS'' AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED
 * TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
 * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL THE FOUNDATION OR CONTRIBUTORS
 * BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
 * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
 * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
 * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
 * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
 * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
 * POSSIBILITY OF SUCH DAMAGE.
 *
 *	$NetBSD: wchar.h,v 1.8 2000/12/22 05:31:42 itojun Exp $
 *//*-
 * Copyright (c)1999 Citrus Project,
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE AUTHOR AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 *
 * $FreeBSD: /repoman/r/ncvs/src/include/wchar.h,v 1.34 2003/03/13 06:29:53 tjr Exp $
 */__bufp__sizep/Users/owura/Repos/codeql_eval/proj_repos/Exiv2-exiv2-pull-962-commits-e925bc5addd881543fa503470c8a859e112cca62/exiv2/src/helper_functions.hppHELPER_FUNCTIONS_HPPstring_from_unterminated// HELPER_FUNCTIONS_HPP/*!
  @brief Convert a (potentially not null terminated) array into a
  std::string.

  Convert a C style string that may or may not be null terminated safely
  into a std::string. The string's termination is either set at the first \0
  or after data_length characters.

  @param[in] data  A c-string from which the std::string shall be
      constructed. Does not need to be null terminated.
  @param[in] data_length  An upper bound for the string length (must be at most
      the allocated length of `buffer`). If no null terminator is found in data,
      then the resulting std::string will be null terminated at `data_length`.

 *//*!
  @file    helper_functions.hpp
  @brief   A collection of helper functions
  @author  Dan ermk (D4N)
           <a href="mailto:dan.cermak@cgc-instruments.com">dan.cermak@cgc-instruments.com</a>
  @date    25-May-18, D4N: created
 */data_length/Users/owura/Repos/codeql_eval/proj_repos/Exiv2-exiv2-pull-962-commits-e925bc5addd881543fa503470c8a859e112cca62/exiv2/src/helper_functions.cpp"helper_functions.hpp"StringLength/*!
  @file    helper_functions.cpp
  @brief   A collection of helper functions
  @author  Dan ermk (D4N)
           <a href="mailto:dan.cermak@cgc-instruments.com">dan.cermak@cgc-instruments.com</a>
  @date    25-May-18, D4N: created
 */__xx__tree_end_node<_Pointer> *__prior/Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX.sdk/usr/include/sys/uio.hpwritevpreadvwritevreadvuio_rwUIO_READUIO_WRITE_SYS_UIO_H_/* !_SYS_UIO_H_ *//*
 * IO direction for uio_t.
 *	UIO_READ - data moves into iovec(s) associated with uio_t
 *	UIO_WRITE - data moves out of iovec(s) associated with uio_t
 *//*
 * [XSI] Structure whose address is passed as the second parameter to the
 * readv(), preadv(), writev() and pwritev() functions.
 *//*
 * [XSI] The ssize_t and size_t types shall be defined as described
 * in <sys/types.h>.
 *//*
 * Copyright (c) 1982, 1986, 1993, 1994
 *	The Regents of the University of California.  All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *	This product includes software developed by the University of
 *	California, Berkeley and its contributors.
 * 4. Neither the name of the University nor the names of its contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 *
 *	@(#)uio.h	8.5 (Berkeley) 2/22/94
 *//Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX.sdk/usr/include/arpa/inet.hinet_nsap_ntoainet_nsap_addrinet_netainet_net_ptoninet_net_ntopinet_networkinet_netofinet_makeaddrinet_lnaofinet_atonaddr2asciiascii2addrinet_ptoninet_ntopinet_ntoainet_addr_ARPA_INET_H_/* !_ARPA_INET_H_ *//* in_addr *//* htonl() and family if (_POSIX_C_SOURCE && !_DARWIN_C_SOURCE) *//* htonl() and family if (!_POSIX_C_SOURCE || _DARWIN_C_SOURCE) *//* uint32_t uint16_t *//* External definitions for functions in inet(3), addr2ascii(3) *//*
 *	@(#)inet.h	8.1 (Berkeley) 6/2/93
 *	$Id: inet.h,v 1.10 2006/02/01 18:09:47 majka Exp $
 *//*
 * ++Copyright++ 1983, 1993
 * -
 * Copyright (c) 1983, 1993
 *    The Regents of the University of California.  All rights reserved.
 * 
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 * 	This product includes software developed by the University of
 * 	California, Berkeley and its contributors.
 * 4. Neither the name of the University nor the names of its contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
 * 
 * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 * -
 * Portions Copyright (c) 1993 by Digital Equipment Corporation.
 * 
 * Permission to use, copy, modify, and distribute this software for any
 * purpose with or without fee is hereby granted, provided that the above
 * copyright notice and this permission notice appear in all copies, and that
 * the name of Digital Equipment Corporation not be used in advertising or
 * publicity pertaining to distribution of the document or software without
 * specific, written prior permission.
 * 
 * THE SOFTWARE IS PROVIDED "AS IS" AND DIGITAL EQUIPMENT CORP. DISCLAIMS ALL
 * WARRANTIES WITH REGARD TO THIS SOFTWARE, INCLUDING ALL IMPLIED WARRANTIES
 * OF MERCHANTABILITY AND FITNESS.   IN NO EVENT SHALL DIGITAL EQUIPMENT
 * CORPORATION BE LIABLE FOR ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL
 * DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR
 * PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS
 * ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS
 * SOFTWARE.
 * -
 * --Copyright--
 *//Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX.sdk/usr/include/arpa/Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX.sdk/usr/include/netdb.hsetnetgrentendnetgrentgetnetgrentinnetgrhstrerrorherrorendrpcentsetrpcentrpcent *getrpcentgetrpcbynumbergetrpcbynamehostent *getipnodebynamegetipnodebyaddrgethostbyname2freehostentsetserventsetprotoentsetnetentsethostentservent *getserventgetservbyportgetservbynameprotoent *getprotoentgetprotobynumbergetprotobynamenetent *getnetentgetnetbynamegetnetbyaddrgetnameinfogethostentgethostbynamegethostbyaddrgetaddrinfoconst addrinfoconst addrinfo *addrinfo *addrinfo **gai_strerrorfreeaddrinfoendserventendprotoentendnetentendhostentrpcent &const rpcentconst rpcent &addrinfo &const addrinfo &protoent &const protoentconst protoent &servent &const serventconst servent &netent &const netentconst netent &hostent &const hostentconst hostent &rpcentaddrinfoprotoentserventnetenthostentr_numberr_aliasesr_nameai_nextai_addrai_canonnameai_addrlenai_protocolai_socktypeai_familyp_protop_aliasesp_names_protos_ports_aliasess_namen_netn_addrtypen_aliasesn_nameh_addr_listh_lengthh_addrtypeh_aliasesh_nameh_errnoSCOPE_DELIMITERNI_WITHSCOPEIDNI_DGRAMNI_NUMERICSCOPENI_NUMERICSERVNI_NAMEREQDNI_NUMERICHOSTNI_NOFQDNNI_MAXSERVNI_MAXHOST1025AI_UNUSABLEAI_DEFAULT(AI_V4MAPPED_CFG | AI_ADDRCONFIG)AI_V4MAPPEDAI_ADDRCONFIGAI_V4MAPPED_CFGAI_ALLAI_MASK(AI_PASSIVE | AI_CANONNAME | AI_NUMERICHOST | AI_NUMERICSERV | AI_ADDRCONFIG)AI_NUMERICSERVAI_NUMERICHOSTAI_CANONNAMEAI_PASSIVEEAI_MAXEAI_OVERFLOWEAI_PROTOCOLEAI_BADHINTSEAI_SYSTEMEAI_SOCKTYPEEAI_SERVICEEAI_NONAMEEAI_NODATAEAI_MEMORYEAI_FAMILYEAI_FAILEAI_BADFLAGSEAI_AGAINEAI_ADDRFAMILYNO_ADDRESSNO_DATANO_RECOVERYTRY_AGAINHOST_NOT_FOUNDNETDB_SUCCESSNETDB_INTERNALh_addrh_addr_list[0]_PATH_SERVICES"/etc/services"_PATH_PROTOCOLS"/etc/protocols"_PATH_NETWORKS"/etc/networks"_PATH_HOSTS"/etc/hosts"_PATH_HEQUIV"/etc/hosts.equiv"_NETDB_H_/* !_NETDB_H_ *//* void		sethostfile(const char *); *//*
 * Scope delimit character
 *//*
 * Flag values for getnameinfo()
 *//*
 * Constants for getnameinfo()
 *//* return addresses even if unusable (i.e. opposite of AI_DEFAULT) *//* If the hints pointer is null or ai_flags is zero, getaddrinfo() automatically defaults to the AI_DEFAULT behavior.
 * To override this default behavior, thereby causing unusable addresses to be included in the results, pass any nonzero
 * value for ai_flags, by setting any desired flag values, or by setting AI_UNUSABLE if no other flags are desired. *//* special recommended flags for getipnodebyname *//* accept IPv4-mapped IPv6 address *//* only if any address is assigned *//* accept IPv4-mapped if kernel supports *//* IPv6 and IPv4-mapped (with AI_V4MAPPED) *//* valid flags for addrinfo (not a standard def, apps should not use it) *//* prevent service name resolution *//* prevent host name resolution *//* fill ai_canonname *//* get address to use bind() *//*
 * Flag values for getaddrinfo()
 *//* argument buffer overflow *//* resolved protocol is unknown *//* invalid value for hints *//* system error returned in errno *//* ai_socktype not supported *//* servname not supported for ai_socktype *//* hostname nor servname provided, or not known *//* no address associated with hostname *//* memory allocation failure *//* ai_family not supported *//* non-recoverable failure in name resolution *//* invalid value for ai_flags *//* temporary failure in name resolution *//* address family for hostname not supported *//*
 * Error return codes from getaddrinfo()
 *//* no address, look for MX record *//* Valid name, no data record of requested type *//* Non recoverable errors, FORMERR, REFUSED, NOTIMP *//* Non-Authoritative Host not found, or SERVERFAIL *//* Authoritative Answer Host not found *//* no problem *//* see errno *//*
 * Error return codes from gethostbyname() and gethostbyaddr()
 * (left in h_errno).
 *//* rpc program number *//* alias list *//* name of server for this rpc program *//* next structure in linked list *//* binary address *//* canonical name for hostname *//* length of ai_addr *//* 0 or IPPROTO_xxx for IPv4 and IPv6 *//* SOCK_xxx *//* PF_xxx *//* AI_PASSIVE, AI_CANONNAME, AI_NUMERICHOST *//* protocol # *//* official protocol name *//* protocol to use *//* port # *//* official service name *//* network # *//* net address type *//* official name of net *//*
 * Assumption here is that a network number
 * fits in an unsigned long -- probably a poor one.
 *//* address, for backward compatibility *//* list of addresses from name server *//* length of address *//* host address type *//* official name of host *//*
 * Structures returned by network data base library.  All addresses are
 * supplied in host order, and returned in network order (suitable for
 * use in system calls).
 *//* IPPORT_RESERVED *//*
 *      @(#)netdb.h	8.1 (Berkeley) 6/2/93
 *//*
 * ++Copyright++ 1980, 1983, 1988, 1993
 * -
 * Copyright (c) 1980, 1983, 1988, 1993
 *	The Regents of the University of California.  All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *	This product includes software developed by the University of
 *	California, Berkeley and its contributors.
 * 4. Neither the name of the University nor the names of its contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 *
 * -
 * Portions Copyright (c) 1993 by Digital Equipment Corporation.
 *
 * Permission to use, copy, modify, and distribute this software for any
 * purpose with or without fee is hereby granted, provided that the above
 * copyright notice and this permission notice appear in all copies, and that
 * the name of Digital Equipment Corporation not be used in advertising or
 * publicity pertaining to distribution of the document or software without
 * specific, written prior permission.
 *
 * THE SOFTWARE IS PROVIDED "AS IS" AND DIGITAL EQUIPMENT CORP. DISCLAIMS ALL
 * WARRANTIES WITH REGARD TO THIS SOFTWARE, INCLUDING ALL IMPLIED WARRANTIES
 * OF MERCHANTABILITY AND FITNESS.   IN NO EVENT SHALL DIGITAL EQUIPMENT
 * CORPORATION BE LIABLE FOR ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL
 * DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR
 * PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS
 * ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS
 * SOFTWARE.
 * -
 * --Copyright--
 *//*
 * Copyright (c) 2000-2009 Apple Inc. All rights reserved.
 *
 * @APPLE_LICENSE_HEADER_START@
 * 
 * This file contains Original Code and/or Modifications of Original Code
 * as defined in and that are subject to the Apple Public Source License
 * Version 2.0 (the 'License'). You may not use this file except in
 * compliance with the License. Please obtain a copy of the License at
 * http://www.opensource.apple.com/apsl/ and read it before using this
 * file.
 * 
 * The Original Code and all software distributed under the License are
 * distributed on an 'AS IS' basis, WITHOUT WARRANTY OF ANY KIND, EITHER
 * EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES,
 * INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE, QUIET ENJOYMENT OR NON-INFRINGEMENT.
 * Please see the License for the specific language governing rights and
 * limitations under the License.
 * 
 * @APPLE_LICENSE_HEADER_END@
 */stayopen/Users/owura/Repos/codeql_eval/proj_repos/Exiv2-exiv2-pull-962-commits-e925bc5addd881543fa503470c8a859e112cca62/exiv2/src/http.cpp<netdb.h><arpa/inet.h><sys/uio.h>makeNonBlockingSOCKET_ERRORstringToDictconst map<basic_string<char, char_traits<char>, allocator<char>>, basic_string<char, char_traits<char>, allocator<char>>, less<basic_string<char, char_traits<char>, allocator<char>>>, allocator<pair<const basic_string<char, char_traits<char>, allocator<char>>, basic_string<char, char_traits<char>, allocator<char>>>>> &flushBufferbuffer_size%s
"%s\n"forgive999-999FINISHbForgivebErrorSleeprqtprmtpWSAGetLastError"1.0"servernameservername_pport_pPROXIHTTP_PROXY"HTTP_PROXY"proxihttp_proxy"http_proxy"PROXYproxybProxproxProxyNO_PROXINO_PROXY"NO_PROXY"no_proxino_proxy"no_proxy"bNoProxyno_proxnoProxy,localhost,127.0.0.1",localhost,127.0.0.1"sockfdunable to create socket
"unable to create socket\n"serv_addrserv_lensizeof(serv_addr)atoi(port_p)__builtin_constant_p(unsigned long)INADDR_NONEhostno such host"no such host"sizeof(serv_addr.sin_addr)error - unable to connect to server = %s port = %s wsa_error = %d"error - unable to connect to server = %s port = %s wsa_error = %d"char[32769]3276932*1024+1buff_lyerrmillisecssizeof buffer - 1requestheaders"requestheaders"error - timeout connecting to server = %s port = %s wsa_error = %d"error - timeout connecting to server = %s port = %s wsa_error = %d"bSearching 200blankLines ':' '\n'firstSpacefirst_newlinelengthof(blankLines)blankLinePoswsa_error = %d,n = %d,sleep_ = %d status = %d"wsa_error = %d,n = %d,sleep_ = %d status = %d"error - no response from server = %s port = %s wsa_error = %d"error - no response from server = %s port = %s wsa_error = %d"DWORDSLEEPsleep_SNOOZEsnooze

"\r\n\r\n"

"\n\n"%s %s HTTP/%s
User-Agent: exiv2http/1.0.0
Accept: */*
Host: %s
%s
"%s %s HTTP/%s\r\n"            // $verb $page $version
"User-Agent: exiv2http/1.0.0\r\n"
"Accept: */*\r\n"
"Host: %s\r\n"                 // $servername
"%s"                           // $header
"\r\n"httpTemplateOK(s)(200 <= s && s < 300)white(c)((c == ' ') || (c == '\t'))(sizeof(x)/sizeof((x)[0]))WSAENOTCONNWSAEWOULDBLOCKWINAPIfopen_S(f,n,o)f=fopen(n,o)closesocketdefined(WIN32) || defined(_MSC_VER) || defined(__MINGW__)WIN32// That's all Folks// close sockets//////////////////////////////////////  we finished OK without finding headers, flush the buffer// this handles the possibility that there are no headers// if the bufffer's full and we're still searching - give up!// initial byte in buffer// parse response headers// search for the body// start of body// read and process the response// assume happiness// looking for headers in the response// write position in buffer/* && WSAGetLastError() == WSAENOTCONN */// send the header (we'll have to wait for the connection by the non-blocking socket)// format the request// and connect// http://publib.boulder.ibm.com/infocenter/iseries/v5r3/index.jsp?topic=/rzab6/rzab6uafinet.htm// convert unknown servername into IP address// fill in the address// connect the socket to the server// open the socket//  std::cerr << p << '=' << prox << " page = " << page << std::endl;// if the server is on the no_proxy list ... ignore the proxy!// find the dictionary of no_proxy servers// parse and change server if using a proxy// Windows specific code// server hungup// this is commonly sent by CGI scripts// this is the standard// $header// $servername// $verb $page $version// code// Unix or Mac/*
 * http.cpp
 */const map<basic_string<char, char_traits<char>, allocator<char>>, basic_string<char, char_traits<char>, allocator<char>>, less<basic_string<char, char_traits<char>, allocator<char>>>, allocator<pair<const basic_string<char, char_traits<char>, allocator<char>>, basic_string<char, char_traits<char>, allocator<char>>>>> *const __baseconst __base &__tree<__value_type<basic_string<char, char_traits<char>, allocator<char>>, basic_string<char, char_traits<char>, allocator<char>>>, __map_value_compare<basic_string<char, char_traits<char>, allocator<char>>, __value_type<basic_string<char, char_traits<char>, allocator<char>>, basic_string<char, char_traits<char>, allocator<char>>>, less<basic_string<char, char_traits<char>, allocator<char>>>, true>, allocator<__value_type<basic_string<char, char_traits<char>, allocator<char>>, basic_string<char, char_traits<char>, allocator<char>>>>> &allocator<__tree_node<__value_type<basic_string<char, char_traits<char>, allocator<char>>, basic_string<char, char_traits<char>, allocator<char>>>, void *>> &__tree_node_destructor<allocator<__tree_node<__value_type<basic_string<char, char_traits<char>, allocator<char>>, basic_string<char, char_traits<char>, allocator<char>>>, void *>>> &__tree_node_destructor<allocator<__tree_node<__value_type<basic_string<char, char_traits<char>, allocator<char>>, basic_string<char, char_traits<char>, allocator<char>>>, void *>>>const __tree<__value_type<basic_string<char, char_traits<char>, allocator<char>>, basic_string<char, char_traits<char>, allocator<char>>>, __map_value_compare<basic_string<char, char_traits<char>, allocator<char>>, __value_type<basic_string<char, char_traits<char>, allocator<char>>, basic_string<char, char_traits<char>, allocator<char>>>, less<basic_string<char, char_traits<char>, allocator<char>>>, true>, allocator<__value_type<basic_string<char, char_traits<char>, allocator<char>>, basic_string<char, char_traits<char>, allocator<char>>>>>const __tree<__value_type<basic_string<char, char_traits<char>, allocator<char>>, basic_string<char, char_traits<char>, allocator<char>>>, __map_value_compare<basic_string<char, char_traits<char>, allocator<char>>, __value_type<basic_string<char, char_traits<char>, allocator<char>>, basic_string<char, char_traits<char>, allocator<char>>>, less<basic_string<char, char_traits<char>, allocator<char>>>, true>, allocator<__value_type<basic_string<char, char_traits<char>, allocator<char>>, basic_string<char, char_traits<char>, allocator<char>>>>> &__tree<__value_type<basic_string<char, char_traits<char>, allocator<char>>, basic_string<char, char_traits<char>, allocator<char>>>, __map_value_compare<basic_string<char, char_traits<char>, allocator<char>>, __value_type<basic_string<char, char_traits<char>, allocator<char>>, basic_string<char, char_traits<char>, allocator<char>>>, less<basic_string<char, char_traits<char>, allocator<char>>>, true>, allocator<__value_type<basic_string<char, char_traits<char>, allocator<char>>, basic_string<char, char_traits<char>, allocator<char>>>>> *__iter_pointer()__map_value_compare<basic_string<char, char_traits<char>, allocator<char>>, __value_type<basic_string<char, char_traits<char>, allocator<char>>, basic_string<char, char_traits<char>, allocator<char>>>, less<basic_string<char, char_traits<char>, allocator<char>>>, true> &const __tree<__value_type<basic_string<char, char_traits<char>, allocator<char>>, basic_string<char, char_traits<char>, allocator<char>>>, __map_value_compare<basic_string<char, char_traits<char>, allocator<char>>, __value_type<basic_string<char, char_traits<char>, allocator<char>>, basic_string<char, char_traits<char>, allocator<char>>>, less<basic_string<char, char_traits<char>, allocator<char>>>, true>, allocator<__value_type<basic_string<char, char_traits<char>, allocator<char>>, basic_string<char, char_traits<char>, allocator<char>>>>> *const __value_type<basic_string<char, char_traits<char>, allocator<char>>, basic_string<char, char_traits<char>, allocator<char>>>const __value_type<basic_string<char, char_traits<char>, allocator<char>>, basic_string<char, char_traits<char>, allocator<char>>> &__value_type<basic_string<char, char_traits<char>, allocator<char>>, basic_string<char, char_traits<char>, allocator<char>>> &unique_ptr<__tree_node<__value_type<basic_string<char, char_traits<char>, allocator<char>>, basic_string<char, char_traits<char>, allocator<char>>>, void *>, __tree_node_destructor<allocator<__tree_node<__value_type<basic_string<char, char_traits<char>, allocator<char>>, basic_string<char, char_traits<char>, allocator<char>>>, void *>>>>unique_ptr<__tree_node<__value_type<basic_string<char, char_traits<char>, allocator<char>>, basic_string<char, char_traits<char>, allocator<char>>>, void *>, __tree_node_destructor<allocator<__tree_node<__value_type<basic_string<char, char_traits<char>, allocator<char>>, basic_string<char, char_traits<char>, allocator<char>>>, void *>>>> &pair<__tree_iterator<__value_type<basic_string<char, char_traits<char>, allocator<char>>, basic_string<char, char_traits<char>, allocator<char>>>, __tree_node<__value_type<basic_string<char, char_traits<char>, allocator<char>>, basic_string<char, char_traits<char>, allocator<char>>>, void *> *, long>, bool>const pair<__tree_iterator<__value_type<basic_string<char, char_traits<char>, allocator<char>>, basic_string<char, char_traits<char>, allocator<char>>>, __tree_node<__value_type<basic_string<char, char_traits<char>, allocator<char>>, basic_string<char, char_traits<char>, allocator<char>>>, void *> *, long>, bool>const pair<__tree_iterator<__value_type<basic_string<char, char_traits<char>, allocator<char>>, basic_string<char, char_traits<char>, allocator<char>>>, __tree_node<__value_type<basic_string<char, char_traits<char>, allocator<char>>, basic_string<char, char_traits<char>, allocator<char>>>, void *> *, long>, bool> &pair<__tree_iterator<__value_type<basic_string<char, char_traits<char>, allocator<char>>, basic_string<char, char_traits<char>, allocator<char>>>, __tree_node<__value_type<basic_string<char, char_traits<char>, allocator<char>>, basic_string<char, char_traits<char>, allocator<char>>>, void *> *, long>, bool> &pair<__tree_iterator<__value_type<basic_string<char, char_traits<char>, allocator<char>>, basic_string<char, char_traits<char>, allocator<char>>>, __tree_node<__value_type<basic_string<char, char_traits<char>, allocator<char>>, basic_string<char, char_traits<char>, allocator<char>>>, void *> *, long>, bool> *const __map_const_iterator<__tree_const_iterator<__value_type<basic_string<char, char_traits<char>, allocator<char>>, basic_string<char, char_traits<char>, allocator<char>>>, __tree_node<__value_type<basic_string<char, char_traits<char>, allocator<char>>, basic_string<char, char_traits<char>, allocator<char>>>, void *> *, long>> *const __map_value_compare<basic_string<char, char_traits<char>, allocator<char>>, __value_type<basic_string<char, char_traits<char>, allocator<char>>, basic_string<char, char_traits<char>, allocator<char>>>, less<basic_string<char, char_traits<char>, allocator<char>>>, true>const __map_value_compare<basic_string<char, char_traits<char>, allocator<char>>, __value_type<basic_string<char, char_traits<char>, allocator<char>>, basic_string<char, char_traits<char>, allocator<char>>>, less<basic_string<char, char_traits<char>, allocator<char>>>, true> &const allocator<__tree_node<__value_type<basic_string<char, char_traits<char>, allocator<char>>, basic_string<char, char_traits<char>, allocator<char>>>, void *>>const allocator<__tree_node<__value_type<basic_string<char, char_traits<char>, allocator<char>>, basic_string<char, char_traits<char>, allocator<char>>>, void *>> &allocator<__tree_node<__value_type<basic_string<char, char_traits<char>, allocator<char>>, basic_string<char, char_traits<char>, allocator<char>>>, void *>> &&remove_reference<allocator<__tree_node<__value_type<basic_string<char, char_traits<char>, allocator<char>>, basic_string<char, char_traits<char>, allocator<char>>>, void *>>>remove_reference<allocator<__tree_node<__value_type<basic_string<char, char_traits<char>, allocator<char>>, basic_string<char, char_traits<char>, allocator<char>>>, void *>>> &const remove_reference<allocator<__tree_node<__value_type<basic_string<char, char_traits<char>, allocator<char>>, basic_string<char, char_traits<char>, allocator<char>>>, void *>>>const remove_reference<allocator<__tree_node<__value_type<basic_string<char, char_traits<char>, allocator<char>>, basic_string<char, char_traits<char>, allocator<char>>>, void *>>> &__compressed_pair<__tree_node<__value_type<basic_string<char, char_traits<char>, allocator<char>>, basic_string<char, char_traits<char>, allocator<char>>>, void *> *, __tree_node_destructor<allocator<__tree_node<__value_type<basic_string<char, char_traits<char>, allocator<char>>, basic_string<char, char_traits<char>, allocator<char>>>, void *>>>>__compressed_pair<__tree_node<__value_type<basic_string<char, char_traits<char>, allocator<char>>, basic_string<char, char_traits<char>, allocator<char>>>, void *> *, __tree_node_destructor<allocator<__tree_node<__value_type<basic_string<char, char_traits<char>, allocator<char>>, basic_string<char, char_traits<char>, allocator<char>>>, void *>>>> &const __compressed_pair<__tree_node<__value_type<basic_string<char, char_traits<char>, allocator<char>>, basic_string<char, char_traits<char>, allocator<char>>>, void *> *, __tree_node_destructor<allocator<__tree_node<__value_type<basic_string<char, char_traits<char>, allocator<char>>, basic_string<char, char_traits<char>, allocator<char>>>, void *>>>>const __compressed_pair<__tree_node<__value_type<basic_string<char, char_traits<char>, allocator<char>>, basic_string<char, char_traits<char>, allocator<char>>>, void *> *, __tree_node_destructor<allocator<__tree_node<__value_type<basic_string<char, char_traits<char>, allocator<char>>, basic_string<char, char_traits<char>, allocator<char>>>, void *>>>> &__pointer<__tree_node<__value_type<basic_string<char, char_traits<char>, allocator<char>>, basic_string<char, char_traits<char>, allocator<char>>>, void *>, __tree_node_destructor<allocator<__tree_node<__value_type<basic_string<char, char_traits<char>, allocator<char>>, basic_string<char, char_traits<char>, allocator<char>>>, void *>>>, __tree_node_destructor<allocator<__tree_node<__value_type<basic_string<char, char_traits<char>, allocator<char>>, basic_string<char, char_traits<char>, allocator<char>>>, void *>>>, true>__pointer<__tree_node<__value_type<basic_string<char, char_traits<char>, allocator<char>>, basic_string<char, char_traits<char>, allocator<char>>>, void *>, __tree_node_destructor<allocator<__tree_node<__value_type<basic_string<char, char_traits<char>, allocator<char>>, basic_string<char, char_traits<char>, allocator<char>>>, void *>>>, __tree_node_destructor<allocator<__tree_node<__value_type<basic_string<char, char_traits<char>, allocator<char>>, basic_string<char, char_traits<char>, allocator<char>>>, void *>>>, true> &const __pointer<__tree_node<__value_type<basic_string<char, char_traits<char>, allocator<char>>, basic_string<char, char_traits<char>, allocator<char>>>, void *>, __tree_node_destructor<allocator<__tree_node<__value_type<basic_string<char, char_traits<char>, allocator<char>>, basic_string<char, char_traits<char>, allocator<char>>>, void *>>>, __tree_node_destructor<allocator<__tree_node<__value_type<basic_string<char, char_traits<char>, allocator<char>>, basic_string<char, char_traits<char>, allocator<char>>>, void *>>>, true>const __pointer<__tree_node<__value_type<basic_string<char, char_traits<char>, allocator<char>>, basic_string<char, char_traits<char>, allocator<char>>>, void *>, __tree_node_destructor<allocator<__tree_node<__value_type<basic_string<char, char_traits<char>, allocator<char>>, basic_string<char, char_traits<char>, allocator<char>>>, void *>>>, __tree_node_destructor<allocator<__tree_node<__value_type<basic_string<char, char_traits<char>, allocator<char>>, basic_string<char, char_traits<char>, allocator<char>>>, void *>>>, true> &__unique_ptr_deleter_sfinae<__tree_node_destructor<allocator<__tree_node<__value_type<basic_string<char, char_traits<char>, allocator<char>>, basic_string<char, char_traits<char>, allocator<char>>>, void *>>>>__unique_ptr_deleter_sfinae<__tree_node_destructor<allocator<__tree_node<__value_type<basic_string<char, char_traits<char>, allocator<char>>, basic_string<char, char_traits<char>, allocator<char>>>, void *>>>> &const __unique_ptr_deleter_sfinae<__tree_node_destructor<allocator<__tree_node<__value_type<basic_string<char, char_traits<char>, allocator<char>>, basic_string<char, char_traits<char>, allocator<char>>>, void *>>>>const __unique_ptr_deleter_sfinae<__tree_node_destructor<allocator<__tree_node<__value_type<basic_string<char, char_traits<char>, allocator<char>>, basic_string<char, char_traits<char>, allocator<char>>>, void *>>>> &__tree_node_destructor<allocator<__tree_node<__value_type<basic_string<char, char_traits<char>, allocator<char>>, basic_string<char, char_traits<char>, allocator<char>>>, void *>>> &&const __tree_node_destructor<allocator<__tree_node<__value_type<basic_string<char, char_traits<char>, allocator<char>>, basic_string<char, char_traits<char>, allocator<char>>>, void *>>>const __tree_node_destructor<allocator<__tree_node<__value_type<basic_string<char, char_traits<char>, allocator<char>>, basic_string<char, char_traits<char>, allocator<char>>>, void *>>> &allocator<__tree_node<__value_type<basic_string<char, char_traits<char>, allocator<char>>, basic_string<char, char_traits<char>, allocator<char>>>, void *>> *__compressed_pair_elem<__tree_end_node<__tree_node_base<void *> *>, 0, false> *const __compressed_pair<__tree_end_node<__tree_node_base<void *> *>, allocator<__tree_node<__value_type<basic_string<char, char_traits<char>, allocator<char>>, basic_string<char, char_traits<char>, allocator<char>>>, void *>>>const __compressed_pair<__tree_end_node<__tree_node_base<void *> *>, allocator<__tree_node<__value_type<basic_string<char, char_traits<char>, allocator<char>>, basic_string<char, char_traits<char>, allocator<char>>>, void *>>> *__compressed_pair<__tree_end_node<__tree_node_base<void *> *>, allocator<__tree_node<__value_type<basic_string<char, char_traits<char>, allocator<char>>, basic_string<char, char_traits<char>, allocator<char>>>, void *>>> *const __compressed_pair_elem<allocator<__tree_node<__value_type<basic_string<char, char_traits<char>, allocator<char>>, basic_string<char, char_traits<char>, allocator<char>>>, void *>>, 1, true>const __compressed_pair<unsigned long, __map_value_compare<basic_string<char, char_traits<char>, allocator<char>>, __value_type<basic_string<char, char_traits<char>, allocator<char>>, basic_string<char, char_traits<char>, allocator<char>>>, less<basic_string<char, char_traits<char>, allocator<char>>>, true>>const __compressed_pair<unsigned long, __map_value_compare<basic_string<char, char_traits<char>, allocator<char>>, __value_type<basic_string<char, char_traits<char>, allocator<char>>, basic_string<char, char_traits<char>, allocator<char>>>, less<basic_string<char, char_traits<char>, allocator<char>>>, true>> *__compressed_pair<unsigned long, __map_value_compare<basic_string<char, char_traits<char>, allocator<char>>, __value_type<basic_string<char, char_traits<char>, allocator<char>>, basic_string<char, char_traits<char>, allocator<char>>>, less<basic_string<char, char_traits<char>, allocator<char>>>, true>> *const __compressed_pair_elem<__map_value_compare<basic_string<char, char_traits<char>, allocator<char>>, __value_type<basic_string<char, char_traits<char>, allocator<char>>, basic_string<char, char_traits<char>, allocator<char>>>, less<basic_string<char, char_traits<char>, allocator<char>>>, true>, 1, true>const pair<const basic_string<char, char_traits<char>, allocator<char>>, basic_string<char, char_traits<char>, allocator<char>>>const pair<const basic_string<char, char_traits<char>, allocator<char>>, basic_string<char, char_traits<char>, allocator<char>>> &__has_pointer<__tree_node_destructor<allocator<__tree_node<__value_type<basic_string<char, char_traits<char>, allocator<char>>, basic_string<char, char_traits<char>, allocator<char>>>, void *>>>, void>__has_pointer<__tree_node_destructor<allocator<__tree_node<__value_type<basic_string<char, char_traits<char>, allocator<char>>, basic_string<char, char_traits<char>, allocator<char>>>, void *>>>, void> &const __has_pointer<__tree_node_destructor<allocator<__tree_node<__value_type<basic_string<char, char_traits<char>, allocator<char>>, basic_string<char, char_traits<char>, allocator<char>>>, void *>>>, void>const __has_pointer<__tree_node_destructor<allocator<__tree_node<__value_type<basic_string<char, char_traits<char>, allocator<char>>, basic_string<char, char_traits<char>, allocator<char>>>, void *>>>, void> &__compressed_pair_elem<__tree_node_destructor<allocator<__tree_node<__value_type<basic_string<char, char_traits<char>, allocator<char>>, basic_string<char, char_traits<char>, allocator<char>>>, void *>>>, 1, false>is_empty<_Tp>::value__libcpp_is_final<_Tp>::value!__libcpp_is_final<_Tp>::valueis_empty<_Tp>::value && !__libcpp_is_final<_Tp>::value__compressed_pair_elem<__tree_node_destructor<allocator<__tree_node<__value_type<basic_string<char, char_traits<char>, allocator<char>>, basic_string<char, char_traits<char>, allocator<char>>>, void *>>>, 1, false> &const __compressed_pair_elem<__tree_node_destructor<allocator<__tree_node<__value_type<basic_string<char, char_traits<char>, allocator<char>>, basic_string<char, char_traits<char>, allocator<char>>>, void *>>>, 1, false>const __compressed_pair_elem<__tree_node_destructor<allocator<__tree_node<__value_type<basic_string<char, char_traits<char>, allocator<char>>, basic_string<char, char_traits<char>, allocator<char>>>, void *>>>, 1, false> &const unique_ptr<__tree_node<__value_type<basic_string<char, char_traits<char>, allocator<char>>, basic_string<char, char_traits<char>, allocator<char>>>, void *>, __tree_node_destructor<allocator<__tree_node<__value_type<basic_string<char, char_traits<char>, allocator<char>>, basic_string<char, char_traits<char>, allocator<char>>>, void *>>>>const __compressed_pair_elem<__map_value_compare<basic_string<char, char_traits<char>, allocator<char>>, __value_type<basic_string<char, char_traits<char>, allocator<char>>, basic_string<char, char_traits<char>, allocator<char>>>, less<basic_string<char, char_traits<char>, allocator<char>>>, true>, 1, true> *__compressed_pair_elem<__map_value_compare<basic_string<char, char_traits<char>, allocator<char>>, __value_type<basic_string<char, char_traits<char>, allocator<char>>, basic_string<char, char_traits<char>, allocator<char>>>, less<basic_string<char, char_traits<char>, allocator<char>>>, true>, 1, true> *const __compressed_pair_elem<allocator<__tree_node<__value_type<basic_string<char, char_traits<char>, allocator<char>>, basic_string<char, char_traits<char>, allocator<char>>>, void *>>, 1, true> *__compressed_pair_elem<allocator<__tree_node<__value_type<basic_string<char, char_traits<char>, allocator<char>>, basic_string<char, char_traits<char>, allocator<char>>>, void *>>, 1, true> *remove_reference<const pair<const basic_string<char, char_traits<char>, allocator<char>>, basic_string<char, char_traits<char>, allocator<char>>> &>remove_reference<const pair<const basic_string<char, char_traits<char>, allocator<char>>, basic_string<char, char_traits<char>, allocator<char>>> &> &const remove_reference<const pair<const basic_string<char, char_traits<char>, allocator<char>>, basic_string<char, char_traits<char>, allocator<char>>> &>const remove_reference<const pair<const basic_string<char, char_traits<char>, allocator<char>>, basic_string<char, char_traits<char>, allocator<char>>> &> &unique_ptr<__tree_node<__value_type<basic_string<char, char_traits<char>, allocator<char>>, basic_string<char, char_traits<char>, allocator<char>>>, void *>, __tree_node_destructor<allocator<__tree_node<__value_type<basic_string<char, char_traits<char>, allocator<char>>, basic_string<char, char_traits<char>, allocator<char>>>, void *>>>> *const unique_ptr<__tree_node<__value_type<basic_string<char, char_traits<char>, allocator<char>>, basic_string<char, char_traits<char>, allocator<char>>>, void *>, __tree_node_destructor<allocator<__tree_node<__value_type<basic_string<char, char_traits<char>, allocator<char>>, basic_string<char, char_traits<char>, allocator<char>>>, void *>>>> *__iterator_traits_impl<__tree_const_iterator<__value_type<basic_string<char, char_traits<char>, allocator<char>>, basic_string<char, char_traits<char>, allocator<char>>>, __tree_node<__value_type<basic_string<char, char_traits<char>, allocator<char>>, basic_string<char, char_traits<char>, allocator<char>>>, void *> *, long>, true>__iterator_traits_impl<__tree_const_iterator<__value_type<basic_string<char, char_traits<char>, allocator<char>>, basic_string<char, char_traits<char>, allocator<char>>>, __tree_node<__value_type<basic_string<char, char_traits<char>, allocator<char>>, basic_string<char, char_traits<char>, allocator<char>>>, void *> *, long>, true> &const __iterator_traits_impl<__tree_const_iterator<__value_type<basic_string<char, char_traits<char>, allocator<char>>, basic_string<char, char_traits<char>, allocator<char>>>, __tree_node<__value_type<basic_string<char, char_traits<char>, allocator<char>>, basic_string<char, char_traits<char>, allocator<char>>>, void *> *, long>, true>const __iterator_traits_impl<__tree_const_iterator<__value_type<basic_string<char, char_traits<char>, allocator<char>>, basic_string<char, char_traits<char>, allocator<char>>>, __tree_node<__value_type<basic_string<char, char_traits<char>, allocator<char>>, basic_string<char, char_traits<char>, allocator<char>>>, void *> *, long>, true> &enable_if<true, __tree_const_iterator<__value_type<basic_string<char, char_traits<char>, allocator<char>>, basic_string<char, char_traits<char>, allocator<char>>>, __tree_node<__value_type<basic_string<char, char_traits<char>, allocator<char>>, basic_string<char, char_traits<char>, allocator<char>>>, void *> *, long>>enable_if<true, __tree_const_iterator<__value_type<basic_string<char, char_traits<char>, allocator<char>>, basic_string<char, char_traits<char>, allocator<char>>>, __tree_node<__value_type<basic_string<char, char_traits<char>, allocator<char>>, basic_string<char, char_traits<char>, allocator<char>>>, void *> *, long>> &const enable_if<true, __tree_const_iterator<__value_type<basic_string<char, char_traits<char>, allocator<char>>, basic_string<char, char_traits<char>, allocator<char>>>, __tree_node<__value_type<basic_string<char, char_traits<char>, allocator<char>>, basic_string<char, char_traits<char>, allocator<char>>>, void *> *, long>>const enable_if<true, __tree_const_iterator<__value_type<basic_string<char, char_traits<char>, allocator<char>>, basic_string<char, char_traits<char>, allocator<char>>>, __tree_node<__value_type<basic_string<char, char_traits<char>, allocator<char>>, basic_string<char, char_traits<char>, allocator<char>>>, void *> *, long>> &__tree_const_iterator<__value_type<basic_string<char, char_traits<char>, allocator<char>>, basic_string<char, char_traits<char>, allocator<char>>>, __tree_node<__value_type<basic_string<char, char_traits<char>, allocator<char>>, basic_string<char, char_traits<char>, allocator<char>>>, void *> *, long> *unique_ptr<__tree_node<__value_type<basic_string<char, char_traits<char>, allocator<char>>, basic_string<char, char_traits<char>, allocator<char>>>, void *>, __tree_node_destructor<allocator<__tree_node<__value_type<basic_string<char, char_traits<char>, allocator<char>>, basic_string<char, char_traits<char>, allocator<char>>>, void *>>>> &&__tree_node<__value_type<basic_string<char, char_traits<char>, allocator<char>>, basic_string<char, char_traits<char>, allocator<char>>>, void *> *&const __compressed_pair<__tree_node<__value_type<basic_string<char, char_traits<char>, allocator<char>>, basic_string<char, char_traits<char>, allocator<char>>>, void *> *, __tree_node_destructor<allocator<__tree_node<__value_type<basic_string<char, char_traits<char>, allocator<char>>, basic_string<char, char_traits<char>, allocator<char>>>, void *>>>> *__compressed_pair<__tree_node<__value_type<basic_string<char, char_traits<char>, allocator<char>>, basic_string<char, char_traits<char>, allocator<char>>>, void *> *, __tree_node_destructor<allocator<__tree_node<__value_type<basic_string<char, char_traits<char>, allocator<char>>, basic_string<char, char_traits<char>, allocator<char>>>, void *>>>> *const __compressed_pair_elem<__tree_node<__value_type<basic_string<char, char_traits<char>, allocator<char>>, basic_string<char, char_traits<char>, allocator<char>>>, void *> *, 0, false>__tree_node<__value_type<basic_string<char, char_traits<char>, allocator<char>>, basic_string<char, char_traits<char>, allocator<char>>>, void *> *const__tree_node<__value_type<basic_string<char, char_traits<char>, allocator<char>>, basic_string<char, char_traits<char>, allocator<char>>>, void *> *const &remove_reference<__tree_node_destructor<allocator<__tree_node<__value_type<basic_string<char, char_traits<char>, allocator<char>>, basic_string<char, char_traits<char>, allocator<char>>>, void *>>>>remove_reference<__tree_node_destructor<allocator<__tree_node<__value_type<basic_string<char, char_traits<char>, allocator<char>>, basic_string<char, char_traits<char>, allocator<char>>>, void *>>>> &const remove_reference<__tree_node_destructor<allocator<__tree_node<__value_type<basic_string<char, char_traits<char>, allocator<char>>, basic_string<char, char_traits<char>, allocator<char>>>, void *>>>>const remove_reference<__tree_node_destructor<allocator<__tree_node<__value_type<basic_string<char, char_traits<char>, allocator<char>>, basic_string<char, char_traits<char>, allocator<char>>>, void *>>>> &__tree_node_destructor<allocator<__tree_node<__value_type<basic_string<char, char_traits<char>, allocator<char>>, basic_string<char, char_traits<char>, allocator<char>>>, void *>>> *__tree_node<__value_type<basic_string<char, char_traits<char>, allocator<char>>, basic_string<char, char_traits<char>, allocator<char>>>, void *> *&&__compressed_pair_elem<__tree_node_destructor<allocator<__tree_node<__value_type<basic_string<char, char_traits<char>, allocator<char>>, basic_string<char, char_traits<char>, allocator<char>>>, void *>>>, 1, false> *vector<Iptcdatum, allocator<Iptcdatum>> &const vector<Iptcdatum, allocator<Iptcdatum>> &IptcMetadata *const IptcMetadataconst IptcMetadata &vector<Xmpdatum, allocator<Xmpdatum>> &const vector<Xmpdatum, allocator<Xmpdatum>> &XmpMetadata *const XmpMetadataconst XmpMetadata &/Users/owura/Repos/codeql_eval/proj_repos/Exiv2-exiv2-pull-962-commits-e925bc5addd881543fa503470c8a859e112cca62/exiv2/include/exiv2/webpimage.hppisWebPTypenewWebPInstance~WebPImageWebPImage &const WebPImageconst WebPImage &WebPImageinject_VP8XdecodeChunksdebugPrintHexequalsWebPTaggetHeaderOffsetwebpWEBP_CHUNK_HEADER_XMPWEBP_CHUNK_HEADER_EXIFWEBP_CHUNK_HEADER_ICCPWEBP_CHUNK_HEADER_ANIMWEBP_CHUNK_HEADER_ANMFWEBP_CHUNK_HEADER_VP8WEBP_CHUNK_HEADER_VP8LWEBP_CHUNK_HEADER_VP8XWEBP_VP8X_XMP_BITWEBP_VP8X_EXIF_BITWEBP_VP8X_ALPHA_BITWEBP_VP8X_ICC_BITWEBP_TAG_SIZEWEBP_PAD_ODDWEBPIMAGE_HPP// WEBPIMAGE_HPP//! Check if the file iIo is a WebP Video./*!
      @brief Create a new WebPImage instance and return an auto-pointer to it.
          Caller owns the returned object and the auto-pointer ensures that
          it will be deleted.
     *///Class WebPImage/*!
          @brief Constructor for a WebP video. Since the constructor
              can not return a result, callers should check the good() method
              after object construction to determine success or failure.
          @param io An auto-pointer that owns a BasicIo instance used for
              reading and writing image metadata. \b Important: The constructor
              takes ownership of the passed in BasicIo instance through the
              auto-pointer. Callers should not continue to use the BasicIo
              instance after it is passed to this method. Use the Image::io()
              method to get a temporary reference.
         *//*!
      @brief Class to access WEBP video files.
     *///!< Treating webp as an image type>// Add WEBP to the supported image formats/*!
  @file    webpimage.hpp
  @brief   An Image subclass to support WEBP image files
  @author  Ben Touchette
           <a href="mailto:draekko.software+exiv2@gmail.com">draekko.software+exiv2@gmail.com</a>
  @date    29-Jul-16
 */has_xmphas_exifhas_alphahas_iccfilesizedata_sizeheader_sizeoutIo/Users/owura/Repos/codeql_eval/proj_repos/Exiv2-exiv2-pull-962-commits-e925bc5addd881543fa503470c8a859e112cca62/exiv2/src/tiffvisitor_int.hpp/Users/owura/Repos/codeql_eval/proj_repos/Exiv2-exiv2-pull-962-commits-e925bc5addd881543fa503470c8a859e112cca62/exiv2/src/nikonmn_int.hpp/Users/owura/Repos/codeql_eval/proj_repos/Exiv2-exiv2-pull-962-commits-e925bc5addd881543fa503470c8a859e112cca62/exiv2/src/image.cpp"pgfimage.hpp""rw2image.hpp""nikonmn_int.hpp""jp2image.hpp""tgaimage.hpp""psdimage.hpp""orfimage.hpp""webpimage.hpp""tiffvisitor_int.hpp""rafimage.hpp""pngimage.hpp""mrwimage.hpp"buf != 0typeValidconst Registryconst Registry *Registry *const Registry[27]Registry[27]const Registry(&)[27]Registry(&)[27]amImageType::noneconst auto_ptr<FileIo>auto_ptr<FileIo> &fProtRegistry &const Registry &BYTE"BYTE"ASCII"ASCII"SHORT"SHORT"LONG"LONG"RATIONAL"RATIONAL"SBYTE"SBYTE"SSHORT"SSHORT"SLONG"SLONG"SRATIONAL"SRATIONAL"FLOAT"FLOAT"DOUBLE"DOUBLE"IFD"IFD"uint64_t *uint16_t *0x00FF0xFF000x000000FF0x0000FF00167116800x00FF000042781900800xFF000000source_valuedestination_value346750x8773Exiv2::tiffIfd8Exiv2::unsignedLongLongExiv2::signedLongLong16777216dirSizeseekSuccessbytesReaddirLengthSTRUCTURE OF TIFF FILE (%c%c): "STRUCTURE OF TIFF FILE (%c%c): "dirLength = "dirLength = "bOffsetIsPointer address |    tag                              |     " address |    tag                              |     "invalid type value detected in Image::printIFDStructure:  "invalid type value detected in Image::printIFDStructure:  "offsetString%10u"%10u"%8u | %#06x %-28s |%10s |%9u |%10s | "%8u | %#06x %-28s |%10s |%9u |%10s | "XmpParser::useCompactFormatXmpParser::omitAllFormatting2112XmpParser::useCompactFormat |
                              XmpParser::omitAllFormatting(long) sizeof(long)pixelWidth_(0)pixelHeight_(0)writeXmpFromPacket_(false)init_(true)commentSupport_xmpSupport_iptcSupport_exifSupport_isThisType_newInstance_const Registry[]Registry[]ImageType::jpegImageType::exvImageType::mrwImageType::tiffImageType::webpImageType::dngImageType::nefImageType::pefImageType::arwImageType::rw2ImageType::sr2ImageType::srwImageType::orfImageType::pngImageType::pgfImageType::rafImageType::xmpImageType::psdImageType::tgaImageType::jp2registryEXV_ENABLE_VIDEOEXV_USE_SSH == 1EXV_USE_CURL == 1// ImageFactory::create// BasicIo instance does not need to be open// ImageFactory::open// ImageFactory::createIo// ImageFactory::getType// ImageFactory::checkType// no default: let the compiler complain// Serialize the current XMP// read header (we already know for certain that we have a Tiff file)/*=0*/// free// copy dir[8:11] into buffer (short strings)// allocate a buffer// if ( offset > io.size() ) offset = 0; // Denial of service?// ditto// haul in all the data// break from do loop// Break for unknown tag types else we may segfault.//! List of TIFF image tags/*depth*/// EXV_ENABLE_VIDEO// EXV_HAVE_LIBZ//---------------  ---------------  ----------  -----------  -----------  -----------  ------------//image type       creation fct     type check  Exif mode    IPTC mode    XMP mode     Comment mode//! Comparison operator to compare a Registry structure with an image type//! Struct for storing image types and function pointers.// stat/*
  File:      image.cpp
 */auto_ptr_ref<BasicIo>auto_ptr_ref<BasicIo> &const auto_ptr_ref<BasicIo>const auto_ptr_ref<BasicIo> &auto_ptr<FileIo>integral_constant<bool, value>map<int, basic_string<char, char_traits<char>, allocator<char>>, less<int>, allocator<pair<const int, basic_string<char, char_traits<char>, allocator<char>>>>> *const unique_ptr<__tree_node<__value_type<int, basic_string<char, char_traits<char>, allocator<char>>>, void *>, __map_node_destructor<allocator<__tree_node<__value_type<int, basic_string<char, char_traits<char>, allocator<char>>>, void *>>>>operator std::__1::auto_ptr_ref<Exiv2::BasicIo>auto_ptr<FileIo> *const auto_ptr<FileIo> *const __list_imp<Exifdatum, allocator<Exifdatum>> &__list_imp<Exifdatum, allocator<Exifdatum>> &__tree_node<__value_type<int, basic_string<char, char_traits<char>, allocator<char>>>, void *> *&__map_node_destructor<allocator<__tree_node<__value_type<int, basic_string<char, char_traits<char>, allocator<char>>>, void *>>> &operator std::__1::__tree_node<std::__1::__value_type<int, std::__1::basic_string<char, std::__1::char_traits<char>, std::__1::allocator<char>>>, void *> *operator Exiv2::FileIo *__map_value_compare<int, __value_type<int, basic_string<char, char_traits<char>, allocator<char>>>, less<int>, true> *const __map_node_destructor<allocator<__tree_node<__value_type<int, basic_string<char, char_traits<char>, allocator<char>>>, void *>>>const __map_node_destructor<allocator<__tree_node<__value_type<int, basic_string<char, char_traits<char>, allocator<char>>>, void *>>> &unique_ptr<__tree_node<__value_type<int, basic_string<char, char_traits<char>, allocator<char>>>, void *>, __map_node_destructor<allocator<__tree_node<__value_type<int, basic_string<char, char_traits<char>, allocator<char>>>, void *>>>> &unique_ptr<__tree_node<__value_type<int, basic_string<char, char_traits<char>, allocator<char>>>, void *>, __map_node_destructor<allocator<__tree_node<__value_type<int, basic_string<char, char_traits<char>, allocator<char>>>, void *>>>> *const unique_ptr<__tree_node<__value_type<int, basic_string<char, char_traits<char>, allocator<char>>>, void *>, __map_node_destructor<allocator<__tree_node<__value_type<int, basic_string<char, char_traits<char>, allocator<char>>>, void *>>>> *__tree<__value_type<int, basic_string<char, char_traits<char>, allocator<char>>>, __map_value_compare<int, __value_type<int, basic_string<char, char_traits<char>, allocator<char>>>, less<int>, true>, allocator<__value_type<int, basic_string<char, char_traits<char>, allocator<char>>>>> *const __tree<__value_type<int, basic_string<char, char_traits<char>, allocator<char>>>, __map_value_compare<int, __value_type<int, basic_string<char, char_traits<char>, allocator<char>>>, less<int>, true>, allocator<__value_type<int, basic_string<char, char_traits<char>, allocator<char>>>>>const __tree<__value_type<int, basic_string<char, char_traits<char>, allocator<char>>>, __map_value_compare<int, __value_type<int, basic_string<char, char_traits<char>, allocator<char>>>, less<int>, true>, allocator<__value_type<int, basic_string<char, char_traits<char>, allocator<char>>>>> *__compressed_pair_elem<__tree_node<__value_type<int, basic_string<char, char_traits<char>, allocator<char>>>, void *> *, 0, false>__compressed_pair_elem<__tree_node<__value_type<int, basic_string<char, char_traits<char>, allocator<char>>>, void *> *, 0, false> &const __compressed_pair_elem<__tree_node<__value_type<int, basic_string<char, char_traits<char>, allocator<char>>>, void *> *, 0, false>const __compressed_pair_elem<__tree_node<__value_type<int, basic_string<char, char_traits<char>, allocator<char>>>, void *> *, 0, false> &__tree_node<__value_type<int, basic_string<char, char_traits<char>, allocator<char>>>, void *> *const__tree_node<__value_type<int, basic_string<char, char_traits<char>, allocator<char>>>, void *> *const &__compressed_pair<__tree_node<__value_type<int, basic_string<char, char_traits<char>, allocator<char>>>, void *> *, __map_node_destructor<allocator<__tree_node<__value_type<int, basic_string<char, char_traits<char>, allocator<char>>>, void *>>>>__compressed_pair<__tree_node<__value_type<int, basic_string<char, char_traits<char>, allocator<char>>>, void *> *, __map_node_destructor<allocator<__tree_node<__value_type<int, basic_string<char, char_traits<char>, allocator<char>>>, void *>>>> &const __compressed_pair<__tree_node<__value_type<int, basic_string<char, char_traits<char>, allocator<char>>>, void *> *, __map_node_destructor<allocator<__tree_node<__value_type<int, basic_string<char, char_traits<char>, allocator<char>>>, void *>>>>const __compressed_pair<__tree_node<__value_type<int, basic_string<char, char_traits<char>, allocator<char>>>, void *> *, __map_node_destructor<allocator<__tree_node<__value_type<int, basic_string<char, char_traits<char>, allocator<char>>>, void *>>>> &__pointer<__tree_node<__value_type<int, basic_string<char, char_traits<char>, allocator<char>>>, void *>, __map_node_destructor<allocator<__tree_node<__value_type<int, basic_string<char, char_traits<char>, allocator<char>>>, void *>>>, __map_node_destructor<allocator<__tree_node<__value_type<int, basic_string<char, char_traits<char>, allocator<char>>>, void *>>>, true>__pointer<__tree_node<__value_type<int, basic_string<char, char_traits<char>, allocator<char>>>, void *>, __map_node_destructor<allocator<__tree_node<__value_type<int, basic_string<char, char_traits<char>, allocator<char>>>, void *>>>, __map_node_destructor<allocator<__tree_node<__value_type<int, basic_string<char, char_traits<char>, allocator<char>>>, void *>>>, true> &const __pointer<__tree_node<__value_type<int, basic_string<char, char_traits<char>, allocator<char>>>, void *>, __map_node_destructor<allocator<__tree_node<__value_type<int, basic_string<char, char_traits<char>, allocator<char>>>, void *>>>, __map_node_destructor<allocator<__tree_node<__value_type<int, basic_string<char, char_traits<char>, allocator<char>>>, void *>>>, true>const __pointer<__tree_node<__value_type<int, basic_string<char, char_traits<char>, allocator<char>>>, void *>, __map_node_destructor<allocator<__tree_node<__value_type<int, basic_string<char, char_traits<char>, allocator<char>>>, void *>>>, __map_node_destructor<allocator<__tree_node<__value_type<int, basic_string<char, char_traits<char>, allocator<char>>>, void *>>>, true> &__unique_ptr_deleter_sfinae<__map_node_destructor<allocator<__tree_node<__value_type<int, basic_string<char, char_traits<char>, allocator<char>>>, void *>>>>__unique_ptr_deleter_sfinae<__map_node_destructor<allocator<__tree_node<__value_type<int, basic_string<char, char_traits<char>, allocator<char>>>, void *>>>> &const __unique_ptr_deleter_sfinae<__map_node_destructor<allocator<__tree_node<__value_type<int, basic_string<char, char_traits<char>, allocator<char>>>, void *>>>>const __unique_ptr_deleter_sfinae<__map_node_destructor<allocator<__tree_node<__value_type<int, basic_string<char, char_traits<char>, allocator<char>>>, void *>>>> &__map_node_destructor<allocator<__tree_node<__value_type<int, basic_string<char, char_traits<char>, allocator<char>>>, void *>>> &&const __map_value_compare<int, __value_type<int, basic_string<char, char_traits<char>, allocator<char>>>, less<int>, true> *unique_ptr<__tree_node<__value_type<int, basic_string<char, char_traits<char>, allocator<char>>>, void *>, __map_node_destructor<allocator<__tree_node<__value_type<int, basic_string<char, char_traits<char>, allocator<char>>>, void *>>>> &&const __compressed_pair<__tree_node<__value_type<int, basic_string<char, char_traits<char>, allocator<char>>>, void *> *, __map_node_destructor<allocator<__tree_node<__value_type<int, basic_string<char, char_traits<char>, allocator<char>>>, void *>>>> *__compressed_pair<__tree_node<__value_type<int, basic_string<char, char_traits<char>, allocator<char>>>, void *> *, __map_node_destructor<allocator<__tree_node<__value_type<int, basic_string<char, char_traits<char>, allocator<char>>>, void *>>>> *const unique_ptr<__list_node<Exifdatum, void *>, __allocator_destructor<allocator<__list_node<Exifdatum, void *>>>>remove_reference<__map_node_destructor<allocator<__tree_node<__value_type<int, basic_string<char, char_traits<char>, allocator<char>>>, void *>>>>remove_reference<__map_node_destructor<allocator<__tree_node<__value_type<int, basic_string<char, char_traits<char>, allocator<char>>>, void *>>>> &const remove_reference<__map_node_destructor<allocator<__tree_node<__value_type<int, basic_string<char, char_traits<char>, allocator<char>>>, void *>>>>const remove_reference<__map_node_destructor<allocator<__tree_node<__value_type<int, basic_string<char, char_traits<char>, allocator<char>>>, void *>>>> &remove_reference<const __map_value_compare<int, __value_type<int, basic_string<char, char_traits<char>, allocator<char>>>, less<int>, true> &>remove_reference<const __map_value_compare<int, __value_type<int, basic_string<char, char_traits<char>, allocator<char>>>, less<int>, true> &> &const remove_reference<const __map_value_compare<int, __value_type<int, basic_string<char, char_traits<char>, allocator<char>>>, less<int>, true> &>const remove_reference<const __map_value_compare<int, __value_type<int, basic_string<char, char_traits<char>, allocator<char>>>, less<int>, true> &> &__has_pointer<__map_node_destructor<allocator<__tree_node<__value_type<int, basic_string<char, char_traits<char>, allocator<char>>>, void *>>>, void>__has_pointer<__map_node_destructor<allocator<__tree_node<__value_type<int, basic_string<char, char_traits<char>, allocator<char>>>, void *>>>, void> &const __has_pointer<__map_node_destructor<allocator<__tree_node<__value_type<int, basic_string<char, char_traits<char>, allocator<char>>>, void *>>>, void>const __has_pointer<__map_node_destructor<allocator<__tree_node<__value_type<int, basic_string<char, char_traits<char>, allocator<char>>>, void *>>>, void> &__compressed_pair_elem<__map_node_destructor<allocator<__tree_node<__value_type<int, basic_string<char, char_traits<char>, allocator<char>>>, void *>>>, 1, false>__compressed_pair_elem<__map_node_destructor<allocator<__tree_node<__value_type<int, basic_string<char, char_traits<char>, allocator<char>>>, void *>>>, 1, false> &const __compressed_pair_elem<__map_node_destructor<allocator<__tree_node<__value_type<int, basic_string<char, char_traits<char>, allocator<char>>>, void *>>>, 1, false>const __compressed_pair_elem<__map_node_destructor<allocator<__tree_node<__value_type<int, basic_string<char, char_traits<char>, allocator<char>>>, void *>>>, 1, false> &__map_node_destructor<allocator<__tree_node<__value_type<int, basic_string<char, char_traits<char>, allocator<char>>>, void *>>> *__compressed_pair_elem<__tree_node<__value_type<int, basic_string<char, char_traits<char>, allocator<char>>>, void *> *, 0, false> *const __compressed_pair_elem<__tree_node<__value_type<int, basic_string<char, char_traits<char>, allocator<char>>>, void *> *, 0, false> *__compressed_pair<__tree_end_node<__tree_node_base<void *> *>, allocator<__tree_node<__value_type<int, basic_string<char, char_traits<char>, allocator<char>>>, void *>>> *__compressed_pair<unsigned long, __map_value_compare<int, __value_type<int, basic_string<char, char_traits<char>, allocator<char>>>, less<int>, true>> *__tree_node<__value_type<int, basic_string<char, char_traits<char>, allocator<char>>>, void *> *&&const less<int> *less<int> *remove_reference<__tree_node<__value_type<int, basic_string<char, char_traits<char>, allocator<char>>>, void *> *>remove_reference<__tree_node<__value_type<int, basic_string<char, char_traits<char>, allocator<char>>>, void *> *> &const remove_reference<__tree_node<__value_type<int, basic_string<char, char_traits<char>, allocator<char>>>, void *> *>const remove_reference<__tree_node<__value_type<int, basic_string<char, char_traits<char>, allocator<char>>>, void *> *> &allocator<__tree_node<__value_type<int, basic_string<char, char_traits<char>, allocator<char>>>, void *>> *__compressed_pair_elem<__map_value_compare<int, __value_type<int, basic_string<char, char_traits<char>, allocator<char>>>, less<int>, true>, 1, true> *const __compressed_pair<__tree_end_node<__tree_node_base<void *> *>, allocator<__tree_node<__value_type<int, basic_string<char, char_traits<char>, allocator<char>>>, void *>>> *__compressed_pair_elem<__map_node_destructor<allocator<__tree_node<__value_type<int, basic_string<char, char_traits<char>, allocator<char>>>, void *>>>, 1, false> *__compressed_pair_elem<allocator<__tree_node<__value_type<int, basic_string<char, char_traits<char>, allocator<char>>>, void *>>, 1, true> *__non_trivial_if<true, allocator<NativePreview>> */Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX.sdk/usr/include/c++/v1/cstdarg_LIBCPP_CSTDARG// _LIBCPP_CSTDARG/*
    cstdarg synopsis

Macros:

    type va_arg(va_list ap, type);
    void va_copy(va_list dest, va_list src);  // C99
    void va_end(va_list ap);
    void va_start(va_list ap, parmN);

namespace std
{

Types:

    va_list

}  // std

*///===--------------------------- cstdarg ----------------------------------===///Users/owura/Repos/codeql_eval/proj_repos/Exiv2-exiv2-pull-962-commits-e925bc5addd881543fa503470c8a859e112cca62/exiv2/src/image_int.cpp<cstdarg>hexOutputtltl_offsetloop 150x7Eargsrc >= 0__va_list_tag *// rc < 0 => we have made an error in the format string// free the args// args start after format// variable arg list// or two iterations (after the first call to vsnprintf we know the required length)// one iteration (if 'need' was large enough for the for formatted string)// the following loop goes through://           returns the number of bytes required for the formatted string excluding \0// vsnprintf writes at most size (2nd parameter) bytes (including \0)// initial guessconst basic_stringstream<char, char_traits<char>, allocator<char>> *basic_iostream<char, char_traits<char>> *_BinaryOperation_UnaryOperation_LIBCPP___ALGORITHM_TRANSFORM_H// _LIBCPP___ALGORITHM_TRANSFORM_H__binary_op/Users/owura/Repos/codeql_eval/proj_repos/Exiv2-exiv2-pull-962-commits-e925bc5addd881543fa503470c8a859e112cca62/exiv2/src/ini.cppMAX_SECTIONMAX_NAMEprev_namelineno0xEF0xBB0xBFsizeof(section)=:"=:"sizeof(prev_name)="="valstryes"yes"on"on"no"no"off"off"strncpy0find_chars_or_commentwas_space;lskiprstripdefined(_MSC_VER) && !defined(_CRT_SECURE_NO_WARNINGS)!INI_USE_STACK// Convert to lower case to make section/name lookups case-insensitive// Convert to lower case to make string comparisons case-insensitive// This parses "1234" (decimal) and also "0x4D2" (hex)/* See documentation in header file. *//* No '=' or ':' found on name[=:]value line *//* Valid name[=:]value pair found, call handler *//* Not a comment, must be a name[=:]value pair *//* No ']' found on section line *//* A "[section]" line *//* Non-blank line with leading whitespace, treat as continuation
               of previous name's value (as per Python configparser). *//* Per Python configparser, allow both ; and # comments at the
               start of a line *//* Scan through stream line by line *//* Uses a fair bit of stack (use heap instead if you need to) *//* Version of strncpy that ensures dest (size bytes) is null-terminated. *//* Return pointer to first char (of chars) or inline comment in given string,
   or pointer to null at end of string if neither found. Inline comment must
   be prefixed by a whitespace character to register as a comment. *//* Return pointer to first non-whitespace char in given string. *//* Strip whitespace chars off end of given string, in place. Return s. */back_inserterback_insert_iterator<_Container> &back_insert_iterator<_Container> *_Container *back_insert_iteratorback_insert_iterator<_Container>_LIBCPP___ITERATOR_BACK_INSERT_ITERATOR_H// _LIBCPP___ITERATOR_BACK_INSERT_ITERATOR_Hconst ContainerStorage<container>const ContainerStorage<container> *ContainerStorage<container> *Invalid input parameters to slice"Invalid input parameters to slice"new_beginnew_endconst Slice<T *>const Slice<T *> *Slice<const T *> *Slice<const container> *__copy_LIBCPP___ALGORITHM_COPY_H// _LIBCPP___ALGORITHM_COPY_H_LIBCPP___ALGORITHM_MOVE_H// _LIBCPP___ALGORITHM_MOVE_H_BidirectionalIterator1_BidirectionalIterator2_LIBCPP___ALGORITHM_MOVE_BACKWARD_H// _LIBCPP___ALGORITHM_MOVE_BACKWARD_H/Users/owura/Repos/codeql_eval/proj_repos/Exiv2-exiv2-pull-962-commits-e925bc5addd881543fa503470c8a859e112cca62/exiv2/src/iptc.cppExiv2::bigEndiancmpIptcdataByRecordpWritesortedIptcDataIptcMetadata &sizeOfSize327724 | 0x8000pReadconst byte *constpEndextTest0x7FFFFailed to read IPTC dataset "Failed to read IPTC dataset " (rc = " (rc = "); skipped.
"); skipped.\n"IPTC dataset "IPTC dataset " has invalid size " has invalid size "; skipped.
"; skipped.\n"FindIptcdatum &const FindIptcdatumconst FindIptcdatum &FindIptcdatumFindIptcdatum *const FindIptcdatum *0x1cRecord | DataSet | Name                     | Length | Data"Record | DataSet | Name                     | Length | Data"const Slice<const unsigned char *>const Slice<const unsigned char *> &Slice<const unsigned char *> &  %6d | %7d | %-24s | %6d | "  %6d | %7d | %-24s | %6d | "const binaryToStringHelper<const Slice<unsigned char *>>const binaryToStringHelper<const Slice<unsigned char *>> &binaryToStringHelper<const Slice<unsigned char *>> &..."..."utf8seqCount0xe00xf00xf80xfc0xfenewSizedataset_0x1C// If the first attempt failed, try with a string value// IptcParser::encode// always use 4 bytes for extended length// extended or standard dataset?// marker, record Id, dataset num// Copy the iptc data sets and sort them by record but preserve the order of datasets/*!
      @brief Compare two iptc items by record. Return true if the record of
             lhs is less than that of rhs.

      This is a helper function for IptcParser::encode().
     */// IptcParser::decode// standard dataset// extended dataset// standard, which advises to treat such cases as errors.// the chunk bytes present in some images. This deviates from the// First byte should be a marker. If it isn't, scan forward and skip// unterminated seq// ascii character// other values are probably not practically relevant// IptcData::size// extended dataset (we always use 4 bytes)// marker, record Id, dataset num, first 2 bytes of size// Iptcdatum::operator=// class FindIptcdatum/*!
          @brief Returns true if the record and dataset id of the argument
                Iptcdatum is equal to that of the object.
        *///! Constructor, initializes the object with the record and dataset id//! Unary predicate that matches an Iptcdatum with given record and dataset/*!
      @brief Read a single dataset payload and create a new metadata entry.

      @param iptcData IPTC metadata container to add the dataset to
      @param dataSet  DataSet number
      @param record   Record Id
      @param data     Pointer to the first byte of dataset payload
      @param sizeData Length in bytes of dataset payload
      @return 0 if successful.
     *//*
  File:      iptc.cpp
  Author(s): Brad Schick (brad) <brad@robotbattle.com>
  History:   31-July-04, brad: created
 */iptcDatumSlice<const Slice<unsigned char *>>Slice<const Slice<unsigned char *>> &const Slice<const Slice<unsigned char *>>const Slice<const Slice<unsigned char *>> &Slice<const Slice<unsigned char *>> *binaryToStringHelper<const Slice<unsigned char *>>binaryToStringHelper<const Slice<unsigned char *>> *back_insert_iterator<vector<Iptcdatum, allocator<Iptcdatum>>>back_insert_iterator<vector<Iptcdatum, allocator<Iptcdatum>>> &const back_insert_iterator<vector<Iptcdatum, allocator<Iptcdatum>>>const back_insert_iterator<vector<Iptcdatum, allocator<Iptcdatum>>> &back_insert_iterator<vector<Iptcdatum, allocator<Iptcdatum>>> *Slice<const unsigned char *> *Iptcdatum *&&__wrap_iter<Iptcdatum *> &&const ConstSliceBase<ContainerStorage, const Slice<unsigned char *>>const Slice<unsigned char *> *const ConstSliceBase<PtrSliceStorage, unsigned char *const>const ConstSliceBase<PtrSliceStorage, const unsigned char *>const __wrap_iter<const Iptcdatum *> *stable_sortstatic_cast<difference_type>(__stable_sort_switch<value_type>::value)pair<Iptcdatum *, long> &const pair<Iptcdatum *, long>const pair<Iptcdatum *, long> &const Iptcdatum *&&__wrap_iter<const Iptcdatum *> &&back_insert_iterator<vector<Iptcdatum, allocator<Iptcdatum>>> &&const auto_ptr<IptcKey>const auto_ptr<IptcKey> *const Iptcdatum *&__unwrap_iter_impl<back_insert_iterator<vector<Iptcdatum, allocator<Iptcdatum>>>, false>__unwrap_iter_impl<back_insert_iterator<vector<Iptcdatum, allocator<Iptcdatum>>>, false> &const __unwrap_iter_impl<back_insert_iterator<vector<Iptcdatum, allocator<Iptcdatum>>>, false>const __unwrap_iter_impl<back_insert_iterator<vector<Iptcdatum, allocator<Iptcdatum>>>, false> &__unwrap_iter_impl<__wrap_iter<const Iptcdatum *>, true>__unwrap_iter_impl<__wrap_iter<const Iptcdatum *>, true> &const __unwrap_iter_impl<__wrap_iter<const Iptcdatum *>, true>const __unwrap_iter_impl<__wrap_iter<const Iptcdatum *>, true> &__stable_sort_switch<Iptcdatum>__stable_sort_switch<Iptcdatum> &const __stable_sort_switch<Iptcdatum>const __stable_sort_switch<Iptcdatum> &unique_ptr<Iptcdatum, __return_temporary_buffer>unique_ptr<Iptcdatum, __return_temporary_buffer> &pair<Iptcdatum *, long>pair<Iptcdatum *, long> *__iterator_traits_impl<__wrap_iter<Iptcdatum *>, true>__iterator_traits_impl<__wrap_iter<Iptcdatum *>, true> &const __iterator_traits_impl<__wrap_iter<Iptcdatum *>, true>const __iterator_traits_impl<__wrap_iter<Iptcdatum *>, true> &ConstSliceBase<PtrSliceStorage, unsigned char *const>ConstSliceBase<PtrSliceStorage, unsigned char *const> &const ConstSliceBase<PtrSliceStorage, unsigned char *const> &ConstSliceBase<PtrSliceStorage, unsigned char *const> *__unwrap_iter_impl<__wrap_iter<Iptcdatum *>, true>__unwrap_iter_impl<__wrap_iter<Iptcdatum *>, true> &const __unwrap_iter_impl<__wrap_iter<Iptcdatum *>, true>const __unwrap_iter_impl<__wrap_iter<Iptcdatum *>, true> &ConstSliceBase<PtrSliceStorage, const unsigned char *>ConstSliceBase<PtrSliceStorage, const unsigned char *> &const ConstSliceBase<PtrSliceStorage, const unsigned char *> &reverse_iterator<__wrap_iter<Iptcdatum *>> &const reverse_iterator<__wrap_iter<Iptcdatum *>>const reverse_iterator<__wrap_iter<Iptcdatum *>> &reverse_iterator<__wrap_iter<Iptcdatum *>> *ConstSliceBase<ContainerStorage, const Slice<unsigned char *>>ConstSliceBase<ContainerStorage, const Slice<unsigned char *>> &const ConstSliceBase<ContainerStorage, const Slice<unsigned char *>> &return_temporary_bufferunique_ptr<Iptcdatum, __return_temporary_buffer> *__stable_sort__l2__h2__buff__buff_sizeconst __return_temporary_bufferget_temporary_bufferptrdiff_t(0)~ptrdiff_t(0)ptrdiff_t(1)sizeof(ptrdiff_t)sizeof(ptrdiff_t) * __CHAR_BIT__sizeof(ptrdiff_t) * __CHAR_BIT__ - 1(sizeof(ptrdiff_t) * __CHAR_BIT__ - 1)-9223372036854775808ptrdiff_t(ptrdiff_t(1) << (sizeof(ptrdiff_t) * __CHAR_BIT__ - 1))~ptrdiff_t(0) ^
                           ptrdiff_t(ptrdiff_t(1) << (sizeof(ptrdiff_t) * __CHAR_BIT__ - 1))(~ptrdiff_t(0) ^
                           ptrdiff_t(ptrdiff_t(1) << (sizeof(ptrdiff_t) * __CHAR_BIT__ - 1)))384307168202282325(~ptrdiff_t(0) ^
                           ptrdiff_t(ptrdiff_t(1) << (sizeof(ptrdiff_t) * __CHAR_BIT__ - 1)))
                           / sizeof(_Tp)const ConstSliceBase<PtrSliceStorage, const unsigned char *> *ConstSliceBase<PtrSliceStorage, const unsigned char *> *const ConstSliceBase<PtrSliceStorage, unsigned char *const> *const ConstSliceBase<ContainerStorage, const Slice<unsigned char *>> *ConstSliceBase<ContainerStorage, const Slice<unsigned char *>> *const Iptcdatum &&Iptcdatum &&__split_buffer<Iptcdatum, allocator<Iptcdatum> &> &remove_reference<const Iptcdatum &>remove_reference<const Iptcdatum &> &const remove_reference<const Iptcdatum &>const remove_reference<const Iptcdatum &> &remove_reference<const Iptcdatum>remove_reference<const Iptcdatum> &const remove_reference<const Iptcdatum>const remove_reference<const Iptcdatum> &__split_buffer<Iptcdatum, allocator<Iptcdatum> &>__unwrap_iter_impl<Iptcdatum *, true>__unwrap_iter_impl<Iptcdatum *, true> &const __unwrap_iter_impl<Iptcdatum *, true>const __unwrap_iter_impl<Iptcdatum *, true> &unique_ptr<Iptcdatum, __destruct_n &>unique_ptr<Iptcdatum, __destruct_n &> &ContainerStorage<const Slice<unsigned char *>>ContainerStorage<const Slice<unsigned char *>> &const ContainerStorage<const Slice<unsigned char *>>const ContainerStorage<const Slice<unsigned char *>> &iterator<random_access_iterator_tag, Iptcdatum, long, Iptcdatum *, Iptcdatum &>iterator<random_access_iterator_tag, Iptcdatum, long, Iptcdatum *, Iptcdatum &> &const iterator<random_access_iterator_tag, Iptcdatum, long, Iptcdatum *, Iptcdatum &>const iterator<random_access_iterator_tag, Iptcdatum, long, Iptcdatum *, Iptcdatum &> &PtrSliceStorage<const unsigned char *>PtrSliceStorage<const unsigned char *> &const PtrSliceStorage<const unsigned char *>const PtrSliceStorage<const unsigned char *> &PtrSliceStorage<unsigned char *const>PtrSliceStorage<unsigned char *const> &const PtrSliceStorage<unsigned char *const>const PtrSliceStorage<unsigned char *const> &__compressed_pair<Iptcdatum *, __return_temporary_buffer>__compressed_pair<Iptcdatum *, __return_temporary_buffer> &const __compressed_pair<Iptcdatum *, __return_temporary_buffer>const __compressed_pair<Iptcdatum *, __return_temporary_buffer> &__pointer<Iptcdatum, __return_temporary_buffer, __return_temporary_buffer, false>__pointer<Iptcdatum, __return_temporary_buffer, __return_temporary_buffer, false> &const __pointer<Iptcdatum, __return_temporary_buffer, __return_temporary_buffer, false>const __pointer<Iptcdatum, __return_temporary_buffer, __return_temporary_buffer, false> &__split_buffer<Iptcdatum, allocator<Iptcdatum> &> *const __split_buffer<Iptcdatum, allocator<Iptcdatum> &>const __split_buffer<Iptcdatum, allocator<Iptcdatum> &> *const ContainerStorage<const Slice<unsigned char *>> *ContainerStorage<const Slice<unsigned char *>> *const unsigned char *&const PtrSliceStorage<const unsigned char *> *PtrSliceStorage<const unsigned char *> *__compressed_pair<Iptcdatum *, __return_temporary_buffer> *__return_temporary_buffer &__inplace_merge__m1__len11__len21__len12__len22__merge_move_assign__stable_sort_moveremove_reference<Iptcdatum &>remove_reference<Iptcdatum &> &const remove_reference<Iptcdatum &>const remove_reference<Iptcdatum &> &remove_cv<const unsigned char>remove_cv<const unsigned char> &const remove_cv<const unsigned char>const remove_cv<const unsigned char> &__compressed_pair<Iptcdatum *, __destruct_n &>__compressed_pair<Iptcdatum *, __destruct_n &> &const __compressed_pair<Iptcdatum *, __destruct_n &>const __compressed_pair<Iptcdatum *, __destruct_n &> &__pointer<Iptcdatum, __destruct_n &, __destruct_n, false>__pointer<Iptcdatum, __destruct_n &, __destruct_n, false> &const __pointer<Iptcdatum, __destruct_n &, __destruct_n, false>const __pointer<Iptcdatum, __destruct_n &, __destruct_n, false> &__compressed_pair<Iptcdatum *, allocator<Iptcdatum> &>__compressed_pair<Iptcdatum *, allocator<Iptcdatum> &> &const __compressed_pair<Iptcdatum *, allocator<Iptcdatum> &>const __compressed_pair<Iptcdatum *, allocator<Iptcdatum> &> &remove_reference<allocator<Iptcdatum> &>remove_reference<allocator<Iptcdatum> &> &const remove_reference<allocator<Iptcdatum> &>const remove_reference<allocator<Iptcdatum> &> &add_lvalue_reference<allocator<Iptcdatum> &>add_lvalue_reference<allocator<Iptcdatum> &> &const add_lvalue_reference<allocator<Iptcdatum> &>const add_lvalue_reference<allocator<Iptcdatum> &> &__merge_move_constructunique_ptr<Iptcdatum, __destruct_n &> *__buffered_inplace_merge_RBi_Rv_InvertedPtrSliceStorage<unsigned char *const> *remove_reference<Iptcdatum *&>remove_reference<Iptcdatum *&> &const remove_reference<Iptcdatum *&>const remove_reference<Iptcdatum *&> &__invert<..(*&)(..)>__invert<..(*&)(..)> &const __invert<..(*&)(..)>const __invert<..(*&)(..)> &__invert__invert<..(*&)(..)> *__p_reverse_iterator<Iptcdatum *>reverse_iterator<Iptcdatum *> &const reverse_iterator<Iptcdatum *>const reverse_iterator<Iptcdatum *> &reverse_iterator<Iptcdatum *> *__add_lvalue_reference_impl<allocator<Iptcdatum> &, true>__add_lvalue_reference_impl<allocator<Iptcdatum> &, true> &const __add_lvalue_reference_impl<allocator<Iptcdatum> &, true>const __add_lvalue_reference_impl<allocator<Iptcdatum> &, true> &__compressed_pair_elem<allocator<Iptcdatum> &, 1, false>__compressed_pair_elem<allocator<Iptcdatum> &, 1, false> &const __compressed_pair_elem<allocator<Iptcdatum> &, 1, false>const __compressed_pair_elem<allocator<Iptcdatum> &, 1, false> &remove_const<const unsigned char>remove_const<const unsigned char> &const remove_const<const unsigned char>const remove_const<const unsigned char> &__compressed_pair<Iptcdatum *, allocator<Iptcdatum> &> *__half_inplace_mergeis_trivially_move_assignable<value_type>::value__compressed_pair<Iptcdatum *, __destruct_n &> *enable_if<true, __wrap_iter<Iptcdatum *>>enable_if<true, __wrap_iter<Iptcdatum *>> &const enable_if<true, __wrap_iter<Iptcdatum *>>const enable_if<true, __wrap_iter<Iptcdatum *>> &__is_referenceable<allocator<Iptcdatum> &>__is_referenceable<allocator<Iptcdatum> &> &const __is_referenceable<allocator<Iptcdatum> &>const __is_referenceable<allocator<Iptcdatum> &> &__rotate_forward__rotate_gcd__p1__rotate_right__fp1__rotate_leftconst reverse_iterator<Iptcdatum *> *const reverse_iterator<__wrap_iter<Iptcdatum *>> *reverse_iterator<Iptcdatum *> &&reverse_iterator<__wrap_iter<Iptcdatum *>> &&const allocator<Iptcdatum> *768614336404564650const __compressed_pair<Iptcdatum *, allocator<Iptcdatum> &> *__compressed_pair_elem<allocator<Iptcdatum> &, 1, false> *__unwrap_iter_impl<reverse_iterator<__wrap_iter<Iptcdatum *>>, false>__unwrap_iter_impl<reverse_iterator<__wrap_iter<Iptcdatum *>>, false> &const __unwrap_iter_impl<reverse_iterator<__wrap_iter<Iptcdatum *>>, false>const __unwrap_iter_impl<reverse_iterator<__wrap_iter<Iptcdatum *>>, false> &__unwrap_iter_impl<reverse_iterator<Iptcdatum *>, false>__unwrap_iter_impl<reverse_iterator<Iptcdatum *>, false> &const __unwrap_iter_impl<reverse_iterator<Iptcdatum *>, false>const __unwrap_iter_impl<reverse_iterator<Iptcdatum *>, false> &const __compressed_pair_elem<allocator<Iptcdatum>, 1, true> *__n <= 0 || __is_cpp17_bidirectional_iterator<_InputIter>::value"Attempt to prev(it, n) with a positive n on a non-bidirectional iterator"/Users/owura/Repos/codeql_eval/proj_repos/Exiv2-exiv2-pull-962-commits-e925bc5addd881543fa503470c8a859e112cca62/exiv2/src/jp2image.cppJp2UuidBox &const Jp2UuidBoxconst Jp2UuidBox &Jp2ImageHeaderBox &const Jp2ImageHeaderBoxconst Jp2ImageHeaderBox &Jp2BoxHeader &const Jp2BoxHeaderconst Jp2BoxHeader & 12byte[12]unsigned char[12]const unsigned char[12]-12Jp2Image *toAsciibBigEndianisBigEndianlfoutputoutlensizeof(Jp2BoxHeader)inlenJp2BoxHeader *pBoxsizeof (Jp2BoxHeader)bWroteColorpSubBoxsubBoxnewBoxnewlen1668246642kJp2BoxTypeColorHeader       uuid"\x01\x00\x00\x00\x00\x00\x10\x00\x00\x05\x1cuuid"psizesizeof(newBox) x02  "\0x02\x00\x00"1785737832kJp2BoxTypeJp2HeaderboxboxDataSizeboxUUIDtypebheaderBufbufReadboxBufnewBufrawExifboxData8 + 161970628964kJp2BoxTypeUuidbLFoutBufconst unsigned char[17]unsigned char[17]Failed to encode XMP metadata."Failed to encode XMP metadata."const Jp2Image *image/jp2"image/jp2"JP2"JP2"bRecursivebICCbXMPbIPTCEraseSTRUCTURE OF JPEG2000 FILE: "STRUCTURE OF JPEG2000 FILE: " address |   length | box       | data" address |   length | box       | data"uuiduint8_t[16]1785737827kJp2BoxTypeClosesizeof(box)%8ld | %8ld | "%8ld | %8ld | "      | "      | "sizeof(subBox)%8ld | %8ld |  sub:"%8ld | %8ld |  sub:"30liccLength | pad:" | pad:" | iccLength:" | iccLength:"Jp2UuidBox *sizeof(uuid)bIsExifuint8_t *bIsIPTCbIsXMPbUnknownrawDataExif: "Exif: "IPTC: "IPTC: "XMP : "XMP : "????: "????: "JPEG-2000"JPEG-2000"ihdrstatic_cast<uint32_t>(8)icc1768449138kJp2BoxTypeImageHeaderJp2ImageHeaderBox *sizeof(ihdr)Exiv2::BasicIo::cursizeof(box) + sizeof(uuid)(sizeof(box) + sizeof(uuid))exifHeaderconst byte[6]0x450x780x690x66(long)sizeof(exifHeader)sizeof(exifHeader)Reading non-standard UUID-EXIF_bad box in "Reading non-standard UUID-EXIF_bad box in "Failed to decode Exif metadata."Failed to decode Exif metadata."Failed to decode IPTC metadata."Failed to decode IPTC metadata."(uint32_t)(sizeof(box) + sizeof(uuid))Removing "Removing " characters from the beginning of the XMP packet" characters from the beginning of the XMP packet"Failed to decode XMP metadata."Failed to decode XMP metadata."const unsigned char[249]unsigned char[249]sizeof(Jp2Blank)Jp2UuidBoxJp2ImageHeaderBoxJp2BoxHeadercompressionTypeProfileintellectualPropertyFlagcolorspaceIsUnknowncompressionTypebitsPerComponentcomponentCountconst unsigned char[]Jp2Blank0x6a0x500x0d0x0aJp2SignaturezBq"\xbe\x7a\xcf\xcb\x97\xa9\x42\xe8\x9c\x71\x99\x94\x91\xe3\xaf\xac"kJp2UuidXmp3G#8"\x33\xc7\xa4\xd2\xb8\x1d\x47\x23\xa0\xba\xf1\xa3\xe0\x97\xad\x38"kJp2UuidIptcJpgTiffExif->JP2"JpgTiffExif->JP2"kJp2UuidExif0x6a7032630x757569640x636f6c720x696864720x6a703268JP2_JP20x6a703220JP2_BPCC0x62706363JP2_DTBL0x6474626cJP2_CDEF0x63646566JP2_CMAP0x636d6170JP2_PCLR0x70636c72JP2_URL0x75726c20JP2_JP2CJP2_COLRJP2_IHDRJP2_JP2HJP2_FTYP0x66747970JP2_JP0x6a502020clang diagnostic ignored "-Wcast-align"// Jp2Image::doWriteMetadata// Update Xmp data to a new UUID box// Update Iptc data to a new UUID box// Update Exif data to a new UUID box// Write all updated metadata here, just after JP2Header.// Extract box data.// Copy header.// Box header (8 bytes) + box data.// Read whole box : Box header + Box data (not fixed size - can be null).// FIXME. Special case. the real box size is given in another place.// Decode box header.// Read chunk header.// generated by a zero size data read.// FIXME: Andreas, why the loop do not stop when EOF is taken from _io. The loop go out by an exception// Box header : 4 bytes (data size) + 4 bytes (box type).// Write JPEG2000 Signature.// Jp2Image::encodeJp2Header// allocate the correct number of bytes, copy the data and update the box header// copy data.  pointer could be into a memory mapped file which we will decode!// how many bytes have we read from boxBuf?// now many bytes have we written to output?// allocate sufficient space// ignore cast align errors.  dataBuf.pData_ is allocated by malloc() and 4 (or 8 byte aligned).// Jp2Image::writeMetadata// JpegBase::printStructure// Move to the next box.// don't know why there are 3 padding bytes// don't read beyond the box!// Jp2Image::readMetadata// If found it, store only these data at from this place.// #1242  Forgive having Exif\0\0 in rawData.pData_// Find the position of Exif header in bytes array.// size_ is at least 8 and pad = 3// subtracting pad from data.size_ is safe:// data_length makes no sense if it is larger than the rest of the file// 3 padding bytes 2 0 0// Jp2Image::setComment// Jp2Image::Jp2Image// See section B.1.1 (JPEG 2000 Signature box) of JPEG-2000 specification// See http://www.adobe.com/devnet/xmp/pdfs/xmp_specification.pdf for information about embedding XMP data in JPEG-2000 files// See http://www.jpeg.org/public/wg1n2600.doc for information about embedding IPTC-NAA data in JPEG-2000 files// JPEG-2000 UUIDs for embedded metadata/**< UUID list box *//* #define JP2_ULST 0x756c7374 *//**< UUID info box (super-box) *//* #define JP2_UINF 0x75696e66 *//**< UUID box *//* #define JP2_UUID 0x75756994 *//**< XML box *//* #define JP2_XML  0x786d6c20 *//**< Intellectual property box *//* #define JP2_JP2I 0x6a703269 *//**< Resolution box (super-box) *//* #define JP2_RES 0x72657320 *//* For the future *//**< File type fields *//**< Bits per component box *//**< Data Reference box *//**< Channel Definition box *//**< Component Mapping box *//**< Palette box *//**< Data entry URL box *//**< Contiguous codestream box *//**< Colour specification box *//**< Image header box *//**< JP2 header box (super-box) *//**< File type box *//**< JPEG 2000 signature box *//*#define JPIP_JPIP 0x6a706970*/// from openjpeg-2.1.2/src/lib/openjp2/jp2.h// 'jp2c'// 'uuid'// 'colr'// 'ihdr'// 'jp2h'// JPEG-2000 box types__less<long, long>__less<long, long> &const __less<long, long>const __less<long, long> &const __less<long, long> *__less<long, long> */Users/owura/Repos/codeql_eval/proj_repos/Exiv2-exiv2-pull-962-commits-e925bc5addd881543fa503470c8a859e112cca62/exiv2/src/fff.h_fff_header_t &const _fff_header_tconst _fff_header_t &_bidata_t &const _bidata_tconst _bidata_t &EXTENDED_IMAGEINFO_T &const EXTENDED_IMAGEINFO_Tconst EXTENDED_IMAGEINFO_T &DETECTOR_PARAM_T &const DETECTOR_PARAM_Tconst DETECTOR_PARAM_T &TEMPSENSOR_DATA_T &const TEMPSENSOR_DATA_Tconst TEMPSENSOR_DATA_T &_adjust_par_t &const _adjust_par_tconst _adjust_par_t &TEMP_CALIB_T &const TEMP_CALIB_Tconst TEMP_CALIB_T &OBJECT_PAR_T &const OBJECT_PAR_Tconst OBJECT_PAR_T &tagFLIRFILEINDEX &const tagFLIRFILEINDEXconst tagFLIRFILEINDEX &_pres_par_t &const _pres_par_tconst _pres_par_t &DISTR_DATA_T &const DISTR_DATA_Tconst DISTR_DATA_T &IMAGEINFO_T &const IMAGEINFO_Tconst IMAGEINFO_T &_geometric_info_t &const _geometric_info_tconst _geometric_info_t &tagFLIRFILEHEAD &const tagFLIRFILEHEADconst tagFLIRFILEHEAD &_fpgaheader_t &const _fpgaheader_tconst _fpgaheader_t &FFF_FILE_HEADER_fff_header_tBI_DATA_T_bidata_tEXTENDED_IMAGEINFO_TDETECTOR_PARAM_TTEMPSENSOR_DATA_TADJUST_PAR_T_adjust_par_tTEMP_CALIB_TOBJECT_PAR_TFLIRFILEINDEXtagFLIRFILEINDEXPRES_PAR_T_pres_par_tDISTR_DATA_TIMAGEINFO_TGEOMETRIC_INFO_T_geometric_info_tFLIRFILEHEADtagFLIRFILEHEADFFF_SubID_defaultFFF_Pixels_BEFFF_Pixels_LEFFF_Pixels_PNGTAG_MAIN_TFFF_TAGID_FREEFFF_TAGID_PixelsFFF_TAGID_GainMapFFF_TAGID_OffsMapFFF_TAGID_DeadMapFFF_TAGID_GainDeadMapFFF_TAGID_CoarseMapFFF_TAGID_ImageMapFFF_TAGID_SubFlirFileHead0x1eFFF_general_highFFF_TAGID_BasicDataFFF_TAGID_MeasureFFF_TAGID_ColorPalFFF_TAGID_TextCommentFFF_TAGID_VoiceCommentFFF_TAGID_matrix_highFFF_TAGID_Boston_reservedFFF_TAGID_Boston_reserved_high0x5fFFF_highnumFPGA_HEADER_fpgaheader_tFFF_HDR_SWAP_PATTERNbtagitagExtendedImageInfoDistributionDataImageInfoDisplayParametersPresentParametersAdjustParameterschar[564]CalibInfoCalibParametersObjectParametersGeometricInfoDETECTOR_PARAM_T[20]detectorParsTEMPSENSOR_DATA_T[20]tsDataSYSIMG_NAMELENpzDPNamefDatacaptureMilliTimecaptureTimepzTSNamefTSTemplong[9]Reserved2ipixOverflowipixUnderflownormGainnormOffsetReserved4tminSaturatedtmaxSaturatedtminWarntmaxWarntminCliptmaxCliptmintmaxlong[3]Reserved3Xbeta2beta1alpha2alpha1long[2]Reserved1long[4]relHumestAtmTransmextOptTransmextOptTempatmTempambTempobjectDistanceemissivitydwChecksumdwObjectNrdwParentdwDataSizedwDataPtrdwIndexIDdwVersionwSubTypewMainTypespanreserved2imageMilliFreqerrStatusPixStreamDataLinetypePixStreamCtrlDataimageFreqStripeStartStripeHeightfocusDistancevisualImageregulMethodMaskcurGlobalGaincurGlobalOffsetdistrRecalleddistrLiveimgNamelong[5]long[20]short[5]manipFactorsmanipulTypetrigCountreserved1trigFlagstrigHittrigInfoTypefloat[4]fTSTempExtfloat[7]focusPosswReserved1timeZoneBiasimageMilliTimeimageTimestripeFieldsminMeasRadiusframeCtrupSamplingdetectorIDdetectorDeeplastValidYfirstValidYlastValidXfirstValidXupperLeftYupperLeftXpixelSizeunsigned long[2]unsigned short[7]usSpareusSwapPatterndwNextIDdwNumUsedIndexdwIndexOffszOriginszFormatIDframe_cnt_LSBframe_cnt_MSBdp2_trig_statedp1_trig_statedp2_line_ts_LSBdp2_line_ts_MSBdp2_frame_tsdp1_line_ts_LSBdp1_line_ts_MSBdp1_frame_tsdp2_trig_typedp1_trig_typeIMAGEPIXELREV100LBASICDATAREVIMGSMSK_BMP_RECALLIMGSMSK_LSLOCKEDIMGSMSK_NONLINEARIMGSMSK_ILL_LENSIMGSMSK_INVALIDregulationOnFPGA_TRIG_STATE_ASSERTEDFPGA_TRIG_STATE_DEASSERTEDFPGA_TRIG_TYPE_MARK_DISABLEFPGA_TRIG_TYPE_MARK_ENABLEFPGA_TRIG_TYPE_MARK_STOPFPGA_TRIG_TYPE_MARK_STARTFPGA_TRIG_TYPE_MARKFFF_EXT"FFF"FILE_FORMAT_VERSIONFLIR_FILE_FORMAT0x46464600FFF_Hpack(push,1)/*---------------------------------------------------------------------*//* #endif for fff.h include                                            */// 32 bytes//!< sizeof struct == 960 bytes//!     dependent//!     used bias, offsets. Usage is camera//!< Currently used detector parameters like//!< Temp sensor data/**
    Extended image info (more tempsensor and detector data)
 *///!< sizeof struct == 20 bytes/** Detector parameter struct *///!< sizeof struct == 28 bytes//!< TS updated; Milliseconds since last second//!< TS updated; time in seconds since 1970-01-01 00:00//!< Converted to Kelvin/** Temp sensor data struct *//* sizeof struct == 48 bytes *//* Image pixel overflow limit *//* Image pixel underflow limit *//* Temperature compensation gain
                                         (globalGain) *//* Temperature compensation offset
                                         (globalOffset) *//*
  Adjust parameters
  -----------------
*///!< sizeof struct == 132 bytes//!<   over/underflow.//!<   LUT handler should look at ipix//!<   by imgsrc from tmin/maxSaturated.//!<   ipix over/under flow should be calculated//!<   (see also ADJUST_PAR_T:ipixOverflow).//!< Lower temp limit [K] for saturation//!<   should be presented with overflow color//!< Upper temp limit [K] over which pixels//!<   calibration soon will become invalid//!< Lower temp limit [K] under which the//!< Upper temp limit [K] over which the//!<   calibration becomes invalid//!<   current temp range//!< Lower temp limit [K] when calibrated for//!< Upper temp limit [K] when calibrated for/* Scaling factor for attenuation. *//* Attenuation for water vapor *//* Attenuation for atmosphere without water vapor *//* Attenuation for atmosphere without water vapor. *///!< Calibration constant F//!< Calibration constant B//!< Calibration constant R//!< sizeof struct == 48 bytes//!< For future use - should be set to 0//!< relative humidity//!< 0 - 1: should be set = 0.0 for basic S/W//!< 0 - 1: should be set = 1.0 for basic S/W/**< degrees Kelvin
                                      - should be set = ambTemp for basic S/W *//**< degrees Kelvin
                                      - should be set == ambTemp for basic S/W *///!< degrees Kelvin//!< Meters//!< 0 - 1/**
 *  Object parameters
 *
 *//**< Data checksum          4  32 bytes

        dwChecksum is a checksum of the tag data block. It may be
        set to 0 when not used. The algorithm is CRC32 with the
        Ethernet polynom. *//**< This object nr         4  28
                              may be set to 0 when not used      *//**< Parentnr               4  24
                              may be set to 0 when not used      *//**< Size of data           4  20       *//**< Pointer to data        4  16       *//**< Index ID               4  12       *//**< Version for data       4   8       *//**< Sub type of index      2   4       *//**< Main type of index     2   2
                              Should be one of TAG_MAIN_T        *//**
 *  FFF tag index
 *//* Span as normalized pixel value (apix) *//* Level as normalized pixel value (apix), Level is defined as middle of
				                    span (in pixel units) *///!< sizeof struct == 64 bytes//!< For future use//!< Image frequency, milliHz part of imageFreq//!< bit field, mask definitions above// Bit set means that a CSI bmp image is recalled. (Lut shall be updated even if image is non-measurable)// Bit set means that (live) image should be locked for level/span/distr updates, but not palette changes// Bit set means that (live) image is nonlinear (and therefore non-measurable).// Measurement functions etc should be invalidated.// Bit set means that image is non-measurable. Possibly because of a ongoing NUC.//!    PixStreamCtrlData if any//!< At which line to find//!    other types TBD//!< 0 = no such data,//!    image frequency in Hz//!< Image frequency, defines the nominal//!< Striping start line if striped//!< 0 = not striped//!    NOT calculated by image source//!    0 means not defined.//!< focusDistance in meters.//!  FALSE (0) for IR image//!< TRUE (1) for TV (visual)//!< Method used for o/g calculation//!  updated continously when live only//!< globalOffset/Gain to generate LUT from//!       FALSE//!< TRUE also implies that distrLive ==//!       recalled. FALSE (0) otherwise.//!< TRUE (1) when image distribution is//!	'LIVE'. FALSE (0) otherwise/* (4 longs) *//** Framegrab independent distribution data *//**
   Distribution information
*///!< sizeof struct == 184 bytes//!    dependent//!    used bias, offsets. Usage is camera/** Detecor settings - camera type dependent *///!< Used average factors//!< defines how to interpret manipFactors//!< trig counter//!< trig flags, type dependent//!    reference//!< hit count - microsecs from trig//!< 0 = No info, 1 = THV 900 type info//!< Lens temp sensors et.c. Converted to Kelvin//!< Temp sensor values converted to Kelvin//!< Focus position as counter value//!< filler == 0//!    UTC = local time + bias//!< Time zone bias in minutes//!< Milliseconds since last second//!< Time in seconds since 1970-01-01 00:00 (UTC)//!< sizeof struct == 32 bytes//!< Number of striped fields this image consists of//!< See AppCore/core_imgflow/imgflow_state.hpp for reference//!< Image number from frame buffer/**  Type of upsampling from Detector to IR pixels.
                                       Defined in AppCore/core_imgflow/imgflow_state.hpp *//** Type of detector to be able to differ
                                      between technologies if necessary.
                                      Defined in AppCore/core_imgflow/imgflow_state.hpp *///!< Number of bits from detector A/D/*@}*///!< Normally imageHeight - 1//!< Normally 0//!< Normally imageWidth - 1/*@{*//** @name Valid pixels
                                      The following four number identifies the
				      valid pixels area within the image.
				      Sometimes the first row and column only
				      contains calibration pixels that should not
				      be considered as real pixels *//** @name Upper left coordinates
                                      X and Y coordinates for upper left corner
                                      relative original in case this image is a
                                      cutout, normally 0 *///!< Image height in pixels//!< Image width in pixels/** Size of one pixel in bytes.
                                      Normal size is 2 bytes (16 bit pixels)
                                      or 3 (for colorized YCbCr pixels) *//* Head & index checksum  4  64 bytes *//* reserved               8  60       *//* Spare                 14  52       *//* Swap pattern (0=MSBF)  2  38       *//* Next free index ID     4  36       *//* Number of indexes      4  32       *//* Pointer to indexes     4  28       *//* File format version    4  24       *//* File origin           16  20       *//* Fileformat ID 'FFF\0'  4   4       *//* When subtype isn't used, fill subtype with FFF_SubID_default *//* When appropriate, add subID enums for other TAG_MAIN_T too *//* PNG compressed pixel data block (BE or LE) *//* Little endian pixel data block *//* Big endian pixel data block *//* Sub Tags for FFF_TAGID_Pixels *//* Guarantee 2 bytes enum *//* FLIR Boston reserved TAG number series *//* reserve space for other system
                                           image blocks *//* FLIR TAGs *//* Reserve space for other general
                                           tags *//* Marks unused tag descriptor *//* General tags */// main types// Digital port 2, trig state// Digital port 1, trig state// Digital port 2, line time stamp (LSB)// Digital port 2, line time stamp (MSB)// Digital port 2, frame time stamp// Digital port 1, line time stamp (LSB)// Digital port 1, line time stamp (MSB)// Digital port 1, frame time stamp// Digital port 2, trig type// Digital port 1, trig type// Disable image flow// Enable image flow// Bit mask for trig types// Default file name extension// 1.00// FFF\0/*=====================================================================*//***********************************************************************
 *
 * Description of file:
 *   Definition of FFF fileformat
 *
 ***********************************************************************//Users/owura/Repos/codeql_eval/proj_repos/Exiv2-exiv2-pull-962-commits-e925bc5addd881543fa503470c8a859e112cca62/exiv2/src/jpgimage.cpp"fff.h"byte[7]unsigned char[7]-7ExvImage *JpegBase *JpegImage::soi_JpegImage *inRange2inRangeconst ExvImage *image/x-exv"image/x-exv"const byte[9]unsigned char[9]sizeof(blank_)const JpegImage *const byte[251]unsigned char[251]const JpegBase *bufMinSizeinsertPoscomPosskipApp1ExifskipApp1XmpfoundCompletePsDatafoundIccDataskipApp13Ps3skipApp2IccskipCompsBlobmarkerpsDatalo1hi1lo2hi2lohibyte[64]unsigned char[64]exifSizeXmpParser::useCompactFormat | XmpParser::omitAllFormattingXMP"XMP"chunk_size256 * 25665496256 * 256 - 40chunksIccProfile"IccProfile"chunk2 + 14newPsDatamaxChunkSize655190xffff - 16chunkStartchunkEndchunkSizewrittenSizeconst __wrap_iter<int *>const __wrap_iter<int *> &__wrap_iter<int *> &readSizemdExif | mdIptc | mdXmp | mdCommentiptcDataSegsstring[256]basic_string<char, char_traits<char>, allocator<char>>[256]nmbool[256]mHasLengthbExtXMP0xd8SOI"SOI"0xd9EOI"EOI"0xdaSOS"SOS"0xdbDQT"DQT"0xddDRI"DRI"COM"COM"0xc4DHT"DHT"MNAPP%d"APP%d"SOF%d"SOF%d"app0_ | 0x0F(app0_ | 0x0F)STRUCTURE OF JPEG FILE: "STRUCTURE OF JPEG FILE: " address | marker       |  length | data" address | marker       |  length | data"%8ld | 0xff%02x %-5s | %7d " | %7d "bFlirapp0_ + 1(app0_ + 1)FLIR"FLIR"bExifbMPFapp0_ + 2(app0_ + 2)MPF"MPF"bPSPhotoshop 3.0"Photoshop 3.0"http://ns.adobe.com/x"http://ns.adobe.com/x"xmp_from_startHasExtendedXMP"HasExtendedXMP"2 + 352 + 35 + 322 + 35 + 32 + 42 + 35 + 32 + 4 + 414 + 2(14 + 2)| "| "2 + 122 + 13const char(&)[47]char(&)[47]Buffer too small to extract chunk information."Buffer too small to extract chunk information." chunk %d/%d" chunk %d/%d"FFF  FFF start = "  FFF start = "Exiv2::BasicIo::beguint64_t[]unsigned long long[]const __wrap_iter<unsigned int *>const __wrap_iter<unsigned int *> &__wrap_iter<unsigned int *> &bOddbEvenfoundExifDatafoundXmpDataFailed to decode Exif metadata.
"Failed to decode Exif metadata.\n"2+122+132+14(2+14)icc_size14+2profileiptcBlobsizeIptcpCurFailed to decode IPTC metadata.
"Failed to decode IPTC metadata.\n"JPEG format error, rc = "JPEG format error, rc = "sizeFrontnewPos1036hrdpsSizePhotoshop IRB data is not padded to even size
"Photoshop IRB data is not padded to even size\n"strlen(irbId_[i]) == 4sizeof irbId_(sizeof irbId_)sizeof *irbId_(sizeof *irbId_)(sizeof irbId_) / (sizeof *irbId_)'2'ICC_PROFILE "ICC_PROFILE\0"http://ns.adobe.com/xap/1.0/ "http://ns.adobe.com/xap/1.0/\0"JFIF "JFIF\0"Exif  "Exif\0\0"0xcf0xce0xcd0xcb0xca0xc90xc70xc60xc50xc30xc20xc10xed0xe20xe10x040c0x04048BIM"8BIM"AgHg"AgHg"DCSR"DCSR"PHUT"PHUT"Photoshop 3.0 "Photoshop 3.0\0"REPORT_MARKERif ( (option == kpsBasic||option == kpsRecursive) ) out << Internal::stringFormat("%8ld | 0xff%02x %-5s", io_->tell()-2,marker,nm[marker].c_str())ULONGUSHORT// Exv header// Jpeg header// JpegBase::doWriteMetadata// Copy rest of the Io// it avoids allocating memory for parts of the file that contain image-date.// Populate the fake data, only make sense for remoteio, httpio and sshio.// Next marker// Write COM marker, size of comment, and string// Write next chunk of the Photoshop IRB data buffer// Write APP13 marker, chunk size, and ps3Id// (chunkSize - 8) can't be also a IRB boundary// Since an IRB has minimum size 12,// Don't break at a valid IRB boundary// Determine size of next chunk// IPTC block if there is no new IPTC data to write// Set the new IPTC IRB, keeps existing IRBs but removes the// write the ICC_PROFILE header (14 bytes)// JPEG Length// write length (2 bytes).  length includes the 2 bytes for the length// JPEG Marker// write JPEG marker (2 bytes)// bytes to write// leave bytes for marker, header and padding// See comments in readMetadata() about the ICC embedding specification// Write APP2 marker, size of APP2 field, and IccProfile// Write new XMP packet// Write APP1 marker, size of APP1 field, XMP id and XMP packet// Write new Exif data buffer// Write APP1 marker, size of APP1 field, Exif id and Exif data// create "Exif images" according to the Exif standard.// Write Exif data first so that - if there is no app0 - we// images with only an eoi_ marker// Careful, this can be a meaningless number for empty// Read size and signature (ok if this hits EOF)// Segments are erased if there is no assigned metadata.// potential to change segment ordering (which is allowed).// or right after app0. This is standard in most jpegs, but has the// To simplify this a bit, new segments are inserts at either the start// or JFXX markers, as required by the JFIF specification.// existing comments; and (b) ensures that comments come after any JFIF// This (a) causes the new comment to appear after, rather than before,// We will insert the new comment marker just before SOFn.// As in jpeg-6b/wrjpgcom.c:// the first one (most jpegs only have one anyway).// Jpegs can have multiple comments, but for now only handle// Check whether psBlob is complete// Append to psBlob// Load PS data now to allow reinsertion at any point// Seek to beginning and read the current Exif data// don't bother.// to insert after it. But if app0 comes after com, app1 and app13 then// First find segments of interest. Normally app0 is first and we want// Read section marker// Write image header// JpegBase::writeMetadata// read the file 2 byte SOI// step JPG 2 byte marker// binary copy io_ to a temporary file// exiv2 -pS E.jpg// cat E1.jpg E2.jpg > E.jpg// $ dd bs=1 skip=$((49304)) count=2000000  if=ETH0138028.jpg of=E2.jpg// $ dd bs=1 skip=$((0)) count=$((13164)) if=ETH0138028.jpg of=E1.jpg// copy the data that is not iptc// figure out which blocks to copy// Read the beginning of the next segment// Skip the segment if the size is known/* cannot overflow as n is at most size - 2 */// start after the two bytes// size includes 2 for the two bytes for size!// print COM marker// restore and clean up// create a copy on write memio object with the data, then print the structure// << " index = " << pFFF->dwIndexOff << std::endl;// FLIRFILEHEAD* pFFF = (FLIRFILEHEAD*) (exif+start) ;// Hunt down the tiff using brute force// there is a header in FLIR, followed by a tiff block// is this an fff block?// copy the data to memory// allocate storage and current file position// extract Exif data block which is tiff formatted// for FLIR: http://owl.phy.queensu.ca/~phil/exiftool/TagNames/FLIR.html// for MPF: http://www.sno.phy.queensu.ca/~phil/exiftool/TagNames/MPF.html// => Read the chunk info from the DataBuf directly// null termination (and signature ends there).// We cannot extract the variables A and B from the signature string, as they are beyond the// where A & B are bytes (the variables chunk & chunks)// ICC_PROFILE\0AB// the buffer looks like this in this branch// extract the chunk information from the buffer// delete IPTC data segment from JPEG// step over header// back to buffer (after marker)// extract ICCProfile// Adobe Spec, p19// ignore this packet, we'll get on the next time around// for the moment, dumping 'on the fly' is working fine// and dumping the XMP in a post read operation similar to kpsIptcErase// we could implement out of sequence with a dictionary of sequence/offset// a robust implementation allows extended blocks to be out of sequence// the first extended block is a copy of the Standard block.// if we find HasExtendedXMP, set the flag and ignore this block// http://wwwimages.adobe.com/content/dam/Adobe/en/devnet/xmp/pdfs/XMPSpecificationPart3.pdf// extract XMP//    1787 | 0xe1 APP1  |   65460 | http://ns.adobe.com/xmp/extensio//     915 | 0xe1 APP1  |     870 | http://ns.adobe.com/xap/1.0/.<x://       2 | 0xe1 APP1  |     911 | Exif..MM.*.......%.........#....//       0 | 0xd8 SOI   |       0// address | marker     | length  | data// STRUCTURE OF JPEG FILE: test/data/exiv2-bug922.jpg// 728 rmills@rmillsmbp:~/gnu/exiv2/ttt $ exiv2 -pS test/data/exiv2-bug922.jpg// http://www.adobe.com/content/dam/Adobe/en/devnet/xmp/pdfs/XMPSpecificationPart3.pdf p75// print signature for APPn// Read size and signature// print marker bytes// Container for the signature// which markers have a length field?// 0xc0 .. 0xcf are SOFn (except 4)// 0xe0 .. 0xef are APPn// nmonic for markers// JpegBase::readMetadata// psBlob.size() > 0// Find actual IPTC data within the psBlob// while there are segments to process// Skip the remainder of the unknown segment// Skip the remainder of the segment// We hit a SOFn (start-of-frame) marker// extend existing profile// first block of profile// #1286 profile can be padded// read in profile// step header// back up to start of buffer (after marker)// Spec 7.2 Profile bytes 0-3 size// chunk/chunks are a single byte// header = "ICC_PROFILE\0" (12 bytes)// ICC1v43_2010-12.pdf header is 14 bytes// ICC profile// are simple single byte ISO-8859-1 strings.// the first one (most jpegs only have one anyway). Comments// JPEGs can have multiple comments, but for now only read//hexdump(std::cerr, psData.pData_, psData.size_);// Read the rest of the APP13 segment// Seek to beginning and read the XMP packet// Seek to beginning and read the Exif data// Exif, ICC, XMP, Comment, IPTC, SOF// Todo: this should be the return value// Markers can start with any number of 0xff// Skips potential padding between markers// Photoshop::setIptcIrb// Data is rounded to be even// Skip the IPTC IRB// Copy data up to the IPTC IRB// skip the current and all remaining IPTC blocks// Write existing stuff after record,// Data is padded to be even (but not included in size)// Write new iptc record if we have it// Write data before old record.// Safe to call with zero psData.size_// Photoshop::locateIrb// Data size is also padded to be even// Pascal string is padded to have an even size (including size byte)// Data should follow Photoshop format, if not exit// Used for error checking//       if this also makes sense for psTag != Photoshop::iptc//       the format (in particular the header). So it remains to be confirmed// Todo: Generalised from JpegBase::locateIptcData without really understanding// deprecated// start of frame 15, differential lossless, arithmetic coding// start of frame 14, progressive DCT, arithmetic coding// start of frame 13, differential sequential DCT, arithmetic coding// Start of Frame markers, differential arithmetic-coding frames// start of frame 11, lossless sequential, arithmetic coding// start of frame 10, progressive DCT, arithmetic coding// start of frame 9, extended sequential DCT, arithmetic coding// Start of Frame markers, nondifferential arithmetic-coding frames// start of frame 7, differential lossless, Huffman coding// start of frame 6, differential progressive DCT, Huffman coding// start of frame 5, differential sequential DCT, Huffman coding// Start of Frame markers, differential Huffman-coding frames// start of frame 3, lossless sequential, Huffman coding// start of frame 2, progressive DCT, Huffman coding// start of frame 1, extended sequential DCT, Huffman coding// start of frame 0, baseline DCT// Start of Frame markers, nondifferential Huffman-coding frames/*
  File:      jpgimage.cpp
 */__wrap_iter<unsigned int *> *__wrap_iter<int *> *iterator_traits<int *>iterator_traits<int *> &const iterator_traits<int *>const iterator_traits<int *> &iterator_traits<unsigned int *>iterator_traits<unsigned int *> &const iterator_traits<unsigned int *>const iterator_traits<unsigned int *> &const __wrap_iter<int *> *const __wrap_iter<unsigned int *> *remove_cv<unsigned int>remove_cv<unsigned int> &const remove_cv<unsigned int>const remove_cv<unsigned int> &remove_cv<int>remove_cv<int> &const remove_cv<int>const remove_cv<int> &SamsungMnHeader *const Casio2MnHeaderconst Casio2MnHeader *Casio2MnHeader *const SonyMnHeaderconst SonyMnHeader *SonyMnHeader *const SigmaMnHeaderconst SigmaMnHeader *SigmaMnHeader *const SamsungMnHeader *const PentaxMnHeaderconst PentaxMnHeader *PentaxMnHeader *const PentaxDngMnHeaderconst PentaxDngMnHeader *PentaxDngMnHeader *const PanasonicMnHeaderconst PanasonicMnHeader *PanasonicMnHeader *const Nikon3MnHeaderconst Nikon3MnHeader *Nikon3MnHeader *const Nikon2MnHeaderconst Nikon2MnHeader *Nikon2MnHeader *const FujiMnHeaderconst FujiMnHeader *FujiMnHeader *const Olympus2MnHeaderconst Olympus2MnHeader *Olympus2MnHeader *const OlympusMnHeaderconst OlympusMnHeader *OlympusMnHeader *const MnHeader *const TiffMnRegistry *TiffMnRegistry *TiffReader &const TiffReaderconst TiffReader &postProcessnextIdxcircularReferencesetOrigStatesetMnStateconst TiffRwStateconst TiffRwState *TiffRwState *readDataEntryBasereadTiffEntryvisitBinaryElementvisitBinaryArrayvisitIfdMakernoteEndvisitIfdMakernotevisitMnEntryvisitSubIfdvisitDirectoryvisitSizeEntryvisitImageEntryvisitDataEntryvisitEntry~TiffReaderTiffRwState &const TiffRwState &TiffDecoder &const TiffDecoderconst TiffDecoder &getObjDataconst byte *&decodeXmpdecodeIptcdecodeStdTiffEntrydecodeTiffEntry~TiffDecoderTiffCopier &const TiffCopierconst TiffCopier &TiffCopiercopyObject~TiffCopierTiffFinder &const TiffFinderconst TiffFinder &const TiffFinder *TiffFinder *findObject~TiffFinderconst TiffVisitorconst TiffVisitor &visitBinaryArrayEndvisitDirectoryEndvisitDirectoryNextconst TiffEncoderconst TiffEncoder &updateDirEntryencodeXmpencodeIptcwriteMethodconst TiffEncoder *TiffEncoder *setDirtyencodeOffsetEntryencodeTiffEntryBaseencodeSubIfdencodeSizeEntryencodeMnEntryencodeImageEntryencodeTiffEntryencodeDataEntryencodeBinaryArrayencodeBinaryElementencodeTiffComponent~TiffEncodersetGo~TiffVisitorPostListIdxSeqDirListGoEventgeTraversegeKnownMakernotepostProc_postList_idxSeq_dirList_mnState_origState_pState_pLast_baseOffset_decodedIptc_const FindDecoderFctfindDecoderFct_pPrimaryGroups_tiffComponent_writeMethod_dirty_const FindEncoderFctfindEncoderFct_origByteOrder_pSourceTree_isNewImage_del_bool[2]events_go_TIFFVISITOR_INT_HPP_// #ifndef TIFFVISITOR_INT_HPP_// class TiffReader//!< True in postProcessList()//!< List of components with deferred reading//!< Sequences for group, used for the entry's idx//!< List of IFD pointers and their groups//!< State class as set in the c'tor or by setMnState()//!< State class as set in the c'tor//!< Pointer to the state in effect (origState_ or mnState_)//!< Root element of the composite//!< Pointer to the last byte//!< Size of the buffer//!< Pointer to the memory buffer//! Return the base offset. See class TiffRwState for details//! Return the byte order./*!
          @brief Read deferred components.

          This function is called after the TIFF composite is read by passing a
          TiffReader to the accept() function of the root component. It reads
          all components for which reading was deferred during that pass.  This
          is usually done to make sure that all other components are accessible
          at the time the deferred components are processed.
         *///! Return the next idx sequence number for \em group//! Check IFD directory pointer \em start for circular reference//! Set the state to the original state as set in the constructor./*!
          @brief Set the \em state of the reader to one suitable for the Makernote.

          Uses the \em state passed in, if any, and remembers it for use during
          subsequent calls without any argument.
         *///! Read a TiffDataEntryBase from the data buffer//! Read a standard TIFF entry from the data buffer//! Read an element of a binary array from the data buffer//! Read a binary array from the data buffer//! Reset reader to its original state, undo makernote specific settings//! Read an IFD makernote from the data buffer//! Read a TIFF makernote entry from the data buffer//! Read a TIFF sub-IFD from the data buffer//! Read a TIFF directory from the data buffer//! Read a TIFF size entry from the data buffer//! Read a TIFF image entry from the data buffer//! Read a TIFF data entry from the data buffer//! Read a TIFF entry from the data buffer/*!
          @brief Constructor. The data buffer and table describing the TIFF
                           structure of the data are set in the constructor.
          @param pData     Pointer to the data buffer, starting with a TIFF header.
          @param size      Number of bytes in the data buffer.
          @param pRoot     Root element of the TIFF composite.
          @param state     State object for creation function, byte order and
                           base offset.
         *//*!
      @brief TIFF composite visitor to read the TIFF structure from a block of
             memory and build the composite from it (Visitor pattern). Used by
             TiffParser to read the TIFF data from a block of memory.
     */// TiffRwState/*!
          @brief Return the base offset.

          TIFF standard format uses byte offsets which are always relative to
          the start of the TIFF file, i.e., relative to the start of the TIFF
          image header. In this case, the base offset is 0.  However, some
          camera vendors encode their makernotes in TIFF IFDs using offsets
          relative to (somewhere near) the start of the makernote data. In this
          case, base offset added to the start of the TIFF image header points
          to the basis for such makernote offsets.
         *//*!
          @brief Return the applicable byte order. May be different for
                 the Makernote and the rest of the TIFF entries.
         *//*!
      @brief Simple state class containing relevant state information for
             the TIFF reader. This is in a separate class so that the
             reader can change state if needed (e.g., to read certain complex
             makernotes).
     */// class TiffEncoder//!< Write method used.//!< Signals if any tag is deleted or allocated//!< Camera make, determined from the tags to encode//!< Ptr to the function to find special encoding functions//!< Byteorder as set in the c'tor//!< Byteorder for encoding//!< Parsed source tree for reference//!< List of primary image groups//!< True if the TIFF image is created from scratch//!< TIFF image header//!< Indicates if Exif data entries should be deleted after encoding//!< XMP data to encode, just a reference//!< IPTC data to encode, just a reference//!< Copy of the Exif data to encode/*!
          @brief Check if the tag is an image tag of an existing image. Such
                 tags are copied from the original image and can't be modifed.

                 The condition is true if there is an existing image (as
                 opposed to a newly created TIFF image) and \em tag, \em group
                 is considered an image tag of this image - whether or not
                 it's actually present in the existing image doesn't matter.
         *//*!
          @brief Update a directory entry. This is called after all directory
                 entries are encoded. It takes care of type and count changes
                 and size shrinkage for non-intrusive writing.
         *//*!
          Encode XMP data. Adds tag Exif.Image.XMLPacket with the XMP packet.
          This method is called from the constructor.
         *//*!
          Encode IPTC data. Updates or adds tag Exif.Image.IPTCNAA, updates but
          never adds tag Exif.Image.ImageResources.
          This method is called from the constructor.
         *///! Return the write method used./*!
          @brief True if any tag was deleted or allocated in the process of
                 visiting a TIFF composite tree.
         *///! Set the dirty flag and end of traversing signal./*!
          @brief Add metadata from image to the TIFF composite.

          For each Exif metadatum, the corresponding TiffComponent is created
          if necessary and populated using encodeTiffComponent(). The add() function
          is used during intrusive writing, to create a new TIFF structure.

          @note For non-intrusive writing, the encoder is used as a visitor (by
          passing it to the accept() member of a TiffComponent). The composite
          tree is then traversed and metadata from the image is used to encode
          each existing component.
        *///! Special encoder function to encode IPTC data to an IPTCNAA or Photoshop ImageResources tag.// Todo void encodeNikonSubIfd(TiffEntryBase* object, const Exifdatum* datum);//! Special encoder function to encode SubIFD contents to Image group if it contains primary image data//! Special encoder function for an offset entry.//! Special encoder function for the base part of a TIFF entry.//! Callback encoder function for a sub-IFD entry.//! Callback encoder function for a size entry.//! Callback encoder function for a %Makernote entry.//! Callback encoder function for an image entry.//! Callback encoder function for a standard TIFF entry//! Callback encoder function for a data entry.//! Callback encoder function for a binary array.//! Callback encoder function for an element of a binary array./*!
          @brief Top level encoder function. Determines how to encode each TIFF
                 component. This function is called by the visit methods of the
                 encoder as well as the add() method.

          If no \em datum is provided, search the metadata based on tag and
          group of the \em object. This is the case if the function is called
          from a visit method.

          Then check if a special encoder function is registered for the tag,
          and if so use it to encode the \em object. Else use the callback
          encoder function at the object (which results in a double-dispatch to
          the appropriate encoding function of the encoder.

          @param object Object in the TIFF component tree to encode.
          @param datum  The corresponding metadatum with the updated value.

          @note Encoder functions may use metadata other than \em datum.
         *///! Encode an element of a binary array//! Re-encrypt binary array if necessary//! Encode a binary array//! Reset encoder to its original state, undo makernote specific settings//! Encode an IFD makernote//! Encode a TIFF makernote//! Encode a TIFF sub-IFD//! Update directory entries//! Encode a TIFF directory//! Encode a TIFF size entry//! Encode a TIFF image entry//! Encode a TIFF data entry//! Encode a TIFF entry/*!
          @brief Constructor, taking the root element of the composite to encode
                 to, the image with the metadata to encode and a function to
                 find special encoders.
         *//*!
      @brief TIFF composite visitor to encode metadata from an image to the TIFF
             tree. The metadata containers and root element of the tree are
             supplied in the constructor. Used by TiffParserWorker to encode the
             metadata into a TIFF composite.

             For non-intrusive writing, the encoder is used as a visitor (by
             passing it to the accept() member of a TiffComponent). The
             composite tree is then traversed and metadata from the image is
             used to encode each existing component.

             For intrusive writing, add() is called, which loops through the
             metadata and creates and populates corresponding TiffComponents
             as needed.
     */// class TiffDecoder//!< Indicates if IPTC has been decoded yet//!< Camera make, determined from the tags to decode//!< Ptr to the function to find special decoding functions//!< XMP metadata container//!< IPTC metadata container//!< Exif metadata container/*!
          @brief Get the data for a \em tag and \em group, either from the
                 \em object provided, if it matches or from the matching element
                 in the hierarchy.

          Populates \em pData and \em size with the result. If no matching
          element is found the function leaves both of these parameters unchanged.
        *///! Decode XMP packet from an XMLPacket tag//! Decode IPTC data from an IPTCNAA tag or Photoshop ImageResources//! Decode a standard TIFF entry//! Entry function, determines how to decode each tag//! Decode an element of a binary array//! Decode a binary array//! Decode an IFD makernote//! Decode a TIFF makernote//! Decode a TIFF sub-IFD//! Decode a TIFF directory//! Decode a TIFF size entry//! Decode a TIFF image entry//! Decode a TIFF data entry//! Decode a TIFF entry/*!
          @brief Constructor, taking metadata containers to add the metadata to,
                 the root element of the composite to decode and a FindDecoderFct
                 function to get the decoder function for each tag.
         *//*!
      @brief TIFF composite visitor to decode metadata from the TIFF tree and
             add it to an Image, which is supplied in the constructor (Visitor
             pattern). Used by TiffParser to decode the metadata from a
             TIFF composite.
     */// class TiffCopier//! Check if \em object is an image tag and if so, copy it to the target tree.//! Copy an element of a binary array if it is an image tag//! Copy a binary array if it is an image tag//! Copy an IFD makernote if it is an image tag//! Copy a TIFF makernote if it is an image tag//! Copy a TIFF sub-IFD if it is an image tag//! Copy a TIFF directory if it is an image tag//! Copy a TIFF size entry if it is an image tag//! Copy a TIFF image entry if it is an image tag//! Copy a TIFF data entry if it is an image tag//! Copy a TIFF entry if it is an image tag/*!
          @brief Constructor

          @param pRoot Pointer to the root element of the (empty) target tree.
          @param root
          @param pHeader Pointer to the TIFF header of the source image.
          @param pPrimaryGroups Pointer to the list of primary groups.
         *//*!
      @brief Copy all image tags from the source tree (the tree that is traversed) to a
             target tree, which is empty except for the root element provided in the
             constructor.
    */// class TiffFinder/*!
          @brief Return the search result. 0 if no TIFF component was found
                 for the tag and group combination.
         *///! Initialize the Finder for a new search.//! Check if \em object matches \em tag and \em group//! Find tag and group in an element of a binary array//! Find tag and group in a binary array//! Find tag and group in an IFD makernote//! Find tag and group in a TIFF makernote//! Find tag and group in a TIFF sub-IFD//! Find tag and group in a TIFF directory//! Find tag and group in a TIFF size entry//! Find tag and group in a TIFF image entry//! Find tag and group in a TIFF data entry//! Find tag and group in a TIFF entry//! Constructor, taking \em tag and \em group of the component to find./*!
      @brief Search the composite for a component with \em tag and \em group.
             Return a pointer to the component or 0, if not found. The class
             is ready for a first search after construction and can be
             re-initialized with init().
    */// class TiffVisitor//! Check if stop flag for \em event is clear, return true if it's clear.//! Operation to perform for an element of a binary array/*!
          @brief Operation to perform for a TIFF binary array, at the end
                 of the processing.
         *///! Operation to perform for a binary array//! Operation to perform after processing an IFD makernote//! Operation to perform for an IFD makernote//! Operation to perform for the makernote component//! Operation to perform for a TIFF sub-IFD/*!
          @brief Operation to perform for a TIFF directory, at the end of the
                 processing.
         *//*!
          @brief Operation to perform for a TIFF directory, after all components
                 and before the next entry is processed.
         *///! Operation to perform for a TIFF directory//! Operation to perform for a TIFF size entry//! Operation to perform for a TIFF image entry//! Operation to perform for a TIFF data entry//! Operation to perform for a TIFF entry/*!
          @brief Set the stop/go flag: true for go, false for stop.

          This mechanism is used by visitors and components to signal special
          events. Specifically, TiffFinder sets the geTraverse flag as soon as
          it finds the correct component to signal to components that the search
          should be aborted. TiffReader uses geKnownMakernote to signal problems
          reading a makernote to the TiffMnEntry component. There is an array
          of flags, one for each defined \em event, so different signals can be
          used independent of each other.
         *///! Default constructor. Initialises all stop/go flags to true.//!< Array of stop/go flags. See setGo().//!< The number of stop/go flags.// Note: If you add more events here, adjust the events_ constant too!//! Signal used by TiffReader to signal an unknown makernote.//! Signal to control traversing of the composite tree.//! Events for the stop/go flag. See setGo()./*!
      @brief Abstract base class defining the interface for TIFF composite
             visitors (Visitor pattern)

      A concrete visitor class is used as shown in the example below. Accept()
      will invoke the member function corresponding to the concrete type of each
      component in the composite.

      @code
      void visitorExample(Exiv2::TiffComponent* tiffComponent, Exiv2::TiffVisitor& visitor)
      {
          tiffComponent->accept(visitor);
      }
      @endcode
     *//*!
  @file    tiffvisitor_int.hpp
  @brief   Internal operations on a TIFF composite tree, implemented as visitor
           classes.
  @author  Andreas Huggel (ahu)
           <a href="mailto:ahuggel@gmx.net">ahuggel@gmx.net</a>
  @date    11-Apr-06, ahu: created
 */pRootDirisNewImageuuid_unparse_upperuuid_unparse_loweruuid_unparseuuid_parseconst uuid_string_tuuid_is_nulluuid_generate_timeuuid_generate_randomuuid_generateuuid_copyuuid_compareuuid_clearuuid_string_tUUID_NULLUUID_DEFINE(name,u0,u1,u2,u3,u4,u5,u6,u7,u8,u9,u10,u11,u12,u13,u14,u15)static const uuid_t name __attribute__ ((unused)) = {u0,u1,u2,u3,u4,u5,u6,u7,u8,u9,u10,u11,u12,u13,u14,u15}_UUID_STRING_T_UUID_UUID_H/* _UUID_UUID_H *//* _UUID_STRING_T *//*
 * Public include file for the UUID library
 *
 * Copyright (C) 1996, 1997, 1998 Theodore Ts'o.
 *
 * %Begin-Header%
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, and the entire permission notice in its entirety,
 *    including the disclaimer of warranties.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. The name of the author may not be used to endorse or promote
 *    products derived from this software without specific prior
 *    written permission.
 *
 * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESS OR IMPLIED
 * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
 * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE, ALL OF
 * WHICH ARE HEREBY DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR BE
 * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
 * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT
 * OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR
 * BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
 * LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE
 * USE OF THIS SOFTWARE, EVEN IF NOT ADVISED OF THE POSSIBILITY OF SUCH
 * DAMAGE.
 * %End-Header%
 *//Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX.sdk/usr/include/uuiduuuu1uu2/Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX.sdk/usr/include/pwd.hgetpwuuid_rpasswd *passwd **getpwuuiduser_from_uidsetpassentendpwentsetpwentgetpwentgetpwnam_rgetpwuid_rgetpwnamgetpwuidpasswd &const passwdconst passwd &passwdpw_expirepw_shellpw_dirpw_gecospw_classpw_changepw_gidpw_uidpw_passwdpw_name_PASSWORD_CHGNOW_PASSWORD_WARNDAYS_PASSWORD_NOEXP_PASSWORD_NOCHG_PASSWORD_NOGID_PASSWORD_NOUID_PASSWORD_LEN_PASSWORD_EFMT1_PW_KEYBYUID'3'_PW_KEYBYNUM_PW_KEYBYNAME'1'_PATH_PWD_MKDB"/usr/sbin/pwd_mkdb"_SMP_DB"spwd.db"_PATH_SMP_DB"/etc/spwd.db"_MP_DB"pwd.db"_PATH_MP_DB"/etc/pwd.db"_MASTERPASSWD"master.passwd"_PATH_MASTERPASSWD_LOCK"/etc/ptmp"_PATH_MASTERPASSWD"/etc/master.passwd"_PASSWD"passwd"_PATH_PASSWD"/etc/passwd"_PATH_PWD"/etc"_PWD_H_/* !_PWD_H_ *//* account expiration *//* default shell *//* home directory *//* Honeywell login info *//* user access class *//* password change time *//* user gid *//* user uid *//* encrypted password *//* user name *//* special day to force password
					 * change at next login *//* days to warn about expiry *//* flag for no specified expire. *//* flag for no specified change. *//* flag for no specified gid. *//* flag for no specified uid. *//* max length, not counting NULL *//* extended encryption format *//* stored by uid *//* stored by entry in the "file" *//* stored by name *//* Portions copyright (c) 2000-2011 Apple Inc. All rights reserved. *//*-
 * Copyright (c) 1989, 1993
 *	The Regents of the University of California.  All rights reserved.
 * (c) UNIX System Laboratories, Inc.
 * All or some portions of this file are derived from material licensed
 * to the University of California by American Telephone and Telegraph
 * Co. or Unix System Laboratories, Inc. and are reproduced herein with
 * the permission of UNIX System Laboratories, Inc.
 * Portions Copyright(C) 1995, Jason Downs.  All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *	This product includes software developed by the University of
 *	California, Berkeley and its contributors.
 * 4. Neither the name of the University nor the names of its contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 *
 *	@(#)pwd.h	8.2 (Berkeley) 1/21/94
 *//Users/owura/Repos/codeql_eval/proj_repos/Exiv2-exiv2-pull-962-commits-e925bc5addd881543fa503470c8a859e112cca62/exiv2/src/makernote_int.cpp<pwd.h>ncryptconst byte[256]unsigned char[256]const byte[2][256]unsigned char[2][256]xlatciconst byte(*)[256]unsigned char(*)[256]cjck0x60getExifModelfinder0x0110Exiv2::Internal::ifd0IdteDSLR-A330"DSLR-A330"DSLR-A380"DSLR-A380"const NikonArrayIdxconst NikonArrayIdx *NikonArrayIdx *nciconst NikonArrayIdx[26]NikonArrayIdx[26]const NikonArrayIdx(&)[26]NikonArrayIdx(&)[26]NA0x00a7false)serialD50"D50"0x00b7aixQVC   "QVC\0\0\0"SONY DSC    "SONY DSC \0\0\0"AOC "AOC\0"PENTAX  "PENTAX \0"507400xc634Nikon "Nikon\0"tiffHeaderOLYMPUS II"OLYMPUS\0II"homedirinifilepwsizeof(signature_)const byte[12]sizeof(signature1_) == sizeof(signature2_)const byte[10]unsigned char[10]sizeof(signature1_)const byte[18]unsigned char[18]buf_.size_ >= 10thconst byte[8]tmrconst TiffMnRegistry[25]TiffMnRegistry[25]const TiffMnRegistry(&)[25]TiffMnRegistry(&)[25]const IfdId &IfdId &tmr->newMnFct2_mnGroup = "mnGroup = "tmr->newMnFct_NikonArrayIdx &const NikonArrayIdx &NikonArrayIdxver_const NikonArrayIdx[]NikonArrayIdx[]0x00910208"0208"0209"0209"0210"0210"5291530302"02"01"01""0100"0102"0102"0103"0103"0204"0204"0205"0205"0206"0206"0207"0207"0x00980101"0101"0201"0201"0202"0202"0203"0203"0x00a8nikonArrayIdx'U''J''L'FOVEON"FOVEON"FUJI"FUJI"KONICA MINOLTA"KONICA MINOLTA"verOLYMPUS"OLYMPUS"PENTAX"PENTAX"RICOH"RICOH"SAMSUNG"SAMSUNG"CASIO"CASIO"((uint32_t)-1)!defined(_MSC_VER) && !defined(__MINGW__)CSIDL_MYMUSICCSIDL_MYVIDEOCSIDL_INTERNET_CACHECSIDL_COMMON_APPDATACSIDL_MYPICTURESCSIDL_COMMON_DOCUMENTSCSIDL_PROFILE// Exif.Image.Model/*size*//*pData*//*tag*/// Find Exif.Nikon3.SerialNumber// Find Exif.Nikon3.ShutterCount/*pRoot*/// NikonFl// NikonLd// NikonCb// Other v1.* (not encrypted)// Other v2.* (encrypted)// D300, firmware version 1.10// D300// D40// D80// NikonSi//! Nikon binary array version lookup table//!< Start of the encrypted data//!< Index into the array set//!< Size of the data//!< Version string//!< Tag number of the binary array//! Comparison operator for a key//!< Size of the data (not the version string)//!< Tag number//! Key for comparisons//! Structure for an index into the array set of complex binary arrays.// Require at least an IFD with 1 entry, but not necessarily a next pointer/* byteOrder *//* mnGroup*/// Require at least the header and an IFD with 1 entry, but without a next pointer// Require at least an IFD with 1 entry// If there is no "SONY DSC " string we assume it's a simple IFD Makernote/*mnGroup*/// Require at least the header and an IFD with 1 entry// Genuine Samsung camera:// Samsung branded Pentax camera:// Else we have a Nikon3 makernote// Nikon2 format// If the "Nikon" string is not followed by a TIFF header, we assume// If there is no "Nikon" string it must be Nikon1 format// Casio2MnHeader::write// Casio2MnHeader::read// SonyMnHeader::write// SonyMnHeader::read// SigmaMnHeader::write// SigmaMnHeader::read// SamsungMnHeader::write/*ioWrapper*/// SamsungMnHeader::read// PentaxMnHeader::write// PentaxMnHeader::read// PentaxDngMnHeader::write// PentaxDngMnHeader::read// PanasonicMnHeader::write// PanasonicMnHeader::read// Nikon3MnHeader::write// makernote IFD. The gap should be copied too.// Todo: This removes any gap between the header and// Nikon3MnHeader::read// Nikon2MnHeader::write// Nikon2MnHeader::read// FujiMnHeader::write// FujiMnHeader::read// from the header. Note that we ignore the byteOrder argument// Read offset to the IFD relative to the start of the makernote// Olympus2MnHeader::write// Olympus2MnHeader::read// OlympusMnHeader::write// OlympusMnHeader::read/*mnOffset*/// TiffMnCreator::create// Entries below are only used for lookup by group// mnGroup_ is not used//! Nikon en/decryption function//! Get the model name from tag Exif.Image.Model// Todo: Can be generalized further - get any tag as a string/long/.../* older SDKs not have these *//*
  File:      makernote.cpp
  Author(s): Andreas Huggel (ahu) <ahuggel@gmx.net>
  History:   11-Apr-06, ahu: created
 */map<const unsigned char *, IfdId, less<const unsigned char *>, allocator<pair<const unsigned char *const, IfdId>>>less<const unsigned char *> &allocator<pair<const unsigned char *const, IfdId>> &__tree_node<__value_type<const unsigned char *, IfdId>, void *> *pair<const unsigned char *const, IfdId> *pair<const unsigned char *const, IfdId> &map<unsigned short, int, less<unsigned short>, allocator<pair<const unsigned short, int>>>less<unsigned short> &allocator<pair<const unsigned short, int>> &__tree_node<__value_type<unsigned short, int>, void *> *pair<const unsigned short, int> *pair<const unsigned short, int> &allocator<__value_type<const unsigned char *, IfdId>>allocator<__value_type<const unsigned char *, IfdId>> &const allocator<__value_type<const unsigned char *, IfdId>>const allocator<__value_type<const unsigned char *, IfdId>> &const __value_type<const unsigned char *, IfdId>const __value_type<const unsigned char *, IfdId> &__value_type<const unsigned char *, IfdId> &const __value_type<const unsigned char *, IfdId> *__value_type<const unsigned char *, IfdId> *__allocator_traits_rebind<allocator<pair<const unsigned char *const, IfdId>>, __value_type<const unsigned char *, IfdId>, true>__allocator_traits_rebind<allocator<pair<const unsigned char *const, IfdId>>, __value_type<const unsigned char *, IfdId>, true> &const __allocator_traits_rebind<allocator<pair<const unsigned char *const, IfdId>>, __value_type<const unsigned char *, IfdId>, true>const __allocator_traits_rebind<allocator<pair<const unsigned char *const, IfdId>>, __value_type<const unsigned char *, IfdId>, true> &allocator<__tree_node<__value_type<const unsigned char *, IfdId>, void *>>allocator<__tree_node<__value_type<const unsigned char *, IfdId>, void *>> &const allocator<__tree_node<__value_type<const unsigned char *, IfdId>, void *>>const allocator<__tree_node<__value_type<const unsigned char *, IfdId>, void *>> &const __tree_node<__value_type<const unsigned char *, IfdId>, void *>const __tree_node<__value_type<const unsigned char *, IfdId>, void *> &__tree_node<__value_type<const unsigned char *, IfdId>, void *> &const __tree_node<__value_type<const unsigned char *, IfdId>, void *> *__allocator_traits_rebind<allocator<__value_type<const unsigned char *, IfdId>>, __tree_node<__value_type<const unsigned char *, IfdId>, void *>, true>__allocator_traits_rebind<allocator<__value_type<const unsigned char *, IfdId>>, __tree_node<__value_type<const unsigned char *, IfdId>, void *>, true> &const __allocator_traits_rebind<allocator<__value_type<const unsigned char *, IfdId>>, __tree_node<__value_type<const unsigned char *, IfdId>, void *>, true>const __allocator_traits_rebind<allocator<__value_type<const unsigned char *, IfdId>>, __tree_node<__value_type<const unsigned char *, IfdId>, void *>, true> &__allocator_traits_rebind<allocator<__tree_node<__value_type<const unsigned char *, IfdId>, void *>>, __tree_node_base<void *>, true>__allocator_traits_rebind<allocator<__tree_node<__value_type<const unsigned char *, IfdId>, void *>>, __tree_node_base<void *>, true> &const __allocator_traits_rebind<allocator<__tree_node<__value_type<const unsigned char *, IfdId>, void *>>, __tree_node_base<void *>, true>const __allocator_traits_rebind<allocator<__tree_node<__value_type<const unsigned char *, IfdId>, void *>>, __tree_node_base<void *>, true> &allocator<__value_type<unsigned short, int>>allocator<__value_type<unsigned short, int>> &const allocator<__value_type<unsigned short, int>>const allocator<__value_type<unsigned short, int>> &const __value_type<unsigned short, int>const __value_type<unsigned short, int> &__value_type<unsigned short, int> &const __value_type<unsigned short, int> *__value_type<unsigned short, int> *__allocator_traits_rebind<allocator<pair<const unsigned short, int>>, __value_type<unsigned short, int>, true>__allocator_traits_rebind<allocator<pair<const unsigned short, int>>, __value_type<unsigned short, int>, true> &const __allocator_traits_rebind<allocator<pair<const unsigned short, int>>, __value_type<unsigned short, int>, true>const __allocator_traits_rebind<allocator<pair<const unsigned short, int>>, __value_type<unsigned short, int>, true> &allocator<__tree_node<__value_type<unsigned short, int>, void *>>allocator<__tree_node<__value_type<unsigned short, int>, void *>> &const allocator<__tree_node<__value_type<unsigned short, int>, void *>>const allocator<__tree_node<__value_type<unsigned short, int>, void *>> &const __tree_node<__value_type<unsigned short, int>, void *>const __tree_node<__value_type<unsigned short, int>, void *> &__tree_node<__value_type<unsigned short, int>, void *> &const __tree_node<__value_type<unsigned short, int>, void *> *__allocator_traits_rebind<allocator<__value_type<unsigned short, int>>, __tree_node<__value_type<unsigned short, int>, void *>, true>__allocator_traits_rebind<allocator<__value_type<unsigned short, int>>, __tree_node<__value_type<unsigned short, int>, void *>, true> &const __allocator_traits_rebind<allocator<__value_type<unsigned short, int>>, __tree_node<__value_type<unsigned short, int>, void *>, true>const __allocator_traits_rebind<allocator<__value_type<unsigned short, int>>, __tree_node<__value_type<unsigned short, int>, void *>, true> &__allocator_traits_rebind<allocator<__tree_node<__value_type<unsigned short, int>, void *>>, __tree_node_base<void *>, true>__allocator_traits_rebind<allocator<__tree_node<__value_type<unsigned short, int>, void *>>, __tree_node_base<void *>, true> &const __allocator_traits_rebind<allocator<__tree_node<__value_type<unsigned short, int>, void *>>, __tree_node_base<void *>, true>const __allocator_traits_rebind<allocator<__tree_node<__value_type<unsigned short, int>, void *>>, __tree_node_base<void *>, true> &less<const unsigned char *>const less<const unsigned char *>const less<const unsigned char *> &__identity<less<const unsigned char *>>__identity<less<const unsigned char *>> &const __identity<less<const unsigned char *>>const __identity<less<const unsigned char *>> &allocator<pair<const unsigned char *const, IfdId>>const allocator<pair<const unsigned char *const, IfdId>>const allocator<pair<const unsigned char *const, IfdId>> &const pair<const unsigned char *const, IfdId>const pair<const unsigned char *const, IfdId> &const pair<const unsigned char *const, IfdId> *__identity<allocator<pair<const unsigned char *const, IfdId>>>__identity<allocator<pair<const unsigned char *const, IfdId>>> &const __identity<allocator<pair<const unsigned char *const, IfdId>>>const __identity<allocator<pair<const unsigned char *const, IfdId>>> &less<unsigned short>const less<unsigned short>const less<unsigned short> &__identity<less<unsigned short>>__identity<less<unsigned short>> &const __identity<less<unsigned short>>const __identity<less<unsigned short>> &allocator<pair<const unsigned short, int>>const allocator<pair<const unsigned short, int>>const allocator<pair<const unsigned short, int>> &const pair<const unsigned short, int>const pair<const unsigned short, int> &const pair<const unsigned short, int> *__identity<allocator<pair<const unsigned short, int>>>__identity<allocator<pair<const unsigned short, int>>> &const __identity<allocator<pair<const unsigned short, int>>>const __identity<allocator<pair<const unsigned short, int>>> &__non_trivial_if<true, allocator<pair<const unsigned short, int>>>__non_trivial_if<true, allocator<pair<const unsigned short, int>>> &const __non_trivial_if<true, allocator<pair<const unsigned short, int>>>const __non_trivial_if<true, allocator<pair<const unsigned short, int>>> &binary_function<unsigned short, unsigned short, bool>binary_function<unsigned short, unsigned short, bool> &const binary_function<unsigned short, unsigned short, bool>const binary_function<unsigned short, unsigned short, bool> &__non_trivial_if<true, allocator<pair<const unsigned char *const, IfdId>>>__non_trivial_if<true, allocator<pair<const unsigned char *const, IfdId>>> &const __non_trivial_if<true, allocator<pair<const unsigned char *const, IfdId>>>const __non_trivial_if<true, allocator<pair<const unsigned char *const, IfdId>>> &binary_function<const unsigned char *, const unsigned char *, bool>binary_function<const unsigned char *, const unsigned char *, bool> &const binary_function<const unsigned char *, const unsigned char *, bool>const binary_function<const unsigned char *, const unsigned char *, bool> &__has_rebind_other<allocator<__tree_node<__value_type<unsigned short, int>, void *>>, __tree_node_base<void *>, void>__has_rebind_other<allocator<__tree_node<__value_type<unsigned short, int>, void *>>, __tree_node_base<void *>, void> &const __has_rebind_other<allocator<__tree_node<__value_type<unsigned short, int>, void *>>, __tree_node_base<void *>, void>const __has_rebind_other<allocator<__tree_node<__value_type<unsigned short, int>, void *>>, __tree_node_base<void *>, void> &__has_rebind_other<allocator<__value_type<unsigned short, int>>, __tree_node<__value_type<unsigned short, int>, void *>, void>__has_rebind_other<allocator<__value_type<unsigned short, int>>, __tree_node<__value_type<unsigned short, int>, void *>, void> &const __has_rebind_other<allocator<__value_type<unsigned short, int>>, __tree_node<__value_type<unsigned short, int>, void *>, void>const __has_rebind_other<allocator<__value_type<unsigned short, int>>, __tree_node<__value_type<unsigned short, int>, void *>, void> &__non_trivial_if<true, allocator<__tree_node<__value_type<unsigned short, int>, void *>>>__non_trivial_if<true, allocator<__tree_node<__value_type<unsigned short, int>, void *>>> &const __non_trivial_if<true, allocator<__tree_node<__value_type<unsigned short, int>, void *>>>const __non_trivial_if<true, allocator<__tree_node<__value_type<unsigned short, int>, void *>>> &rebind<__value_type<unsigned short, int>>rebind<__value_type<unsigned short, int>> &const rebind<__value_type<unsigned short, int>>const rebind<__value_type<unsigned short, int>> &__has_rebind_other<allocator<pair<const unsigned short, int>>, __value_type<unsigned short, int>, void>__has_rebind_other<allocator<pair<const unsigned short, int>>, __value_type<unsigned short, int>, void> &const __has_rebind_other<allocator<pair<const unsigned short, int>>, __value_type<unsigned short, int>, void>const __has_rebind_other<allocator<pair<const unsigned short, int>>, __value_type<unsigned short, int>, void> &__non_trivial_if<true, allocator<__value_type<unsigned short, int>>>__non_trivial_if<true, allocator<__value_type<unsigned short, int>>> &const __non_trivial_if<true, allocator<__value_type<unsigned short, int>>>const __non_trivial_if<true, allocator<__value_type<unsigned short, int>>> &rebind<__tree_node<__value_type<unsigned short, int>, void *>>rebind<__tree_node<__value_type<unsigned short, int>, void *>> &const rebind<__tree_node<__value_type<unsigned short, int>, void *>>const rebind<__tree_node<__value_type<unsigned short, int>, void *>> &__has_rebind_other<allocator<__tree_node<__value_type<const unsigned char *, IfdId>, void *>>, __tree_node_base<void *>, void>__has_rebind_other<allocator<__tree_node<__value_type<const unsigned char *, IfdId>, void *>>, __tree_node_base<void *>, void> &const __has_rebind_other<allocator<__tree_node<__value_type<const unsigned char *, IfdId>, void *>>, __tree_node_base<void *>, void>const __has_rebind_other<allocator<__tree_node<__value_type<const unsigned char *, IfdId>, void *>>, __tree_node_base<void *>, void> &__has_rebind_other<allocator<__value_type<const unsigned char *, IfdId>>, __tree_node<__value_type<const unsigned char *, IfdId>, void *>, void>__has_rebind_other<allocator<__value_type<const unsigned char *, IfdId>>, __tree_node<__value_type<const unsigned char *, IfdId>, void *>, void> &const __has_rebind_other<allocator<__value_type<const unsigned char *, IfdId>>, __tree_node<__value_type<const unsigned char *, IfdId>, void *>, void>const __has_rebind_other<allocator<__value_type<const unsigned char *, IfdId>>, __tree_node<__value_type<const unsigned char *, IfdId>, void *>, void> &__non_trivial_if<true, allocator<__tree_node<__value_type<const unsigned char *, IfdId>, void *>>>__non_trivial_if<true, allocator<__tree_node<__value_type<const unsigned char *, IfdId>, void *>>> &const __non_trivial_if<true, allocator<__tree_node<__value_type<const unsigned char *, IfdId>, void *>>>const __non_trivial_if<true, allocator<__tree_node<__value_type<const unsigned char *, IfdId>, void *>>> &rebind<__value_type<const unsigned char *, IfdId>>rebind<__value_type<const unsigned char *, IfdId>> &const rebind<__value_type<const unsigned char *, IfdId>>const rebind<__value_type<const unsigned char *, IfdId>> &__has_rebind_other<allocator<pair<const unsigned char *const, IfdId>>, __value_type<const unsigned char *, IfdId>, void>__has_rebind_other<allocator<pair<const unsigned char *const, IfdId>>, __value_type<const unsigned char *, IfdId>, void> &const __has_rebind_other<allocator<pair<const unsigned char *const, IfdId>>, __value_type<const unsigned char *, IfdId>, void>const __has_rebind_other<allocator<pair<const unsigned char *const, IfdId>>, __value_type<const unsigned char *, IfdId>, void> &__non_trivial_if<true, allocator<__value_type<const unsigned char *, IfdId>>>__non_trivial_if<true, allocator<__value_type<const unsigned char *, IfdId>>> &const __non_trivial_if<true, allocator<__value_type<const unsigned char *, IfdId>>>const __non_trivial_if<true, allocator<__value_type<const unsigned char *, IfdId>>> &rebind<__tree_node<__value_type<const unsigned char *, IfdId>, void *>>rebind<__tree_node<__value_type<const unsigned char *, IfdId>, void *>> &const rebind<__tree_node<__value_type<const unsigned char *, IfdId>, void *>>const rebind<__tree_node<__value_type<const unsigned char *, IfdId>, void *>> &__map_iterator<__tree_iterator<__value_type<basic_string<char, char_traits<char>, allocator<char>>, basic_string<char, char_traits<char>, allocator<char>>>, __tree_node<__value_type<basic_string<char, char_traits<char>, allocator<char>>, basic_string<char, char_traits<char>, allocator<char>>>, void *> *, long>>reverse_iterator<__map_iterator<__tree_iterator<__value_type<basic_string<char, char_traits<char>, allocator<char>>, basic_string<char, char_traits<char>, allocator<char>>>, __tree_node<__value_type<basic_string<char, char_traits<char>, allocator<char>>, basic_string<char, char_traits<char>, allocator<char>>>, void *> *, long>>>__value_type<unsigned short, int>__map_value_compare<unsigned short, __value_type<unsigned short, int>, less<unsigned short>, true>__map_value_compare<unsigned short, __value_type<unsigned short, int>, less<unsigned short>, true> &const __map_value_compare<unsigned short, __value_type<unsigned short, int>, less<unsigned short>, true>const __map_value_compare<unsigned short, __value_type<unsigned short, int>, less<unsigned short>, true> &__rebind_alloc_helper<allocator_traits<allocator<pair<const unsigned short, int>>>, __value_type<unsigned short, int>>__rebind_alloc_helper<allocator_traits<allocator<pair<const unsigned short, int>>>, __value_type<unsigned short, int>> &const __rebind_alloc_helper<allocator_traits<allocator<pair<const unsigned short, int>>>, __value_type<unsigned short, int>>const __rebind_alloc_helper<allocator_traits<allocator<pair<const unsigned short, int>>>, __value_type<unsigned short, int>> &allocator_traits<allocator<__tree_node<__value_type<unsigned short, int>, void *>>>allocator_traits<allocator<__tree_node<__value_type<unsigned short, int>, void *>>> &const allocator_traits<allocator<__tree_node<__value_type<unsigned short, int>, void *>>>const allocator_traits<allocator<__tree_node<__value_type<unsigned short, int>, void *>>> &pair<const unsigned short, int>allocator_traits<allocator<pair<const unsigned short, int>>>allocator_traits<allocator<pair<const unsigned short, int>>> &const allocator_traits<allocator<pair<const unsigned short, int>>>const allocator_traits<allocator<pair<const unsigned short, int>>> &__map_iterator<__tree_iterator<__value_type<unsigned short, int>, __tree_node<__value_type<unsigned short, int>, void *> *, long>>__map_const_iterator<__tree_const_iterator<__value_type<unsigned short, int>, __tree_node<__value_type<unsigned short, int>, void *> *, long>>reverse_iterator<__map_iterator<__tree_iterator<__value_type<unsigned short, int>, __tree_node<__value_type<unsigned short, int>, void *> *, long>>>reverse_iterator<__map_const_iterator<__tree_const_iterator<__value_type<unsigned short, int>, __tree_node<__value_type<unsigned short, int>, void *> *, long>>>__tree_node<__value_type<unsigned short, int>, void *>__tree<__value_type<unsigned short, int>, __map_value_compare<unsigned short, __value_type<unsigned short, int>, less<unsigned short>, true>, allocator<__value_type<unsigned short, int>>>__map_node_destructor<allocator<__tree_node<__value_type<unsigned short, int>, void *>>>unique_ptr<__tree_node<__value_type<unsigned short, int>, void *>, __map_node_destructor<allocator<__tree_node<__value_type<unsigned short, int>, void *>>>>__value_type<const unsigned char *, IfdId>__map_value_compare<const unsigned char *, __value_type<const unsigned char *, IfdId>, less<const unsigned char *>, true>__map_value_compare<const unsigned char *, __value_type<const unsigned char *, IfdId>, less<const unsigned char *>, true> &const __map_value_compare<const unsigned char *, __value_type<const unsigned char *, IfdId>, less<const unsigned char *>, true>const __map_value_compare<const unsigned char *, __value_type<const unsigned char *, IfdId>, less<const unsigned char *>, true> &__rebind_alloc_helper<allocator_traits<allocator<pair<const unsigned char *const, IfdId>>>, __value_type<const unsigned char *, IfdId>>__rebind_alloc_helper<allocator_traits<allocator<pair<const unsigned char *const, IfdId>>>, __value_type<const unsigned char *, IfdId>> &const __rebind_alloc_helper<allocator_traits<allocator<pair<const unsigned char *const, IfdId>>>, __value_type<const unsigned char *, IfdId>>const __rebind_alloc_helper<allocator_traits<allocator<pair<const unsigned char *const, IfdId>>>, __value_type<const unsigned char *, IfdId>> &allocator_traits<allocator<__tree_node<__value_type<const unsigned char *, IfdId>, void *>>>allocator_traits<allocator<__tree_node<__value_type<const unsigned char *, IfdId>, void *>>> &const allocator_traits<allocator<__tree_node<__value_type<const unsigned char *, IfdId>, void *>>>const allocator_traits<allocator<__tree_node<__value_type<const unsigned char *, IfdId>, void *>>> &pair<const unsigned char *const, IfdId>const unsigned char *constallocator_traits<allocator<pair<const unsigned char *const, IfdId>>>allocator_traits<allocator<pair<const unsigned char *const, IfdId>>> &const allocator_traits<allocator<pair<const unsigned char *const, IfdId>>>const allocator_traits<allocator<pair<const unsigned char *const, IfdId>>> &__map_iterator<__tree_iterator<__value_type<const unsigned char *, IfdId>, __tree_node<__value_type<const unsigned char *, IfdId>, void *> *, long>>__map_const_iterator<__tree_const_iterator<__value_type<const unsigned char *, IfdId>, __tree_node<__value_type<const unsigned char *, IfdId>, void *> *, long>>reverse_iterator<__map_iterator<__tree_iterator<__value_type<const unsigned char *, IfdId>, __tree_node<__value_type<const unsigned char *, IfdId>, void *> *, long>>>reverse_iterator<__map_const_iterator<__tree_const_iterator<__value_type<const unsigned char *, IfdId>, __tree_node<__value_type<const unsigned char *, IfdId>, void *> *, long>>>__tree_node<__value_type<const unsigned char *, IfdId>, void *>__tree<__value_type<const unsigned char *, IfdId>, __map_value_compare<const unsigned char *, __value_type<const unsigned char *, IfdId>, less<const unsigned char *>, true>, allocator<__value_type<const unsigned char *, IfdId>>>__map_node_destructor<allocator<__tree_node<__value_type<const unsigned char *, IfdId>, void *>>>unique_ptr<__tree_node<__value_type<const unsigned char *, IfdId>, void *>, __map_node_destructor<allocator<__tree_node<__value_type<const unsigned char *, IfdId>, void *>>>>__compressed_pair<__tree_end_node<__tree_node_base<void *> *>, allocator<__tree_node<__value_type<const unsigned char *, IfdId>, void *>>>__compressed_pair<__tree_end_node<__tree_node_base<void *> *>, allocator<__tree_node<__value_type<const unsigned char *, IfdId>, void *>>> &const __compressed_pair<__tree_end_node<__tree_node_base<void *> *>, allocator<__tree_node<__value_type<const unsigned char *, IfdId>, void *>>>const __compressed_pair<__tree_end_node<__tree_node_base<void *> *>, allocator<__tree_node<__value_type<const unsigned char *, IfdId>, void *>>> &__compressed_pair<unsigned long, __map_value_compare<const unsigned char *, __value_type<const unsigned char *, IfdId>, less<const unsigned char *>, true>>__compressed_pair<unsigned long, __map_value_compare<const unsigned char *, __value_type<const unsigned char *, IfdId>, less<const unsigned char *>, true>> &const __compressed_pair<unsigned long, __map_value_compare<const unsigned char *, __value_type<const unsigned char *, IfdId>, less<const unsigned char *>, true>>const __compressed_pair<unsigned long, __map_value_compare<const unsigned char *, __value_type<const unsigned char *, IfdId>, less<const unsigned char *>, true>> &__tree_key_value_types<__value_type<const unsigned char *, IfdId>>__tree_key_value_types<__value_type<const unsigned char *, IfdId>> &const __tree_key_value_types<__value_type<const unsigned char *, IfdId>>const __tree_key_value_types<__value_type<const unsigned char *, IfdId>> &__make_tree_node_types<__value_type<const unsigned char *, IfdId>, void *>__make_tree_node_types<__value_type<const unsigned char *, IfdId>, void *> &const __make_tree_node_types<__value_type<const unsigned char *, IfdId>, void *>const __make_tree_node_types<__value_type<const unsigned char *, IfdId>, void *> &allocator_traits<allocator<__value_type<const unsigned char *, IfdId>>>allocator_traits<allocator<__value_type<const unsigned char *, IfdId>>> &const allocator_traits<allocator<__value_type<const unsigned char *, IfdId>>>const allocator_traits<allocator<__value_type<const unsigned char *, IfdId>>> &__tree_node_types<__tree_node<__value_type<const unsigned char *, IfdId>, void *> *, __tree_node<__value_type<const unsigned char *, IfdId>, void *>>__tree_node_types<__tree_node<__value_type<const unsigned char *, IfdId>, void *> *, __tree_node<__value_type<const unsigned char *, IfdId>, void *>> &const __tree_node_types<__tree_node<__value_type<const unsigned char *, IfdId>, void *> *, __tree_node<__value_type<const unsigned char *, IfdId>, void *>>const __tree_node_types<__tree_node<__value_type<const unsigned char *, IfdId>, void *> *, __tree_node<__value_type<const unsigned char *, IfdId>, void *>> &__rebind_alloc_helper<allocator_traits<allocator<__value_type<const unsigned char *, IfdId>>>, __tree_node<__value_type<const unsigned char *, IfdId>, void *>>__rebind_alloc_helper<allocator_traits<allocator<__value_type<const unsigned char *, IfdId>>>, __tree_node<__value_type<const unsigned char *, IfdId>, void *>> &const __rebind_alloc_helper<allocator_traits<allocator<__value_type<const unsigned char *, IfdId>>>, __tree_node<__value_type<const unsigned char *, IfdId>, void *>>const __rebind_alloc_helper<allocator_traits<allocator<__value_type<const unsigned char *, IfdId>>>, __tree_node<__value_type<const unsigned char *, IfdId>, void *>> &__rebind_alloc_helper<allocator_traits<allocator<__tree_node<__value_type<const unsigned char *, IfdId>, void *>>>, __tree_node_base<void *>>__rebind_alloc_helper<allocator_traits<allocator<__tree_node<__value_type<const unsigned char *, IfdId>, void *>>>, __tree_node_base<void *>> &const __rebind_alloc_helper<allocator_traits<allocator<__tree_node<__value_type<const unsigned char *, IfdId>, void *>>>, __tree_node_base<void *>>const __rebind_alloc_helper<allocator_traits<allocator<__tree_node<__value_type<const unsigned char *, IfdId>, void *>>>, __tree_node_base<void *>> &__tree_node_destructor<allocator<__tree_node<__value_type<const unsigned char *, IfdId>, void *>>>unique_ptr<__tree_node<__value_type<const unsigned char *, IfdId>, void *>, __tree_node_destructor<allocator<__tree_node<__value_type<const unsigned char *, IfdId>, void *>>>>pair<__tree_iterator<__value_type<const unsigned char *, IfdId>, __tree_node<__value_type<const unsigned char *, IfdId>, void *> *, long>, bool>pair<__tree_iterator<__value_type<const unsigned char *, IfdId>, __tree_node<__value_type<const unsigned char *, IfdId>, void *> *, long>, __tree_iterator<__value_type<const unsigned char *, IfdId>, __tree_node<__value_type<const unsigned char *, IfdId>, void *> *, long>>pair<__tree_const_iterator<__value_type<const unsigned char *, IfdId>, __tree_node<__value_type<const unsigned char *, IfdId>, void *> *, long>, __tree_const_iterator<__value_type<const unsigned char *, IfdId>, __tree_node<__value_type<const unsigned char *, IfdId>, void *> *, long>>__tree_const_iterator<__value_type<const unsigned char *, IfdId>, __tree_node<__value_type<const unsigned char *, IfdId>, void *> *, long>__tree_iterator<__value_type<const unsigned char *, IfdId>, __tree_node<__value_type<const unsigned char *, IfdId>, void *> *, long>__size_type<allocator<pair<const unsigned char *const, IfdId>>, long, true>__size_type<allocator<pair<const unsigned char *const, IfdId>>, long, true> &const __size_type<allocator<pair<const unsigned char *const, IfdId>>, long, true>const __size_type<allocator<pair<const unsigned char *const, IfdId>>, long, true> &__const_void_pointer<pair<const unsigned char *const, IfdId> *, allocator<pair<const unsigned char *const, IfdId>>, false>__const_void_pointer<pair<const unsigned char *const, IfdId> *, allocator<pair<const unsigned char *const, IfdId>>, false> &const __const_void_pointer<pair<const unsigned char *const, IfdId> *, allocator<pair<const unsigned char *const, IfdId>>, false>const __const_void_pointer<pair<const unsigned char *const, IfdId> *, allocator<pair<const unsigned char *const, IfdId>>, false> &__pointer<pair<const unsigned char *const, IfdId>, allocator<pair<const unsigned char *const, IfdId>>, allocator<pair<const unsigned char *const, IfdId>>, true>__pointer<pair<const unsigned char *const, IfdId>, allocator<pair<const unsigned char *const, IfdId>>, allocator<pair<const unsigned char *const, IfdId>>, true> &const __pointer<pair<const unsigned char *const, IfdId>, allocator<pair<const unsigned char *const, IfdId>>, allocator<pair<const unsigned char *const, IfdId>>, true>const __pointer<pair<const unsigned char *const, IfdId>, allocator<pair<const unsigned char *const, IfdId>>, allocator<pair<const unsigned char *const, IfdId>>, true> &__const_pointer<pair<const unsigned char *const, IfdId>, pair<const unsigned char *const, IfdId> *, allocator<pair<const unsigned char *const, IfdId>>, true>__const_pointer<pair<const unsigned char *const, IfdId>, pair<const unsigned char *const, IfdId> *, allocator<pair<const unsigned char *const, IfdId>>, true> &const __const_pointer<pair<const unsigned char *const, IfdId>, pair<const unsigned char *const, IfdId> *, allocator<pair<const unsigned char *const, IfdId>>, true>const __const_pointer<pair<const unsigned char *const, IfdId>, pair<const unsigned char *const, IfdId> *, allocator<pair<const unsigned char *const, IfdId>>, true> &__void_pointer<pair<const unsigned char *const, IfdId> *, allocator<pair<const unsigned char *const, IfdId>>, false>__void_pointer<pair<const unsigned char *const, IfdId> *, allocator<pair<const unsigned char *const, IfdId>>, false> &const __void_pointer<pair<const unsigned char *const, IfdId> *, allocator<pair<const unsigned char *const, IfdId>>, false>const __void_pointer<pair<const unsigned char *const, IfdId> *, allocator<pair<const unsigned char *const, IfdId>>, false> &__alloc_traits_difference_type<allocator<pair<const unsigned char *const, IfdId>>, pair<const unsigned char *const, IfdId> *, true>__alloc_traits_difference_type<allocator<pair<const unsigned char *const, IfdId>>, pair<const unsigned char *const, IfdId> *, true> &const __alloc_traits_difference_type<allocator<pair<const unsigned char *const, IfdId>>, pair<const unsigned char *const, IfdId> *, true>const __alloc_traits_difference_type<allocator<pair<const unsigned char *const, IfdId>>, pair<const unsigned char *const, IfdId> *, true> &__propagate_on_container_move_assignment<allocator<pair<const unsigned char *const, IfdId>>, true>__propagate_on_container_move_assignment<allocator<pair<const unsigned char *const, IfdId>>, true> &const __propagate_on_container_move_assignment<allocator<pair<const unsigned char *const, IfdId>>, true>const __propagate_on_container_move_assignment<allocator<pair<const unsigned char *const, IfdId>>, true> &__is_always_equal<allocator<pair<const unsigned char *const, IfdId>>, true>__is_always_equal<allocator<pair<const unsigned char *const, IfdId>>, true> &const __is_always_equal<allocator<pair<const unsigned char *const, IfdId>>, true>const __is_always_equal<allocator<pair<const unsigned char *const, IfdId>>, true> &__size_type<allocator<__tree_node<__value_type<const unsigned char *, IfdId>, void *>>, long, true>__size_type<allocator<__tree_node<__value_type<const unsigned char *, IfdId>, void *>>, long, true> &const __size_type<allocator<__tree_node<__value_type<const unsigned char *, IfdId>, void *>>, long, true>const __size_type<allocator<__tree_node<__value_type<const unsigned char *, IfdId>, void *>>, long, true> &__const_void_pointer<__tree_node<__value_type<const unsigned char *, IfdId>, void *> *, allocator<__tree_node<__value_type<const unsigned char *, IfdId>, void *>>, false>__const_void_pointer<__tree_node<__value_type<const unsigned char *, IfdId>, void *> *, allocator<__tree_node<__value_type<const unsigned char *, IfdId>, void *>>, false> &const __const_void_pointer<__tree_node<__value_type<const unsigned char *, IfdId>, void *> *, allocator<__tree_node<__value_type<const unsigned char *, IfdId>, void *>>, false>const __const_void_pointer<__tree_node<__value_type<const unsigned char *, IfdId>, void *> *, allocator<__tree_node<__value_type<const unsigned char *, IfdId>, void *>>, false> &__pointer<__tree_node<__value_type<const unsigned char *, IfdId>, void *>, allocator<__tree_node<__value_type<const unsigned char *, IfdId>, void *>>, allocator<__tree_node<__value_type<const unsigned char *, IfdId>, void *>>, true>__pointer<__tree_node<__value_type<const unsigned char *, IfdId>, void *>, allocator<__tree_node<__value_type<const unsigned char *, IfdId>, void *>>, allocator<__tree_node<__value_type<const unsigned char *, IfdId>, void *>>, true> &const __pointer<__tree_node<__value_type<const unsigned char *, IfdId>, void *>, allocator<__tree_node<__value_type<const unsigned char *, IfdId>, void *>>, allocator<__tree_node<__value_type<const unsigned char *, IfdId>, void *>>, true>const __pointer<__tree_node<__value_type<const unsigned char *, IfdId>, void *>, allocator<__tree_node<__value_type<const unsigned char *, IfdId>, void *>>, allocator<__tree_node<__value_type<const unsigned char *, IfdId>, void *>>, true> &__const_pointer<__tree_node<__value_type<const unsigned char *, IfdId>, void *>, __tree_node<__value_type<const unsigned char *, IfdId>, void *> *, allocator<__tree_node<__value_type<const unsigned char *, IfdId>, void *>>, true>__const_pointer<__tree_node<__value_type<const unsigned char *, IfdId>, void *>, __tree_node<__value_type<const unsigned char *, IfdId>, void *> *, allocator<__tree_node<__value_type<const unsigned char *, IfdId>, void *>>, true> &const __const_pointer<__tree_node<__value_type<const unsigned char *, IfdId>, void *>, __tree_node<__value_type<const unsigned char *, IfdId>, void *> *, allocator<__tree_node<__value_type<const unsigned char *, IfdId>, void *>>, true>const __const_pointer<__tree_node<__value_type<const unsigned char *, IfdId>, void *>, __tree_node<__value_type<const unsigned char *, IfdId>, void *> *, allocator<__tree_node<__value_type<const unsigned char *, IfdId>, void *>>, true> &__void_pointer<__tree_node<__value_type<const unsigned char *, IfdId>, void *> *, allocator<__tree_node<__value_type<const unsigned char *, IfdId>, void *>>, false>__void_pointer<__tree_node<__value_type<const unsigned char *, IfdId>, void *> *, allocator<__tree_node<__value_type<const unsigned char *, IfdId>, void *>>, false> &const __void_pointer<__tree_node<__value_type<const unsigned char *, IfdId>, void *> *, allocator<__tree_node<__value_type<const unsigned char *, IfdId>, void *>>, false>const __void_pointer<__tree_node<__value_type<const unsigned char *, IfdId>, void *> *, allocator<__tree_node<__value_type<const unsigned char *, IfdId>, void *>>, false> &__alloc_traits_difference_type<allocator<__tree_node<__value_type<const unsigned char *, IfdId>, void *>>, __tree_node<__value_type<const unsigned char *, IfdId>, void *> *, true>__alloc_traits_difference_type<allocator<__tree_node<__value_type<const unsigned char *, IfdId>, void *>>, __tree_node<__value_type<const unsigned char *, IfdId>, void *> *, true> &const __alloc_traits_difference_type<allocator<__tree_node<__value_type<const unsigned char *, IfdId>, void *>>, __tree_node<__value_type<const unsigned char *, IfdId>, void *> *, true>const __alloc_traits_difference_type<allocator<__tree_node<__value_type<const unsigned char *, IfdId>, void *>>, __tree_node<__value_type<const unsigned char *, IfdId>, void *> *, true> &__propagate_on_container_move_assignment<allocator<__tree_node<__value_type<const unsigned char *, IfdId>, void *>>, true>__propagate_on_container_move_assignment<allocator<__tree_node<__value_type<const unsigned char *, IfdId>, void *>>, true> &const __propagate_on_container_move_assignment<allocator<__tree_node<__value_type<const unsigned char *, IfdId>, void *>>, true>const __propagate_on_container_move_assignment<allocator<__tree_node<__value_type<const unsigned char *, IfdId>, void *>>, true> &__is_always_equal<allocator<__tree_node<__value_type<const unsigned char *, IfdId>, void *>>, true>__is_always_equal<allocator<__tree_node<__value_type<const unsigned char *, IfdId>, void *>>, true> &const __is_always_equal<allocator<__tree_node<__value_type<const unsigned char *, IfdId>, void *>>, true>const __is_always_equal<allocator<__tree_node<__value_type<const unsigned char *, IfdId>, void *>>, true> &rebind_alloc<__value_type<const unsigned char *, IfdId>>rebind_alloc<__value_type<const unsigned char *, IfdId>> &const rebind_alloc<__value_type<const unsigned char *, IfdId>>const rebind_alloc<__value_type<const unsigned char *, IfdId>> &__compressed_pair<__tree_end_node<__tree_node_base<void *> *>, allocator<__tree_node<__value_type<unsigned short, int>, void *>>>__compressed_pair<__tree_end_node<__tree_node_base<void *> *>, allocator<__tree_node<__value_type<unsigned short, int>, void *>>> &const __compressed_pair<__tree_end_node<__tree_node_base<void *> *>, allocator<__tree_node<__value_type<unsigned short, int>, void *>>>const __compressed_pair<__tree_end_node<__tree_node_base<void *> *>, allocator<__tree_node<__value_type<unsigned short, int>, void *>>> &__compressed_pair<unsigned long, __map_value_compare<unsigned short, __value_type<unsigned short, int>, less<unsigned short>, true>>__compressed_pair<unsigned long, __map_value_compare<unsigned short, __value_type<unsigned short, int>, less<unsigned short>, true>> &const __compressed_pair<unsigned long, __map_value_compare<unsigned short, __value_type<unsigned short, int>, less<unsigned short>, true>>const __compressed_pair<unsigned long, __map_value_compare<unsigned short, __value_type<unsigned short, int>, less<unsigned short>, true>> &__tree_key_value_types<__value_type<unsigned short, int>>__tree_key_value_types<__value_type<unsigned short, int>> &const __tree_key_value_types<__value_type<unsigned short, int>>const __tree_key_value_types<__value_type<unsigned short, int>> &__make_tree_node_types<__value_type<unsigned short, int>, void *>__make_tree_node_types<__value_type<unsigned short, int>, void *> &const __make_tree_node_types<__value_type<unsigned short, int>, void *>const __make_tree_node_types<__value_type<unsigned short, int>, void *> &allocator_traits<allocator<__value_type<unsigned short, int>>>allocator_traits<allocator<__value_type<unsigned short, int>>> &const allocator_traits<allocator<__value_type<unsigned short, int>>>const allocator_traits<allocator<__value_type<unsigned short, int>>> &__tree_node_types<__tree_node<__value_type<unsigned short, int>, void *> *, __tree_node<__value_type<unsigned short, int>, void *>>__tree_node_types<__tree_node<__value_type<unsigned short, int>, void *> *, __tree_node<__value_type<unsigned short, int>, void *>> &const __tree_node_types<__tree_node<__value_type<unsigned short, int>, void *> *, __tree_node<__value_type<unsigned short, int>, void *>>const __tree_node_types<__tree_node<__value_type<unsigned short, int>, void *> *, __tree_node<__value_type<unsigned short, int>, void *>> &__rebind_alloc_helper<allocator_traits<allocator<__value_type<unsigned short, int>>>, __tree_node<__value_type<unsigned short, int>, void *>>__rebind_alloc_helper<allocator_traits<allocator<__value_type<unsigned short, int>>>, __tree_node<__value_type<unsigned short, int>, void *>> &const __rebind_alloc_helper<allocator_traits<allocator<__value_type<unsigned short, int>>>, __tree_node<__value_type<unsigned short, int>, void *>>const __rebind_alloc_helper<allocator_traits<allocator<__value_type<unsigned short, int>>>, __tree_node<__value_type<unsigned short, int>, void *>> &__rebind_alloc_helper<allocator_traits<allocator<__tree_node<__value_type<unsigned short, int>, void *>>>, __tree_node_base<void *>>__rebind_alloc_helper<allocator_traits<allocator<__tree_node<__value_type<unsigned short, int>, void *>>>, __tree_node_base<void *>> &const __rebind_alloc_helper<allocator_traits<allocator<__tree_node<__value_type<unsigned short, int>, void *>>>, __tree_node_base<void *>>const __rebind_alloc_helper<allocator_traits<allocator<__tree_node<__value_type<unsigned short, int>, void *>>>, __tree_node_base<void *>> &__tree_node_destructor<allocator<__tree_node<__value_type<unsigned short, int>, void *>>>unique_ptr<__tree_node<__value_type<unsigned short, int>, void *>, __tree_node_destructor<allocator<__tree_node<__value_type<unsigned short, int>, void *>>>>pair<__tree_iterator<__value_type<unsigned short, int>, __tree_node<__value_type<unsigned short, int>, void *> *, long>, bool>pair<__tree_iterator<__value_type<unsigned short, int>, __tree_node<__value_type<unsigned short, int>, void *> *, long>, __tree_iterator<__value_type<unsigned short, int>, __tree_node<__value_type<unsigned short, int>, void *> *, long>>pair<__tree_const_iterator<__value_type<unsigned short, int>, __tree_node<__value_type<unsigned short, int>, void *> *, long>, __tree_const_iterator<__value_type<unsigned short, int>, __tree_node<__value_type<unsigned short, int>, void *> *, long>>__tree_const_iterator<__value_type<unsigned short, int>, __tree_node<__value_type<unsigned short, int>, void *> *, long>__tree_iterator<__value_type<unsigned short, int>, __tree_node<__value_type<unsigned short, int>, void *> *, long>__size_type<allocator<pair<const unsigned short, int>>, long, true>__size_type<allocator<pair<const unsigned short, int>>, long, true> &const __size_type<allocator<pair<const unsigned short, int>>, long, true>const __size_type<allocator<pair<const unsigned short, int>>, long, true> &__const_void_pointer<pair<const unsigned short, int> *, allocator<pair<const unsigned short, int>>, false>__const_void_pointer<pair<const unsigned short, int> *, allocator<pair<const unsigned short, int>>, false> &const __const_void_pointer<pair<const unsigned short, int> *, allocator<pair<const unsigned short, int>>, false>const __const_void_pointer<pair<const unsigned short, int> *, allocator<pair<const unsigned short, int>>, false> &__pointer<pair<const unsigned short, int>, allocator<pair<const unsigned short, int>>, allocator<pair<const unsigned short, int>>, true>__pointer<pair<const unsigned short, int>, allocator<pair<const unsigned short, int>>, allocator<pair<const unsigned short, int>>, true> &const __pointer<pair<const unsigned short, int>, allocator<pair<const unsigned short, int>>, allocator<pair<const unsigned short, int>>, true>const __pointer<pair<const unsigned short, int>, allocator<pair<const unsigned short, int>>, allocator<pair<const unsigned short, int>>, true> &__const_pointer<pair<const unsigned short, int>, pair<const unsigned short, int> *, allocator<pair<const unsigned short, int>>, true>__const_pointer<pair<const unsigned short, int>, pair<const unsigned short, int> *, allocator<pair<const unsigned short, int>>, true> &const __const_pointer<pair<const unsigned short, int>, pair<const unsigned short, int> *, allocator<pair<const unsigned short, int>>, true>const __const_pointer<pair<const unsigned short, int>, pair<const unsigned short, int> *, allocator<pair<const unsigned short, int>>, true> &__void_pointer<pair<const unsigned short, int> *, allocator<pair<const unsigned short, int>>, false>__void_pointer<pair<const unsigned short, int> *, allocator<pair<const unsigned short, int>>, false> &const __void_pointer<pair<const unsigned short, int> *, allocator<pair<const unsigned short, int>>, false>const __void_pointer<pair<const unsigned short, int> *, allocator<pair<const unsigned short, int>>, false> &__alloc_traits_difference_type<allocator<pair<const unsigned short, int>>, pair<const unsigned short, int> *, true>__alloc_traits_difference_type<allocator<pair<const unsigned short, int>>, pair<const unsigned short, int> *, true> &const __alloc_traits_difference_type<allocator<pair<const unsigned short, int>>, pair<const unsigned short, int> *, true>const __alloc_traits_difference_type<allocator<pair<const unsigned short, int>>, pair<const unsigned short, int> *, true> &__propagate_on_container_move_assignment<allocator<pair<const unsigned short, int>>, true>__propagate_on_container_move_assignment<allocator<pair<const unsigned short, int>>, true> &const __propagate_on_container_move_assignment<allocator<pair<const unsigned short, int>>, true>const __propagate_on_container_move_assignment<allocator<pair<const unsigned short, int>>, true> &__is_always_equal<allocator<pair<const unsigned short, int>>, true>__is_always_equal<allocator<pair<const unsigned short, int>>, true> &const __is_always_equal<allocator<pair<const unsigned short, int>>, true>const __is_always_equal<allocator<pair<const unsigned short, int>>, true> &__size_type<allocator<__tree_node<__value_type<unsigned short, int>, void *>>, long, true>__size_type<allocator<__tree_node<__value_type<unsigned short, int>, void *>>, long, true> &const __size_type<allocator<__tree_node<__value_type<unsigned short, int>, void *>>, long, true>const __size_type<allocator<__tree_node<__value_type<unsigned short, int>, void *>>, long, true> &__const_void_pointer<__tree_node<__value_type<unsigned short, int>, void *> *, allocator<__tree_node<__value_type<unsigned short, int>, void *>>, false>__const_void_pointer<__tree_node<__value_type<unsigned short, int>, void *> *, allocator<__tree_node<__value_type<unsigned short, int>, void *>>, false> &const __const_void_pointer<__tree_node<__value_type<unsigned short, int>, void *> *, allocator<__tree_node<__value_type<unsigned short, int>, void *>>, false>const __const_void_pointer<__tree_node<__value_type<unsigned short, int>, void *> *, allocator<__tree_node<__value_type<unsigned short, int>, void *>>, false> &__pointer<__tree_node<__value_type<unsigned short, int>, void *>, allocator<__tree_node<__value_type<unsigned short, int>, void *>>, allocator<__tree_node<__value_type<unsigned short, int>, void *>>, true>__pointer<__tree_node<__value_type<unsigned short, int>, void *>, allocator<__tree_node<__value_type<unsigned short, int>, void *>>, allocator<__tree_node<__value_type<unsigned short, int>, void *>>, true> &const __pointer<__tree_node<__value_type<unsigned short, int>, void *>, allocator<__tree_node<__value_type<unsigned short, int>, void *>>, allocator<__tree_node<__value_type<unsigned short, int>, void *>>, true>const __pointer<__tree_node<__value_type<unsigned short, int>, void *>, allocator<__tree_node<__value_type<unsigned short, int>, void *>>, allocator<__tree_node<__value_type<unsigned short, int>, void *>>, true> &__const_pointer<__tree_node<__value_type<unsigned short, int>, void *>, __tree_node<__value_type<unsigned short, int>, void *> *, allocator<__tree_node<__value_type<unsigned short, int>, void *>>, true>__const_pointer<__tree_node<__value_type<unsigned short, int>, void *>, __tree_node<__value_type<unsigned short, int>, void *> *, allocator<__tree_node<__value_type<unsigned short, int>, void *>>, true> &const __const_pointer<__tree_node<__value_type<unsigned short, int>, void *>, __tree_node<__value_type<unsigned short, int>, void *> *, allocator<__tree_node<__value_type<unsigned short, int>, void *>>, true>const __const_pointer<__tree_node<__value_type<unsigned short, int>, void *>, __tree_node<__value_type<unsigned short, int>, void *> *, allocator<__tree_node<__value_type<unsigned short, int>, void *>>, true> &__void_pointer<__tree_node<__value_type<unsigned short, int>, void *> *, allocator<__tree_node<__value_type<unsigned short, int>, void *>>, false>__void_pointer<__tree_node<__value_type<unsigned short, int>, void *> *, allocator<__tree_node<__value_type<unsigned short, int>, void *>>, false> &const __void_pointer<__tree_node<__value_type<unsigned short, int>, void *> *, allocator<__tree_node<__value_type<unsigned short, int>, void *>>, false>const __void_pointer<__tree_node<__value_type<unsigned short, int>, void *> *, allocator<__tree_node<__value_type<unsigned short, int>, void *>>, false> &__alloc_traits_difference_type<allocator<__tree_node<__value_type<unsigned short, int>, void *>>, __tree_node<__value_type<unsigned short, int>, void *> *, true>__alloc_traits_difference_type<allocator<__tree_node<__value_type<unsigned short, int>, void *>>, __tree_node<__value_type<unsigned short, int>, void *> *, true> &const __alloc_traits_difference_type<allocator<__tree_node<__value_type<unsigned short, int>, void *>>, __tree_node<__value_type<unsigned short, int>, void *> *, true>const __alloc_traits_difference_type<allocator<__tree_node<__value_type<unsigned short, int>, void *>>, __tree_node<__value_type<unsigned short, int>, void *> *, true> &__propagate_on_container_move_assignment<allocator<__tree_node<__value_type<unsigned short, int>, void *>>, true>__propagate_on_container_move_assignment<allocator<__tree_node<__value_type<unsigned short, int>, void *>>, true> &const __propagate_on_container_move_assignment<allocator<__tree_node<__value_type<unsigned short, int>, void *>>, true>const __propagate_on_container_move_assignment<allocator<__tree_node<__value_type<unsigned short, int>, void *>>, true> &__is_always_equal<allocator<__tree_node<__value_type<unsigned short, int>, void *>>, true>__is_always_equal<allocator<__tree_node<__value_type<unsigned short, int>, void *>>, true> &const __is_always_equal<allocator<__tree_node<__value_type<unsigned short, int>, void *>>, true>const __is_always_equal<allocator<__tree_node<__value_type<unsigned short, int>, void *>>, true> &rebind_alloc<__value_type<unsigned short, int>>rebind_alloc<__value_type<unsigned short, int>> &const rebind_alloc<__value_type<unsigned short, int>>const rebind_alloc<__value_type<unsigned short, int>> &__tree_iterator<__value_type<basic_string<char, char_traits<char>, allocator<char>>, basic_string<char, char_traits<char>, allocator<char>>>, __tree_node<__value_type<basic_string<char, char_traits<char>, allocator<char>>, basic_string<char, char_traits<char>, allocator<char>>>, void *> *, long>pair<__tree_iterator<__value_type<basic_string<char, char_traits<char>, allocator<char>>, basic_string<char, char_traits<char>, allocator<char>>>, __tree_node<__value_type<basic_string<char, char_traits<char>, allocator<char>>, basic_string<char, char_traits<char>, allocator<char>>>, void *> *, long>, __tree_iterator<__value_type<basic_string<char, char_traits<char>, allocator<char>>, basic_string<char, char_traits<char>, allocator<char>>>, __tree_node<__value_type<basic_string<char, char_traits<char>, allocator<char>>, basic_string<char, char_traits<char>, allocator<char>>>, void *> *, long>>pointer_traits<__tree_node<__value_type<unsigned short, int>, void *> *>pointer_traits<__tree_node<__value_type<unsigned short, int>, void *> *> &const pointer_traits<__tree_node<__value_type<unsigned short, int>, void *> *>const pointer_traits<__tree_node<__value_type<unsigned short, int>, void *> *> &__rebind_pointer<void *, __value_type<unsigned short, int>>__rebind_pointer<void *, __value_type<unsigned short, int>> &const __rebind_pointer<void *, __value_type<unsigned short, int>>const __rebind_pointer<void *, __value_type<unsigned short, int>> &__rebind_pointer<void *, const __value_type<unsigned short, int>>__rebind_pointer<void *, const __value_type<unsigned short, int>> &const __rebind_pointer<void *, const __value_type<unsigned short, int>>const __rebind_pointer<void *, const __value_type<unsigned short, int>> &conditional<true, __tree_end_node<__tree_node_base<void *> *> *, __tree_node<__value_type<unsigned short, int>, void *> *>conditional<true, __tree_end_node<__tree_node_base<void *> *> *, __tree_node<__value_type<unsigned short, int>, void *> *> &const conditional<true, __tree_end_node<__tree_node_base<void *> *> *, __tree_node<__value_type<unsigned short, int>, void *> *>const conditional<true, __tree_end_node<__tree_node_base<void *> *> *, __tree_node<__value_type<unsigned short, int>, void *> *> &__tree_map_pointer_types<__value_type<unsigned short, int>, void *, __tree_key_value_types<__value_type<unsigned short, int>>, true>__tree_map_pointer_types<__value_type<unsigned short, int>, void *, __tree_key_value_types<__value_type<unsigned short, int>>, true> &const __tree_map_pointer_types<__value_type<unsigned short, int>, void *, __tree_key_value_types<__value_type<unsigned short, int>>, true>const __tree_map_pointer_types<__value_type<unsigned short, int>, void *, __tree_key_value_types<__value_type<unsigned short, int>>, true> &__size_type<allocator<__value_type<unsigned short, int>>, long, true>__size_type<allocator<__value_type<unsigned short, int>>, long, true> &const __size_type<allocator<__value_type<unsigned short, int>>, long, true>const __size_type<allocator<__value_type<unsigned short, int>>, long, true> &__const_void_pointer<__value_type<unsigned short, int> *, allocator<__value_type<unsigned short, int>>, false>__const_void_pointer<__value_type<unsigned short, int> *, allocator<__value_type<unsigned short, int>>, false> &const __const_void_pointer<__value_type<unsigned short, int> *, allocator<__value_type<unsigned short, int>>, false>const __const_void_pointer<__value_type<unsigned short, int> *, allocator<__value_type<unsigned short, int>>, false> &__pointer<__value_type<unsigned short, int>, allocator<__value_type<unsigned short, int>>, allocator<__value_type<unsigned short, int>>, true>__pointer<__value_type<unsigned short, int>, allocator<__value_type<unsigned short, int>>, allocator<__value_type<unsigned short, int>>, true> &const __pointer<__value_type<unsigned short, int>, allocator<__value_type<unsigned short, int>>, allocator<__value_type<unsigned short, int>>, true>const __pointer<__value_type<unsigned short, int>, allocator<__value_type<unsigned short, int>>, allocator<__value_type<unsigned short, int>>, true> &__const_pointer<__value_type<unsigned short, int>, __value_type<unsigned short, int> *, allocator<__value_type<unsigned short, int>>, true>__const_pointer<__value_type<unsigned short, int>, __value_type<unsigned short, int> *, allocator<__value_type<unsigned short, int>>, true> &const __const_pointer<__value_type<unsigned short, int>, __value_type<unsigned short, int> *, allocator<__value_type<unsigned short, int>>, true>const __const_pointer<__value_type<unsigned short, int>, __value_type<unsigned short, int> *, allocator<__value_type<unsigned short, int>>, true> &__void_pointer<__value_type<unsigned short, int> *, allocator<__value_type<unsigned short, int>>, false>__void_pointer<__value_type<unsigned short, int> *, allocator<__value_type<unsigned short, int>>, false> &const __void_pointer<__value_type<unsigned short, int> *, allocator<__value_type<unsigned short, int>>, false>const __void_pointer<__value_type<unsigned short, int> *, allocator<__value_type<unsigned short, int>>, false> &__alloc_traits_difference_type<allocator<__value_type<unsigned short, int>>, __value_type<unsigned short, int> *, true>__alloc_traits_difference_type<allocator<__value_type<unsigned short, int>>, __value_type<unsigned short, int> *, true> &const __alloc_traits_difference_type<allocator<__value_type<unsigned short, int>>, __value_type<unsigned short, int> *, true>const __alloc_traits_difference_type<allocator<__value_type<unsigned short, int>>, __value_type<unsigned short, int> *, true> &__propagate_on_container_move_assignment<allocator<__value_type<unsigned short, int>>, true>__propagate_on_container_move_assignment<allocator<__value_type<unsigned short, int>>, true> &const __propagate_on_container_move_assignment<allocator<__value_type<unsigned short, int>>, true>const __propagate_on_container_move_assignment<allocator<__value_type<unsigned short, int>>, true> &__is_always_equal<allocator<__value_type<unsigned short, int>>, true>__is_always_equal<allocator<__value_type<unsigned short, int>>, true> &const __is_always_equal<allocator<__value_type<unsigned short, int>>, true>const __is_always_equal<allocator<__value_type<unsigned short, int>>, true> &rebind_alloc<__tree_node<__value_type<unsigned short, int>, void *>>rebind_alloc<__tree_node<__value_type<unsigned short, int>, void *>> &const rebind_alloc<__tree_node<__value_type<unsigned short, int>, void *>>const rebind_alloc<__tree_node<__value_type<unsigned short, int>, void *>> &__rebind_pointer<void *, __tree_node<__value_type<unsigned short, int>, void *>>__rebind_pointer<void *, __tree_node<__value_type<unsigned short, int>, void *>> &const __rebind_pointer<void *, __tree_node<__value_type<unsigned short, int>, void *>>const __rebind_pointer<void *, __tree_node<__value_type<unsigned short, int>, void *>> &__compressed_pair_elem<__map_value_compare<unsigned short, __value_type<unsigned short, int>, less<unsigned short>, true>, 1, true>__compressed_pair_elem<__map_value_compare<unsigned short, __value_type<unsigned short, int>, less<unsigned short>, true>, 1, true> &const __compressed_pair_elem<__map_value_compare<unsigned short, __value_type<unsigned short, int>, less<unsigned short>, true>, 1, true>const __compressed_pair_elem<__map_value_compare<unsigned short, __value_type<unsigned short, int>, less<unsigned short>, true>, 1, true> &__compressed_pair_elem<allocator<__tree_node<__value_type<unsigned short, int>, void *>>, 1, true>__compressed_pair_elem<allocator<__tree_node<__value_type<unsigned short, int>, void *>>, 1, true> &const __compressed_pair_elem<allocator<__tree_node<__value_type<unsigned short, int>, void *>>, 1, true>const __compressed_pair_elem<allocator<__tree_node<__value_type<unsigned short, int>, void *>>, 1, true> &pointer_traits<__tree_node<__value_type<const unsigned char *, IfdId>, void *> *>pointer_traits<__tree_node<__value_type<const unsigned char *, IfdId>, void *> *> &const pointer_traits<__tree_node<__value_type<const unsigned char *, IfdId>, void *> *>const pointer_traits<__tree_node<__value_type<const unsigned char *, IfdId>, void *> *> &__rebind_pointer<void *, __value_type<const unsigned char *, IfdId>>__rebind_pointer<void *, __value_type<const unsigned char *, IfdId>> &const __rebind_pointer<void *, __value_type<const unsigned char *, IfdId>>const __rebind_pointer<void *, __value_type<const unsigned char *, IfdId>> &__rebind_pointer<void *, const __value_type<const unsigned char *, IfdId>>__rebind_pointer<void *, const __value_type<const unsigned char *, IfdId>> &const __rebind_pointer<void *, const __value_type<const unsigned char *, IfdId>>const __rebind_pointer<void *, const __value_type<const unsigned char *, IfdId>> &conditional<true, __tree_end_node<__tree_node_base<void *> *> *, __tree_node<__value_type<const unsigned char *, IfdId>, void *> *>conditional<true, __tree_end_node<__tree_node_base<void *> *> *, __tree_node<__value_type<const unsigned char *, IfdId>, void *> *> &const conditional<true, __tree_end_node<__tree_node_base<void *> *> *, __tree_node<__value_type<const unsigned char *, IfdId>, void *> *>const conditional<true, __tree_end_node<__tree_node_base<void *> *> *, __tree_node<__value_type<const unsigned char *, IfdId>, void *> *> &__tree_map_pointer_types<__value_type<const unsigned char *, IfdId>, void *, __tree_key_value_types<__value_type<const unsigned char *, IfdId>>, true>__tree_map_pointer_types<__value_type<const unsigned char *, IfdId>, void *, __tree_key_value_types<__value_type<const unsigned char *, IfdId>>, true> &const __tree_map_pointer_types<__value_type<const unsigned char *, IfdId>, void *, __tree_key_value_types<__value_type<const unsigned char *, IfdId>>, true>const __tree_map_pointer_types<__value_type<const unsigned char *, IfdId>, void *, __tree_key_value_types<__value_type<const unsigned char *, IfdId>>, true> &__size_type<allocator<__value_type<const unsigned char *, IfdId>>, long, true>__size_type<allocator<__value_type<const unsigned char *, IfdId>>, long, true> &const __size_type<allocator<__value_type<const unsigned char *, IfdId>>, long, true>const __size_type<allocator<__value_type<const unsigned char *, IfdId>>, long, true> &__const_void_pointer<__value_type<const unsigned char *, IfdId> *, allocator<__value_type<const unsigned char *, IfdId>>, false>__const_void_pointer<__value_type<const unsigned char *, IfdId> *, allocator<__value_type<const unsigned char *, IfdId>>, false> &const __const_void_pointer<__value_type<const unsigned char *, IfdId> *, allocator<__value_type<const unsigned char *, IfdId>>, false>const __const_void_pointer<__value_type<const unsigned char *, IfdId> *, allocator<__value_type<const unsigned char *, IfdId>>, false> &__pointer<__value_type<const unsigned char *, IfdId>, allocator<__value_type<const unsigned char *, IfdId>>, allocator<__value_type<const unsigned char *, IfdId>>, true>__pointer<__value_type<const unsigned char *, IfdId>, allocator<__value_type<const unsigned char *, IfdId>>, allocator<__value_type<const unsigned char *, IfdId>>, true> &const __pointer<__value_type<const unsigned char *, IfdId>, allocator<__value_type<const unsigned char *, IfdId>>, allocator<__value_type<const unsigned char *, IfdId>>, true>const __pointer<__value_type<const unsigned char *, IfdId>, allocator<__value_type<const unsigned char *, IfdId>>, allocator<__value_type<const unsigned char *, IfdId>>, true> &__const_pointer<__value_type<const unsigned char *, IfdId>, __value_type<const unsigned char *, IfdId> *, allocator<__value_type<const unsigned char *, IfdId>>, true>__const_pointer<__value_type<const unsigned char *, IfdId>, __value_type<const unsigned char *, IfdId> *, allocator<__value_type<const unsigned char *, IfdId>>, true> &const __const_pointer<__value_type<const unsigned char *, IfdId>, __value_type<const unsigned char *, IfdId> *, allocator<__value_type<const unsigned char *, IfdId>>, true>const __const_pointer<__value_type<const unsigned char *, IfdId>, __value_type<const unsigned char *, IfdId> *, allocator<__value_type<const unsigned char *, IfdId>>, true> &__void_pointer<__value_type<const unsigned char *, IfdId> *, allocator<__value_type<const unsigned char *, IfdId>>, false>__void_pointer<__value_type<const unsigned char *, IfdId> *, allocator<__value_type<const unsigned char *, IfdId>>, false> &const __void_pointer<__value_type<const unsigned char *, IfdId> *, allocator<__value_type<const unsigned char *, IfdId>>, false>const __void_pointer<__value_type<const unsigned char *, IfdId> *, allocator<__value_type<const unsigned char *, IfdId>>, false> &__alloc_traits_difference_type<allocator<__value_type<const unsigned char *, IfdId>>, __value_type<const unsigned char *, IfdId> *, true>__alloc_traits_difference_type<allocator<__value_type<const unsigned char *, IfdId>>, __value_type<const unsigned char *, IfdId> *, true> &const __alloc_traits_difference_type<allocator<__value_type<const unsigned char *, IfdId>>, __value_type<const unsigned char *, IfdId> *, true>const __alloc_traits_difference_type<allocator<__value_type<const unsigned char *, IfdId>>, __value_type<const unsigned char *, IfdId> *, true> &__propagate_on_container_move_assignment<allocator<__value_type<const unsigned char *, IfdId>>, true>__propagate_on_container_move_assignment<allocator<__value_type<const unsigned char *, IfdId>>, true> &const __propagate_on_container_move_assignment<allocator<__value_type<const unsigned char *, IfdId>>, true>const __propagate_on_container_move_assignment<allocator<__value_type<const unsigned char *, IfdId>>, true> &__is_always_equal<allocator<__value_type<const unsigned char *, IfdId>>, true>__is_always_equal<allocator<__value_type<const unsigned char *, IfdId>>, true> &const __is_always_equal<allocator<__value_type<const unsigned char *, IfdId>>, true>const __is_always_equal<allocator<__value_type<const unsigned char *, IfdId>>, true> &rebind_alloc<__tree_node<__value_type<const unsigned char *, IfdId>, void *>>rebind_alloc<__tree_node<__value_type<const unsigned char *, IfdId>, void *>> &const rebind_alloc<__tree_node<__value_type<const unsigned char *, IfdId>, void *>>const rebind_alloc<__tree_node<__value_type<const unsigned char *, IfdId>, void *>> &__rebind_pointer<void *, __tree_node<__value_type<const unsigned char *, IfdId>, void *>>__rebind_pointer<void *, __tree_node<__value_type<const unsigned char *, IfdId>, void *>> &const __rebind_pointer<void *, __tree_node<__value_type<const unsigned char *, IfdId>, void *>>const __rebind_pointer<void *, __tree_node<__value_type<const unsigned char *, IfdId>, void *>> &__compressed_pair_elem<__map_value_compare<const unsigned char *, __value_type<const unsigned char *, IfdId>, less<const unsigned char *>, true>, 1, true>__compressed_pair_elem<__map_value_compare<const unsigned char *, __value_type<const unsigned char *, IfdId>, less<const unsigned char *>, true>, 1, true> &const __compressed_pair_elem<__map_value_compare<const unsigned char *, __value_type<const unsigned char *, IfdId>, less<const unsigned char *>, true>, 1, true>const __compressed_pair_elem<__map_value_compare<const unsigned char *, __value_type<const unsigned char *, IfdId>, less<const unsigned char *>, true>, 1, true> &__compressed_pair_elem<allocator<__tree_node<__value_type<const unsigned char *, IfdId>, void *>>, 1, true>__compressed_pair_elem<allocator<__tree_node<__value_type<const unsigned char *, IfdId>, void *>>, 1, true> &const __compressed_pair_elem<allocator<__tree_node<__value_type<const unsigned char *, IfdId>, void *>>, 1, true>const __compressed_pair_elem<allocator<__tree_node<__value_type<const unsigned char *, IfdId>, void *>>, 1, true> &__rebind_pointer<void *, pair<const unsigned char *const, IfdId>>__rebind_pointer<void *, pair<const unsigned char *const, IfdId>> &const __rebind_pointer<void *, pair<const unsigned char *const, IfdId>>const __rebind_pointer<void *, pair<const unsigned char *const, IfdId>> &__rebind_pointer<void *, const pair<const unsigned char *const, IfdId>>__rebind_pointer<void *, const pair<const unsigned char *const, IfdId>> &const __rebind_pointer<void *, const pair<const unsigned char *const, IfdId>>const __rebind_pointer<void *, const pair<const unsigned char *const, IfdId>> &is_pointer<__tree_node<__value_type<const unsigned char *, IfdId>, void *> *>is_pointer<__tree_node<__value_type<const unsigned char *, IfdId>, void *> *> &const is_pointer<__tree_node<__value_type<const unsigned char *, IfdId>, void *> *>const is_pointer<__tree_node<__value_type<const unsigned char *, IfdId>, void *> *> &pointer_traits<pair<const unsigned char *const, IfdId> *>pointer_traits<pair<const unsigned char *const, IfdId> *> &const pointer_traits<pair<const unsigned char *const, IfdId> *>const pointer_traits<pair<const unsigned char *const, IfdId> *> &__rebind_pointer<void *, pair<const unsigned short, int>>__rebind_pointer<void *, pair<const unsigned short, int>> &const __rebind_pointer<void *, pair<const unsigned short, int>>const __rebind_pointer<void *, pair<const unsigned short, int>> &__rebind_pointer<void *, const pair<const unsigned short, int>>__rebind_pointer<void *, const pair<const unsigned short, int>> &const __rebind_pointer<void *, const pair<const unsigned short, int>>const __rebind_pointer<void *, const pair<const unsigned short, int>> &is_pointer<__tree_node<__value_type<unsigned short, int>, void *> *>is_pointer<__tree_node<__value_type<unsigned short, int>, void *> *> &const is_pointer<__tree_node<__value_type<unsigned short, int>, void *> *>const is_pointer<__tree_node<__value_type<unsigned short, int>, void *> *> &pointer_traits<pair<const unsigned short, int> *>pointer_traits<pair<const unsigned short, int> *> &const pointer_traits<pair<const unsigned short, int> *>const pointer_traits<pair<const unsigned short, int> *> &rebind<const __value_type<unsigned short, int>>rebind<const __value_type<unsigned short, int>> &const rebind<const __value_type<unsigned short, int>>const rebind<const __value_type<unsigned short, int>> &rebind<const pair<const unsigned short, int>>rebind<const pair<const unsigned short, int>> &const rebind<const pair<const unsigned short, int>>const rebind<const pair<const unsigned short, int>> &rebind<pair<const unsigned short, int>>rebind<pair<const unsigned short, int>> &const rebind<pair<const unsigned short, int>>const rebind<pair<const unsigned short, int>> &rebind<const __value_type<const unsigned char *, IfdId>>rebind<const __value_type<const unsigned char *, IfdId>> &const rebind<const __value_type<const unsigned char *, IfdId>>const rebind<const __value_type<const unsigned char *, IfdId>> &rebind<const pair<const unsigned char *const, IfdId>>rebind<const pair<const unsigned char *const, IfdId>> &const rebind<const pair<const unsigned char *const, IfdId>>const rebind<const pair<const unsigned char *const, IfdId>> &rebind<pair<const unsigned char *const, IfdId>>rebind<pair<const unsigned char *const, IfdId>> &const rebind<pair<const unsigned char *const, IfdId>>const rebind<pair<const unsigned char *const, IfdId>> &pointer_traits<__value_type<unsigned short, int> *>pointer_traits<__value_type<unsigned short, int> *> &const pointer_traits<__value_type<unsigned short, int> *>const pointer_traits<__value_type<unsigned short, int> *> &pointer_traits<__value_type<const unsigned char *, IfdId> *>pointer_traits<__value_type<const unsigned char *, IfdId> *> &const pointer_traits<__value_type<const unsigned char *, IfdId> *>const pointer_traits<__value_type<const unsigned char *, IfdId> *> &/Users/owura/Repos/codeql_eval/proj_repos/Exiv2-exiv2-pull-962-commits-e925bc5addd881543fa503470c8a859e112cca62/exiv2/src/metadatum.cpp/*rhs*//*
  File:      metadatum.cpp
  Author(s): Andreas Huggel (ahu) <ahuggel@gmx.net>
             Brad Schick (brad) <brad@robotbattle.com>
  History:   26-Jan-04, ahu: created
             31-Jul-04, brad: isolated as a component
 */auto_ptr_ref<Key>auto_ptr_ref<Key> &const auto_ptr_ref<Key>const auto_ptr_ref<Key> &auto_ptr<Key> &auto_ptr<Key> *operator std::__1::auto_ptr_ref<Exiv2::Key>operator Exiv2::Key *const basic_string_view<_CharT, _Traits> *basic_string_view<_CharT, _Traits> */Users/owura/Repos/codeql_eval/proj_repos/Exiv2-exiv2-pull-962-commits-e925bc5addd881543fa503470c8a859e112cca62/exiv2/src/minoltamn_int.hppMinoltaMakerNote &const MinoltaMakerNoteconst MinoltaMakerNote &MinoltaMakerNoteMINOLTAMN_INT_HPP_printMinoltaSonyFlashExposureCompprintMinoltaSonyZoneMatchingprintMinoltaSonyWhiteBalanceStdprintMinoltaSonyTeleconverterModelprintMinoltaSonyImageQualityprintMinoltaSonySceneModeprintMinoltaSonyRotationprintMinoltaSonyQualityCsprintMinoltaSonyPrioritySetupShutterReleaseprintMinoltaSonyDynamicRangeOptimizerModeprintMinoltaSonyLocalAFAreaPointprintMinoltaSonyAFAreaModeprintMinoltaSonyBoolInverseValueprintMinoltaSonyBoolValueprintMinoltaSonyColorModeprintMinoltaSonyLensIDtagInfoCsStd_tagInfoCs7D_tagInfoCs5D_tagInfoCsA100_printMinoltaExposureCompensation5DprintMinoltaExposureManualBias5DprintMinoltaBrightnessStdprintMinoltaWhiteBalanceStdprintMinoltaFlashExposureCompStdprintMinoltaTimeStdprintMinoltaDateStdprintMinoltaFocalLengthStdprintMinoltaExposureCompensationStdprintMinoltaFNumberStdprintMinoltaExposureTimeStdprintMinoltaExposureSpeedStdtagListCsA100tagListCs5DtagListCs7DtagListCsStd// #ifndef MINOLTAMN_INT_HPP_// TODO: Added shared methods here.//! Print Minolta/Sony FlashExposureComp values to readable labels.//! Print Minolta/Sony ZoneMatching values to readable labels.//! Print Minolta/Sony White Balance Std values to readable labels.//! Print Minolta/Sony Teleconverter Model values to readable labels.//! Print Minolta/Sony Image Quality values to readable labels.//! Print Minolta/Sony Scene Mode values to readable labels.//! Print Minolta/Sony Rotation values to readable labels.//! Print Minolta/Sony Quality values to readable labels.//! Print Minolta/Sony priority setup shutter release values to readable labels.//! Print Minolta/Sony dynamic range optimizer mode values to readable labels.//! Print Minolta/Sony Local AF Area Point values to readable labels.//! Print Minolta/Sony AF Area Mode values to readable labels.//! Print Minolta/Sony bool inverse function values to readable labels.//! Print Minolta/Sony bool function values to readable labels.//! Print Minolta/Sony Color Mode values to readable labels.//! Print Minolta/Sony Lens id values to readable labels.// -- Minolta and Sony MakerNote Common Values ---------------------------------------// class MinoltaMakerNote//! Print Exposure Compensation setting from 5D Minolta Camera Settings makernote//! Print Exposure Manual Bias setting from 5D Minolta Camera Settings makernote//! Print Brightness setting from standard Minolta Camera Settings makernote//! Print White Balance setting from standard Minolta Camera Settings makernote//! Print Flash Exposure Compensation setting from standard Minolta Camera Settings makernote//! Print Minolta Time from standard Minolta Camera Settings makernote//! Print Minolta Date from standard Minolta Camera Settings makernote//! Print Focal Length setting from standard Minolta Camera Settings makernote//! Print Exposure Compensation setting from standard Minolta Camera Settings makernote//! Print F Number setting from standard Minolta Camera Settings makernote//! Print Exposure Time setting from standard Minolta Camera Settings makernote//! Print Exposure Speed setting from standard Minolta Camera Settings makernote//! @name Print functions for Minolta %MakerNote tags//! Return read-only list of built-in Sony A100 Camera Settings tags//! Return read-only list of built-in Minolta 5D Camera Settings tags//! Return read-only list of built-in Minolta 7D Camera Settings tags//! Return read-only list of built-in Minolta Standard Camera Settings tags//! Return read-only list of built-in Minolta tags//! MakerNote for Minolta cameras/*!
  @file    minoltamn_int.hpp
  @brief   Minolta MakerNote implemented using the following references:<br>
           <a href="http://www.dalibor.cz/minolta/makernote.htm">Minolta Makernote Format Specification</a> by Dalibor Jelinek,<br>
           <a href="http://www.sno.phy.queensu.ca/~phil/exiftool/TagNames/Minolta.html">Minolta Makernote list</a> by Phil Harvey<br>
           <a href="http://www.ozhiker.com/electronics/pjmt/jpeg_info/minolta_mn.html">Minolta Makernote list from PHP JPEG Metadata Toolkit</a><br>
           Email communication with <a href="mailto:caulier dot gilles at gmail dot com">caulier dot gilles at gmail dot com</a><br>
           Some Minolta camera settings have been decoded by <a href="mailto:xraynaud@gmail.com">Xavier Raynaud</a> from digiKam project and added by Gilles Caulier.
  @author  Andreas Huggel (ahu)
           <a href="mailto:ahuggel@gmx.net">ahuggel@gmx.net</a>
  @author  Gilles Caulier (cgilles)
           <a href="mailto:caulier dot gilles at gmail dot com">caulier dot gilles at gmail dot com</a>
  @date    06-May-06, gc: submitted
 *//Users/owura/Repos/codeql_eval/proj_repos/Exiv2-exiv2-pull-962-commits-e925bc5addd881543fa503470c8a859e112cca62/exiv2/src/minoltamn_int.cpp"minoltamn_int.hpp" EV" EV"minoltaSonyZoneMatchingminoltaSonyWhiteBalanceStdminoltaSonyTeleconverterModelminoltaSonyImageQualityminoltaSonySceneModeminoltaSonyRotationminoltaSonyQualityCsminoltaSonyPrioritySetupShutterReleaseminoltaSonyDynamicRangeOptimizerModeminoltaSonyLocalAFAreaPointminoltaSonyAFAreaModeminoltaSonyBoolInverseFunctionminoltaSonyBoolFunctionminoltaSonyColorModeminolta"minolta"sony"sony"const LensIdFct[6]LensIdFct[6]const LensIdFct(&)[6]LensIdFct(&)[6]minoltaSonyLensIDresolveLens0xffffmaxApertureF1_8434/256"434/256"maxApertures926/256"926/256"1024/256"1024/256"1110/256"1110/256"1188/256"1188/256"1272/256"1272/256"ILCE-6000"ILCE-6000"focalL35mmfocalRatiolensIDresolveLens0xffF2_8760/256"760/256"SLT-A77V"SLT-A77V"resolveLens0x80F4resolveLens0x340x34resolveLens0x29lensDT 11-18mm F4.5-5.6"DT 11-18mm F4.5-5.6"0x29resolveLens0x1c100mm F2.8 Macro"100mm F2.8 Macro"resolvedLensconst TagDetails[205]TagDetails[205]const TagDetails(&)[205]TagDetails(&)[205]|"|"splitconst vector<basic_string<char, char_traits<char>, allocator<char>>, allocator<basic_string<char, char_traits<char>, allocator<char>>>> &trim 	
" \t\n\r\f\v"rtrimltrimgetKeyLonggetKeyString24.0whichconst TagInfo[79]TagInfo[79]const TagInfo[31]TagInfo[31]const TagInfo[51]TagInfo[51]const TagInfo[29]TagInfo[29]"ISO Setting Used""High Key""Low Key"ISO Setting UsedHigh KeyLow Key"Color Temperature/Color Filter"Color Temperature/Color Filter0x300x70"Minolta/Sony AF 1.4x APO (D) (0x04)""Minolta/Sony AF 2x APO (D) (0x05)""Minolta/Sony AF 2x APO (D)""Minolta AF 2x APO II""Minolta AF 2x APO""Minolta/Sony AF 1.4x APO (D)""Minolta AF 1.4x APO II""Minolta AF 1.4x APO"Minolta/Sony AF 1.4x APO (D) (0x04)Minolta/Sony AF 2x APO (D) (0x05)0x48Minolta/Sony AF 2x APO (D)Minolta AF 2x APO IIMinolta AF 2x APOMinolta/Sony AF 1.4x APO (D)0x90Minolta AF 1.4x APO II0xa0Minolta AF 1.4x APO"Super Fine""Extra Fine""Raw + JPEG""Compressed Raw""Compressed Raw + JPEG"Super FineExtra FineRaw + JPEGCompressed RawCompressed Raw + JPEG"Night Portrait""Night View/Portrait"Night PortraitNight View/Portrait"Horizontal (normal)""Rotate 90 CW""Rotate 270 CW"Horizontal (normal)Rotate 90 CWRotate 270 CW"CRAW""RAW+JPEG""CRAW+JPEG"CRAWRAW+JPEGCRAW+JPEG"AF""Release"AFRelease"Advanced Auto""Advanced Level"Advanced AutoAdvanced Level"Top""Top-Right""Bottom-Right""Bottom""Bottom-Left""Top-Left""Far-Right""Far-Left"TopTop-RightBottom-RightBottomBottom-LeftTop-LeftFar-RightFar-Left"Local"Local"Vivid Color""AdobeRGB""Clear""Deep""Light""Night View""Autumn Leaves"const TagDetails[15]TagDetails[15]Vivid ColorAdobeRGBDeepLightNight ViewAutumn LeavesMinolta AF 28-85mm F3.5-4.5 New"Minolta AF 28-85mm F3.5-4.5 New"Minolta AF 80-200mm F2.8 HS-APO G"Minolta AF 80-200mm F2.8 HS-APO G"Minolta AF 28-70mm F2.8 G"Minolta AF 28-70mm F2.8 G"Minolta AF 28-80mm F4-5.6"Minolta AF 28-80mm F4-5.6"Minolta AF 85mm F1.4G"Minolta AF 85mm F1.4G"Minolta AF 35-70mm F3.5-4.5 [II]"Minolta AF 35-70mm F3.5-4.5 [II]"Minolta AF 24-85mm F3.5-4.5 [New]"Minolta AF 24-85mm F3.5-4.5 [New]"Minolta AF 100-300mm F4.5-5.6 (D) APO [New] | Minolta AF 100-400mm F4.5-6.7 (D) | Sigma AF 100-300mm F4 EX DG IF"Minolta AF 100-300mm F4.5-5.6 (D) APO [New] | "
                 "Minolta AF 100-400mm F4.5-6.7 (D) | "
                 "Sigma AF 100-300mm F4 EX DG IF"const char[113]char[113]Minolta AF 70-210mm F4.5-5.6 [II]"Minolta AF 70-210mm F4.5-5.6 [II]"Minolta AF 50mm F3.5 Macro"Minolta AF 50mm F3.5 Macro"Minolta AF 28-105mm F3.5-4.5 [New]"Minolta AF 28-105mm F3.5-4.5 [New]"Minolta AF 300mm F4 HS-APO G"Minolta AF 300mm F4 HS-APO G"Minolta AF 100mm F2.8 Soft Focus"Minolta AF 100mm F2.8 Soft Focus"Minolta AF 75-300mm F4.5-5.6 (New or II)"Minolta AF 75-300mm F4.5-5.6 (New or II)"Minolta AF 100-400mm F4.5-6.7 APO"Minolta AF 100-400mm F4.5-6.7 APO"Minolta AF 400mm F4.5 HS-APO G"Minolta AF 400mm F4.5 HS-APO G"Minolta AF 17-35mm F3.5 G"Minolta AF 17-35mm F3.5 G"Minolta AF 20-35mm F3.5-4.5"Minolta AF 20-35mm F3.5-4.5"Minolta AF 28-80mm F3.5-5.6 II"Minolta AF 28-80mm F3.5-5.6 II"Minolta AF 35mm F1.4 G"Minolta AF 35mm F1.4 G"Minolta/Sony 135mm F2.8 [T4.5] STF"Minolta/Sony 135mm F2.8 [T4.5] STF"Minolta AF 35-80mm F4-5.6 II"Minolta AF 35-80mm F4-5.6 II"Minolta AF 200mm F4 Macro APO G"Minolta AF 200mm F4 Macro APO G"Minolta/Sony AF 24-105mm F3.5-4.5 (D) | Sigma 18-50mm F2.8 | Sigma 17-70mm F2.8-4.5 (D) | Sigma 20-40mm F2.8 EX DG Aspherical IF | Sigma 18-200mm F3.5-6.3 DC | Sigma DC 18-125mm F4-5,6 D | Tamron SP AF 28-75mm F2.8 XR Di LD Aspherical [IF] Macro"Minolta/Sony AF 24-105mm F3.5-4.5 (D) | "
                 "Sigma 18-50mm F2.8 | "
                 "Sigma 17-70mm F2.8-4.5 (D) | "
                 "Sigma 20-40mm F2.8 EX DG Aspherical IF | "
                 "Sigma 18-200mm F3.5-6.3 DC | "
                 "Sigma DC 18-125mm F4-5,6 D | "
                 "Tamron SP AF 28-75mm F2.8 XR Di LD Aspherical [IF] Macro"const char[246]char[246]Minolta AF 100-300mm F4.5-5.6 APO (D) | Sigma 100-300mm F4 EX (APO (D) or D IF) | Sigma 70mm F2.8 EX DG Macro | Sigma 20mm F1.8 EX DG Aspherical RF | Sigma 30mm F1.4 DG EX | Sigma 24mm F1.8 EX DG ASP Macro"Minolta AF 100-300mm F4.5-5.6 APO (D) | "
                 "Sigma 100-300mm F4 EX (APO (D) or D IF) | "
                 "Sigma 70mm F2.8 EX DG Macro | "
                 "Sigma 20mm F1.8 EX DG Aspherical RF | "
                 "Sigma 30mm F1.4 DG EX | "
                 "Sigma 24mm F1.8 EX DG ASP Macro"Minolta AF 85mm F1.4 G (D)"Minolta AF 85mm F1.4 G (D)"Minolta/Sony AF 100mm F2.8 Macro (D) | Tamron SP AF 90mm F2.8 Di Macro | Tamron SP AF 180mm F3.5 SP Di LD [IF] Macro"Minolta/Sony AF 100mm F2.8 Macro (D) | "                               // 1
                 "Tamron SP AF 90mm F2.8 Di Macro | "                                    // 2
                 "Tamron SP AF 180mm F3.5 SP Di LD [IF] Macro"const char[117]char[117]Minolta/Sony AF 75-300mm F4.5-5.6 (D) "Minolta/Sony AF 75-300mm F4.5-5.6 (D) "Minolta AF 28-80mm F3.5-5.6 (D) | Sigma AF 10-20mm F4-5.6 EX DC | Sigma AF 12-24mm F4.5-5.6 EX DG | Sigma 28-70mm EX DG F2.8 | Sigma 55-200mm F4-5.6 DC"Minolta AF 28-80mm F3.5-5.6 (D) | "
                 "Sigma AF 10-20mm F4-5.6 EX DC | "
                 "Sigma AF 12-24mm F4.5-5.6 EX DG | "
                 "Sigma 28-70mm EX DG F2.8 | "
                 "Sigma 55-200mm F4-5.6 DC"const char[152]char[152]Minolta/Sony AF 50mm F2.8 Macro (D) | Minolta/Sony AF 50mm F3.5 Macro"Minolta/Sony AF 50mm F2.8 Macro (D) | "
                 "Minolta/Sony AF 50mm F3.5 Macro"Minolta AF 100-400mm F4.5-6.7 (D) | Minolta/Sony AF 300mm F2.8G APO (D) SSM"Minolta AF 100-400mm F4.5-6.7 (D) | "
                 "Minolta/Sony AF 300mm F2.8G APO (D) SSM"Minolta/Sony AF 70-200mm F2.8 APO G (D) SSM"Minolta/Sony AF 70-200mm F2.8 APO G (D) SSM"Minolta AF 85mm F1.4 G (D) Limited"Minolta AF 85mm F1.4 G (D) Limited"Minolta AF 28-100mm F3.5-5.6 (D)"Minolta AF 28-100mm F3.5-5.6 (D)"Minolta AF 17-35mm F2.8-4 (D)"Minolta AF 17-35mm F2.8-4 (D)"Minolta AF 28-75mm F2.8 (D)"Minolta AF 28-75mm F2.8 (D)"Minolta/Sony AF DT 18-70mm F3.5-5.6 (D) | Sony AF DT 18-200mm F3.5-6.3"Minolta/Sony AF DT 18-70mm F3.5-5.6 (D) | "
                 "Sony AF DT 18-200mm F3.5-6.3"Minolta/Sony AF DT 11-18mm F4.5-5.6 (D) | Tamron SP AF 11-18mm F4.5-5.6 Di II LD Aspherical IF"Minolta/Sony AF DT 11-18mm F4.5-5.6 (D) | "                            // 1
                 "Tamron SP AF 11-18mm F4.5-5.6 Di II LD Aspherical IF"const char[95]char[95]Minolta/Sony AF DT 18-200mm F3.5-6.3 (D)"Minolta/Sony AF DT 18-200mm F3.5-6.3 (D)"Sony 35mm F1.4 G (SAL35F14G)"Sony 35mm F1.4 G (SAL35F14G)"Sony 50mm F1.4 (SAL50F14)"Sony 50mm F1.4 (SAL50F14)"Carl Zeiss Planar T* 85mm F1.4 ZA (SAL85F14Z)"Carl Zeiss Planar T* 85mm F1.4 ZA (SAL85F14Z)"Carl Zeiss Vario-Sonnar T* DT 16-80mm F3.5-4.5 ZA (SAL1680Z)"Carl Zeiss Vario-Sonnar T* DT 16-80mm F3.5-4.5 ZA (SAL1680Z)"Carl Zeiss Sonnar T* 135mm F1.8 ZA (SAL135F18Z)"Carl Zeiss Sonnar T* 135mm F1.8 ZA (SAL135F18Z)"Carl Zeiss Vario-Sonnar T* 24-70mm F2.8 ZA SSM (SAL2470Z) | Carl Zeiss Vario-Sonnar T* 24-70mm F2.8 ZA SSM II (SAL2470Z2)"Carl Zeiss Vario-Sonnar T* 24-70mm F2.8 ZA SSM (SAL2470Z) | "
                 "Carl Zeiss Vario-Sonnar T* 24-70mm F2.8 ZA SSM II (SAL2470Z2)"const char[122]char[122]Sony AF DT 55-200mm F4-5.6 (SAL55200)"Sony AF DT 55-200mm F4-5.6 (SAL55200)"Sony AF DT 18-250mm F3.5-6.3 (SAL18250)"Sony AF DT 18-250mm F3.5-6.3 (SAL18250)"Sony AF DT 16-105mm F3.5-5.6 (SAL16105)"Sony AF DT 16-105mm F3.5-5.6 (SAL16105)"Sony 70-300mm F4.5-5.6 G SSM (SAL70300G) | Sony 70-300mm F4.5-5.6 G SSM II (SAL70300G2) | Tamron SP 70-300mm F4-5.6 Di USD | Tamron SP AF 17-50mm F2.8 XR Di II LD Aspherical"Sony 70-300mm F4.5-5.6 G SSM (SAL70300G) | "                           // 1
                 "Sony 70-300mm F4.5-5.6 G SSM II (SAL70300G2) | "                       // 2
                 "Tamron SP 70-300mm F4-5.6 Di USD | "                                   // 3
                 "Tamron SP AF 17-50mm F2.8 XR Di II LD Aspherical"const char[174]char[174]Sony AF 70-400mm F4.5-5.6 G SSM (SAL70400G)"Sony AF 70-400mm F4.5-5.6 G SSM (SAL70400G)"Carl Zeiss Vario-Sonnar T* 16-35mm F2.8 ZA SSM (SAL1635Z) | Carl Zeiss Vario-Sonnar T* 16-35mm F2.8 ZA SSM II (SAL1635Z2)"Carl Zeiss Vario-Sonnar T* 16-35mm F2.8 ZA SSM (SAL1635Z) | "
                 "Carl Zeiss Vario-Sonnar T* 16-35mm F2.8 ZA SSM II (SAL1635Z2)"Sony DT 18-55mm F3.5-5.6 SAM (SAL1855) | Sony DT 18-55mm F3.5-5.6 SAM II (SAL18552)"Sony DT 18-55mm F3.5-5.6 SAM (SAL1855) | "
                 "Sony DT 18-55mm F3.5-5.6 SAM II (SAL18552)"Sony AF DT 55-200mm F4-5.6 SAM (SAL55200-2)"Sony AF DT 55-200mm F4-5.6 SAM (SAL55200-2)"Sony DT 50mm F1.8 SAM (SAL50F18) | Tamron SP AF 60mm F2 Di II LD [IF] Macro 1:1 | Tamron 18-270mm F3.5-6.3 Di II PZD"Sony DT 50mm F1.8 SAM (SAL50F18) | "
                 "Tamron SP AF 60mm F2 Di II LD [IF] Macro 1:1 | "
                 "Tamron 18-270mm F3.5-6.3 Di II PZD"Sony AF DT 30mm F2.8 SAM Macro (SAL30M28)"Sony AF DT 30mm F2.8 SAM Macro (SAL30M28)"Sony 28-75mm F2.8 SAM (SAL2875)"Sony 28-75mm F2.8 SAM (SAL2875)"Carl Zeiss Distagon T* 24mm F2 ZA SSM (SAL24F20Z)"Carl Zeiss Distagon T* 24mm F2 ZA SSM (SAL24F20Z)"Sony 85mm F2.8 SAM (SAL85F28)"Sony 85mm F2.8 SAM (SAL85F28)"Sony DT 35mm F1.8 SAM (SAL35F18)"Sony DT 35mm F1.8 SAM (SAL35F18)"Sony DT 16-50mm F2.8 SSM (SAL1650)"Sony DT 16-50mm F2.8 SSM (SAL1650)"Sony 500mm F4.0 G SSM (SAL500F40G)"Sony 500mm F4.0 G SSM (SAL500F40G)"Sony DT 18-135mm F3.5-5.6 SAM (SAL18135)"Sony DT 18-135mm F3.5-5.6 SAM (SAL18135)"Sony 300mm F2.8 G SSM II (SAL300F28G2)"Sony 300mm F2.8 G SSM II (SAL300F28G2)"Sony 70-200mm F2.8 G SSM II (SAL70200G2)"Sony 70-200mm F2.8 G SSM II (SAL70200G2)"Sony DT 55-300mm F4.5-5.6 SAM (SAL55300)"Sony DT 55-300mm F4.5-5.6 SAM (SAL55300)"Sony 70-400mm F4-5.6 G SSM II (SAL70400G2)"Sony 70-400mm F4-5.6 G SSM II (SAL70400G2)"Sony Carl Zeiss Planar T* 50mm F1.4 ZA SSM (SALF0F14Z)"Sony Carl Zeiss Planar T* 50mm F1.4 ZA SSM (SALF0F14Z)"Sigma 70-200mm F2.8 APO EX DG MACRO | Tamron AF 18-200mm F3.5-6.3 XR Di II LD Aspherical [IF] Macro | Tamron AF 28-300mm F3.5-6.3 XR Di LD Aspherical [IF] Macro | Tamron 80-300mm F3.5-6.3 | Tamron AF 28-200mm F3.8-5.6 XR Di Aspherical [IF] MACRO | Tamron SP AF 17-35mm F2.8-4 Di LD Aspherical IF | Sigma AF 50-150mm F2.8 EX DC APO HSM II | Sigma 10-20mm F3.5 EX DC HSM | Sigma 70-200mm F2.8 II EX DG APO MACRO HSM | Sigma 10mm F2.8 EX DC HSM Fisheye | Sigma 50mm F1.4 EX DG HSM | Sigma 85mm F1.4 EX DG HSM | Sigma 24-70mm F2.8 IF EX DG HSM | Sigma 18-250mm F3.5-6.3 DC OS HSM | Sigma 17-50mm F2.8 EX DC HSM | Sigma 17-70mm F2.8-4 DC Macro HSM | Sigma 150mm F2.8 EX DG OS HSM APO Macro | Sigma 150-500mm F5-6.3 APO DG OS HSM | Tamron AF 28-105mm F4-5.6 [IF] | Sigma 35mm F1.4 DG HSM | Sigma 18-35mm F1.8 DC HSM | Sigma 50-500mm F4.5-6.3 APO DG OS HSM | Sigma 24-105mm F4 DG HSM | Art 013"Sigma 70-200mm F2.8 APO EX DG MACRO | "                                // 1
                 "Tamron AF 18-200mm F3.5-6.3 XR Di II LD Aspherical [IF] Macro | "      // 2
                 "Tamron AF 28-300mm F3.5-6.3 XR Di LD Aspherical [IF] Macro | "         // 3
                 "Tamron 80-300mm F3.5-6.3 | "                                           // 4
                 "Tamron AF 28-200mm F3.8-5.6 XR Di Aspherical [IF] MACRO | "            // 5
                 "Tamron SP AF 17-35mm F2.8-4 Di LD Aspherical IF | "                    // 6
                 "Sigma AF 50-150mm F2.8 EX DC APO HSM II | "                            // 7
                 "Sigma 10-20mm F3.5 EX DC HSM | "                                       // 8
                 "Sigma 70-200mm F2.8 II EX DG APO MACRO HSM | "                         // 9
                 "Sigma 10mm F2.8 EX DC HSM Fisheye | "                                  // 10
                 "Sigma 50mm F1.4 EX DG HSM | "                                          // 11
                 "Sigma 85mm F1.4 EX DG HSM | "                                          // 12
                 "Sigma 24-70mm F2.8 IF EX DG HSM | "                                    // 13
                 "Sigma 18-250mm F3.5-6.3 DC OS HSM | "                                  // 14
                 "Sigma 17-50mm F2.8 EX DC HSM | "                                       // 15
                 "Sigma 17-70mm F2.8-4 DC Macro HSM | "                                  // 16
                 "Sigma 150mm F2.8 EX DG OS HSM APO Macro | "                            // 17
                 "Sigma 150-500mm F5-6.3 APO DG OS HSM | "                               // 18
                 "Tamron AF 28-105mm F4-5.6 [IF] | "                                     // 19
                 "Sigma 35mm F1.4 DG HSM | "                                             // 20
                 "Sigma 18-35mm F1.8 DC HSM | "                                          // 21
                 "Sigma 50-500mm F4.5-6.3 APO DG OS HSM | "                              // 22
                 "Sigma 24-105mm F4 DG HSM | Art 013"const char[887]char[887]Tamron 200-400mm F5.6 LD | Tamron 70-300mm F4-5.6 LD"Tamron 200-400mm F5.6 LD | "
                 "Tamron 70-300mm F4-5.6 LD"Tamron 20-40mm F2.7-3.5 SP Aspherical IF"Tamron 20-40mm F2.7-3.5 SP Aspherical IF"Vivitar 28-210mm F3.5-5.6"Vivitar 28-210mm F3.5-5.6"Tokina EMZ M100 AF 100mm F3.5"Tokina EMZ M100 AF 100mm F3.5"Cosina 70-210mm F2.8-4 AF"Cosina 70-210mm F2.8-4 AF"Soligor 19-35mm F3.5-4.5"Soligor 19-35mm F3.5-4.5"Tokina AF 28-300mm F4-6.3"Tokina AF 28-300mm F4-6.3"Voigtlander 70-300mm F4.5-5.6"Voigtlander 70-300mm F4.5-5.6"Voigtlander Macro APO-Lanthar 125mm F2.5 SL"Voigtlander Macro APO-Lanthar 125mm F2.5 SL"Tamron SP AF 17-50mm F2.8 XR Di II LD Aspherical [IF]"Tamron SP AF 17-50mm F2.8 XR Di II LD Aspherical [IF]"Tamron SP AF 70-200mm F2.8 Di LD [IF] Macro"Tamron SP AF 70-200mm F2.8 Di LD [IF] Macro"Tamron SP 70-200mm F2.8 Di USD"Tamron SP 70-200mm F2.8 Di USD"Tamron SP 24-70mm F2.8 Di USD"Tamron SP 24-70mm F2.8 Di USD"Tamron 28-300mm F3.5-6.3 Di PZD"Tamron 28-300mm F3.5-6.3 Di PZD"Tamron 16-300mm F3.5-6.3 Di II PZD Macro"Tamron 16-300mm F3.5-6.3 Di II PZD Macro"Tamron Tamron SP 150-600mm F5-6.3 Di USD"Tamron Tamron SP 150-600mm F5-6.3 Di USD"Tamron SP 15-30mm F2.8 Di USD"Tamron SP 15-30mm F2.8 Di USD"Tamron SP 90mm F2.8 Di Macro 1:1 USD (F017)"Tamron SP 90mm F2.8 Di Macro 1:1 USD (F017)"Tamron SP 90mm F2.8 Di Macro 1:1 USD (F004)"Tamron SP 90mm F2.8 Di Macro 1:1 USD (F004)"Tamron SP AF 17-50mm F2.8 XR Di II LD Aspherical | Tamron AF 18-250mm F3.5-6.3 XR Di II LD | Tamron AF 55-200mm F4-5.6 Di II LD Macro | Tamron AF 70-300mm F4-5.6 Di LD Macro 1:2 | Tamron SP AF 200-500mm F5.0-6.3 Di LD IF | Tamron SP AF 10-24mm F3.5-4.5 Di II LD Aspherical IF | Tamron SP AF 70-200mm F2.8 Di LD IF Macro | Tamron SP AF 28-75mm F2.8 XR Di LD Aspherical IF | Tamron AF 90-300mm F4.5-5.6 Telemacro"Tamron SP AF 17-50mm F2.8 XR Di II LD Aspherical | "                   // 1
                 "Tamron AF 18-250mm F3.5-6.3 XR Di II LD | "                            // 2
                 "Tamron AF 55-200mm F4-5.6 Di II LD Macro | "                           // 3
                 "Tamron AF 70-300mm F4-5.6 Di LD Macro 1:2 | "                          // 4
                 "Tamron SP AF 200-500mm F5.0-6.3 Di LD IF | "                           // 5
                 "Tamron SP AF 10-24mm F3.5-4.5 Di II LD Aspherical IF | "               // 6
                 "Tamron SP AF 70-200mm F2.8 Di LD IF Macro | "                          // 7
                 "Tamron SP AF 28-75mm F2.8 XR Di LD Aspherical IF | "                   // 8
                 "Tamron AF 90-300mm F4.5-5.6 Telemacro"const char[411]char[411]25500Minolta AF 50mm F1.7"Minolta AF 50mm F1.7"2550125510Minolta AF 35-70mm F4"Minolta AF 35-70mm F4"25511Minolta AF 35-70mm F4 | Sigma UC AF 28-70mm F3.5-4.5 | Sigma AF 28-70mm F2.8 | Sigma M-AF 70-200mm F2.8 EX Aspherical | Quantaray M-AF 35-80mm F4-5.6 | Tokina 28-70mm F2.8-4.5 AF"Minolta AF 35-70mm F4 | "
                 "Sigma UC AF 28-70mm F3.5-4.5 | "
                 "Sigma AF 28-70mm F2.8 | "
                 "Sigma M-AF 70-200mm F2.8 EX Aspherical | "
                 "Quantaray M-AF 35-80mm F4-5.6 | "
                 "Tokina 28-70mm F2.8-4.5 AF"const char[179]char[179]25520Minolta AF 28-85mm F3.5-4.5"Minolta AF 28-85mm F3.5-4.5"25521Minolta AF 28-85mm F3.5-4.5 | Tokina 19-35mm F3.5-4.5 | Tokina 28-70mm F2.8 AT-X | Tokina 80-400mm F4.5-5.6 AT-X AF II 840 | Tokina AF PRO 28-80mm F2.8 AT-X 280 | Tokina AT-X PRO [II] AF 28-70mm F2.6-2.8 270 | Tamron AF 19-35mm F3.5-4.5 | Angenieux AF 28-70mm F2.6 | Tokina AT-X 17 AF 17mm F3.5 | Tokina 20-35mm F3.5-4.5 II AF"Minolta AF 28-85mm F3.5-4.5 | "
                 "Tokina 19-35mm F3.5-4.5 | "
                 "Tokina 28-70mm F2.8 AT-X | "
                 "Tokina 80-400mm F4.5-5.6 AT-X AF II 840 | "
                 "Tokina AF PRO 28-80mm F2.8 AT-X 280 | "
                 "Tokina AT-X PRO [II] AF 28-70mm F2.6-2.8 270 | "
                 "Tamron AF 19-35mm F3.5-4.5 | "
                 "Angenieux AF 28-70mm F2.6 | "
                 "Tokina AT-X 17 AF 17mm F3.5 | "
                 "Tokina 20-35mm F3.5-4.5 II AF"const char[327]char[327]25530Minolta AF 28-135mm F4-4.5"Minolta AF 28-135mm F4-4.5"25531Minolta AF 28-135mm F4-4.5 | Sigma ZOOM-alpha 35-135mm F3.5-4.5 | Sigma 28-105mm F2.8-4 Aspherical | Sigma 28-105mm F4-5.6 UC"Minolta AF 28-135mm F4-4.5 | "
                 "Sigma ZOOM-alpha 35-135mm F3.5-4.5 | "
                 "Sigma 28-105mm F2.8-4 Aspherical | "
                 "Sigma 28-105mm F4-5.6 UC"const char[126]25540Minolta AF 35-105mm F3.5-4.5"Minolta AF 35-105mm F3.5-4.5"2554125550Minolta AF 70-210mm F4"Minolta AF 70-210mm F4"25551Minolta AF 70-210mm F4 Macro | Sigma 70-210mm F4-5.6 APO | Sigma M-AF 70-200mm F2.8 EX APO | Sigma 75-200mm F2.8-3.5"Minolta AF 70-210mm F4 Macro | "
                 "Sigma 70-210mm F4-5.6 APO | "
                 "Sigma M-AF 70-200mm F2.8 EX APO | "
                 "Sigma 75-200mm F2.8-3.5"25560Minolta AF 135mm F2.8"Minolta AF 135mm F2.8"2556125570Minolta AF 28mm F2.8"Minolta AF 28mm F2.8"25571Minolta/Sony AF 28mm F2.8"Minolta/Sony AF 28mm F2.8"25580Minolta AF 24-50mm F4"Minolta AF 24-50mm F4"2558125600Minolta AF 100-200mm F4.5"Minolta AF 100-200mm F4.5"2560125610Minolta AF 75-300mm F4.5-5.6"Minolta AF 75-300mm F4.5-5.6"25611Minolta AF 75-300mm F4.5-5.6 | Sigma 70-300mm F4-5.6 DL Macro | Sigma 300mm F4 APO Macro | Sigma AF 500mm F4.5 APO | Sigma AF 170-500mm F5-6.3 APO Aspherical | Tokina AT-X AF 300mm F4 | Tokina AT-X AF 400mm F5.6 SD | Tokina AF 730 II 75-300mm F4.5-5.6 | Sigma 800mm F5.6 APO | Sigma AF 400mm F5.6 APO Macro"Minolta AF 75-300mm F4.5-5.6 | "
                 "Sigma 70-300mm F4-5.6 DL Macro | "
                 "Sigma 300mm F4 APO Macro | "
                 "Sigma AF 500mm F4.5 APO | "
                 "Sigma AF 170-500mm F5-6.3 APO Aspherical | "
                 "Tokina AT-X AF 300mm F4 | "
                 "Tokina AT-X AF 400mm F5.6 SD | "
                 "Tokina AF 730 II 75-300mm F4.5-5.6 | "
                 "Sigma 800mm F5.6 APO | "
                 "Sigma AF 400mm F5.6 APO Macro"const char[307]char[307]25620Minolta AF 50mm F1.4"Minolta AF 50mm F1.4"25621Minolta AF 50mm F1.4 [New]"Minolta AF 50mm F1.4 [New]"25630Minolta AF 300mm F2.8G APO"Minolta AF 300mm F2.8G APO"25631Minolta AF 300mm F2.8 APO | Sigma AF 50-500mm F4-6.3 EX DG APO | Sigma AF 170-500mm F5-6.3 APO Aspherical | Sigma AF 500mm F4.5 EX DG APO | Sigma 400mm F5.6 APO"Minolta AF 300mm F2.8 APO | "
                 "Sigma AF 50-500mm F4-6.3 EX DG APO | "
                 "Sigma AF 170-500mm F5-6.3 APO Aspherical | "
                 "Sigma AF 500mm F4.5 EX DG APO | "
                 "Sigma 400mm F5.6 APO"const char[161]char[161]25640Minolta AF 50mm F2.8 Macro"Minolta AF 50mm F2.8 Macro"25641Minolta AF 50mm F2.8 Macro | Sigma 50mm F2.8 EX Macro"Minolta AF 50mm F2.8 Macro | "
                 "Sigma 50mm F2.8 EX Macro"25650Minolta AF 600mm F4 APO"Minolta AF 600mm F4 APO"2565125660Minolta AF 24mm F2.8"Minolta AF 24mm F2.8"25661Minolta AF 24mm F2.8 | Sigma 17-35mm F2.8-4.0 EX-D"Minolta AF 24mm F2.8 | "
                 "Sigma 17-35mm F2.8-4.0 EX-D"25720Minolta AF 500mm F8 Reflex"Minolta AF 500mm F8 Reflex"25721Minolta/Sony AF 500mm F8 Reflex"Minolta/Sony AF 500mm F8 Reflex"25780Minolta/Sony AF 16mm F2.8 Fisheye"Minolta/Sony AF 16mm F2.8 Fisheye"25781Minolta/Sony AF 16mm F2.8 Fisheye | Sigma 8mm F4 EX [DG] Fisheye | Sigma 14mm F3.5 | Sigma 15mm F2.8 Fisheye"Minolta/Sony AF 16mm F2.8 Fisheye | "
                 "Sigma 8mm F4 EX [DG] Fisheye | "
                 "Sigma 14mm F3.5 | "
                 "Sigma 15mm F2.8 Fisheye"25790Minolta AF 20mm F2.8"Minolta AF 20mm F2.8"25791Minolta/Sony AF 20mm F2.8 | Tokina AT-X 116 PRO DX AF 11-16mm F2.8"Minolta/Sony AF 20mm F2.8 | "
                 "Tokina AT-X 116 PRO DX AF 11-16mm F2.8"25810Minolta AF 100mm F2.8 Macro"Minolta AF 100mm F2.8 Macro"25811Minolta AF 100mm F2.8 Macro [New] | Sigma AF 90mm F2.8 Macro | Sigma AF 105mm F2.8 EX [DG] Macro | Sigma 180mm F5.6 Macro | Sigma 180mm F3.5 EX DG Macro | Tamron 90mm F2.8 Macro"Minolta AF 100mm F2.8 Macro [New] | "
                 "Sigma AF 90mm F2.8 Macro | "
                 "Sigma AF 105mm F2.8 EX [DG] Macro | "
                 "Sigma 180mm F5.6 Macro | "
                 "Sigma 180mm F3.5 EX DG Macro | "
                 "Tamron 90mm F2.8 Macro"const char[178]char[178]2585025851Beroflex 35-135mm F3.5-4.5"Beroflex 35-135mm F3.5-4.5"25858Minolta AF 35-105mm F3.5-4.5 New | Tamron 24-135mm F3.5-5.6"Minolta AF 35-105mm F3.5-4.5 New | "
                 "Tamron 24-135mm F3.5-5.6"25880Minolta AF 70-210mm F3.5-4.5"Minolta AF 70-210mm F3.5-4.5"2588125890Minolta AF 80-200mm F2.8 APO"Minolta AF 80-200mm F2.8 APO"25891Minolta AF 80-200mm F2.8 APO | Tokina 80-200mm F2.8"Minolta AF 80-200mm F2.8 APO | "
                 "Tokina 80-200mm F2.8"25900Minolta AF 200mm F2.8 G APO + Minolta AF 1.4x APO"Minolta AF 200mm F2.8 G APO + Minolta AF 1.4x APO"25901Minolta AF 200mm F2.8 G APO + Minolta AF 1.4x APO | Minolta AF 600mm F4 HS-APO G + Minolta AF 1.4x APO"Minolta AF 200mm F2.8 G APO + Minolta AF 1.4x APO | "
                 "Minolta AF 600mm F4 HS-APO G + Minolta AF 1.4x APO"25910Minolta AF 35mm F1.4G"Minolta AF 35mm F1.4G"25911Minolta AF 35mm F1.4"Minolta AF 35mm F1.4"2592025921Minolta AF 85mm F1.4G (D)"Minolta AF 85mm F1.4G (D)"25930Minolta AF 200mm F2.8 APO"Minolta AF 200mm F2.8 APO"2593125940Minolta AF 3X-1X F1.7-2.8 Macro"Minolta AF 3X-1X F1.7-2.8 Macro"25941Minolta AF 3x-1x F1.7-2.8 Macro"Minolta AF 3x-1x F1.7-2.8 Macro"25960Minolta AF 28mm F2"Minolta AF 28mm F2"2596125970Minolta AF 35mm F2"Minolta AF 35mm F2"25971Minolta AF 35mm F2 [New]"Minolta AF 35mm F2 [New]"25980Minolta AF 100mm F2"Minolta AF 100mm F2"2598126010Minolta AF 200mm F2.8 G APO + Minolta AF 2x APO"Minolta AF 200mm F2.8 G APO + Minolta AF 2x APO"26011Minolta AF 200mm F2.8 G APO + Minolta AF 2x APO | Minolta AF 600mm F4 HS-APO G + Minolta AF 2x APO"Minolta AF 200mm F2.8 G APO + Minolta AF 2x APO | "
                 "Minolta AF 600mm F4 HS-APO G + Minolta AF 2x APO"const char[99]char[99]26040Minolta AF 80-200mm F4.5-5.6"Minolta AF 80-200mm F4.5-5.6"2604126050Minolta AF 35-80mm F4-5.6"Minolta AF 35-80mm F4-5.6"2605126060Minolta AF 100-300mm F4.5-5.6"Minolta AF 100-300mm F4.5-5.6"26061Minolta AF 100-300mm F4.5-5.6 (D) | Sigma 105mm F2.8 Macro EX DG"Minolta AF 100-300mm F4.5-5.6 (D) | "
                 "Sigma 105mm F2.8 Macro EX DG"260702607126080Minolta AF 300mm F2.8 G"Minolta AF 300mm F2.8 G"26081Minolta AF 300mm F2.8 G APO High Speed"Minolta AF 300mm F2.8 G APO High Speed"26090Minolta AF 600mm F4 G"Minolta AF 600mm F4 G"26091Minolta AF 600mm F4 G APO High Speed"Minolta AF 600mm F4 G APO High Speed"26120Minolta AF 200mm F2.8 G"Minolta AF 200mm F2.8 G"26121Minolta AF 200mm F2.8 G APO High Speed"Minolta AF 200mm F2.8 G APO High Speed"2613026131Minolta AF 50mm F1.7 New"Minolta AF 50mm F1.7 New"26150Minolta AF 28-105mm F3.5-4.5 Xi"Minolta AF 28-105mm F3.5-4.5 Xi"26151Minolta AF 28-105mm F3.5-4.5 xi"Minolta AF 28-105mm F3.5-4.5 xi"26160Minolta AF 35-200mm F4.5-5.6 Xi"Minolta AF 35-200mm F4.5-5.6 Xi"2616126180Minolta AF 28-80mm F4-5.6 Xi"Minolta AF 28-80mm F4-5.6 Xi"26181Minolta AF 28-80mm F4-5.6 xi"Minolta AF 28-80mm F4-5.6 xi"26190Minolta AF 80-200mm F4.5-5.6 Xi"Minolta AF 80-200mm F4.5-5.6 Xi"261912620126210Minolta AF 100-300mm F4.5-5.6 Xi"Minolta AF 100-300mm F4.5-5.6 Xi"26211Minolta AF 100-300mm F4.5-5.6 xi"Minolta AF 100-300mm F4.5-5.6 xi"26240Minolta AF 35-80mm F4-5.6 Power Zoom"Minolta AF 35-80mm F4-5.6 Power Zoom"262412628126291Minolta AF 85mm F1.4 New"Minolta AF 85mm F1.4 New"26311Minolta/Sony AF 100-300mm F4.5-5.6 APO"Minolta/Sony AF 100-300mm F4.5-5.6 APO"26321Minolta AF 24-50mm F4 New"Minolta AF 24-50mm F4 New"26381Minolta AF 50mm F2.8 Macro New"Minolta AF 50mm F2.8 Macro New"2639126411Minolta/Sony AF 20mm F2.8 New"Minolta/Sony AF 20mm F2.8 New"26421Minolta AF 24mm F2.8 New"Minolta AF 24mm F2.8 New"2644126621Minolta AF 50mm F1.4 New"Minolta AF 50mm F1.4 New"26671Minolta AF 35mm F2 New"Minolta AF 35mm F2 New"26681Minolta AF 28mm F2 New"Minolta AF 28mm F2 New"26721Minolta AF 24-105mm F3.5-4.5 (D)"Minolta AF 24-105mm F3.5-4.5 (D)"45671Tokina 70-210mm F4-5.6"Tokina 70-210mm F4-5.6"45711Vivitar 70-210mm F4.5-5.6"Vivitar 70-210mm F4.5-5.6"45741Minolta AF200mm F2.8G x2 | Tokina 300mm F2.8 x2 | Tokina RF 500mm F8.0 x2 | Tamron SP AF 90mm F2.5"Minolta AF200mm F2.8G x2 | "
                 "Tokina 300mm F2.8 x2 | "
                 "Tokina RF 500mm F8.0 x2 | "
                 "Tamron SP AF 90mm F2.5"457511.4x Teleconverter "1.4x Teleconverter "45851Tamron SP AF 300mm F2.8 LD IF"Tamron SP AF 300mm F2.8 LD IF"45861Tamron SP AF 35-105mm F2.8 LD Aspherical IF"Tamron SP AF 35-105mm F2.8 LD Aspherical IF"45871Tamron AF 70-210mm F2.8 SP LD"Tamron AF 70-210mm F2.8 SP LD"Sigma 16mm F2.8 Filtermatic Fisheye"Sigma 16mm F2.8 Filtermatic Fisheye"Manual lens | Sony E 50mm F1.8 OSS | E PZ 16-50mm F3.5-5.6 OSS"Manual lens | "                        // 1
                 "Sony E 50mm F1.8 OSS | "               // 2
                 "E PZ 16-50mm F3.5-5.6 OSS""Very Low""Half Full""Sufficient Power Remaining"Very LowHalf FullSufficient Power RemainingsonyBatteryLevelA100"Built-in"Built-insonyFlashTypeA100"AM""MF"AMMFsonyFocusModeSwitchA100"Not Indicated""Under Scale""Bottom of Scale""Top of Scale""Over Scale"Not IndicatedUnder ScaleBottom of Scale-2.0"-2.0"-1.7"-1.7"-1.3"-1.3""-1.0"-0.7"-0.7"-0.5"-0.5"-0.3"-0.3"-0.0"-0.0"+0.3"+0.3"+0.5"+0.5"+0.7"+0.7"+1.3"+1.3"+1.5"+1.5"+1.7"+1.7"Top of ScaleOver ScalesonyExposureIndicatorA100"Within Range""Under/Over Range""Out of Range"Within RangeUnder/Over RangeOut of RangesonyMeteringOffScaleIndicatorA100"Auto-rotate""Manual Rotate"Auto-rotateManual RotatesonyPlayDisplayA100"Horizontal"HorizontalsonyRecordDisplayA100"Automatic"AutomaticsonyMonitorDisplayOffA100"0.3 seconds""0.6 seconds"0.3 seconds0.6 secondssonyAFAreaIlluminationA100"Ambient and Flash""Ambient Only"Ambient and FlashAmbient OnlysonyExposureCompensationModeA100"Shutter Speed"Shutter SpeedsonyControlDialSetA100"Hold""Toggle""Spot Hold""Spot Toggle"HoldToggleSpot HoldSpot TogglesonyAELButtonA100"Focus Hold""DOF Preview"Focus HoldDOF PreviewsonyFocusHoldButtonA1000-+"0-+"-0+"-0+"sonyAutoBracketOrderA100"Fill Flash"Fill FlashsonyFlashDefaultA100"Image and Information""Image Only""Image and Histogram"Image and InformationImage OnlyImage and HistogramsonyInstantPlaybackSetupA100sonyImageSizeA100"Ok""Error"OksonyCustomWBErrorA100"Setup""Recall"SetupRecallsonyCustomWBSettingA100"Temperature"TemperaturesonyColorTemperatureSettingA100sonyPresetWhiteBalanceA100"Preset"Preset0x8001sonyWhiteBalanceSettingA100sonyWhiteBalanceBracketingA1000x30217940x702sonySingleFrameBracketingA1000x30317950x703sonyContinuousBracketingA10010s"10s"2s"2s"sonySelfTimerTimeA100"Single Frame""Self-timer""Continuous Bracketing""Single-Frame Bracketing""White Balance Bracketing"Single FrameSelf-timerContinuous BracketingSingle-Frame BracketingWhite Balance BracketingsonyDriveModeA100sonyColorSpaceA100"Advanced"AdvancedsonyZoneMatchingModeA100"Multi-segment""Center weighted average"Multi-segmentCenter weighted averagesonyMeteringModeA100"Rear flash sync""Wireless""Fill flash"Rear flash syncWirelessFill flashsonyFlashModeA100AF-S"AF-S"AF-C"AF-C"AF-A"AF-A"DMF"DMF"sonyFocusModeA100"Self-timer 10 sec""Self-timer 2 sec""White Balance Bracketing Low""White Balance Bracketing High""Single-frame Bracketing Low""Continuous Bracketing Low""Single-frame Bracketing High""Continuous Bracketing High"Self-timer 10 secSelf-timer 2 secWhite Balance Bracketing LowWhite Balance Bracketing HighSingle-frame Bracketing LowContinuous Bracketing LowSingle-frame Bracketing HighContinuous Bracketing HighsonyDriveMode2A100"Natural""Natural+""Wind Scene""Evening Scene""Adobe RGB (ICC)"NaturalNatural+Wind SceneEvening SceneAdobe RGB (ICC)minoltaPictureFinish5DAF-D"AF-D"minoltaAFMode5D"Selection"SelectionminoltaFocusArea5D"Central""Up""Up right""Down right""Down""Down left""Up left"CentralUpUp rightDown rightDownDown leftUp leftminoltaFocusPosition5DminoltaRotation5D"sRGB (Natural)""sRGB (Natural+)"sRGB (Natural)sRGB (Natural+)minoltaColorSpace5D"200 (Zone Matching High)""80 (Zone Matching Low)"200 (Zone Matching High)80 (Zone Matching Low)minoltaISOSetting5D"Center weighted"Center weightedminoltaMeteringMode5D"Kelvin"KelvinminoltaWhiteBalance5D"Raw+Jpeg"Raw+JpegminoltaImageQuality5DminoltaImageSize5D"Aperture priority""Shutter priority""Program Shift A""Program Shift S"Aperture priorityShutter priorityProgram Shift AProgram Shift S41150x1013413141630x104341790x10534227minoltaExposureMode5DminoltaRotation7DminoltaColorSpace7DminoltaISOSetting7D"Top-right""Bottom-right""Bottom-left""Top-left"Top-rightBottom-rightBottom-leftTop-leftminoltaAFPoints7D"Single-shot AF""Continuous AF""Automatic AF"Single-shot AFContinuous AFAutomatic AFminoltaFocusMode7DminoltaWhiteBalance7DminoltaImageQuality7DminoltaImageSize7D"Program-shift A""Program-shift S"Program-shift AProgram-shift SminoltaExposureMode7D"ADI (Advanced Distance Integration)""Pre-flash TTl""Manual flash control"ADI (Advanced Distance Integration)Pre-flash TTlManual flash controlminoltaFlashMeteringStd"Text + ID#"YYYY/MM/DD"YYYY/MM/DD"MM/DD/HH:MM"MM/DD/HH:MM"Text + ID#minoltaDataImprintStd"Not embedded""Embedded"Not embeddedEmbeddedminoltaColorProfileStd"Exposure""Filter"ExposureFilterminoltaDECPositionStd"Wide focus (normal)""Spot focus"Wide focus (normal)Spot focusminoltaFocusAreaStd"Auto focus""Manual focus"Auto focusManual focusminoltaFocusModeStd"No zone""Center zone (horizontal orientation)""Center zone (vertical orientation)""Left zone""Right zone"No zoneCenter zone (horizontal orientation)Center zone (vertical orientation)Left zoneRight zoneminoltaWideFocusZoneStd"Natural color""Black and white""Vivid color""Solarization"Natural colorBlack and whiteVivid colorSolarizationminoltaColorModeStd"Standard form""Data form"Standard formData formminoltaFolderNameStd"Still image""Time-lapse movie"Still imageTime-lapse movieminoltaIntervalModeStdDiMAGE 7 | X1 | X21 | X31"DiMAGE 7 | X1 | X21 | X31"DiMAGE 5"DiMAGE 5"DiMAGE S304"DiMAGE S304"DiMAGE S404"DiMAGE S404"DiMAGE 7i"DiMAGE 7i"DiMAGE 7Hi"DiMAGE 7Hi"DiMAGE A1"DiMAGE A1"DiMAGE A2 | S414"DiMAGE A2 | S414"minoltaModelStdminoltaISOSettingStd"Night portrait""Sports action"Night portraitSports actionminoltaSubjectProgramStdminoltaSharpnessStdminoltaFlashFiredminoltaAFPointsStd1/3 EV"1/3 EV"2/3 EV"2/3 EV"minoltaBracketStepStd"Electronic magnification"Electronic magnificationminoltaDigitalZoomStdminoltaMeteringModeStd"Bracketing""Interval""UHS continuous""HS continuous"BracketingIntervalUHS continuousHS continuousminoltaDriveModeStd"Super fine""Extra fine"Super fineExtra fineminoltaImageQualityStd"Full size"Full size1280x960"1280x960"2080x1560"2080x1560"2560x1920"2560x1920"3264x2176"3264x2176"minoltaImageSizeStd"Fluorescent 2"Fluorescent 2minoltaWhiteBalanceStdminoltaFlashModeStdminoltaExposureModeStdminoltaImageStabilizationminoltaImageQuality"Natural Color""Natural sRGB""Natural+ sRGB""Evening"const TagDetails[14]TagDetails[14]Natural ColorNatural sRGBNatural+ sRGBEveningminoltaColorMode"Exposure Mode""Flash mode""Image Quality""Drive mode""ISO Value""Exposure Time""The F-Number""Macro Mode""Exposure Compensation""Bracket Step""Bracket step""Interval Length""Interval length""Interval Number""Interval number""Focus Distance""Focus distance""Flash Fired""Flash fired""Minolta Date""Minolta date""Minolta Time""Minolta time""File Number Memory""File number memory""Last Image Number""Last image number""Color Balance Red""Color balance red""Color Balance Green""Color balance green""Color Balance Blue""Color balance blue""Subject Program""Subject program""Flash Exposure Compensation""Flash exposure compensation in EV""ISO Settings""ISO setting""Minolta Model""Minolta model""Interval Mode""Interval mode""Folder Name""Folder name""Color filter""Black and White Filter""Black and white filter""Internal Flash""Brightness""Spot Focus Point X""Spot focus point X""Spot Focus Point Y""Spot focus point Y""Wide Focus Zone""Wide focus zone""Focus mode""Focus area""DEC Switch Position""DEC switch position""Color Profile""Color profile""Data Imprint""Flash Metering""Flash metering""Unknown Minolta Camera Settings tag"ExposureMode"ExposureMode"Exposure ModeFlash modeImage QualityDrive modeISO ValueExposureTime"ExposureTime"Exposure Time0x000AThe F-Number0x000BMacroMode"MacroMode"Macro Mode0x000C0x000DExposureCompensation"ExposureCompensation"Exposure Compensation0x000EBracketStep"BracketStep"Bracket StepBracket stepIntervalLength"IntervalLength"Interval LengthInterval lengthIntervalNumber"IntervalNumber"Interval NumberInterval numberFocusDistance"FocusDistance"Focus DistanceFocus distanceFlashFired"FlashFired"Flash FiredFlash firedMinoltaDate"MinoltaDate"Minolta DateMinolta dateMinoltaTime"MinoltaTime"Minolta TimeMinolta time0x001AFileNumberMemory"FileNumberMemory"File Number MemoryFile number memory0x001BLastFileNumber"LastFileNumber"Last Image NumberLast image number0x001CColorBalanceRed"ColorBalanceRed"Color Balance RedColor balance red0x001DColorBalanceGreen"ColorBalanceGreen"Color Balance GreenColor balance green0x001EColorBalanceBlue"ColorBalanceBlue"Color Balance BlueColor balance blue0x001FSubjectProgram"SubjectProgram"Subject ProgramSubject programFlashExposureComp"FlashExposureComp"Flash Exposure CompensationFlash exposure compensation in EVISOSetting"ISOSetting"ISO SettingsISO settingMinoltaModel"MinoltaModel"Minolta ModelMinolta modelIntervalMode"IntervalMode"Interval ModeInterval modeFolderName"FolderName"Folder NameFolder nameColor filter0x002ABWFilter"BWFilter"Black and White FilterBlack and white filter0x002BInternal Flash0x002CBrightness0x002DSpotFocusPointX"SpotFocusPointX"Spot Focus Point XSpot focus point X0x002ESpotFocusPointY"SpotFocusPointY"Spot Focus Point YSpot focus point Y0x002FWideFocusZone"WideFocusZone"Wide Focus ZoneWide focus zoneFocus mode0x0031FocusArea"FocusArea"Focus area0x0032DECPosition"DECPosition"DEC Switch PositionDEC switch position0x0033ColorProfile"ColorProfile"Color ProfileColor profileDataImprint"DataImprint"Data Imprint0x003FFlashMetering"FlashMetering"Flash MeteringFlash metering(UnknownMinoltaCsStdTag)"(UnknownMinoltaCsStdTag)"Unknown Minolta Camera Settings tag"AF Points""AF points""Color Space""Color space""Free Memory Card Images""Free memory card images""Color temperature""Hue""Rotation""Image Number""Noise reduction""Zone Matching On""Zone matching on""Unknown Minolta Camera Settings 7D tag"AFPoints"AFPoints"AF PointsAF pointsColor SpaceColor spaceFreeMemoryCardImages"FreeMemoryCardImages"Free Memory Card ImagesFree memory card imagesColor temperatureHue0x0046Rotation0x00470x00480x004A0x005EImageNumber"ImageNumber"Image Number0x0060Noise reduction0x00620x00710x0075ZoneMatchingOn"ZoneMatchingOn"Zone Matching OnZone matching on(UnknownMinoltaCs7DTag)"(UnknownMinoltaCs7DTag)"Unknown Minolta Camera Settings 7D tag"Focus Position""Focus position""Focus Area""Exposure Revision""Exposure revision""Rotation2""Picture Finish""Exposure Manual Bias""Exposure manual bias""AF mode""Unknown Minolta Camera Settings 5D tag"FocusPosition"FocusPosition"Focus PositionFocus positionFocus Area0x00360x00370x0038ExposureRevision"ExposureRevision"Exposure RevisionExposure revision0x00490x00500x00530x00540x0065Rotation20x006EPictureFinish"PictureFinish"Picture FinishExposureManualBias"ExposureManualBias"Exposure Manual BiasExposure manual bias0x009EAF mode0x00AE0x00B00x00BD(UnknownMinoltaCs5DTag)"(UnknownMinoltaCs5DTag)"Unknown Minolta Camera Settings 5D tag"Exposure Compensation Setting""Exposure compensation setting""High Speed Sync""High speed sync""Manual Exposure Time""Manual exposure time""Manual FNumber""Drive Mode 2""Drive mode 2""Local AF Area Point""AF Area Mode""Flash Exposure Comp Setting""Flash exposure compensation setting""ISO Setting""Zone Matching Mode""Dynamic Range Optimizer Mode""Dynamic range optimizer mode""Color mode""Priority Setup Shutter Release""Self Timer Time""Self timer time""Continuous bracketing""Single Frame Bracketing""Single frame bracketing""White balance bracketing""Preset White Balance""Preset white balance""Color Temperature Setting""Color temperature setting""Custom WB Setting""Custom WB setting""Dynamic Range Optimizer Settings""Custom WB Red Level""Custom WB red level""Custom WB Green Level""Custom WB green level""Custom WB Blue Level""CustomWB blue level""Custom WB Error""White Balance Fine Tune""White balance fine tune""Color Compensation Filter""Color compensation filter""Sony Image Size""Instant Playback Time""Instant playback time""Instant Playback Setup""Instant playback setup""Eye Start AF""Eye start AF""Red Eye Reduction""Red eye reduction""Flash Default""Flash default""Auto Bracket Order""Auto bracket order""Focus Hold Button""Focus hold button""AEL Button""AEL button""Control Dial Set""Control dial set""Exposure Compensation Mode""Exposure compensation mode""AF assist""Card Shutter Lock""Card shutter lock""Lens Shutter Lock""Lens shutter lock""AF Area Illumination""AF area illumination""Monitor Display Off""Monitor display off""Record Display""Record display""Play Display""Play display""Exposure Indicator""Exposure indicator""AEL Exposure Indicator""AEL exposure indicator (also indicates exposure for next shot when bracketing)""Exposure Bracketing Indicator Last""Exposure bracketing indicator last (indicator for last shot when bracketing)""Metering Off Scale Indicator""Metering off scale indicator (two flashing triangles when under or over metering scale)""Flash Exposure Indicator""Flash exposure indicator""Flash Exposure Indicator Next""Flash exposure indicator next (indicator for next shot when bracketing)""Flash Exposure Indicator Last""Flash exposure indicator last (indicator for last shot when bracketing)""Focus Mode Switch""Focus mode switch""Flash Type""Flash type""AE Lock""Color compensation filter: negative is green, positive is magenta""Battery Level""Battery level""Unknown Sony Camera Settings A100 tag"ExposureCompensationSetting"ExposureCompensationSetting"Exposure Compensation SettingExposure compensation settingHighSpeedSync"HighSpeedSync"High Speed SyncHigh speed syncManualExposureTime"ManualExposureTime"Manual Exposure TimeManual exposure timeManualFNumber"ManualFNumber"Manual FNumberDriveMode2"DriveMode2"Drive Mode 2Drive mode 2LocalAFAreaPoint"LocalAFAreaPoint"Local AF Area PointAFAreaMode"AFAreaMode"AF Area Mode0x000FFlashExposureCompSetting"FlashExposureCompSetting"Flash Exposure Comp SettingFlash exposure compensation settingISO SettingZoneMatchingMode"ZoneMatchingMode"Zone Matching ModeDynamicRangeOptimizerMode"DynamicRangeOptimizerMode"Dynamic Range Optimizer ModeDynamic range optimizer modeColor modePrioritySetupShutterRelease"PrioritySetupShutterRelease"Priority Setup Shutter ReleaseSelfTimerTime"SelfTimerTime"Self Timer TimeSelf timer timeContinuousBracketing"ContinuousBracketing"Continuous bracketingSingleFrameBracketing"SingleFrameBracketing"Single Frame BracketingSingle frame bracketingWhiteBalanceBracketing"WhiteBalanceBracketing"White balance bracketingWhiteBalanceSetting"WhiteBalanceSetting"PresetWhiteBalance"PresetWhiteBalance"Preset White BalancePreset white balanceColorTemperatureSetting"ColorTemperatureSetting"Color Temperature SettingColor temperature settingCustomWBSetting"CustomWBSetting"Custom WB SettingCustom WB settingDynamicRangeOptimizerSettings"DynamicRangeOptimizerSettings"Dynamic Range Optimizer SettingsCustomWBRedLevel"CustomWBRedLevel"Custom WB Red LevelCustom WB red levelCustomWBGreenLevel"CustomWBGreenLevel"Custom WB Green LevelCustom WB green levelCustomWBBlueLevel"CustomWBBlueLevel"Custom WB Blue LevelCustomWB blue levelCustomWBError"CustomWBError"Custom WB ErrorWhiteBalanceFineTune"WhiteBalanceFineTune"White Balance Fine TuneWhite balance fine tune0x00390x003AColorCompensationFilter"ColorCompensationFilter"Color Compensation FilterColor compensation filter0x003BSonyImageSize"SonyImageSize"Sony Image Size0x003C0x003DInstantPlaybackTime"InstantPlaybackTime"Instant Playback TimeInstant playback time0x003EInstantPlaybackSetup"InstantPlaybackSetup"Instant Playback SetupInstant playback setupEyeStartAF"EyeStartAF"Eye Start AFEye start AF0x0041RedEyeReduction"RedEyeReduction"Red Eye ReductionRed eye reduction0x0042FlashDefault"FlashDefault"Flash DefaultFlash default0x0043AutoBracketOrder"AutoBracketOrder"Auto Bracket OrderAuto bracket order0x0044FocusHoldButton"FocusHoldButton"Focus Hold ButtonFocus hold button0x0045AELButton"AELButton"AEL ButtonAEL buttonControlDialSet"ControlDialSet"Control Dial SetControl dial setExposureCompensationMode"ExposureCompensationMode"Exposure Compensation ModeExposure compensation modeAF assistCardShutterLock"CardShutterLock"Card Shutter LockCard shutter lockLensShutterLock"LensShutterLock"Lens Shutter LockLens shutter lock0x004BAFAreaIllumination"AFAreaIllumination"AF Area IlluminationAF area illumination0x004CMonitorDisplayOff"MonitorDisplayOff"Monitor Display OffMonitor display off0x004DRecordDisplay"RecordDisplay"Record DisplayRecord display0x004EPlayDisplay"PlayDisplay"Play DisplayPlay displayExposureIndicator"ExposureIndicator"Exposure IndicatorExposure indicator0x0051AELExposureIndicator"AELExposureIndicator"AEL Exposure IndicatorAEL exposure indicator (also indicates exposure for next shot when bracketing)0x0052ExposureBracketingIndicatorLast"ExposureBracketingIndicatorLast"Exposure Bracketing Indicator LastExposure bracketing indicator last (indicator for last shot when bracketing)MeteringOffScaleIndicator"MeteringOffScaleIndicator"Metering Off Scale IndicatorMetering off scale indicator (two flashing triangles when under or over metering scale)const char[88]char[88]FlashExposureIndicator"FlashExposureIndicator"Flash Exposure IndicatorFlash exposure indicator0x0055FlashExposureIndicatorNext"FlashExposureIndicatorNext"Flash Exposure Indicator NextFlash exposure indicator next (indicator for next shot when bracketing)0x0056FlashExposureIndicatorLast"FlashExposureIndicatorLast"Flash Exposure Indicator LastFlash exposure indicator last (indicator for last shot when bracketing)0x00570x0058FocusModeSwitch"FocusModeSwitch"Focus Mode SwitchFocus mode switch0x0059FlashType"FlashType"Flash TypeFlash type0x005AAELock"AELock"AE Lock0x005FColor compensation filter: negative is green, positive is magentaBatteryLevel"BatteryLevel"Battery LevelBattery level(UnknownSonyCsA100Tag)"(UnknownSonyCsA100Tag)"Unknown Sony Camera Settings A100 tag"Makernote Version""String 'MLT0' (not null terminated)""Camera Settings (Std Old)""Standard Camera settings (Old Camera models like D5, D7, S304, and S404)""Camera Settings (Std New)""Standard Camera settings (New Camera Models like D7u, D7i, and D7hi)""Camera Settings (7D)""Camera Settings (for Dynax 7D model)""Image Stabilization Data""Image stabilization data""WB Info A100""White balance information for the Sony DSLR-A100""Compressed Image Size""Compressed image size""Jpeg thumbnail 640x480 pixels""Thumbnail Offset""Offset of the thumbnail""Thumbnail Length""Size of the thumbnail""Scene Mode""0x0103""Teleconverter Model""RAW+JPG Recording""RAW and JPG files recording""Zone Matching""Zone matching""Lens ID""Lens identifier""Color Compensation Filter: negative is green, positive is magenta""White Balance Fine Tune Value""Image Stabilization A100""Image Stabilization for the Sony DSLR-A100""Camera Settings (5D)""Camera Settings (for Dynax 5D model)""Camera Settings (Z1)""Camera Settings (for Z1, DImage X, and F100 models)""Unknown Minolta MakerNote tag"Makernote VersionString 'MLT0' (not null terminated)CameraSettingsStdOld"CameraSettingsStdOld"Camera Settings (Std Old)Standard Camera settings (Old Camera models like D5, D7, S304, and S404)CameraSettingsStdNew"CameraSettingsStdNew"Camera Settings (Std New)Standard Camera settings (New Camera Models like D7u, D7i, and D7hi)CameraSettings7D"CameraSettings7D"Camera Settings (7D)Camera Settings (for Dynax 7D model)ImageStabilizationData"ImageStabilizationData"Image Stabilization DataImage stabilization dataWBInfoA100"WBInfoA100"WB Info A100White balance information for the Sony DSLR-A100CompressedImageSize"CompressedImageSize"Compressed Image SizeCompressed image size0x0081Jpeg thumbnail 640x480 pixels0x0088ThumbnailOffset"ThumbnailOffset"Thumbnail OffsetOffset of the thumbnail0x0089ThumbnailLength"ThumbnailLength"Thumbnail LengthSize of the thumbnailSceneMode"SceneMode"Scene Mode0x01010x01020x01030x01040x0105Teleconverter"Teleconverter"Teleconverter Model0x01070x0109RawAndJpgRecording"RawAndJpgRecording"RAW+JPG RecordingRAW and JPG files recording0x010aZoneMatching"ZoneMatching"Zone MatchingZone matching0x010b0x010cLensID"LensID"Lens IDLens identifier0x0111Color Compensation Filter: negative is green, positive is magenta0x0112White Balance Fine Tune Value0x0113ImageStabilizationA100"ImageStabilizationA100"Image Stabilization A100Image Stabilization for the Sony DSLR-A1000x0114CameraSettings5D"CameraSettings5D"Camera Settings (5D)Camera Settings (for Dynax 5D model)0x011538400x0f00CameraSettingsZ1"CameraSettingsZ1"Camera Settings (Z1)Camera Settings (for Z1, DImage X, and F100 models)(UnknownMinoltaMakerNoteTag)"(UnknownMinoltaMakerNoteTag)"Unknown Minolta MakerNote tag//! Lookup table to translate Sony/Minolta zone matching values to readable labels//! Lookup table to translate Sony/Minolta Std camera settings white balance values to readable labels// ----------------------------------------------------------------------------------------------------//! Lookup table to translate Sony/Minolta teleconverter model values to readable labels//! Lookup table to translate Sony/Minolta image quality values to readable labels//! Lookup table to translate Minolta/Sony scene mode values to readable labels//! Lookup table to translate Sony camera settings rotation values to readable labels//! Lookup table to translate Sony camera settings quality values to readable labels//! Lookup table to translate Sony camera settings priority setup shutter release values to readable labels//! Lookup table to translate Sony camera settings dynamic range optimizer mode values to readable labels//! Lookup table to translate Sony camera settings Local AF Area Point values to readable labels//! Lookup table to translate Sony camera settings focus mode values to readable labels//! Lookup table to translate Minolta/Sony bool inverse function values to readable labels//! Lookup table to translate Minolta/Sony bool function values to readable labels//! Lookup table to translate Minolta A100 and all other Sony Alpha camera color mode values to readable labels// #1145 - respect lenses with shared LensID// ----------------------------------------------------------------------// #1145 end - respect lenses with shared LensID//     {   0x00ff, resolveLensTypeUsingExiftool }, // was used for debugging//! List of lens ids which require special treatment from printMinoltaSonyLensID// F5.6// F5// F4.5// F4// F3.5// #1153// https://stackoverflow.com/questions/14265581/parse-split-a-string-in-c-using-string-delimiter-standard-c//! trim from left & right//! trim from right/*! http://stackoverflow.com/questions/1798112/removing-leading-and-trailing-spaces-from-a-string
        trim from left
    */// and stop at any non-printing character such as line-feed// just to be sure, add a null byte// #if ! defined(WIN32) && ! defined(__CYGWIN__) && ! defined(__MINGW__)// 4 I haven't asked Phil's permission to do this// 3 almost certainly throws an ugly ugly dos box on the screen in Windows// 2 can't work for a remote file as exiftool doesn't handle remote IO// 1 we don't know the path to the file being processed// It's not in service because:// resolveLensTypeUsingExiftool has been debugged on the Mac// #1145 begin - respect lenses with shared LensID// 23// 22// 21// 20// 19// 18// 17//      { 51,    "Sony AF DT 55-200mm F4-5.5" }, // Anomaly? - unconfirmed./* NOTE:
       - duplicate tags value are:
       0/25520, 4/25920, 13/25610, 19/25910, 22/26050/26070,
       25500/25501/26130, 25540/25541/25850, 25580/25581, 2564025641,
       25720/25721, 25790/25791, 25960/25961, 25980/25981, 26150/26151
       - No need to i18n these string.
    *///! Lookup table to translate Minolta/Sony Lens id values to readable labels// TODO : Add camera settings tags info "New2"...// Sony A100 Camera Settings Tag Info//! Lookup table to translate Sony A100 camera settings battery level switch values to readable labels//! Lookup table to translate Sony A100 camera settings flash type switch values to readable labels//! Lookup table to translate Sony A100 camera settings focus mode switch values to readable labels//! Lookup table to translate Sony A100 camera settings exposure indicator values to readable labels//! Lookup table to translate Sony A100 camera settings metering off scale indicator values to readable labels//! Lookup table to translate Sony A100 camera settings play display values to readable labels//! Lookup table to translate Sony A100 camera settings record display values to readable labels//! Lookup table to translate Sony A100 camera settings monitor display off values to readable labels//! Lookup table to translate Sony A100 camera settings sony AF area illumination values to readable labels//! Lookup table to translate Sony A100 camera settings exposure compensation mode values to readable labels//! Lookup table to translate Sony A100 camera settings control dial set values to readable labels//! Lookup table to translate Sony A100 camera settings AEL button values to readable labels//! Lookup table to translate Sony A100 camera settings focus hold button values to readable labels//! Lookup table to translate Sony A100 camera settings auto bracket order values to readable labels//! Lookup table to translate Sony A100 camera settings flash default setup values to readable labels//! Lookup table to translate Sony A100 camera settings instant playback setup values to readable labels//! Lookup table to translate Sony A100 camera settings image size values to readable labels//! Lookup table to translate Sony A100 camera settings custom WB error values to readable labels//! Lookup table to translate Sony A100 camera settings custom WB setting values to readable labels//! Lookup table to translate Sony A100 camera settings color temperature setting values to readable labels//! Lookup table to translate Sony A100 camera settings preset white balance values to readable labels//! Lookup table to translate Sony A100 camera settings white balance setting values to readable labels//! Lookup table to translate Sony A100 camera settings white balance bracketing values to readable labels//! Lookup table to translate Sony A100 camera settings single frame bracketing values to readable labels//! Lookup table to translate Sony A100 camera settings continuous bracketing values to readable labels//! Lookup table to translate Sony A100 camera settings self timer time values to readable labels//! Lookup table to translate Sony A100 camera settings drive mode values to readable labels//! Lookup table to translate Sony A100 camera settings color space values to readable labels//! Lookup table to translate Sony A100 camera settings zone matching mode values to readable labels//! Lookup table to translate Sony A100 camera settings metering mode values to readable labels//! Lookup table to translate Sony A100 camera settings flash mode values to readable labels//! Lookup table to translate Sony A100 camera settings focus mode values to readable labels//! Lookup table to translate Sony A100 camera settings drive mode 2 values to readable labels// -- Sony A100 camera settings ---------------------------------------------------------------// value and Exposure time is exp(-4+value*0.085)// 0x0052 seems to be identical to ExposureTime (0x0035). An approx. relation between Tag// and Fstop is exp(-0.335+value*0.043)// 0x0051 seems to be identical to FNumber (0x0036). An approx. relation between Tag value// From Xavier Raynaud: some notes on missing tags.// Minolta Dynax 5D Camera Settings Tag Info//! Method to convert Minolta Dynax 5D exposure compensation values.// From Xavier Raynaud: the value is converted from 0:256 to -5.33:5.33//! Method to convert Minolta Dynax 5D exposure manual bias values.//! Lookup table to translate Minolta Dynax 5D camera settings picture finish values to readable labels//! Lookup table to translate Minolta Dynax 5D camera settings focus mode values to readable labels//! Lookup table to translate Minolta Dynax 5D camera settings focus area values to readable labels//! Lookup table to translate Minolta Dynax 5D camera settings focus position values to readable labels//! Lookup table to translate Minolta Dynax 5D camera settings rotation values to readable labels//! Lookup table to translate Minolta Dynax 5D camera settings color space values to readable labels//! Lookup table to translate Minolta Dynax 5D camera settings ISO settings values to readable labels//! Lookup table to translate Minolta Dynax 5D camera settings metering mode values to readable labels//! Lookup table to translate Minolta Dynax 5D camera settings white balance values to readable labels//! Lookup table to translate Minolta Dynax 5D camera settings image quality values to readable labels//! Lookup table to translate Minolta Dynax 5D camera settings image size values to readable labels//! Lookup table to translate Minolta Dynax 5D camera settings exposure mode values to readable labels// -- Minolta Dynax 5D camera settings ---------------------------------------------------------------// 0x0062 is a dupplicate than 0x005E.// 0x004A is a dupplicate than 0x002D.// Minolta Dynax 7D Camera Settings Tag Info//! Lookup table to translate Minolta Dynax 7D camera settings rotation values to readable labels//! Lookup table to translate Minolta Dynax 7D camera settings color space values to readable labels//! Lookup table to translate Minolta Dynax 7D camera settings ISO settings values to readable labels//! Lookup table to translate Minolta Dynax 7D camera settings AF points values to readable labels//! Lookup table to translate Minolta Dynax 7D camera settings focus mode values to readable labels//! Lookup table to translate Minolta Dynax 7D camera settings white balance values to readable labels//! Lookup table to translate Minolta Dynax 7D camera settings image quality values to readable labels//! Lookup table to translate Minolta Dynax 7D camera settings image size values to readable labels//! Lookup table to translate Minolta Dynax 7D camera settings exposure mode values to readable labels// -- Minolta Dynax 7D camera settings ---------------------------------------------------------------// Minolta Standard Camera Settings Tag Info (Old and New)// From the PHP JPEG Metadata Toolkit//! Lookup table to translate Minolta Std camera settings flash metering values to readable labels//! Lookup table to translate Minolta Std camera settings data Imprint values to readable labels//! Lookup table to translate Minolta Std camera settings color profile values to readable labels//! Lookup table to translate Minolta Std camera settings DEC switch position values to readable labels//! Lookup table to translate Minolta Std camera settings focus area values to readable labels//! Lookup table to translate Minolta Std camera settings focus mode values to readable labels//! Lookup table to translate Minolta Std camera settings wide focus zone values to readable labels//! Lookup table to translate Minolta Std camera settings color mode values to readable labels//! Lookup table to translate Minolta Std camera settings folder name values to readable labels//! Lookup table to translate Minolta Std camera settings interval mode values to readable labels//! Lookup table to translate Minolta Std camera settings model values to readable labels//! Lookup table to translate Minolta Std camera settings ISO settings values to readable labels//! Lookup table to translate Minolta Std camera settings subject program values to readable labels//! Lookup table to translate Minolta Std camera settings sharpness values to readable labels//! Lookup table to translate Minolta Std camera settings flash fired values to readable labels//! Lookup table to translate Minolta Std camera settings AF points values to readable labels//! Lookup table to translate Minolta Std camera bracket step mode values to readable labels//! Lookup table to translate Minolta Std camera settings digital zoom values to readable labels//! Lookup table to translate Minolta Std camera settings metering mode values to readable labels//! Lookup table to translate Minolta Std camera settings drive mode values to readable labels//! Lookup table to translate Minolta Std camera settings image quality values to readable labels//! Lookup table to translate Minolta Std camera settings image size values to readable labels//! Lookup table to translate Minolta Std camera settings white balance values to readable labels//! Lookup table to translate Minolta Std camera settings flash mode values to readable labels//! Lookup table to translate Minolta Std camera settings exposure mode values to readable labels// -- Standard Minolta camera settings ---------------------------------------------------------------// TODO: implement CameraSettingsA100 tags decoding.// TODO: Tag 0x0103 : quality or image size (see ExifTool doc).// TODO: for A100, use Sony table from printMinoltaSonyColorMode().// TODO: Implement WB Info A100 tags decoding.// Minolta Tag Info//! Lookup table to translate Minolta image stabilization values//! Lookup table to translate Minolta image quality values to readable labels//! Lookup table to translate Minolta color mode values to readable labels// -- Standard Minolta Makernotes tags ---------------------------------------------------------------// popen to call exiftool/*
  File:      minoltamn.cpp
  Author(s): Gilles Caulier (cgilles) <caulier dot gilles at gmail dot com>
             Andreas Huggel (ahu) <ahuggel@gmx.net>
  History:   06-May-06, gc: submitted
  Credits:   See header file.
 */pair<__tree_const_iterator<basic_string<char, char_traits<char>, allocator<char>>, __tree_node<basic_string<char, char_traits<char>, allocator<char>>, void *> *, long>, bool>const pair<__tree_const_iterator<basic_string<char, char_traits<char>, allocator<char>>, __tree_node<basic_string<char, char_traits<char>, allocator<char>>, void *> *, long>, bool>const pair<__tree_const_iterator<basic_string<char, char_traits<char>, allocator<char>>, __tree_node<basic_string<char, char_traits<char>, allocator<char>>, void *> *, long>, bool> &pair<__tree_const_iterator<basic_string<char, char_traits<char>, allocator<char>>, __tree_node<basic_string<char, char_traits<char>, allocator<char>>, void *> *, long>, bool> &__tree_iterator<basic_string<char, char_traits<char>, allocator<char>>, __tree_node<basic_string<char, char_traits<char>, allocator<char>>, void *> *, long> *const TagDetails(&)[14]TagDetails(&)[14]const pair<__tree_iterator<basic_string<char, char_traits<char>, allocator<char>>, __tree_node<basic_string<char, char_traits<char>, allocator<char>>, void *> *, long>, bool>const pair<__tree_iterator<basic_string<char, char_traits<char>, allocator<char>>, __tree_node<basic_string<char, char_traits<char>, allocator<char>>, void *> *, long>, bool> &pair<__tree_iterator<basic_string<char, char_traits<char>, allocator<char>>, __tree_node<basic_string<char, char_traits<char>, allocator<char>>, void *> *, long>, bool> &const TagDetails(&)[15]TagDetails(&)[15]__tree_node<basic_string<char, char_traits<char>, allocator<char>>, void *> *&__tree_node_destructor<allocator<__tree_node<basic_string<char, char_traits<char>, allocator<char>>, void *>>> &operator std::__1::basic_string<char, std::__1::char_traits<char>, std::__1::allocator<char>> *operator std::__1::__tree_node<std::__1::basic_string<char, std::__1::char_traits<char>, std::__1::allocator<char>>, void *> *pair<__tree_iterator<basic_string<char, char_traits<char>, allocator<char>>, __tree_node<basic_string<char, char_traits<char>, allocator<char>>, void *> *, long>, bool> *unique_ptr<__tree_node<basic_string<char, char_traits<char>, allocator<char>>, void *>, __tree_node_destructor<allocator<__tree_node<basic_string<char, char_traits<char>, allocator<char>>, void *>>>> &const __tree<basic_string<char, char_traits<char>, allocator<char>>, less<basic_string<char, char_traits<char>, allocator<char>>>, allocator<basic_string<char, char_traits<char>, allocator<char>>>>const __tree<basic_string<char, char_traits<char>, allocator<char>>, less<basic_string<char, char_traits<char>, allocator<char>>>, allocator<basic_string<char, char_traits<char>, allocator<char>>>> *const basic_string<char, char_traits<char>, allocator<char>> &&__split_buffer<basic_string<char, char_traits<char>, allocator<char>>, allocator<basic_string<char, char_traits<char>, allocator<char>>> &> &remove_reference<const basic_string<char, char_traits<char>, allocator<char>>>remove_reference<const basic_string<char, char_traits<char>, allocator<char>>> &const remove_reference<const basic_string<char, char_traits<char>, allocator<char>>>const remove_reference<const basic_string<char, char_traits<char>, allocator<char>>> &__split_buffer<basic_string<char, char_traits<char>, allocator<char>>, allocator<basic_string<char, char_traits<char>, allocator<char>>> &>__compressed_pair<__tree_node<basic_string<char, char_traits<char>, allocator<char>>, void *> *, __tree_node_destructor<allocator<__tree_node<basic_string<char, char_traits<char>, allocator<char>>, void *>>>>__compressed_pair<__tree_node<basic_string<char, char_traits<char>, allocator<char>>, void *> *, __tree_node_destructor<allocator<__tree_node<basic_string<char, char_traits<char>, allocator<char>>, void *>>>> &const __compressed_pair<__tree_node<basic_string<char, char_traits<char>, allocator<char>>, void *> *, __tree_node_destructor<allocator<__tree_node<basic_string<char, char_traits<char>, allocator<char>>, void *>>>>const __compressed_pair<__tree_node<basic_string<char, char_traits<char>, allocator<char>>, void *> *, __tree_node_destructor<allocator<__tree_node<basic_string<char, char_traits<char>, allocator<char>>, void *>>>> &__pointer<__tree_node<basic_string<char, char_traits<char>, allocator<char>>, void *>, __tree_node_destructor<allocator<__tree_node<basic_string<char, char_traits<char>, allocator<char>>, void *>>>, __tree_node_destructor<allocator<__tree_node<basic_string<char, char_traits<char>, allocator<char>>, void *>>>, true>__pointer<__tree_node<basic_string<char, char_traits<char>, allocator<char>>, void *>, __tree_node_destructor<allocator<__tree_node<basic_string<char, char_traits<char>, allocator<char>>, void *>>>, __tree_node_destructor<allocator<__tree_node<basic_string<char, char_traits<char>, allocator<char>>, void *>>>, true> &const __pointer<__tree_node<basic_string<char, char_traits<char>, allocator<char>>, void *>, __tree_node_destructor<allocator<__tree_node<basic_string<char, char_traits<char>, allocator<char>>, void *>>>, __tree_node_destructor<allocator<__tree_node<basic_string<char, char_traits<char>, allocator<char>>, void *>>>, true>const __pointer<__tree_node<basic_string<char, char_traits<char>, allocator<char>>, void *>, __tree_node_destructor<allocator<__tree_node<basic_string<char, char_traits<char>, allocator<char>>, void *>>>, __tree_node_destructor<allocator<__tree_node<basic_string<char, char_traits<char>, allocator<char>>, void *>>>, true> &__unique_ptr_deleter_sfinae<__tree_node_destructor<allocator<__tree_node<basic_string<char, char_traits<char>, allocator<char>>, void *>>>>__unique_ptr_deleter_sfinae<__tree_node_destructor<allocator<__tree_node<basic_string<char, char_traits<char>, allocator<char>>, void *>>>> &const __unique_ptr_deleter_sfinae<__tree_node_destructor<allocator<__tree_node<basic_string<char, char_traits<char>, allocator<char>>, void *>>>>const __unique_ptr_deleter_sfinae<__tree_node_destructor<allocator<__tree_node<basic_string<char, char_traits<char>, allocator<char>>, void *>>>> &__tree_node_destructor<allocator<__tree_node<basic_string<char, char_traits<char>, allocator<char>>, void *>>> &&const __tree_node_destructor<allocator<__tree_node<basic_string<char, char_traits<char>, allocator<char>>, void *>>>const __tree_node_destructor<allocator<__tree_node<basic_string<char, char_traits<char>, allocator<char>>, void *>>> &const __compressed_pair<basic_string<char, char_traits<char>, allocator<char>> *, allocator<basic_string<char, char_traits<char>, allocator<char>>>> *__compressed_pair<basic_string<char, char_traits<char>, allocator<char>> *, allocator<basic_string<char, char_traits<char>, allocator<char>>>> *__split_buffer<basic_string<char, char_traits<char>, allocator<char>>, allocator<basic_string<char, char_traits<char>, allocator<char>>> &> *const __split_buffer<basic_string<char, char_traits<char>, allocator<char>>, allocator<basic_string<char, char_traits<char>, allocator<char>>> &>const __split_buffer<basic_string<char, char_traits<char>, allocator<char>>, allocator<basic_string<char, char_traits<char>, allocator<char>>> &> *const __tree_iterator<basic_string<char, char_traits<char>, allocator<char>>, __tree_node<basic_string<char, char_traits<char>, allocator<char>>, void *> *, long> *const unique_ptr<__tree_node<basic_string<char, char_traits<char>, allocator<char>>, void *>, __tree_node_destructor<allocator<__tree_node<basic_string<char, char_traits<char>, allocator<char>>, void *>>>>remove_reference<const less<basic_string<char, char_traits<char>, allocator<char>>> &>remove_reference<const less<basic_string<char, char_traits<char>, allocator<char>>> &> &const remove_reference<const less<basic_string<char, char_traits<char>, allocator<char>>> &>const remove_reference<const less<basic_string<char, char_traits<char>, allocator<char>>> &> &remove_reference<const allocator<basic_string<char, char_traits<char>, allocator<char>>> &>remove_reference<const allocator<basic_string<char, char_traits<char>, allocator<char>>> &> &const remove_reference<const allocator<basic_string<char, char_traits<char>, allocator<char>>> &>const remove_reference<const allocator<basic_string<char, char_traits<char>, allocator<char>>> &> &__has_pointer<__tree_node_destructor<allocator<__tree_node<basic_string<char, char_traits<char>, allocator<char>>, void *>>>, void>__has_pointer<__tree_node_destructor<allocator<__tree_node<basic_string<char, char_traits<char>, allocator<char>>, void *>>>, void> &const __has_pointer<__tree_node_destructor<allocator<__tree_node<basic_string<char, char_traits<char>, allocator<char>>, void *>>>, void>const __has_pointer<__tree_node_destructor<allocator<__tree_node<basic_string<char, char_traits<char>, allocator<char>>, void *>>>, void> &__compressed_pair_elem<__tree_node_destructor<allocator<__tree_node<basic_string<char, char_traits<char>, allocator<char>>, void *>>>, 1, false>__compressed_pair_elem<__tree_node_destructor<allocator<__tree_node<basic_string<char, char_traits<char>, allocator<char>>, void *>>>, 1, false> &const __compressed_pair_elem<__tree_node_destructor<allocator<__tree_node<basic_string<char, char_traits<char>, allocator<char>>, void *>>>, 1, false>const __compressed_pair_elem<__tree_node_destructor<allocator<__tree_node<basic_string<char, char_traits<char>, allocator<char>>, void *>>>, 1, false> &__compressed_pair_elem<__tree_node<basic_string<char, char_traits<char>, allocator<char>>, void *> *, 0, false>__compressed_pair_elem<__tree_node<basic_string<char, char_traits<char>, allocator<char>>, void *> *, 0, false> &const __compressed_pair_elem<__tree_node<basic_string<char, char_traits<char>, allocator<char>>, void *> *, 0, false>const __compressed_pair_elem<__tree_node<basic_string<char, char_traits<char>, allocator<char>>, void *> *, 0, false> &__tree_node<basic_string<char, char_traits<char>, allocator<char>>, void *> *const__tree_node<basic_string<char, char_traits<char>, allocator<char>>, void *> *const &__compressed_pair<basic_string<char, char_traits<char>, allocator<char>> *, allocator<basic_string<char, char_traits<char>, allocator<char>>> &>__compressed_pair<basic_string<char, char_traits<char>, allocator<char>> *, allocator<basic_string<char, char_traits<char>, allocator<char>>> &> &const __compressed_pair<basic_string<char, char_traits<char>, allocator<char>> *, allocator<basic_string<char, char_traits<char>, allocator<char>>> &>const __compressed_pair<basic_string<char, char_traits<char>, allocator<char>> *, allocator<basic_string<char, char_traits<char>, allocator<char>>> &> &remove_reference<allocator<basic_string<char, char_traits<char>, allocator<char>>> &>remove_reference<allocator<basic_string<char, char_traits<char>, allocator<char>>> &> &const remove_reference<allocator<basic_string<char, char_traits<char>, allocator<char>>> &>const remove_reference<allocator<basic_string<char, char_traits<char>, allocator<char>>> &> &add_lvalue_reference<allocator<basic_string<char, char_traits<char>, allocator<char>>> &>add_lvalue_reference<allocator<basic_string<char, char_traits<char>, allocator<char>>> &> &const add_lvalue_reference<allocator<basic_string<char, char_traits<char>, allocator<char>>> &>const add_lvalue_reference<allocator<basic_string<char, char_traits<char>, allocator<char>>> &> &__compressed_pair<__tree_end_node<__tree_node_base<void *> *>, allocator<__tree_node<basic_string<char, char_traits<char>, allocator<char>>, void *>>> *unique_ptr<__tree_node<basic_string<char, char_traits<char>, allocator<char>>, void *>, __tree_node_destructor<allocator<__tree_node<basic_string<char, char_traits<char>, allocator<char>>, void *>>>> *const unique_ptr<__tree_node<basic_string<char, char_traits<char>, allocator<char>>, void *>, __tree_node_destructor<allocator<__tree_node<basic_string<char, char_traits<char>, allocator<char>>, void *>>>> *__compressed_pair<unsigned long, less<basic_string<char, char_traits<char>, allocator<char>>>> *allocator<basic_string<char, char_traits<char>, allocator<char>>> *__compressed_pair_elem<allocator<basic_string<char, char_traits<char>, allocator<char>>>, 1, true> *__compressed_pair_elem<basic_string<char, char_traits<char>, allocator<char>> *, 0, false> *const __compressed_pair_elem<allocator<basic_string<char, char_traits<char>, allocator<char>>>, 1, true> *remove_reference<basic_string<char, char_traits<char>, allocator<char>> &>remove_reference<basic_string<char, char_traits<char>, allocator<char>> &> &const remove_reference<basic_string<char, char_traits<char>, allocator<char>> &>const remove_reference<basic_string<char, char_traits<char>, allocator<char>> &> &remove_reference<basic_string<char, char_traits<char>, allocator<char>> *&>remove_reference<basic_string<char, char_traits<char>, allocator<char>> *&> &const remove_reference<basic_string<char, char_traits<char>, allocator<char>> *&>const remove_reference<basic_string<char, char_traits<char>, allocator<char>> *&> &__add_lvalue_reference_impl<allocator<basic_string<char, char_traits<char>, allocator<char>>> &, true>__add_lvalue_reference_impl<allocator<basic_string<char, char_traits<char>, allocator<char>>> &, true> &const __add_lvalue_reference_impl<allocator<basic_string<char, char_traits<char>, allocator<char>>> &, true>const __add_lvalue_reference_impl<allocator<basic_string<char, char_traits<char>, allocator<char>>> &, true> &__compressed_pair_elem<allocator<basic_string<char, char_traits<char>, allocator<char>>> &, 1, false>__compressed_pair_elem<allocator<basic_string<char, char_traits<char>, allocator<char>>> &, 1, false> &const __compressed_pair_elem<allocator<basic_string<char, char_traits<char>, allocator<char>>> &, 1, false>const __compressed_pair_elem<allocator<basic_string<char, char_traits<char>, allocator<char>>> &, 1, false> &const allocator<basic_string<char, char_traits<char>, allocator<char>>> *__compressed_pair<basic_string<char, char_traits<char>, allocator<char>> *, allocator<basic_string<char, char_traits<char>, allocator<char>>> &> *allocator<__tree_node<basic_string<char, char_traits<char>, allocator<char>>, void *>> *__compressed_pair_elem<less<basic_string<char, char_traits<char>, allocator<char>>>, 1, true> *const __compressed_pair<__tree_end_node<__tree_node_base<void *> *>, allocator<__tree_node<basic_string<char, char_traits<char>, allocator<char>>, void *>>> *unique_ptr<__tree_node<basic_string<char, char_traits<char>, allocator<char>>, void *>, __tree_node_destructor<allocator<__tree_node<basic_string<char, char_traits<char>, allocator<char>>, void *>>>> &&const __compressed_pair<__tree_node<basic_string<char, char_traits<char>, allocator<char>>, void *> *, __tree_node_destructor<allocator<__tree_node<basic_string<char, char_traits<char>, allocator<char>>, void *>>>> *__compressed_pair<__tree_node<basic_string<char, char_traits<char>, allocator<char>>, void *> *, __tree_node_destructor<allocator<__tree_node<basic_string<char, char_traits<char>, allocator<char>>, void *>>>> *remove_reference<__tree_node_destructor<allocator<__tree_node<basic_string<char, char_traits<char>, allocator<char>>, void *>>>>remove_reference<__tree_node_destructor<allocator<__tree_node<basic_string<char, char_traits<char>, allocator<char>>, void *>>>> &const remove_reference<__tree_node_destructor<allocator<__tree_node<basic_string<char, char_traits<char>, allocator<char>>, void *>>>>const remove_reference<__tree_node_destructor<allocator<__tree_node<basic_string<char, char_traits<char>, allocator<char>>, void *>>>> &__is_referenceable<allocator<basic_string<char, char_traits<char>, allocator<char>>> &>__is_referenceable<allocator<basic_string<char, char_traits<char>, allocator<char>>> &> &const __is_referenceable<allocator<basic_string<char, char_traits<char>, allocator<char>>> &>const __is_referenceable<allocator<basic_string<char, char_traits<char>, allocator<char>>> &> &__tree_node_destructor<allocator<__tree_node<basic_string<char, char_traits<char>, allocator<char>>, void *>>> *__compressed_pair_elem<__tree_node<basic_string<char, char_traits<char>, allocator<char>>, void *> *, 0, false> *const __compressed_pair_elem<__tree_node<basic_string<char, char_traits<char>, allocator<char>>, void *> *, 0, false> *__tree_node<basic_string<char, char_traits<char>, allocator<char>>, void *> *&&__compressed_pair_elem<allocator<__tree_node<basic_string<char, char_traits<char>, allocator<char>>, void *>>, 1, true> *const __compressed_pair_elem<basic_string<char, char_traits<char>, allocator<char>> *, 0, false> *__non_trivial_if<true, allocator<basic_string<char, char_traits<char>, allocator<char>>>> *const __compressed_pair<basic_string<char, char_traits<char>, allocator<char>> *, allocator<basic_string<char, char_traits<char>, allocator<char>>> &> *__compressed_pair_elem<allocator<basic_string<char, char_traits<char>, allocator<char>>> &, 1, false> *remove_reference<__tree_node<basic_string<char, char_traits<char>, allocator<char>>, void *> *>remove_reference<__tree_node<basic_string<char, char_traits<char>, allocator<char>>, void *> *> &const remove_reference<__tree_node<basic_string<char, char_traits<char>, allocator<char>>, void *> *>const remove_reference<__tree_node<basic_string<char, char_traits<char>, allocator<char>>, void *> *> &__compressed_pair_elem<__tree_node_destructor<allocator<__tree_node<basic_string<char, char_traits<char>, allocator<char>>, void *>>>, 1, false> */Users/owura/Repos/codeql_eval/proj_repos/Exiv2-exiv2-pull-962-commits-e925bc5addd881543fa503470c8a859e112cca62/exiv2/src/mrwimage.cpp 4 MRM"\0MRM"-4MrwImage *const MrwImage *image/x-minolta-mrw"image/x-minolta-mrw"MRW"MRW"TTW"TTW"siz// MrwImage::writeMetadata// MrwImage::readMetadata// will fail if there are fewer than siz bytes left to read.// exact bounds checking is done by the call to io_->read, which// greater than io_->size() then it is definitely invalid. But the// get DOS-ed by a 4GB allocation on the next line. If siz is// First do an approximate bounds check of siz, so that we don't// Find the TTW block and read it into a buffer// MrwImage::MrwImage/*
  File:      mrwimage.cpp
  Author(s): Andreas Huggel (ahu) <ahuggel@gmx.net>
  History:   13-May-06, ahu: created
  Credits:   See header file
 */Nikon3MakerNote &const Nikon3MakerNoteconst Nikon3MakerNote &Nikon2MakerNote &const Nikon2MakerNoteconst Nikon2MakerNote &Nikon1MakerNote &const Nikon1MakerNoteconst Nikon1MakerNote &Nikon3MakerNoteNikon2MakerNoteNikon1MakerNoteNIKONMN_INT_HPP_tagInfoLd3_tagInfoLd2_tagInfoLd1_tagInfoCb4_tagInfoCb3_tagInfoCb2b_tagInfoCb2a_tagInfoCb2_tagInfoCb1_tagInfoSi5_tagInfoSi4_tagInfoSi3_tagInfoSi2_tagInfoSi1_tagInfoFl3_tagInfoFl2_tagInfoFl1_tagInfoMe_tagInfoAFT_tagInfoAf22_tagInfoAf21_tagInfoAf_tagInfoIi_tagInfoWt_tagInfoPc_tagInfoVr_printPictureControlprintTimeZoneprintRepeatingFlashCountprintRepeatingFlashRateprintFlashFocalLengthprintIiIsoprint0x009eprint0x009aprintExitPupilPositionprintFStopsprintFocalprintApertureprintFocusDistanceprintLensId3printLensId2printLensId1printLensIdprintAfPointsInFocusprint0x008bprint0x0089print0x0088print0x0086print0x0085print0x0084print0x0083print0x0002tagListLd3tagListLd2tagListLd1tagListCb4tagListCb3tagListCb2btagListCb2atagListCb2tagListCb1tagListSi5tagListSi4tagListSi3tagListSi2tagListSi1tagListFl3tagListFl2tagListFl1tagListMetagListAFTtagListAf22tagListAf21tagListAftagListIitagListWttagListPctagListVrprintBarValue// #ifndef NIKONMN_INT_HPP_// class Nikon3MakerNote//! Lens Data 3 tag information//! Lens Data 2 tag information//! Lens Data 1 tag information//! Color Balance 4 tag information//! Color Balance 3 tag information//! Color Balance 2b tag information//! Color Balance 2a tag information//! Color Balance 2 tag information//! Color Balance 1 tag information//! Shot Info tag information//! Shot Info D300 (b) tag information//! Shot Info D300 (a) tag information//! Shot Info D40 tag information//! Shot Info D80 tag information//! Flash Info 3 tag information//! Flash Info 2 tag information//! Flash Info 1 tag information//! Multi Exposure tag information//! File Info tag information//! AF Fine Tune tag information//! Auto Focus tag 2 information//! Auto Focus tag information//! ISO info tag information//! World Time tag information//! Picture Control tag information//! Vibration Reduction tag information//! Print picture control value//! Print time zone//! Print repeating flash count//! Print repeating flash rate//! Print flash focal length//! Print Exif.NikonIi.ISO(2)//! Print retouch history//! Print sensor pixel size//! Print exit pupil position//! Print lens f-stops//! Print lens focal length//! Print lens aperture value//! Print focus distance//! Print lens name//! Print AF Points In Focus//! Print number of lens stops//! Print shooting mode//! Print AF point//! Print digital zoom setting//! Print manual focus distance//! Print lens information//! Print lens type//! Print autofocus mode//! Print ISO setting//! @name Print functions for Nikon3 %MakerNote tags//! Return read-only list of built-in Lens Data 3 tags//! Return read-only list of built-in Lens Data 2 tags//! Return read-only list of built-in Lens Data 1 tags//! Return read-only list of built-in Color Balance 4 tags//! Return read-only list of built-in Color Balance 3 tags//! Return read-only list of built-in Color Balance 2b tags//! Return read-only list of built-in Color Balance 2a tags//! Return read-only list of built-in Color Balance 2 tags//! Return read-only list of built-in Color Balance 1 tags//! Return read-only list of built-in Shot Info tags//! Return read-only list of built-in Shot Info D300 (b) tags//! Return read-only list of built-in Shot Info D300 (a) tags//! Return read-only list of built-in Shot Info D40 tags//! Return read-only list of built-in Shot Info D80 tags//! Return read-only list of built-in Flash Info 3 tags//! Return read-only list of built-in Flash Info 2 tags//! Return read-only list of built-in Flash Info 1 tags//! Return read-only list of built-in Multi Exposure tags//! Return read-only list of built-in File Info tags//! Return read-only list of built-in AF Fine Tune tags//! Return read-only list of built-in Auto Focus 2 tags//! Return read-only list of built-in Auto Focus tags//! Return read-only list of built-in ISO info tags//! Return read-only list of built-in World time tags//! Return read-only list of built-in Picture Control tags//! Return read-only list of built-in Vibration Reduction tags//! Return read-only list of built-in Nikon3 tags//! A third MakerNote format used by Nikon cameras, e.g., E5400, SQ, D2H, D70// class Nikon2MakerNote//! @name Print functions for Nikon2 %MakerNote tags//! Return read-only list of built-in Nikon2 tags/*!
      @brief A second MakerNote format used by Nikon cameras, including the
             E700, E800, E900, E900S, E910, E950
     */// class Nikon1MakerNote//! Print BarometerInfo//! Print AF focus position//! @name Print functions for Nikon1 %MakerNote tags//! Return read-only list of built-in Nikon1 tags//! A MakerNote format used by Nikon cameras, such as the E990 and D1./*!
  @file    nikonmn_int.hpp
  @brief   Nikon makernote tags.<BR>References:<BR>
  [1] <a href="http://www.tawbaware.com/990exif.htm">MakerNote EXIF Tag of the Nikon 990</a> by Max Lyons<BR>
  [2] <a href="http://park2.wakwak.com/%7Etsuruzoh/Computer/Digicams/exif-e.html">Exif file format</a> by TsuruZoh Tachibanaya<BR>
  [3] "EXIFutils Field Reference Guide"<BR>
  [3] <a href="http://www.ozhiker.com/electronics/pjmt/jpeg_info/nikon_mn.html#Nikon_Type_3_Tags">Nikon Type 3 Makernote Tags Definition</a> of the PHP JPEG Metadata Toolkit by Evan Hunter<BR>
  [4] <a href="http://www.sno.phy.queensu.ca/~phil/exiftool/">ExifTool</a> by Phil Harvey<BR>
  [5] Email communication with <a href="http://www.rottmerhusen.com">Robert Rottmerhusen</a><BR>
  [6] Email communication with Roger Larsson<BR>
  [7] <a href="http://www.cybercom.net/~dcoffin/dcraw/">Decoding raw digital photos in Linux</a> by Dave Coffin<br>

  @author  Andreas Huggel (ahu)
           <a href="mailto:ahuggel@gmx.net">ahuggel@gmx.net</a>
  @author  Gilles Caulier (gc)
           <a href="mailto:caulier dot gilles at gmail dot com">caulier dot gilles at gmail dot com</a>
  @author  Jens Mueller (jm)
           <a href="mailto:tschensinger at web dot de">tschensinger at web dot de</a>
  @date    17-May-04, ahu: created<BR>
           25-May-04, ahu: combined all Nikon formats in one component
 *//Users/owura/Repos/codeql_eval/proj_repos/Exiv2-exiv2-pull-962-commits-e925bc5addd881543fa503470c8a859e112cca62/exiv2/src/nikonmn_int.cppFMntLensFMntLens &const FMntLensconst FMntLens &testConfigFilenikon"nikon"pcval-127User"User"UTC "UTC " Hz" Hz" 9; "; "f1f2 um" um"epp2048.0fstopsfocaldist0.0100000000000000002140.0NikonLd3"NikonLd3"NikonLd2"NikonLd2"NikonLd1"NikonLd1"const FMntLens[]FMntLens[]fmountlensvidconst FMntLens *FMntLens *const FMntLens[553]FMntLens[553]rawtagspreExif."Exif."Exif.Nikon3.LensType"Exif.Nikon3.LensType"lensIDStreamSigma"Sigma"LensIDNumber"LensIDNumber"LensFStops"LensFStops"MCUVersion"MCUVersion"0x58JAA00901"JAA00901"AF Nikkor 50mm f/1.8"AF Nikkor 50mm f/1.8"0x440x5CJAA72701"JAA72701"AF Zoom-Nikkor 35-70mm f/3.3-4.5"AF Zoom-Nikkor 35-70mm f/3.3-4.5"JAA72801"JAA72801"AF Zoom-Nikkor 70-210mm f/4"AF Zoom-Nikkor 70-210mm f/4"0x3C0x24JAA12001"JAA12001"AF Nikkor 28mm f/2.8"AF Nikkor 28mm f/2.8"0x540x0CJAA01001"JAA01001"AF Nikkor 50mm f/1.4"AF Nikkor 50mm f/1.4"0x53JAA62101"JAA62101"AF Micro-Nikkor 55mm f/2.8"AF Micro-Nikkor 55mm f/2.8"0x620x2CJAA72901"JAA72901"AF Zoom-Nikkor 28-85mm f/3.5-4.5"AF Zoom-Nikkor 28-85mm f/3.5-4.5"0x6AJAA73001"JAA73001"AF Zoom-Nikkor 35-105mm f/3.5-4.5"AF Zoom-Nikkor 35-105mm f/3.5-4.5"0x090x37JAA12101"JAA12101"AF Nikkor 24mm f/2.8"AF Nikkor 24mm f/2.8"0x0A0x8EJAA322AA"JAA322AA"AF Nikkor 300mm f/2.8 IF-ED"AF Nikkor 300mm f/2.8 IF-ED"JAA322AB"JAA322AB"0x0B0x7CJAA32101"JAA32101"AF Nikkor 180mm f/2.8 IF-ED"AF Nikkor 180mm f/2.8 IF-ED"0x0D0x72JAA73101"JAA73101"AF Zoom-Nikkor 35-135mm f/3.5-4.5"AF Zoom-Nikkor 35-135mm f/3.5-4.5"0x0EJAA009AD"JAA009AD"AF Nikkor 50mm f/1.8 N"AF Nikkor 50mm f/1.8 N"JAA32301"JAA32301"AF Nikkor 300mm f/4 IF-ED"AF Nikkor 300mm f/4 IF-ED"0x11JAA73301"JAA73301"AF Zoom-Nikkor 35-70mm f/2.8"AF Zoom-Nikkor 35-70mm f/2.8"0x15JAA73201"JAA73201"AF Nikkor 70-210mm f/4-5.6"AF Nikkor 70-210mm f/4-5.6"JAA73401"JAA73401"AF Zoom-Nikkor 24-50mm f/3.3-4.5"AF Zoom-Nikkor 24-50mm f/3.3-4.5"JAA73501"JAA73501"AF Zoom-Nikkor 80-200mm f/2.8 ED"AF Zoom-Nikkor 80-200mm f/2.8 ED"0x4CJAA32401"JAA32401"AF Nikkor 85mm f/1.8"AF Nikkor 85mm f/1.8"0x170xA0JAA518AA"JAA518AA"Nikkor 500mm f/4 P ED IF"Nikkor 500mm f/4 P ED IF"0x18JAA736AA"JAA736AA"AF Zoom-Nikkor 35-135mm f/3.5-4.5 N"AF Zoom-Nikkor 35-135mm f/3.5-4.5 N"0x1AJAA12201"JAA12201"AF Nikkor 35mm f/2"AF Nikkor 35mm f/2"0x1B0x5EJAA738AA"JAA738AA"AF Zoom-Nikkor 75-300mm f/4.5-5.6"AF Zoom-Nikkor 75-300mm f/4.5-5.6"JAA12301"JAA12301"AF Nikkor 20mm f/2.8"AF Nikkor 20mm f/2.8"0x1DAF Zoom-Nikkor 35-70mm f/3.3-4.5 N"AF Zoom-Nikkor 35-70mm f/3.3-4.5 N"0x1E0x56JAA62201"JAA62201"AF Micro-Nikkor 60mm f/2.8"AF Micro-Nikkor 60mm f/2.8"0x1FJAA62301"JAA62301"AF Micro-Nikkor 105mm f/2.8"AF Micro-Nikkor 105mm f/2.8"0x16AF Zoom-Nikkor 28-70mm f/3.5-4.5"AF Zoom-Nikkor 28-70mm f/3.5-4.5"JAA32501"JAA32501"AF DC-Nikkor 135mm f/2"AF DC-Nikkor 135mm f/2"0xBE0xCAZoom-Nikkor 1200-1700mm f/5.6-8 P ED IF"Zoom-Nikkor 1200-1700mm f/5.6-8 P ED IF"JAA742DA"JAA742DA"AF Zoom-Nikkor 80-200mm f/2.8D ED"AF Zoom-Nikkor 80-200mm f/2.8D ED"0x250x5cJAA743DA"JAA743DA"AF Zoom-Nikkor 35-70mm f/2.8D"AF Zoom-Nikkor 35-70mm f/2.8D"0x3A0x520x26JAA744DA"JAA744DA"AF Zoom-Nikkor 28-70mm f/3.5-4.5D"AF Zoom-Nikkor 28-70mm f/3.5-4.5D"0x27JAA326DA"JAA326DA"AF-I Nikkor 300mm f/2.8D IF-ED"AF-I Nikkor 300mm f/2.8D IF-ED"0xF1AF-I Nikkor 300mm f/2.8D IF-ED + TC-14E"AF-I Nikkor 300mm f/2.8D IF-ED + TC-14E"0xE1AF-I Nikkor 300mm f/2.8D IF-ED + TC-17E"AF-I Nikkor 300mm f/2.8D IF-ED + TC-17E"0xF2AF-I Nikkor 300mm f/2.8D IF-ED + TC-20E"AF-I Nikkor 300mm f/2.8D IF-ED + TC-20E"0x280xA6JAA519DA"JAA519DA"AF-I Nikkor 600mm f/4D IF-ED"AF-I Nikkor 600mm f/4D IF-ED"AF-I Nikkor 600mm f/4D IF-ED + TC-14E"AF-I Nikkor 600mm f/4D IF-ED + TC-14E"AF-I Nikkor 600mm f/4D IF-ED + TC-17E"AF-I Nikkor 600mm f/4D IF-ED + TC-17E"AF-I Nikkor 600mm f/4D IF-ED + TC-20E"AF-I Nikkor 600mm f/4D IF-ED + TC-20E"JAA124DA"JAA124DA"AF Nikkor 28mm f/1.4D"AF Nikkor 28mm f/1.4D"AF Zoom-Nikkor 35-80mm f/4-5.6D"AF Zoom-Nikkor 35-80mm f/4-5.6D"JAA327DA"JAA327DA"AF DC-Nikkor 105mm f/2D"AF DC-Nikkor 105mm f/2D"0x2DJAA624DA"JAA624DA"AF Micro-Nikkor 200mm f/4D IF-ED"AF Micro-Nikkor 200mm f/4D IF-ED"0x2EJAA747DA"JAA747DA"AF Nikkor 70-210mm f/4-5.6D"AF Nikkor 70-210mm f/4-5.6D"0x2FJAA746DA"JAA746DA"AF Zoom-Nikkor 20-35mm f/2.8D IF"AF Zoom-Nikkor 20-35mm f/2.8D IF"0x98JAA520DA"JAA520DA"AF-I Nikkor 400mm f/2.8D IF-ED"AF-I Nikkor 400mm f/2.8D IF-ED"AF-I Nikkor 400mm f/2.8D IF-ED + TC-14E"AF-I Nikkor 400mm f/2.8D IF-ED + TC-14E"AF-I Nikkor 400mm f/2.8D IF-ED + TC-17E"AF-I Nikkor 400mm f/2.8D IF-ED + TC-17E"AF-I Nikkor 400mm f/2.8D IF-ED + TC-20E"AF-I Nikkor 400mm f/2.8D IF-ED + TC-20E"0x31JAA625DA"JAA625DA"AF Micro-Nikkor 60mm f/2.8D"AF Micro-Nikkor 60mm f/2.8D"0x320x35JAA627DA"JAA627DA"AF Micro-Nikkor 105mm f/2.8D"AF Micro-Nikkor 105mm f/2.8D"0x33JAA126DA"JAA126DA"AF Nikkor 18mm f/2.8D"AF Nikkor 18mm f/2.8D"JAA626DA"JAA626DA"AF Fisheye Nikkor 16mm f/2.8D"AF Fisheye Nikkor 16mm f/2.8D"JAA521DA"JAA521DA"AF-I Nikkor 500mm f/4D IF-ED"AF-I Nikkor 500mm f/4D IF-ED"AF-I Nikkor 500mm f/4D IF-ED + TC-14E"AF-I Nikkor 500mm f/4D IF-ED + TC-14E"AF-I Nikkor 500mm f/4D IF-ED + TC-17E"AF-I Nikkor 500mm f/4D IF-ED + TC-17E"AF-I Nikkor 500mm f/4D IF-ED + TC-20E"AF-I Nikkor 500mm f/4D IF-ED + TC-20E"0x36JAA125DA"JAA125DA"AF Nikkor 24mm f/2.8D"AF Nikkor 24mm f/2.8D"JAA127DA"JAA127DA"AF Nikkor 20mm f/2.8D"AF Nikkor 20mm f/2.8D"0x38JAA328DA"JAA328DA"AF Nikkor 85mm f/1.8D"AF Nikkor 85mm f/1.8D"0x390x3BAF Zoom-Nikkor 35-70mm f/2.8D N"AF Zoom-Nikkor 35-70mm f/2.8D N"0x3D0x3EJAA128DA"JAA128DA"AF Nikkor 28mm f/2.8D"AF Nikkor 28mm f/2.8D"0x3FJAA748DA"JAA748DA"AF Zoom-Nikkor 35-105mm f/3.5-4.5D"AF Zoom-Nikkor 35-105mm f/3.5-4.5D"0x7cJAA330DA"JAA330DA"AF Nikkor 180mm f/2.8D IF-ED"AF Nikkor 180mm f/2.8D IF-ED"JAA129DA"JAA129DA"AF Nikkor 35mm f/2D"AF Nikkor 35mm f/2D"0x46JAA011DB"JAA011DB"AF Nikkor 50mm f/1.4D"AF Nikkor 50mm f/1.4D"0x47JAA753DB"JAA753DB"AF Zoom-Nikkor 80-200mm f/4.5-5.6D"AF Zoom-Nikkor 80-200mm f/4.5-5.6D"JAA752DA"JAA752DA"AF Zoom-Nikkor 28-80mm f/3.5-5.6D"AF Zoom-Nikkor 28-80mm f/3.5-5.6D"0x49JAA754DA"JAA754DA"AF Zoom-Nikkor 35-80mm f/4-5.6D N"AF Zoom-Nikkor 35-80mm f/4-5.6D N"0x4AJAA756DA"JAA756DA"AF Zoom-Nikkor 24-50mm f/3.3-4.5D"AF Zoom-Nikkor 24-50mm f/3.3-4.5D"0x4BJAA333DA"JAA333DA"AF-S Nikkor 300mm f/2.8D IF-ED"AF-S Nikkor 300mm f/2.8D IF-ED"AF-S Nikkor 300mm f/2.8D IF-ED + TC-14E"AF-S Nikkor 300mm f/2.8D IF-ED + TC-14E"AF-S Nikkor 300mm f/2.8D IF-ED + TC-17E"AF-S Nikkor 300mm f/2.8D IF-ED + TC-17E"AF-S Nikkor 300mm f/2.8D IF-ED + TC-20E"AF-S Nikkor 300mm f/2.8D IF-ED + TC-20E"JAA522DA"JAA522DA"AF-S Nikkor 600mm f/4D IF-ED"AF-S Nikkor 600mm f/4D IF-ED"AF-S Nikkor 600mm f/4D IF-ED + TC-14E"AF-S Nikkor 600mm f/4D IF-ED + TC-14E"AF-S Nikkor 600mm f/4D IF-ED + TC-17E"AF-S Nikkor 600mm f/4D IF-ED + TC-17E"AF-S Nikkor 600mm f/4D IF-ED + TC-20E"AF-S Nikkor 600mm f/4D IF-ED + TC-20E"0x4DJAA332DA"JAA332DA"AF Nikkor 85mm f/1.4D IF"AF Nikkor 85mm f/1.4D IF"0x4EJAA523DA"JAA523DA"AF-S Nikkor 500mm f/4D IF-ED"AF-S Nikkor 500mm f/4D IF-ED"AF-S Nikkor 500mm f/4D IF-ED + TC-14E"AF-S Nikkor 500mm f/4D IF-ED + TC-14E"AF-S Nikkor 500mm f/4D IF-ED + TC-17E"AF-S Nikkor 500mm f/4D IF-ED + TC-17E"AF-S Nikkor 500mm f/4D IF-ED + TC-20E"AF-S Nikkor 500mm f/4D IF-ED + TC-20E"0x6E0x4FJAA757DA"JAA757DA"AF Zoom-Nikkor 24-120mm f/3.5-5.6D IF"AF Zoom-Nikkor 24-120mm f/3.5-5.6D IF"JAA758DA"JAA758DA"AF Zoom-Nikkor 28-200mm f/3.5-5.6D IF"AF Zoom-Nikkor 28-200mm f/3.5-5.6D IF"0x51JAA329DA"JAA329DA"AF DC-Nikkor 135mm f/2D"AF DC-Nikkor 135mm f/2D"JBA701AA"JBA701AA"IX-Nikkor 24-70mm f/3.5-5.6"IX-Nikkor 24-70mm f/3.5-5.6"JBA702AA"JBA702AA"IX-Nikkor 60-180mm f/4-5.6"IX-Nikkor 60-180mm f/4-5.6"0x57JAA762DA"JAA762DA"JAA763DA"JAA763DA"AF Zoom-Micro Nikkor 70-180mm f/4.5-5.6D ED"AF Zoom-Micro Nikkor 70-180mm f/4.5-5.6D ED"0x610x5AJAA764DA"JAA764DA"AF Zoom-Nikkor 70-300mm f/4-5.6D ED"AF Zoom-Nikkor 70-300mm f/4-5.6D ED"0x590x5DJAA524DA"JAA524DA"AF-S Nikkor 400mm f/2.8D IF-ED"AF-S Nikkor 400mm f/2.8D IF-ED"AF-S Nikkor 400mm f/2.8D IF-ED + TC-14E"AF-S Nikkor 400mm f/2.8D IF-ED + TC-14E"AF-S Nikkor 400mm f/2.8D IF-ED + TC-17E"AF-S Nikkor 400mm f/2.8D IF-ED + TC-17E"AF-S Nikkor 400mm f/2.8D IF-ED + TC-20E"AF-S Nikkor 400mm f/2.8D IF-ED + TC-20E"JBA704AA"JBA704AA"IX-Nikkor 30-60mm f/4-5.6"IX-Nikkor 30-60mm f/4-5.6"0x5B0x5FJBA705AA"JBA705AA"IX-Nikkor 60-180mm f/4.5-5.6"IX-Nikkor 60-180mm f/4.5-5.6"0x63JAA767DA"JAA767DA"AF-S Zoom-Nikkor 28-70mm f/2.8D IF-ED"AF-S Zoom-Nikkor 28-70mm f/2.8D IF-ED"0x64JAA765DA"JAA765DA"AF-S Zoom-Nikkor 80-200mm f/2.8D IF-ED"AF-S Zoom-Nikkor 80-200mm f/2.8D IF-ED"0x65JAA766DA"JAA766DA"AF Zoom-Nikkor 28-105mm f/3.5-4.5D IF"AF Zoom-Nikkor 28-105mm f/3.5-4.5D IF"JAA769DA"JAA769DA"0x67JAA768DA"JAA768DA"AF Zoom-Nikkor 75-240mm f/4.5-5.6D"AF Zoom-Nikkor 75-240mm f/4.5-5.6D"0x68JAA770DA"JAA770DA"AF-S Nikkor 17-35mm f/2.8D IF-ED"AF-S Nikkor 17-35mm f/2.8D IF-ED"JAA628DA"JAA628DA"PC Micro-Nikkor 85mm f/2.8D"PC Micro-Nikkor 85mm f/2.8D"0x6BJAA771DA"JAA771DA"AF VR Zoom-Nikkor 80-400mm f/4.5-5.6D ED"AF VR Zoom-Nikkor 80-400mm f/4.5-5.6D ED"0x6CJAA772DA"JAA772DA"AF Zoom-Nikkor 18-35mm f/3.5-4.5D IF-ED"AF Zoom-Nikkor 18-35mm f/3.5-4.5D IF-ED"0x6DJAA774DA"JAA774DA"AF Zoom-Nikkor 24-85mm f/2.8-4D IF"AF Zoom-Nikkor 24-85mm f/2.8-4D IF"JAA777DA"JAA777DA"AF Zoom-Nikkor 28-80mm f/3.3-5.6G"AF Zoom-Nikkor 28-80mm f/3.3-5.6G"0x6FJAA776DA"JAA776DA"AF Zoom-Nikkor 70-300mm f/4-5.6G"AF Zoom-Nikkor 70-300mm f/4-5.6G"JAA334DA"JAA334DA"AF-S Nikkor 300mm f/4D IF-ED"AF-S Nikkor 300mm f/4D IF-ED"0x71JAA130DA"JAA130DA"AF Nikkor ED 14mm f/2.8D"AF Nikkor ED 14mm f/2.8D"0x73JAA335DA"JAA335DA"AF-S Nikkor 300mm f/2.8D IF-ED II"AF-S Nikkor 300mm f/2.8D IF-ED II"0x74JAA525DA"JAA525DA"AF-S Nikkor 400mm f/2.8D IF-ED II"AF-S Nikkor 400mm f/2.8D IF-ED II"0x75JAA526DA"JAA526DA"AF-S Nikkor 500mm f/4D IF-ED II"AF-S Nikkor 500mm f/4D IF-ED II"0x76JAA527DA"JAA527DA"AF-S Nikkor 600mm f/4D IF-ED II"AF-S Nikkor 600mm f/4D IF-ED II"0x77JAA012AA"JAA012AA"Nikkor 45mm f/2.8 P"Nikkor 45mm f/2.8 P"JAA780DA"JAA780DA"AF-S Zoom-Nikkor 24-85mm f/3.5-4.5G IF-ED"AF-S Zoom-Nikkor 24-85mm f/3.5-4.5G IF-ED"0x79JAA778DA"JAA778DA"AF Zoom-Nikkor 28-100mm f/3.5-5.6G"AF Zoom-Nikkor 28-100mm f/3.5-5.6G"0x7AJAA013DA"JAA013DA"AF Nikkor 50mm f/1.8D"AF Nikkor 50mm f/1.8D"0x7BJAA781DA"JAA781DA"AF-S VR Zoom-Nikkor 70-200mm f/2.8G IF-ED"AF-S VR Zoom-Nikkor 70-200mm f/2.8G IF-ED"JAA782DA"JAA782DA"AF-S VR Zoom-Nikkor 24-120mm f/3.5-5.6G IF-ED"AF-S VR Zoom-Nikkor 24-120mm f/3.5-5.6G IF-ED"0x7FJAA783DA"JAA783DA"AF Zoom-Nikkor 28-200mm f/3.5-5.6G IF-ED"AF Zoom-Nikkor 28-200mm f/3.5-5.6G IF-ED"JAA784DA"JAA784DA"AF-S DX Zoom-Nikkor 12-24mm f/4G IF-ED"AF-S DX Zoom-Nikkor 12-24mm f/4G IF-ED"JAA787DA"JAA787DA"AF-S VR Zoom-Nikkor 200-400mm f/4G IF-ED"AF-S VR Zoom-Nikkor 200-400mm f/4G IF-ED"0x7DJAA788DA"JAA788DA"AF-S DX Zoom-Nikkor 17-55mm f/2.8G IF-ED"AF-S DX Zoom-Nikkor 17-55mm f/2.8G IF-ED"JAA790DA"JAA790DA"AF-S DX Zoom-Nikkor 18-70mm f/3.5-4.5G IF-ED"AF-S DX Zoom-Nikkor 18-70mm f/3.5-4.5G IF-ED"JAA629DA"JAA629DA"AF DX Fisheye-Nikkor 10.5mm f/2.8G ED"AF DX Fisheye-Nikkor 10.5mm f/2.8G ED"JAA336DA"JAA336DA"AF-S VR Nikkor 200mm f/2G IF-ED"AF-S VR Nikkor 200mm f/2G IF-ED"JAA337DA"JAA337DA"AF-S VR Nikkor 300mm f/2.8G IF-ED"AF-S VR Nikkor 300mm f/2.8G IF-ED"0xB0FSA-L2, EDG 65, 800mm F13 G"FSA-L2, EDG 65, 800mm F13 G"0x890x8BJAA793DA"JAA793DA"AF-S DX Zoom-Nikkor 55-200mm f/4-5.6G ED"AF-S DX Zoom-Nikkor 55-200mm f/4-5.6G ED"0x8A0x8CJAA630DA"JAA630DA"AF-S VR Micro-Nikkor 105mm f/2.8G IF-ED"AF-S VR Micro-Nikkor 105mm f/2.8G IF-ED"0x8DJAA794DA"JAA794DA"AF-S DX VR Zoom-Nikkor 18-200mm f/3.5-5.6G IF-ED"AF-S DX VR Zoom-Nikkor 18-200mm f/3.5-5.6G IF-ED"0xFDJAA813DA"JAA813DA"AF-S DX VR Zoom-Nikkor 18-200mm f/3.5-5.6G IF-ED II"AF-S DX VR Zoom-Nikkor 18-200mm f/3.5-5.6G IF-ED II"JAA792DA"JAA792DA"AF-S DX Zoom-Nikkor 18-55mm f/3.5-5.6G ED"AF-S DX Zoom-Nikkor 18-55mm f/3.5-5.6G ED"0x8FJAA795DA"JAA795DA"AF-S VR Zoom-Nikkor 70-300mm f/4.5-5.6G IF-ED"AF-S VR Zoom-Nikkor 70-300mm f/4.5-5.6G IF-ED"0x91JAA796DA"JAA796DA"AF-S DX Zoom-Nikkor 18-135mm f/3.5-5.6G IF-ED"AF-S DX Zoom-Nikkor 18-135mm f/3.5-5.6G IF-ED"0x92JAA798DA"JAA798DA"AF-S DX VR Zoom-Nikkor 55-200mm f/4-5.6G IF-ED"AF-S DX VR Zoom-Nikkor 55-200mm f/4-5.6G IF-ED"0x94JAA801DA"JAA801DA"AF-S Zoom-Nikkor 14-24mm f/2.8G ED"AF-S Zoom-Nikkor 14-24mm f/2.8G ED"0x930x95JAA802DA"JAA802DA"AF-S Zoom-Nikkor 24-70mm f/2.8G ED"AF-S Zoom-Nikkor 24-70mm f/2.8G ED"0x96JAA797DA"JAA797DA"AF-S DX Zoom-Nikkor 18-55mm f/3.5-5.6G ED II"AF-S DX Zoom-Nikkor 18-55mm f/3.5-5.6G ED II"0x97JAA631DA"JAA631DA"PC-E Nikkor 24mm f/3.5D ED"PC-E Nikkor 24mm f/3.5D ED"JAA528DA"JAA528DA"AF-S VR Nikkor 400mm f/2.8G ED"AF-S VR Nikkor 400mm f/2.8G ED"0x99JAA529DA"JAA529DA"AF-S VR Nikkor 500mm f/4G ED"AF-S VR Nikkor 500mm f/4G ED"0x9AJAA530DA"JAA530DA"AF-S VR Nikkor 600mm f/4G ED"AF-S VR Nikkor 600mm f/4G ED"0x9BJAA800DA"JAA800DA"AF-S DX VR Zoom-Nikkor 16-85mm f/3.5-5.6G ED"AF-S DX VR Zoom-Nikkor 16-85mm f/3.5-5.6G ED"0x9CJAA803DA"JAA803DA"AF-S DX VR Zoom-Nikkor 18-55mm f/3.5-5.6G"AF-S DX VR Zoom-Nikkor 18-55mm f/3.5-5.6G"0x9DJAA633DA"JAA633DA"PC-E Micro Nikkor 45mm f/2.8D ED"PC-E Micro Nikkor 45mm f/2.8D ED"0x9EJAA632DA"JAA632DA"AF-S Micro Nikkor 60mm f/2.8G ED"AF-S Micro Nikkor 60mm f/2.8G ED"0x9FJAA634DA"JAA634DA"PC-E Micro Nikkor 85mm f/2.8D"PC-E Micro Nikkor 85mm f/2.8D"JAA805DA"JAA805DA"AF-S DX VR Zoom-Nikkor 18-105mm f/3.5-5.6G ED"AF-S DX VR Zoom-Nikkor 18-105mm f/3.5-5.6G ED"0xA1JAA132DA"JAA132DA"AF-S DX Nikkor 35mm f/1.8G"AF-S DX Nikkor 35mm f/1.8G"0xA2JAA014DA"JAA014DA"AF-S Nikkor 50mm f/1.4G"AF-S Nikkor 50mm f/1.4G"0xA3JAA804DA"JAA804DA"AF-S DX Nikkor 10-24mm f/3.5-4.5G ED"AF-S DX Nikkor 10-24mm f/3.5-4.5G ED"0xA4JAA807DA"JAA807DA"AF-S Nikkor 70-200mm f/2.8G ED VR II"AF-S Nikkor 70-200mm f/2.8G ED VR II"0xA5JAA806DA"JAA806DA"AF-S Nikkor 16-35mm f/4G ED VR"AF-S Nikkor 16-35mm f/4G ED VR"JAA131DA"JAA131DA"AF-S Nikkor 24mm f/1.4G ED"AF-S Nikkor 24mm f/1.4G ED"0xA7JAA808DA"JAA808DA"AF-S Nikkor 28-300mm f/3.5-5.6G ED VR"AF-S Nikkor 28-300mm f/3.5-5.6G ED VR"0xA8JAA339DA"JAA339DA"AF-S Nikkor 300mm f/2.8G IF-ED VR II"AF-S Nikkor 300mm f/2.8G IF-ED VR II"0xA9JAA637DA"JAA637DA"AF-S DX Micro Nikkor 85mm f/3.5G ED VR"AF-S DX Micro Nikkor 85mm f/3.5G ED VR"0xAAJAA809DA"JAA809DA"AF-S Zoom-Nikkor 200-400mm f/4G IF-ED VR II"AF-S Zoom-Nikkor 200-400mm f/4G IF-ED VR II"0xABJAA340DA"JAA340DA"AF-S Nikkor 200mm f/2G ED VR II"AF-S Nikkor 200mm f/2G ED VR II"0xACJAA811DA"JAA811DA"AF-S Nikkor 24-120mm f/4G ED VR"AF-S Nikkor 24-120mm f/4G ED VR"0xAEJAA814DA"JAA814DA"AF-S DX Nikkor 55-300mm f/4.5-5.6G ED VR"AF-S DX Nikkor 55-300mm f/4.5-5.6G ED VR"0xAD0xAFJAA812DA"JAA812DA"AF-S DX Nikkor 18-300mm f/3.5-5.6G ED VR"AF-S DX Nikkor 18-300mm f/3.5-5.6G ED VR"JAA338DA"JAA338DA"AF-S Nikkor 85mm f/1.4G"AF-S Nikkor 85mm f/1.4G"0xB1JAA134DA"JAA134DA"AF-S Nikkor 35mm f/1.4G"AF-S Nikkor 35mm f/1.4G"0xB2JAA015DA"JAA015DA"AF-S Nikkor 50mm f/1.8G"AF-S Nikkor 50mm f/1.8G"0xB3JAA638DA"JAA638DA"AF-S DX Micro Nikkor 40mm f/2.8G"AF-S DX Micro Nikkor 40mm f/2.8G"0xB4JAA815DA"JAA815DA"AF-S Nikkor 70-200mm f/4G ED VR"AF-S Nikkor 70-200mm f/4G ED VR"0xB5JAA341DA"JAA341DA"AF-S Nikkor 85mm f/1.8G"AF-S Nikkor 85mm f/1.8G"0xB6JAA816DA"JAA816DA"AF-S Nikkor 24-85mm f/3.5-4.5G ED VR"AF-S Nikkor 24-85mm f/3.5-4.5G ED VR"0xB7JAA135DA"JAA135DA"AF-S Nikkor 28mm f/1.8G"AF-S Nikkor 28mm f/1.8G"0xB8JAA531DA"JAA531DA"AF-S VR Nikkor 800mm f/5.6E FL ED"AF-S VR Nikkor 800mm f/5.6E FL ED"0xB9JAA817DA"JAA817DA"AF-S Nikkor 80-400mm f/4.5-5.6G ED VR"AF-S Nikkor 80-400mm f/4.5-5.6G ED VR"0xBAJAA818DA"JAA818DA"AF-S Nikkor 18-35mm f/3.5-4.5G ED"AF-S Nikkor 18-35mm f/3.5-4.5G ED"JAA819DA"JAA819DA"AF-S DX Nikkor 18-140mm f/3.5-5.6G ED VR"AF-S DX Nikkor 18-140mm f/3.5-5.6G ED VR"0x550xBCJAA136DA"JAA136DA"AF-S Nikkor 58mm f/1.4G"AF-S Nikkor 58mm f/1.4G"0xBDJAA820DA"JAA820DA"AF-S DX Nikkor 18-55mm f/3.5-5.6G VR II"AF-S DX Nikkor 18-55mm f/3.5-5.6G VR II"JAA821DA"JAA821DA"AF-S DX Nikkor 18-300mm f/3.5-6.3G ED VR"AF-S DX Nikkor 18-300mm f/3.5-6.3G ED VR"0xC0JAA137DA"JAA137DA"AF-S Nikkor 35mm f/1.8G ED"AF-S Nikkor 35mm f/1.8G ED"0xC1JAA532DA"JAA532DA"AF-S Nikkor 400mm f/2.8E FL ED VR"AF-S Nikkor 400mm f/2.8E FL ED VR"0xC2JAA823DA"JAA823DA"AF-S DX Nikkor 55-200mm f/4-5.6G ED VR II"AF-S DX Nikkor 55-200mm f/4-5.6G ED VR II"0xC3JAA342DA"JAA342DA"AF-S Nikkor 300mm f/4E PF ED VR"AF-S Nikkor 300mm f/4E PF ED VR"0xC4JAA138DA"JAA138DA"AF-S Nikkor 20mm f/1.8G ED"AF-S Nikkor 20mm f/1.8G ED"0xC5JAA824DA"JAA824DA"AF-S Nikkor 24-70mm f/2.8E ED VR"AF-S Nikkor 24-70mm f/2.8E ED VR"0xC6JAA533DA"JAA533DA"AF-S Nikkor 500mm f/4E FL ED VR"AF-S Nikkor 500mm f/4E FL ED VR"0xC7JAA534DA"JAA534DA"AF-S Nikkor 600mm f/4E FL ED VR"AF-S Nikkor 600mm f/4E FL ED VR"0xC8JAA825DA"JAA825DA"AF-S DX Nikkor 16-80mm f/2.8-4E ED VR"AF-S DX Nikkor 16-80mm f/2.8-4E ED VR"0xC9JAA822DA"JAA822DA"AF-S Nikkor 200-500mm f/5.6E ED VR"AF-S Nikkor 200-500mm f/5.6E ED VR"JAA826DA"JAA826DA"AF-P DX Nikkor 18-55mm f/3.5-5.6G VR"AF-P DX Nikkor 18-55mm f/3.5-5.6G VR"JAA827DA"JAA827DA"AF-P DX Nikkor 18-55mm f/3.5-5.6G"AF-P DX Nikkor 18-55mm f/3.5-5.6G"0xCCJAA139DA"JAA139DA"AF-S Nikkor 24mm f/1.8G ED"AF-S Nikkor 24mm f/1.8G ED"0xCEJAA829DA"JAA829DA"AF-P DX Nikkor 70-300mm f/4.5-6.3G ED VR"AF-P DX Nikkor 70-300mm f/4.5-6.3G ED VR"JAA828DA"JAA828DA"AF-P DX Nikkor 70-300mm f/4.5-6.3G ED"AF-P DX Nikkor 70-300mm f/4.5-6.3G ED"0xCFJAA830DA"JAA830DA"AF-S Nikkor 70-200mm f/2.8E FL ED VR"AF-S Nikkor 70-200mm f/2.8E FL ED VR"0xD0JAA343DA"JAA343DA"AF-S Nikkor 105mm f/1.4E ED"AF-S Nikkor 105mm f/1.4E ED"0xD1JAA639DA"JAA639DA"PC Nikkor 19mm f/4E ED"PC Nikkor 19mm f/4E ED"0xD2JAA831DA"JAA831DA"AF-S Fisheye Nikkor 8-15mm f/3.5-4.5E ED"AF-S Fisheye Nikkor 8-15mm f/3.5-4.5E ED"0xD3JAA832DA"JAA832DA"AF-P DX Nikkor 10-20mm f/4.5-5.6G VR"AF-P DX Nikkor 10-20mm f/4.5-5.6G VR"0xD6JAA833DA"JAA833DA"AF-P Nikkor 70-300mm f/4.5-5.6E ED VR"AF-P Nikkor 70-300mm f/4.5-5.6E ED VR"0xD7JAA140DA"JAA140DA"AF-S Nikkor 28mm f/1.4E ED"AF-S Nikkor 28mm f/1.4E ED"JAA90701"JAA90701"TC-16A"TC-16A"0xFE486556"486556"4.5mm F2.8 EX DC HSM Circular Fisheye"4.5mm F2.8 EX DC HSM Circular Fisheye""483"8mm F4 EX Circular Fisheye"8mm F4 EX Circular Fisheye"485597"485597"8mm F3.5 EX Circular Fisheye"8mm F3.5 EX Circular Fisheye"0xDC0x19477554"477554"10mm F2.8 EX DC HSM Fisheye"10mm F2.8 EX DC HSM Fisheye""468"14mm F3.5"14mm F3.5"14mm F2.8 EX Aspherical HSM"14mm F2.8 EX Aspherical HSM"476441"476441"15mm F2.8 EX Diagonal Fisheye"15mm F2.8 EX Diagonal Fisheye"0xEA411442"411442"20mm F1.8 EX DG Aspherical RF"20mm F1.8 EX DG Aspherical RF"412555"412555"20mm F1.4 DG HSM | A"20mm F1.4 DG HSM | A"432447"432447"24mm F1.8 EX DG Aspherical Macro"24mm F1.8 EX DG Aspherical Macro""438"24mm F2.8 Super Wide II Macro"24mm F2.8 Super Wide II Macro"440442"440442"28mm F1.8 EX DG Aspherical Macro"28mm F1.8 EX DG Aspherical Macro"30mm F1.4 EX DC HSM"30mm F1.4 EX DC HSM"0xF835mm F1.4 DG HSM"35mm F1.4 DG HSM"0xDE310554"310554"50mm F1.4 EX DG HSM"50mm F1.4 EX DG HSM"311551"311551"50mm F1.4 DG HSM | A"50mm F1.4 DG HSM | A"Macro 50mm F2.8"Macro 50mm F2.8"346447"346447"Macro 50mm F2.8 EX DG"Macro 50mm F2.8 EX DG"0xE3270599"270599"Macro 70mm F2.8 EX DG"Macro 70mm F2.8 EX DG"85mm F1.4 EX DG HSM"85mm F1.4 EX DG HSM"Macro 90mm F2.8"Macro 90mm F2.8""256"Macro 105mm F2.8 EX DG"Macro 105mm F2.8 EX DG"0xE5257446"257446"Macro 105mm F2.8 EX DG OS HSM"Macro 105mm F2.8 EX DG OS HSM"104559"104559"APO Macro 150mm F2.8 EX DG HSM"APO Macro 150mm F2.8 EX DG HSM"0xF5APO Macro 150mm F2.8 EX DG OS HSM"APO Macro 150mm F2.8 EX DG OS HSM"APO Macro 180mm F3.5 EX DG HSM"APO Macro 180mm F3.5 EX DG HSM"105556"105556"APO Macro 180mm F2.8 EX DG OS HSM"APO Macro 180mm F2.8 EX DG OS HSM"APO 300mm F2.8 EX DG HSM"APO 300mm F2.8 EX DG HSM"0xFB195557"195557"APO Tele Macro 300mm F4"APO Tele Macro 300mm F4"APO 400mm F5.6"APO 400mm F5.6"APO Tele Macro 400mm F5.6"APO Tele Macro 400mm F5.6"APO 500mm F4.5"APO 500mm F4.5"APO 500mm F4.5 EX HSM"APO 500mm F4.5 EX HSM"184551"184551"APO 500mm F4.5 EX DG HSM"APO 500mm F4.5 EX DG HSM"APO 500mm F7.2"APO 500mm F7.2"APO 800mm F5.6"APO 800mm F5.6"APO 800mm F5.6 EX HSM"APO 800mm F5.6 EX HSM"8-16mm F4.5-5.6 DC HSM"8-16mm F4.5-5.6 DC HSM"10-20mm F3.5 EX DC HSM"10-20mm F3.5 EX DC HSM"201555"201555"10-20mm F4-5.6 EX DC HSM"10-20mm F4-5.6 EX DC HSM"0xF9200558"200558"12-24mm F4.5-5.6 EX DG Aspherical HSM"12-24mm F4.5-5.6 EX DG Aspherical HSM"0xF012-24mm F4.5-5.6 II DG HSM"12-24mm F4.5-5.6 II DG HSM"15-30mm F3.5-4.5 EX DG Aspherical DF"15-30mm F3.5-4.5 EX DG Aspherical DF"17-35mm F2.8-4 EX DG  Aspherical HSM"17-35mm F2.8-4 EX DG  Aspherical HSM"17-35mm F2.8-4 EX Aspherical"17-35mm F2.8-4 EX Aspherical"17-50mm F2.8 EX DC OS HSM"17-50mm F2.8 EX DC OS HSM"689599"689599"17-70mm F2.8-4.5 DC Macro Asp. IF HSM"17-70mm F2.8-4.5 DC Macro Asp. IF HSM"17-70mm F2.8-4.5 DC Macro Asp. IF"17-70mm F2.8-4.5 DC Macro Asp. IF"17-70mm F2.8-4 DC MACRO OS HSM | C"17-70mm F2.8-4 DC MACRO OS HSM | C"17-70mm F2.8-4 DC Macro OS HSM"17-70mm F2.8-4 DC Macro OS HSM"18-35mm F1.8 DC HSM"18-35mm F1.8 DC HSM"18-35mm F3.5-4.5 Aspherical"18-35mm F3.5-4.5 Aspherical"18-50mm F2.8 EX DC"18-50mm F2.8 EX DC"18-50mm F2.8 EX DC Macro"18-50mm F2.8 EX DC Macro"582593"582593"0xF618-50mm F2.8-4.5 DC OS HSM"18-50mm F2.8-4.5 DC OS HSM"18-50mm F3.5-5.6 DC"18-50mm F3.5-5.6 DC"551551"551551"18-50mm F3.5-5.6 DC HSM"18-50mm F3.5-5.6 DC HSM"18-125mm F3.5-5.6 DC"18-125mm F3.5-5.6 DC"0xCD853556"853556"18-125mm F3.8-5.6 DC OS HSM"18-125mm F3.8-5.6 DC OS HSM"777555"777555"18-200mm F3.5-6.3 DC"18-200mm F3.5-6.3 DC"0xFF888558"888558"18-200mm F3.5-6.3 DC OS HSM"18-200mm F3.5-6.3 DC OS HSM"0xED18-200mm F3.5-6.3 II DC OS HSM"18-200mm F3.5-6.3 II DC OS HSM"18-250mm F3.5-6.3 DC OS HSM"18-250mm F3.5-6.3 DC OS HSM"18-250mm F3.5-6.3 DC OS Macro HSM"18-250mm F3.5-6.3 DC OS Macro HSM"20-40mm F2.8"20-40mm F2.8"24-50mm F4-5.6 UC"24-50mm F4-5.6 UC"547448"547448"24-60mm F2.8 EX DG"24-60mm F2.8 EX DG"571559"571559"24-70mm F2.8 IF EX DG HSM"24-70mm F2.8 IF EX DG HSM"24-70mm F2.8 EX DG Macro"24-70mm F2.8 EX DG Macro"548445"548445"0xE924-70mm F3.5-5.6 Aspherical HF"24-70mm F3.5-5.6 Aspherical HF"24-105mm F4 DG OS HSM"24-105mm F4 DG OS HSM"24-135mm F2.8-4.5"24-135mm F2.8-4.5"28-70mm F2.8"28-70mm F2.8"28-70mm F2.8 EX"28-70mm F2.8 EX"549442"549442"28-70mm F2.8 EX DG"28-70mm F2.8 EX DG"634445"634445"28-70mm F2.8-4 DG"28-70mm F2.8-4 DG"28-70mm F3.5-4.5 UC"28-70mm F3.5-4.5 UC"28-80mm F3.5-5.6 Mini Zoom Macro II Aspherical"28-80mm F3.5-5.6 Mini Zoom Macro II Aspherical"28-90mm F3.5-5.6 Macro"28-90mm F3.5-5.6 Macro"28-105mm F2.8-4 Aspherical"28-105mm F2.8-4 Aspherical"28-105mm F3.8-5.6 UC-III Aspherical IF"28-105mm F3.8-5.6 UC-III Aspherical IF"28-200mm F3.5-5.6 Compact Aspherical Hyperzoom Macro"28-200mm F3.5-5.6 Compact Aspherical Hyperzoom Macro"28-300mm F3.8-5.6 Aspherical"28-300mm F3.8-5.6 Aspherical"795443"795443"28-300mm F3.5-6.3 DG Macro"28-300mm F3.5-6.3 DG Macro"0xE628-300mm F3.5-6.3 Macro"28-300mm F3.5-6.3 Macro"35-80mm F4-5.6"35-80mm F4-5.6"35-135mm F3.5-4.5 a"35-135mm F3.5-4.5 a"50-100mm F1.8 DC HSM | A"50-100mm F1.8 DC HSM | A"50-150mm F2.8 EX APO DC HSM"50-150mm F2.8 EX APO DC HSM"691554"691554"50-150mm F2.8 EX APO DC HSM II"50-150mm F2.8 EX APO DC HSM II"50-150 f/2.8 EX DC APO OS HSM"50-150 f/2.8 EX DC APO OS HSM"736552"736552"APO 50-500mm F4-6.3 EX HSM"APO 50-500mm F4-6.3 EX HSM"50-500mm F4.5-6.3 APO DG OS HSM"50-500mm F4.5-6.3 APO DG OS HSM"55-200mm F4-5.6 DC"55-200mm F4-5.6 DC"55-200mm F4-5.6 DC HSM"55-200mm F4-5.6 DC HSM"70-200mm F2.8 EX APO IF HSM"70-200mm F2.8 EX APO IF HSM"70-200mm F2.8 EX APO DG Macro HSM II"70-200mm F2.8 EX APO DG Macro HSM II"0xEE579555"579555"70-200mm F2.8 EX DG OS HSM"70-200mm F2.8 EX DG OS HSM"70-210mm F2.8 APO"70-210mm F2.8 APO"APO 70-210mm F3.5-4.5"APO 70-210mm F3.5-4.5"70-210mm F4-5.6 UC-II"70-210mm F4-5.6 UC-II"70-300mm F4-5.6 DG Macro"70-300mm F4-5.6 DG Macro"70-300mm F4-5.6 APO Macro Super II"70-300mm F4-5.6 APO Macro Super II"0xE0508555"508555"APO 70-300mm F4-5.6 DG Macro"APO 70-300mm F4-5.6 DG Macro"572556"572556"70-300mm F4-5.6 DG OS"70-300mm F4-5.6 DG OS"75-300mm F4.5-5.6 APO"75-300mm F4.5-5.6 APO"75-300mm F4.0-5.6"75-300mm F4.0-5.6"80-400mm f4.5-5.6 EX OS"80-400mm f4.5-5.6 EX OS"80-400mm f4.5-5.6 APO DG D OS"80-400mm f4.5-5.6 APO DG D OS"134556"134556"APO 100-300mm F4 EX IF HSM"APO 100-300mm F4 EX IF HSM"0xF3APO 120-300mm F2.8 EX DG HSM"APO 120-300mm F2.8 EX DG HSM"135553"135553"0xFA728557"728557"APO 120-400mm F4.5-5.6 DG OS HSM"APO 120-400mm F4.5-5.6 DG OS HSM"100-400mm F5-6.3 DG OS HSM C"100-400mm F5-6.3 DG OS HSM C"120-300mm F2.8 DG OS HSM | S"120-300mm F2.8 DG OS HSM | S"135-400mm F4.5-5.6 APO Aspherical"135-400mm F4.5-5.6 APO Aspherical"737559"737559"APO 150-500mm F5-6.3 DG OS HSM"APO 150-500mm F5-6.3 DG OS HSM"150-600mm F5-6.3 DG OS HSM Sports"150-600mm F5-6.3 DG OS HSM Sports"150-600mm F5-6.3 DG OS HSM Contemporary"150-600mm F5-6.3 DG OS HSM Contemporary"APO 170-500mm F5-6.3 Aspherical RF"APO 170-500mm F5-6.3 Aspherical RF"APO 200-500mm F2.8 EX DG"APO 200-500mm F2.8 EX DG"595555"595555"APO 300-800mm F5.6 EX DG HSM"APO 300-800mm F5.6 EX DG HSM"Tamron"Tamron"69E"69E"SP AF 14mm F/2.8 Aspherical (IF)"SP AF 14mm F/2.8 Aspherical (IF)"0xE80xDFF012"F012"SP 35mm F/1.8 Di VC USD"SP 35mm F/1.8 Di VC USD"0xE7F013"F013"SP 45mm F/1.8 Di VC USD"SP 45mm F/1.8 Di VC USD"0xF4G005"G005"SP AF 60mm F/2 Di II LD (IF) Macro 1:1"SP AF 60mm F/2 Di II LD (IF) Macro 1:1"52E"52E"SP AF 90mm F/2.5"SP AF 90mm F/2.5"152E"152E"SP AF 90mm F/2.5 Macro"SP AF 90mm F/2.5 Macro"72E"72E"SP AF 90mm F/2.8 Macro 1:1"SP AF 90mm F/2.8 Macro 1:1"172E"172E"272E"272E"SP AF 90mm F/2.8 Di Macro 1:1"SP AF 90mm F/2.8 Di Macro 1:1"272NII"272NII"F004"F004"SP 90mm F/2.8 Di VC USD MACRO 1:1"SP 90mm F/2.8 Di VC USD MACRO 1:1"0xE4F017"F017"SP 90mm f/2.8 Di VC USD Macro 1:1"SP 90mm f/2.8 Di VC USD Macro 1:1"B01"B01"SP AF 180mm F/3.5 Di Model"SP AF 180mm F/3.5 Di Model"60E"60E"SP AF 300mm F/2.8 LD-IF"SP AF 300mm F/2.8 LD-IF"360E"360E"B001"B001"SP AF 10-24mm F/3.5-4.5 Di II LD Aspherical (IF)"SP AF 10-24mm F/3.5-4.5 Di II LD Aspherical (IF)"A13"A13"SP AF 11-18mm F/4.5-5.6 Di II LD Aspherical (IF)"SP AF 11-18mm F/4.5-5.6 Di II LD Aspherical (IF)"A012"A012"SP 15-30mm F/2.8 Di VC USD"SP 15-30mm F/2.8 Di VC USD"B016"B016"AF 16-300mm F/3.5-6.3 Di II VC PZD"AF 16-300mm F/3.5-6.3 Di II VC PZD"A05"A05"SP AF 17-35mm F/2.8-4 Di LD Aspherical (IF)"SP AF 17-35mm F/2.8-4 Di LD Aspherical (IF)"A16"A16"SP AF 17-50mm F/2.8 XR Di II LD Aspherical (IF)"SP AF 17-50mm F/2.8 XR Di II LD Aspherical (IF)"A16NII"A16NII"B005"B005"SP AF 17-50mm F/2.8 XR Di II VC LD Aspherical (IF)"SP AF 17-50mm F/2.8 XR Di II VC LD Aspherical (IF)"A14"A14"AF 18-200mm F/3.5-6.3 XR Di II LD Aspherical (IF)"AF 18-200mm F/3.5-6.3 XR Di II LD Aspherical (IF)"AF 18-200mm F/3.5-6.3 XR Di II LD Aspherical (IF) Macro"AF 18-200mm F/3.5-6.3 XR Di II LD Aspherical (IF) Macro"A14NII"A14NII"0xFCB018"B018"AF 18-200mm f/3.5-6.3 Di II VC"AF 18-200mm f/3.5-6.3 Di II VC"A18"A18"AF 18-250mm F/3.5-6.3 Di II LD Aspherical (IF) Macro"AF 18-250mm F/3.5-6.3 Di II LD Aspherical (IF) Macro"A18NII"A18NII"AF 18-250mm F/3.5-6.3 Di II LD Aspherical (IF) Macro "AF 18-250mm F/3.5-6.3 Di II LD Aspherical (IF) Macro "B003"B003"AF 18-270mm F/3.5-6.3 Di II VC LD Aspherical (IF) Macro"AF 18-270mm F/3.5-6.3 Di II VC LD Aspherical (IF) Macro"B008"B008"AF 18-270mm F/3.5-6.3 Di II VC PZD"AF 18-270mm F/3.5-6.3 Di II VC PZD"B028"B028"AF 18-400mm F/3.5-6.3 Di II VC HLD"AF 18-400mm F/3.5-6.3 Di II VC HLD"A10"A10"AF 19-35mm F/3.5-4.5"AF 19-35mm F/3.5-4.5"166D"166D"SP AF 20-40mm F/2.7-3.5"SP AF 20-40mm F/2.7-3.5"A007"A007"SP 24-70mm F/2.8 Di VC USD"SP 24-70mm F/2.8 Di VC USD"A032"A032"SP 24-70mm F/2.8 Di VC USD G2"SP 24-70mm F/2.8 Di VC USD G2"190D"190D"SP AF 24-135mm F/3.5-5.6 AD Aspherical (IF) Macro"SP AF 24-135mm F/3.5-5.6 AD Aspherical (IF) Macro"A09"A09"SP AF 28-75mm F/2.8 XR Di LD Aspherical (IF) Macro"SP AF 28-75mm F/2.8 XR Di LD Aspherical (IF) Macro"A09NII"A09NII"177D"177D"AF 28-80mm F/3.5-5.6 Aspherical"AF 28-80mm F/3.5-5.6 Aspherical"176D"176D"SP AF 28-105mm F/2.8 LD Aspherical IF"SP AF 28-105mm F/2.8 LD Aspherical IF"A03N"A03N"AF 28-200mm F/3.8-5.6 XR Aspherical (IF) Macro"AF 28-200mm F/3.8-5.6 XR Aspherical (IF) Macro"71D"71D"AF 28-200mm F/3.8-5.6"AF 28-200mm F/3.8-5.6"171D"171D"AF 28-200mm F/3.8-5.6D"AF 28-200mm F/3.8-5.6D"271D"271D"AF 28-200mm F/3.8-5.6 LD Aspherical (IF)"AF 28-200mm F/3.8-5.6 LD Aspherical (IF)"A061"A061"AF 28-300mm F/3.5-6.3 XR Di LD Aspherical (IF)"AF 28-300mm F/3.5-6.3 XR Di LD Aspherical (IF)"185D"185D"AF 28-300mm F/3.5-6.3 XR LD Aspherical (IF)"AF 28-300mm F/3.5-6.3 XR LD Aspherical (IF)"A20"A20"AF 28-300mm F/3.5-6.3 XR Di VC LD Aspherical (IF) Macro"AF 28-300mm F/3.5-6.3 XR Di VC LD Aspherical (IF) Macro"A15"A15"AF 55-200mm F/4-5.6 Di II LD"AF 55-200mm F/4-5.6 Di II LD"0xF7A001"A001"SP AF 70-200mm F/2.8 Di LD (IF) Macro"SP AF 70-200mm F/2.8 Di LD (IF) Macro"A009"A009"SP AF 70-200mm F/2.8 Di VC USD"SP AF 70-200mm F/2.8 Di VC USD"572D/772D"572D/772D"AF 70-300mm F/4-5.6 LD Macro 1:2"AF 70-300mm F/4-5.6 LD Macro 1:2"A17N"A17N"AF 70-300mm F/4-5.6 Di LD Macro 1:2"AF 70-300mm F/4-5.6 Di LD Macro 1:2"A17NII"A17NII"A005"A005"SP 70-300mm F4-5.6 Di VC USD"SP 70-300mm F4-5.6 Di VC USD"0xEBA011"A011"SP AF 150-600mm F/5-6.3 VC USD"SP AF 150-600mm F/5-6.3 VC USD"A022"A022"SP AF 150-600mm F/5-6.3 Di VC USD G2"SP AF 150-600mm F/5-6.3 Di VC USD G2"75D"75D"AF 200-400mm F/5.6 LD IF"AF 200-400mm F/5.6 LD IF"A08"A08"SP AF 200-500mm F/5-6.3 Di LD (IF)"SP AF 200-500mm F/5-6.3 Di LD (IF)"SP AF 200-500mm F/5-6.3 Di"SP AF 200-500mm F/5-6.3 Di"Tokina"Tokina"AT-X 17 AF PRO (AF 17mm f/3.5)"AT-X 17 AF PRO (AF 17mm f/3.5)"T303503"T303503"AT-X M35 PRO DX (AF 35mm f/2.8 Macro)"AT-X M35 PRO DX (AF 35mm f/2.8 Macro)"T310003N"T310003N"AT-X M100 AF PRO D (AF 100mm f/2.8 Macro)"AT-X M100 AF PRO D (AF 100mm f/2.8 Macro)"AT-X 304 AF (AF 300mm f/4.0)"AT-X 304 AF (AF 300mm f/4.0)"AT-X 300 AF PRO (AF 300mm f/2.8)"AT-X 300 AF PRO (AF 300mm f/2.8)"AT-X 400 AF SD (AF 400mm f/5.6)"AT-X 400 AF SD (AF 400mm f/5.6)"T4101703"T4101703"AT-X 107 AF DX Fisheye (AF 10-17mm f/3.5-4.5)"AT-X 107 AF DX Fisheye (AF 10-17mm f/3.5-4.5)"T4111603"T4111603"AT-X 116 PRO DX (AF 11-16mm f/2.8)"AT-X 116 PRO DX (AF 11-16mm f/2.8)"AT-X 116 PRO DX II (AF 11-16mm f/2.8)"AT-X 116 PRO DX II (AF 11-16mm f/2.8)"AT-X 11-20 F2.8 PRO DX (AF 11-20mm f/2.8)"AT-X 11-20 F2.8 PRO DX (AF 11-20mm f/2.8)"T4122403"T4122403"AT-X 124 AF PRO DX (AF 12-24mm f/4)"AT-X 124 AF PRO DX (AF 12-24mm f/4)"T4122423"T4122423"AT-X 124 AF PRO DX II (AF 12-24mm f/4)"AT-X 124 AF PRO DX II (AF 12-24mm f/4)"AT-X 12-28 PRO DX (AF 12-28mm F/4)"AT-X 12-28 PRO DX (AF 12-28mm F/4)"AT-X 16-28 AF PRO FX (AF 16-28mm f/2.8)"AT-X 16-28 AF PRO FX (AF 16-28mm f/2.8)"AT-X 165 PRO DX (AF 16-50mm f/2.8)"AT-X 165 PRO DX (AF 16-50mm f/2.8)"AT-X 16.5-135 DX (AF 16.5-135mm F3.5-5.6)"AT-X 16.5-135 DX (AF 16.5-135mm F3.5-5.6)"AT-X 17-35 F4 PRO FX (AF 17-35mm f/4)"AT-X 17-35 F4 PRO FX (AF 17-35mm f/4)"AF 193 (AF 19-35mm f/3.5-4.5)"AF 193 (AF 19-35mm f/3.5-4.5)"AT-X 235 AF PRO (AF 20-35mm f/2.8)"AT-X 235 AF PRO (AF 20-35mm f/2.8)"AF 235 II (AF 20-35mm f/3.5-4.5)"AF 235 II (AF 20-35mm f/3.5-4.5)"AT-X 24-70MM F2.8 PRO FX (AF 24-70mm f/2.8)"AT-X 24-70MM F2.8 PRO FX (AF 24-70mm f/2.8)"AT-X 242 AF (AF 24-200mm f/3.5-5.6)"AT-X 242 AF (AF 24-200mm f/3.5-5.6)"AT-X 270 AF PRO II (AF 28-70mm f/2.6-2.8)"AT-X 270 AF PRO II (AF 28-70mm f/2.6-2.8)"AT-X 287 AF PRO SV (AF 28-70mm f/2.8)"AT-X 287 AF PRO SV (AF 28-70mm f/2.8)"AT-X 287 AF (AF 28-70mm f/2.8)"AT-X 287 AF (AF 28-70mm f/2.8)"AF 287 SD (AF 28-70mm f/2.8-4.5)"AF 287 SD (AF 28-70mm f/2.8-4.5)"AF 270 II (AF 28-70mm f/3.5-4.5)"AF 270 II (AF 28-70mm f/3.5-4.5)"AT-X 280 AF PRO (AF 28-80mm f/2.8)"AT-X 280 AF PRO (AF 28-80mm f/2.8)"AF 353 (AF 35-300mm f/4.5-6.7)"AF 353 (AF 35-300mm f/4.5-6.7)"AT-X 535 PRO DX (AF 50-135mm f/2.8)"AT-X 535 PRO DX (AF 50-135mm f/2.8)"AT-X 70-200MM F4 FX VCM-S (AF 70-200mm f/4)"AT-X 70-200MM F4 FX VCM-S (AF 70-200mm f/4)"AF 730 (AF 75-300mm F4.5-5.6)"AF 730 (AF 75-300mm F4.5-5.6)"AT-X 828 AF (AF 80-200mm f/2.8)"AT-X 828 AF (AF 80-200mm f/2.8)"AT-X 828 AF PRO (AF 80-200mm f/2.8)"AT-X 828 AF PRO (AF 80-200mm f/2.8)"AT-X 840 AF-II (AF 80-400mm f/4.5-5.6)"AT-X 840 AF-II (AF 80-400mm f/4.5-5.6)"AT-X 840 D (AF 80-400mm f/4.5-5.6)"AT-X 840 D (AF 80-400mm f/4.5-5.6)"AT-X 340 AF (AF 100-300mm f/4)"AT-X 340 AF (AF 100-300mm f/4)"Cosina"Cosina"AF 100mm F3.5 Macro"AF 100mm F3.5 Macro"AF Zoom 28-80mm F3.5-5.6 MC Macro"AF Zoom 28-80mm F3.5-5.6 MC Macro"AF Zoom 28-105mm F2.8-3.8 MC"AF Zoom 28-105mm F2.8-3.8 MC"AF Zoom 70-210mm F4.5-5.6 MC Macro"AF Zoom 70-210mm F4.5-5.6 MC Macro"AF Zoom 70-300mm F4.5-5.6 MC Macro"AF Zoom 70-300mm F4.5-5.6 MC Macro"AF Zoom 100-300mm F5.6-6.7 MC Macro"AF Zoom 100-300mm F5.6-6.7 MC Macro"Promaster"Promaster"Spectrum 7 100-400mm 1:4.5-6.7"Spectrum 7 100-400mm 1:4.5-6.7"Voigtlander"Voigtlander"BA295AN"BA295AN"Color Skopar 20mm F3.5 SLII Aspherical"Color Skopar 20mm F3.5 SLII Aspherical"Color Skopar 28mm F2.8 SL II"Color Skopar 28mm F2.8 SL II"BA229DN"BA229DN"Ultron 40mm F2 SLII Aspherical"Ultron 40mm F2 SLII Aspherical"BA239BN"BA239BN"Nokton 58mm F1.4 SLII"Nokton 58mm F1.4 SLII"APO-Lanthar 90mm F3.5 SLII Close Focus"APO-Lanthar 90mm F3.5 SLII Close Focus"Carl Zeiss"Carl Zeiss"Distagon T* 3,5/18 ZF.2"Distagon T* 3,5/18 ZF.2"Distagon T* 2,8/21 ZF.2"Distagon T* 2,8/21 ZF.2"Distagon T* 2/25 ZF.2"Distagon T* 2/25 ZF.2"Distagon T* 2/28 ZF.2"Distagon T* 2/28 ZF.2"Distagon T* 1.4/35 ZF.2"Distagon T* 1.4/35 ZF.2"Distagon T* 2/35 ZF.2"Distagon T* 2/35 ZF.2"Planar T* 1,4/50 ZF.2"Planar T* 1,4/50 ZF.2"Makro-Planar T* 2/50 ZF.2"Makro-Planar T* 2/50 ZF.2"Planar T* 1,4/85 ZF.2"Planar T* 1,4/85 ZF.2"Makro-Planar T* 2/100 ZF.2"Makro-Planar T* 2/100 ZF.2"Apo Sonnar T* 2/135 ZF.2"Apo Sonnar T* 2/135 ZF.2"Zeiss"Zeiss"Otus 1.4/55"Otus 1.4/55"Otus 1.4/85"Otus 1.4/85"Milvus 2/35"Milvus 2/35"Milvus 1.4/50"Milvus 1.4/50"Milvus 2/50M"Milvus 2/50M"Milvus 1.4/85"Milvus 1.4/85"Milvus 2/100M"Milvus 2/100M"Coastal Optical Systems"Coastal Optical Systems"60mm 1:4 UV-VIS-IR Macro Apo"60mm 1:4 UV-VIS-IR Macro Apo"Irix"Irix"15mm f/2.4 Firefly"15mm f/2.4 Firefly"11mm f/4.0 Blackstone/Firefly"11mm f/4.0 Blackstone/Firefly"Samyang"Samyang"8mm f/3.5 Fish-Eye CS"8mm f/3.5 Fish-Eye CS"10mm f/2.8 ED AS NCS CS"10mm f/2.8 ED AS NCS CS"12mm f/2.8 ED AS NCS Fish-eye"12mm f/2.8 ED AS NCS Fish-eye"14mm f/2.4 Premium"14mm f/2.4 Premium"AE 14mm f/2.8 ED AS IF UMC"AE 14mm f/2.8 ED AS IF UMC"16mm F2.0 ED AS UMC CS"16mm F2.0 ED AS UMC CS"24mm f/1.4 ED AS UMC"24mm f/1.4 ED AS UMC"35mm f/1.4 AS UMC"35mm f/1.4 AS UMC"AE 85mm f/1.4 AS IF UMC"AE 85mm f/1.4 AS IF UMC"Yongnuo"Yongnuo"YN50mm F1.8N"YN50mm F1.8N"Exakta"Exakta"AF 35-70mm 1:3.5-4.5 MC"AF 35-70mm 1:3.5-4.5 MC"Soligor"Soligor"AF Zoom 19-35mm 1:3.5-4.5 MC"AF Zoom 19-35mm 1:3.5-4.5 MC"AF C/D Zoom UMCS 70-210mm 1:4.5"AF C/D Zoom UMCS 70-210mm 1:4.5"AF C/D Auto Zoom+Macro 70-210mm 1:4-5.6 UMCS"AF C/D Auto Zoom+Macro 70-210mm 1:4-5.6 UMCS"AF Zoom 100-400mm 1:4.5-6.7 MC"AF Zoom 100-400mm 1:4.5-6.7 MC"Manual Lens"Manual Lens"No CPU"No CPU"Loreo"Loreo"40mm F11-22 3D Lens in a Cap 9005"40mm F11-22 3D Lens in a Cap 9005"JAA604AC"JAA604AC"Fisheye Nikkor 8mm f/2.8 AiS"Fisheye Nikkor 8mm f/2.8 AiS"Nikkor 28mm f/2.8 AiS"Nikkor 28mm f/2.8 AiS"Nikkor 50mm f/1.8 AI"Nikkor 50mm f/1.8 AI"Nikkor H 50mm f/2"Nikkor H 50mm f/2"JAA304AA"JAA304AA"Series E 100mm f/2.8"Series E 100mm f/2.8"JAA305AA"JAA305AA"Nikkor 105mm f/2.5 AiS"Nikkor 105mm f/2.5 AiS"JAA313AA"JAA313AA"Nikkor 200mm f/4 AiS"Nikkor 200mm f/4 AiS"8mm f/3.5 Fish-Eye"8mm f/3.5 Fish-Eye"C/D Macro MC 90mm f/2.5"C/D Macro MC 90mm f/2.5"0x4b0x4e24-70mm F2,8 DG OS HSM Art"24-70mm F2,8 DG OS HSM Art"A030"A030"SP 70-300mm F/4-5.6 Di VC USD"SP 70-300mm F/4-5.6 Di VC USD"dModelNIKON D"NIKON D""All 11 Points"20470x07ffAll 11 PointsnikonAfPointsInFocus"Single-frame"Single-framed70D70"D70"nikonShootingModeD70nikonShootingMode"Single area""Dynamic area""Closest subject""Group dynamic-AF""Single area (wide)""Dynamic area (wide)""used"focusmeteringfocuspointfocususedfocuspointsconst char *const[11]sizeof(nikonFocuspoints)sizeof(nikonFocuspoints[0])sizeof(nikonFocuspoints)
                                         / sizeof(nikonFocuspoints[0]) ';'N/A"N/A"Single areaDynamic areaClosest subjectGroup dynamic-AFSingle area (wide)Dynamic area (wide)1Ufpidzoom"Not used"Not usedfno1fno2mm "mm "lensTypeMF "MF "D "D "G "G "VR"VR"focus"Continuous autofocus""Single autofocus"AF-C  "AF-C  "Continuous autofocusAF-S  "AF-S  "Single autofocusAF-A  "AF-A  "const TagInfo[15]TagInfo[15]const TagInfo[9]TagInfo[9]const TagInfo[10]TagInfo[10]const TagInfo[5]TagInfo[5]const TagInfo[12]TagInfo[12]const TagInfo[92]TagInfo[92]Exif.MakerNote.ByteOrder"Exif.MakerNote.ByteOrder""MM"nikonFocusareafocusAreachar(&)[6]const char *const[6]const char *const(&)[6]char *(&)[6]..(*)(..))[6]EXV_COUNTOF(nikonFocusarea)Invalid value"Invalid value""guess"focusPointsizeof(nikonFocuspoints)/sizeof(nikonFocuspoints[0])guessfocusPointsUsed1focusPointsUsed2; ["; ["const TagInfo[17]TagInfo[17]lensnamelnumbermanufmiddblidtcinfoltypelfwaplapsfoclfocsstpslidnikonOffOn3"On (3)"On (3)nikonOffOn2const TagDetails[41]TagDetails[41]10860x043e+13"+13"12180x04c2-13"-13"62050x183d+7"+7"62060x183e+14"+14"63380x18c2"-14"63390x18c3"-7"113260x2c3e+15"+15"114580x2cc2-15"-15"164420x403a164430x403b164440x403c+4"+4"164450x403d+8"+8"164460x403e+16"+16"165780x40c2"-16"165790x40c3-8"-8"165800x40c4"-4"165810x40c5"-2"165820x40c6215660x543e+17"+17"216980x54c2-17"-17"266850x683d+9"+9"266860x683e+18"+18"268180x68c2-18"-18"268190x68c3-9"-9"318060x7c3e+19"+19"319380x7cc2-19"-19"369240x903c+5"+5"369250x903d+10"+10"369260x903e+20"+20"370580x90c2-20"-20"370590x90c3-10"-10"370600x90c4"-5"471650xb83d+11"+11"472990xb8c3-11"-11"574030xe03b+3"+3"574040xe03c+6"+6"574050xe03d+12"+12"575390xe0c3"-12"575400xe0c4"-6"575410xe0c5"-3"nikonAfFineTuneAdj20x003a0x003b0x003c0x003d0x003e0x00c20x00c30x00c40x00c50x00c60x103e42900x10c282530x203d82540x203e83860x20c283870x20c3123500x303e124820x30c2246370x603d247710x60c3328270x803b328280x803c328290x803d329630x80c3329640x80c4329650x80c5410210xa03d411550xa0c3492120xc03c492130xc03d493470xc0c3493480xc0c4nikonAfFineTuneAdj1"FL-GL1""FL-GL2""TN-A1""TN-A2""Amber"FL-GL1FL-GL2TN-A1TN-A2AmbernikonFlashColorFilter"Bounce Flash""Wide Flash Adapter"Bounce FlashWide Flash AdapternikonExternalFlashFlags"iTTL-BL""iTTL""Auto Aperture""GN (distance priority)""Repeating Flash"iTTL-BLiTTLAuto ApertureGN (distance priority)Repeating FlashnikonFlashControlModeconst TagDetails[38]TagDetails[38]0.1 m"0.1 m"0.2 m"0.2 m"0.3 m"0.3 m"0.4 m"0.4 m"0.5 m"0.5 m"0.6 m"0.6 m"0.7 m"0.7 m"0.8 m"0.8 m"0.9 m"0.9 m"1.0 m"1.0 m"1.1 m"1.1 m"1.3 m"1.3 m"1.4 m"1.4 m"1.6 m"1.6 m"1.8 m"1.8 m"2.0 m"2.0 m"2.2 m"2.2 m"2.5 m"2.5 m"2.8 m"2.8 m"3.2 m"3.2 m"3.6 m"3.6 m"4.0 m"4.0 m"4.5 m"4.5 m"5.0 m"5.0 m"5.6 m"5.6 m"6.3 m"6.3 m"7.1 m"7.1 m"8.0 m"8.0 m"9.0 m"9.0 m"10.0 m"10.0 m"11.0 m"11.0 m"13.0 m"13.0 m"14.0 m"14.0 m"16.0 m"16.0 m"18.0 m"18.0 m"20.0 m"20.0 m"nikonFlashGNDistance"1.01 (SB-800 or Metz 58 AF-1)"1.01 (SB-800 or Metz 58 AF-1)1.03 (SB-800)"1.03 (SB-800)"0x02012.01 (SB-800)"2.01 (SB-800)"0x02042.04 (SB-600)"2.04 (SB-600)"0x02052.05 (SB-600)"2.05 (SB-600)"0x03013.01 (SU-800 Remote Commander)"3.01 (SU-800 Remote Commander)"0x04014.01 (SB-400)"4.01 (SB-400)"10260x04024.02 (SB-400)"4.02 (SB-400)"4.04 (SB-400)"4.04 (SB-400)"0x05015.01 (SB-900)"5.01 (SB-900)"5.02 (SB-900)"5.02 (SB-900)"15370x06016.01 (SB-700)"6.01 (SB-700)"17930x07017.01 (SB-910)"7.01 (SB-910)"nikonFlashFirmware"Internal"nikonFlashSource"Multiple Exposure""Image Overlay"Multiple ExposureImage OverlaynikonMultiExposureMode"On (51-point)""On (11-point)""On (39-point)""On (73-point)""On (73-point, new)""On (105-point)"On (51-point)On (11-point)On (39-point)On (73-point)On (73-point, new)On (105-point)nikonPhaseDetectAF"Mid-left""Mid-right""Upper-left""Upper-right""Lower-left""Lower-right""Far Left""Far Right"const TagDetailsBitmask[11]TagDetailsBitmask[11]Mid-leftMid-rightUpper-leftUpper-rightLower-leftLower-rightFar LeftFar RightnikonAfPoint"Single Area""Dynamic Area""Dynamic Area, Closest Subject""Group Dynamic""Single Area (wide)""Dynamic Area (wide)"Single AreaDynamic AreaDynamic Area, Closest SubjectGroup DynamicSingle Area (wide)Dynamic Area (wide)nikonAfAreaMode"Hi 0.3""Hi 0.5""Hi 0.7""Hi 1.0""Hi 1.3""Hi 1.5""Hi 1.7""Hi 2.0""Hi 2.3""Hi 2.5""Hi 2.7""Hi 3.0""Hi 3.3""Hi 3.5""Hi 3.7""Hi 4.0""Hi 4.3""Hi 4.5""Hi 4.7""Hi 5.0""Lo 0.3""Lo 0.5""Lo 0.7""Lo 1.0"const TagDetails[25]TagDetails[25]0x000Hi 0.3Hi 0.5Hi 0.7Hi 1.0Hi 1.3Hi 1.50x107Hi 1.70x108Hi 2.00x109Hi 2.30x10aHi 2.50x10bHi 2.70x10cHi 3.00x10dHi 3.30x10eHi 3.50x10fHi 3.70x110Hi 4.00x111Hi 4.30x112Hi 4.50x113Hi 4.70x114Hi 5.0Lo 0.30x202Lo 0.50x203Lo 0.70x204Lo 1.0nikonIsoExpansionaftOnOff"Cyanotype""Blue-green""Purple-blue""Red-purple"CyanotypeBlue-greenPurple-blueRed-purplenikonToningEffectnikonFilterEffect"Default Settings""Quick Adjust""Full Control"Default SettingsQuick AdjustFull ControlnikonAdjustnikonOnOff"Y/M/D""M/D/Y""D/M/Y"Y/M/DM/D/YD/M/YnikonDateDisplayFormat"No""Yes"NoYesnikonYesNo"Speedlight"Speedlightnikon2WhiteBalancenikon2IsoSpeed"Bright+""Bright-""Contrast+""Contrast-"Bright+Bright-Contrast+Contrast-nikon2ImageAdjustmentnikon2ColorMode"VGA Basic""VGA Normal""VGA Fine""SXGA Basic""SXGA Normal""SXGA Fine"VGA BasicVGA NormalVGA FineSXGA BasicSXGA NormalSXGA Finenikon2Quality"Minimal"MinimalnikonHighISONoiseReduction"B & W""Trim""Small picture""D-Lighting""Red eye""Sky light""Warm tone""Color custom""Image overlay"B & WTrimSmall pictureD-LightingRed eyeSky lightWarm toneColor customImage overlaynikonRetouchHistory"Lossy (type 1)""Uncompressed""Lossless""Lossy (type 2)"Lossy (type 1)UncompressedLosslessLossy (type 2)nikonNefCompression"Auto release""Manual release"Auto releaseManual releasenikonAutoBracketRelease"Delay""PC control""Exposure bracketing""Unused LE-NR slowdown""IR control"DelayPC controlExposure bracketingUnused LE-NR slowdownIR control"PC Control""Exposure Bracketing""White-Balance Bracketing""IR Control""D-Lighting Bracketing"PC ControlExposure BracketingWhite-Balance BracketingIR ControlD-Lighting Bracketing"Fire, manual""Fire, external""Fire, commander mode""Fire, TTL mode"Fire, manualFire, externalFire, commander modeFire, TTL modenikonFlashModenikonColorSpace+1.0 EV"+1.0 EV"+0.7 EV"+0.7 EV"+0.5 EV"+0.5 EV"+0.3 EV"+0.3 EV"0.0 EV"0.0 EV"-0.3 EV"-0.3 EV"0xfd-0.5 EV"-0.5 EV"-0.7 EV"-0.7 EV"0xfa-1.0 EV"-1.0 EV"-1.3 EV"-1.3 EV"0xf7-1.5 EV"-1.5 EV"0xf6-1.7 EV"-1.7 EV"0xf4-2.0 EV"-2.0 EV"0xf2-2.3 EV"-2.3 EV"0xf1-2.5 EV"-2.5 EV"-2.7 EV"-2.7 EV"0xee-3.0 EV"-3.0 EV"nikonFlashCompconst char *const[]"Left-most""Right-most"Left-mostRight-mostnikonFocuspoints"Dynamic area, closest subject""Group dynamic"Dynamic area, closest subjectGroup dynamic"Extra High"Extra HighnikonActiveDLighningnikonOlnhnikonOffOn"Exit Pupil Position""Exit pupil position""AF Aperture""AF aperture""Lens ID Number""Lens ID number""Lens F-Stops""Lens F-stops""Min Focal Length""Min focal length""Max Focal Length""Max focal length""Max Aperture At Min Focal""Max aperture at min focal length""Max Aperture At Max Focal""Max aperture at max focal length""MCU Version""MCU version""Effective Max Aperture""Effective max aperture""Unknown Nikon Lens Data 3 Tag"ExitPupilPosition"ExitPupilPosition"Exit Pupil PositionExit pupil positionAFAperture"AFAperture"AF ApertureAF apertureLens ID NumberLens ID numberLens F-StopsLens F-stopsMin Focal LengthMin focal lengthMax Focal LengthMax focal lengthMax Aperture At Min FocalMax aperture at min focal lengthMax Aperture At Max FocalMax aperture at max focal lengthMCU VersionMCU versionEffectiveMaxAperture"EffectiveMaxAperture"Effective Max ApertureEffective max aperture(UnknownNikonLd3Tag)"(UnknownNikonLd3Tag)"Unknown Nikon Lens Data 3 Tag"Max aperture at min focal""Max aperture at max focal""Unknown Nikon Lens Data 2 Tag"Max aperture at min focalMax aperture at max focal(UnknownNikonLd2Tag)"(UnknownNikonLd2Tag)"Unknown Nikon Lens Data 2 Tag"Unknown Nikon Lens Data 1 Tag"(UnknownNikonLd1Tag)"(UnknownNikonLd1Tag)"Unknown Nikon Lens Data 1 Tag"WB GRBG Levels""WB GRBG levels""Unknown Nikon Color Balance 4 Tag"WB_GRBGLevels"WB_GRBGLevels"WB GRBG LevelsWB GRBG levels(UnknownNikonCb4Tag)"(UnknownNikonCb4Tag)"Unknown Nikon Color Balance 4 Tag"WB RGBG Levels""WB RGBG levels""Unknown Nikon Color Balance 3 Tag"WB_RGBGLevels"WB_RGBGLevels"WB RGBG LevelsWB RGBG levels(UnknownNikonCb3Tag)"(UnknownNikonCb3Tag)"Unknown Nikon Color Balance 3 Tag"WB RGGB Levels""WB RGGB levels""Unknown Nikon Color Balance 2b Tag"WB_RGGBLevels"WB_RGGBLevels"WB RGGB LevelsWB RGGB levels(UnknownNikonCb2bTag)"(UnknownNikonCb2bTag)"Unknown Nikon Color Balance 2b Tag"Unknown Nikon Color Balance 2a Tag"(UnknownNikonCb2aTag)"(UnknownNikonCb2aTag)"Unknown Nikon Color Balance 2a Tag"Unknown Nikon Color Balance 2 Tag"(UnknownNikonCb2Tag)"(UnknownNikonCb2Tag)"Unknown Nikon Color Balance 2 Tag"WB RBGG Levels""WB RBGG levels""Unknown Nikon Color Balance 1 Tag"WB_RBGGLevels"WB_RBGGLevels"WB RBGG LevelsWB RBGG levels(UnknownNikonCb1Tag)"(UnknownNikonCb1Tag)"Unknown Nikon Color Balance 1 Tag"Shutter Count 1""Shutter count 1""Deleted Image Count""Deleted image count""Vibration Reduction""Vibration reduction""Vibration Reduction 1""Vibration reduction 1""Shutter Count 2""Shutter count 2""Vibration Reduction 2""Vibration reduction 2""Shutter Count""Shutter count""Unknown Nikon Shot Info Tag"ShutterCount1"ShutterCount1"Shutter Count 1Shutter count 1DeletedImageCount"DeletedImageCount"Deleted Image CountDeleted image countVibrationReduction"VibrationReduction"Vibration ReductionVibration reductionVibrationReduction1"VibrationReduction1"Vibration Reduction 1Vibration reduction 1ShutterCount2"ShutterCount2"Shutter Count 2Shutter count 2VibrationReduction2"VibrationReduction2"Vibration Reduction 2Vibration reduction 2ShutterCount"ShutterCount"Shutter CountShutter count(UnknownNikonSi5Tag)"(UnknownNikonSi5Tag)"Unknown Nikon Shot Info Tag"AF Fine Tune Adj""AF fine tune adj""Unknown Nikon Shot Info D300 (b) Tag"AFFineTuneAdj"AFFineTuneAdj"AF Fine Tune AdjAF fine tune adj(UnknownNikonSi4Tag)"(UnknownNikonSi4Tag)"Unknown Nikon Shot Info D300 (b) Tag"Unknown Nikon Shot Info D300 (a) Tag"(UnknownNikonSi3Tag)"(UnknownNikonSi3Tag)"Unknown Nikon Shot Info D300 (a) Tag"Flash Level""Flash level""Unknown Nikon Shot Info D40 Tag"FlashLevel"FlashLevel"Flash LevelFlash level(UnknownNikonSi2Tag)"(UnknownNikonSi2Tag)"Unknown Nikon Shot Info D40 Tag"Unknown Nikon Shot Info D80 Tag"(UnknownNikonSi1Tag)"(UnknownNikonSi1Tag)"Unknown Nikon Shot Info D80 Tag"Flash Source""Flash source""External Flash Firmware""External flash firmware""External Flash Flags""External flash flags""Flash Focal Length""Flash focal length""Repeating Flash Rate""Repeating flash rate""Repeating Flash Count""Repeating flash count""Flash GN Distance""Flash GN distance""Flash Color Filter""Flash color filter""Unknown Nikon Multi Exposure Tag"FlashSource"FlashSource"Flash SourceFlash sourceExternalFlashFirmware"ExternalFlashFirmware"External Flash FirmwareExternal flash firmwareExternalFlashFlags"ExternalFlashFlags"External Flash FlagsExternal flash flagsFlashFocalLength"FlashFocalLength"Flash Focal LengthFlash focal lengthRepeatingFlashRate"RepeatingFlashRate"Repeating Flash RateRepeating flash rateRepeatingFlashCount"RepeatingFlashCount"Repeating Flash CountRepeating flash countFlashGNDistance"FlashGNDistance"Flash GN DistanceFlash GN distanceFlashColorFilter"FlashColorFilter"Flash Color FilterFlash color filter(UnknownNikonMeTag)"(UnknownNikonMeTag)"Unknown Nikon Multi Exposure Tag"0x0005""Flash Group A Control Mode""Flash group a control mode""Flash Group B Control Mode""Flash group b control mode"FlashGroupAControlMode"FlashGroupAControlMode"Flash Group A Control ModeFlash group a control modeFlashGroupBControlMode"FlashGroupBControlMode"Flash Group B Control ModeFlash group b control mode"Multi Exposure Mode""Multi exposure mode""Multi Exposure Shots""Multi exposure shots""Multi Exposure Auto Gain""Multi exposure auto gain"MultiExposureMode"MultiExposureMode"Multi Exposure ModeMulti exposure modeMultiExposureShots"MultiExposureShots"Multi Exposure ShotsMulti exposure shotsMultiExposureAutoGain"MultiExposureAutoGain"Multi Exposure Auto GainMulti exposure auto gain"Directory Number""Directory number""Unknown Nikon File Info Tag"DirectoryNumber"DirectoryNumber"Directory NumberDirectory number(UnknownNikonFiTag)"(UnknownNikonFiTag)"Unknown Nikon File Info Tag"AF Fine Tune""AF fine tune""AF Fine Tune Index""AF fine tune index""AF Fine Tune Adjustment""AF fine tune adjustment""Unknown Nikon AF Fine Tune Tag"AFFineTune"AFFineTune"AF Fine TuneAF fine tuneAFFineTuneIndex"AFFineTuneIndex"AF Fine Tune IndexAF fine tune indexAF Fine Tune AdjustmentAF fine tune adjustment(UnknownNikonAFTTag)"(UnknownNikonAFTTag)"Unknown Nikon AF Fine Tune Tag"Contrast Detect AF""Contrast detect AF""AF area mode""Phase Detect AF""Phase detect AF""Primary AF Point""Primary AF point""AF Image Width""AF image width""AF Image Height""AF image height""AF Area X Position""AF area x position""AF Area Y Position""AF area y position""AF Area Width""AF area width""AF Area Height""AF area height""Contrast Detect AF In Focus""Contrast detect AF in focus""Unknown Nikon Auto Focus 2 Tag"ContrastDetectAF"ContrastDetectAF"Contrast Detect AFContrast detect AFAF area modePhaseDetectAF"PhaseDetectAF"Phase Detect AFPhase detect AFPrimaryAFPoint"PrimaryAFPoint"Primary AF PointPrimary AF pointAFImageWidth"AFImageWidth"AF Image WidthAF image widthAFImageHeight"AFImageHeight"AF Image HeightAF image heightAFAreaXPosition"AFAreaXPosition"AF Area X PositionAF area x positionAFAreaYPosition"AFAreaYPosition"AF Area Y PositionAF area y positionAFAreaWidth"AFAreaWidth"AF Area WidthAF area widthAFAreaHeight"AFAreaHeight"AF Area HeightAF area heightContrastDetectAFInFocus"ContrastDetectAFInFocus"Contrast Detect AF In FocusContrast detect AF in focus(UnknownNikonAf2Tag)"(UnknownNikonAf2Tag)"Unknown Nikon Auto Focus 2 Tag"AF Points In Focus""AF points in focus""Unknown Nikon Auto Focus Tag"AFPointsInFocus"AFPointsInFocus"AF Points In FocusAF points in focus(UnknownNikonAfTag)"(UnknownNikonAfTag)"Unknown Nikon Auto Focus Tag"ISO Expansion""ISO expansion""ISO 2""ISO Expansion 2""ISO expansion 2""Unknown Nikon Iso Info Tag"ISOExpansion"ISOExpansion"ISO ExpansionISO expansionISO2"ISO2"ISO 2ISOExpansion2"ISOExpansion2"ISO Expansion 2ISO expansion 2(UnknownNikonIiTag)"(UnknownNikonIiTag)"Unknown Nikon Iso Info Tag"Timezone""Daylight savings""Date Display Format""Date display format""Unknown Nikon World Time Tag"TimezoneDaylight savingsDateDisplayFormat"DateDisplayFormat"Date Display FormatDate display format(UnknownNikonWtTag)"(UnknownNikonWtTag)"Unknown Nikon World Time Tag"Name""Base""Adjust""Quick adjust""Hue Adjustment""Hue adjustment""Filter effect""Toning effect""Toning Saturation""Toning saturation""Unknown Nikon Picture Control Tag"NameBaseQuickAdjust"QuickAdjust"Quick adjustHueAdjustment"HueAdjustment"Hue AdjustmentHue adjustmentFilter effectToning effectToningSaturation"ToningSaturation"Toning SaturationToning saturation(UnknownNikonPcTag)"(UnknownNikonPcTag)"Unknown Nikon Picture Control Tag"Unknown Nikon Vibration Reduction Tag"(UnknownNikonVrTag)"(UnknownNikonVrTag)"Unknown Nikon Vibration Reduction Tag"Nikon Makernote version""Sharpening""Image sharpening setting""Flash Setting""Flash setting""Flash Device""Flash device""White balance bias""WB RB Levels""WB RB levels""Program Shift""Program shift""Exposure Difference""Exposure difference""ISO Selection""ISO selection""Data Dump""Data dump""Pointer to a preview image""Offset to an IFD containing a preview image""Flash Comp""Flash compensation setting""Image Boundary""Image boundary""Flash exposure comp""Flash Bracket Comp""Flash bracket compensation applied""Exposure Bracket Comp""AE bracket compensation applied""Image Processing""Image processing""Crop High Speed""Crop high speed""Exposure Tuning""Exposure tuning""VR Info""VR info""Image Authentication""Image authentication""ActiveD-Lighting""ActiveD-lighting""Picture Control"" Picture control""World Time""World time""ISO Info""ISO info""Vignette Control""Vignette control""Image Adjustment""Image adjustment setting""Tone Compensation""Tone compensation""Auxiliary Lens""Auxiliary lens (adapter)""Manual focus distance""Digital zoom setting""Mode of flash used""Shooting Mode""Shooting mode""Auto Bracket Release""Auto bracket release""Lens FStops""Contrast Curve""Contrast curve""Color Hue""Color hue""Light Source""Light source""Shot info""NEF Compression""NEF compression""Linearization Table""Linearization table""Color Balance""Color balance""Lens Data""Lens data settings""Raw Image Center""Raw image center""Sensor Pixel Size""Sensor pixel size""Scene Assist""Scene assist""Retouch History""Retouch history""Serial NO""Camera serial number, usually starts with \"NO= \"""Image Data Size""Image data size""Image Count""Image count""Number of shots taken by camera""Flash info""Image Optimization""Image optimization""Program Variation""Program variation""AF Response""AF response""Multi exposure""High ISO Noise Reduction""AF info 2""File info""AF tune""Barometer Info""Capture Data""Capture data""Capture Version""Capture version""Capture Offsets""Capture offsets""Scan IFD""ICC profile""Capture output""Unknown Nikon3MakerNote tag"Nikon Makernote versionSharpeningImage sharpening settingFlashSetting"FlashSetting"Flash SettingFlash settingFlashDevice"FlashDevice"Flash DeviceFlash deviceWhite balance biasWB_RBLevels"WB_RBLevels"WB RB LevelsWB RB levelsProgramShift"ProgramShift"Program ShiftProgram shiftExposureDiff"ExposureDiff"Exposure DifferenceExposure differenceISOSelection"ISOSelection"ISO SelectionISO selectionDataDump"DataDump"Data DumpData dumpPointer to a preview imageOffset to an IFD containing a preview imageFlashComp"FlashComp"Flash CompFlash compensation settingISOSettings"ISOSettings"ImageBoundary"ImageBoundary"Image BoundaryImage boundaryFlash Exposure Comp"Flash Exposure Comp"Flash exposure compFlashBracketComp"FlashBracketComp"Flash Bracket CompFlash bracket compensation appliedExposureBracketComp"ExposureBracketComp"Exposure Bracket CompAE bracket compensation appliedImageProcessing"ImageProcessing"Image ProcessingImage processingCropHiSpeed"CropHiSpeed"Crop High SpeedCrop high speedExposureTuning"ExposureTuning"Exposure TuningExposure tuningVRInfo"VRInfo"VR InfoVR infoImageAuthentication"ImageAuthentication"Image AuthenticationImage authenticationActiveDLighting"ActiveDLighting"ActiveD-LightingActiveD-lightingPictureControl"PictureControl"Picture Control Picture controlWorldTime"WorldTime"World TimeWorld timeISOInfo"ISOInfo"ISO InfoISO infoVignetteControl"VignetteControl"Vignette ControlVignette controlImageAdjustment"ImageAdjustment"Image AdjustmentImage adjustment settingToneComp"ToneComp"Tone CompensationTone compensation0x0082AuxiliaryLens"AuxiliaryLens"Auxiliary LensAuxiliary lens (adapter)0x00840x0085Manual focus distance0x0086Digital zoom setting0x0087Mode of flash usedShootingMode"ShootingMode"Shooting ModeShooting mode0x008aAutoBracketRelease"AutoBracketRelease"Auto Bracket ReleaseAuto bracket release0x008bLens FStops0x008cContrastCurve"ContrastCurve"Contrast CurveContrast curve0x008dColorHue"ColorHue"Color HueColor hue0x008f0x0090LightSource"LightSource"Light SourceLight sourceShot info0x00920x0093NEFCompression"NEFCompression"NEF CompressionNEF compression0x0094LinearizationTable"LinearizationTable"Linearization TableLinearization tableColorBalance"ColorBalance"Color BalanceColor balanceLensData"LensData"Lens DataLens data settingsRawImageCenter"RawImageCenter"Raw Image CenterRaw image center0x009aSensorPixelSize"SensorPixelSize"Sensor Pixel SizeSensor pixel size0x009b"0x009b"0x009cSceneAssist"SceneAssist"Scene AssistScene assist0x009eRetouchHistory"RetouchHistory"Retouch HistoryRetouch history0x009f"0x009f"SerialNO"SerialNO"Serial NOCamera serial number, usually starts with "NO= "0x00a2ImageDataSize"ImageDataSize"Image Data SizeImage data size0x00a3"0x00a3"0x00a5ImageCount"ImageCount"Image CountImage count0x00a6Number of shots taken by cameraFlashInfo"FlashInfo"Flash Info"Flash Info"Flash infoImageOptimization"ImageOptimization"Image OptimizationImage optimization0x00abVariProgram"VariProgram"Program VariationProgram variation0x00ac0x00adAFResponse"AFResponse"AF ResponseAF response0x00b0MultiExposure"MultiExposure"Multi Exposure"Multi Exposure"Multi exposure0x00b1HighISONoiseReduction"HighISONoiseReduction"High ISO Noise Reduction0x00b3AFInfo2"AFInfo2"AF Info 2"AF Info 2"AF info 20x00b8FileInfo"FileInfo"File Info"File Info"File info0x00b9AFTune"AFTune"AF Tune"AF Tune"AF tuneBarometerInfo"BarometerInfo"Barometer Info35850x0e01CaptureData"CaptureData"Capture DataCapture data35930x0e09CaptureVersion"CaptureVersion"Capture VersionCapture version35980x0e0eCaptureOffsets"CaptureOffsets"Capture OffsetsCapture offsets0x0e10ScanIFD"ScanIFD"Scan IFD36130x0e1dICCProfile"ICCProfile"ICC Profile"ICC Profile"ICC profile36140x0e1eCaptureOutput"CaptureOutput"Capture Output"Capture Output"Capture output(UnknownNikon3MnTag)"(UnknownNikon3MnTag)"Unknown Nikon3MakerNote tag"Unknown Nikon2MakerNote tag""0x0002""0x0f00"(UnknownNikon2MnTag)"(UnknownNikon2MnTag)"Unknown Nikon2MakerNote tag"AF Focus Position""AF focus position information""Unknown Nikon1MakerNote tag"AFFocusPos"AFFocusPos"AF Focus PositionAF focus position information(UnknownNikon1MnTag)"(UnknownNikon1MnTag)"Unknown Nikon1MakerNote tagFMLDATE"2018-03-03"FMLVERSION"4.4.550.02"FMOUNTLH// EXV_HAVE_LENSDATA// Lens not found in database// Lens found in database// stps varies with focal length for some Sigma zoom lenses./* the 'FMntLens' name is added to the annonymous struct for
         * fmountlens[]
         *
         * remember to name the struct when importing/updating the lens info
         * from:
         *
         * www.rottmerhusen.com/objektives/lensid/files/c-header/fmountlens4.h
         *//* if no meta obj is provided, try to use the value param that *may*
     * be the pre-parsed lensid
     */// 8< - - - 8< do not remove this line >8 - - - >8//------------------------------------------------------------------------------//  https://github.com/Exiv2/exiv2/issues/598 , https://github.com/Exiv2/exiv2/pull/891// https://github.com/Exiv2/exiv2/issues/743//"00 54 44 44 0C 0C 00" "00" "00" "00" "00" "Nikon"   "JAA115AD" "Nikkor 35mm f/1.4 AiS" double ID with Zeiss// Lenses, that were upgraded with custom CPU//                    " "00" "00" "00" "00" "Zeiss" "" "Milvus 2.8/21"//M                                         "Cosina" "" "AF Zoom 100-400mm F5.6-6.7 MC";//M                                         "Cosina" "" "AF Zoom 70-210mm F2.8-4.0";//M                                         "Cosina" "" "AF Zoom 28-300mm F4.0-6.3";//M                                         "Cosina" "" "AF Zoom 28-210mm F4.2-6.5 Aspherical IF";//M                                         "Cosina" "" "AF Zoom 28-210mm F3.5-5.6";// Lenses from various other brands//M                                         "Tokina" ""          "AF 140 EMZ (AF 100-400mm f/4.5-6.3)"//M                                         "Tokina" ""          "AF 130 EMZ II (AF 100-300mm f/5.6-6.7)"//M                                         "Tokina" ""          "AT-X 340 AF-II (AF 100-300mm f/4)"//M                                         "Tokina" ""          "AT-X 840 AF (AF 80-400mm f/4.5-5.6)"//M                                         "Tokina" ""          "AF 730 II (AF 75-300mm f/4.5-5.6)"//M                                         "Tokina" ""          "AF 210 II SD (AF 70-210mm f/4.0-5.6)"//M                                         "Tokina" ""          "AF 210 (AF 70-210mm f/4.0-5.6)"//M                                         "Tokina" ""          "AF 745 (AF 70-210mm f/4.5)"//M                                         "Tokina" ""          "AF 370 II (AF 35-70mm f/3.5-4.6)"//M                                         "Tokina" ""          "AF 370 (AF 35-70mm f/3.5-4.6)"//M                                         "Tokina" ""          "AF 282 EMZ II (AF 28-210mm f/4.2-6.5)"//M                                         "Tokina" ""          "AF 282 (AF 28-200mm 3.5-5.6)"//M                                         "Tokina" ""          "AF 205 (AF 28-105mm f/3.5-4.5)"//M                                         "Tokina" ""          "AF 280 II EMZ (AF 28-80mm f/3.5-5.6)"//M                                         "Tokina" ""          "AT-X 240 AF (AF 24-40mm f/2.8)"//M                                         "Tokina" ""          "AF 235 (AF 20-35mm f/3.5-4.5)"// Tokina Lenses by focal length, first fixed then zoom lenses//M                                         "Tamron" "186D"   "AF 100-300mm F/5-6.3";//M                                         "Tamron" "62D"    "AF 90-300mm F/4.5-5.6";//M                                         "Tamron" "278D"   "AF 80-210mm F/4.5-5.6";//M                                         "Tamron" "872D"   "AF 75-300mm F/4-5.6 LD";//M                                         "Tamron" "472D"   "AF 70-300mm F/4-5.6 LD";//M                                         "Tamron" "172D"   "AF 70-300mm F/4-5.6";//M                                         "Tamron" "258D"   "AF 70-210mm F/4-5.6";//M                                         "Tamron" "158D"   "AF 70-210mm F/4-5.6";//M                                         "Tamron" ""       "AF 70-210mm F/3.5-4.5";//M                                         "Tamron" "67D"    "SP AF 70-210mm f/2.8 LD";//M                                         "Tamron" ""       "AF 35-135mm F/3.5-4.5";//M                                         "Tamron" "65D"    "SP AF 35-105mm F/2.8 Aspherical";//M                                         "Tamron" "63D"    "AF 35-90mm F/4-5.6";//M                                         "Tamron" "285D"   "AF 28-300mm F/3.8-6.3 LD Aspherical IF Silver";//M                                         "Tamron" "471D"   "AF 28-200mm F/3.8-5.6 Aspherical IF Super2 Silver";//M                                         "Tamron" "179D"   "AF 28-105mm F4.0-5.6 IF";//M                                         "Tamron" "276D"   "SP AF 28-105mm F/2.8 LD Aspherical IF";//M                                         "Tamron" "259D"   "AF 28-70mm F/3.5-4.5";//M                                         "Tamron" "159D"   "AF 28-70mm F/3.5-4.5";//M                                         "Tamron" "73D"    "AF 24-70mm F/3.3-5.6 Aspherical";//M                                         "Tamron" "266D"   "SP AF 20-40mm F/2.7-3.5 Aspherical-IF";// Tamron lenses by focal length, first fixed then zoom lenses//M                                         "Sigma" "686550" "50-200mm F4-5.6 DC OS HSM";//M2    B8 B8 49 49 02" "00" "00" "00" "00" "Sigma" ""       "APO 1000mm F8.0";//M                                         "Sigma" "152550" "APO 800mm F5.6 EX DG HSM";//M                                         "Sigma" ""       "APO 300mm F2.8";//M                                         "Sigma" "410"    "18mm F3.5";// Sigma lenses by focal length, first fixed then zoom lenses//   "AF-S DX Nikkor 18-200mm f/3.5-5.6G ED VR II"//AA                D5//A9                D4//                  CB//AB                AD                                          -- no lens --//91                93//8E                90//{0x8B,0x40,0x2D,0x80,0x2C,0x3C,0xFD,0x0E,0x01,0x01,0x00, "Nikon", "JAA794DA", "AF-S DX VR Zoom-Nikkor 18-200mm f/3.5-5.6G IF-ED"}, // Fix bug #1026.//88//87//86//85//84//7E                83//7C                81//73//71//6C                72//62                69//5C//                                                  "JBA706AC" "IX-Nikkor 20-60 mm f/3.5-5.6N";//58//57//55//52//51//                                                  "JBA703AC" "IX-Nikkor 20-60 mm f/3.5-5.6";//40//39                38//29// ^- not yet verified// - D - lenses from here//19//16//0C// Nikkor lenses by their LensID//"data from TAG 0x98" "ltyp" " "TC" "MID" "maker" "PN" "lens name from manuf";// Please contact me for adding lenses or use in commercial software.// Free use in non-commercial, GPL or open source software only!// product number/order code not complete// 4A 48 24 24 24 0C 4D 02.2: Samyang 10mm f/2.8 ED AS NCS CS// 4A 48 24 24 24 0C 4D 02.1: Samyang AE 14mm f/2.8 ED AS IF UMC// 25 48 3C 5C 24 24 1B 02.2: Tokina AT-X 270 AF PRO II (AF 28-70mm f/2.6-2.8)// 25 48 3C 5C 24 24 1B 02.1: Tokina AT-X 287 AF PRO SV (AF 28-70mm f/2.8)// 2F 40 30 44 2C 34 29 02.2: Tokina AF 193 (AF 19-35mm f/3.5-4.5)// 2F 40 30 44 2C 34 29 02.1: Tokina AF 235 II (AF 20-35mm f/3.5-4.5)// 32 53 64 64 24 24 35 02.2: Tamron SP AF 90mm F/2.8 Di Macro 1:1 (272E)// 32 53 64 64 24 24 35 02.1: Tamron SP AF 90mm F/2.8 Macro 1:1 (172E)// 8B 40 2D 80 2C 3C FD 0E.2: Nikon AF-S DX VR Zoom-Nikkor 18-200mm f/3.5-5.6G IF-ED II// 8B 40 2D 80 2C 3C FD 0E.1: Nikon AF-S DX VR Zoom-Nikkor 18-200mm f/3.5-5.6G IF-ED// 7A 3C 1F 37 30 30 7E 06.2: Tokina AT-X 124 AF PRO DX II (AF 12-24mm f/4)// 7A 3C 1F 37 30 30 7E 06.1: Nikon AF-S DX Zoom-Nikkor 12-24mm f/4G IF-ED// 32 54 6A 6A 24 24 35 02.2: Sigma Macro 105mm F2.8 EX DG// 32 54 6A 6A 24 24 35 02.1: Nikon AF Micro-Nikkor 105mm f/2.8D// 2F 48 30 44 24 24 29 02.2: Tokina AT-X 235 AF PRO (AF 20-35mm f/2.8)// 2F 48 30 44 24 24 29 02.1: Nikon AF Zoom-Nikkor 20-35mm f/2.8D IF// Eight misidentified lenses due to double LensIDs:// http://www.rottmerhusen.com/objektives/lensid/thirdparty.html// For contributor info and more visit my online list:// http://www.rottmerhusen.com (lens_id@rottmerhusen.com)// Created by Robert Rottmerhusen 2005 - 2018// List of AF F-Mount lenses - Version 4.4.550.02                    2018-03-03// Decoded by Robert Rottmerhusen <email@rottmerhusen.com>// (Roger Larsson: my interpretation, verify)// selected point was not the actually used one// What fokuspoints(!) did the camera use? add if differs// TODO: os << position[fokuspoint][combination]// What focuspoint did the user select?//  No user selected point for Closest subject// D200/* TODO: combination = wide; */// D70, D200// TODO: handle the meaningful case (interacts with other fields)// that focus was not found (try this in AF-C mode)// But when actually in "Single area, Center" this can mean// this indicates that the field has no meaning.// Special case, in Manual focus and with Nikon compacts// TODO: enum {standard, wide} combination = standard;// Mapping by Roger Larsson// Size is 4 even for those who map this way...// Nikon3 Lens Data 3 Tag Info// Nikon3 Lens Data 2 Tag Info// Nikon3 Lens Data 1 Tag Info// Nikon3 Color Balance 4 Tag Info// Nikon3 Color Balance 3 Tag Info// Nikon3 Color Balance 2b Tag Info// Nikon3 Color Balance 2a Tag Info// Nikon3 Color Balance 2 Tag Info// Nikon3 Color Balance 1 Tag Info// Nikon3 Shot Info Tag Info//! VibrationReduction2//! VibrationReduction// Nikon3 Shot Info D300 (b) Tag Info//! AfFineTuneAdj D300 (b)// Nikon3 Shot Info D300 (a) Tag Info//! AfFineTuneAdj D300 (a)// Nikon3 Shot Info D40 Tag Info// Nikon3 Shot Info D80 Tag Info// Nikon3 Flash Info 3 Tag Info// Nikon3 Flash Info 2 Tag Info// Nikon3 Flash Info 1 Tag Info//! FlashColorFilter//! ExternalFlashFlags//! FlashControlMode//! FlashGNDistance//! FlashFirmware//! FlashSource// Nikon3 Multi Exposure Tag Info//! MultiExposureMode// Nikon3 File Info Tag Info// Nikon3 Auto Focus Tag Info Version 1.01 https://github.com/Exiv2/exiv2/pull/900// Nikon3 Auto Focus Tag Info//! PhaseDetectAF//! AfPointsInFocus//! AfPoint//! AfAreaMode// Nikon3 ISO Info Tag Info//! ISOExpansion, tag index 4 and 10// Nikon3 World Time Tag Info// Nikon3 AF Fine Tune//! OnOff// Nikon3 Picture Control Tag Info//! ToningEffect//! FilterEffect//! Adjust// Nikon3 Vibration Reduction Tag Info//! DateDisplayFormat, tag index 3//! YesNo, used for DaylightSavings, tag index 2// TODO: Add Capture Offsets decoding implementation.// TODO: Add Capture Data decoding implementation.// use 0x0012 print fct// use 0x0002 print fct// Nikon3 MakerNote Tag Info// Nikon2 MakerNote Tag Info//! WhiteBalance, tag 0x0007//! ISOSpeed, tag 0x0006//! ImageAdjustment, tag 0x0005//! ColorMode, tag 0x0004// Could use array nikonFokuspoints// Nikon1 MakerNote Tag Info//! HighISONoiseReduction, tag 0x00b1//! RetouchHistory, tag 0x009e//! NEFCompression, tag 0x0093//! AutoBracketRelease, tag 0x008a//! ShootingMode D70, tag 0x0089//! ShootingMode, tag 0x0089//! FlashMode, tag 0x0087//! ColorSpace, tag 0x001e//! FlashComp, tag 0x0012//! Focus points for Nikon cameras, used for Nikon 1 and Nikon 3 makernotes.// "wide" or not// module. Note that relative size and position will vary depending on if// Roger Larsson: My guess is that focuspoints will follow autofocus sensor//! Focus area for Nikon cameras.//! Off, Low, Normal, High, multiple tags//for log, pow, abs/*
  File:      nikonmn.cpp
  Author(s): Andreas Huggel (ahu) <ahuggel@gmx.net>
             Gilles Caulier (gc) <caulier dot gilles at gmail dot com>
             Jens Mueller (jm) <tschensinger at web dot de>
  History:   17-May-04, ahu: created
             25-May-04, ahu: combined all Nikon formats in one component
 *//*
 * Lens database for the conversion of Nikon lens data to readable lens names
 * Copyright (C) 2005-2014 Robert Rottmerhusen <lens_id@rottmerhusen.com>
 *
 * Copyright (C) 2004-2018 Exiv2 authors
 * This program is part of the Exiv2 distribution.
 *
 * This program is free software; you can redistribute it and/or
 * modify it under the terms of the GNU General Public License
 * as published by the Free Software Foundation; either version 2
 * of the License, or (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin Street, 5th Floor, Boston, MA 02110-1301 USA.
 */__promote<double, double, void>__promote<double, double, void> &const __promote<double, double, void>const __promote<double, double, void> &const TagDetails(&)[25]TagDetails(&)[25]const TagDetails(&)[38]TagDetails(&)[38]const TagDetails(&)[41]TagDetails(&)[41]const TagDetailsBitmask(&)[11]TagDetailsBitmask(&)[11]const TagDetailsBitmask(*)[11]TagDetailsBitmask(*)[11]__promote_imp<double, double, void, true>__promote_imp<double, double, void, true> &const __promote_imp<double, double, void, true>const __promote_imp<double, double, void, true> &__promote_imp<double, void, void, true>__promote_imp<double, void, void, true> &const __promote_imp<double, void, void, true>const __promote_imp<double, void, void, true> &__numeric_type<double>__numeric_type<double> &const __numeric_type<double>const __numeric_type<double> &double &&/Users/owura/Repos/codeql_eval/proj_repos/Exiv2-exiv2-pull-962-commits-e925bc5addd881543fa503470c8a859e112cca62/exiv2/src/olympusmn_int.hppOlympusMakerNote &const OlympusMakerNoteconst OlympusMakerNote &printGenericOlympusMakerNoteOLYMPUSMN_INT_HPP_tagInfoRi_tagInfoFe_tagInfoIp_tagInfoRd2_tagInfoRd_tagInfoEq_print0x0308print0x0305print0x1209print0x0529print0x0527print0x050fprintCs0x0301printEq0x0301print0x0209print0x0201print0x1015print0x0204print0x0200tagListRitagListFetagListIptagListRd2tagListRdtagListEq// #ifndef OLYMPUSMN_INT_HPP_// class OlympusMakerNote//! Print Olympus generic//! Print Olympus focus info AF Point//! Print Olympus focus distance//! Print Olympus focus info ManualFlash//! Print Olympus ArtFilter//! Print Olympus camera settings Noise Filter//! Print Olympus camera settings Gradation//! Print Olympus camera settings Focus Mode//! Print Olympus equipment Extender//! Print Olympus CamerID//! Print Olympus equipment Lens type//! Print White Balance Mode//! Print Digital Zoom Factor//! Print 'Special Mode'//! @name Print functions for Olympus %MakerNote tags//! Return read-only list of built-in Olympus Raw Info tags//! Return read-only list of built-in Olympus FE tags//! Return read-only list of built-in Olympus Focus Info tags//! Return read-only list of built-in Olympus Image Processing tags//! Return read-only list of built-in Olympus Raw Development 2 tags//! Return read-only list of built-in Olympus Raw Development tags//! Return read-only list of built-in Olympus Equipment tags//! Return read-only list of built-in Olympus Camera Settings tags//! Return read-only list of built-in Olympus tags//! MakerNote for Olympus cameras/*!
  @file    olympusmn_int.hpp
  @brief   Olympus makernote tags.<br>References:<br>
           [1] <a href="http://park2.wakwak.com/%7Etsuruzoh/Computer/Digicams/exif-e.html#APP1">Exif file format, Appendix 1: MakerNote of Olympus Digicams</a> by TsuruZoh Tachibanaya<br>
           [2] <a href="http://www.sno.phy.queensu.ca/~phil/exiftool/">ExifTool</a> by Phil Harvey<br>
           [3] <a href="http://www.ozhiker.com/electronics/pjmt/jpeg_info/olympus_mn.html">Olympus Makernote Format Specification</a> by Evan Hunter<br>
           [4] email communication with <a href="mailto:wstokes@gmail.com">Will Stokes</a>
  @author  Andreas Huggel (ahu)
           <a href="mailto:ahuggel@gmx.net">ahuggel@gmx.net</a>
  @author  Will Stokes (wuz)
           <a href="mailto:wstokes@gmail.com">wstokes@gmail.com</a>
  @author  Gilles Caulier (gc)
           <a href="mailto:caulier dot gilles at gmail dot com">caulier dot gilles at gmail dot com</a>
  @author  Greg Mansfield
           <a href="mailto:G.Mansfield at computer dot org">G.Mansfield at computer dot org</a>
  @date    10-Mar-05, wuz: created
 *//Users/owura/Repos/codeql_eval/proj_repos/Exiv2-exiv2-pull-962-commits-e925bc5addd881543fa503470c8a859e112cca62/exiv2/src/olympusmn_int.cpp"olympusmn_int.hpp""Left (or n/a)""Center (horizontal)""Center (vertical)"afPoints"Top-left (horizontal)""Top-center (horizontal)""Top-right (horizontal)""Left (horizontal)""Mid-left (horizontal)""Mid-right (horizontal)""Right (horizontal)""Bottom-left (horizontal)""Bottom-center (horizontal)""Bottom-right (horizontal)""Top-left (vertical)""Top-center (vertical)""Top-right (vertical)""Left (vertical)""Mid-left (vertical)""Mid-right (vertical)""Right (vertical)""Bottom-left (vertical)""Bottom-center (vertical)""Bottom-right (vertical)"afPointsE3E3_E30modelE-3 "E-3 "E-30 "E-30 ""Single Target""All Target""Dynamic Single Target"struct <unnamed>[6]struct <unnamed>[24]Single TargetAll TargetDynamic Single TargetTop-left (horizontal)Top-center (horizontal)Top-right (horizontal)Left (horizontal)Mid-left (horizontal)Center (horizontal)Mid-right (horizontal)Right (horizontal)Bottom-left (horizontal)Bottom-center (horizontal)0x0bBottom-right (horizontal)Top-left (vertical)Top-center (vertical)Top-right (vertical)Left (vertical)Mid-left (vertical)Center (vertical)Mid-right (vertical)Right (vertical)Bottom-left (vertical)Bottom-center (vertical)Bottom-right (vertical)Left (or n/a)"Pale & Light Color""Pin Hole""Grainy Film""Diorama""Cross Process""Fish Eye""Drawing""Gentle Sepia""Pale & Light Color II""Pop Art II""Pin Hole II""Pin Hole III""Grainy Film II""Dramatic Tone""Punk""Soft Focus 2""Sparkle""Watercolor""Key Line""Key Line II""Miniature""Reflection""Fragmented""Cross Process II""Dramatic Tone II""Watercolor I""Watercolor II""Diorama II""Vintage""Vintage II""Vintage III""Partial Color""Partial Color II""Partial Color III"artFiltersv0struct <unnamed>[40]uint16_t[2]unsigned short[2]Pale & Light ColorPin HoleGrainy FilmDioramaCross ProcessFish EyeDrawingGentle SepiaPale & Light Color IIPop Art IIPin Hole IIPin Hole IIIGrainy Film IIDramatic TonePunkSoft Focus 2SparkleWatercolorKey LineKey Line IIMiniatureReflectionFragmentedCross Process IIDramatic Tone IIWatercolor IWatercolor IIDiorama IIVintageVintage IIVintage IIIPartial ColorPartial Color IIPartial Color III"User-Selected""Auto-Override"User-SelectedAuto-Override"Single AF""Sequential shooting AF""Multi AF""Face detect"focusModes0"S-AF""C-AF""Imager AF""AF sensor"focusModes1struct <unnamed>[7]S-AFC-AFFace detectImager AFAF sensorSingle AFSequential shooting AFMulti AFextenderModelsstruct <unnamed>[5]Olympus Zuiko Digital EC-14 1.4x Teleconverter"Olympus Zuiko Digital EC-14 1.4x Teleconverter"Olympus EX-25 Extension Tube"Olympus EX-25 Extension Tube"Olympus Zuiko Digital EC-20 2.0x Teleconverter"Olympus Zuiko Digital EC-20 2.0x Teleconverter"olympus"olympus"lensTypesstruct <unnamed>[113]byte[3]unsigned char[3]Olympus Zuiko Digital ED 50mm F2.0 Macro"Olympus Zuiko Digital ED 50mm F2.0 Macro"Olympus Zuiko Digital 40-150mm F3.5-4.5"Olympus Zuiko Digital 40-150mm F3.5-4.5"Olympus M.Zuiko Digital ED 14-42mm F3.5-5.6"Olympus M.Zuiko Digital ED 14-42mm F3.5-5.6"Olympus Zuiko Digital ED 150mm F2.0"Olympus Zuiko Digital ED 150mm F2.0"Olympus M.Zuiko Digital 17mm F2.8 Pancake"Olympus M.Zuiko Digital 17mm F2.8 Pancake"Olympus Zuiko Digital ED 300mm F2.8"Olympus Zuiko Digital ED 300mm F2.8"Olympus M.Zuiko Digital ED 14-150mm F4.0-5.6"Olympus M.Zuiko Digital ED 14-150mm F4.0-5.6"Olympus M.Zuiko Digital ED 9-18mm F4.0-5.6"Olympus M.Zuiko Digital ED 9-18mm F4.0-5.6"Olympus Zuiko Digital 14-54mm F2.8-3.5"Olympus Zuiko Digital 14-54mm F2.8-3.5"Olympus Zuiko Digital Pro ED 90-250mm F2.8"Olympus Zuiko Digital Pro ED 90-250mm F2.8"Olympus M.Zuiko Digital ED 14-42mm F3.5-5.6 L"Olympus M.Zuiko Digital ED 14-42mm F3.5-5.6 L"Olympus Zuiko Digital ED 50-200mm F2.8-3.5"Olympus Zuiko Digital ED 50-200mm F2.8-3.5"Olympus Zuiko Digital ED 8mm F3.5 Fisheye"Olympus Zuiko Digital ED 8mm F3.5 Fisheye"Olympus M.Zuiko Digital ED 40-150mm F4.0-5.6"Olympus M.Zuiko Digital ED 40-150mm F4.0-5.6"Olympus Zuiko Digital 11-22mm F2.8-3.5"Olympus Zuiko Digital 11-22mm F2.8-3.5"Olympus Zuiko Digital 18-180mm F3.5-6.3"Olympus Zuiko Digital 18-180mm F3.5-6.3"Olympus M.Zuiko Digital ED 12mm F2.0"Olympus M.Zuiko Digital ED 12mm F2.0"Olympus Zuiko Digital 70-300mm F4.0-5.6"Olympus Zuiko Digital 70-300mm F4.0-5.6"Olympus M.Zuiko Digital ED 75-300mm F4.8-6.7"Olympus M.Zuiko Digital ED 75-300mm F4.8-6.7"Olympus M.Zuiko Digital 14-42mm F3.5-5.6 II"Olympus M.Zuiko Digital 14-42mm F3.5-5.6 II"Kenko Tokina Reflex 300mm F6.3 MF Macro"Kenko Tokina Reflex 300mm F6.3 MF Macro"Olympus M.Zuiko Digital ED 12-50mm F3.5-6.3 EZ"Olympus M.Zuiko Digital ED 12-50mm F3.5-6.3 EZ"Olympus M.Zuiko Digital 45mm F1.8"Olympus M.Zuiko Digital 45mm F1.8"Olympus M.Zuiko Digital ED 60mm F2.8 Macro"Olympus M.Zuiko Digital ED 60mm F2.8 Macro"Olympus M.Zuiko Digital 14-42mm F3.5-5.6 II R"Olympus M.Zuiko Digital 14-42mm F3.5-5.6 II R"Olympus M.Zuiko Digital ED 40-150mm F4.0-5.6 R"Olympus M.Zuiko Digital ED 40-150mm F4.0-5.6 R"Olympus Zuiko Digital ED 7-14mm F4.0"Olympus Zuiko Digital ED 7-14mm F4.0"Olympus M.Zuiko Digital ED 75mm F1.8"Olympus M.Zuiko Digital ED 75mm F1.8"Olympus M.Zuiko Digital 17mm F1.8"Olympus M.Zuiko Digital 17mm F1.8"Olympus Zuiko Digital Pro ED 35-100mm F2.0"Olympus Zuiko Digital Pro ED 35-100mm F2.0"Olympus Zuiko Digital 14-45mm F3.5-5.6"Olympus Zuiko Digital 14-45mm F3.5-5.6"Olympus M.Zuiko Digital ED 75-300mm F4.8-6.7 II"Olympus M.Zuiko Digital ED 75-300mm F4.8-6.7 II"Olympus M.Zuiko Digital ED 12-40mm F2.8 Pro"Olympus M.Zuiko Digital ED 12-40mm F2.8 Pro"Olympus Zuiko Digital 35mm F3.5 Macro"Olympus Zuiko Digital 35mm F3.5 Macro"Olympus M.Zuiko Digital ED 40-150mm F2.8 Pro"Olympus M.Zuiko Digital ED 40-150mm F2.8 Pro"Olympus M.Zuiko Digital ED 14-42mm F3.5-5.6 EZ"Olympus M.Zuiko Digital ED 14-42mm F3.5-5.6 EZ"Olympus Zuiko Digital 17.5-45mm F3.5-5.6"Olympus Zuiko Digital 17.5-45mm F3.5-5.6"Olympus M.Zuiko Digital 25mm F1.8"Olympus M.Zuiko Digital 25mm F1.8"Olympus Zuiko Digital ED 14-42mm F3.5-5.6"Olympus Zuiko Digital ED 14-42mm F3.5-5.6"Olympus M.Zuiko Digital ED 7-14mm F2.8 Pro"Olympus M.Zuiko Digital ED 7-14mm F2.8 Pro"Olympus Zuiko Digital ED 40-150mm F4.0-5.6"Olympus Zuiko Digital ED 40-150mm F4.0-5.6"Olympus M.Zuiko Digital ED 300mm F4.0 IS Pro"Olympus M.Zuiko Digital ED 300mm F4.0 IS Pro"Olympus M.Zuiko Digital ED 8mm F1.8 Fisheye Pro"Olympus M.Zuiko Digital ED 8mm F1.8 Fisheye Pro"Olympus M.Zuiko Digital ED 12-100mm F4.0 IS Pro"Olympus M.Zuiko Digital ED 12-100mm F4.0 IS Pro"Olympus M.Zuiko Digital ED 30mm F3.5 Macro"Olympus M.Zuiko Digital ED 30mm F3.5 Macro"Olympus M.Zuiko Digital ED 25mm F1.2 Pro"Olympus M.Zuiko Digital ED 25mm F1.2 Pro"Olympus Zuiko Digital ED 50-200mm F2.8-3.5 SWD"Olympus Zuiko Digital ED 50-200mm F2.8-3.5 SWD"Olympus Zuiko Digital ED 12-60mm F2.8-4.0 SWD"Olympus Zuiko Digital ED 12-60mm F2.8-4.0 SWD"Olympus Zuiko Digital ED 14-35mm F2.0 SWD"Olympus Zuiko Digital ED 14-35mm F2.0 SWD"Olympus Zuiko Digital 25mm F2.8"Olympus Zuiko Digital 25mm F2.8"Olympus Zuiko Digital ED 9-18mm F4.0-5.6"Olympus Zuiko Digital ED 9-18mm F4.0-5.6"Olympus Zuiko Digital 14-54mm F2.8-3.5 II"Olympus Zuiko Digital 14-54mm F2.8-3.5 II"Sigma 18-50mm F3.5-5.6 DC"Sigma 18-50mm F3.5-5.6 DC"Sigma 30mm F2.8 EX DN"Sigma 30mm F2.8 EX DN"Sigma 55-200mm F4.0-5.6 DC"Sigma 55-200mm F4.0-5.6 DC"Sigma 19mm F2.8 EX DN"Sigma 19mm F2.8 EX DN"Sigma 18-125mm F3.5-5.6 DC"Sigma 18-125mm F3.5-5.6 DC"Sigma 30mm F2.8 DN | A"Sigma 30mm F2.8 DN | A"Sigma 18-125mm F3.5-5.6"Sigma 18-125mm F3.5-5.6"Sigma 19mm F2.8 DN | A"Sigma 19mm F2.8 DN | A"Sigma 30mm F1.4"Sigma 30mm F1.4"Sigma 60mm F2.8 DN | A"Sigma 60mm F2.8 DN | A"Sigma 50-500mm F4.0-6.3 EX DG APO HSM RF"Sigma 50-500mm F4.0-6.3 EX DG APO HSM RF"Sigma 30mm F1.4 DC DN | C"Sigma 30mm F1.4 DC DN | C"Sigma 105mm F2.8 DG"Sigma 105mm F2.8 DG"Sigma 150mm F2.8 DG HSM"Sigma 150mm F2.8 DG HSM"Sigma 18-50mm F2.8 EX DC Macro"Sigma 18-50mm F2.8 EX DC Macro"Sigma 24mm F1.8 EX DG Aspherical Macro"Sigma 24mm F1.8 EX DG Aspherical Macro"Sigma 135-400mm F4.5-5.6 DG ASP APO RF"Sigma 135-400mm F4.5-5.6 DG ASP APO RF"Sigma 300-800mm F5.6 EX DG APO"Sigma 300-800mm F5.6 EX DG APO"Sigma 30mm F1.4 EX DC HSM"Sigma 30mm F1.4 EX DC HSM"Sigma 10-20mm F4.0-5.6 EX DC HSM"Sigma 10-20mm F4.0-5.6 EX DC HSM"Sigma 70-200mm F2.8 EX DG Macro HSM II"Sigma 70-200mm F2.8 EX DG Macro HSM II"Sigma 50mm F1.4 EX DG HSM"Sigma 50mm F1.4 EX DG HSM"Leica D Vario Elmarit 14-50mm F2.8-3.5 Asph."Leica D Vario Elmarit 14-50mm F2.8-3.5 Asph."Lumix G Vario 14-45mm F3.5-5.6 Asph. Mega OIS"Lumix G Vario 14-45mm F3.5-5.6 Asph. Mega OIS"Leica D Summilux 25mm F1.4 Asph."Leica D Summilux 25mm F1.4 Asph."Lumix G Vario 45-200mm F4.0-5.6 Mega OIS"Lumix G Vario 45-200mm F4.0-5.6 Mega OIS"Leica D Vario Elmar 14-50mm F3.8-5.6 Asph. Mega OIS"Leica D Vario Elmar 14-50mm F3.8-5.6 Asph. Mega OIS"Leica D Vario Elmar 14-50mm F3.8-5.6 Asph."Leica D Vario Elmar 14-50mm F3.8-5.6 Asph."Lumix G Vario HD 14-140mm F4.0-5.8 Asph. Mega OIS"Lumix G Vario HD 14-140mm F4.0-5.8 Asph. Mega OIS"Leica D Vario Elmar 14-150mm F3.5-5.6"Leica D Vario Elmar 14-150mm F3.5-5.6"Lumix G Vario 7-14mm F4.0 Asph."Lumix G Vario 7-14mm F4.0 Asph."Lumix G 20mm F1.7 Asph."Lumix G 20mm F1.7 Asph."Leica DG Macro-Elmarit 45mm F2.8 Asph. Mega OIS"Leica DG Macro-Elmarit 45mm F2.8 Asph. Mega OIS"Lumix G Vario 14-42mm F3.5-5.6 Asph. Mega OIS"Lumix G Vario 14-42mm F3.5-5.6 Asph. Mega OIS"Lumix G Fisheye 8mm F3.5"Lumix G Fisheye 8mm F3.5"Lumix G Vario 100-300mm F4.0-5.6 Mega OIS"Lumix G Vario 100-300mm F4.0-5.6 Mega OIS"Lumix G 14mm F2.5 Asph."Lumix G 14mm F2.5 Asph."Lumix G 3D 12.5mm F12"Lumix G 3D 12.5mm F12"Leica DG Summilux 25mm F1.4 Asph."Leica DG Summilux 25mm F1.4 Asph."Lumix G X Vario PZ 45-175mm F4.0-5.6 Asph. Power OIS"Lumix G X Vario PZ 45-175mm F4.0-5.6 Asph. Power OIS"Lumix G X Vario PZ 14-42mm F3.5-5.6 Asph. Power OIS"Lumix G X Vario PZ 14-42mm F3.5-5.6 Asph. Power OIS"Lumix G X Vario 12-35mm F2.8 Asph. Power OIS"Lumix G X Vario 12-35mm F2.8 Asph. Power OIS"Lumix G Vario 45-150mm F4.0-5.6 Asph. Mega OIS"Lumix G Vario 45-150mm F4.0-5.6 Asph. Mega OIS"Lumix G X Vario 35-100mm F2.8 Power OIS"Lumix G X Vario 35-100mm F2.8 Power OIS"Lumix G Vario 14-42mm F3.5-5.6 II Asph. Mega OIS"Lumix G Vario 14-42mm F3.5-5.6 II Asph. Mega OIS"Lumix G Vario 14-140mm F3.5-5.6 Asph. Power OIS"Lumix G Vario 14-140mm F3.5-5.6 Asph. Power OIS"Lumix G Vario 12-32mm F3.5-5.6 Asph. Mega OIS"Lumix G Vario 12-32mm F3.5-5.6 Asph. Mega OIS"Leica DG Nocticron 42.5mm F1.2 Asph. Power OIS"Leica DG Nocticron 42.5mm F1.2 Asph. Power OIS"Leica DG Summilux 15mm F1.7 Asph."Leica DG Summilux 15mm F1.7 Asph."Lumix G Vario 35-100mm F4.0-5.6 Asph. Mega OIS"Lumix G Vario 35-100mm F4.0-5.6 Asph. Mega OIS"Lumix G Macro 30mm F2.8 Asph. Mega OIS"Lumix G Macro 30mm F2.8 Asph. Mega OIS"Lumix G 42.5mm F1.7 Asph. Power OIS"Lumix G 42.5mm F1.7 Asph. Power OIS"Lumix G 25mm F1.7 Asph."Lumix G 25mm F1.7 Asph."Leica DG Vario-Elmar 100-400mm F4.0-6.3 Asph. Power OIS"Leica DG Vario-Elmar 100-400mm F4.0-6.3 Asph. Power OIS"Lumix G Vario 12-60mm F3.5-5.6 Asph. Power OIS"Lumix G Vario 12-60mm F3.5-5.6 Asph. Power OIS"Tamron 14-150mm F3.5-5.8 Di III"Tamron 14-150mm F3.5-5.8 Di III""3000 Kelvin""3700 Kelvin""4000 Kelvin""4500 Kelvin""5500 Kelvin""6500 Kelvin""7500 Kelvin""One-touch"l0l13000 Kelvin3700 Kelvin4000 Kelvin4500 Kelvin5500 Kelvin6500 Kelvin7500 KelvinOne-touchof"Fast"Fastl2const TagInfo[37]TagInfo[37]const TagInfo[2]TagInfo[2]const TagInfo[52]TagInfo[52]const TagInfo[24]TagInfo[24]const TagInfo[26]TagInfo[26]const TagInfo[55]TagInfo[55]const TagInfo[95]TagInfo[95]"Fine Weather""Tungsten (incandescent)""Evening Sunlight""Daylight Fluorescent (D 5700 - 7100K)""Day White Fluorescent (N 4600 - 5400K)""Cool White Fluorescent (W 3900 - 4500K)""White Fluorescent (WW 3200 - 3700K)""One Touch White Balance""Custom 1-4"Fine WeatherTungsten (incandescent)Evening SunlightDaylight Fluorescent (D 5700 - 7100K)Day White Fluorescent (N 4600 - 5400K)Cool White Fluorescent (W 3900 - 4500K)White Fluorescent (WW 3200 - 3700K)One Touch White BalanceCustom 1-4olympusRiLightSource"Bounce or Off""Direct"Bounce or OffDirectolympusFiExternalFlashBounce4:3"4:3"3:2"3:2"16:9"16:9"6:6"6:6"5:4"5:4"7:6"7:6"6:5"6:5"7:5"7:5"3:4"3:4"olympusIpAspectRatio"On (2 frames)""On (3 frames)"On (2 frames)On (3 frames)olympusIpMultipleExposureModeolympusRd2PMPictureToneolympusRd2PM_BWFilter"Muted""Monotone"MutedMonotoneolympusRd2PictureMode"High Function"High FunctionolympusRd2Engine"Pro Photo RGB"Pro Photo RGBolympusRd2ColorSpace"Gray Point"Gray PointolympusRd2WhiteBalance"WB Color Temp""WB Gray Point"const TagDetailsBitmask[8]TagDetailsBitmask[8]WB Color TempWB Gray PointolympusRdSettings"Original""Edited (Landscape)""Edited (Portrait)"OriginalEdited (Landscape)Edited (Portrait)olympusRdEditStatus"Advanced High Speed""Advanced High Function"Advanced High SpeedAdvanced High FunctionolympusRdEngineolympusRdColorSpaceFL-20"FL-20"FL-50"FL-50"RF-11"RF-11"TF-22"TF-22"FL-36"FL-36"FL-50R"FL-50R"FL-36R"FL-36R"FL-14"FL-14"FL-600R"FL-600R"olympusEqFlashModel"Simple E-System""E-System"Simple E-SystemE-SystemolympusEqFlashType"On, Mode 1""On, Mode 2""On, Mode 3"On, Mode 1On, Mode 2On, Mode 3olympusImageStabilization"SQ""HQ""SHQ"SQHQSHQolympusCsQualityolympusPictureModeToneolympusPictureModeBWFilter"i-Enhance""e-Portrait""Color Creator""Color Profile 1""Color Profile 2""Color Profile 3""Monochrome Profile 1""Monochrome Profile 2""Monochrome Profile 3"i-Enhancee-PortraitColor CreatorColor Profile 1Color Profile 2Color Profile 3Monochrome Profile 1Monochrome Profile 2Monochrome Profile 3olympusPictureMode"Noise Filter""Noise Filter (ISO Boost)"const TagDetailsBitmask[4]TagDetailsBitmask[4]Noise FilterNoise Filter (ISO Boost)olympusNoiseReductionolympusColorSpace"CM1 (Red Enhance)""CM2 (Green Enhance)""CM3 (Blue Enhance)""CM4 (Skin Tones)"CM1 (Red Enhance)CM2 (Green Enhance)CM3 (Blue Enhance)CM4 (Skin Tones)olympusModifiedSaturation"Auto (Keep Warm Color Off""7500K (Fine Weather with Shade)""6000K (Cloudy)""5300K (Fine Weather)""3000K (Tungsten light)""3600K (Tungsten light-like)""Auto Setup""5500K (Flash)""6600K (Daylight fluorescent)""4500K (Neutral white fluorescent)""4000K (Cool white fluorescent)""White Fluorescent""One Touch WB 1""One Touch WB 2""One Touch WB 3""One Touch WB 4""Custom WB 1""Custom WB 2""Custom WB 3""Custom WB 4"const TagDetails[23]TagDetails[23]Auto (Keep Warm Color Off7500K (Fine Weather with Shade)6000K (Cloudy)5300K (Fine Weather)3000K (Tungsten light)3600K (Tungsten light-like)Auto Setup5500K (Flash)6600K (Daylight fluorescent)4500K (Neutral wh Y  y^    