/Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX.sdk/usr/include/pcap/namedb.hpcap_nametollcconst charconst char *char *pcap_nametoeprotopcap_nametoprotopcap_nametoportrangeint *pcap_nametoportpcap_nametonetaddraddrinfo *pcap_nametoaddrinfobpf_u_int32 *unsigned int *bpf_u_int32 **unsigned int **pcap_nametoaddru_char *unsigned char *pcap_ether_atonpcap_ether_hosttonpcap_etherent *pcap_next_etherentFILE *__sFILE *pcap_etherentchar[122]122nameu_char[6]unsigned char[6]6addrPROTO_UNDEF-1PCAP_ETHERS_FILE"/etc/ethers"lib_pcap_namedb_h__cplusplusexternc_linkage/*
 * If a protocol is unknown, PROTO_UNDEF is returned.
 * Also, pcap_nametoport() returns the protocol along with the port number.
 * If there are ambiguous entried in /etc/services (i.e. domain
 * can be either tcp or udp) PROTO_UNDEF is returned.
 *//*
 * As returned by the pcap_next_etherent()
 * XXX this stuff doesn't belong in this interface, but this
 * library already must do name to address translation, so
 * on systems that don't have support for /etc/ethers, we
 * export these hooks since they're already being used by
 * some applications (such as tcpdump) and already being
 * marked as exported in some OSes offering libpcap (such
 * as Debian).
 *//*
 * Copyright (c) 1994, 1996
 *	The Regents of the University of California.  All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *	This product includes software developed by the Computer Systems
 *	Engineering Group at Lawrence Berkeley Laboratory.
 * 4. Neither the name of the University nor of the Laboratory may be used
 *    to endorse or promote products derived from this software without
 *    specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 *//Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX.sdk/usr/include/pcap/Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX.sdk/usr/include/Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX.sdk/usr/Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX.sdk/Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Applications/Xcode.app/Contents/Developer/Platforms/Applications/Xcode.app/Contents/Developer/Applications/Xcode.app/Contents/Applications/Xcode.app/Applications//Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX.sdk/usr/include/pcap-namedb.h<pcap/namedb.h>/*
 * For backwards compatibility.
 *
 * Note to OS vendors: do NOT get rid of this file!  Some applications
 * might expect to be able to include <pcap-namedb.h>.
 *//Users/owura/Repos/codeql_eval/proj_repos/the-tcpdump-group-tcpdump-commit-9ba91381954ad325ea4fd26b9c65a8bd9a2a85b6/tcpdump/addrtoname.h(unnamed enum)LINKADDR_ETHER0LINKADDR_FRELAY1LINKADDR_IEEE13942LINKADDR_ATM3LINKADDR_OTHER4ip6addr_string(ndo,p)getname6(ndo, (const u_char *)(p))ipaddr_string(ndo,p)getname(ndo, (const u_char *)(p))BUFSIZE128INET6_ADDRSTRLENieee8021q_tci_stringconst uint16_th6namemem *newh6namememnetdissect_options *h6namememhnamemem *newhnamememhnamememinit_addrtonameintoagetname6const u_charconst u_char *getnameipxsap_stringprotoid_stringdnaddr_stringisonsap_stringudpport_stringtcpport_stringetherproto_stringle64addr_stringetheraddr_stringlinkaddr_stringconst unsigned int/* Name to address translation routines. *//*
 * Definitions to let us compile most of the IPv6 code even on systems
 * without IPv6 support.
 *//*
 * Copyright (c) 1990, 1992, 1993, 1994, 1995, 1996, 1997
 *	The Regents of the University of California.  All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that: (1) source code distributions
 * retain the above copyright notice and this paragraph in its entirety, (2)
 * distributions including binary code include the above copyright notice and
 * this paragraph in its entirety in the documentation or other materials
 * provided with the distribution, and (3) all advertising materials mentioning
 * features or use of this software display the following acknowledgement:
 * ``This product includes software developed by the University of California,
 * Lawrence Berkeley Laboratory and its contributors.'' Neither the name of
 * the University nor the names of its contributors may be used to endorse
 * or promote products derived from this software without specific prior
 * written permission.
 * THIS SOFTWARE IS PROVIDED ``AS IS'' AND WITHOUT ANY EXPRESS OR IMPLIED
 * WARRANTIES, INCLUDING, WITHOUT LIMITATION, THE IMPLIED WARRANTIES OF
 * MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE.
 *//Users/owura/Repos/codeql_eval/proj_repos/the-tcpdump-group-tcpdump-commit-9ba91381954ad325ea4fd26b9c65a8bd9a2a85b6/tcpdump/Users/owura/Repos/codeql_eval/proj_repos/the-tcpdump-group-tcpdump-commit-9ba91381954ad325ea4fd26b9c65a8bd9a2a85b6/Users/owura/Repos/codeql_eval/proj_repos/Users/owura/Repos/codeql_eval/Users/owura/Repos/Users/owura/Users/Users/owura/Repos/codeql_eval/proj_repos/the-tcpdump-group-tcpdump-commit-9ba91381954ad325ea4fd26b9c65a8bd9a2a85b6/tcpdump/addrtostr.haddrtostr6const voidconst void *void *addrtostr/* Address to printable string translation routines. *//*
 * Copyright (c) 1999 Kungliga Tekniska HÃ¶gskolan
 * (Royal Institute of Technology, Stockholm, Sweden).
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 *
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 *
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 *
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *      This product includes software developed by the Kungliga Tekniska
 *      HÃ¶gskolan and its contributors.
 *
 * 4. Neither the name of the Institute nor the names of its contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE INSTITUTE AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE INSTITUTE OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 */srcdstsize/Users/owura/Repos/codeql_eval/proj_repos/the-tcpdump-group-tcpdump-commit-9ba91381954ad325ea4fd26b9c65a8bd9a2a85b6/tcpdump/ethertype.hconst tokconst tok[]tok[]ethertype_valuesETHERTYPE_MEDSA0xdadaETHERTYPE_GEONET0x8947ETHERTYPE_GEONET_OLD0x0707ETHERTYPE_CALM_FAST0x1111ETHERTYPE_ISO0xfefeETHERTYPE_IEEE1905_10x893aETHERTYPE_CFM0x8902ETHERTYPE_CFM_OLD0xabcdETHERTYPE_VMAN0x9100ETHERTYPE_LOOPBACK0x9000ETHERTYPE_AOE0x88a2ETHERTYPE_RRCP0x8899ETHERTYPE_EAPOL0x888eETHERTYPE_LLDP0x88ccETHERTYPE_JUMBO0x8870ETHERTYPE_MS_NLB_HB0x886fETHERTYPE_PPPOES20x3c13ETHERTYPE_PPPOED20x3c12ETHERTYPE_PPPOES0x8864ETHERTYPE_PPPOED0x8863ETHERTYPE_MPLS_MULTI0x8848ETHERTYPE_MPLS0x8847ETHERTYPE_SLOW0x8809ETHERTYPE_MPCP0x8808ETHERTYPE_PPP0x880bETHERTYPE_IPV60x86ddETHERTYPE_IPX0x8137ETHERTYPE_8021QinQ0x88a8ETHERTYPE_8021Q92000x9200ETHERTYPE_8021Q9100ETHERTYPE_8021Q0x8100ETHERTYPE_TIPC0x88caETHERTYPE_AARP0x80f3ETHERTYPE_ATALK0x809bETHERTYPE_VPROD0x805cETHERTYPE_VEXP0x805bETHERTYPE_DECDTS0x803eETHERTYPE_DECDNS0x803cETHERTYPE_LANBRIDGE0x8038ETHERTYPE_TEB0x6558ETHERTYPE_SCA0x6007ETHERTYPE_LAT0x6004ETHERTYPE_DN0x6003ETHERTYPE_MOPRC0x6002ETHERTYPE_MOPDL0x6001ETHERTYPE_TRAIL0x1000ETHERTYPE_SPRITE0x0500ETHERTYPE_NS0x0600ETHERTYPE_REVARP0x8035ETHERTYPE_ARP0x0806ETHERTYPE_IP0x0800ETHERTYPE_PUP0x0200ETHERTYPE_GRE_ISO0x00FEETHERTYPE_LEN/* Marvel Distributed Switch Architecture *//* ETSI GeoNetworking (Official IEEE registration from Jan 2013) *//* ETSI GeoNetworking (before Jan 2013) *//* ISO CALM FAST *//* nonstandard - used in Cisco HDLC encapsulation *//* IEEE 1905.1 *//* 802.1ag *//* 802.1ag depreciated *//* Extreme VMAN Protocol *//* MS Network Load Balancing Heartbeat *//* see:
        http://en.wikipedia.org/wiki/IEEE_802.1Q
    and http://en.wikipedia.org/wiki/QinQ
*//* reverse Addr. resolution protocol *//* Addr. resolution protocol *//* IP protocol *//* PUP protocol *//* not really an ethertype only used in GRE *//*
 * Ethernet types.
 *
 * We wrap the declarations with #ifdef, so that if a file includes
 * <netinet/if_ether.h>, which may declare some of these, we don't
 * get a bunch of complaints from the C compiler about redefinitions
 * of these values.
 *
 * We declare all of them here so that no file has to include
 * <netinet/if_ether.h> if all it needs are ETHERTYPE_ values.
 *//*
 * Copyright (c) 1993, 1994, 1996
 *	The Regents of the University of California.  All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that: (1) source code distributions
 * retain the above copyright notice and this paragraph in its entirety, (2)
 * distributions including binary code include the above copyright notice and
 * this paragraph in its entirety in the documentation or other materials
 * provided with the distribution, and (3) all advertising materials mentioning
 * features or use of this software display the following acknowledgement:
 * ``This product includes software developed by the University of California,
 * Lawrence Berkeley Laboratory and its contributors.'' Neither the name of
 * the University nor the names of its contributors may be used to endorse
 * or promote products derived from this software without specific prior
 * written permission.
 * THIS SOFTWARE IS PROVIDED ``AS IS'' AND WITHOUT ANY EXPRESS OR IMPLIED
 * WARRANTIES, INCLUDING, WITHOUT LIMITATION, THE IMPLIED WARRANTIES OF
 * MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE.
 *//Users/owura/Repos/codeql_eval/proj_repos/the-tcpdump-group-tcpdump-commit-9ba91381954ad325ea4fd26b9c65a8bd9a2a85b6/tcpdump/llc.hPID_RFC2684_BPDU0x000ePID_RFC2684_802_6_NOFCS0x000bPID_RFC2684_802_6_FCS0x0005PID_RFC2684_FDDI_NOFCS0x000aPID_RFC2684_FDDI_FCS0x0004PID_RFC2684_802_5_NOFCS0x0009PID_RFC2684_802_5_FCS0x0003PID_RFC2684_802_4_NOFCS0x0008PID_RFC2684_802_4_FCS0x0002PID_RFC2684_ETH_NOFCS0x0007PID_RFC2684_ETH_FCS0x0001PID_CISCO_VLANBRIDGE0x010cPID_CISCO_PVST0x010bPID_CISCO_UDLD0x0111PID_CISCO_DTP0x2004PID_CISCO_VTP0x2003PID_CISCO_CDP0x2000LLCSAP_ISONS0xfeLLCSAP_NETBEUI0xf0LLCSAP_IPX0xe0LLCSAP_SNAP0xaaLLCSAP_PROWAY0x8eLLCSAP_ISO82080x7eLLCSAP_RS5110x4eLLCSAP_8021D0x42LLCSAP_PROWAYNM0x0eLLCSAP_IP0x06LLCSAP_SNA0x04LLCSAP_8021B_G0x03LLCSAP_8021B_I0x02LLCSAP_GLOBAL0xffLLCSAP_NULL0x00LLC_I_NS(is)(((is) >> 1) & 0x7f)LLC_IS_NR(is)(((is) >> 9) & 0x7f)LLC_REJLLC_RNRLLC_RRLLC_S_CMD(is)(((is) >> 2) & 0x03)LLC_FRMR0x87LLC_XID0xafLLC_TEST0xe3LLC_SABME0x6fLLC_DM0x0fLLC_DISC0x43LLC_UA0x63LLC_UILLC_U_CMD(u)((u) & 0xef)LLC_XID_FI0x81LLC_IS_POLL0x0100LLC_U_POLL0x10LLC_S_FMTLLC_IGLLC_GSAPLLC_U_FMT/* BPDUs *//* 802.6, without FCS *//* 802.6, with FCS *//* FDDI, without FCS *//* FDDI, with FCS *//* 802.5, without FCS *//* 802.5, with FCS *//* 802.4, without FCS *//* 802.4, with FCS *//* Ethernet, without FCS *//* Ethernet, with FCS *//*
 * PIDs for use with OUI_RFC2684.
 *//* "VLAN Bridge", according to Wireshark *//* Per VLAN Spanning Tree+ and RPVST+ *//* Unidirectional Link Detection *//* Cisco Dynamic Trunk Protocol *//* Cisco VLAN Trunk Protocol *//* Cisco Discovery Protocol *//*
 * PIDs for use with OUI_CISCO.
 *//* Individual / Group *//*
 * Definitions for information in the LLC header.
 *//*
 * Copyright (c) 1993, 1994, 1997
 *	The Regents of the University of California.  All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that: (1) source code distributions
 * retain the above copyright notice and this paragraph in its entirety, (2)
 * distributions including binary code include the above copyright notice and
 * this paragraph in its entirety in the documentation or other materials
 * provided with the distribution, and (3) all advertising materials mentioning
 * features or use of this software display the following acknowledgement:
 * ``This product includes software developed by the University of California,
 * Lawrence Berkeley Laboratory and its contributors.'' Neither the name of
 * the University nor the names of its contributors may be used to endorse
 * or promote products derived from this software without specific prior
 * written permission.
 * THIS SOFTWARE IS PROVIDED ``AS IS'' AND WITHOUT ANY EXPRESS OR IMPLIED
 * WARRANTIES, INCLUDING, WITHOUT LIMITATION, THE IMPLIED WARRANTIES OF
 * MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE.
 *//Users/owura/Repos/codeql_eval/proj_repos/the-tcpdump-group-tcpdump-commit-9ba91381954ad325ea4fd26b9c65a8bd9a2a85b6/tcpdump/extract.h"funcattrs.h"ND_TCHECK_128BITS(p)ND_TCHECK2(*(p), 16)ND_TTEST_128BITS(p)ND_TTEST2(*(p), 16)ND_TCHECK_64BITS(p)ND_TCHECK2(*(p), 8)ND_TTEST_64BITS(p)ND_TTEST2(*(p), 8)ND_TCHECK_56BITS(p)ND_TCHECK2(*(p), 7)ND_TTEST_56BITS(p)ND_TTEST2(*(p), 7)ND_TCHECK_48BITS(p)ND_TCHECK2(*(p), 6)ND_TTEST_48BITS(p)ND_TTEST2(*(p), 6)ND_TCHECK_40BITS(p)ND_TCHECK2(*(p), 5)ND_TTEST_40BITS(p)ND_TTEST2(*(p), 5)ND_TCHECK_32BITS(p)ND_TCHECK2(*(p), 4)ND_TTEST_32BITS(p)ND_TTEST2(*(p), 4)ND_TCHECK_24BITS(p)ND_TCHECK2(*(p), 3)ND_TTEST_24BITS(p)ND_TTEST2(*(p), 3)ND_TCHECK_16BITS(p)ND_TCHECK2(*(p), 2)ND_TTEST_16BITS(p)ND_TTEST2(*(p), 2)ND_TCHECK_8BITS(p)ND_TCHECK2(*(p), 1)ND_TTEST_8BITS(p)ND_TTEST2(*(p), 1)EXTRACT_LE_64BITS(p)((uint64_t)(((uint64_t)(*((const uint8_t *)(p) + 7)) << 56) | ((uint64_t)(*((const uint8_t *)(p) + 6)) << 48) | ((uint64_t)(*((const uint8_t *)(p) + 5)) << 40) | ((uint64_t)(*((const uint8_t *)(p) + 4)) << 32) | ((uint64_t)(*((const uint8_t *)(p) + 3)) << 24) | ((uint64_t)(*((const uint8_t *)(p) + 2)) << 16) | ((uint64_t)(*((const uint8_t *)(p) + 1)) << 8) | ((uint64_t)(*((const uint8_t *)(p) + 0)) << 0)))EXTRACT_LE_24BITS(p)((uint32_t)(((uint32_t)(*((const uint8_t *)(p) + 2)) << 16) | ((uint32_t)(*((const uint8_t *)(p) + 1)) << 8) | ((uint32_t)(*((const uint8_t *)(p) + 0)) << 0)))EXTRACT_LE_32BITS(p)((uint32_t)(((uint32_t)(*((const uint8_t *)(p) + 3)) << 24) | ((uint32_t)(*((const uint8_t *)(p) + 2)) << 16) | ((uint32_t)(*((const uint8_t *)(p) + 1)) << 8) | ((uint32_t)(*((const uint8_t *)(p) + 0)) << 0)))EXTRACT_LE_16BITS(p)((uint16_t)(((uint16_t)(*((const uint8_t *)(p) + 1)) << 8) | ((uint16_t)(*((const uint8_t *)(p) + 0)) << 0)))EXTRACT_56BITS(p)((uint64_t)(((uint64_t)(*((const uint8_t *)(p) + 0)) << 48) | ((uint64_t)(*((const uint8_t *)(p) + 1)) << 40) | ((uint64_t)(*((const uint8_t *)(p) + 2)) << 32) | ((uint64_t)(*((const uint8_t *)(p) + 3)) << 24) | ((uint64_t)(*((const uint8_t *)(p) + 4)) << 16) | ((uint64_t)(*((const uint8_t *)(p) + 5)) << 8) | ((uint64_t)(*((const uint8_t *)(p) + 6)) << 0)))EXTRACT_48BITS(p)((uint64_t)(((uint64_t)(*((const uint8_t *)(p) + 0)) << 40) | ((uint64_t)(*((const uint8_t *)(p) + 1)) << 32) | ((uint64_t)(*((const uint8_t *)(p) + 2)) << 24) | ((uint64_t)(*((const uint8_t *)(p) + 3)) << 16) | ((uint64_t)(*((const uint8_t *)(p) + 4)) << 8) | ((uint64_t)(*((const uint8_t *)(p) + 5)) << 0)))EXTRACT_40BITS(p)((uint64_t)(((uint64_t)(*((const uint8_t *)(p) + 0)) << 32) | ((uint64_t)(*((const uint8_t *)(p) + 1)) << 24) | ((uint64_t)(*((const uint8_t *)(p) + 2)) << 16) | ((uint64_t)(*((const uint8_t *)(p) + 3)) << 8) | ((uint64_t)(*((const uint8_t *)(p) + 4)) << 0)))EXTRACT_24BITS(p)((uint32_t)(((uint32_t)(*((const uint8_t *)(p) + 0)) << 16) | ((uint32_t)(*((const uint8_t *)(p) + 1)) << 8) | ((uint32_t)(*((const uint8_t *)(p) + 2)) << 0)))EXTRACT_64BITS(p)((uint64_t)(((uint64_t)(*((const uint8_t *)(p) + 0)) << 56) | ((uint64_t)(*((const uint8_t *)(p) + 1)) << 48) | ((uint64_t)(*((const uint8_t *)(p) + 2)) << 40) | ((uint64_t)(*((const uint8_t *)(p) + 3)) << 32) | ((uint64_t)(*((const uint8_t *)(p) + 4)) << 24) | ((uint64_t)(*((const uint8_t *)(p) + 5)) << 16) | ((uint64_t)(*((const uint8_t *)(p) + 6)) << 8) | ((uint64_t)(*((const uint8_t *)(p) + 7)) << 0)))EXTRACT_32BITS(p)((uint32_t)(((uint32_t)(*((const uint8_t *)(p) + 0)) << 24) | ((uint32_t)(*((const uint8_t *)(p) + 1)) << 16) | ((uint32_t)(*((const uint8_t *)(p) + 2)) << 8) | ((uint32_t)(*((const uint8_t *)(p) + 3)) << 0)))EXTRACT_16BITS(p)((uint16_t)(((uint16_t)(*((const uint8_t *)(p) + 0)) << 8) | ((uint16_t)(*((const uint8_t *)(p) + 1)) << 0)))UNALIGNED_OKEXTRACT_LE_8BITS(p)(*(p))EXTRACT_8BITS(p)defined(__GNUC__) && ((__GNUC__ * 100 + __GNUC_MINOR__) >= 409)__has_attribute(no_sanitize)LBL_ALIGNdefined(__GNUC__) && defined(HAVE___ATTRIBUTE__) && \__GNUC____GNUC_MINOR__/*
 * Macros to check the presence of the values in question.
 *//*
 * Macros to extract possibly-unaligned little-endian integral values.
 * XXX - do loads on little-endian machines that support unaligned loads?
 *//* LBL_ALIGN *//*
 * The processor natively handles unaligned loads, so we can just
 * cast the pointer and fetch through it.
 *//* must special-case unaligned accesses *//*
 * This isn't a GCC-compatible compiler, we don't have __attribute__,
 * or we do but we don't know of any better way with this instruction
 * set to do unaligned loads, so do unaligned loads of big-endian
 * quantities the hard way - fetch the bytes one at a time and
 * assemble them.
 *//* have to do it a byte at a time *//*
* This is a GCC-compatible compiler and we have __attribute__, which
 * we assume that mean we have __attribute__((packed)), and this is
 * MIPS or Alpha, which has instructions that can help when doing
 * unaligned loads.
 *
 * Declare packed structures containing a uint16_t and a uint32_t,
 * cast the pointer to point to one of those, and fetch through it;
 * the GCC manual doesn't appear to explicitly say that
 * __attribute__((packed)) causes the compiler to generate unaligned-safe
 * code, but it apppears to do so.
 *
 * We do this in case the compiler can generate code using those
 * instructions to do an unaligned load and pass stuff to "ntohs()" or
 * "ntohl()", which might be better than than the code to fetch the
 * bytes one at a time and assemble them.  (That might not be the
 * case on a little-endian platform, such as DEC's MIPS machines and
 * Alpha machines, where "ntohs()" and "ntohl()" might not be done
 * inline.)
 *
 * We do this only for specific architectures because, for example,
 * at least some versions of GCC, when compiling for 64-bit SPARC,
 * generate code that assumes alignment if we do this.
 *
 * XXX - add other architectures and compilers as possible and
 * appropriate.
 *
 * HP's C compiler, indicated by __HP_cc being defined, supports
 * "#pragma unaligned N" in version A.05.50 and later, where "N"
 * specifies a number of bytes at which the typedef on the next
 * line is aligned, e.g.
 *
 *	#pragma unalign 1
 *	typedef uint16_t unaligned_uint16_t;
 *
 * to define unaligned_uint16_t as a 16-bit unaligned data type.
 * This could be presumably used, in sufficiently recent versions of
 * the compiler, with macros similar to those below.  This would be
 * useful only if that compiler could generate better code for PA-RISC
 * or Itanium than would be generated by a bunch of shifts-and-ORs.
 *
 * DEC C, indicated by __DECC being defined, has, at least on Alpha,
 * an __unaligned qualifier that can be applied to pointers to get the
 * compiler to generate code that does unaligned loads and stores when
 * dereferencing the pointer in question.
 *
 * XXX - what if the native C compiler doesn't support
 * __attribute__((packed))?  How can we get it to generate unaligned
 * accesses for *specific* items?
 *//*
 * The processor doesn't natively handle unaligned loads.
 *//*
 * If we have versions of GCC or Clang that support an __attribute__
 * to say "if we're building with unsigned behavior sanitization,
 * don't complain about undefined behavior in this function", we
 * label these functions with that attribute - we *know* it's undefined
 * in the C standard, but we *also* know it does what we want with
 * the ISA we're targeting and the compiler we're using.
 *
 * For GCC 4.9.0 and later, we use __attribute__((no_sanitize_undefined));
 * pre-5.0 GCC doesn't have __has_attribute, and I'm not sure whether
 * GCC or Clang first had __attribute__((no_sanitize(XXX)).
 *
 * For Clang, we check for __attribute__((no_sanitize(XXX)) with
 * __has_attribute, as there are versions of Clang that support
 * __attribute__((no_sanitize("undefined")) but don't support
 * __attribute__((no_sanitize_undefined)).
 *
 * We define this here, rather than in funcattrs.h, because we
 * only want it used here, we don't want it to be broadly used.
 * (Any printer will get this defined, but this should at least
 * make it harder for people to find.)
 *//*
 * Inline functions or macros to extract possibly-unaligned big-endian
 * integral values.
 *//*
 * For 8-bit values; provided for the sake of completeness.  Byte order
 * isn't relevant, and alignment isn't an issue.
 *//*
 * Copyright (c) 1992, 1993, 1994, 1995, 1996
 *	The Regents of the University of California.  All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that: (1) source code distributions
 * retain the above copyright notice and this paragraph in its entirety, (2)
 * distributions including binary code include the above copyright notice and
 * this paragraph in its entirety in the documentation or other materials
 * provided with the distribution, and (3) all advertising materials mentioning
 * features or use of this software display the following acknowledgement:
 * ``This product includes software developed by the University of California,
 * Lawrence Berkeley Laboratory and its contributors.'' Neither the name of
 * the University nor the names of its contributors may be used to endorse
 * or promote products derived from this software without specific prior
 * written permission.
 * THIS SOFTWARE IS PROVIDED ``AS IS'' AND WITHOUT ANY EXPRESS OR IMPLIED
 * WARRANTIES, INCLUDING, WITHOUT LIMITATION, THE IMPLIED WARRANTIES OF
 * MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE.
 *//Users/owura/Repos/codeql_eval/proj_repos/the-tcpdump-group-tcpdump-commit-9ba91381954ad325ea4fd26b9c65a8bd9a2a85b6/tcpdump/oui.hsmi_valuesoui_valuesSMI_WIFI_ALLIANCE14122SMI_GEMTEK_SYSTEMS10529SMI_THE3GPP10415SMI_COLUMBIA_UNIVERSITY11862SMI_COLUBRIS8744SMI_INTERLINK6728SMI_QUINTUM6618SMI_ISSANNI5948SMI_IP_UNPLUGGED5925SMI_THE3GPP25535SMI_CISCO_BBSM5263SMI_UNISPHERE4874SMI_CABLELABS4491SMI_SIEMENS4329SMI_NOMADIX3309SMI_NETSCREEN3224SMI_SHASTA3199SMI_COSINE3085SMI_CISCO_VPN30003076SMI_APTIS2637SMI_JUNIPER2636SMI_REDBACK2352SMI_VERSANET2180SMI_FOUNDRY1991SMI_BAY1584SMI_ASCEND529SMI_3COM429SMI_MICROSOFT311SMI_LIVINGSTON307SMI_CISCO_VPN5000255SMI_ERICSSON193SMI_SHIVA166SMI_MERIT61SMI_SUN_MICROSYSTEMS42SMI_HEWLETT_PACKARD11SMI_CISCO9SMI_ACC5SMI_IETFOUI_NETRONOME0x0015adOUI_FREESCALE0x00049fOUI_ONLAB0xa42305OUI_INFOBLOX0x748771OUI_HPLABS0x0004eaOUI_HP20x002481OUI_VELLO0xb0d2f5OUI_BSN0x5c16c7OUI_NICIRA0x002320OUI_DCBX0x001B21OUI_TIA0x0012bbOUI_IEEE_8023_PRIVATE0x00120fOUI_IEEE_8021_PRIVATE0x0080c2OUI_HP0x080009OUI_JUNIPER0x009069OUI_APPLETALK0x080007OUI_CABLE_BPDU0x00E02FOUI_ATM_FORUM0x00A03EOUI_RFC2684OUI_CISCO_900x0000f8OUI_NORTEL0x000081OUI_IANA0x00005EOUI_CISCO0x00000cOUI_ENCAP_ETHER0x000000/* reserved - used by the IETF in L2TP? *//*
 * These are SMI Network Management Private Enterprise Codes for
 * organizations; see
 *
 *	http://www.iana.org/assignments/enterprise-numbers
 *
 * for a list.
 *
 * List taken from Ethereal's epan/sminmpec.h.
 *//* Netronome *//* Freescale *//* Open Networking Lab *//* Infoblox Inc *//* HP-Labs *//* HP too *//* Vello Systems *//* Big Switch Networks *//* Nicira Networks *//* DCBX *//* TIA - Telecommunications Industry Association - ANSI/TIA-1057- 2006 *//* IEEE 802.3 Organisation Specific - Annex G *//* IEEE 802.1 Organisation Specific - Annex F *//* Hewlett-Packard *//* Juniper *//* Appletalk *//* DOCSIS spanning tree BPDU *//* ATM Forum *//* RFC 2427/2684 bridged Ethernet *//* Cisco bridging *//* Nortel SONMP *//* IANA *//* Cisco protocols *//* encapsulated Ethernet *//*
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that: (1) source code
 * distributions retain the above copyright notice and this paragraph
 * in its entirety, and (2) distributions including binary code include
 * the above copyright notice and this paragraph in its entirety in
 * the documentation or other materials provided with the distribution.
 * THIS SOFTWARE IS PROVIDED ``AS IS'' AND
 * WITHOUT ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, WITHOUT
 * LIMITATION, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS
 * FOR A PARTICULAR PURPOSE.
 *
 * Original code by Hannes Gredler (hannes@gredler.at)
 */compiled as c/Users/owura/Repos/codeql_eval/proj_repos/the-tcpdump-group-tcpdump-commit-9ba91381954ad325ea4fd26b9c65a8bd9a2a85b6/tcpdump/config.h/Users/owura/Repos/codeql_eval/proj_repos/the-tcpdump-group-tcpdump-commit-9ba91381954ad325ea4fd26b9c65a8bd9a2a85b6/tcpdump/netdissect-stdinc.h/Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX.sdk/usr/include/errno.h/Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX.sdk/usr/include/sys/errno.h/Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX.sdk/usr/include/sys/cdefs.h/Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX.sdk/usr/include/sys/_symbol_aliasing.h/Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX.sdk/usr/include/sys/_posix_availability.h7/Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX.sdk/usr/include/sys/_types/_errno_t.h8/Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX.sdk/usr/include/ctype.h/Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX.sdk/usr/include/_ctype.h10/Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX.sdk/usr/include/runetype.h/Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX.sdk/usr/include/_types.h12/Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX.sdk/usr/include/sys/_types.h13/Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX.sdk/usr/include/machine/_types.h14/Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX.sdk/usr/include/i386/_types.h15/Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX.sdk/usr/include/sys/_pthread/_pthread_types.h16/Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX.sdk/usr/include/sys/_types/_size_t.h17/Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX.sdk/usr/include/sys/_types/_ct_rune_t.h18/Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX.sdk/usr/include/sys/_types/_rune_t.h19/Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX.sdk/usr/include/sys/_types/_wchar_t.h20/Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX.sdk/usr/include/sys/_types/_wint_t.h21/Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX.sdk/usr/include/unistd.h22/Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX.sdk/usr/include/sys/unistd.h23/Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX.sdk/usr/include/sys/_types/_posix_vdisable.h24/Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX.sdk/usr/include/sys/_types/_seek_set.h25/Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX.sdk/usr/include/sys/_types/_ssize_t.h26/Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX.sdk/usr/include/machine/types.h27/Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX.sdk/usr/include/i386/types.h28/Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX.sdk/usr/include/sys/_types/_int8_t.h29/Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX.sdk/usr/include/sys/_types/_int16_t.h30/Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX.sdk/usr/include/sys/_types/_int32_t.h31/Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX.sdk/usr/include/sys/_types/_int64_t.h32/Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX.sdk/usr/include/sys/_types/_u_int8_t.h33/Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX.sdk/usr/include/sys/_types/_u_int16_t.h34/Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX.sdk/usr/include/sys/_types/_u_int32_t.h35/Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX.sdk/usr/include/sys/_types/_u_int64_t.h36/Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX.sdk/usr/include/sys/_types/_intptr_t.h3738/Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX.sdk/usr/include/sys/_types/_uintptr_t.h39/Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX.sdk/usr/include/_types/_uint64_t.h40/Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX.sdk/usr/include/_types/_uint32_t.h41/Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX.sdk/usr/include/Availability.h/Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX.sdk/usr/include/AvailabilityVersions.h43/Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX.sdk/usr/include/AvailabilityInternal.h44/Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX.sdk/usr/include/sys/_types/_uid_t.h45/Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX.sdk/usr/include/sys/_types/_gid_t.h46/Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX.sdk/usr/include/sys/_types/_off_t.h47/Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX.sdk/usr/include/sys/_types/_pid_t.h48/Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX.sdk/usr/include/sys/_types/_useconds_t.h49/Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX.sdk/usr/include/sys/_types/_null.h50/Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX.sdk/usr/include/_ctermid.h51/Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX.sdk/usr/include/sys/select.h52/Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX.sdk/usr/include/sys/appleapiopts.h53/Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX.sdk/usr/include/sys/_types/_fd_def.h54/Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX.sdk/usr/include/sys/_types/_timespec.h55/Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX.sdk/usr/include/sys/_types/_timeval.h56/Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX.sdk/usr/include/sys/_types/_time_t.h57/Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX.sdk/usr/include/sys/_types/_suseconds_t.h58/Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX.sdk/usr/include/sys/_types/_sigset_t.h59/Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX.sdk/usr/include/sys/_types/_fd_setsize.h60/Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX.sdk/usr/include/sys/_types/_fd_set.h/Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX.sdk/usr/include/sys/_types/_fd_clr.h62/Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX.sdk/usr/include/sys/_types/_fd_isset.h63/Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX.sdk/usr/include/sys/_types/_fd_zero.h64/Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX.sdk/usr/include/sys/_types/_fd_copy.h65/Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX.sdk/usr/include/sys/_select.h66/Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX.sdk/usr/include/sys/_types/_dev_t.h67/Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX.sdk/usr/include/sys/_types/_mode_t.h68/Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX.sdk/usr/include/sys/_types/_uuid_t.h69/Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX.sdk/usr/include/gethostuuid.h70/Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX.sdk/usr/include/netdb.h71/Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX.sdk/usr/include/sys/_types/_socklen_t.h72/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/lib/clang/13.1.6/include/stdint.h73/Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX.sdk/usr/include/stdint.h74/Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX.sdk/usr/include/_types/_uint8_t.h75/Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX.sdk/usr/include/_types/_uint16_t.h76/Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX.sdk/usr/include/_types/_intmax_t.h77/Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX.sdk/usr/include/_types/_uintmax_t.h78/Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX.sdk/usr/include/netinet/in.h79/Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX.sdk/usr/include/sys/_types/_in_addr_t.h80/Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX.sdk/usr/include/sys/_types/_in_port_t.h81/Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX.sdk/usr/include/sys/socket.h82/Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX.sdk/usr/include/sys/types.h83/Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX.sdk/usr/include/machine/endian.h84/Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX.sdk/usr/include/i386/endian.h85/Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX.sdk/usr/include/sys/_endian.h86/Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX.sdk/usr/include/libkern/_OSByteOrder.h87/Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX.sdk/usr/include/libkern/i386/_OSByteOrder.h88/Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX.sdk/usr/include/sys/_types/_u_char.h89/Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX.sdk/usr/include/sys/_types/_u_short.h90/Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX.sdk/usr/include/sys/_types/_u_int.h91/Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX.sdk/usr/include/sys/_types/_caddr_t.h92/Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX.sdk/usr/include/sys/_types/_blkcnt_t.h93/Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX.sdk/usr/include/sys/_types/_blksize_t.h94/Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX.sdk/usr/include/sys/_types/_ino_t.h95/Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX.sdk/usr/include/sys/_types/_ino64_t.h96/Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX.sdk/usr/include/sys/_types/_key_t.h97/Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX.sdk/usr/include/sys/_types/_nlink_t.h98/Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX.sdk/usr/include/sys/_types/_id_t.h99/Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX.sdk/usr/include/sys/_types/_clock_t.h100/Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX.sdk/usr/include/sys/_types/_rsize_t.h101/Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX.sdk/usr/include/sys/_pthread/_pthread_attr_t.h102/Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX.sdk/usr/include/sys/_pthread/_pthread_cond_t.h103/Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX.sdk/usr/include/sys/_pthread/_pthread_condattr_t.h104/Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX.sdk/usr/include/sys/_pthread/_pthread_mutex_t.h105/Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX.sdk/usr/include/sys/_pthread/_pthread_mutexattr_t.h106/Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX.sdk/usr/include/sys/_pthread/_pthread_once_t.h107/Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX.sdk/usr/include/sys/_pthread/_pthread_rwlock_t.h108/Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX.sdk/usr/include/sys/_pthread/_pthread_rwlockattr_t.h109/Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX.sdk/usr/include/sys/_pthread/_pthread_t.h110/Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX.sdk/usr/include/sys/_pthread/_pthread_key_t.h111/Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX.sdk/usr/include/sys/_types/_fsblkcnt_t.h112/Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX.sdk/usr/include/sys/_types/_fsfilcnt_t.h113/Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX.sdk/usr/include/machine/_param.h114/Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX.sdk/usr/include/i386/_param.h115/Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX.sdk/usr/include/net/net_kev.h116/Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX.sdk/usr/include/sys/_types/_sa_family_t.h117/Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX.sdk/usr/include/sys/_types/_iovec_t.h118/Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX.sdk/usr/include/netinet6/in6.h119/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/lib/clang/13.1.6/include/inttypes.h120/Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX.sdk/usr/include/inttypes.h121/Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX.sdk/usr/include/sys/param.h123/Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX.sdk/usr/include/sys/syslimits.h124/Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX.sdk/usr/include/machine/param.h125/Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX.sdk/usr/include/i386/param.h126/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/lib/clang/13.1.6/include/limits.h127/Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX.sdk/usr/include/limits.h/Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX.sdk/usr/include/machine/limits.h129/Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX.sdk/usr/include/i386/limits.h130/Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX.sdk/usr/include/i386/_limits.h131/Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX.sdk/usr/include/sys/signal.h132/Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX.sdk/usr/include/machine/signal.h133/Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX.sdk/usr/include/i386/signal.h134/Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX.sdk/usr/include/machine/_mcontext.h135/Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX.sdk/usr/include/i386/_mcontext.h136/Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX.sdk/usr/include/mach/machine/_structs.h137/Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX.sdk/usr/include/mach/i386/_structs.h138/Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX.sdk/usr/include/sys/_types/_sigaltstack.h139/Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX.sdk/usr/include/sys/_types/_ucontext.h140/Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX.sdk/usr/include/sys/time.h141/Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX.sdk/usr/include/sys/_types/_timeval64.h142/Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX.sdk/usr/include/time.h143/Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX.sdk/usr/include/arpa/inet.h144/Users/owura/Repos/codeql_eval/proj_repos/the-tcpdump-group-tcpdump-commit-9ba91381954ad325ea4fd26b9c65a8bd9a2a85b6/tcpdump/funcattrs.h145/Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX.sdk/usr/include/pcap.h146/Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX.sdk/usr/include/pcap/pcap.h147/Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX.sdk/usr/include/pcap/funcattrs.h148/Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX.sdk/usr/include/pcap/compiler-tests.h149/Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX.sdk/usr/include/pcap/pcap-inttypes.h150/Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX.sdk/usr/include/pcap/socket.h151/Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX.sdk/usr/include/pcap/bpf.h152/Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX.sdk/usr/include/pcap/dlt.h153/Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX.sdk/usr/include/stdio.h154/Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX.sdk/usr/include/_stdio.h155/Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX.sdk/usr/include/sys/_types/_va_list.h156/Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX.sdk/usr/include/sys/stdio.h157/Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX.sdk/usr/include/secure/_stdio.h158/Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX.sdk/usr/include/secure/_common.h159160161/Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX.sdk/usr/include/signal.h162/Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX.sdk/usr/include/string.h163/Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX.sdk/usr/include/strings.h164165/Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX.sdk/usr/include/secure/_strings.h/Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX.sdk/usr/include/secure/_string.h167/Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX.sdk/usr/include/stdlib.h168/Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX.sdk/usr/include/sys/wait.h169/Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX.sdk/usr/include/sys/resource.h170/Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX.sdk/usr/include/alloca.h171172/Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX.sdk/usr/include/malloc/_malloc.h173/Users/owura/Repos/codeql_eval/proj_repos/the-tcpdump-group-tcpdump-commit-9ba91381954ad325ea4fd26b9c65a8bd9a2a85b6/tcpdump/netdissect.h174/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/lib/clang/13.1.6/include/stdarg.h175176/Users/owura/Repos/codeql_eval/proj_repos/the-tcpdump-group-tcpdump-commit-9ba91381954ad325ea4fd26b9c65a8bd9a2a85b6/tcpdump/ip.h177/Users/owura/Repos/codeql_eval/proj_repos/the-tcpdump-group-tcpdump-commit-9ba91381954ad325ea4fd26b9c65a8bd9a2a85b6/tcpdump/ip6.h178179180181182/Users/owura/Repos/codeql_eval/proj_repos/the-tcpdump-group-tcpdump-commit-9ba91381954ad325ea4fd26b9c65a8bd9a2a85b6/tcpdump/setsignal.h183184185/Users/owura/Repos/codeql_eval/proj_repos/the-tcpdump-group-tcpdump-commit-9ba91381954ad325ea4fd26b9c65a8bd9a2a85b6/tcpdump/addrtoname.c"oui.h""extract.h""setsignal.h""llc.h""ethertype.h""addrtostr.h""addrtoname.h""netdissect.h"<stdlib.h><string.h><stdio.h><signal.h><pcap-namedb.h><pcap.h><netdissect-stdinc.h>"config.h"char[128]bufstaticsizeof(buf)"vlan %u, p %u%s", tci & 0xfff, tci >> 13, (tci & 0x1000) ? ", DEI" : ""__builtin___snprintf_chk..(*)(..)__builtin_object_sizevlan %u, p %u%schar[16]40954096, DEIchar[6]char[1]pregisterptrnumsizeof (*ptr)newh6namemem: calloc"newh6namemem: calloc"char[21]newhnamemem: calloc"newhnamemem: calloc"char[20]tphnamemem[4096]HASHNAMESIZE(HASHNAMESIZE-1)init_ipxsaparrayitableipxsap_db[i].vconst tok[214]tok[214]const tok *tok *j__builtin_constant_p65280init_etherarrayconst etherlistconst etherlist *etherlist *elenamemem *epfpconst char *__restrict__/etc/etherschar[12]r"r"char[2]init_etherarray: strdup(ep->addr)"init_etherarray: strdup(ep->addr)"char[34]const u_char[6]const etherlist[2]etherlist[2]init_protoidarrayprotoidmem *const protoidlistconst protoidlist *protoidlist *plu_char[5]unsigned char[5]protoideproto_db[i].p(char *)&protoid[3](char *)&etype, 2const eprotoconst eproto[21]eproto[21]const eproto *eproto *etype__builtin___memcpy_chku_short *unsigned short *tcindodnaddrlocalnetmaskinit_protoidarray: strdup(eproto_db[i].s)"init_protoidarray: strdup(eproto_db[i].s)"char[42]const u_char[5]const protoidlist[6]protoidlist[6]init_eprotoarrayinit_servarrayservent *svchar[11]sizeof("0000000000")sv->s_port"%d", portporttcp"tcp"char[4]udp"udp"%dchar[3]init_servarray: strdup"init_servarray: strdup"char[23]cpchar[5]sizeof("0000")(__uint16_t)portconst char[16]0xf'\0'ipxsap_string: strdup(buf)"ipxsap_string: strdup(buf)"char[27]sizeof("00000")"%u", i%uudpport_string: strdup(buf)"udpport_string: strdup(buf)"char[28]tcpport_string: strdup(buf)"tcpport_string: strdup(buf)"nsap_idxISONSAP_MAX_LENGTHisonsap_string: illegal length"isonsap_string: illegal length"char[31]("isonsap_string: illegal length")xx.xxxx.xxxx.xxxx.xxxx.xxxx.xxxx.xxxx.xxxx.xxxx.xx"xx.xxxx.xxxx.xxxx.xxxx.xxxx.xxxx.xxxx.xxxx.xxxx.xx"char[51]"xx.xxxx.xxxx.xxxx.xxxx.xxxx.xxxx.xxxx.xxxx.xxxx.xx")sizeof("xx.xxxx.xxxx.xxxx.xxxx.xxxx.xxxx.xxxx.xxxx.xxxx.xx")isonsap_string: malloc"isonsap_string: malloc"'.'char[15]sizeof("00:00:00:00:00")':'protoid_string: strdup(buf)"protoid_string: strdup(buf)"etherproto_string: strdup(buf)"etherproto_string: strdup(buf)"bsnamemem *<empty>"<empty>"char[8]("<empty>")ETHER_ADDR_LENlinkaddr_string: malloc"linkaddr_string: malloc"char[24]lenle64addr_string: strdup(buf)"le64addr_string: strdup(buf)"char[29]ouiconst uint8_tconst uint8_t *nsapnsap_lengthpitypeBUFSIZE - (2 + 5*3)128 - (2 + 5*3)" (oui %s)", tok2str(oui_values, "Unknown", oui) (oui %s)char[10]Unknownetheraddr_string: strdup(buf)"etheraddr_string: strdup(buf)"char[30]lookup_protoidprotoidmem[4096]sizeof(*tp)lookup_protoid: calloc"lookup_protoid: calloc"lookup_nsapkensapenamemem[4096]lookup_nsap: malloc"lookup_nsap: malloc"(char *)&tp->e_nsap[1](const char *)nsap, nsap_lengthlookup_nsap: calloc"lookup_nsap: calloc"lookup_bytestringbsnamemem[4096]lookup_bytestring: calloc"lookup_bytestring: calloc"char[26]tp->bs_bytesbs, nlenlookup_emembsnlenlookup_emem: calloc"lookup_emem: calloc"hostent *hpunion <unnamed>for_hash_addrchar[46]ntop_buf&addrap, sizeof(addr)union <unnamed> *h6namemem[4096]in6_addr *sizeof(addr)AF_INET6dotpgetname6: strdup(hp->h_name)"getname6: strdup(hp->h_name)"sizeof(ntop_buf)getname6: strdup(cp)"getname6: strdup(cp)"uint32_t *AF_INETgetname: strdup(hp->h_name)"getname: strdup(hp->h_name)"getname: strdup(intoa(addr))"getname: strdup(intoa(addr))"bytenchar[17]sizeof(".xxx.xxx.xxx.xxx")(__uint32_t)addr427819008016711680'0'etherlistprotoidlisteprotoprotoidmembsnamememenamememaddradchar[14]fillsp_nxtp_namep_protop_ouibs_nxtbs_nbytesbs_bytesbs_namebs_addr2bs_addr1bs_addr0e_nxte_nsape_namee_addr2e_addr1e_addr0nxt0x0000"Unknown"User"User"User Group"User Group"PrintQueue"PrintQueue"FileServer"FileServer"JobServer"JobServer"0x0006Gateway"Gateway"PrintServer"PrintServer"ArchiveQueue"ArchiveQueue"char[13]ArchiveServer"ArchiveServer"JobQueue"JobQueue"char[9]Administration"Administration"0x000FNovell TI-RPC"Novell TI-RPC"0x0017Diagnostics"Diagnostics"0x0020NetBIOS"NetBIOS"0x0021NAS SNA Gateway"NAS SNA Gateway"0x0023NACS AsyncGateway"NACS AsyncGateway"char[18]0x0024RemoteBridge/RoutingService"RemoteBridge/RoutingService"0x0026BridgeServer"BridgeServer"0x0027TCP/IP Gateway"TCP/IP Gateway"0x0028Point-to-point X.25 BridgeServer"Point-to-point X.25 BridgeServer"char[33]0x00293270 Gateway"3270 Gateway"0x002aCHI Corp"CHI Corp"0x002cPC Chalkboard"PC Chalkboard"0x002dTimeSynchServer"TimeSynchServer"0x002eARCserve5.0/PalindromeBackup"ARCserve5.0/PalindromeBackup"0x0045DI3270 Gateway"DI3270 Gateway"0x0047AdvertisingPrintServer"AdvertisingPrintServer"0x004aNetBlazerModems"NetBlazerModems"0x004bBtrieveVAP"BtrieveVAP"0x004cNetwareSQL"NetwareSQL"0x004dXtreeNetwork"XtreeNetwork"0x0050BtrieveVAP4.11"BtrieveVAP4.11"0x0052QuickLink"QuickLink"0x0053PrintQueueUser"PrintQueueUser"0x0058Multipoint X.25 Router"Multipoint X.25 Router"0x0060STLB/NLM"STLB/NLM"0x0064ARCserve"ARCserve"0x0066ARCserve3.0"ARCserve3.0"0x0072WAN CopyUtility"WAN CopyUtility"0x007aTES-NetwareVMS"TES-NetwareVMS"0x0092WATCOM Debugger/EmeraldTapeBackupServer"WATCOM Debugger/EmeraldTapeBackupServer"char[40]0x0095DDA OBGYN"DDA OBGYN"0x0098NetwareAccessServer"NetwareAccessServer"0x009aNetware for VMS II/NamedPipeServer"Netware for VMS II/NamedPipeServer"char[35]0x009b0x009ePortableNetwareServer/SunLinkNVT"PortableNetwareServer/SunLinkNVT"0x00a1PowerchuteAPC UPS"PowerchuteAPC UPS"0x00aaLAWserve"LAWserve"0x00acCompaqIDA StatusMonitor"CompaqIDA StatusMonitor"256PIPE STAIL"PIPE STAIL"2580x0102LAN ProtectBindery"LAN ProtectBindery"char[19]2590x0103OracleDataBaseServer"OracleDataBaseServer"2630x0107Netware386/RSPX RemoteConsole"Netware386/RSPX RemoteConsole"2710x010fNovellSNA Gateway"NovellSNA Gateway"273TestServer"TestServer"2740x0112HP PrintServer"HP PrintServer"2760x0114CSA MUX"CSA MUX"2770x0115CSA LCA"CSA LCA"2780x0116CSA CM"CSA CM"char[7]2790x0117CSA SMA"CSA SMA"2800x0118CSA DBA"CSA DBA"2810x0119CSA NMA"CSA NMA"2820x011aCSA SSA"CSA SSA"2830x011bCSA STATUS"CSA STATUS"2860x011eCSA APPC"CSA APPC"ap2940x0126SNA TEST SSA Profile"SNA TEST SSA Profile"2980x012aCSA TRACE"CSA TRACE"2990x012bNetwareSAA"NetwareSAA"3020x012eIKARUS VirusScan"IKARUS VirusScan"3040x0130CommunicationsExecutive"CommunicationsExecutive"0x0133NNS DomainServer/NetwareNamingServicesDomain"NNS DomainServer/NetwareNamingServicesDomain"char[45]3090x0135NetwareNamingServicesProfile"NetwareNamingServicesProfile"0x0137Netware386 PrintQueue/NNS PrintQueue"Netware386 PrintQueue/NNS PrintQueue"char[37]3210x0141LAN SpoolServer"LAN SpoolServer"3380x0152IRMALAN Gateway"IRMALAN Gateway"3400x0154NamedPipeServer"NamedPipeServer"3580x0166NetWareManagement"NetWareManagement"3600x0168Intel PICKIT CommServer/Intel CAS TalkServer"Intel PICKIT CommServer/Intel CAS TalkServer"3710x0173Compaq"Compaq"3720x0174Compaq SNMP Agent"Compaq SNMP Agent"3730x01753840x0180XTreeServer/XTreeTools"XTreeServer/XTreeTools"3940x018ANASI ServicesBroadcastServer"NASI ServicesBroadcastServer"4320x01b0GARP Gateway"GARP Gateway"4330x01b1Binfview"Binfview"4470x01bfIntelLanDeskManager"IntelLanDeskManager"4580x01caAXTEC"AXTEC"4590x01cbShivaNetModem/E"ShivaNetModem/E"4600x01ccShivaLanRover/E"ShivaLanRover/E"4610x01cdShivaLanRover/T"ShivaLanRover/T"4620x01ceShivaUniversal"ShivaUniversal"4720x01d8CastelleFAXPressServer"CastelleFAXPressServer"4740x01daCastelleLANPressPrintServer"CastelleLANPressPrintServer"4760x01dcCastelleFAX/Xerox7033 FaxServer/ExcelLanFax"CastelleFAX/Xerox7033 FaxServer/ExcelLanFax"char[44]4960x01f0LEGATO"LEGATO"5010x01f55630x0233NMS Agent/NetwareManagementAgent"NMS Agent/NetwareManagementAgent"5670x0237NMS IPX Discovery/LANternReadWriteChannel"NMS IPX Discovery/LANternReadWriteChannel"5680x0238NMS IP Discovery/LANternTrapAlarmChannel"NMS IP Discovery/LANternTrapAlarmChannel"char[41]5700x023aLANtern"LANtern"5720x023cMAVERICK"MAVERICK"5750x023fNovellSMDR"NovellSMDR"5900x024eNetwareConnect"NetwareConnect"5910x024fNASI ServerBroadcast Cisco"NASI ServerBroadcast Cisco"6180x026aNMS ServiceConsole"NMS ServiceConsole"6190x026bTimeSynchronizationServer Netware 4.x"TimeSynchronizationServer Netware 4.x"char[38]6320x0278DirectoryServer Netware 4.x"DirectoryServer Netware 4.x"6350x027bNetwareManagementAgent"NetwareManagementAgent"6400x0280Novell File and Printer Sharing Service for PC"Novell File and Printer Sharing Service for PC"char[47]7720x0304NovellSAA Gateway"NovellSAA Gateway"7760x0308COM/VERMED"COM/VERMED"7780x030aGalacticommWorldgroupServer"GalacticommWorldgroupServer"7800x030cIntelNetport2/HP JetDirect/HP Quicksilver"IntelNetport2/HP JetDirect/HP Quicksilver"8000x0320AttachmateGateway"AttachmateGateway"8070x0327MicrosoftDiagnostiocs"MicrosoftDiagnostiocs"char[22]8080x0328WATCOM SQL Server"WATCOM SQL Server"8210x0335MultiTechSystems MultisynchCommServer"MultiTechSystems MultisynchCommServer"8350x0343Xylogics RemoteAccessServer/LANModem"Xylogics RemoteAccessServer/LANModem"8530x0355ArcadaBackupExec"ArcadaBackupExec"8560x0358MSLCD1"MSLCD1"8650x0361NETINELO"NETINELO"8940x037ePowerchute UPS Monitoring"Powerchute UPS Monitoring"8950x037fViruSafeNotify"ViruSafeNotify"9020x0386HP Bridge"HP Bridge"9030x0387HP Hub"HP Hub"9160x0394NetWare SAA Gateway"NetWare SAA Gateway"9230x039bLotusNotes"LotusNotes"9510x03b7CertusAntiVirus"CertusAntiVirus"9640x03c4ARCserve4.0"ARCserve4.0"9670x03c7LANspool3.5"LANspool3.5"9830x03d7LexmarkPrinterServer"LexmarkPrinterServer"9840x03d8LexmarkXLE PrinterServer"LexmarkXLE PrinterServer"char[25]9890x03ddBanyanENS NetwareClient"BanyanENS NetwareClient"9900x03deGuptaSequelBaseServer/NetWareSQL"GuptaSequelBaseServer/NetWareSQL"9930x03e1UnivelUnixware"UnivelUnixware"9960x03e410200x03fcIntelNetport"IntelNetport"10210x03fdPrintServerQueue"PrintServerQueue"10340x040AipnServer"ipnServer"10370x040DLVERRMAN"LVERRMAN"10380x040ELVLIC"LVLIC"10440x0414NET Silicon (DPI)/Kyocera"NET Silicon (DPI)/Kyocera"10650x0429SiteLockVirus"SiteLockVirus"10740x0432UFHELPR???"UFHELPR???"10750x0433Synoptics281xAdvancedSNMPAgent"Synoptics281xAdvancedSNMPAgent"10920x0444MicrosoftNT SNA Server"MicrosoftNT SNA Server"10960x0448Oracle"Oracle"11000x044cARCserve5.01"ARCserve5.01"11110x0457CanonGP55"CanonGP55"11140x045aQMS Printers"QMS Printers"11150x045bDellSCSI Array"DellSCSI Array"11690x049111960x04acOnTimeScheduler"OnTimeScheduler"12000x04b0CD-Net"CD-Net"12990x0513EmulexNQA"EmulexNQA"13120x0520SiteLockChecks"SiteLockChecks"13210x052913250x052dCitrixOS2 AppServer"CitrixOS2 AppServer"13330x0535Tektronix"Tektronix"13340x0536Milan"Milan"13730x055dAttachmate SNA gateway"Attachmate SNA gateway"13870x056bIBM8235 ModemServer"IBM8235 ModemServer"13880x056cShivaLanRover/E PLUS"ShivaLanRover/E PLUS"13890x056dShivaLanRover/T PLUS"ShivaLanRover/T PLUS"14080x0580McAfeeNetShield"McAfeeNetShield"14640x05B8NLM to workstation communication (Revelation Software)"NLM to workstation communication (Revelation Software)"char[55]14660x05BACompatibleSystemsRouters"CompatibleSystemsRouters"14700x05BECheyenneHierarchicalStorageManager"CheyenneHierarchicalStorageManager"15420x0606JCWatermarkImaging"JCWatermarkImaging"15480x060cAXISNetworkPrinter"AXISNetworkPrinter"15520x0610AdaptecSCSIManagement"AdaptecSCSIManagement"15690x0621IBM AntiVirus"IBM AntiVirus"16000x0640Windows95 RemoteRegistryService"Windows95 RemoteRegistryService"char[32]16140x064eMicrosoftIIS"MicrosoftIIS"16590x067bMicrosoft Win95/98 File and Print Sharing for NetWare"Microsoft Win95/98 File and Print Sharing for NetWare"char[54]16600x067c19000x076CXerox"Xerox"19470x079bShivaLanRover/E 115"ShivaLanRover/E 115"19480x079cShivaLanRover/T 115"ShivaLanRover/T 115"19720x07B4CubixWorldDesk"CubixWorldDesk"19860x07c2Quarterdeck IWare Connect V2.x NLM"Quarterdeck IWare Connect V2.x NLM"19850x07c1Quarterdeck IWare Connect V3.x NLM"Quarterdeck IWare Connect V3.x NLM"20640x0810ELAN License Server Demo"ELAN License Server Demo"20840x0824ShivaLanRoverAccessSwitch/E"ShivaLanRoverAccessSwitch/E"21540x086aISSC Collector"ISSC Collector"21750x087fISSC DAS AgentAIX"ISSC DAS AgentAIX"21760x0880Intel Netport PRO"Intel Netport PRO"21770x088128570x0b29SiteLock"SiteLock"31130x0c29SiteLockApplications"SiteLockApplications"31160x0c2cLicensingServer"LicensingServer"84490x2101PerformanceTechnologyInstantInternet"PerformanceTechnologyInstantInternet"90880x2380LAI SiteLock"LAI SiteLock"91000x238cMeetingMaker"MeetingMaker"184400x4808SiteLockServer/SiteLockMetering"SiteLockServer/SiteLockMetering"218450x5555SiteLockUser"SiteLockUser"253620x6312Tapeware"Tapeware"284160x6f00RabbitGateway"RabbitGateway"304670x7703MODEM"MODEM"327700x8002NetPortPrinters"NetPortPrinters"327760x8008WordPerfectNetworkVersion"WordPerfectNetworkVersion"342380x85BECisco EIGRP"Cisco EIGRP"349520x8888WordPerfectNetworkVersion/QuickNetworkManagement"WordPerfectNetworkVersion/QuickNetworkManagement"char[49]36864384040x9604CSA-NT_MON"CSA-NT_MON"467600xb6a8OceanIsleReachoutRemoteControl"OceanIsleReachoutRemoteControl"617270xf11fSiteLockMetering"SiteLockMetering"619510xf1ff627230xf503Microsoft SQL Server"Microsoft SQL Server"637490xF905IBM TimeAndPlace"IBM TimeAndPlace"645070xfbfbTopCallIII FaxServer"TopCallIII FaxServer"655350xffffAnyService/Wildcard"AnyService/Wildcard"(char *)0ipxsap_dbconst etherlist[]etherlist[]Broadcast"Broadcast"const protoidlist[]protoidlist[]0x0c0x010x07CiscoMLS"CiscoMLS"0x20CiscoCDP"CiscoCDP"CiscoCGMP"CiscoCGMP"CiscoVTP"CiscoVTP"2240x2b1870xbbExtremeEDP"ExtremeEDP"const eproto[]eproto[]pup"pup"512xns"xns"1536ip"ip"2048ip6"ip6"34525arp"arp"2054rarp"rarp"32821sprite"sprite"1280mopdl"mopdl"24577moprc"moprc"24578decnet"decnet"24579lat"lat"24580sca"sca"24583lanbridge"lanbridge"32824vexp"vexp"32859vprod"vprod"32860atalk"atalk"32923atalkarp"atalkarp"33011loopback"loopback"decdts"decdts"32830decdns"decdns"32828eproto_db0123456789abcde"0123456789abcdef"hexf_localnetf_netmaskprotoidtablebytestringtablensaptableenametableh6nametableipxsaptablednaddrtableeprototableuporttabletporttablehnametableHAVE_CONFIG_HUSE_ETHER_NTOHOSTHAVE_NETINET_IF_ETHER_HNETINET_ETHER_H_DECLARES_ETHER_NTOHOST!defined(HAVE_DECL_ETHER_NTOHOST) || !HAVE_DECL_ETHER_NTOHOSTHAVE_STRUCT_ETHER_ADDR_WIN32/* Represent TCI part of the 802.1Q 4-octet tag as text. *//* Return a zero'ed h6namemem struct and cuts down on calloc() overhead *//* Return a zero'ed hnamemem struct and cuts down on calloc() overhead *//*
		 * Simplest way to suppress names.
		 *//*
 * Initialize the address to name translation machinery.  We map all
 * non-local IP addresses to numeric addresses if ndo->ndo_fflag is true
 * (i.e., to prevent blocking on the nameserver).  localnet is the IP address
 * of the local network.  mask is its subnet mask.
 *//*
		 * Use YP/NIS version of name if available.
		 *//* Don't override existing name *//* Hardwire some ethernet names *//* Suck in entire ethers file *//*
 * Initialize the ethers hash table.  We take two different approaches
 * depending on whether or not the system provides the ethers name
 * service.  If it does, we just wire in a few names at startup,
 * and etheraddr_string() fills in the table on demand.  If it doesn't,
 * then we suck in the entire /etc/ethers file at startup.  The idea
 * is that parsing the local file will be fast, but spinning through
 * all the ethers entries via NIS & next_etherent might be very slow.
 *
 * XXX pcap_next_etherent doesn't belong in the pcap interface, but
 * since the pcap module already does name-to-address translation,
 * it's already does most of the work for the ethernet address-to-name
 * translation, so we just pcap_next_etherent as a convenience.
 *//* Hardwire some SNAP proto ID names *//*
 * SNAP proto IDs with org code 0:0:0 are actually encapsulated Ethernet
 * types.
 *//* XXX should be endian-insensitive, but do big-endian testing  XXX *//* 5 octets won't be aligned *//* Find the hash node that corresponds the protoid 'pi'. *//* guaranteed < ISONSAP_MAX_LENGTH *//* Find the hash node that corresponds the NSAP 'nsap' *//*
 * Find the hash node that corresponds to the bytestring 'bs'
 * with length 'nlen'
 *//* Find the hash node that corresponds the ether address 'ep' *//* Remove domain qualifications *//*
	 * Do not print names if -n was given.
	 *//*
 * Return a name for the IP6 address pointed to by ap.  This address
 * is assumed to be in network byte order.
 *//*
	 * Print names unless:
	 *	(1) -n was given.
	 *      (2) Address is foreign and -f was given. (If -f was not
	 *	    given, f_netmask and f_localnet are 0 and the test
	 *	    evaluates to true)
	 *//*
 * Return a name for the IP address pointed to by ap.  This address
 * is assumed to be in network byte order.
 *
 * NOTE: ap is *NOT* necessarily part of the packet data (not even if
 * this is being called with the "ipaddr_string()" macro), so you
 * *CANNOT* use the ND_TCHECK{2}/ND_TTEST{2} macros on it.  Furthermore,
 * even in cases where it *is* part of the packet data, the caller
 * would still have to check for a null return value, even if it's
 * just printing the return value with "%s" - not all versions of
 * printf print "(null)" with "%s" and a null pointer, some of them
 * don't check for a null pointer and crash in that case.
 *
 * The callers of this routine should, before handing this routine
 * a pointer to packet data, be sure that the data is present in
 * the packet buffer.  They should probably do those checks anyway,
 * as other data at that layer might not be IP addresses, and it
 * also needs to check whether they're present in the packet buffer.
 *//*
 * A faster replacement for inet_ntoa().
 *//* used only for nsaptable[] *//* _WIN32 *//*
 * fake gethostbyaddr for Win2k/XP
 * gethostbyaddr() returns incorrect value when AF_INET6 is passed
 * to 3rd argument.
 *
 * h_name in struct hostent is only valid.
 *//*
 * hash tables for whatever-to-name translations
 *
 * ndo_error() called on strdup(3) failure
 *//* USE_ETHER_NTOHOST *//* NETINET_ETHER_H_DECLARES_ETHER_NTOHOST *//* HAVE_NETINET_IF_ETHER_H *//* for "struct ifnet" in "struct arpcom" on Solaris *//* declarations in <net/if.h> *//* Squelch compiler warnings on some platforms for *//*
 * Copyright (c) 1990, 1991, 1992, 1993, 1994, 1995, 1996, 1997
 *	The Regents of the University of California.  All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that: (1) source code distributions
 * retain the above copyright notice and this paragraph in its entirety, (2)
 * distributions including binary code include the above copyright notice and
 * this paragraph in its entirety in the documentation or other materials
 * provided with the distribution, and (3) all advertising materials mentioning
 * features or use of this software display the following acknowledgement:
 * ``This product includes software developed by the University of California,
 * Lawrence Berkeley Laboratory and its contributors.'' Neither the name of
 * the University nor the names of its contributors may be used to endorse
 * or promote products derived from this software without specific prior
 * written permission.
 * THIS SOFTWARE IS PROVIDED ``AS IS'' AND WITHOUT ANY EXPRESS OR IMPLIED
 * WARRANTIES, INCLUDING, WITHOUT LIMITATION, THE IMPLIED WARRANTIES OF
 * MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE.
 *
 *  Internet, ethernet, port, and protocol string to address
 *  and address to string conversion routines
 */<machine/types.h>va_list__va_list_tag[1]_VA_LIST_T/* _VA_LIST_T *//* __darwin_va_list *//*
 * Copyright (c) 2012 Apple Inc. All rights reserved.
 *
 * @APPLE_OSREFERENCE_LICENSE_HEADER_START@
 *
 * This file contains Original Code and/or Modifications of Original Code
 * as defined in and that are subject to the Apple Public Source License
 * Version 2.0 (the 'License'). You may not use this file except in
 * compliance with the License. The rights granted to you under the License
 * may not be used to create, or enable the creation or redistribution of,
 * unlawful or unlicensed copies of an Apple operating system, or to
 * circumvent, violate, or enable the circumvention or violation of, any
 * terms of an Apple operating system software license agreement.
 *
 * Please obtain a copy of the License at
 * http://www.opensource.apple.com/apsl/ and read it before using this file.
 *
 * The Original Code and all software distributed under the License are
 * distributed on an 'AS IS' basis, WITHOUT WARRANTY OF ANY KIND, EITHER
 * EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES,
 * INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE, QUIET ENJOYMENT OR NON-INFRINGEMENT.
 * Please see the License for the specific language governing rights and
 * limitations under the License.
 *
 * @APPLE_OSREFERENCE_LICENSE_HEADER_END@
 *//Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX.sdk/usr/include/sys/_types/Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX.sdk/usr/include/sys/Users/owura/Repos/codeql_eval/proj_repos/the-tcpdump-group-tcpdump-commit-9ba91381954ad325ea4fd26b9c65a8bd9a2a85b6/tcpdump/addrtostr.csrcaddrdpspace_leftadded_spacesnprintfedstruct <unnamed>bestcuruint16_t[8]unsigned short[8]IN6ADDRSZINT16SZwords(IN6ADDRSZ / INT16SZ)uint16_t *(int)(IN6ADDRSZ / INT16SZ)"%x", words[i]ENOSPC(NULL)%xconst char[]char[]digits0123456789"0123456789"orig_dstINET_ADDRSTRLENnon_zerop 0const char[11]baseAPPEND_CHAR(c){ if (space_left == 0) { errno = ENOSPC; return (NULL); } *dp++ = c; space_left--; }/* Was it a trailing run of 0x00's?
   *//* Is this address an encapsulated IPv4?
     *//* Are we following an initial run of 0x00s or any real hex?
     *//* Are we inside the best run of 0x00's?
     *//* Format the result.
   *//* Preprocess:
   *  Copy the input (bytewise) array into a wordwise array.
   *  Find the longest run of 0x00's in src[] for :: shorthanding.
   *//*
   * Note that int32_t and int16_t need only be "at least" large enough
   * to contain a value of the specified size.  On some systems, like
   * Crays, there is no such thing as an integer variable with 16 bits.
   * Keep this in mind if you think this function should have been coded
   * to use pointer overlays.  All the world's not a VAX.
   *//*
 * Convert IPv6 binary address into presentation (printable) format.
 *//* word size *//* IPv6 T_AAAA *//*
 *
 */__gnuc_va_list__GNUC_VA_LISTva_copy(dest,src)__builtin_va_copy(dest, src)__va_copy(d,s)__builtin_va_copy(d,s)va_arg(ap,type)__builtin_va_arg(ap, type)va_end(ap)__builtin_va_end(ap)va_start(ap,param)__builtin_va_start(ap, param)_VA_LIST__STDARG_H__STDC_VERSION__ >= 199901L || __cplusplus >= 201103L || !defined(__STRICT_ANSI__)__STDC_VERSION__201710L/* __STDARG_H *//* GCC always defines __va_copy, but does not define va_copy unless in c99 mode
 * or -ansi is not specified, since it was not part of C90.
 *//*===---- stdarg.h - Variable argument handling ----------------------------===
 *
 * Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.
 * See https://llvm.org/LICENSE.txt for license information.
 * SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
 *
 *===-----------------------------------------------------------------------===
 *//Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/lib/clang/13.1.6/include/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/lib/clang/13.1.6/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/lib/clang/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/lib/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/Applications/Xcode.app/Contents/Developer/Toolchains/Users/owura/Repos/codeql_eval/proj_repos/the-tcpdump-group-tcpdump-commit-9ba91381954ad325ea4fd26b9c65a8bd9a2a85b6/tcpdump/af.hBSD_AFNUM_INET6_DARWINBSD_AFNUM_INET6_FREEBSDBSD_AFNUM_INET6_BSDBSD_AFNUM_IPXBSD_AFNUM_APPLETALKBSD_AFNUM_ISOBSD_AFNUM_NSBSD_AFNUM_INETAFNUM_L2VPN196AFNUM_VPLSAFNUM_E164NSAPAFNUM_BANYANAFNUM_DECNETAFNUM_ATALKAFNUM_IPXAFNUM_X121AFNUM_F69AFNUM_E164AFNUM_E163AFNUM_802AFNUM_BBN1822AFNUM_HDLCAFNUM_NSAPAFNUM_INET6AFNUM_INETbsd_af_valuesaf_values/* OS X, iOS, other Darwin-based OSes *//* FreeBSD *//* NetBSD, OpenBSD, BSD/OS, Npcap *//* XEROX NS protocols *//*
 * BSD AF_ values.
 *
 * Unfortunately, the BSDs don't all use the same value for AF_INET6,
 * so, because we want to be able to read captures from all of the BSDs,
 * we check for all of them.
 *//* still to be approved by IANA *//* draft-kompella-ppvpn-l2vpn *//* RFC1700 address family numbers *//*
 * Copyright (c) 1998-2006 The TCPDUMP project
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that: (1) source code
 * distributions retain the above copyright notice and this paragraph
 * in its entirety, and (2) distributions including binary code include
 * the above copyright notice and this paragraph in its entirety in
 * the documentation or other materials provided with the distribution.
 * THIS SOFTWARE IS PROVIDED ``AS IS'' AND
 * WITHOUT ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, WITHOUT
 * LIMITATION, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS
 * FOR A PARTICULAR PURPOSE.
 *
 * Original code by Hannes Gredler (hannes@gredler.at)
 *//Users/owura/Repos/codeql_eval/proj_repos/the-tcpdump-group-tcpdump-commit-9ba91381954ad325ea4fd26b9c65a8bd9a2a85b6/tcpdump/af.c"af.h"const tok[9]tok[9]IPv4"IPv4"NS"NS"ISO"ISO"Appletalk"Appletalk"IPX"IPX"IPv6"IPv6"const tok[19]tok[19]Reserved"Reserved"NSAP"NSAP"HDLC"HDLC"BBN 1822"BBN 1822"802"802"E.163"E.163"E.164"E.164"F.69"F.69"X.121"X.121"Novell IPX"Novell IPX"Decnet IV"Decnet IV"Banyan Vines"Banyan Vines"E.164 with NSAP subaddress"E.164 with NSAP subaddress"Layer-2 VPN"Layer-2 VPN"VPLS"VPLS"/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/lib/clang/13.1.6/include/stddef.h"__stddef_max_align_t.h"wchar_tsize_tptrdiff_t__need_STDDEF_H_miscoffsetof(t,d)__builtin_offsetof(t, d)__need_NULLNULL((void*)0)__need_wchar_t_WCHAR_T__need_size_t_SIZE_T__need_ptrdiff_t_PTRDIFF_T__STDDEF_H!defined(__STDDEF_H) || defined(__need_ptrdiff_t) ||                       \!defined(__need_ptrdiff_t) && !defined(__need_size_t) &&                   \!__has_feature(modules)defined(__need_ptrdiff_t)!defined(_PTRDIFF_T) || __has_feature(modules)defined(__need_size_t)!defined(_SIZE_T) || __has_feature(modules)defined(__need_STDDEF_H_misc)(defined(__STDC_WANT_LIB_EXT1__) && __STDC_WANT_LIB_EXT1__ >= 1 && \defined(__need_wchar_t)!defined(_WCHAR_T) || __has_feature(modules)defined(_MSC_EXTENSIONS)defined(__need_NULL)!defined(__MINGW32__) && !defined(_MSC_VER)defined(_MSC_EXTENSIONS) && defined(_NATIVE_NULLPTR_SUPPORTED)__STDC_VERSION__ >= 201112L || __cplusplus >= 201103Ldefined(__need_wint_t)!defined(_WINT_T) || __has_feature(modules)__WCHAR_TYPE__int__SIZE_TYPE__long unsigned int__PTRDIFF_TYPE__long int/* __need_wint_t *//* Always define wint_t when modules are available. *//* Some C libraries expect to see a wint_t here. Others (notably MinGW) will use
__WINT_TYPE__ directly; accommodate both by requiring __need_wint_t *//* defined(__need_STDDEF_H_misc) *//* defined(__need_NULL) *//* defined(__need_wchar_t) *//* Always define wchar_t when modules are available. *//* Always define rsize_t when modules are available. *//* ISO9899:2011 7.20 (C11 Annex K): Define rsize_t if __STDC_WANT_LIB_EXT1__ is
 * enabled. *//*defined(__need_size_t) *//* Always define size_t when modules are available. *//* defined(__need_ptrdiff_t) *//* Always define ptrdiff_t when modules are available. *//* __need_wint_t is intentionally not defined here. *//* Always define miscellaneous pieces when modules are available. *//*===---- stddef.h - Basic type definitions --------------------------------===
 *
 * Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.
 * See https://llvm.org/LICENSE.txt for license information.
 * SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
 *
 *===-----------------------------------------------------------------------===
 *//Users/owura/Repos/codeql_eval/proj_repos/the-tcpdump-group-tcpdump-commit-9ba91381954ad325ea4fd26b9c65a8bd9a2a85b6/tcpdump/ascii_strcasecmp.h/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/lib/clang/13.1.6/include/__stddef_max_align_t.h/Users/owura/Repos/codeql_eval/proj_repos/the-tcpdump-group-tcpdump-commit-9ba91381954ad325ea4fd26b9c65a8bd9a2a85b6/tcpdump/ascii_strcasecmp.c"ascii_strcasecmp.h"ascii_strncasecmpconst unsigned charconst unsigned char *cmconst unsigned char[256]unsigned char[256]us1us2(0)ascii_strcasecmpconst unsigned char[]unsigned char[]charmap/*
			 * We've run out of characters *to* compare,
			 * and they've all been equal; return 0, to
			 * indicate that the strings are the same.
			 *//*
			 * We've found a mismatch.
			 *//*
			 * We've run out of characters that we should
			 * compare, and they've all been equal; return
			 * 0, to indicate that the prefixes are the
			 * same.
			 *//*
 * This array maps upper-case ASCII letters to their lower-case
 * equivalents; all other byte values are mapped to themselves,
 * so this is locale-independent and intended to be locale-independent,
 * to avoid issues with, for example, "i" and "I" not being lower-case
 * and upper-case versions of the same letter in Turkish, where
 * there are separate "i with dot" and "i without dot" letters.
 *//*
 * Copyright (c) 1987 Regents of the University of California.
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms are permitted
 * provided that this notice is preserved and that due credit is given
 * to the University of California at Berkeley. The name of the University
 * may not be used to endorse or promote products derived from this
 * software without specific written prior permission. This software
 * is provided ``as is'' without express or implied warranty.
 */s1s2/Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX.sdk/usr/include/assert.h<sys/cdefs.h>__assert_rtnstatic_assert_Static_assert_ASSERT_H_assert(e)(__builtin_expect(!(e), 0) ? __assert_rtn(__func__, __ASSERT_FILE_NAME, __LINE__, #e) : (void)0)__assert(e,file,line)__assert_rtn ((const char *)-1L, file, line, e)__ASSERT_FILE_NAME__FILE____assertassertNDEBUG__FILE_NAME__defined(__ENVIRONMENT_MAC_OS_X_VERSION_MIN_REQUIRED__) && ((__ENVIRONMENT_MAC_OS_X_VERSION_MIN_REQUIRED__-0) < 1070)__DARWIN_UNIX03defined(__STDC_VERSION__) && __STDC_VERSION__ >= 201112Lnoreturncold__ENVIRONMENT_MAC_OS_X_VERSION_MIN_REQUIRED__120000/* _ASSERT_H_ *//* !__cplusplus *//* __STDC_VERSION__ *//* NDEBUG *//* __GNUC__ *//* __DARWIN_UNIX03 *//* !__DARWIN_UNIX03 *//* 8462256: modified __assert_rtn() replaces deprecated __eprintf() *//* __FILE_NAME__ *//*
 * Unlike other ANSI header files, <assert.h> may usefully be included
 * multiple times, with and without NDEBUG defined.
 *//* __cplusplus *//*-
 * Copyright (c) 1992, 1993
 *	The Regents of the University of California.  All rights reserved.
 * (c) UNIX System Laboratories, Inc.
 * All or some portions of this file are derived from material licensed
 * to the University of California by American Telephone and Telegraph
 * Co. or Unix System Laboratories, Inc. and are reproduced herein with
 * the permission of UNIX System Laboratories, Inc.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *	This product includes software developed by the University of
 *	California, Berkeley and its contributors.
 * 4. Neither the name of the University nor the names of its contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 *
 *	@(#)assert.h	8.2 (Berkeley) 1/21/94
 * $FreeBSD: src/include/assert.h,v 1.4 2002/03/23 17:24:53 imp Exp $
 *//Users/owura/Repos/codeql_eval/proj_repos/the-tcpdump-group-tcpdump-commit-9ba91381954ad325ea4fd26b9c65a8bd9a2a85b6/tcpdump/checksum.c<assert.h>create_osi_cksumxymulc0c1checksumidx0x00FFinit_checksumvoid_param_listverify_crc10_cksum10230x3ffconst uint16_t[256]unsigned short[256]const uint16_t *init_crc10_tableaccumuint16_t[256]verify_crc10_table10240x4001587CRC10_POLYNOMIALmemcmp(verify_crc10_table, crc10_table, sizeof(verify_crc10_table)) == 0__builtin_expectconst char[17]__func__./checksum.cchar[73]crc10_table0x633/*
         * Ignore the contents of the checksum field.
         *//*
 * Creates the OSI Fletcher checksum. See 8473-1, Appendix C, section C.3.
 * The checksum field of the passed PDU does not need to be reset to zero.
 *//* precompute checksum tables *//*
 * CRC-10 table generated using the following Python snippet:

import sys

crc_table = []
for i in range(256):
	accum = i << 2
	for j in range(8):
		accum <<= 1
		if accum & 0x400:
			accum ^= 0x633
	crc_table.append(accum)

for i in range(len(crc_table)/8):
	for j in range(8):
		sys.stdout.write("0x%04x, " % crc_table[i*8+j])
	sys.stdout.write("\n")

 *//*
 * Copyright (c) 1998-2006 The TCPDUMP project
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that: (1) source code
 * distributions retain the above copyright notice and this paragraph
 * in its entirety, and (2) distributions including binary code include
 * the above copyright notice and this paragraph in its entirety in
 * the documentation or other materials provided with the distribution.
 * THIS SOFTWARE IS PROVIDED ``AS IS'' AND
 * WITHOUT ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, WITHOUT
 * LIMITATION, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS
 * FOR A PARTICULAR PURPOSE.
 *
 * miscellaneous checksumming routines
 *
 * Original code by Hannes Gredler (hannes@gredler.at)
 */pptrchecksum_offsetlength/Users/owura/Repos/codeql_eval/proj_repos/the-tcpdump-group-tcpdump-commit-9ba91381954ad325ea4fd26b9c65a8bd9a2a85b6/tcpdump/cpack.hcpack_statec_lenc_nextc_bufcpack_int64(__s,__p)cpack_uint64((__s), (uint64_t*)(__p))cpack_int32(__s,__p)cpack_uint32((__s), (uint32_t*)(__p))cpack_int16(__s,__p)cpack_uint16((__s), (uint16_t*)(__p))cpack_int8(__s,__p)cpack_uint8((__s), (uint8_t*)(__p))_CPACK_Hcpack_advancecpack_state *const size_tcpack_align_and_reservecpack_next_boundarycpack_uint64uint64_t *unsigned long long *cpack_uint32cpack_uint16cpack_uint8uint8_t *cpack_init/* _CPACK_H *//*-
 * Copyright (c) 2003, 2004 David Young.  All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. The name of David Young may not be used to endorse or promote
 *    products derived from this software without specific prior
 *    written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY DAVID YOUNG ``AS IS'' AND ANY
 * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
 * THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A
 * PARTICULAR PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL DAVID
 * YOUNG BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
 * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED
 * TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
 * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
 * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
 * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY
 * OF SUCH DAMAGE.
 */cswordsizealignment/Users/owura/Repos/codeql_eval/proj_repos/the-tcpdump-group-tcpdump-commit-9ba91381954ad325ea4fd26b9c65a8bd9a2a85b6/tcpdump/cpack.c"cpack.h"nextsizeof(*u)0, sizeof(*cs)__builtin___memset_chkmisalignment/* Move pointer past the uint8_t. *//* No space left? *//* Unpack an 8-bit unsigned integer. *//* Move pointer past the uint16_t. *//* Unpack a 16-bit unsigned integer. *//* Move pointer past the uint32_t. *//* Unpack a 32-bit unsigned integer. *//* Move pointer past the uint64_t. *//* Unpack a 64-bit unsigned integer. *//* Advance by N bytes without returning them. *//* Too little space for wordsize bytes? *//* Ensure alignment. *//* Advance to the next wordsize boundary. Return NULL if fewer than
 * wordsize bytes remain in the buffer after the boundary.  Otherwise,
 * return a pointer to the boundary.
 */ubuflentoskip/Users/owura/Repos/codeql_eval/proj_repos/the-tcpdump-group-tcpdump-commit-9ba91381954ad325ea4fd26b9c65a8bd9a2a85b6/tcpdump/gmpls.hGMPLS_FSC200GMPLS_LSCGMPLS_TSCGMPLS_L2SCGMPLS_PSC4GMPLS_PSC3GMPLS_PSC2GMPLS_PSC1lmp_sd_service_config_cpsa_signal_type_sonet_valueslmp_sd_service_config_cpsa_signal_type_sdh_valueslmp_sd_service_config_cpsa_link_type_valuesdiffserv_te_bc_valuesgmpls_payload_valuesgmpls_encoding_valuesgmpls_switch_cap_tsc_indication_valuesgmpls_switch_cap_valuesgmpls_link_prot_values/Users/owura/Repos/codeql_eval/proj_repos/the-tcpdump-group-tcpdump-commit-9ba91381954ad325ea4fd26b9c65a8bd9a2a85b6/tcpdump/gmpls.c"gmpls.h"const tok[4]tok[4]DIFFSERV_BC_MODEL_RDMRussian dolls"Russian dolls"DIFFSERV_BC_MODEL_MAMMaximum allocation"Maximum allocation"254DIFFSERV_BC_MODEL_EXTD_MAMMaximum allocation with E-LSP support"Maximum allocation with E-LSP support"STS-1 SPE"STS-1 SPE"STS-3c SPE"STS-3c SPE"STS-1"STS-1"STM-3"STM-3"STM-12"STM-12"STM-48"STM-48"STM-192"STM-192"STM-768"STM-768"VC-3"VC-3"VC-4"VC-4"STM-0"STM-0"STM-1"STM-1"STM-4"STM-4"STM-16"STM-16"STM-64"STM-64"STM-256"STM-256"const tok[3]tok[3]SDH ITU-T G.707"SDH ITU-T G.707"SONET ANSI T1.105"SONET ANSI T1.105"const tok[60]tok[60]Asynchronous mapping of E4"Asynchronous mapping of E4"Asynchronous mapping of DS3/T3"Asynchronous mapping of DS3/T3"Asynchronous mapping of E3"Asynchronous mapping of E3"Bit synchronous mapping of E3"Bit synchronous mapping of E3"Byte synchronous mapping of E3"Byte synchronous mapping of E3"Asynchronous mapping of DS2/T2"Asynchronous mapping of DS2/T2"Bit synchronous mapping of DS2/T2"Bit synchronous mapping of DS2/T2"Asynchronous mapping of E1"Asynchronous mapping of E1"Byte synchronous mapping of E1"Byte synchronous mapping of E1"Byte synchronous mapping of 31 * DS0"Byte synchronous mapping of 31 * DS0"Asynchronous mapping of DS1/T1"Asynchronous mapping of DS1/T1"Bit synchronous mapping of DS1/T1"Bit synchronous mapping of DS1/T1"Byte synchronous mapping of DS1/T1"Byte synchronous mapping of DS1/T1"VC-11 in VC-12"VC-11 in VC-12"DS1 SF Asynchronous"DS1 SF Asynchronous"DS1 ESF Asynchronous"DS1 ESF Asynchronous"DS3 M23 Asynchronous"DS3 M23 Asynchronous"DS3 C-Bit Parity Asynchronous"DS3 C-Bit Parity Asynchronous"VT/LOVC"VT/LOVC"STS SPE/HOVC"STS SPE/HOVC"POS - No Scrambling, 16 bit CRC"POS - No Scrambling, 16 bit CRC"POS - No Scrambling, 32 bit CRC"POS - No Scrambling, 32 bit CRC"POS - Scrambling, 16 bit CRC"POS - Scrambling, 16 bit CRC"POS - Scrambling, 32 bit CRC"POS - Scrambling, 32 bit CRC"ATM mapping"ATM mapping"Ethernet PHY"Ethernet PHY"SONET/SDH"SONET/SDH"Reserved (SONET deprecated)"Reserved (SONET deprecated)"Digital Wrapper"Digital Wrapper"Lambda"Lambda"ANSI/ETSI PDH"ANSI/ETSI PDH"Link Access Protocol SDH (X.85 and X.86)"Link Access Protocol SDH (X.85 and X.86)"FDDI"FDDI"DQDB (ETSI ETS 300 216)"DQDB (ETSI ETS 300 216)"FiberChannel-3 (Services)"FiberChannel-3 (Services)"Ethernet V2/DIX (only)"Ethernet V2/DIX (only)"Ethernet 802.3 (only)"Ethernet 802.3 (only)"G.709 ODUj"G.709 ODUj"G.709 OTUk(v)"G.709 OTUk(v)"CBR/CBRa"CBR/CBRa"CBRb"CBRb"BSOT"BSOT"BSNT"BSNT"IP/PPP (GFP)"IP/PPP (GFP)"Ethernet MAC (framed GFP)"Ethernet MAC (framed GFP)"Ethernet PHY (transparent GFP)"Ethernet PHY (transparent GFP)"ESCON"ESCON"FICON"FICON"Fiber Channel"Fiber Channel"const tok[12]tok[12]Packet"Packet"Ethernet V2/DIX"Ethernet V2/DIX"SDH ITU-T G.707/SONET ANSI T1.105"SDH ITU-T G.707/SONET ANSI T1.105"Lambda (photonic)"Lambda (photonic)"Fiber"Fiber"FiberChannel"FiberChannel"Standard SONET/SDH"Standard SONET/SDH"Arbitrary SONET/SDH"Arbitrary SONET/SDH"Packet-Switch Capable-1"Packet-Switch Capable-1"Packet-Switch Capable-2"Packet-Switch Capable-2"Packet-Switch Capable-3"Packet-Switch Capable-3"Packet-Switch Capable-4"Packet-Switch Capable-4"Layer-2 Switch Capable"Layer-2 Switch Capable"Time-Division-Multiplex"Time-Division-Multiplex"Lambda-Switch Capable"Lambda-Switch Capable"Fiber-Switch Capable"Fiber-Switch Capable"Extra Traffic"Extra Traffic"Unprotected"Unprotected"Shared"Shared"0x08Dedicated 1:1"Dedicated 1:1"Dedicated 1+1"Dedicated 1+1"Enhanced"Enhanced"0x400x80/* experimental *//* draft-ietf-tewg-diff-te-proto-07 *//*
 * Signal Type values for SONET links used by LMP Service Discovery (specifically,
 * the Client Port Service Attributes Object). See UNI 1.0 section 9.4.2 for
 * details.
 *//*
 * Signal Type values for SDH links used by LMP Service Discovery (specifically,
 * the Client Port Service Attributes Object). See UNI 1.0 section 9.4.2 for
 * details.
 *//*
 * Link Type values used by LMP Service Discovery (specifically, the Client
 * Port Service Attributes Object). See UNI 1.0 section 9.4.2 for details.
 *//* draft-ietf-ccamp-gmpls-g709-04.txt *//* rfc3471 *//* rfc4205 *//Users/owura/Repos/codeql_eval/proj_repos/the-tcpdump-group-tcpdump-commit-9ba91381954ad325ea4fd26b9c65a8bd9a2a85b6/tcpdump/gmt2local.h/Users/owura/Repos/codeql_eval/proj_repos/the-tcpdump-group-tcpdump-commit-9ba91381954ad325ea4fd26b9c65a8bd9a2a85b6/tcpdump/gmt2local.c"gmt2local.h"gmt2localdtdirtm *gmtlocsgmttime_t *long *const time_tconst time_t *HAVE_OS_PROTO_H/*
	 * If the year or julian day is different, we span 00:00 GMT
	 * and must add or subtract a day. Check the year first to
	 * avoid problems when the julian day wraps.
	 *//*
 * Returns the difference between gmt and local time in seconds.
 * Use gmtime() and localtime() to keep things simple.
 *//*
 * Copyright (c) 1997
 *	The Regents of the University of California.  All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that: (1) source code distributions
 * retain the above copyright notice and this paragraph in its entirety, (2)
 * distributions including binary code include the above copyright notice and
 * this paragraph in its entirety in the documentation or other materials
 * provided with the distribution, and (3) all advertising materials mentioning
 * features or use of this software display the following acknowledgement:
 * ``This product includes software developed by the University of California,
 * Lawrence Berkeley Laboratory and its contributors.'' Neither the name of
 * the University nor the names of its contributors may be used to endorse
 * or promote products derived from this software without specific prior
 * written permission.
 * THIS SOFTWARE IS PROVIDED ``AS IS'' AND WITHOUT ANY EXPRESS OR IMPLIED
 * WARRANTIES, INCLUDING, WITHOUT LIMITATION, THE IMPLIED WARRANTIES OF
 * MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE.
 */t/Users/owura/Repos/codeql_eval/proj_repos/the-tcpdump-group-tcpdump-commit-9ba91381954ad325ea4fd26b9c65a8bd9a2a85b6/tcpdump/in_cksum.cin_cksum_shouldbeshouldbecomputed_sum0xFFFFin_cksumconst cksum_vecconst cksum_vec *cksum_vec *wsummlenbyte_swappeds_utill_utiluint8_t[2]unsigned char[2]uint16_t[2]unsigned short[2]lcREDUCE{l_util.l = sum; sum = l_util.s[0] + l_util.s[1]; ADDCARRY(sum);}ADDCARRY(x){if ((x) > 65535) (x) -= 65535;}/*
	 * The value that should have gone into the checksum field
	 * is the negative of the value gotten by summing up everything
	 * *but* the checksum field.
	 *
	 * We can compute that by subtracting the value of the checksum
	 * field from the sum of all the data in the packet, and then
	 * computing the negative of that value.
	 *
	 * "sum" is the value of the checksum field, and "computed_sum"
	 * is the negative of the sum of all the data in the packets,
	 * so that's -(-computed_sum - sum), or (sum + computed_sum).
	 *
	 * All the arithmetic in question is one's complement, so the
	 * addition must include an end-around carry; we do this by
	 * doing the arithmetic in 32 bits (with no sign-extension),
	 * and then adding the upper 16 bits of the sum, which contain
	 * the carry, to the lower 16 bits of the sum, and then do it
	 * again in case *that* sum produced a carry.
	 *
	 * As RFC 1071 notes, the checksum can be computed without
	 * byte-swapping the 16-bit words; summing 16-bit words
	 * on a big-endian machine gives a big-endian checksum, which
	 * can be directly stuffed into the big-endian checksum fields
	 * in protocol headers, and summing words on a little-endian
	 * machine gives a little-endian checksum, which must be
	 * byte-swapped before being stuffed into a big-endian checksum
	 * field.
	 *
	 * "computed_sum" is a network-byte-order value, so we must put
	 * it in host byte order before subtracting it from the
	 * host-byte-order value from the header; the adjusted checksum
	 * will be in host byte order, which is what we'll return.
	 *//*
 * Given the host-byte-order value of the checksum field in a packet
 * header, and the network-byte-order computed checksum of the data
 * that the checksum covers (including the checksum itself), compute
 * what the checksum field *should* have been.
 *//* The last mbuf has odd # of bytes. Follow the
		   standard (the odd byte may be shifted left by 8 bits
		   or not as determined by endian-ness of the machine) *//*
		 * Unroll the loop to make overhead from
		 * branches &c small.
		 *//*
		 * Force to even boundary.
		 *//*
			 * The first byte of this chunk is the continuation
			 * of a word spanning between this chunk and the
			 * last chunk.
			 *
			 * s_util.c[0] is already saved when scanning previous
			 * chunk.
			 *//*
 * Checksum routine for Internet Protocol family headers (Portable Version).
 *
 * This routine is very heavily used in the network
 * code and should be modified for each CPU to be as fast as possible.
 *//*
 * Copyright (c) 1988, 1992, 1993
 *	The Regents of the University of California.  All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. Neither the name of the University nor the names of its contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 *
 *	@(#)in_cksum.c	8.1 (Berkeley) 6/10/93
 *//* in_cksum.c
 * 4.4-Lite-2 Internet checksum routine, modified to take a vector of
 * pointers/lengths giving the pieces to be checksummed.  Also using
 * Tahoe/CGI version of ADDCARRY(x) macro instead of from portable version.
 */vecveclen/Users/owura/Repos/codeql_eval/proj_repos/the-tcpdump-group-tcpdump-commit-9ba91381954ad325ea4fd26b9c65a8bd9a2a85b6/tcpdump/ipproto.hIPPROTO_MOBILITYIPPROTO_CARPIPPROTO_VRRPIPPROTO_OSPFIPPROTO_EIGRPIPPROTO_MOBILITY_OLDIPPROTO_MOBILEIPPROTO_DCCPIPPROTO_IPIPPROTO_HOPOPTSIPPROTO_ICMPIPPROTO_IGMPIPPROTO_IPV4IPPROTO_TCPIPPROTO_EGPIPPROTO_PIGPIPPROTO_UDPIPPROTO_IPV6IPPROTO_ROUTINGIPPROTO_FRAGMENTIPPROTO_RSVPIPPROTO_GREIPPROTO_ESPIPPROTO_AHIPPROTO_ICMPV6IPPROTO_NONEIPPROTO_DSTOPTSIPPROTO_NDIPPROTO_PIMIPPROTO_IPCOMPIPPROTO_PGMIPPROTO_SCTPnetdb_protonameconst nd_uint8_tipproto_values/* Cisco/GXS IGRP *//* Sun net disk proto (temp.) *//*
 * The current Protocol Numbers list says that the IP protocol number for
 * mobility headers is 135; it cites draft-ietf-mobileip-ipv6-24, but
 * that draft doesn't actually give a number.
 *
 * It appears that 62 used to be used, even though that's assigned to
 * a protocol called CFTP; however, the only reference for CFTP is a
 * Network Message from BBN back in 1982, so, for now, we support 62,
 * as well as 135, as a protocol number for mobility headers.
 *//* IPv6 destination options *//* IPv6 no next header *//* ICMPv6 *//* SIPP Auth Header *//* SIPP Encap Sec. Payload *//* General Routing Encap. *//* resource reservation *//* IPv6 fragmentation header *//* IPv6 routing header *//* datagram congestion control protocol *//* user datagram protocol *//* exterior gateway protocol *//* tcp *//* group mgmt protocol *//* control message protocol *//* IPv6 hop-by-hop options *//* dummy for IP *//*
 * Copyright (c) 1982, 1986, 1990, 1993
 *	The Regents of the University of California.  All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *	This product includes software developed by the University of
 *	California, Berkeley and its contributors.
 * 4. Neither the name of the University nor the names of its contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 *
 * From:
 *	@(#)in.h	8.3 (Berkeley) 1/3/94
 * $FreeBSD: src/sys/netinet/in.h,v 1.38.2.3 1999/08/29 16:29:34 peter Exp $
 *//Users/owura/Repos/codeql_eval/proj_repos/the-tcpdump-group-tcpdump-commit-9ba91381954ad325ea4fd26b9c65a8bd9a2a85b6/tcpdump/ipproto.c"ipproto.h"const char *[256]char *[256]const char **char **hopopt"hopopt"icmp"icmp"igmp"igmp"ggp"ggp"ipencap"ipencap"st"st"cbt"cbt"egp"egp"igp"igp"bbn-rcc-mon"bbn-rcc-mon"nvp-ii"nvp-ii"argus"argus"emcon"emcon"xnet"xnet"chaos"chaos"mux"mux"dcn-meas"dcn-meas"hmp"hmp"prm"prm"xns-idp"xns-idp"trunk-1"trunk-1"trunk-2"trunk-2"leaf-1"leaf-1"leaf-2"leaf-2"rdp"rdp"irtp"irtp"iso-tp4"iso-tp4"netblt"netblt"mfe-nsp"mfe-nsp"merit-inp"merit-inp"dccp"dccp"3pc"3pc"idpr"idpr"xtp"xtp"ddp"ddp"idpr-cmtp"idpr-cmtp"tp++"tp++"il"il"ipv6"ipv6"sdrp"sdrp"ipv6-route"ipv6-route"ipv6-frag"ipv6-frag"idrp"idrp"rsvp"rsvp"gre"gre"dsr"dsr"bna"bna"esp"esp"ah"ah"i-nlsp"i-nlsp"swipe"swipe"narp"narp"mobile"mobile"tlsp"tlsp"skip"skip"ipv6-icmp"ipv6-icmp"ipv6-nonxt"ipv6-nonxt"ipv6-opts"ipv6-opts"cftp"cftp"sat-expak"sat-expak"kryptolan"kryptolan"rvd"rvd"ippc"ippc"sat-mon"sat-mon"visa"visa"ipcv"ipcv"cpnx"cpnx"rspf"rspf"wsn"wsn"pvp"pvp"br-sat-mon"br-sat-mon"sun-nd"sun-nd"wb-mon"wb-mon"wb-expak"wb-expak"iso-ip"iso-ip"vmtp"vmtp"secure-vmtp"secure-vmtp"vines"vines"ttp"ttp"nsfnet-igp"nsfnet-igp"dgp"dgp"tcf"tcf"eigrp"eigrp"ospf"ospf"sprite-rpc"sprite-rpc"larp"larp"mtp"mtp"ax.25"ax.25"ipip"ipip"micp"micp"scc-sp"scc-sp"etherip"etherip"encap"encap"gmtp"gmtp"ifmp"ifmp"pnni"pnni"pim"pim"aris"aris"scps"scps"qnx"qnx"a/n"a/n"ipcomp"ipcomp"snp"snp"compaq-peer"compaq-peer"ipx-in-ip"ipx-in-ip"vrrp"vrrp"pgm"pgm"l2tp"l2tp"ddx"ddx"iatp"iatp"stp"stp"srp"srp"uti"uti"smp"smp"sm"sm"ptp"ptp"isis"isis"fire"fire"crtp"crtp"crudp"crudp"sscopmce"sscopmce"iplt"iplt"sps"sps"pipe"pipe"sctp"sctp"fc"fc"rsvp-e2e-ignore"rsvp-e2e-ignore"mobility-header"mobility-header"udplite"udplite"mpls-in-ip"mpls-in-ip"manet"manet"hip"hip"shim6"shim6"wesp"wesp"rohc"rohc"exptest-253"exptest-253"exptest-254"exptest-254"reserved"reserved"netdb_protocol_namesconst tok[29]tok[29]Options"Options"ICMP"ICMP"IGMP"IGMP"IPIP"IPIP"TCP"TCP"EGP"EGP"IGRP"IGRP"UDP"UDP"DCCP"DCCP"Routing"Routing"Fragment"Fragment"RSVP"RSVP"GRE"GRE"ESP"ESP"AH"AH"Mobile IP"Mobile IP"ICMPv6"ICMPv6"Mobile IP (old)"Mobile IP (old)"EIGRP"EIGRP"OSPF"OSPF"PIM"PIM"Compressed IP"Compressed IP"VRRP"VRRP"PGM"PGM"SCTP"SCTP"Mobility"Mobility"CARP"CARP"/* The function enforces the array index to be 8-bit. *//* 255 (reserved) *//* 254 (Use for experimentation and testing,
	                      *     RFC 3692)
	                      *//* 253 (Use for experimentation and testing,
	                      *     RFC 3692)
	                      *//* 252 (unassigned) *//* 251 (unassigned) *//* 250 (unassigned) *//* 249 (unassigned) *//* 248 (unassigned) *//* 247 (unassigned) *//* 246 (unassigned) *//* 245 (unassigned) *//* 244 (unassigned) *//* 243 (unassigned) *//* 242 (unassigned) *//* 241 (unassigned) *//* 240 (unassigned) *//* 239 (unassigned) *//* 238 (unassigned) *//* 237 (unassigned) *//* 236 (unassigned) *//* 235 (unassigned) *//* 234 (unassigned) *//* 233 (unassigned) *//* 232 (unassigned) *//* 231 (unassigned) *//* 230 (unassigned) *//* 229 (unassigned) *//* 228 (unassigned) *//* 227 (unassigned) *//* 226 (unassigned) *//* 225 (unassigned) *//* 224 (unassigned) *//* 223 (unassigned) *//* 222 (unassigned) *//* 221 (unassigned) *//* 220 (unassigned) *//* 219 (unassigned) *//* 218 (unassigned) *//* 217 (unassigned) *//* 216 (unassigned) *//* 215 (unassigned) *//* 214 (unassigned) *//* 213 (unassigned) *//* 212 (unassigned) *//* 211 (unassigned) *//* 210 (unassigned) *//* 209 (unassigned) *//* 208 (unassigned) *//* 207 (unassigned) *//* 206 (unassigned) *//* 205 (unassigned) *//* 204 (unassigned) *//* 203 (unassigned) *//* 202 (unassigned) *//* 201 (unassigned) *//* 200 (unassigned) *//* 199 (unassigned) *//* 198 (unassigned) *//* 197 (unassigned) *//* 196 (unassigned) *//* 195 (unassigned) *//* 194 (unassigned) *//* 193 (unassigned) *//* 192 (unassigned) *//* 191 (unassigned) *//* 190 (unassigned) *//* 189 (unassigned) *//* 188 (unassigned) *//* 187 (unassigned) *//* 186 (unassigned) *//* 185 (unassigned) *//* 184 (unassigned) *//* 183 (unassigned) *//* 182 (unassigned) *//* 181 (unassigned) *//* 180 (unassigned) *//* 179 (unassigned) *//* 178 (unassigned) *//* 177 (unassigned) *//* 176 (unassigned) *//* 175 (unassigned) *//* 174 (unassigned) *//* 173 (unassigned) *//* 172 (unassigned) *//* 171 (unassigned) *//* 170 (unassigned) *//* 169 (unassigned) *//* 168 (unassigned) *//* 167 (unassigned) *//* 166 (unassigned) *//* 165 (unassigned) *//* 164 (unassigned) *//* 163 (unassigned) *//* 162 (unassigned) *//* 161 (unassigned) *//* 160 (unassigned) *//* 159 (unassigned) *//* 158 (unassigned) *//* 157 (unassigned) *//* 156 (unassigned) *//* 155 (unassigned) *//* 154 (unassigned) *//* 153 (unassigned) *//* 152 (unassigned) *//* 151 (unassigned) *//* 150 (unassigned) *//* 149 (unassigned) *//* 148 (unassigned) *//* 147 (unassigned) *//* 146 (unassigned) *//* 145 (unassigned) *//* 144 (unassigned) *//* 143 (unassigned) *//* 142 (Robust Header Compression) *//* 141 (Wrapped Encapsulating Security Payload) *//* 140 (Shim6 Protocol) *//* 139 (Host Identity Protocol) *//* 138 (MANET Protocols) *//* 137 (MPLS-in-IP) *//* 136 (UDPLite) *//* 135 (IPPROTO_MOBILITY, Mobility Header) *//* 134 (RSVP-E2E-IGNORE) *//* 133 (Fibre Channel) *//* 132 (IPPROTO_SCTP, Stream Control Transmission
	                      *     Protocol)
	                      *//* 131 (Private IP Encapsulation within IP) *//* 130 (Secure Packet Shield) *//* 129 (IPLT) *//* 128 (SSCOPMCE) *//* 127 (Combat Radio User Datagram) *//* 126 (Combat Radio Transport Protocol) *//* 125 (FIRE) *//* 124 (ISIS over IPv4) *//* 123 (Performance Transparency Protocol) *//* 122 (Simple Multicast Protocol) *//* 121 (Simple Message Protocol) *//* 120 (UTI) *//* 119 (SpectraLink Radio Protocol) *//* 118 (Schedule Transfer Protocol) *//* 117 (Interactive Agent Transfer Protocol) *//* 116 (D-II Data Exchange (DDX)) *//* 115 (Layer Two Tunneling Protocol) *//* 114 (any 0-hop protocol) *//* 113 (IPPROTO_PGM, PGM Reliable Transport
	                      *     Protocol)
	                      *//* 112 (IPPROTO_VRRP, Virtual Router Redundancy
	                      *     Protocol)
	                      *//* 111 (IPX in IP) *//* 110 (Compaq Peer Protocol) *//* 109 (Sitara Networks Protocol) *//* 108 (IPPROTO_IPCOMP, IP Payload Compression
	                      *     Protocol)
	                      *//* 107 (Active Networks) *//* 106 (QNX) *//* 105 (SCPS) *//* 104 (ARIS) *//* 103 (IPPROTO_PIM, Protocol Independent
	                      *     Multicast)
	                      *//* 102 (PNNI over IP) *//* 101 (Ipsilon Flow Management Protocol) *//* 100 (GMTP) *//* 99 (any private encryption scheme) *//* 98 (Encapsulation Header) *//* 97 (Ethernet-within-IP Encapsulation) *//* 96 (Semaphore Communications Sec. Pro.) *//* 95 (Mobile Internetworking Control Pro.) *//* 94 (IP-within-IP Encapsulation Protocol) *//* 93 (AX.25 Frames) *//* 92 (Multicast Transport Protocol) *//* 91 (Locus Address Resolution Protocol) *//* 90 (Sprite RPC Protocol) *//* 89 (IPPROTO_OSPF, Open Shortest Path First
	                      *    IGP)
	                      *//* 88 (IPPROTO_EIGRP, Cisco EIGRP) *//* 87 (TCF) *//* 86 (Dissimilar Gateway Protocol) *//* 85 (NSFNET-IGP) *//* 84 (Transaction Transport Protocol, also IPTM --
	                      *    Internet Protocol Traffic Manager)
	                      *//* 83 (VINES) *//* 82 (Secure VMTP) *//* 81 (Versatile Message Transport) *//* 80 (ISO Internet Protocol) *//* 79 (WIDEBAND EXPAK) *//* 78 (WIDEBAND Monitoring) *//* 77 (IPPROTO_ND, SUN ND PROTOCOL-Temporary) *//* 76 (Backroom SATNET Monitoring) *//* 75 (Packet Video Protocol) *//* 74 (Wang Span Network) *//* 73 (Radio Shortest Path First, CPHB -- Computer
	                      *    Protocol Heart Beat -- in IANA)
	                      *//* 72 (Computer Protocol Network Executive) *//* 71 (Internet Packet Core Utility) *//* 70 (VISA Protocol) *//* 69 (SATNET Monitoring) *//* 68 (any distributed file system) *//* 67 (Internet Pluribus Packet Core) *//* 66 (MIT Remote Virtual Disk Protocol) *//* 65 (Kryptolan) *//* 64 (SATNET and Backroom EXPAK) *//* 63 (any local network) *//* 62 (IPPROTO_MOBILITY_OLD, CFTP, see the note
	                      *    in ipproto.h)
	                      *//* 61 (any host internal protocol) *//* 60 (IPPROTO_DSTOPTS, Destination Options for
	                      *    IPv6)
	                      *//* 59 (IPPROTO_NONE, No Next Header for IPv6) *//* 58 (IPPROTO_ICMPV6, ICMP for IPv6) *//* 57 (SKIP) *//* 56 (Transport Layer Security Protocol using
	                      *    Kryptonet key management)
	                      *//* 55 (IPPROTO_MOBILE, IP Mobility) *//* 54 (NBMA Address Resolution Protocol) *//* 53 (IP with Encryption) *//* 52 (Integrated Net Layer Security TUBA) *//* 51 (IPPROTO_AH, Authentication Header) *//* 50 (IPPROTO_ESP, Encap Security Payload) *//* 49 (BNA) *//* 48 (Dynamic Source Routing Protocol) *//* 47 (IPPROTO_GRE, Generic Routing
	                      *    Encapsulation)
	                      *//* 46 (IPPROTO_RSVP, Reservation Protocol) *//* 45 (Inter-Domain Routing Protocol) *//* 44 (IPPROTO_FRAGMENT, Fragment Header for
	                      *    IPv6)
	                      *//* 43 (IPPROTO_ROUTING, Routing Header for IPv6) *//* 42 (Source Demand Routing Protocol) *//* 41 (IPPROTO_IPV6, IPv6 encapsulation) *//* 40 (IL Transport Protocol) *//* 39 (TP++ Transport Protocol) *//* 38 (IDPR Control Message Transport Proto) *//* 37 (Datagram Delivery Protocol) *//* 36 (Xpress Transfer Protocol) *//* 35 (Inter-Domain Policy Routing Protocol) *//* 34 (Third Party Connect Protocol) *//* 33 (IPPROTO_DCCP, Datagram Congestion
	                      *    Control Protocol)
	                      *//* 32 (MERIT Internodal Protocol) *//* 31 (MFE Network Services Protocol) *//* 30 (Bulk Data Transfer Protocol) *//* 29 (ISO Transport Protocol Class 4) *//* 28 (Internet Reliable Transaction) *//* 27 (Reliable Data Protocol) *//* 26 (Leaf-2) *//* 25 (Leaf-1) *//* 24 (Trunk-2) *//* 23 (Trunk-1) *//* 22 (XEROX NS IDP) *//* 21 (Packet Radio Measurement) *//* 20 (Host Monitoring) *//* 19 (DCN Measurement Subsystems) *//* 18 (Multiplexing) *//* 17 (IPPROTO_UDP, User Datagram) *//* 16 (Chaos) *//* 15 (Cross Net Debugger) *//* 14 (EMCON) *//* 13 (ARGUS) *//* 12 (PARC universal packet protocol) *//* 11 (Network Voice Protocol) *//* 10 (BBN RCC Monitoring) *//* 9 (IPPROTO_PIGP, "any private interior gateway
	                      *   (used by Cisco for their IGRP)")
	                      *//* 8 (IPPROTO_EGP, Exterior Gateway Protocol) *//* 7 (CBT) *//* 6 (IPPROTO_TCP, Transmission Control) *//* 5 (Stream, ST datagram mode) *//* 4 (IPPROTO_IPV4, IPv4 encapsulation) *//* 3 (Gateway-to-Gateway) *//* 2 (IPPROTO_IGMP, Internet Group Management) *//* 1 (IPPROTO_ICMP, Internet Control Message) *//* 0 (IPPROTO_HOPOPTS, IPv6 Hop-by-Hop Option) *//*
 * For completeness the number space in the array below comes from IANA:
 * https://www.iana.org/assignments/protocol-numbers/protocol-numbers.xhtml
 * However, the spelling tries to match that of /etc/protocols to achieve as
 * much consistency as possible with the previously implemented behaviour,
 * which was based on getprotobynumber (3).
 *//Users/owura/Repos/codeql_eval/proj_repos/the-tcpdump-group-tcpdump-commit-9ba91381954ad325ea4fd26b9c65a8bd9a2a85b6/tcpdump/l2vpn.hmpls_pw_types_valuesl2vpn_encaps_values/Users/owura/Repos/codeql_eval/proj_repos/the-tcpdump-group-tcpdump-commit-9ba91381954ad325ea4fd26b9c65a8bd9a2a85b6/tcpdump/l2vpn.c"l2vpn.h"const tok[28]tok[28]Frame Relay DLCI (Martini Mode)"Frame Relay DLCI (Martini Mode)"ATM AAL5 SDU VCC transport"ATM AAL5 SDU VCC transport"ATM transparent cell transport"ATM transparent cell transport"Ethernet VLAN"Ethernet VLAN"Ethernet"Ethernet"Cisco-HDLC"Cisco-HDLC"PPP"PPP"SONET/SDH Circuit Emulation Service over MPLS"SONET/SDH Circuit Emulation Service over MPLS"ATM n-to-one VCC cell transport"ATM n-to-one VCC cell transport"ATM n-to-one VPC cell transport"ATM n-to-one VPC cell transport"IP Layer2 Transport"IP Layer2 Transport"0x000cATM one-to-one VCC Cell Mode"ATM one-to-one VCC Cell Mode"0x000dATM one-to-one VPC Cell Mode"ATM one-to-one VPC Cell Mode"ATM AAL5 PDU VCC transport"ATM AAL5 PDU VCC transport"0x000fFrame-Relay Port mode"Frame-Relay Port mode"0x0010SONET/SDH Circuit Emulation over Packet"SONET/SDH Circuit Emulation over Packet"0x0011Structure-agnostic E1 over Packet"Structure-agnostic E1 over Packet"0x0012Structure-agnostic T1 (DS1) over Packet"Structure-agnostic T1 (DS1) over Packet"0x0013Structure-agnostic E3 over Packet"Structure-agnostic E3 over Packet"0x0014Structure-agnostic T3 (DS3) over Packet"Structure-agnostic T3 (DS3) over Packet"0x0015CESoPSN basic mode"CESoPSN basic mode"0x0016TDMoIP basic mode"TDMoIP basic mode"CESoPSN TDM with CAS"CESoPSN TDM with CAS"0x0018TDMoIP TDM with CAS"TDMoIP TDM with CAS"0x0019Frame Relay DLCI"Frame Relay DLCI"0x0040IP-interworking"IP-interworking"const tok[25]tok[25]Frame Relay"Frame Relay"Ethernet (VLAN) Tagged Mode"Ethernet (VLAN) Tagged Mode"Ethernet Raw Mode"Ethernet Raw Mode"Cisco HDLC"Cisco HDLC"IP layer 2 transport"IP layer 2 transport"Frame Relay Port mode"Frame Relay Port mode"Structure-agnostic E1 over packet"Structure-agnostic E1 over packet"Structure-agnostic T1 (DS1) over packet"Structure-agnostic T1 (DS1) over packet"Structure-agnostic T3 (DS3) over packet"Structure-agnostic T3 (DS3) over packet"Nx64kbit/s Basic Service using Structure-aware"Nx64kbit/s Basic Service using Structure-aware"Structure-agnostic E3 over packet"Structure-agnostic E3 over packet"Octet-aligned playload for Structure-agnostic DS1 circuits"Octet-aligned playload for Structure-agnostic DS1 circuits"char[59]E1 Nx64kbit/s with CAS using Structure-aware"E1 Nx64kbit/s with CAS using Structure-aware"DS1 (ESF) Nx64kbit/s with CAS using Structure-aware"DS1 (ESF) Nx64kbit/s with CAS using Structure-aware"char[52]DS1 (SF) Nx64kbit/s with CAS using Structure-aware"DS1 (SF) Nx64kbit/s with CAS using Structure-aware"/*
 * MPLS Pseudowire Types
 *
 * RFC 4446
 *
 * http://www.iana.org/assignments/pwe3-parameters/pwe3-parameters.xhtml#pwe3-parameters-2
 *//*
 * BGP Layer 2 Encapsulation Types
 *
 * RFC 6624
 *
 * http://www.iana.org/assignments/bgp-parameters/bgp-parameters.xhtml#bgp-l2-encapsulation-types-registry
 *//Users/owura/Repos/codeql_eval/proj_repos/the-tcpdump-group-tcpdump-commit-9ba91381954ad325ea4fd26b9c65a8bd9a2a85b6/tcpdump/machdep.h/Users/owura/Repos/codeql_eval/proj_repos/the-tcpdump-group-tcpdump-commit-9ba91381954ad325ea4fd26b9c65a8bd9a2a85b6/tcpdump/machdep.c"machdep.h"abort_on_misalignmentunusedHAVE___ATTRIBUTE____osf__!defined(HAVE_SNPRINTF)__ATTRIBUTE___FORMAT_OK_U___attribute__((unused))/*
 * On platforms where the CPU doesn't support unaligned loads, force
 * unaligned accesses to abort with SIGBUS, rather than being fixed
 * up (slowly) by the OS kernel; on those platforms, misaligned accesses
 * are bugs, and we want tcpdump to crash so that the bugs are reported.
 *
 * The only OS on which this is necessary is DEC OSF/1^W^WDigital
 * UNIX^W^WTru64 UNIX.
 *//* __osf__ *//* !defined(HAVE_SNPRINTF) *//* __ATTRIBUTE___FORMAT_OK *//* HAVE___ATTRIBUTE__ *//*
 * XXX - all we need, on platforms other than DEC OSF/1 (a/k/a Digital UNIX,
 * a/k/a Tru64 UNIX), is "size_t", which is a standard C type; what do we
 * need to do to get it defined?  This is clearly wrong, as we shouldn't
 * have to include UNIX or Windows system header files to get it.
 *//*
 * Copyright (c) 1996, 1997
 *	The Regents of the University of California.  All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that: (1) source code distributions
 * retain the above copyright notice and this paragraph in its entirety, (2)
 * distributions including binary code include the above copyright notice and
 * this paragraph in its entirety in the documentation or other materials
 * provided with the distribution, and (3) all advertising materials mentioning
 * features or use of this software display the following acknowledgement:
 * ``This product includes software developed by the University of California,
 * Lawrence Berkeley Laboratory and its contributors.'' Neither the name of
 * the University nor the names of its contributors may be used to endorse
 * or promote products derived from this software without specific prior
 * written permission.
 * THIS SOFTWARE IS PROVIDED ``AS IS'' AND WITHOUT ANY EXPRESS OR IMPLIED
 * WARRANTIES, INCLUDING, WITHOUT LIMITATION, THE IMPLIED WARRANTIES OF
 * MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE.
 */ebufebufsiz/Users/owura/Repos/codeql_eval/proj_repos/the-tcpdump-group-tcpdump-commit-9ba91381954ad325ea4fd26b9c65a8bd9a2a85b6/tcpdump/netdissect.cnd_smi_version_stringnd_load_smi_moduleerrbuferrbuf_size"MIB module %s not loaded: no libsmi support", moduleMIB module %s not loaded: no libsmi support(-1)nd_have_smi_supportnd_cleanupnd_init"", errbuf_size__builtin___strlcpy_chknd_smi_module_loadedUSE_LIBSMI/*
 * Indicates whether an SMI module has been loaded, so that we can use
 * libsmi to translate OIDs.
 *//*
	 * Undo the WSAStartup() call above.
	 *//*
	 * This appears, in libsmi 0.4.8, to do nothing if smiInit()
	 * wasn't done or failed, so we call it unconditionally.
	 *//*
 * Clean up anything that ndo_init() did.
 *//*
	 * Clears the error buffer, and uses it so we don't get
	 * "unused argument" warnings at compile time.
	 *//*
	 * XXX - should we just fail if this fails?  Some of the
	 * libsmi calls may fail.
	 *//*
	 * Request Winsock 2.2; we expect Winsock 2.
	 *//*
 * Initialize anything that must be initialized before dissecting
 * packets.
 *
 * This should be called at the beginning of the program; it does
 * not need to be called, and should not be called, for every
 * netdissect_options structure.
 *//*
 * Copyright (c) 1988-1997
 *	The Regents of the University of California.  All rights reserved.
 *
 * Copyright (c) 1998-2012  Michael Richardson <mcr@tcpdump.org>
 *      The TCPDUMP project
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that: (1) source code distributions
 * retain the above copyright notice and this paragraph in its entirety, (2)
 * distributions including binary code include the above copyright notice and
 * this paragraph in its entirety in the documentation or other materials
 * provided with the distribution, and (3) all advertising materials mentioning
 * features or use of this software display the following acknowledgement:
 * ``This product includes software developed by the University of California,
 * Lawrence Berkeley Laboratory and its contributors.'' Neither the name of
 * the University nor the names of its contributors may be used to endorse
 * or promote products derived from this software without specific prior
 * written permission.
 * THIS SOFTWARE IS PROVIDED ``AS IS'' AND WITHOUT ANY EXPRESS OR IMPLIED
 * WARRANTIES, INCLUDING, WITHOUT LIMITATION, THE IMPLIED WARRANTIES OF
 * MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE.
 */module/Users/owura/Repos/codeql_eval/proj_repos/the-tcpdump-group-tcpdump-commit-9ba91381954ad325ea4fd26b9c65a8bd9a2a85b6/tcpdump/nlpid.hNLPID_IP6NLPID_X25_ESIS0x8aNLPID_PPP0xcfNLPID_IP0xccNLPID_SPB0xc1NLPID_MFR0xb1NLPID_IDRP0x85NLPID_CONS0x84NLPID_ISIS0x83NLPID_ESIS0x82NLPID_CLNPNLPID_SNAPNLPID_LMI0x09NLPID_Q933NLPID_NULLNSnlpid_values/* IEEE 802.1aq/D4.5 *//* FRF.15 *//* iso9577 *//* The original, aka Cisco, aka Gang of Four *//* ANSI T1.617 Annex D or ITU-T Q.933 Annex A *//Users/owura/Repos/codeql_eval/proj_repos/the-tcpdump-group-tcpdump-commit-9ba91381954ad325ea4fd26b9c65a8bd9a2a85b6/tcpdump/nlpid.c"nlpid.h"const tok[16]tok[16]"NULL"Q.933"Q.933"LMI"LMI"SNAP"SNAP"CLNP"CLNP"ES-IS"ES-IS"IS-IS"IS-IS"CONS"CONS"IDRP"IDRP"ISIS_SPB"ISIS_SPB"FRF.15"FRF.15"204207X25 ES-IS"X25 ES-IS"/Users/owura/Repos/codeql_eval/proj_repos/the-tcpdump-group-tcpdump-commit-9ba91381954ad325ea4fd26b9c65a8bd9a2a85b6/tcpdump/oui.cconst tok[39]tok[39]IETF (reserved)"IETF (reserved)"ACC"ACC"Cisco"Cisco"Hewlett Packard"Hewlett Packard"Sun Microsystems"Sun Microsystems"Merit"Merit"Shiva"Shiva"Ericsson AB"Ericsson AB"Cisco VPN 5000"Cisco VPN 5000"Livingston"Livingston"Microsoft"Microsoft"3Com"3Com"Ascend"Ascend"Bay Networks"Bay Networks"Foundry"Foundry"Versanet"Versanet"Redback"Redback"Juniper Networks"Juniper Networks"Aptis"Aptis"Cisco VPN 3000"Cisco VPN 3000"CoSine Communications"CoSine Communications"Netscreen"Netscreen"Shasta"Shasta"Nomadix"Nomadix"Siemens"Siemens"CableLabs"CableLabs"Unisphere Networks"Unisphere Networks"Cisco BBSM"Cisco BBSM"3rd Generation Partnership Project 2 (3GPP2)"3rd Generation Partnership Project 2 (3GPP2)"ipUnplugged"ipUnplugged"Issanni Communications"Issanni Communications"Quintum"Quintum"Interlink"Interlink"Colubris"Colubris"Columbia University"Columbia University"3GPP"3GPP"Gemtek-Systems"Gemtek-Systems"Wi-Fi Alliance"Wi-Fi Alliance"IANA"IANA"Nortel Networks SONMP"Nortel Networks SONMP"248Cisco bridged"Cisco bridged"32962Ethernet bridged"Ethernet bridged"41022ATM Forum"ATM Forum"57391DOCSIS Spanning Tree"DOCSIS Spanning Tree"52429536969Juniper"Juniper"524297Hewlett-Packard"Hewlett-Packard"IEEE 802.1 Private"IEEE 802.1 Private"4623IEEE 802.3 Private"IEEE 802.3 Private"4795ANSI/TIA"ANSI/TIA"6945DCBX"DCBX"8992Nicira Networks"Nicira Networks"6035143Big Switch Networks"Big Switch Networks"11588341Vello Systems"Vello Systems"9345HP"HP"1258HP-Labs"HP-Labs"7636849Infoblox Inc"Infoblox Inc"10756869Open Networking Lab"Open Networking Lab"1183Freescale"Freescale"5549Netronome"Netronome"/*
 * SMI Network Management Private Enterprise Codes for organizations.
 *
 * XXX - these also appear in FreeRadius dictionary files, with items such
 * as
 *
 *	VENDOR          Cisco           9
 *
 * List taken from Ethereal's epan/sminmpec.c.
 *//* FIXME complete OUI list using a script *//Users/owura/Repos/codeql_eval/proj_repos/the-tcpdump-group-tcpdump-commit-9ba91381954ad325ea4fd26b9c65a8bd9a2a85b6/tcpdump/nfsfh.hmy_fsidmy_devtfsid_codechar[65]2 * 322 * 32 + 1Opaque_HandleFsid_devMajorMinorfsid_eq(a,b)((a.fsid_code == b.fsid_code) && dev_eq(a.Fsid_dev, b.Fsid_dev))dev_eq(a,b)((a.Minor == b.Minor) && (a.Major == b.Major))Parse_fhmy_fsid *struct <unnamed> */* XXX avoid name conflict with AIX *//*
 * Many file servers now use a large file system ID.  This is
 * our internal representation of that.
 *//* upper case to avoid clashing with macro names *//*
 * Internal representation of dev_t, because different NFS servers
 * that we might be spying upon use different external representations.
 *//*
 * nfsfh.h - NFS file handle definitions (for portable use)
 *
 * Jeffrey C. Mogul
 * Digital Equipment Corporation
 * Western Research Laboratory
 *//*
 * Copyright (c) 1993, 1994 Jeffrey C. Mogul, Digital Equipment Corporation,
 * Western Research Laboratory. All rights reserved.
 * Copyright (c) 2001 Compaq Computer Corporation. All rights reserved.
 *
 *  Permission to use, copy, and modify this software and its
 *  documentation is hereby granted only under the following terms and
 *  conditions.  Both the above copyright notice and this permission
 *  notice must appear in all copies of the software, derivative works
 *  or modified versions, and any portions thereof, and both notices
 *  must appear in supporting documentation.
 *
 *  Redistribution and use in source and binary forms, with or without
 *  modification, are permitted provided that the following conditions
 *  are met:
 *    1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 *    2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in
 *    the documentation and/or other materials provided with the
 *    distribution.
 *
 *  THE SOFTWARE IS PROVIDED "AS IS" AND COMPAQ COMPUTER CORPORATION
 *  DISCLAIMS ALL WARRANTIES WITH REGARD TO THIS SOFTWARE, INCLUDING
 *  ALL IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS.   IN NO
 *  EVENT SHALL COMPAQ COMPUTER CORPORATION BE LIABLE FOR ANY
 *  SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
 *  WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN
 *  AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING
 *  OUT OF OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS
 *  SOFTWARE.
 *//Users/owura/Repos/codeql_eval/proj_repos/the-tcpdump-group-tcpdump-commit-9ba91381954ad325ea4fd26b9c65a8bd9a2a85b6/tcpdump/parsenfsfh.c"nfsfh.h"is_UCXseen_null28/4fhp[i](1)fhptempfhtype FHT_UNKNOWN16/4FHT_UNKNOWNFHT_AUSPEXFHT_DECOSFFHT_IRIX4FHT_SUNOS4FHT_BSD4424/4FHT_ULTRIXFHT_SUNOS5FHT_HPUX9FHT_VMSUCXfhp[12]fhp[13]fhp[14]fhp[15]fhp[7]fhp[6]fhp[5]fhp[4]fhp[3]fhp[2]fhp[1]fhp[0]fhp[8]fhp[9]fhp[10]fhp[11](char *)fsidp0, sizeof(*fsidp)(const char *)fh, 14(char *)tempa0, sizeof(tempa)fhp[26]fhp[27]fhp[23]fhp[22]&(fsidp->Opaque_Handle[i*2])"%.2X", fhp[i]Auspex"Auspex"BSD 4.4"BSD 4.4"10485750xFFFFF0xFFFOSF"OSF"IRIX4"IRIX4"FHT_IRIX5fhfsidpinoposnamepfsnamepourselfIRIX5"IRIX5"SUNOS4"SUNOS4"163830x3FFF2621430x3FFFFSUNOS5"SUNOS5"Ultrix"Ultrix"sizeof(*fsidp)sizeof(*fsidp) >= 14sizeof(*fsidp) > 14uint32_t[4]unsigned int[4]tempaVMS"VMS"FHT_AIX32AIX32"AIX32"HPUX9"HPUX9"sizeof(fsidp->Opaque_Handle)sizeof(fsidp->Opaque_Handle) - 1%.2X257make_uint48(msb,b,c,d,e,lsb)((lsb) + ((e)<<8) + ((d)<<16) + ((c)<<24))make_uint16(msb,lsb)(XFF(lsb) + (XFF(msb)<<8))make_uint24(msb,b,lsb)(XFF(lsb) + (XFF(b)<<8) + (XFF(msb)<<16))make_uint32(msb,b,c,lsb)(XFF(lsb) + (XFF(c)<<8) + (XFF(b)<<16) + (XFF(msb)<<24))XFF(x)(x)FHT_SUNOS3ultrix__alphadefined(IRIX40)defined(IRIX50)defined(IRIX51)defined(SUNOS4)defined(SUNOS5)defined(ultrix)defined(__osf__)defined(__NetBSD__) || defined(__FreeBSD__) || defined(__DragonFly__) \notdefDEBUG/*
	 * Require at least 28 bytes of file handle; it's variable-length
	 * in NFSv3.  "len" is in units of 32-bit words, not bytes.
	 *//*
 * Is this a VMS UCX file handle?
 *	Check for:
 *	(1) leading code byte	[XXX not yet]
 *	(2) followed by string of printing chars & spaces
 *	(3) followed by string of nulls
 *//* display will show this string instead of (257,257) *//* XXX for now, give "bogus" values to aid debugging *//* Save the actual handle, so it can be display with -u *//* XXX debugging *//* Caller must save (and null-terminate?) this value *//* VMS file ID is: (RVN, FidHi, FidLo) *//* ensure alignment *//* at least 16 bytes, maybe more *//* just use the whole thing *//* No numeric file system ID, so hash on the device-name *//*
	     * XXX - none of the heuristics above return this.
	     * Are there any SunOS 3.x systems around to care about?
	     *//* XXX could ignore 3 high-order bytes *//* XXX still needs to handle SUNOS3 *//* or maybe IRIX5 *//*
				 * XXX Could be SUNOS5/IRIX5 or AIX.  I don't
				 * XXX see any way to disambiguate these, so
				 * XXX I'm going with the more likely guess.
				 * XXX Sorry, Big Blue.
				 *//* This would be MNT_NFS on AIX, which is impossible *//* XXX is this always true of HP-UX? *//* could be SUNOS5/IRIX5, AIX, HP-UX *//*
			 * bytes[2,3] != (0,0); rules out Ultrix, could be
			 * DECOSF, SUNOS5, IRIX5, AIX, HP-UX, or UCX
			 *//* XXX what about AIX? *//* XXX no obvious difference between SUNOS5 and IRIX5 *//* Could be SUNOS5/IRIX5, maybe AIX *//*XXX we probably only need to test of these two bytes *//*
			 * bytes[2,3] == (0,0); rules out OSF, probably not UCX
			 * (unless the exported device name is just one letter!),
			 * could be Ultrix, IRIX5, AIX, or SUNOS5
			 * might be HP-UX (depends on their values for minor devs)
			 *//*
		     * bytes[0,1] != (0,0); rules out Auspex, IRIX4, SUNOS4
		     * could be IRIX5, DECOSF, UCX, Ultrix, SUNOS5
		     * could be AIX, HP-UX
		     *//* by elimination *//* looks like a length, not a file system typecode *//* XXX the test of fhp[5] == 8 could be wrong *//* could be SUNOS4 or IRIX4 *//* seems to be DECOSF, with minor == 0 *//*
			 * bytes[2,3] != (0,0); rules out Auspex, could be
			 * DECOSF, SUNOS4, or IRIX4
			 *//* XXX or could be Ultrix+MASSBUS "hp" disk? *//* bytes[2,3] == (0,0); must be Auspex *//* probably rules out HP-UX, AIX unless they allow major=0 *//* bytes[0,1] == (0,0); rules out Ultrix, IRIX5, SUNOS5 *//*
		 * This is basically a big decision tree
		 *//* File handle generated on this host, no need for guessing *//*
	 * Require at least 16 bytes of file handle; it's variable-length
	 * in NFSv3.  "len" is in units of 32-bit words, not bytes.
	 *//* true if file handle was generated on this host *//* if non-NULL, return server fs name here (for VMS) *//* if non-NULL, return OS name here *//* on 32-bit systems ignore high-order bits *//* or other 64-bit systems *//* Nasty hack to keep the Ultrix C compiler from emitting bogus warnings *//*
 * This routine attempts to parse a file handle (in network byte order),
 * using heuristics to guess what kind of format it is in.  See the
 * file "fhandle_layouts" for a detailed description of the various
 * patterns we know about.
 *
 * The file handle is parsed into our internal representation of a
 * file-system id, and an internal representation of an inode-number.
 *//*
 * parsenfsfh.c - portable parser for NFS file handles
 *			uses all sorts of heuristics
 *
 * Jeffrey C. Mogul
 * Digital Equipment Corporation
 * Western Research Laboratory
 *//Users/owura/Repos/codeql_eval/proj_repos/the-tcpdump-group-tcpdump-commit-9ba91381954ad325ea4fd26b9c65a8bd9a2a85b6/tcpdump/print-802_11.cieee802_11_radio_avs_if_printconst pcap_pkthdrconst pcap_pkthdr *pcap_pkthdr *ieee802_11_radio_if_printprism_if_printcaplenmsgcode(ndo, "%s", tstr)%sconst char[10]2149650433WLANCAP_MAGIC_COOKIE_V12149650434WLANCAP_MAGIC_COOKIE_V2PRISM_HDR_LENieee802_11_avs_radio_printcaphdr_lenp + 4ieee802_11_radio_printcpackerconst ieee80211_radiotap_headerconst ieee80211_radiotap_header *ieee80211_radiotap_header *hdrpresentflagsconst uint32_tconst uint32_t *presentplast_presentpvendor_namespaceuint8_t[3]unsigned char[3]vendor_ouivendor_subnamespaceskip_lengthbit0flagspadfcslensizeof(*hdr)&hdr->it_lenIEEE80211_RADIOTAP_EXT2147483648sizeof(hdr->it_present)0, 3IEEE80211_RADIOTAP_NAMESPACEIEEE80211_RADIOTAP_VENDOR_NAMESPACE536870912hBIT(IEEE80211_RADIOTAP_NAMESPACE)1073741824BIT(IEEE80211_RADIOTAP_VENDOR_NAMESPACE)1610612736BIT(IEEE80211_RADIOTAP_NAMESPACE)|BIT(IEEE80211_RADIOTAP_VENDOR_NAMESPACE)(BIT(IEEE80211_RADIOTAP_NAMESPACE)|BIT(IEEE80211_RADIOTAP_VENDOR_NAMESPACE))IEEE80211_RADIOTAP_F_DATAPADIEEE80211_RADIOTAP_F_FCSprint_in_radiotap_namespacepresentnext_presentbitnobitrcpresent ^ next_present(present ^ next_present) >> 16((present ^ next_present) >> 16) >> 8(((present ^ next_present) >> 16) >> 8) >> 4((((present ^ next_present) >> 16) >> 8) >> 4) >> 2((((present ^ next_present) >> 16) >> 8) >> 4)(((present ^ next_present) >> 16) >> 8)((((present ^ next_present) >> 16) >> 8)) >> 2((((present ^ next_present) >> 16) >> 8))((present ^ next_present) >> 16)(((present ^ next_present) >> 16)) >> 4((((present ^ next_present) >> 16)) >> 4) >> 2((((present ^ next_present) >> 16)) >> 4)(((present ^ next_present) >> 16))((((present ^ next_present) >> 16))) >> 2((((present ^ next_present) >> 16)))(present ^ next_present)((present ^ next_present)) >> 8(((present ^ next_present)) >> 8) >> 4((((present ^ next_present)) >> 8) >> 4) >> 2((((present ^ next_present)) >> 8) >> 4)(((present ^ next_present)) >> 8)((((present ^ next_present)) >> 8)) >> 2((((present ^ next_present)) >> 8))((present ^ next_present))(((present ^ next_present))) >> 4((((present ^ next_present))) >> 4) >> 2((((present ^ next_present))) >> 4)(((present ^ next_present)))((((present ^ next_present)))) >> 2((((present ^ next_present))))print_radiotap_field(ndo, "%" PRIu64 "us tsft ", tsft)(ndo, "%" "ll" "u" "us tsft ", tsft)(ndo, "cfp ")(ndo, "short preamble ")(ndo, "wep ")(ndo, "fragmented ")(ndo, "bad-fcs ")(ndo, "MCS %u ", rate & 0x7f)(ndo, "%2.1f Mb/s ", .5 * rate)(ndo, "fhset %d fhpat %d ", hopset, hoppat)&dbm_antsignal(ndo, "%ddBm signal ", dbm_antsignal)&dbm_antnoise(ndo, "%ddBm noise ", dbm_antnoise)(ndo, "%u sq ", lock_quality)(ndo, "%d tx power ", -(int)tx_attenuation)(ndo, "%ddB tx attenuation ", -(int)db_tx_attenuation)&dbm_tx_power(ndo, "%ddBm tx power ", dbm_tx_power)(ndo, "antenna %u ", antenna)(ndo, "%ddB signal ", db_antsignal)(ndo, "%ddB noise ", db_antnoise)(ndo, "%.1f Mb/s MCS %u ", htrate, mcs_index)(ndo, "MCS %u ", mcs_index)(ndo, "%s ", ht_bandwidth[flags & IEEE80211_RADIOTAP_MCS_BANDWIDTH_MASK])(ndo, "%s ", ht_bandwidth[flags & 0x03])(ndo, "%s GI ", (flags & IEEE80211_RADIOTAP_MCS_SHORT_GI) ? "short" : "long")(ndo, "%s GI ", (flags & 0x04) ? "short" : "long")(ndo, "%s ", (flags & IEEE80211_RADIOTAP_MCS_HT_GREENFIELD) ? "greenfield" : "mixed")(ndo, "%s ", (flags & 0x08) ? "greenfield" : "mixed")(ndo, "%s FEC ", (flags & IEEE80211_RADIOTAP_MCS_FEC_LDPC) ? "LDPC" : "BCC")(ndo, "%s FEC ", (flags & 0x10) ? "LDPC" : "BCC")(ndo, "RX-STBC%u ", (flags & IEEE80211_RADIOTAP_MCS_STBC_MASK) >> IEEE80211_RADIOTAP_MCS_STBC_SHIFT)(ndo, "RX-STBC%u ", (flags & 0x60) >> 5)(ndo, "User %u MCS %u ", i, mcs)(ndo, "%s FEC ", (coding & (IEEE80211_RADIOTAP_CODING_LDPC_USERn << i)) ? "LDPC" : "BCC")(ndo, "%s FEC ", (coding & (0x01 << i)) ? "LDPC" : "BCC")(ndo, "%s ", vht_bandwidth[bandwidth & IEEE80211_RADIOTAP_VHT_BANDWIDTH_MASK])(ndo, "%s ", vht_bandwidth[bandwidth & 0x1f])(ndo, "%s GI ", (flags & IEEE80211_RADIOTAP_VHT_SHORT_GI) ? "short" : "long")(ndo, "[bit %u] ", bit)IEEE80211_RADIOTAP_TSFTtsft%lluus tsft IEEE80211_RADIOTAP_FLAGSflagsvalIEEE80211_RADIOTAP_F_CFPcfp IEEE80211_RADIOTAP_F_SHORTPREshort preamble IEEE80211_RADIOTAP_F_WEPwep IEEE80211_RADIOTAP_F_FRAGfragmented IEEE80211_RADIOTAP_F_BADFCSbad-fcs IEEE80211_RADIOTAP_RATErate0x8fMCS %u %2.1f Mb/s 0.5IEEE80211_RADIOTAP_CHANNELfrequencyIEEE80211_RADIOTAP_XCHANNEL2621441 << IEEE80211_RADIOTAP_XCHANNEL(1 << IEEE80211_RADIOTAP_XCHANNEL)IEEE80211_RADIOTAP_FHSShopsethoppatfhset %d fhpat %d IEEE80211_RADIOTAP_DBM_ANTSIGNALdbm_antsignalint8_t *signed char *%ddBm signal IEEE80211_RADIOTAP_DBM_ANTNOISEdbm_antnoise%ddBm noise IEEE80211_RADIOTAP_LOCK_QUALITYlock_quality%u sq IEEE80211_RADIOTAP_TX_ATTENUATIONtx_attenuation%d tx power IEEE80211_RADIOTAP_DB_TX_ATTENUATIONdb_tx_attenuation%ddB tx attenuation IEEE80211_RADIOTAP_DBM_TX_POWERdbm_tx_power%ddBm tx power IEEE80211_RADIOTAP_ANTENNAantennaantenna %u IEEE80211_RADIOTAP_DB_ANTSIGNALdb_antsignal%ddB signal IEEE80211_RADIOTAP_DB_ANTNOISEdb_antnoise%ddB noise IEEE80211_RADIOTAP_RX_FLAGSrx_flagschannelmaxpowerIEEE80211_RADIOTAP_MCSconst char *[4]char *[4]20 MHz"20 MHz"40 MHz"40 MHz"20 MHz (L)"20 MHz (L)"20 MHz (U)"20 MHz (U)"ht_bandwidthknownmcs_indexhtrateIEEE80211_RADIOTAP_MCS_MCS_INDEX_KNOWNflagspMAX_MCS_INDEXIEEE80211_RADIOTAP_MCS_BANDWIDTH_KNOWNIEEE80211_RADIOTAP_MCS_GUARD_INTERVAL_KNOWN(IEEE80211_RADIOTAP_MCS_BANDWIDTH_KNOWN|IEEE80211_RADIOTAP_MCS_GUARD_INTERVAL_KNOWN)const floatconst float[2]float[2]const float[2][2]float[2][2]const float[77][2][2]float[77][2][2]const float(*)[2][2]float(*)[2][2]const float(*)[2]float(*)[2]IEEE80211_RADIOTAP_MCS_BANDWIDTH_MASKIEEE80211_RADIOTAP_MCS_BANDWIDTH_40const float *float *IEEE80211_RADIOTAP_MCS_SHORT_GI0.0%.1f Mb/s MCS %u %s %s GI shortlongIEEE80211_RADIOTAP_MCS_HT_FORMAT_KNOWNgreenfieldmixedIEEE80211_RADIOTAP_MCS_FEC_TYPE_KNOWN%s FEC LDPCBCCIEEE80211_RADIOTAP_MCS_STBC_KNOWNRX-STBC%u IEEE80211_RADIOTAP_AMPDU_STATUSreference_numdelim_crcIEEE80211_RADIOTAP_VHTconst char *[32]char *[32]80 MHz"80 MHz"80 MHz (L)"80 MHz (L)"80 MHz (U)"80 MHz (U)"80 MHz (LL)"80 MHz (LL)"80 MHz (LU)"80 MHz (LU)"80 MHz (UL)"80 MHz (UL)"80 MHz (UU)"80 MHz (UU)"160 MHz"160 MHz"160 MHz (L)"160 MHz (L)"160 MHz (U)"160 MHz (U)"160 MHz (LL)"160 MHz (LL)"160 MHz (LU)"160 MHz (LU)"160 MHz (UL)"160 MHz (UL)"160 MHz (UU)"160 MHz (UU)"160 MHz (LLL)"160 MHz (LLL)"160 MHz (LLU)"160 MHz (LLU)"160 MHz (LUL)"160 MHz (LUL)"160 MHz (UUU)"160 MHz (UUU)"160 MHz (ULL)"160 MHz (ULL)"160 MHz (ULU)"160 MHz (ULU)"160 MHz (UUL)"160 MHz (UUL)"unknown (26)"unknown (26)"unknown (27)"unknown (27)"unknown (28)"unknown (28)"unknown (29)"unknown (29)"unknown (30)"unknown (30)"unknown (31)"unknown (31)"vht_bandwidthbandwidthuint8_t[4]unsigned char[4]mcs_nsscodinggroup_idpartial_aidnssmcsIEEE80211_RADIOTAP_VHT_NSS_MASK240IEEE80211_RADIOTAP_VHT_MCS_MASKIEEE80211_RADIOTAP_VHT_MCS_SHIFTUser %u MCS %u IEEE80211_RADIOTAP_VHT_BANDWIDTH_KNOWNIEEE80211_RADIOTAP_VHT_GUARD_INTERVAL_KNOWN[bit %u] truncprint_chaninfo(ndo, "%u MHz", freq)%u MHz(ndo, " 11n")(ndo, " FHSS")(ndo, " 11a/10Mhz")(ndo, " 11a/5Mhz")(ndo, " 11a")(ndo, " 11g/10Mhz")(ndo, " 11g/5Mhz")(ndo, " 11g")(ndo, " 11b")(ndo, " Turbo")5242881 << IEEE80211_RADIOTAP_MCS(1 << IEEE80211_RADIOTAP_MCS) 11n FHSS32016384IEEE80211_CHAN_HALF 11a/10Mhz32768IEEE80211_CHAN_QUARTER 11a/5Mhz 11a1921152 11g/10Mhz 11g/5Mhz 11g 11bIEEE80211_CHAN_TURBO Turbo(ndo, " ht/20")(ndo, " ht/40-")(ndo, " ht/40+")65536IEEE80211_CHAN_HT20 ht/20IEEE80211_CHAN_HT40D ht/40-131072IEEE80211_CHAN_HT40U ht/40+(ndo, " ") ieee802_11_if_printieee802_11_printhdrlenmeshdrlenllc_hdrlenIEEE802_11_FC_LEN-44294967292FC_SUBTYPE(fc)(((fc) >> 4) & 0xF)T_DATA(ndo, "Data")T_MGMTconst uint8_t **unsigned char **const u_char **freqorig_caplenT_CTRLDataconst lladdr_infoconst lladdr_info *lladdr_info *ieee_802_11_hdr_print(ndo, "More Data ")(ndo, "More Fragments ")(ndo, "Pwr Mgmt ")(ndo, "Retry ")(ndo, "Strictly Ordered ")(ndo, "Protected ")(ndo, "%dus ", EXTRACT_LE_16BITS( &((const struct mgmt_header_t *)p)->duration))(ndo, "%dus ", ((uint16_t)(((uint16_t)(*((const uint8_t *)(&((const struct mgmt_header_t *)p)->duration) + 1)) << 8) | ((uint16_t)(*((const uint8_t *)(&((const struct mgmt_header_t *)p)->duration) + 0)) << 0))))&((const struct mgmt_header_t *)p)->duration8192More Data More Fragments Pwr Mgmt Retry Strictly Ordered Protected CTRL_PS_POLL%dus const mgmt_header_tconst mgmt_header_t *mgmt_header_t *(ndo, "MeshData (AE %d TTL %u seq %u", ae, mc->ttl, EXTRACT_LE_32BITS(mc->seq))(ndo, "MeshData (AE %d TTL %u seq %u", ae, mc->ttl, ((uint32_t)(((uint32_t)(*((const uint8_t *)(mc->seq) + 3)) << 24) | ((uint32_t)(*((const uint8_t *)(mc->seq) + 2)) << 16) | ((uint32_t)(*((const uint8_t *)(mc->seq) + 1)) << 8) | ((uint32_t)(*((const uint8_t *)(mc->seq) + 0)) << 0))))mc->seq(ndo, " A4:%s", etheraddr_string(ndo, mc->addr4))(ndo, " A5:%s", etheraddr_string(ndo, mc->addr5))(ndo, " A6:%s", etheraddr_string(ndo, mc->addr6))(ndo, ") ")const meshcntl_tconst meshcntl_t *meshcntl_t *mcaeMeshData (AE %d TTL %u seq %u A4:%suint8_t[6] A5:%s A6:%s) extract_mesh_header_length~ 3extract_header_length(ndo, "unknown 802.11 ctrl frame subtype (%d)", FC_SUBTYPE(fc))(ndo, "unknown 802.11 ctrl frame subtype (%d)", (((fc) >> 4) & 0xF))(ndo, "unknown 802.11 frame type (%d)", FC_TYPE(fc))(ndo, "unknown 802.11 frame type (%d)", (((fc) >> 2) & 0x3))MGMT_HDRLENCTRL_CONTROL_WRAPPERCTRL_CONTROL_WRAPPER_HDRLENCTRL_BARCTRL_BAR_HDRLENCTRL_BACTRL_BA_HDRLENCTRL_PS_POLL_HDRLENCTRL_RTSCTRL_RTS_HDRLENCTRL_CTSCTRL_CTS_HDRLENCTRL_ACKCTRL_ACK_HDRLENCTRL_CF_ENDCTRL_END_HDRLENCTRL_END_ACKCTRL_END_ACK_HDRLENunknown 802.11 ctrl frame subtype (%d)char[39]unknown 802.11 frame type (%d)ctrl_header_print(ndo, " RA:%s TA:%s CTL(%x) SEQ(%u) ", etheraddr_string(ndo, ((const struct ctrl_bar_hdr_t *)p)->ra), etheraddr_string(ndo, ((const struct ctrl_bar_hdr_t *)p)->ta), EXTRACT_LE_16BITS(&(((const struct ctrl_bar_hdr_t *)p)->ctl)), EXTRACT_LE_16BITS(&(((const struct ctrl_bar_hdr_t *)p)->seq)))(ndo, " RA:%s TA:%s CTL(%x) SEQ(%u) ", etheraddr_string(ndo, ((const struct ctrl_bar_hdr_t *)p)->ra), etheraddr_string(ndo, ((const struct ctrl_bar_hdr_t *)p)->ta), ((uint16_t)(((uint16_t)(*((const uint8_t *)(&(((const struct ctrl_bar_hdr_t *)p)->ctl)) + 1)) << 8) | ((uint16_t)(*((const uint8_t *)(&(((const struct ctrl_bar_hdr_t *)p)->ctl)) + 0)) << 0))), ((uint16_t)(((uint16_t)(*((const uint8_t *)(&(((const struct ctrl_bar_hdr_t *)p)->seq)) + 1)) << 8) | ((uint16_t)(*((const uint8_t *)(&(((const struct ctrl_bar_hdr_t *)p)->seq)) + 0)) << 0))))&(((const struct ctrl_bar_hdr_t *)p)->ctl)&(((const struct ctrl_bar_hdr_t *)p)->seq)(ndo, "RA:%s ", etheraddr_string(ndo, ((const struct ctrl_ba_hdr_t *)p)->ra))(ndo, "BSSID:%s TA:%s ", etheraddr_string(ndo, ((const struct ctrl_ps_poll_hdr_t *)p)->bssid), etheraddr_string(ndo, ((const struct ctrl_ps_poll_hdr_t *)p)->ta))(ndo, "RA:%s TA:%s ", etheraddr_string(ndo, ((const struct ctrl_rts_hdr_t *)p)->ra), etheraddr_string(ndo, ((const struct ctrl_rts_hdr_t *)p)->ta))(ndo, "RA:%s ", etheraddr_string(ndo, ((const struct ctrl_cts_hdr_t *)p)->ra))(ndo, "RA:%s ", etheraddr_string(ndo, ((const struct ctrl_ack_hdr_t *)p)->ra))(ndo, "RA:%s BSSID:%s ", etheraddr_string(ndo, ((const struct ctrl_end_hdr_t *)p)->ra), etheraddr_string(ndo, ((const struct ctrl_end_hdr_t *)p)->bssid))(ndo, "RA:%s BSSID:%s ", etheraddr_string(ndo, ((const struct ctrl_end_ack_hdr_t *)p)->ra), etheraddr_string(ndo, ((const struct ctrl_end_ack_hdr_t *)p)->bssid)) RA:%s TA:%s CTL(%x) SEQ(%u) const ctrl_bar_hdr_tconst ctrl_bar_hdr_t *ctrl_bar_hdr_t *IEEE802_11_RA_LENIEEE802_11_TA_LENRA:%s const ctrl_ba_hdr_tconst ctrl_ba_hdr_t *ctrl_ba_hdr_t *BSSID:%s TA:%s const ctrl_ps_poll_hdr_tconst ctrl_ps_poll_hdr_t *ctrl_ps_poll_hdr_t *IEEE802_11_BSSID_LENRA:%s TA:%s const ctrl_rts_hdr_tconst ctrl_rts_hdr_t *ctrl_rts_hdr_t *const ctrl_cts_hdr_tconst ctrl_cts_hdr_t *ctrl_cts_hdr_t *const ctrl_ack_hdr_tconst ctrl_ack_hdr_t *ctrl_ack_hdr_t *RA:%s BSSID:%s const ctrl_end_hdr_tconst ctrl_end_hdr_t *ctrl_end_hdr_t *const ctrl_end_ack_hdr_tconst ctrl_end_ack_hdr_t *ctrl_end_ack_hdr_t *mgmt_header_print(ndo, "BSSID:%s DA:%s SA:%s ", etheraddr_string(ndo, (hp)->bssid), etheraddr_string(ndo, (hp)->da), etheraddr_string(ndo, (hp)->sa))BSSID:%s DA:%s SA:%s IEEE802_11_DA_LENIEEE802_11_SA_LENdata_header_printsubtype(ndo, "CF ")(ndo, "Ack/Poll")(ndo, "Ack")(ndo, "Poll")(ndo, "+QoS")CF Ack/PollAckPoll+QoS(ndo, "DA:%s SA:%s BSSID:%s ", etheraddr_string(ndo, ADDR1), etheraddr_string(ndo, ADDR2), etheraddr_string(ndo, ADDR3))(ndo, "DA:%s SA:%s BSSID:%s ", etheraddr_string(ndo, (p + 4)), etheraddr_string(ndo, (p + 10)), etheraddr_string(ndo, (p + 16)))(ndo, "DA:%s BSSID:%s SA:%s ", etheraddr_string(ndo, ADDR1), etheraddr_string(ndo, ADDR2), etheraddr_string(ndo, ADDR3))(ndo, "DA:%s BSSID:%s SA:%s ", etheraddr_string(ndo, (p + 4)), etheraddr_string(ndo, (p + 10)), etheraddr_string(ndo, (p + 16)))(ndo, "BSSID:%s SA:%s DA:%s ", etheraddr_string(ndo, ADDR1), etheraddr_string(ndo, ADDR2), etheraddr_string(ndo, ADDR3))(ndo, "BSSID:%s SA:%s DA:%s ", etheraddr_string(ndo, (p + 4)), etheraddr_string(ndo, (p + 10)), etheraddr_string(ndo, (p + 16)))(ndo, "RA:%s TA:%s DA:%s SA:%s ", etheraddr_string(ndo, ADDR1), etheraddr_string(ndo, ADDR2), etheraddr_string(ndo, ADDR3), etheraddr_string(ndo, ADDR4))(ndo, "RA:%s TA:%s DA:%s SA:%s ", etheraddr_string(ndo, (p + 4)), etheraddr_string(ndo, (p + 10)), etheraddr_string(ndo, (p + 16)), etheraddr_string(ndo, (p + 24)))DA:%s SA:%s BSSID:%s DA:%s BSSID:%s SA:%s BSSID:%s SA:%s DA:%s RA:%s TA:%s DA:%s SA:%s get_mgmt_src_dst_macget_data_src_dst_macctrl_body_print(ndo, "%s", tok2str(ctrl_str, "Unknown Ctrl Subtype", FC_SUBTYPE(fc)))(ndo, "%s", tok2str(ctrl_str, "Unknown Ctrl Subtype", (((fc) >> 4) & 0xF)))const tok[10]tok[10]Unknown Ctrl Subtype*p(2+2+ 6+6+ 2+2)(2+2+6)(ndo, " RA:%s ", etheraddr_string(ndo, ((const struct ctrl_ba_hdr_t *)p)->ra))(2+2+ 6+6)(ndo, " AID(%x)", EXTRACT_LE_16BITS(&(((const struct ctrl_ps_poll_hdr_t *)p)->aid)))(ndo, " AID(%x)", ((uint16_t)(((uint16_t)(*((const uint8_t *)(&(((const struct ctrl_ps_poll_hdr_t *)p)->aid)) + 1)) << 8) | ((uint16_t)(*((const uint8_t *)(&(((const struct ctrl_ps_poll_hdr_t *)p)->aid)) + 0)) << 0))))&(((const struct ctrl_ps_poll_hdr_t *)p)->aid)(ndo, " TA:%s ", etheraddr_string(ndo, ((const struct ctrl_rts_hdr_t *)p)->ta))(ndo, " RA:%s ", etheraddr_string(ndo, ((const struct ctrl_cts_hdr_t *)p)->ra))(ndo, " RA:%s ", etheraddr_string(ndo, ((const struct ctrl_ack_hdr_t *)p)->ra))(ndo, " RA:%s ", etheraddr_string(ndo, ((const struct ctrl_end_hdr_t *)p)->ra))(ndo, " RA:%s ", etheraddr_string(ndo, ((const struct ctrl_end_ack_hdr_t *)p)->ra)) RA:%s  AID(%x) TA:%s srcpdstpmgmt_body_print(ndo, "%s", tok2str(st_str, "Unhandled Management subtype(%x)", FC_SUBTYPE(fc)))(ndo, "%s", tok2str(st_str, "Unhandled Management subtype(%x)", (((fc) >> 4) & 0xF)))const tok[13]tok[13]Unhandled Management subtype(%x)ST_ASSOC_REQUESTST_ASSOC_RESPONSEST_REASSOC_REQUESTST_REASSOC_RESPONSEST_PROBE_REQUESTST_PROBE_RESPONSEST_BEACONST_ATIMST_DISASSOCST_AUTHST_DEAUTHST_ACTIONhandle_action(ndo, ": ")(ndo, " (%s): ", etheraddr_string(ndo, src)):  (%s): (ndo, "Spectrum Management Act#%d", p[1])(ndo, "QoS Act#%d", p[1])(ndo, "DLS Act#%d", p[1])(ndo, "BA ")p[1](ndo, "ADDBA Request")(ndo, "ADDBA Response")(ndo, "DELBA")(ndo, "Act#%d", (p[1]))(ndo, "HT ")(ndo, "TxChWidth")(ndo, "MIMOPwrSave")(ndo, "MeshAction ")(ndo, "MeshLink")(ndo, "HWMP")(ndo, "Gate Announcement")(ndo, "Congestion Control")(ndo, "MCCA Setup Request")(ndo, "MCCA Setup Reply")(ndo, "MCCA Advertisement Request")(ndo, "MCCA Advertisement")(ndo, "MCCA Teardown")(ndo, "TBTT Adjustment Request")(ndo, "TBTT Adjustment Response")(ndo, "MultiohopAction ")(ndo, "Proxy Update")(ndo, "Proxy Update Confirmation")(ndo, "SelfprotectAction ")(ndo, "Peering Open")(ndo, "Peering Confirm")(ndo, "Peering Close")(ndo, "Group Key Inform")(ndo, "Group Key Acknowledge")(ndo, "Vendor Act#%d", p[1])(ndo, "Reserved(%d) Act#%d", p[0], p[1])Spectrum Management Act#%dQoS Act#%dDLS Act#%dBA ADDBA RequestADDBA ResponseDELBAAct#%dHT TxChWidthMIMOPwrSaveMeshAction MeshLinkHWMPGate AnnouncementCongestion ControlMCCA Setup RequestMCCA Setup ReplyMCCA Advertisement RequestMCCA AdvertisementMCCA TeardownTBTT Adjustment RequestTBTT Adjustment ResponseMultiohopAction Proxy UpdateProxy Update ConfirmationSelfprotectAction Peering OpenPeering ConfirmPeering CloseGroup Key InformGroup Key AcknowledgeVendor Act#%dReserved(%d) Act#%dhandle_deauthpbodyreason&pbody0, sizeof(pbody)mgmt_body_t *648IEEE802_11_REASON_LENconst char *[46]char *[46]368NUM_REASONS(ndo, ": %s", reason)(ndo, " (%s): %s", etheraddr_string(ndo, src), reason): %s (%s): %shandle_authoffsetretp + offset(ndo, " (%s)-%x [Challenge Text] %s", (pbody.auth_alg < NUM_AUTH_ALGS) ? auth_alg_text[pbody.auth_alg] : "Reserved", pbody.auth_trans_seq_num, ((pbody.auth_trans_seq_num % 2) ? ((pbody.status_code < NUM_STATUSES) ? status_text[pbody.status_code] : "n/a") : ""))(ndo, " (%s)-%x [Challenge Text] %s", (pbody.auth_alg < (sizeof auth_alg_text / sizeof auth_alg_text[0])) ? auth_alg_text[pbody.auth_alg] : "Reserved", pbody.auth_trans_seq_num, ((pbody.auth_trans_seq_num % 2) ? ((pbody.status_code < (sizeof status_text / sizeof status_text[0])) ? status_text[pbody.status_code] : "n/a") : "")) (%s)-%x [Challenge Text] %sconst char *[3]char *[3]const char *[51]char *[51]408n/a(ndo, " (%s)-%x: %s", (pbody.auth_alg < NUM_AUTH_ALGS) ? auth_alg_text[pbody.auth_alg] : "Reserved", pbody.auth_trans_seq_num, (pbody.auth_trans_seq_num % 2) ? ((pbody.status_code < NUM_STATUSES) ? status_text[pbody.status_code] : "n/a") : "")(ndo, " (%s)-%x: %s", (pbody.auth_alg < (sizeof auth_alg_text / sizeof auth_alg_text[0])) ? auth_alg_text[pbody.auth_alg] : "Reserved", pbody.auth_trans_seq_num, (pbody.auth_trans_seq_num % 2) ? ((pbody.status_code < (sizeof status_text / sizeof status_text[0])) ? status_text[pbody.status_code] : "n/a") : "") (%s)-%x: %shandle_disassoc(ndo, ": %s", (pbody.reason_code < NUM_REASONS) ? reason_text[pbody.reason_code] : "Reserved")(ndo, ": %s", (pbody.reason_code < (sizeof reason_text / sizeof reason_text[0])) ? reason_text[pbody.reason_code] : "Reserved")handle_atimhandle_probe_responseIEEE802_11_TSTAMP_LEN + IEEE802_11_BCNINT_LEN + IEEE802_11_CAPINFO_LEN8 + 2 + 2IEEE802_11_TSTAMP_LENIEEE802_11_BCNINT_LENIEEE802_11_CAPINFO_LEN&pbody.timestampp, IEEE802_11_TSTAMP_LENp, 8uint8_t[8]unsigned char[8]uint8_t(*)[8]unsigned char(*)[8]p+offset(ndo, " (")(ndo, ")") (u_char[33]unsigned char[33])seppbody.rates.rate[z](pbody.rates.rate[z] & 0x80 ? "*" : "")(ndo, "%s%2.1f%s", sep, (.5 * ((pbody.rates.rate[z]) & 0x7f)), (pbody.rates.rate[z] & 0x80 ? "*" : ""))(ndo, " Mbit]")z [%s%2.1f%suint8_t[16]unsigned char[16]* Mbit](ndo, " CH: %u", pbody.ds.channel) CH: %u(ndo, "%s", CAPABILITY_PRIVACY(pbody.capability_info) ? ", PRIVACY" : "")(ndo, "%s", ((pbody.capability_info) & 0x0010) ? ", PRIVACY" : "")pbody.capability_info, PRIVACYhandle_probe_requesthandle_reassoc_responsehandle_reassoc_requestIEEE802_11_CAPINFO_LEN + IEEE802_11_LISTENINT_LEN + IEEE802_11_AP_LEN2 + 2 + 6IEEE802_11_LISTENINT_LENIEEE802_11_AP_LEN&pbody.app+offset, IEEE802_11_AP_LENp+offset, 6u_char(*)[6]unsigned char(*)[6](ndo, " AP : %s", etheraddr_string(ndo, pbody.ap )) AP : %shandle_assoc_responseIEEE802_11_CAPINFO_LEN + IEEE802_11_STATUS_LEN + IEEE802_11_AID_LEN2 + 2 + 2IEEE802_11_STATUS_LENIEEE802_11_AID_LEN(ndo, " AID(%x) :%s: %s", ((uint16_t)(pbody.aid << 2 )) >> 2 , CAPABILITY_PRIVACY(pbody.capability_info) ? " PRIVACY " : "", (pbody.status_code < NUM_STATUSES ? status_text[pbody.status_code] : "n/a"))(ndo, " AID(%x) :%s: %s", ((uint16_t)(pbody.aid << 2 )) >> 2 , ((pbody.capability_info) & 0x0010) ? " PRIVACY " : "", (pbody.status_code < (sizeof status_text / sizeof status_text[0]) ? status_text[pbody.status_code] : "n/a")) AID(%x) :%s: %s PRIVACY handle_assoc_requestIEEE802_11_CAPINFO_LEN + IEEE802_11_LISTENINT_LEN2 + 2handle_beacon(ndo, " %s", CAPABILITY_ESS(pbody.capability_info) ? "ESS" : "IBSS")(ndo, " %s", ((pbody.capability_info) & 0x0001) ? "ESS" : "IBSS") %sESSIBSSparse_elementselementlenssidchallengeratesdscftim*(p + offset)*(p + offset + 2)&ssidp + offset, 2&ssid.ssidp + offset, ssid.length&challenge&challenge.textp + offset, challenge.length&rates&rates.ratep + offset, rates.length&ds&cf&cf.countp + offset, 6&tim&tim.countp + offset, 3tim.bitmapp + offset, tim.length - 3E_SSIDssid_t *sizeof(ssid.ssid)sizeof(ssid.ssid) - 1u_char(*)[33]unsigned char(*)[33]E_CHALLENGEchallenge_t *uint8_t[254]unsigned char[254]sizeof(challenge.text)253sizeof(challenge.text) - 1uint8_t(*)[254]unsigned char(*)[254]E_RATESrates_t *sizeof rates.rateuint8_t(*)[16]unsigned char(*)[16]E_DSds_t *E_CFcf_t *E_TIMtim_t *uint8_t[251]unsigned char[251]251(int)sizeof tim.bitmapwep_printivIEEE802_11_IV_LEN + IEEE802_11_KID_LEN3 + 1(ndo, " IV:%3x Pad %x KeyID %x", IV_IV(iv), IV_PAD(iv), IV_KEYID(iv))(ndo, " IV:%3x Pad %x KeyID %x", ((iv) & 0xFFFFFF), (((iv) >> 24) & 0x3F), (((iv) >> 30) & 0x03)) IV:%3x Pad %x KeyID %x16777215ieee80211_radiotap_typeieee80211_radiotap_headermeshcntl_tctrl_bar_hdr_tctrl_ba_hdr_tctrl_end_ack_hdr_tctrl_end_hdr_tctrl_ps_poll_hdr_tctrl_ack_hdr_tctrl_cts_hdr_tctrl_rts_hdr_tctrl_control_wrapper_hdr_tmgmt_body_ttim_tcf_tds_tfh_tchallenge_trates_tssid_tmgmt_header_tit_presentit_lenit_padit_versionaddr6addr5addr4seqttlctltaradurdurationbssidaiduint16_t[4]unsigned short[4]IEEE802_11_HT_CONTROL_LENht_controlIEEE802_11_CARRIED_FC_LENcarried_fcIEEE802_11_ADDR1_LENaddr1tim_presentfh_presentcf_presentds_presentrates_presentssid_presentcapability_infochallenge_presentauth_trans_seq_numauth_algreason_codestatus_codelisten_intervalbeacon_intervaltimestampbitmapbitmap_controlperiodcountelement_iddur_remaingmax_durationhop_indexhop_patternhop_setdwell_timetextseq_ctrlsada[|802.11]"[|802.11]"tstrconst char *[]char *[]Unspecified reason"Unspecified reason"Previous authentication no longer valid"Previous authentication no longer valid"Deauthenticated because sending station is leaving (or has left) IBSS or ESS"Deauthenticated because sending station is leaving (or has left) "
	  "IBSS or ESS"char[77]Disassociated due to inactivity"Disassociated due to inactivity"Disassociated because AP is unable to handle all currently  associated stations"Disassociated because AP is unable to handle all currently "
	  " associated stations"char[80]Class 2 frame received from nonauthenticated station"Class 2 frame received from nonauthenticated station"char[53]Class 3 frame received from nonassociated station"Class 3 frame received from nonassociated station"char[50]Disassociated because sending station is leaving (or has left) BSS"Disassociated because sending station is leaving "
	  "(or has left) BSS"char[67]Station requesting (re)association is not authenticated with responding station"Station requesting (re)association is not authenticated with "
	  "responding station"Disassociated because the information in the Power Capability element is unacceptable"Disassociated because the information in the Power Capability "
	  "element is unacceptable"char[86]Disassociated because the information in the SupportedChannels element is unacceptable"Disassociated because the information in the SupportedChannels "
	  "element is unacceptable"char[87]Invalid Information Element"Invalid Information Element"Michael MIC failure"Michael MIC failure"4-Way Handshake timeout"4-Way Handshake timeout"Group key update timeout"Group key update timeout"Information element in 4-Way Handshake different from (Re)AssociationRequest/Probe Response/Beacon"Information element in 4-Way Handshake different from (Re)Association"
	  "Request/Probe Response/Beacon"char[99]Group Cipher is not valid"Group Cipher is not valid"AKMP is not valid"AKMP is not valid"Unsupported RSN IE version"Unsupported RSN IE version"Invalid RSN IE Capabilities"Invalid RSN IE Capabilities"IEEE 802.1X Authentication failed"IEEE 802.1X Authentication failed"Cipher suite is rejected per security policy"Cipher suite is rejected per security policy"TS deleted because QoS AP lacks sufficient bandwidth for this QoS STA due to a change in BSS service characteristics or operational mode (e.g. an HT BSS change from 40 MHz channel to 20 MHz channel)"TS deleted because QoS AP lacks sufficient bandwidth for this "
	  "QoS STA due to a change in BSS service characteristics or "
	  "operational mode (e.g. an HT BSS change from 40 MHz channel "
	  "to 20 MHz channel)"char[199]Disassociated for unspecified, QoS-related reason"Disassociated for unspecified, QoS-related reason"Disassociated because QoS AP lacks sufficient bandwidth for this QoS STA"Disassociated because QoS AP lacks sufficient bandwidth for this "
	  "QoS STA"Disassociated because of excessive number of frames that need to be acknowledged, but are not acknowledged for AP transmissions and/or poor channel conditions"Disassociated because of excessive number of frames that need to be "
          "acknowledged, but are not acknowledged for AP transmissions "
	  "and/or poor channel conditions"char[159]Disassociated because STA is transmitting outside the limits of its TXOPs"Disassociated because STA is transmitting outside the limits "
	  "of its TXOPs"char[74]Requested from peer STA as the STA is leaving the BSS (or resetting)"Requested from peer STA as the STA is leaving the BSS "
	  "(or resetting)"char[69]Requested from peer STA as it does not want to use the mechanism"Requested from peer STA as it does not want to use the "
	  "mechanism"Requested from peer STA as the STA received frames using the mechanism for which a set up is required"Requested from peer STA as the STA received frames using the "
	  "mechanism for which a set up is required"char[102]Requested from peer STA due to time out"Requested from peer STA due to time out"Peer STA does not support the requested cipher suite"Peer STA does not support the requested cipher suite"Association denied due to requesting STA not supporting HT features"Association denied due to requesting STA not supporting HT "
	  "features"char[68]reason_textSuccessful"Successful"Unspecified failure"Unspecified failure"Cannot Support all requested capabilities in the Capability Information field"Cannot Support all requested capabilities in the Capability "
	  "Information field"char[78]Reassociation denied due to inability to confirm that association exists"Reassociation denied due to inability to confirm that association "
	  "exists"Association denied due to reason outside the scope of the standard"Association denied due to reason outside the scope of the "
	  "standard"Responding station does not support the specified authentication algorithm "Responding station does not support the specified authentication "
	  "algorithm "char[76]Received an Authentication frame with authentication transaction sequence number out of expected sequence"Received an Authentication frame with authentication transaction "
	  "sequence number out of expected sequence"char[106]Authentication rejected because of challenge failure"Authentication rejected because of challenge failure"Authentication rejected due to timeout waiting for next frame in sequence"Authentication rejected due to timeout waiting for next frame in "
	  "sequence"Association denied because AP is unable to handle additionalassociated stations"Association denied because AP is unable to handle additional"
	  "associated stations"Association denied due to requesting station not supporting all of the data rates in BSSBasicRateSet parameter"Association denied due to requesting station not supporting all of "
	  "the data rates in BSSBasicRateSet parameter"char[111]Association denied due to requesting station not supporting short preamble operation"Association denied due to requesting station not supporting "
	  "short preamble operation"char[85]Association denied due to requesting station not supporting PBCC encoding"Association denied due to requesting station not supporting "
	  "PBCC encoding"Association denied due to requesting station not supporting channel agility"Association denied due to requesting station not supporting "
	  "channel agility"Association request rejected because Spectrum Management capability is required"Association request rejected because Spectrum Management "
	  "capability is required"Association request rejected because the information in the Power Capability element is unacceptable"Association request rejected because the information in the "
	  "Power Capability element is unacceptable"char[101]Association request rejected because the information in the Supported Channels element is unacceptable"Association request rejected because the information in the "
	  "Supported Channels element is unacceptable"char[103]Association denied due to requesting station not supporting short slot operation"Association denied due to requesting station not supporting "
	  "short slot operation"char[81]Association denied due to requesting station not supporting DSSS-OFDM operation"Association denied due to requesting station not supporting "
	  "DSSS-OFDM operation"Association denied because the requested STA does not support HT features"Association denied because the requested STA does not support HT "
	  "features"Association denied because the requested STA does not support the PCO transition time required by the AP"Association denied because the requested STA does not support "
	  "the PCO transition time required by the AP"char[105]Unspecified, QoS-related failure"Unspecified, QoS-related failure"Association denied due to QAP having insufficient bandwidth to handle another QSTA"Association denied due to QAP having insufficient bandwidth "
	  "to handle another QSTA"char[83]Association denied due to excessive frame loss rates and/or poor conditions on current operating channel"Association denied due to excessive frame loss rates and/or "
	  "poor conditions on current operating channel"Association (with QBSS) denied due to requesting station not supporting the QoS facility"Association (with QBSS) denied due to requesting station not "
	  "supporting the QoS facility"char[89]Association denied due to requesting station not supporting Block Ack"Association denied due to requesting station not supporting "
	  "Block Ack"char[70]The request has been declined"The request has been declined"The request has not been successful as one or more parameters have invalid values"The request has not been successful as one or more parameters "
	  "have invalid values"char[82]The TS has not been created because the request cannot be honored. Try again with the suggested changes to the TSPEC"The TS has not been created because the request cannot be honored. "
	  "Try again with the suggested changes to the TSPEC"char[117]Pairwise Cipher is not valid"Pairwise Cipher is not valid"The TS has not been created. However, the HC may be capable of creating a TS, in response to a request, after the time indicated in the TS Delay element"The TS has not been created. However, the HC may be capable of "
	  "creating a TS, in response to a request, after the time indicated "
	  "in the TS Delay element"char[153]Direct Link is not allowed in the BSS by policy"Direct Link is not allowed in the BSS by policy"char[48]Destination STA is not present within this QBSS."Destination STA is not present within this QBSS."The Destination STA is not a QSTA."The Destination STA is not a QSTA."status_textOpen System"Open System"Shared Key"Shared Key"EAP"EAP"auth_alg_textieee80211_float_htratesControl Wrapper"Control Wrapper"BAR"BAR"BA"BA"Power Save-Poll"Power Save-Poll"Request-To-Send"Request-To-Send"Clear-To-Send"Clear-To-Send"Acknowledgment"Acknowledgment"CF-End"CF-End"CF-End+CF-Ack"CF-End+CF-Ack"ctrl_strAssoc Request"Assoc Request"Assoc Response"Assoc Response"ReAssoc Request"ReAssoc Request"ReAssoc Response"ReAssoc Response"Probe Request"Probe Request"Probe Response"Probe Response"Beacon"Beacon"ATIM"ATIM"Disassociation"Disassociation"Authentication"Authentication"DeAuthentication"DeAuthentication"Action"Action"st_str0x802110020x80211001WLANCAP_MAGIC_COOKIE_BASE0x80211000BITBITNO_2BITNO_4BITNO_8BITNO_16BITNO_32IS_EXTENDED(__p)(EXTRACT_LE_32BITS(__p) & BIT(IEEE80211_RADIOTAP_EXT)) != 0BIT(n)(1U << n)BITNO_2(x)(((x) & 2) ? 1 : 0)BITNO_4(x)(((x) >> 2) ? 2 + BITNO_2((x) >> 2) : BITNO_2((x)))BITNO_8(x)(((x) >> 4) ? 4 + BITNO_4((x) >> 4) : BITNO_4((x)))BITNO_16(x)(((x) >> 8) ? 8 + BITNO_8((x) >> 8) : BITNO_8((x)))BITNO_32(x)(((x) >> 16) ? 16 + BITNO_16((x) >> 16) : BITNO_16((x)))IS_CHAN_ANYG(flags)(IS_CHAN_PUREG(flags) || IS_CHAN_G(flags))IS_CHAN_G(flags)((flags & IEEE80211_CHAN_G) == IEEE80211_CHAN_G)IS_CHAN_PUREG(flags)((flags & IEEE80211_CHAN_PUREG) == IEEE80211_CHAN_PUREG)IS_CHAN_B(flags)((flags & IEEE80211_CHAN_B) == IEEE80211_CHAN_B)IS_CHAN_A(flags)((flags & IEEE80211_CHAN_A) == IEEE80211_CHAN_A)IS_CHAN_FHSS(flags)((flags & IEEE80211_CHAN_FHSS) == IEEE80211_CHAN_FHSS)IEEE80211_CHAN_G(IEEE80211_CHAN_2GHZ | IEEE80211_CHAN_DYN)IEEE80211_CHAN_PUREG(IEEE80211_CHAN_2GHZ | IEEE80211_CHAN_OFDM)IEEE80211_CHAN_B(IEEE80211_CHAN_2GHZ | IEEE80211_CHAN_CCK)IEEE80211_CHAN_A(IEEE80211_CHAN_5GHZ | IEEE80211_CHAN_OFDM)IEEE80211_CHAN_FHSS(IEEE80211_CHAN_2GHZ | IEEE80211_CHAN_GFSK)IEEE80211_RADIOTAP_CODING_LDPC_USERnIEEE80211_RADIOTAP_VHT_BANDWIDTH_MASK0x1fIEEE80211_RADIOTAP_VHT_BEAMFORMEDIEEE80211_RADIOTAP_VHT_LDPC_EXTRA_OFDM_SYMIEEE80211_RADIOTAP_VHT_SGI_NSYM_M10_9IEEE80211_RADIOTAP_VHT_SHORT_GIIEEE80211_RADIOTAP_VHT_TXOP_PS_NAIEEE80211_RADIOTAP_VHT_STBCIEEE80211_RADIOTAP_VHT_PARTIAL_AID_KNOWNIEEE80211_RADIOTAP_VHT_GROUP_ID_KNOWN0x0080IEEE80211_RADIOTAP_VHT_BEAMFORMED_KNOWNIEEE80211_RADIOTAP_VHT_LDPC_EXTRA_OFDM_SYM_KNOWNIEEE80211_RADIOTAP_VHT_SGI_NSYM_DIS_KNOWNIEEE80211_RADIOTAP_VHT_TXOP_PS_NA_KNOWNIEEE80211_RADIOTAP_VHT_STBC_KNOWNIEEE80211_RADIOTAP_AMPDU_DELIM_CRC_KNOWNIEEE80211_RADIOTAP_AMPDU_DELIM_CRC_ERRIEEE80211_RADIOTAP_AMPDU_IS_LASTIEEE80211_RADIOTAP_AMPDU_LAST_KNOWNIEEE80211_RADIOTAP_AMPDU_IS_ZEROLENIEEE80211_RADIOTAP_AMPDU_REPORT_ZEROLENIEEE80211_RADIOTAP_MCS_NESS_BIT_0IEEE80211_RADIOTAP_MCS_STBC_SHIFTIEEE80211_RADIOTAP_MCS_STBC_3IEEE80211_RADIOTAP_MCS_STBC_2IEEE80211_RADIOTAP_MCS_STBC_1IEEE80211_RADIOTAP_MCS_STBC_MASK0x60IEEE80211_RADIOTAP_MCS_FEC_LDPCIEEE80211_RADIOTAP_MCS_HT_GREENFIELDIEEE80211_RADIOTAP_MCS_BANDWIDTH_20UIEEE80211_RADIOTAP_MCS_BANDWIDTH_20LIEEE80211_RADIOTAP_MCS_BANDWIDTH_20IEEE80211_RADIOTAP_MCS_NESS_BIT_1IEEE80211_RADIOTAP_MCS_NESS_KNOWNIEEE80211_RADIOTAP_F_RX_PLCP_CRCIEEE80211_RADIOTAP_F_RX_BADFCSIEEE80211_CHAN_TG(IEEE80211_CHAN_2GHZ | IEEE80211_CHAN_DYN | IEEE80211_CHAN_TURBO)IEEE80211_CHAN_TA(IEEE80211_CHAN_5GHZ | IEEE80211_CHAN_OFDM | IEEE80211_CHAN_TURBO)0x400000x200000x100000x080000x04000IEEE80211_CHAN_STURBO0x02000IEEE80211_CHAN_GSM0x01000IEEE80211_CHAN_GFSK0x00800IEEE80211_CHAN_DYN0x00400IEEE80211_CHAN_PASSIVE0x00200IEEE80211_CHAN_5GHZ0x00100IEEE80211_CHAN_2GHZ0x00080IEEE80211_CHAN_OFDM0x00040IEEE80211_CHAN_CCK0x000200x00010roundup2(x,y)(((x)+((y)-1))&(~((y)-1)))ADDR4ADDR3ADDR2ADDR1(p + 24)(p + 16)(p + 10)(p + 4)PRINT_SELFPROT_ACTION(v)( (v) == 1 ? ND_PRINT((ndo, "Peering Open")) : (v) == 2 ? ND_PRINT((ndo, "Peering Confirm")) : (v) == 3 ? ND_PRINT((ndo, "Peering Close")) : (v) == 4 ? ND_PRINT((ndo, "Group Key Inform")) : (v) == 5 ? ND_PRINT((ndo, "Group Key Acknowledge")) : ND_PRINT((ndo, "Act#%d", (v))) )PRINT_MULTIHOP_ACTION(v)( (v) == 0 ? ND_PRINT((ndo, "Proxy Update")) : (v) == 1 ? ND_PRINT((ndo, "Proxy Update Confirmation")) : ND_PRINT((ndo, "Act#%d", (v))) )PRINT_MESH_ACTION(v)( (v) == 0 ? ND_PRINT((ndo, "MeshLink")) : (v) == 1 ? ND_PRINT((ndo, "HWMP")) : (v) == 2 ? ND_PRINT((ndo, "Gate Announcement")) : (v) == 3 ? ND_PRINT((ndo, "Congestion Control")) : (v) == 4 ? ND_PRINT((ndo, "MCCA Setup Request")) : (v) == 5 ? ND_PRINT((ndo, "MCCA Setup Reply")) : (v) == 6 ? ND_PRINT((ndo, "MCCA Advertisement Request")) : (v) == 7 ? ND_PRINT((ndo, "MCCA Advertisement")) : (v) == 8 ? ND_PRINT((ndo, "MCCA Teardown")) : (v) == 9 ? ND_PRINT((ndo, "TBTT Adjustment Request")) : (v) == 10 ? ND_PRINT((ndo, "TBTT Adjustment Response")) : ND_PRINT((ndo, "Act#%d", (v))) )PRINT_MESHPATH_ACTION(v)( (v) == 0 ? ND_PRINT((ndo, "Request")) : (v) == 1 ? ND_PRINT((ndo, "Report")) : (v) == 2 ? ND_PRINT((ndo, "Error")) : (v) == 3 ? ND_PRINT((ndo, "RootAnnouncement")) : ND_PRINT((ndo, "Act#%d", (v))) )PRINT_MESHPEERING_ACTION(v)( (v) == 0 ? ND_PRINT((ndo, "Open")) : (v) == 1 ? ND_PRINT((ndo, "Confirm")) : (v) == 2 ? ND_PRINT((ndo, "Close")) : ND_PRINT((ndo, "Act#%d", (v))) )PRINT_MESHLINK_ACTION(v)( (v) == 0 ? ND_PRINT((ndo, "Request")) : (v) == 1 ? ND_PRINT((ndo, "Report")) : ND_PRINT((ndo, "Act#%d", (v))) )PRINT_BA_ACTION(v)( (v) == 0 ? ND_PRINT((ndo, "ADDBA Request")) : (v) == 1 ? ND_PRINT((ndo, "ADDBA Response")) : (v) == 2 ? ND_PRINT((ndo, "DELBA")) : ND_PRINT((ndo, "Act#%d", (v))) )PRINT_HT_ACTION(v)( (v) == 0 ? ND_PRINT((ndo, "TxChWidth")) : (v) == 1 ? ND_PRINT((ndo, "MIMOPwrSave")) : ND_PRINT((ndo, "Act#%d", (v))) )(sizeof reason_text / sizeof reason_text[0])NUM_STATUSES(sizeof status_text / sizeof status_text[0])NUM_AUTH_ALGS(sizeof auth_alg_text / sizeof auth_alg_text[0])PRINT_DS_CHANNEL(p)if (p.ds_present) ND_PRINT((ndo, " CH: %u", p.ds.channel)); ND_PRINT((ndo, "%s", CAPABILITY_PRIVACY(p.capability_info) ? ", PRIVACY" : ""));PRINT_RATES(p)if (p.rates_present) { int z; const char *sep = " ["; for (z = 0; z < p.rates.length ; z++) { PRINT_RATE(sep, p.rates.rate[z], (p.rates.rate[z] & 0x80 ? "*" : "")); sep = " "; } if (p.rates.length != 0) ND_PRINT((ndo, " Mbit]")); }PRINT_RATE(_sep,_r,_suf)ND_PRINT((ndo, "%s%2.1f%s", _sep, (.5 * ((_r) & 0x7f)), _suf))PRINT_SSID(p)if (p.ssid_present) { ND_PRINT((ndo, " (")); fn_print(ndo, p.ssid.ssid, NULL); ND_PRINT((ndo, ")")); }IV_KEYID(iv)(((iv) >> 30) & 0x03)IV_PAD(iv)(((iv) >> 24) & 0x3F)IV_IV(iv)((iv) & 0xFFFFFF)(IEEE802_11_FC_LEN+IEEE802_11_DUR_LEN+ IEEE802_11_RA_LEN+IEEE802_11_TA_LEN+ IEEE802_11_CTL_LEN+IEEE802_11_SEQ_LEN)(IEEE802_11_FC_LEN+IEEE802_11_DUR_LEN+IEEE802_11_RA_LEN)(IEEE802_11_FC_LEN+IEEE802_11_DUR_LEN+ IEEE802_11_RA_LEN+IEEE802_11_BSSID_LEN)(IEEE802_11_FC_LEN+IEEE802_11_AID_LEN+ IEEE802_11_BSSID_LEN+IEEE802_11_TA_LEN)(IEEE802_11_FC_LEN+IEEE802_11_DUR_LEN+ IEEE802_11_RA_LEN+IEEE802_11_TA_LEN)(IEEE802_11_FC_LEN+IEEE802_11_DUR_LEN+ IEEE802_11_ADDR1_LEN+ IEEE802_11_CARRIED_FC_LEN+ IEEE802_11_HT_CONTROL_LEN)E_IBSSE_FHCAPABILITY_PRIVACY(cap)((cap) & 0x0010)CAPABILITY_CFP_REQ(cap)((cap) & 0x0008)CAPABILITY_CFP(cap)((cap) & 0x0004)CAPABILITY_IBSS(cap)((cap) & 0x0002)CAPABILITY_ESS(cap)((cap) & 0x0001)(IEEE802_11_FC_LEN+IEEE802_11_DUR_LEN+ IEEE802_11_DA_LEN+IEEE802_11_SA_LEN+ IEEE802_11_BSSID_LEN+IEEE802_11_SEQ_LEN)FC_ORDER(fc)((fc) & 0x8000)FC_PROTECTED(fc)((fc) & 0x4000)FC_MORE_DATA(fc)((fc) & 0x2000)FC_POWER_MGMT(fc)((fc) & 0x1000)FC_RETRY(fc)((fc) & 0x0800)FC_MORE_FLAG(fc)((fc) & 0x0400)FC_FROM_DS(fc)((fc) & 0x0200)FC_TO_DS(fc)((fc) & 0x0100)FC_TYPE(fc)(((fc) >> 2) & 0x3)FC_VERSION(fc)((fc) & 0x3)DATA_FRAME_IS_QOS(x)((x) & 0x08)DATA_FRAME_IS_NULL(x)((x) & 0x04)DATA_FRAME_IS_CF_POLL(x)((x) & 0x02)DATA_FRAME_IS_CF_ACK(x)((x) & 0x01)DATA_QOS_CF_ACK_POLL_NODATA0xFDATA_QOS_CF_POLL_NODATA0xEDATA_QOS_NODATA0xCDATA_QOS_DATA_CF_ACK_POLL0xBDATA_QOS_DATA_CF_POLL0xADATA_QOS_DATA_CF_ACK0x9DATA_QOS_DATA0x8DATA_NODATA_CF_ACK_POLL0x7DATA_NODATA_CF_POLL0x6DATA_NODATA_CF_ACK0x5DATA_NODATA0x4DATA_DATA_CF_ACK_POLL0x3DATA_DATA_CF_POLL0x2DATA_DATA_CF_ACK0x1DATA_DATA0x00xDT_RESVIEEE802_11_FCS_LENIEEE802_11_KID_LENIEEE802_11_IV_LENIEEE802_11_CTL_LENIEEE802_11_SEQ_LENIEEE802_11_DUR_LENroundup2/*
 * For DLT_IEEE802_11_RADIO_AVS; like DLT_IEEE802_11, but with an
 * extra header, containing information such as radio information,
 * which we currently ignore.
 *//*
 * For DLT_IEEE802_11_RADIO; like DLT_IEEE802_11, but with an extra
 * header, containing information such as radio information.
 *//*
 * For DLT_PRISM_HEADER; like DLT_IEEE802_11, but with an extra header,
 * containing information such as radio information, which we
 * currently ignore.
 *
 * If, however, the packet begins with WLANCAP_MAGIC_COOKIE_V1 or
 * WLANCAP_MAGIC_COOKIE_V2, it's really DLT_IEEE802_11_RADIO_AVS
 * (currently, on Linux, there's no ARPHRD_ type for
 * DLT_IEEE802_11_RADIO_AVS, as there is a ARPHRD_IEEE80211_PRISM
 * for DLT_PRISM_HEADER, so ARPHRD_IEEE80211_PRISM is used for
 * the AVS header, and the first 4 bytes of the header are used to
 * indicate whether it's a Prism header or an AVS header).
 *//*
		 * Yow!  The capture header length is claimed not
		 * to be large enough to include even the version
		 * cookie or capture header length!
		 *//* FCS at end of packet *//* Atheros padding *//*
			 * Illegal combination.  The behavior in this
			 * case is undefined by the radiotap spec; we
			 * just ignore both bits.
			 *//*
			 * We're switching to a vendor namespace.
			 * Reset the presence-bitmap index to 0,
			 * note that we're in a vendor namespace,
			 * and fetch the fields of the Vendor Namespace
			 * item.
			 *//*
			 * We're switching to the radiotap namespace.
			 * Reset the presence-bitmap index to 0, and
			 * reset the namespace to the default radiotap
			 * namespace.
			 *//*
			 * We're not changing namespaces.
			 * advance to the next 32 bits in the current
			 * namespace.
			 *//*
		 * Handle the namespace switch bits; we've already handled
		 * the extension bit in all but the last word above.
		 *//*
				 * Fatal error - can't process anything
				 * more in the radiotap header.
				 *//*
			 * We've skipped it all; nothing more to
			 * skip.
			 *//*
				 * Ran out of space in the packet.
				 *//*
			 * Skip past the stuff we don't understand.
			 * If we add support for any vendor namespaces,
			 * it'd be added here; use vendor_oui and
			 * vendor_subnamespace to interpret the fields.
			 *//*
		 * If this is a vendor namespace, we don't handle it.
		 *//* Assume no FCS at end of frame *//* Assume no Atheros padding between 802.11 header and body *//* Assume no flags *//*
	 * Start out at the beginning of the default radiotap namespace.
	 *//* are there more bitmap extensions than bytes in header? *//* more bitmaps *//* includes the 1st bitmap *//* align against header start *//*
	 * If we don't have the entire radiotap header, just give up.
	 *//*
		 * The length is the length of the entire header, so
		 * it must be as large as the fixed-length part of
		 * the header.
		 *//*
		 * Get the radiotap bit number of that bit.
		 *//*
		 * Stop if this is one of the "same meaning
		 * in all presence flags" bits.
		 *//*
		 * Get the bit number, within this presence word,
		 * of the remaining least significant bit that
		 * is set.
		 *//*
		 * Clear the least significant bit that is set.
		 *//* this bit indicates a field whose
		 * size we do not know, so we cannot
		 * proceed.  Just print the bit number.
		 *//* Do nothing for now *//*
				 * We at least have the MCS index.
				 * Print it.
				 *//*
				 * We have the rate.
				 * Print it.
				 *//*
				 * The MCS value is out of range.
				 *//*
					 * We don't know both the bandwidth
					 * and the guard interval, so we can
					 * only report the MCS index.
					 *//*
					 * And we know both the bandwidth and
					 * the guard interval, so we can look
					 * up the rate.
					 *//*
				 * And it's in-range.
				 *//*
			 * We know the MCS index.
			 *//*
		 * If CHANNEL and XCHANNEL are both present, skip
		 * CHANNEL.
		 *//*
			 * XXX - we don't know the channel width
			 * or guard interval length, so we can't
			 * convert this to a data rate.
			 *
			 * If you want us to show a data rate,
			 * use the MCS field, not the Rate field;
			 * the MCS field includes not only the
			 * MCS index, it also includes bandwidth
			 * and guard interval information.
			 *
			 * XXX - can we get the channel width
			 * from XChannel and the guard interval
			 * information from Flags, at least on
			 * FreeBSD?
			 *//*
		 * XXX On FreeBSD rate & 0x80 means we have an MCS. On
		 * Linux and AirPcap it does not.  (What about
		 * Mac OS X, NetBSD, OpenBSD, and DragonFly BSD?)
		 *
		 * This is an issue either for proprietary extensions
		 * to 11a or 11g, which do exist, or for 11n
		 * implementations that stuff a rate value into
		 * this field, which also appear to exist.
		 *
		 * We currently handle that by assuming that
		 * if the 0x80 bit is set *and* the remaining
		 * bits have a value between 0 and 15 it's
		 * an MCS value, otherwise it's a rate.  If
		 * there are cases where systems that use
		 * "0x80 + MCS index" for MCS indices > 15,
		 * or stuff a rate value here between 64 and
		 * 71.5 Mb/s in here, we'll need a preference
		 * setting.  Such rates do exist, e.g. 11n
		 * MCS 7 at 20 MHz with a long guard interval.
		 *//*
	 * These apply to 11n.
	 *//*
		 * We have the MCS field, so this is 11n, regardless
		 * of what the channel flags say.
		 *//* For IEEE80211_RADIOTAP_VHT flags *//* For IEEE80211_RADIOTAP_VHT known *//* For IEEE80211_RADIOTAP_AMPDU_STATUS *//* short guard interval *//* For IEEE80211_RADIOTAP_MCS flags *//* MCS index field *//* For IEEE80211_RADIOTAP_MCS known *//* frame failed PLCP CRC check *//* frame failed crc check *//* For IEEE80211_RADIOTAP_RX_FLAGS *//* does not pass FCS check *//* frame has padding between
						 * 802.11 header and payload
						 * (to 32-bit boundary)
						 *//* frame includes FCS *//* sent/received
						 * with fragmentation
						 *//* sent/received
						 * with WEP encryption
						 *//* sent/received
						 * with short
						 * preamble
						 *//* sent/received
						 * during CFP
						 *//* For IEEE80211_RADIOTAP_FLAGS *//* Useful combinations of channel characteristics, borrowed from Ethereal *//* HT 40 channel w/ ext below *//* HT 40 channel w/ ext above *//* HT 20 channel *//* Quarter rate channel *//* Half rate channel *//* 11a static turbo channel only *//* 900 MHz spectrum channel *//* GFSK channel (FHSS PHY) *//* Dynamic CCK-OFDM channel *//* Only passive scan allowed *//* 5 GHz spectrum channel *//* 2 GHz spectrum channel. *//* OFDM channel *//* CCK channel *//* Turbo channel *//* channel attributes *//* NB: gap for netbsd definitions *//* Name                                 Data type       Units
 * ----                                 ---------       -----
 *
 * IEEE80211_RADIOTAP_TSFT              uint64_t       microseconds
 *
 *      Value in microseconds of the MAC's 64-bit 802.11 Time
 *      Synchronization Function timer when the first bit of the
 *      MPDU arrived at the MAC. For received frames, only.
 *
 * IEEE80211_RADIOTAP_CHANNEL           2 x uint16_t   MHz, bitmap
 *
 *      Tx/Rx frequency in MHz, followed by flags (see below).
 *	Note that IEEE80211_RADIOTAP_XCHANNEL must be used to
 *	represent an HT channel as there is not enough room in
 *	the flags word.
 *
 * IEEE80211_RADIOTAP_FHSS              uint16_t       see below
 *
 *      For frequency-hopping radios, the hop set (first byte)
 *      and pattern (second byte).
 *
 * IEEE80211_RADIOTAP_RATE              uint8_t        500kb/s or index
 *
 *      Tx/Rx data rate.  If bit 0x80 is set then it represents an
 *	an MCS index and not an IEEE rate.
 *
 * IEEE80211_RADIOTAP_DBM_ANTSIGNAL     int8_t          decibels from
 *                                                      one milliwatt (dBm)
 *
 *      RF signal power at the antenna, decibel difference from
 *      one milliwatt.
 *
 * IEEE80211_RADIOTAP_DBM_ANTNOISE      int8_t          decibels from
 *                                                      one milliwatt (dBm)
 *
 *      RF noise power at the antenna, decibel difference from one
 *      milliwatt.
 *
 * IEEE80211_RADIOTAP_DB_ANTSIGNAL      uint8_t        decibel (dB)
 *
 *      RF signal power at the antenna, decibel difference from an
 *      arbitrary, fixed reference.
 *
 * IEEE80211_RADIOTAP_DB_ANTNOISE       uint8_t        decibel (dB)
 *
 *      RF noise power at the antenna, decibel difference from an
 *      arbitrary, fixed reference point.
 *
 * IEEE80211_RADIOTAP_LOCK_QUALITY      uint16_t       unitless
 *
 *      Quality of Barker code lock. Unitless. Monotonically
 *      nondecreasing with "better" lock strength. Called "Signal
 *      Quality" in datasheets.  (Is there a standard way to measure
 *      this?)
 *
 * IEEE80211_RADIOTAP_TX_ATTENUATION    uint16_t       unitless
 *
 *      Transmit power expressed as unitless distance from max
 *      power set at factory calibration.  0 is max power.
 *      Monotonically nondecreasing with lower power levels.
 *
 * IEEE80211_RADIOTAP_DB_TX_ATTENUATION uint16_t       decibels (dB)
 *
 *      Transmit power expressed as decibel distance from max power
 *      set at factory calibration.  0 is max power.  Monotonically
 *      nondecreasing with lower power levels.
 *
 * IEEE80211_RADIOTAP_DBM_TX_POWER      int8_t          decibels from
 *                                                      one milliwatt (dBm)
 *
 *      Transmit power expressed as dBm (decibels from a 1 milliwatt
 *      reference). This is the absolute power level measured at
 *      the antenna port.
 *
 * IEEE80211_RADIOTAP_FLAGS             uint8_t        bitmap
 *
 *      Properties of transmitted and received frames. See flags
 *      defined below.
 *
 * IEEE80211_RADIOTAP_ANTENNA           uint8_t        antenna index
 *
 *      Unitless indication of the Rx/Tx antenna for this packet.
 *      The first antenna is antenna 0.
 *
 * IEEE80211_RADIOTAP_RX_FLAGS          uint16_t       bitmap
 *
 *     Properties of received frames. See flags defined below.
 *
 * IEEE80211_RADIOTAP_XCHANNEL          uint32_t	bitmap
 *					uint16_t	MHz
 *					uint8_t		channel number
 *					uint8_t		.5 dBm
 *
 *	Extended channel specification: flags (see below) followed by
 *	frequency in MHz, the corresponding IEEE channel number, and
 *	finally the maximum regulatory transmit power cap in .5 dBm
 *	units.  This property supersedes IEEE80211_RADIOTAP_CHANNEL
 *	and only one of the two should be present.
 *
 * IEEE80211_RADIOTAP_MCS		uint8_t		known
 *					uint8_t		flags
 *					uint8_t		mcs
 *
 *	Bitset indicating which fields have known values, followed
 *	by bitset of flag values, followed by the MCS rate index as
 *	in IEEE 802.11n.
 *
 *
 * IEEE80211_RADIOTAP_AMPDU_STATUS	u32, u16, u8, u8	unitless
 *
 *	Contains the AMPDU information for the subframe.
 *
 * IEEE80211_RADIOTAP_VHT	u16, u8, u8, u8[4], u8, u8, u16
 *
 *	Contains VHT information about this frame.
 *
 * IEEE80211_RADIOTAP_VENDOR_NAMESPACE
 *					uint8_t  OUI[3]
 *                                   uint8_t  subspace
 *                                   uint16_t length
 *
 *     The Vendor Namespace Field contains three sub-fields. The first
 *     sub-field is 3 bytes long. It contains the vendor's IEEE 802
 *     Organizationally Unique Identifier (OUI). The fourth byte is a
 *     vendor-specific "namespace selector."
 *
 *//* A bitmap telling which
					 * fields are present. Set bit 31
					 * (0x80000000) to extend the
					 * bitmap by another 32 bits.
					 * Additional extensions are made
					 * by setting bit 31.
					 *//* length of the whole
					 * header in bytes, including
					 * it_version, it_pad,
					 * it_len, and data fields.
					 *//* Version 0. Only increases
					 * for drastic changes,
					 * introduction of compatible
					 * new fields does not count.
					 *//*
 * The radio capture header precedes the 802.11 header.
 *
 * Note well: all radiotap fields are little-endian.
 *//* A generic radio capture format is desirable. It must be
 * rigidly defined (e.g., units for fields should be given),
 * and easily extensible.
 *
 * The following is an extensible radio capture format. It is
 * based on a bitmap indicating which fields are present.
 *
 * I am trying to describe precisely what the application programmer
 * should expect in the following, and for that reason I tell the
 * units and origin of each measurement (where it applies), or else I
 * use sufficiently weaselly language ("is a monotonically nondecreasing
 * function of...") that I cannot set false expectations for lawyerly
 * readers.
 *//* NetBSD: ieee802_11_radio.h,v 1.2 2006/02/26 03:04:03 dyoung Exp  *//* $FreeBSD: src/sys/net80211/ieee80211_radiotap.h,v 1.5 2005/01/22 20:12:05 sam Exp $ *//*
 * This is the top level routine of the printer.  'p' points
 * to the 802.11 header of the packet, 'h->ts' is the timestamp,
 * 'h->len' is the length of the packet off the wire, and 'h->caplen'
 * is the number of bytes actually captured.
 *//* We shouldn't get here - we should already have quit *//*
				 * Some kinds of LLC packet we cannot
				 * handle intelligently
				 *//* There may be a problem w/ AP not having this bit set *//* no-data frame *//*
	 * Go past the 802.11 header.
	 *//* Unknown frame type or control frame subtype; quit. *//* Amount of FCS in actual packet data, if any *//* Remove FCS, if present *//* if y is powers of two *//*
 * Print the 802.11 MAC header.
 *//*
 * Print Header funcs
 *//* To DS and From DS *//* From DS and not To DS *//* not To DS and From DS *//* not To DS and not From DS *//*
 * Function to get source and destination MAC addresses for a data frame.
 *//*
 *  Data Frame - Address field contents
 *
 *  To Ds  | From DS | Addr 1 | Addr 2 | Addr 3 | Addr 4
 *    0    |  0      |  DA    | SA     | BSSID  | n/a
 *    0    |  1      |  DA    | BSSID  | SA     | n/a
 *    1    |  0      |  BSSID | SA     | DA     | n/a
 *    1    |  1      |  RA    | TA     | DA     | SA
 *//* XXX - requires special handling *//*********************************************************************************
 * Handles printing all the control frame types
 *********************************************************************************//*********************************************************************************
 * Print Body funcs
 *********************************************************************************//* the frame body for ATIM is null. *//* Same as a Association Reponse *//*********************************************************************************
 * Print Handle functions for the management frame types
 *********************************************************************************//* No problems found. *//*
			 * Present and not truncated.
			 *
			 * If we haven't already seen a TIM IE,
			 * copy this one, otherwise ignore this one,
			 * so we later report the first one we saw.
			 *//*
			 * Present and not truncated.
			 *
			 * If we haven't already seen a CF IE,
			 * copy this one, otherwise ignore this one,
			 * so we later report the first one we saw.
			 *//*
			 * Present and not truncated.
			 *
			 * If we haven't already seen a DS IE,
			 * copy this one, otherwise ignore this one,
			 * so we later report the first one we saw.
			 *//*
			 * Present and not truncated.
			 *
			 * If we haven't already seen a rates IE,
			 * copy this one if it's not zero-length,
			 * otherwise ignore this one, so we later
			 * report the first one we saw.
			 *
			 * We ignore zero-length rates IEs as some
			 * devices seem to put a zero-length rates
			 * IE, followed by an SSID IE, followed by
			 * a non-zero-length rates IE into frames,
			 * even though IEEE Std 802.11-2007 doesn't
			 * seem to indicate that a zero-length rates
			 * IE is valid.
			 *//*
			 * Present and not truncated.
			 *
			 * If we haven't already seen a challenge IE,
			 * copy this one, otherwise ignore this one,
			 * so we later report the first one we saw.
			 *//*
			 * Present and not truncated.
			 *
			 * If we haven't already seen an SSID IE,
			 * copy this one, otherwise ignore this one,
			 * so we later report the first one we saw.
			 *//* Make sure we have the entire element. *//* Make sure we at least have the element ID and length. *//*
	 * We haven't seen any elements yet.
	 *//* 46 *//* 45 *//* 44 *//* 43 *//* 42 *//* 41 *//* 40 *//* 39 *//* 38 *//* 37 *//* 36 *//* 35 *//* 34 *//* 33 *//* 32 *//* 31 *//* 30 *//* 29 *//* 28 *//* 27 *//* 26 *//* 25 *//* 24 *//* 23 *//* 22 *//* 21 *//* 20 *//* 18 *//* 17 *//* 16 *//* 15 *//* 14 *//* 13 *//* 12 *//* 11 *//* 10 *//* 9 *//* 8 *//* 7 *//* 6 *//* 5 *//* 4 *//* 3 *//* 2 *//* 1 *//* 0 *//* 50 *//* 49 *//* 48 *//* 47 *//* 19 *//*  9 *//*  8 *//*  7 *//*  6 *//*  5 *//*  4 *//*  3 *//*  2 *//*  1 *//*  0 *//* SGI *//* 40 Mhz *//* 20 Mhz *//* MCS 76  *//* MCS 75  *//* MCS 74  *//* MCS 73  *//* MCS 72  *//* MCS 71  *//* MCS 70  *//* MCS 69  *//* MCS 68  *//* MCS 67  *//* MCS 66  *//* MCS 65  *//* MCS 64  *//* MCS 63  *//* MCS 62  *//* MCS 61  *//* MCS 60  *//* MCS 59  *//* MCS 58  *//* MCS 57  *//* MCS 56  *//* MCS 55  *//* MCS 54  *//* MCS 53  *//* MCS 52  *//* MCS 51  *//* MCS 50  *//* MCS 49  *//* MCS 48  *//* MCS 47  *//* MCS 46  *//* MCS 45  *//* MCS 44  *//* MCS 43  *//* MCS 42  *//* MCS 41  *//* MCS 40  *//* MCS 39  *//* MCS 38  *//* MCS 37  *//* MCS 36  *//* MCS 35  *//* MCS 34  *//* MCS 33  *//* not valid *//* MCS 32  *//* MCS 31  *//* MCS 30  *//* MCS 29  *//* MCS 28  *//* MCS 27  *//* MCS 26  *//* MCS 25  *//* MCS 24  *//* MCS 23  *//* MCS 22  *//* MCS 21  *//* MCS 20  *//* MCS 19  *//* MCS 18  *//* MCS 17  *//* MCS 16  *//* MCS 15  *//* MCS 14  *//* MCS 13  *//* MCS 12  *//* MCS 11  *//* MCS 10  *//* MCS  9  *//* MCS  8  *//* MCS  7  *//* MCS  6  *//* MCS  5  *//* MCS  4  *//* MCS  3  *//* MCS  2  *//* MCS  1  *//* MCS  0  *//*
 * Indices are:
 *
 *	the MCS index (0-76);
 *
 *	0 for 20 MHz, 1 for 40 MHz;
 *
 *	0 for a long guard interval, 1 for a short guard interval.
 *//* reserved 		16 *//* reserved 		19 *//* reserved 		18 *//* reserved 		17 *//* reserved 		15 *//* reserved 		14 *//* reserved 		13 *//* reserved 		12 *//* reserved 		11 *//* reserved 		10 *//* reserved 		9 *//* reserved 		8 *//* reserved 		7 *//* 1-253 + 1 for null *//* 32 + 1 for null *//*
 * Bits in the frame control field.
 *//*
 * The subtype field of a data frame is, in effect, composed of 4 flag
 * bits - CF-Ack, CF-Poll, Null (means the frame doesn't actually have
 * any data), and QoS.
 *//* RESERVED 			0xF  *//* RESERVED 			0xE  *//* RESERVED 			0x7  *//* RESERVED 			0x6  *//* reserved *//* data *//* control *//* management *//* Length of previous AP in reassocation frame *//* Lengths of beacon components. *//* Frame check sequence length. *//* Lengths of 802.11 header components. *//* \summary: IEEE 802.11 printer *//*
 * Copyright (c) 2001
 *	Fortress Technologies, Inc.  All rights reserved.
 *      Charlie Lenahan (clenahan@fortresstech.com)
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that: (1) source code distributions
 * retain the above copyright notice and this paragraph in its entirety, (2)
 * distributions including binary code include the above copyright notice and
 * this paragraph in its entirety in the documentation or other materials
 * provided with the distribution, and (3) all advertising materials mentioning
 * features or use of this software display the following acknowledgement:
 * ``This product includes software developed by the University of California,
 * Lawrence Berkeley Laboratory and its contributors.'' Neither the name of
 * the University nor the names of its contributors may be used to endorse
 * or promote products derived from this software without specific prior
 * written permission.
 * THIS SOFTWARE IS PROVIDED ``AS IS'' AND WITHOUT ANY EXPRESS OR IMPLIED
 * WARRANTIES, INCLUDING, WITHOUT LIMITATION, THE IMPLIED WARRANTIES OF
 * MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE.
 *//Users/owura/Repos/codeql_eval/proj_repos/the-tcpdump-group-tcpdump-commit-9ba91381954ad325ea4fd26b9c65a8bd9a2a85b6/tcpdump/print-802_15_4.cieee802_15_4_if_printpanid(ndo, "[|802.15.4]")[|802.15.4]p + 2(ndo,"IEEE 802.15.4 %s packet ", ftypes[FC_FRAME_TYPE(fc)])(ndo,"IEEE 802.15.4 %s packet ", ftypes[((fc) & 0x7)])IEEE 802.15.4 %s packet const char *[8]char *[8](ndo,"seq %02x ", seq)seq %02x (ndo,"none ")(ndo,"reserved destination addressing mode")(ndo,"%04x:%04x ", panid, EXTRACT_LE_16BITS(p))(ndo,"%04x:%04x ", panid, ((uint16_t)(((uint16_t)(*((const uint8_t *)(p) + 1)) << 8) | ((uint16_t)(*((const uint8_t *)(p) + 0)) << 0))))(ndo,"%04x:%s ", panid, le64addr_string(ndo, p))FC_ADDRESSING_MODE_NONEFC_PAN_ID_COMPRESSIONnone FC_ADDRESSING_MODE_RESERVEDreserved destination addressing modeFC_ADDRESSING_MODE_SHORT%04x:%04x FC_ADDRESSING_MODE_LONG%04x:%s (ndo,"< ")< (ndo,"reserved source addressing mode")reserved source addressing mode"Data"ACK"ACK"Command"Command"Reserved (0x4)"Reserved (0x4)"Reserved (0x5)"Reserved (0x5)"Reserved (0x6)"Reserved (0x6)"Reserved (0x7)"Reserved (0x7)"ftypesFC_SRC_ADDRESSING_MODE(fc)(((fc) >> 14) & 0x3)FC_FRAME_VERSION(fc)(((fc) >> 12) & 0x3)FC_DEST_ADDRESSING_MODE(fc)(((fc) >> 10) & 0x3)FC_ACK_REQUESTFC_FRAME_PENDINGFC_SECURITY_ENABLEDFC_FRAME_TYPE(fc)((fc) & 0x7)/*
			 * The source PAN ID is not compressed out, so
			 * fetch it.  (Otherwise, we'll use the destination
			 * PAN ID, fetched above.)
			 *//*
	 * Source address and PAN ID, if present.
	 *//*
			 * PAN ID compression; this requires that both
			 * the source and destination addresses be present,
			 * but the destination address is missing.
			 *//*
	 * Destination address and PAN ID, if present.
	 *//*
 * Frame Control subfields.
 *//* \summary: IEEE 802.15.4 printer *//*
 * Copyright (c) 2009
 * 	Siemens AG, All rights reserved.
 * 	Dmitry Eremin-Solenikov (dbaryshkov@gmail.com)
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that: (1) source code distributions
 * retain the above copyright notice and this paragraph in its entirety, (2)
 * distributions including binary code include the above copyright notice and
 * this paragraph in its entirety in the documentation or other materials
 * provided with the distribution, and (3) all advertising materials mentioning
 * features or use of this software display the following acknowledgement:
 * ``This product includes software developed by the University of California,
 * Lawrence Berkeley Laboratory and its contributors.'' Neither the name of
 * the University nor the names of its contributors may be used to endorse
 * or promote products derived from this software without specific prior
 * written permission.
 * THIS SOFTWARE IS PROVIDED ``AS IS'' AND WITHOUT ANY EXPRESS OR IMPLIED
 * WARRANTIES, INCLUDING, WITHOUT LIMITATION, THE IMPLIED WARRANTIES OF
 * MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE.
 *//Users/owura/Repos/codeql_eval/proj_repos/the-tcpdump-group-tcpdump-commit-9ba91381954ad325ea4fd26b9c65a8bd9a2a85b6/tcpdump/ah.hnewahah_seqah_spiah_reserveah_lenah_nxt_NETINET6_AH_H_/*_NETINET6_AH_H_*//* Authentication data *//* variable size, 32bit bound*//* Sequence number field *//* Security parameter index *//* Reserved for future use *//* Length of data + 1, in 32bit *//* Next Header *//* Length of data, in 32bit *//*
 * RFC1826/2402 authentication header.
 *//*
 * Copyright (C) 1995, 1996, 1997, and 1998 WIDE Project.
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. Neither the name of the project nor the names of its contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE PROJECT AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE PROJECT OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 *//*	$KAME: ah.h,v 1.12 2000/07/20 17:41:01 itojun Exp $	*//*	$NetBSD: ah.h,v 1.12 2000/07/23 05:23:04 itojun Exp $	*//Users/owura/Repos/codeql_eval/proj_repos/the-tcpdump-group-tcpdump-commit-9ba91381954ad325ea4fd26b9c65a8bd9a2a85b6/tcpdump/print-ah.c"ah.h"ah_printconst ahconst ah *ah *sumlen*ahsizeof(*ah)(ndo, "AH(spi=0x%08x", EXTRACT_32BITS(&ah->ah_spi))(ndo, "AH(spi=0x%08x", ((uint32_t)(((uint32_t)(*((const uint8_t *)(&ah->ah_spi) + 0)) << 24) | ((uint32_t)(*((const uint8_t *)(&ah->ah_spi) + 1)) << 16) | ((uint32_t)(*((const uint8_t *)(&ah->ah_spi) + 2)) << 8) | ((uint32_t)(*((const uint8_t *)(&ah->ah_spi) + 3)) << 0))))AH(spi=0x%08x&ah->ah_spi(ndo, ",sumlen=%d", sumlen),sumlen=%dah + 1*(ah + 1)(ndo, ",seq=0x%x", EXTRACT_32BITS(ah + 1))(ndo, ",seq=0x%x", ((uint32_t)(((uint32_t)(*((const uint8_t *)(ah + 1) + 0)) << 24) | ((uint32_t)(*((const uint8_t *)(ah + 1) + 1)) << 16) | ((uint32_t)(*((const uint8_t *)(ah + 1) + 2)) << 8) | ((uint32_t)(*((const uint8_t *)(ah + 1) + 3)) << 0)))),seq=0x%x*bpsizeof(struct ah) + sumlen(ndo, "[truncated]):")[truncated]):(ndo, "): ")): sizeof(struct ah)(ndo, "[|AH]")[|AH]/* \summary: IPSEC Authentication Header printer *//*
 * Copyright (c) 1988, 1989, 1990, 1991, 1992, 1993, 1994
 *	The Regents of the University of California.  All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that: (1) source code distributions
 * retain the above copyright notice and this paragraph in its entirety, (2)
 * distributions including binary code include the above copyright notice and
 * this paragraph in its entirety in the documentation or other materials
 * provided with the distribution, and (3) all advertising materials mentioning
 * features or use of this software display the following acknowledgement:
 * ``This product includes software developed by the University of California,
 * Lawrence Berkeley Laboratory and its contributors.'' Neither the name of
 * the University nor the names of its contributors may be used to endorse
 * or promote products derived from this software without specific prior
 * written permission.
 * THIS SOFTWARE IS PROVIDED ``AS IS'' AND WITHOUT ANY EXPRESS OR IMPLIED
 * WARRANTIES, INCLUDING, WITHOUT LIMITATION, THE IMPLIED WARRANTIES OF
 * MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE.
 *//*	$NetBSD: print-ah.c,v 1.4 1996/05/20 00:41:16 fvdl Exp $	*/bp/Users/owura/Repos/codeql_eval/proj_repos/the-tcpdump-group-tcpdump-commit-9ba91381954ad325ea4fd26b9c65a8bd9a2a85b6/tcpdump/print-ahcp.cahcp_printconst u_intversion(ndo, "AHCP")AHCP*cpAHCP_MAGIC_NUMBER(ndo, " Version 1")AHCP1_HEADER_FIX_LEN - 224 - 2(ndo, "\n\tHopcount %u", *cp)(ndo, ", Original Hopcount %u", *cp)(ndo, ", Nonce 0x%08x", EXTRACT_32BITS(cp))(ndo, ", Nonce 0x%08x", ((uint32_t)(((uint32_t)(*((const uint8_t *)(cp) + 0)) << 24) | ((uint32_t)(*((const uint8_t *)(cp) + 1)) << 16) | ((uint32_t)(*((const uint8_t *)(cp) + 2)) << 8) | ((uint32_t)(*((const uint8_t *)(cp) + 3)) << 0))))(ndo, ", Source Id %s", linkaddr_string(ndo, cp, 0, 8))(ndo, ", Destination Id %s", linkaddr_string(ndo, cp, 0, 8))(ndo, " Version %u (unknown)", version)AHCP_VERSION_1 Version 1AHCP1_HEADER_FIX_LEN
	Hopcount %u, Original Hopcount %u, Nonce 0x%08x, Source Id %s, Destination Id %s Version %u (unknown)invalid(ndo, "%s", istr)ep - cpconst char[9]ahcp1_body_printmbzbody_lenAHCP1_BODY_MIN_LEN(ndo, "\n\t%s", tok2str(ahcp1_msg_str, "Unknown-%u", type))(ndo, ", MBZ %u", mbz)(ndo, ", Length %u", body_len)
	%sconst tok[7]tok[7]Unknown-%u, MBZ %u, Length %uahcp1_options_printoption_nooption_len(ndo, "\n\t %s", tok2str(ahcp1_opt_str, "Unknown-%u", option_no))(ndo, " (Length %u)", option_len)
	 %sconst tok[15]tok[15]AHCP1_OPT_PADAHCP1_OPT_MANDATORYAHCP1_OPT_MAX..(*const)(..)..(*const[14])(..)..(*[14])(..)..(*const *)(..)..(**)(..) (Length %u)ahcp_ipv4_prefixes_print": "(ndo, "%s%s/%u", sep, ipaddr_string(ndo, cp), *(cp + 4))(ndo, "%s%s/%u", sep, getname(ndo, (const u_char *)(cp)), *(cp + 4))%s%s/%u, ", "ahcp_ipv6_prefixes_print(ndo, "%s%s/%u", sep, ip6addr_string(ndo, cp), *(cp + 16))(ndo, "%s%s/%u", sep, getname6(ndo, (const u_char *)(cp)), *(cp + 16))ahcp_ipv4_addresses_print(ndo, "%s%s", sep, ipaddr_string(ndo, cp))(ndo, "%s%s", sep, getname(ndo, (const u_char *)(cp)))%s%sahcp_ipv6_addresses_print(ndo, "%s%s", sep, ip6addr_string(ndo, cp))(ndo, "%s%s", sep, getname6(ndo, (const u_char *)(cp)))ahcp_seconds_print(ndo, ": %us", EXTRACT_32BITS(cp))(ndo, ": %us", ((uint32_t)(((uint32_t)(*((const uint8_t *)(cp) + 0)) << 24) | ((uint32_t)(*((const uint8_t *)(cp) + 1)) << 16) | ((uint32_t)(*((const uint8_t *)(cp) + 2)) << 8) | ((uint32_t)(*((const uint8_t *)(cp) + 3)) << 0)))): %usahcp_time_printtm(ndo, ": gmtime() error")(ndo, ": strftime() error")(ndo, ": %s UTC", buf): gmtime() errorchar *__restrict__const tmconst tm *const tm *__restrict__%Y-%m-%d %H:%M:%S"%Y-%m-%d %H:%M:%S": strftime() error: %s UTCdata_decodersPad"Pad"Mandatory"Mandatory"AHCP1_OPT_ORIGIN_TIMEOrigin Time"Origin Time"AHCP1_OPT_EXPIRESExpires"Expires"AHCP1_OPT_MY_IPV6_ADDRESSMy-IPv6-Address"My-IPv6-Address"AHCP1_OPT_MY_IPV4_ADDRESSMy-IPv4-Address"My-IPv4-Address"AHCP1_OPT_IPV6_PREFIXIPv6 Prefix"IPv6 Prefix"AHCP1_OPT_IPV4_PREFIXIPv4 Prefix"IPv4 Prefix"AHCP1_OPT_IPV6_ADDRESSIPv6 Address"IPv6 Address"AHCP1_OPT_IPV4_ADDRESSIPv4 Address"IPv4 Address"AHCP1_OPT_IPV6_PREFIX_DELEGATIONIPv6 Prefix Delegation"IPv6 Prefix Delegation"AHCP1_OPT_IPV4_PREFIX_DELEGATIONIPv4 Prefix Delegation"IPv4 Prefix Delegation"AHCP1_OPT_NAME_SERVERName Server"Name Server"AHCP1_OPT_NTP_SERVERNTP Server"NTP Server"ahcp1_opt_strAHCP1_MSG_DISCOVERDiscover"Discover"AHCP1_MSG_OFFEROffer"Offer"AHCP1_MSG_REQUESTRequest"Request"AHCP1_MSG_ACK"Ack"AHCP1_MSG_NACKNack"Nack"AHCP1_MSG_RELEASERelease"Release"ahcp1_msg_str [|ahcp]" [|ahcp]"/* Body *//* Destination Id *//* Source Id *//* Nonce *//* Original Hopcount *//* Hopcount *//* Version *//* Magic *//* not ep (ignore extra data) *//* Options *//* Length *//* MBZ *//* Type *//* truncated and already marked up *//* Value *//* Option no *//* [AHCP1_OPT_NTP_SERVER]             = *//* [AHCP1_OPT_NAME_SERVER]            = *//* [AHCP1_OPT_IPV4_PREFIX_DELEGATION] = *//* [AHCP1_OPT_IPV6_PREFIX_DELEGATION] = *//* [AHCP1_OPT_IPV4_ADDRESS]           = *//* [AHCP1_OPT_IPV6_ADDRESS]           = *//* [AHCP1_OPT_IPV4_PREFIX]            = *//* [AHCP1_OPT_IPV6_PREFIX]            = *//* [AHCP1_OPT_MY_IPV4_ADDRESS]        = *//* [AHCP1_OPT_MY_IPV6_ADDRESS]        = *//* [AHCP1_OPT_EXPIRES]                = *//* [AHCP1_OPT_ORIGIN_TIME]            = *//* [AHCP1_OPT_MANDATORY]              = *//* [AHCP1_OPT_PAD]                    = *//* Data decoders signal truncated data with -1. *//* Based on draft-chroboczek-ahcp-00 and source code of ahcpd-0.53 *//* \summary: Ad Hoc Configuration Protocol (AHCP) printer *//*
 * Copyright (c) 2013 The TCPDUMP project
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
 * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
 * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS
 * FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE
 * COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT,
 * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,
 * BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
 * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
 * CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN
 * ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
 * POSSIBILITY OF SUCH DAMAGE.
 *//Users/owura/Repos/codeql_eval/proj_repos/the-tcpdump-group-tcpdump-commit-9ba91381954ad325ea4fd26b9c65a8bd9a2a85b6/tcpdump/print-aodv.caodv_printmsg_type*datsizeof(*dat)(ndo, " aodv") aodv(ndo, " rrep-ack %u", length)(ndo, " type %u %u", msg_type, length)AODV_RREQAODV_RREPAODV_RERRAODV_RREP_ACK rrep-ack %uAODV_V6_DRAFT_01_RREQAODV_V6_DRAFT_01_RREPAODV_V6_DRAFT_01_RERRAODV_V6_DRAFT_01_RREP_ACK type %u %u(ndo, " [|aodv]") [|aodv]aodv_v6_draft_01_rerrdcconst aodv_rerrconst aodv_rerr *aodv_rerr *const rerr_unreach6_draft_01const rerr_unreach6_draft_01 *rerr_unreach6_draft_01 *dp6*apsizeof(*ap)(ndo, " rerr %s [items %u] [%u]:", ap->rerr_flags & RERR_NODELETE ? "[D]" : "", ap->rerr_dc, length)(ndo, " rerr %s [items %u] [%u]:", ap->rerr_flags & 0x80 ? "[D]" : "", ap->rerr_dc, length) rerr %s [items %u] [%u]:[D]*dp6sizeof(*dp6)(ndo, " {%s}(%ld)", ip6addr_string(ndo, &dp6->u_da), (unsigned long)EXTRACT_32BITS(&dp6->u_ds))(ndo, " {%s}(%ld)", getname6(ndo, (const u_char *)(&dp6->u_da)), (unsigned long)((uint32_t)(((uint32_t)(*((const uint8_t *)(&dp6->u_ds) + 0)) << 24) | ((uint32_t)(*((const uint8_t *)(&dp6->u_ds) + 1)) << 16) | ((uint32_t)(*((const uint8_t *)(&dp6->u_ds) + 2)) << 8) | ((uint32_t)(*((const uint8_t *)(&dp6->u_ds) + 3)) << 0))))&dp6->u_da&dp6->u_ds {%s}(%ld)const in6_addrconst in6_addr *(ndo, "[|rerr]")[|rerr]aodv_v6_draft_01_rrepconst aodv_rrep6_draft_01const aodv_rrep6_draft_01 *aodv_rrep6_draft_01 *(ndo, " rrep %u %s%sprefix %u hops %u\n" "\tdst %s dseq %lu src %s %lu ms", length, ap->rrep_type & RREP_REPAIR ? "[R]" : "", ap->rrep_type & RREP_ACK ? "[A] " : " ", ap->rrep_ps & RREP_PREFIX_MASK, ap->rrep_hops, ip6addr_string(ndo, &ap->rrep_da), (unsigned long)EXTRACT_32BITS(&ap->rrep_ds), ip6addr_string(ndo, &ap->rrep_oa), (unsigned long)EXTRACT_32BITS(&ap->rrep_life))(ndo, " rrep %u %s%sprefix %u hops %u\n" "\tdst %s dseq %lu src %s %lu ms", length, ap->rrep_type & 0x80 ? "[R]" : "", ap->rrep_type & 0x40 ? "[A] " : " ", ap->rrep_ps & 0x1F, ap->rrep_hops, getname6(ndo, (const u_char *)(&ap->rrep_da)), (unsigned long)((uint32_t)(((uint32_t)(*((const uint8_t *)(&ap->rrep_ds) + 0)) << 24) | ((uint32_t)(*((const uint8_t *)(&ap->rrep_ds) + 1)) << 16) | ((uint32_t)(*((const uint8_t *)(&ap->rrep_ds) + 2)) << 8) | ((uint32_t)(*((const uint8_t *)(&ap->rrep_ds) + 3)) << 0))), getname6(ndo, (const u_char *)(&ap->rrep_oa)), (unsigned long)((uint32_t)(((uint32_t)(*((const uint8_t *)(&ap->rrep_life) + 0)) << 24) | ((uint32_t)(*((const uint8_t *)(&ap->rrep_life) + 1)) << 16) | ((uint32_t)(*((const uint8_t *)(&ap->rrep_life) + 2)) << 8) | ((uint32_t)(*((const uint8_t *)(&ap->rrep_life) + 3)) << 0)))) rrep %u %s%sprefix %u hops %u
	dst %s dseq %lu src %s %lu mschar[62][R][A] &ap->rrep_da&ap->rrep_dsdatis_ip6&ap->rrep_oa&ap->rrep_lifesizeof(struct aodv_ext)const aodv_extconst aodv_ext *aodv_ext *(ndo, " [|rreq") [|rreqaodv_v6_draft_01_rreqconst aodv_rreq6_draft_01const aodv_rreq6_draft_01 *aodv_rreq6_draft_01 *(ndo, " rreq %u %s%s%s%s%shops %u id 0x%08lx\n" "\tdst %s seq %lu src %s seq %lu", length, ap->rreq_type & RREQ_JOIN ? "[J]" : "", ap->rreq_type & RREQ_REPAIR ? "[R]" : "", ap->rreq_type & RREQ_GRAT ? "[G]" : "", ap->rreq_type & RREQ_DEST ? "[D]" : "", ap->rreq_type & RREQ_UNKNOWN ? "[U] " : " ", ap->rreq_hops, (unsigned long)EXTRACT_32BITS(&ap->rreq_id), ip6addr_string(ndo, &ap->rreq_da), (unsigned long)EXTRACT_32BITS(&ap->rreq_ds), ip6addr_string(ndo, &ap->rreq_oa), (unsigned long)EXTRACT_32BITS(&ap->rreq_os))(ndo, " rreq %u %s%s%s%s%shops %u id 0x%08lx\n" "\tdst %s seq %lu src %s seq %lu", length, ap->rreq_type & 0x80 ? "[J]" : "", ap->rreq_type & 0x40 ? "[R]" : "", ap->rreq_type & 0x20 ? "[G]" : "", ap->rreq_type & 0x10 ? "[D]" : "", ap->rreq_type & 0x08 ? "[U] " : " ", ap->rreq_hops, (unsigned long)((uint32_t)(((uint32_t)(*((const uint8_t *)(&ap->rreq_id) + 0)) << 24) | ((uint32_t)(*((const uint8_t *)(&ap->rreq_id) + 1)) << 16) | ((uint32_t)(*((const uint8_t *)(&ap->rreq_id) + 2)) << 8) | ((uint32_t)(*((const uint8_t *)(&ap->rreq_id) + 3)) << 0))), getname6(ndo, (const u_char *)(&ap->rreq_da)), (unsigned long)((uint32_t)(((uint32_t)(*((const uint8_t *)(&ap->rreq_ds) + 0)) << 24) | ((uint32_t)(*((const uint8_t *)(&ap->rreq_ds) + 1)) << 16) | ((uint32_t)(*((const uint8_t *)(&ap->rreq_ds) + 2)) << 8) | ((uint32_t)(*((const uint8_t *)(&ap->rreq_ds) + 3)) << 0))), getname6(ndo, (const u_char *)(&ap->rreq_oa)), (unsigned long)((uint32_t)(((uint32_t)(*((const uint8_t *)(&ap->rreq_os) + 0)) << 24) | ((uint32_t)(*((const uint8_t *)(&ap->rreq_os) + 1)) << 16) | ((uint32_t)(*((const uint8_t *)(&ap->rreq_os) + 2)) << 8) | ((uint32_t)(*((const uint8_t *)(&ap->rreq_os) + 3)) << 0)))) rreq %u %s%s%s%s%shops %u id 0x%08lx
	dst %s seq %lu src %s seq %lu[J][G][U] &ap->rreq_id&ap->rreq_da&ap->rreq_ds&ap->rreq_oa&ap->rreq_osaodv_v6_rerrconst rerr_unreach6const rerr_unreach6 *rerr_unreach6 *aodv_v6_rrepconst aodv_rrep6const aodv_rrep6 *aodv_rrep6 *aodv_v6_rreqconst aodv_rreq6const aodv_rreq6 *aodv_rreq6 *(ndo, " v6 rreq %u %s%s%s%s%shops %u id 0x%08lx\n" "\tdst %s seq %lu src %s seq %lu", length, ap->rreq_type & RREQ_JOIN ? "[J]" : "", ap->rreq_type & RREQ_REPAIR ? "[R]" : "", ap->rreq_type & RREQ_GRAT ? "[G]" : "", ap->rreq_type & RREQ_DEST ? "[D]" : "", ap->rreq_type & RREQ_UNKNOWN ? "[U] " : " ", ap->rreq_hops, (unsigned long)EXTRACT_32BITS(&ap->rreq_id), ip6addr_string(ndo, &ap->rreq_da), (unsigned long)EXTRACT_32BITS(&ap->rreq_ds), ip6addr_string(ndo, &ap->rreq_oa), (unsigned long)EXTRACT_32BITS(&ap->rreq_os))(ndo, " v6 rreq %u %s%s%s%s%shops %u id 0x%08lx\n" "\tdst %s seq %lu src %s seq %lu", length, ap->rreq_type & 0x80 ? "[J]" : "", ap->rreq_type & 0x40 ? "[R]" : "", ap->rreq_type & 0x20 ? "[G]" : "", ap->rreq_type & 0x10 ? "[D]" : "", ap->rreq_type & 0x08 ? "[U] " : " ", ap->rreq_hops, (unsigned long)((uint32_t)(((uint32_t)(*((const uint8_t *)(&ap->rreq_id) + 0)) << 24) | ((uint32_t)(*((const uint8_t *)(&ap->rreq_id) + 1)) << 16) | ((uint32_t)(*((const uint8_t *)(&ap->rreq_id) + 2)) << 8) | ((uint32_t)(*((const uint8_t *)(&ap->rreq_id) + 3)) << 0))), getname6(ndo, (const u_char *)(&ap->rreq_da)), (unsigned long)((uint32_t)(((uint32_t)(*((const uint8_t *)(&ap->rreq_ds) + 0)) << 24) | ((uint32_t)(*((const uint8_t *)(&ap->rreq_ds) + 1)) << 16) | ((uint32_t)(*((const uint8_t *)(&ap->rreq_ds) + 2)) << 8) | ((uint32_t)(*((const uint8_t *)(&ap->rreq_ds) + 3)) << 0))), getname6(ndo, (const u_char *)(&ap->rreq_oa)), (unsigned long)((uint32_t)(((uint32_t)(*((const uint8_t *)(&ap->rreq_os) + 0)) << 24) | ((uint32_t)(*((const uint8_t *)(&ap->rreq_os) + 1)) << 16) | ((uint32_t)(*((const uint8_t *)(&ap->rreq_os) + 2)) << 8) | ((uint32_t)(*((const uint8_t *)(&ap->rreq_os) + 3)) << 0)))) v6 rreq %u %s%s%s%s%shops %u id 0x%08lx
	dst %s seq %lu src %s seq %luchar[72]aodv_rerrconst rerr_unreachconst rerr_unreach *rerr_unreach **dpsizeof(*dp)(ndo, " {%s}(%ld)", ipaddr_string(ndo, &dp->u_da), (unsigned long)EXTRACT_32BITS(&dp->u_ds))(ndo, " {%s}(%ld)", getname(ndo, (const u_char *)(&dp->u_da)), (unsigned long)((uint32_t)(((uint32_t)(*((const uint8_t *)(&dp->u_ds) + 0)) << 24) | ((uint32_t)(*((const uint8_t *)(&dp->u_ds) + 1)) << 16) | ((uint32_t)(*((const uint8_t *)(&dp->u_ds) + 2)) << 8) | ((uint32_t)(*((const uint8_t *)(&dp->u_ds) + 3)) << 0))))&dp->u_da&dp->u_dsaodv_rrepconst aodv_rrepconst aodv_rrep *aodv_rrep *(ndo, " rrep %u %s%sprefix %u hops %u\n" "\tdst %s dseq %lu src %s %lu ms", length, ap->rrep_type & RREP_REPAIR ? "[R]" : "", ap->rrep_type & RREP_ACK ? "[A] " : " ", ap->rrep_ps & RREP_PREFIX_MASK, ap->rrep_hops, ipaddr_string(ndo, &ap->rrep_da), (unsigned long)EXTRACT_32BITS(&ap->rrep_ds), ipaddr_string(ndo, &ap->rrep_oa), (unsigned long)EXTRACT_32BITS(&ap->rrep_life))(ndo, " rrep %u %s%sprefix %u hops %u\n" "\tdst %s dseq %lu src %s %lu ms", length, ap->rrep_type & 0x80 ? "[R]" : "", ap->rrep_type & 0x40 ? "[A] " : " ", ap->rrep_ps & 0x1F, ap->rrep_hops, getname(ndo, (const u_char *)(&ap->rrep_da)), (unsigned long)((uint32_t)(((uint32_t)(*((const uint8_t *)(&ap->rrep_ds) + 0)) << 24) | ((uint32_t)(*((const uint8_t *)(&ap->rrep_ds) + 1)) << 16) | ((uint32_t)(*((const uint8_t *)(&ap->rrep_ds) + 2)) << 8) | ((uint32_t)(*((const uint8_t *)(&ap->rrep_ds) + 3)) << 0))), getname(ndo, (const u_char *)(&ap->rrep_oa)), (unsigned long)((uint32_t)(((uint32_t)(*((const uint8_t *)(&ap->rrep_life) + 0)) << 24) | ((uint32_t)(*((const uint8_t *)(&ap->rrep_life) + 1)) << 16) | ((uint32_t)(*((const uint8_t *)(&ap->rrep_life) + 2)) << 8) | ((uint32_t)(*((const uint8_t *)(&ap->rrep_life) + 3)) << 0))))aodv_rreqconst aodv_rreqconst aodv_rreq *aodv_rreq *(ndo, " rreq %u %s%s%s%s%shops %u id 0x%08lx\n" "\tdst %s seq %lu src %s seq %lu", length, ap->rreq_type & RREQ_JOIN ? "[J]" : "", ap->rreq_type & RREQ_REPAIR ? "[R]" : "", ap->rreq_type & RREQ_GRAT ? "[G]" : "", ap->rreq_type & RREQ_DEST ? "[D]" : "", ap->rreq_type & RREQ_UNKNOWN ? "[U] " : " ", ap->rreq_hops, (unsigned long)EXTRACT_32BITS(&ap->rreq_id), ipaddr_string(ndo, &ap->rreq_da), (unsigned long)EXTRACT_32BITS(&ap->rreq_ds), ipaddr_string(ndo, &ap->rreq_oa), (unsigned long)EXTRACT_32BITS(&ap->rreq_os))(ndo, " rreq %u %s%s%s%s%shops %u id 0x%08lx\n" "\tdst %s seq %lu src %s seq %lu", length, ap->rreq_type & 0x80 ? "[J]" : "", ap->rreq_type & 0x40 ? "[R]" : "", ap->rreq_type & 0x20 ? "[G]" : "", ap->rreq_type & 0x10 ? "[D]" : "", ap->rreq_type & 0x08 ? "[U] " : " ", ap->rreq_hops, (unsigned long)((uint32_t)(((uint32_t)(*((const uint8_t *)(&ap->rreq_id) + 0)) << 24) | ((uint32_t)(*((const uint8_t *)(&ap->rreq_id) + 1)) << 16) | ((uint32_t)(*((const uint8_t *)(&ap->rreq_id) + 2)) << 8) | ((uint32_t)(*((const uint8_t *)(&ap->rreq_id) + 3)) << 0))), getname(ndo, (const u_char *)(&ap->rreq_da)), (unsigned long)((uint32_t)(((uint32_t)(*((const uint8_t *)(&ap->rreq_ds) + 0)) << 24) | ((uint32_t)(*((const uint8_t *)(&ap->rreq_ds) + 1)) << 16) | ((uint32_t)(*((const uint8_t *)(&ap->rreq_ds) + 2)) << 8) | ((uint32_t)(*((const uint8_t *)(&ap->rreq_ds) + 3)) << 0))), getname(ndo, (const u_char *)(&ap->rreq_oa)), (unsigned long)((uint32_t)(((uint32_t)(*((const uint8_t *)(&ap->rreq_os) + 0)) << 24) | ((uint32_t)(*((const uint8_t *)(&ap->rreq_os) + 1)) << 16) | ((uint32_t)(*((const uint8_t *)(&ap->rreq_os) + 2)) << 8) | ((uint32_t)(*((const uint8_t *)(&ap->rreq_os) + 3)) << 0))))aodv_extensionconst aodv_helloconst aodv_hello *aodv_hello **epsizeof(*ep)(ndo, "\n\text HELLO - bad length %u", ep->length)(ndo, "\n\text HELLO %ld ms", (unsigned long)EXTRACT_32BITS(&ah->interval))(ndo, "\n\text HELLO %ld ms", (unsigned long)((uint32_t)(((uint32_t)(*((const uint8_t *)(&ah->interval) + 0)) << 24) | ((uint32_t)(*((const uint8_t *)(&ah->interval) + 1)) << 16) | ((uint32_t)(*((const uint8_t *)(&ah->interval) + 2)) << 8) | ((uint32_t)(*((const uint8_t *)(&ah->interval) + 3)) << 0))))&ah->interval(ndo, "\n\text %u %u", ep->type, ep->length)AODV_EXT_HELLOsizeof(struct aodv_hello)
	ext HELLO - bad length %u
	ext HELLO %ld msconst uint8_t[4]const uint8_t(*)[4]unsigned char(*)[4]
	ext %u %u(ndo, " [|hello]") [|hello]aodv_helloaodv_extaodv_rrep_ackrerr_unreach6_draft_01rerr_unreach6rerr_unreachaodv_rrep6_draft_01aodv_rrep6aodv_rreq6_draft_01aodv_rreq6intervalehra_zero0ra_typererr_dcrerr_zero0rerr_flagsrerr_typeu_dsu_darrep_liferrep_oarrep_darrep_dsrrep_hopsrrep_psrrep_flagsrrep_typerreq_oarreq_darreq_osrreq_dsrreq_idrreq_hopsrreq_zero0rreq_flagsrreq_typeRERR_FLAGS_MASKRERR_NODELETERREP_PREFIX_MASK0x1FRREP_FLAGS_MASK0xC0RREP_ACKRREP_REPAIRRREQ_FLAGS_MASK0xF8RREQ_UNKNOWNRREQ_DESTRREQ_GRATRREQ_REPAIRRREQ_JOIN/*
	 * The message type is the first byte; make sure we have it
	 * and then fetch it.
	 *//* expect my next hello in
						 * (n) ms
						 * NOTE: this is not aligned *//* extension header *//* extension length *//* extension type *//* IPV6 route response acknowledgment *//* IPv6 error report *//* IPv6 route response *//* IPv6 route request *//* route response acknowledgement *//* error report *//* route response *//* route request *//* mask for rerr_flags *//* don't delete the link *//* destination count *//* reserved, set to zero *//* various flags *//* AODV message type (3 or 18) *//* sequence number *//* IPv6 address *//* IPv4 address *//* mask for prefix size *//* mask for rrep_flags *//* acknowledgement required *//* repair (reserved for multicast *//* lifetime of this route *//* originator IPv6 address *//* destination IPv6 address *//* destination sequence number *//* number of hops from o to d *//* prefix size *//* AODV message type (17) *//* AODV message type (2) *//* originator IPv4 address *//* destination IPv4 address *//* mask for rreq_flags *//* unknown destination sequence num *//* destination only *//* gratuitous RREP *//* join (reserved for multicast *//* originator sequence number *//* request ID *//* number of hops from originator *//* AODV message type (16) *//* AODV message type (1) *//*
 * RFC 3561
 *//* \summary: Ad hoc On-Demand Distance Vector (AODV) Routing printer *//*
 * Copyright (c) 2003 Bruce M. Simpson <bms@spc.org>
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *        This product includes software developed by Bruce M. Simpson.
 * 4. Neither the name of Bruce M. Simpson nor the names of co-
 *    contributors may be used to endorse or promote products derived
 *    from this software without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY Bruce M. Simpson AND CONTRIBUTORS
 * ``AS IS'' AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED
 * TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
 * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL Bruce M. Simpson OR CONTRIBUTORS
 * BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
 * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
 * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
 * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
 * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
 * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
 * POSSIBILITY OF SUCH DAMAGE.
 *//Users/owura/Repos/codeql_eval/proj_repos/the-tcpdump-group-tcpdump-commit-9ba91381954ad325ea4fd26b9c65a8bd9a2a85b6/tcpdump/ether.hether_headerether_length_typeether_shostether_dhostETHER_HDRLENETHERMTU1500/*
 * Length of an Ethernet header; note that some compilers may pad
 * "struct ether_header" to a multiple of 4 bytes, for example, so
 * "sizeof (struct ether_header)" may not give the right answer.
 *//*
 * Structure of an Ethernet header.
 *//*
 * The number of bytes in an ethernet (MAC) address.
 *//*
 * Copyright (c) 1982, 1986, 1993
 *	The Regents of the University of California.  All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *	This product includes software developed by the University of
 *	California, Berkeley and its contributors.
 * 4. Neither the name of the University nor the names of its contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 *
 *	@(#)if_ether.h	8.3 (Berkeley) 5/2/95
 *//Users/owura/Repos/codeql_eval/proj_repos/the-tcpdump-group-tcpdump-commit-9ba91381954ad325ea4fd26b9c65a8bd9a2a85b6/tcpdump/print-aoe.c"ether.h"aoe_printver(ndo, "AoE length %u", len)AoE length %u0xF0(ndo, ", Ver %u", ver), Ver %uAOE_V1const char[8]aoev1_printcommandcmd_decoderAOEV1_COMMON_HDR_LEN0x0F(ndo, ", Flags: [%s]", bittok2str(aoev1_flag_str, "none", flags)), Flags: [%s]const tok[5]tok[5]none(ndo, "\n\tError: %s", tok2str(aoev1_errcode_str, "Invalid (%u)", *cp))AOEV1_FLAG_E
	Error: %sInvalid (%u)(ndo, "\n\tMajor: 0x%04x", EXTRACT_16BITS(cp))(ndo, "\n\tMajor: 0x%04x", ((uint16_t)(((uint16_t)(*((const uint8_t *)(cp) + 0)) << 8) | ((uint16_t)(*((const uint8_t *)(cp) + 1)) << 0))))
	Major: 0x%04x(ndo, ", Minor: 0x%02x", *cp), Minor: 0x%02x(ndo, ", Command: %s", tok2str(cmdcode_str, "Unknown (0x%02x)", command)), Command: %sUnknown (0x%02x)(ndo, ", Tag: 0x%08x", EXTRACT_32BITS(cp))(ndo, ", Tag: 0x%08x", ((uint32_t)(((uint32_t)(*((const uint8_t *)(cp) + 0)) << 24) | ((uint32_t)(*((const uint8_t *)(cp) + 1)) << 16) | ((uint32_t)(*((const uint8_t *)(cp) + 2)) << 8) | ((uint32_t)(*((const uint8_t *)(cp) + 3)) << 0)))), Tag: 0x%08xAOEV1_CMD_ISSUE_ATA_COMMANDAOEV1_CMD_QUERY_CONFIG_INFORMATIONAOEV1_CMD_MAC_MASK_LISTAOEV1_CMD_RESERVE_RELEASEaoev1_reserve_printnmacsAOEV1_RESERVE_ARG_LEN(ndo, "\n\tRCmd: %s", tok2str(aoev1_rcmd_str, "Unknown (0x%02x)", *cp))
	RCmd: %s(ndo, ", NMacs: %u", nmacs), NMacs: %u(ndo, "\n\tEthernet Address %u: %s", i, etheraddr_string(ndo, cp))
	Ethernet Address %u: %saoev1_mac_printdircountAOEV1_MAC_ARG_LEN(ndo, "\n\tMCmd: %s", tok2str(aoev1_mcmd_str, "Unknown (0x%02x)", *cp))
	MCmd: %s(ndo, ", MError: %s", tok2str(aoev1_merror_str, "Unknown (0x%02x)", *cp)), MError: %s(ndo, ", Dir Count: %u", dircount), Dir Count: %u(ndo, "\n\t DCmd: %s", tok2str(aoev1_dcmd_str, "Unknown (0x%02x)", *cp))(ndo, ", Ethernet Address: %s", etheraddr_string(ndo, cp))
	 DCmd: %s, Ethernet Address: %saoev1_query_printcslenAOEV1_QUERY_ARG_LEN(ndo, "\n\tBuffer Count: %u", EXTRACT_16BITS(cp))(ndo, "\n\tBuffer Count: %u", ((uint16_t)(((uint16_t)(*((const uint8_t *)(cp) + 0)) << 8) | ((uint16_t)(*((const uint8_t *)(cp) + 1)) << 0))))
	Buffer Count: %u(ndo, ", Firmware Version: %u", EXTRACT_16BITS(cp))(ndo, ", Firmware Version: %u", ((uint16_t)(((uint16_t)(*((const uint8_t *)(cp) + 0)) << 8) | ((uint16_t)(*((const uint8_t *)(cp) + 1)) << 0)))), Firmware Version: %u(ndo, ", Sector Count: %u", *cp), Sector Count: %u(ndo, ", AoE: %u, CCmd: %s", (*cp & 0xF0) >> 4, tok2str(aoev1_ccmd_str, "Unknown (0x02x)", *cp & 0x0F)), AoE: %u, CCmd: %sconst tok[6]tok[6]Unknown (0x02x)AOEV1_MAX_CONFSTR_LEN(ndo, "\n\tConfig String (length %u): ", cslen)
	Config String (length %u): aoev1_issue_printAOEV1_ISSUE_ARG_LEN(ndo, "\n\tAFlags: [%s]", bittok2str(aoev1_aflag_str, "none", *cp))
	AFlags: [%s](ndo, ", Err/Feature: %u", *cp), Err/Feature: %u(ndo, ", Cmd/Status: %u", *cp), Cmd/Status: %u(ndo, "\n\tlba0: %u", *cp)
	lba0: %u(ndo, ", lba1: %u", *cp), lba1: %u(ndo, ", lba2: %u", *cp), lba2: %u(ndo, ", lba3: %u", *cp), lba3: %u(ndo, ", lba4: %u", *cp), lba4: %u(ndo, ", lba5: %u", *cp), lba5: %u(ndo, "\n\tData: %u bytes", len - AOEV1_ISSUE_ARG_LEN)(ndo, "\n\tData: %u bytes", len - 12U)
	Data: %u bytesRead reserve list"Read reserve list"Set reserve list"Set reserve list"Force set reserve list"Force set reserve list"aoev1_rcmd_strNo Directive"No Directive"Add mac address to mask list"Add mac address to mask list"Delete mac address from mask list"Delete mac address from mask list"aoev1_dcmd_strUnspecified Error"Unspecified Error"Bad DCmd directive"Bad DCmd directive"Mask list full"Mask list full"aoev1_merror_strRead Mac Mask List"Read Mac Mask List"Edit Mac Mask List"Edit Mac Mask List"aoev1_mcmd_strread config string"read config string"test config string"test config string"test config string prefix"test config string prefix"set config string"set config string"force set config string"force set config string"aoev1_ccmd_strMBZ-0x08"MBZ-0x08"AOEV1_AFLAG_EExt48"Ext48"MBZ-0x06"MBZ-0x06"AOEV1_AFLAG_DDevice"Device"MBZ-0x04"MBZ-0x04"MBZ-0x03"MBZ-0x03"AOEV1_AFLAG_AAsync"Async"AOEV1_AFLAG_WWrite"Write"aoev1_aflag_strUnrecognized command code"Unrecognized command code"Bad argument parameter"Bad argument parameter"Device unavailable"Device unavailable"Config string present"Config string present"Unsupported version"Unsupported version"Target is reserved"Target is reserved"aoev1_errcode_strAOEV1_FLAG_RResponse"Response"Error"Error"MBZ-0x02"MBZ-0x02"MBZ-0x01"MBZ-0x01"aoev1_flag_strIssue ATA Command"Issue ATA Command"Query Config Information"Query Config Information"MAC Mask List"MAC Mask List"Reserve/Release"Reserve/Release"cmdcode_str [|aoe]" [|aoe]"1024U2U4U8U12U10UATA_SECTOR_SIZE/* Don't advance cp yet: low order 4 bits are version-specific. *//* Ver/Flags *//* Arg *//* Tag *//* Command *//* Minor *//* Major *//* Error *//* Flags *//* cp points to the Ver/Flags octet *//* addresses *//* NMacs (correlated with the length) *//* RCmd *//* Ethernet Address *//* DCmd *//* Reserved *//* directives *//* Dir Count *//* MError *//* MCmd *//* Config String *//* Config String Length *//* AoE/CCmd *//* Sector Count *//* Firmware Version *//* Buffer Count *//* Data *//* lba5 *//* lba4 *//* lba3 *//* lba2 *//* lba1 *//* lba0 *//* Cmd/Status *//* Sector Count (not correlated with the length) *//* Err/Feature *//* AFlags *//* up to but w/o Ethernet address 0 *//* up to but w/o Directive 0        *//* up to but w/o Config String      *//* up to but w/o Data               *//* up to but w/o Arg                *//* specification: http://brantleycoilecompany.com/AoEr11.pdf *//* \summary: ATA over Ethernet (AoE) protocol printer *//*
 * Copyright (c) 2014 The TCPDUMP project
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
 * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
 * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS
 * FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE
 * COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT,
 * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,
 * BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
 * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
 * CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN
 * ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
 * POSSIBILITY OF SUCH DAMAGE.
 *//Users/owura/Repos/codeql_eval/proj_repos/the-tcpdump-group-tcpdump-commit-9ba91381954ad325ea4fd26b9c65a8bd9a2a85b6/tcpdump/print-ap1394.cap1394_if_printconst firewire_headerconst firewire_header *firewire_header *ether_type(ndo, "[|ap1394]")FIREWIRE_HDRLEN[|ap1394]&fp->firewire_typeconst u_shortconst u_short *u_char[8]FIREWIRE_EUI64_LENap1394_hdr_printfirewire_type(ndo, "%s > %s", fwaddr_string(ndo, fp->firewire_shost), fwaddr_string(ndo, fp->firewire_dhost))%s > %s(ndo, ", ethertype %s (0x%04x)", tok2str(ethertype_values,"Unknown", firewire_type), firewire_type)(ndo, ", %s", tok2str(ethertype_values,"Unknown Ethertype (0x%04x)", firewire_type)), ethertype %s (0x%04x), %sUnknown Ethertype (0x%04x)(ndo, ", length %u: ", length), length %u: fwaddr_stringfirewire_headerfirewire_shostfirewire_dhost/* ether_type not known, print raw packet *//*
 * This is the top level routine of the printer.  'p' points
 * to the ether header of the packet, 'h->ts' is the timestamp,
 * 'h->len' is the length of the packet off the wire, and 'h->caplen'
 * is the number of bytes actually captured.
 *//*
 * Length of that header; note that some compilers may pad
 * "struct firewire_header" to a multiple of 4 bytes, for example, so
 * "sizeof (struct firewire_header)" may not give the right answer.
 *//*
 * Structure of a header for Apple's IP-over-IEEE 1384 BPF header.
 *//* \summary: Apple IP-over-IEEE 1394 printer *//*
 * Copyright (c) 1988, 1989, 1990, 1991, 1992, 1993, 1994, 1995, 1996, 1997, 2000
 *	The Regents of the University of California.  All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that: (1) source code distributions
 * retain the above copyright notice and this paragraph in its entirety, (2)
 * distributions including binary code include the above copyright notice and
 * this paragraph in its entirety in the documentation or other materials
 * provided with the distribution, and (3) all advertising materials mentioning
 * features or use of this software display the following acknowledgement:
 * ``This product includes software developed by the University of California,
 * Lawrence Berkeley Laboratory and its contributors.'' Neither the name of
 * the University nor the names of its contributors may be used to endorse
 * or promote products derived from this software without specific prior
 * written permission.
 * THIS SOFTWARE IS PROVIDED ``AS IS'' AND WITHOUT ANY EXPRESS OR IMPLIED
 * WARRANTIES, INCLUDING, WITHOUT LIMITATION, THE IMPLIED WARRANTIES OF
 * MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE.
 *//Users/owura/Repos/codeql_eval/proj_repos/the-tcpdump-group-tcpdump-commit-9ba91381954ad325ea4fd26b9c65a8bd9a2a85b6/tcpdump/print-arcnet.carcnet_encap_print(ndo, "et1 ")ARCTYPE_IP_OLD212ARCTYPE_IPARCTYPE_INET6241ARCTYPE_ARP_OLD213ARCTYPE_ARP214ARCTYPE_REVARP221ARCTYPE_ATALKet1 250ARCTYPE_IPXarcnet_linux_if_printconst arc_linux_headerconst arc_linux_header *arc_linux_header *archdrlenarc_type(ndo, "[|arcnet]")ARC_LINUX_HDRLEN[|arcnet]ARC_LINUX_HDRNEWLENARCTYPE_DIAGNOSEarcnet_if_printconst arc_headerconst arc_header *arc_header *phdsflagseqidARC_HDRLEN(ndo, "[|phds]")(ndo, "[|phds extended]")&ap->arc_seqid2&ap->arc_seqidARC_HDRNEWLEN[|phds]ARC_HDRNEWLEN_EXC[|phds extended]arcnet_printarctypename(ndo, "%02x %02x %d: ", ap->arc_shost, ap->arc_dhost, length)%02x %02x %d: const tok[11]tok[11]%02x"%02x"(ndo, "%02x %02x %s %d: ", ap->arc_shost, ap->arc_dhost, arctypename, length)%02x %02x %s %d: (ndo, "%02x %02x %s seqid %04x %d: ", ap->arc_shost, ap->arc_dhost, arctypename, seqid, length)%02x %02x %s seqid %04x %d: (ndo, "%02x %02x %s seqid %04x " "(first of %d fragments) %d: ", ap->arc_shost, ap->arc_dhost, arctypename, seqid, (flag + 3) / 2, length)(ndo, "%02x %02x %s seqid %04x " "(fragment %d) %d: ", ap->arc_shost, ap->arc_dhost, arctypename, seqid, flag/2 + 1, length)%02x %02x %s seqid %04x (first of %d fragments) %d: %02x %02x %s seqid %04x (fragment %d) %d: char[43]arc_linux_headerarc_headerarc_seqidarc_flagarc_offsetarc_dhostarc_shostarc_seqid2arc_flag2arc_type2oldip"oldip"oldarp"oldarp"247ARCTYPE_BANIANbanyan"banyan"ipx"ipx"diag"diag"arctypemap0xc4/*
 * Local Variables:
 * c-style: bsd
 * End:
 *//* XXX was this ever used? *//*
 * Prints the packet encapsulated in an ARCnet data field,
 * given the ARCnet system code.
 *
 * Returns non-zero if it can do so, zero if the system code is unknown.
 *//*
	 * Go past the ARCNET header.
	 *//*
 * This is the top level routine of the printer.  'p' points
 * to the ARCNET header of the packet, 'h->ts' is the timestamp,
 * 'h->len' is the length of the packet off the wire, and 'h->caplen'
 * is the number of bytes actually captured.  It is quite similar
 * to the non-Linux style printer except that Linux doesn't ever
 * supply packets that look like exception frames, it always supplies
 * reassembled packets rather than raw frames, and headers have an
 * extra "offset" field between the src/dest and packet type.
 *//*
		 * This is a middle fragment.
		 *//*
 * This is the top level routine of the printer.  'p' points
 * to the ARCNET header of the packet, 'h->ts' is the timestamp,
 * 'h->len' is the length of the packet off the wire, and 'h->caplen'
 * is the number of bytes actually captured.
 *//*
	 * only present for newstyle encoding with LL fragmentation.
	 * Don't use sizeof(anything), use ARC_LINUX_HDR{,NEW}LEN
	 * instead.
	 *//*
 * Structure of a 2.5MB/s Arcnet header on Linux.  Linux has
 * an extra "offset" field when given to interface code, and
 * never presents packets that look like exception frames.
 *//* as per ANSI/ATA 878.1 *//* IPng *//* Novell IPX *//* Banyan Vines *//* reverse addr resolution protocol *//* address resolution protocol *//* RFC 1201 *//* RFC 1051 *//* real seqid value *//* real flag value *//* same as arc_type *//*
	 * only present in exception packets (arc_flag == 0xff)
	 *//*
	 * only present for newstyle encoding with LL fragmentation.
	 * Don't use sizeof(anything), use ARC_HDR{,NEW}LEN instead.
	 *//*
 * Structure of a 2.5MB/s Arcnet header on the BSDs,
 * as given to interface code.
 *//*
 * from: NetBSD: if_arc.h,v 1.13 1999/11/19 20:41:19 thorpej Exp
 *//* \summary: Attached Resource Computer NETwork (ARCNET) printer *//*
 * Copyright (c) 1988, 1989, 1990, 1991, 1992, 1993, 1994, 1995, 1996, 1997
 *	The Regents of the University of California.  All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that: (1) source code distributions
 * retain the above copyright notice and this paragraph in its entirety, (2)
 * distributions including binary code include the above copyright notice and
 * this paragraph in its entirety in the documentation or other materials
 * provided with the distribution, and (3) all advertising materials mentioning
 * features or use of this software display the following acknowledgement:
 * ``This product includes software developed by the University of California,
 * Lawrence Berkeley Laboratory and its contributors.'' Neither the name of
 * the University nor the names of its contributors may be used to endorse
 * or promote products derived from this software without specific prior
 * written permission.
 * THIS SOFTWARE IS PROVIDED ``AS IS'' AND WITHOUT ANY EXPRESS OR IMPLIED
 * WARRANTIES, INCLUDING, WITHOUT LIMITATION, THE IMPLIED WARRANTIES OF
 * MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE.
 *
 * From: NetBSD: print-arcnet.c,v 1.2 2000/04/24 13:02:28 itojun Exp
 */arctype/Users/owura/Repos/codeql_eval/proj_repos/the-tcpdump-group-tcpdump-commit-9ba91381954ad325ea4fd26b9c65a8bd9a2a85b6/tcpdump/print-arp.carp_printconst arp_pkthdrconst arp_pkthdr *arp_pkthdr *prohrdoplinkaddr&(ap)->ar_hrd&(ap)->ar_pro&(ap)->ar_opARPHRD_ATM2225ARPHRD_FRELAY*TPA(ap)*((((const u_char *)((ap)+1))+2*(ap)->ar_hln+(ap)->ar_pln))PROTO_LEN(ap)((ap)->ar_pln)(const u_char *)apconst char[7](ndo, "ARP, ")ARP, (ndo, "%s (len %u), %s (len %u)", tok2str(arphrd_values, "Unknown Hardware (%u)", hrd), HRD_LEN(ap), tok2str(ethertype_values, "Unknown Protocol (0x%04x)", pro), PROTO_LEN(ap))(ndo, "%s (len %u), %s (len %u)", tok2str(arphrd_values, "Unknown Hardware (%u)", hrd), ((ap)->ar_hln), tok2str(ethertype_values, "Unknown Protocol (0x%04x)", pro), ((ap)->ar_pln))%s (len %u), %s (len %u)const tok[8]tok[8]Unknown Hardware (%u)Unknown Protocol (0x%04x)(ndo, "%s%s ", ndo->ndo_vflag ? ", " : "", tok2str(arpop_values, "Unknown (%u)", op))%s%s Unknown (%u)(ndo, "who-has ")(ndo, " (%s)", linkaddr_string(ndo, THA(ap), linkaddr, HRD_LEN(ap)))(ndo, " (%s)", linkaddr_string(ndo, ((((const u_char *)((ap)+1))+ (ap)->ar_hln+(ap)->ar_pln)), linkaddr, ((ap)->ar_hln)))(ndo, " tell ")(ndo, " is-at %s", linkaddr_string(ndo, SHA(ap), linkaddr, HRD_LEN(ap)))(ndo, " is-at %s", linkaddr_string(ndo, ((((const u_char *)((ap)+1))+ 0)), linkaddr, ((ap)->ar_hln)))(ndo, "who-is %s tell %s", linkaddr_string(ndo, THA(ap), linkaddr, HRD_LEN(ap)), linkaddr_string(ndo, SHA(ap), linkaddr, HRD_LEN(ap)))(ndo, "who-is %s tell %s", linkaddr_string(ndo, ((((const u_char *)((ap)+1))+ (ap)->ar_hln+(ap)->ar_pln)), linkaddr, ((ap)->ar_hln)), linkaddr_string(ndo, ((((const u_char *)((ap)+1))+ 0)), linkaddr, ((ap)->ar_hln)))(ndo, "%s at ", linkaddr_string(ndo, THA(ap), linkaddr, HRD_LEN(ap)))(ndo, "%s at ", linkaddr_string(ndo, ((((const u_char *)((ap)+1))+ (ap)->ar_hln+(ap)->ar_pln)), linkaddr, ((ap)->ar_hln)))(ndo,"%s at ", linkaddr_string(ndo, SHA(ap), linkaddr, HRD_LEN(ap)))(ndo,"%s at ", linkaddr_string(ndo, ((((const u_char *)((ap)+1))+ 0)), linkaddr, ((ap)->ar_hln)))ARPOP_REQUESTwho-has  (%s) tell ARPOP_REPLY is-at %sARPOP_REVREQUESTwho-is %s tell %sARPOP_REVREPLY%s at ARPOP_INVREQUESTARPOP_INVREPLYout(ndo, ", length %u", length), length %uatmarp_printconst atmarp_pkthdrconst atmarp_pkthdr *atmarp_pkthdr *&(ap)->aar_hrd&(ap)->aar_pro&(ap)->aar_op*aar_tpa(ap)*(((((((const u_char *)((ap)+1)) + ((ap)->aar_shtl & 0x3F)) + ((ap)->aar_sstl & 0x3F)) + ((ap)->aar_spln)) + ((ap)->aar_thtl & 0x3F)) + ((ap)->aar_tstl & 0x3F))ATMTPROTO_LEN(ap)((ap)->aar_tpln)(ndo, "%s, %s (len %u/%u)", tok2str(arphrd_values, "Unknown Hardware (%u)", hrd), tok2str(ethertype_values, "Unknown Protocol (0x%04x)", pro), ATMSPROTO_LEN(ap), ATMTPROTO_LEN(ap))(ndo, "%s, %s (len %u/%u)", tok2str(arphrd_values, "Unknown Hardware (%u)", hrd), tok2str(ethertype_values, "Unknown Protocol (0x%04x)", pro), ((ap)->aar_spln), ((ap)->aar_tpln))%s, %s (len %u/%u)(ndo, " is-at ")(ndo, "who-is ")(ndo, "at ")(ndo, "for ") is-at who-is at ARPOP_NAKfor atmarp_spaddr_print(ndo, "<wrong proto type>")(ndo, "<wrong splen>")(ndo, "%s", ipaddr_string(ndo, ATMSPA(ap)))(ndo, "%s", getname(ndo, (const u_char *)((((((const u_char *)((ap)+1)) + ((ap)->aar_shtl & 0x3F)) + ((ap)->aar_sstl & 0x3F))))))ATMSPA(ap)(((((const u_char *)((ap)+1)) + ((ap)->aar_shtl & 0x3F)) + ((ap)->aar_sstl & 0x3F)))<wrong proto type><wrong splen>atmarp_tpaddr_print(ndo, "<wrong tplen>")(ndo, "%s", ipaddr_string(ndo, ATMTPA(ap)))(ndo, "%s", getname(ndo, (const u_char *)(((((((((const u_char *)((ap)+1)) + ((ap)->aar_shtl & 0x3F)) + ((ap)->aar_sstl & 0x3F)) + ((ap)->aar_spln)) + ((ap)->aar_thtl & 0x3F)) + ((ap)->aar_tstl & 0x3F))))))ATMTPA(ap)((((((((const u_char *)((ap)+1)) + ((ap)->aar_shtl & 0x3F)) + ((ap)->aar_sstl & 0x3F)) + ((ap)->aar_spln)) + ((ap)->aar_thtl & 0x3F)) + ((ap)->aar_tstl & 0x3F)))<wrong tplen>atmarp_addr_print(ndo, "<No address>")(ndo, "%s", linkaddr_string(ndo, ha, LINKADDR_ATM, ha_len))(ndo, ",%s", linkaddr_string(ndo, srca, LINKADDR_ATM, srca_len))<No address>,%sspaddr_print_ip(ndo, "<wrong len>")(ndo, "%s", ipaddr_string(ndo, SPA(ap)))(ndo, "%s", getname(ndo, (const u_char *)(((((const u_char *)((ap)+1))+ (ap)->ar_hln)))))SPA(ap)((((const u_char *)((ap)+1))+ (ap)->ar_hln))<wrong len>tpaddr_print_ip(ndo, "%s", ipaddr_string(ndo, TPA(ap)))(ndo, "%s", getname(ndo, (const u_char *)(((((const u_char *)((ap)+1))+2*(ap)->ar_hln+(ap)->ar_pln)))))TPA(ap)((((const u_char *)((ap)+1))+2*(ap)->ar_hln+(ap)->ar_pln))isnonzeroatmarp_pkthdrarp_pkthdraar_tplnaar_tstlaar_thtlaar_splnaar_opaar_sstlaar_shtlaar_proaar_hrdar_opar_plnar_hlnar_proar_hrdARPHRD_ETHERARPHRD_IEEE802TokenRing"TokenRing"ARPHRD_ARCNETArcNet"ArcNet"FrameRelay"FrameRelay"ARPHRD_STRIPStrip"Strip"ARPHRD_IEEE1394IEEE 1394"IEEE 1394"ATM"ATM"arphrd_valuesReply"Reply"Reverse Request"Reverse Request"Reverse Reply"Reverse Reply"Inverse Request"Inverse Request"haha_lensrcasrca_lenaInverse Reply"Inverse Reply"NACK Reply"NACK Reply"arpop_values[|ARP]"[|ARP]"(aar_tpa(ap))ATMTSA(ap)(aar_tsa(ap))ATMTHA(ap)(aar_tha(ap))(aar_spa(ap))ATMSSA(ap)(aar_ssa(ap))ATMSHA(ap)(aar_sha(ap))aar_tpa(ap)(aar_tsa(ap) + ATMTSLN(ap))aar_tsa(ap)(aar_tha(ap) + ATMTHRD_LEN(ap))aar_tha(ap)(aar_spa(ap) + ATMSPROTO_LEN(ap))aar_spa(ap)(aar_ssa(ap) + ATMSSLN(ap))aar_ssa(ap)(aar_sha(ap) + ATMSHRD_LEN(ap))aar_sha(ap)((const u_char *)((ap)+1))ATMTSLN(ap)((ap)->aar_tstl & ATMARP_LEN_MASK)ATMTHRD_LEN(ap)((ap)->aar_thtl & ATMARP_LEN_MASK)ATMPRO(ap)EXTRACT_16BITS(&(ap)->aar_pro)ATMOP(ap)EXTRACT_16BITS(&(ap)->aar_op)ATMSPROTO_LEN(ap)((ap)->aar_spln)ATMSSLN(ap)((ap)->aar_sstl & ATMARP_LEN_MASK)ATMSHRD_LEN(ap)((ap)->aar_shtl & ATMARP_LEN_MASK)ATMHRD(ap)EXTRACT_16BITS(&(ap)->aar_hrd)ATMARP_LEN_MASK0x3FATMARP_IS_E164(ar_tpa(ap))THA(ap)(ar_tha(ap))(ar_spa(ap))SHA(ap)(ar_sha(ap))PRO(ap)EXTRACT_16BITS(&(ap)->ar_pro)OP(ap)EXTRACT_16BITS(&(ap)->ar_op)HRD_LEN(ap)((ap)->ar_hln)HRD(ap)EXTRACT_16BITS(&(ap)->ar_hrd)ARP_HDRLENar_tpa(ap)(((const u_char *)((ap)+1))+2*(ap)->ar_hln+(ap)->ar_pln)ar_tha(ap)(((const u_char *)((ap)+1))+ (ap)->ar_hln+(ap)->ar_pln)ar_spa(ap)(((const u_char *)((ap)+1))+ (ap)->ar_hln)ar_sha(ap)(((const u_char *)((ap)+1))+ 0)COMMENT_ONLY/* print operation *//* don't know know about the address formats *//* print hardware type/len and proto type/len *//* if its ATM then call the ATM ARP printer
           for Frame-relay ARP most of the fields
           are similar to Ethernet so overload the Ethernet Printer
           and set the linkaddr type for linkaddr_string(ndo, ) accordingly *//* target protocol address *//* target ATM subaddress *//* target ATM number *//* sender protocol address *//* source ATM subaddress *//* source ATM number *//*
 * The remaining fields are variable in size,
 * according to the sizes above.
 *//* length of target protocol address *//* length of target ATM subaddress *//* length of target ATM number *//* length of source protocol address *//* same as regular ARP *//* length of {sub}address in type/length *//* bit in type/length for E.164 format *//* length of source ATM subaddress *//* length of source ATM number *//* format of protocol address *//* format of hardware address *//*
 * ATM Address Resolution Protocol.
 *
 * See RFC 2225 for protocol description.  ATMARP packets are similar
 * to ARP packets, except that there are no length fields for the
 * protocol address - instead, there are type/length fields for
 * the ATM number and subaddress - and the hardware addresses consist
 * of an ATM number and an ATM subaddress.
 *//* target hardware address *//* sender hardware address *//* NAK - only valif for ATM ARP *//* response identifying peer *//* request to identify peer *//* response giving protocol address *//* request protocol address given hardware *//* response to previous request *//* request to resolve address *//* one of: *//* length of protocol address *//* length of hardware address *//* IEEE 1394 (FireWire) hardware format *//* Ricochet Starmode Radio hardware format *//* ATM (RFC 2225) *//* frame relay hardware format *//* arcnet hardware format *//* token-ring hardware format *//* ethernet hardware format *//*
 * Address Resolution Protocol.
 *
 * See RFC 826 for protocol description.  ARP packets are variable
 * in size; the arphdr structure defines the fixed-length portion.
 * Protocol type values are the same as those for 10 Mb/s Ethernet.
 * It is followed by the variable-sized fields ar_sha, arp_spa,
 * arp_tha and arp_tpa in that order, according to the lengths
 * specified.  Field names used correspond to RFC 826.
 *//* \summary: Address Resolution Protocol (ARP) printer *//*
 * Copyright (c) 1988, 1989, 1990, 1991, 1992, 1993, 1994, 1995, 1996, 1997
 *	The Regents of the University of California.  All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that: (1) source code distributions
 * retain the above copyright notice and this paragraph in its entirety, (2)
 * distributions including binary code include the above copyright notice and
 * this paragraph in its entirety in the documentation or other materials
 * provided with the distribution, and (3) all advertising materials mentioning
 * features or use of this software display the following acknowledgement:
 * ``This product includes software developed by the University of California,
 * Lawrence Berkeley Laboratory and its contributors.'' Neither the name of
 * the University nor the names of its contributors may be used to endorse
 * or promote products derived from this software without specific prior
 * written permission.
 * THIS SOFTWARE IS PROVIDED ``AS IS'' AND WITHOUT ANY EXPRESS OR IMPLIED
 * WARRANTIES, INCLUDING, WITHOUT LIMITATION, THE IMPLIED WARRANTIES OF
 * MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE.
 *//Users/owura/Repos/codeql_eval/proj_repos/the-tcpdump-group-tcpdump-commit-9ba91381954ad325ea4fd26b9c65a8bd9a2a85b6/tcpdump/print-ascii.chex_printhex_print_with_offsetcaplengthnshortssizeof(u_short)(ndo,"%s0x%04x: ", ident, oset)(ndo," %02x%02x", s, *cp++)%s0x%04x: HEXDUMP_BYTES_PER_LINE %02x%02x(ndo," %02x", *cp) %02xhex_and_ascii_printhex_and_ascii_print_with_offsetHEXDUMP_SHORTS_PER_LINEHEXDUMP_HEXSTUFF_PER_SHORThexstuffhspchar[301]300ASCII_LINELENGTH301asciistuffaspsizeof(hexstuff) - (hsp - hexstuff)" %02x%02x", s1, s2(ndo, "%s0x%04x: %-*s  %s", ident, oset, HEXDUMP_HEXSTUFF_PER_LINE, hexstuff, asciistuff)(ndo, "%s0x%04x: %-*s  %s", ident, oset, (5 * (16 / 2)), hexstuff, asciistuff)%s0x%04x: %-*s  %s" %02x", s1ascii_print(ndo, "\n")
(ndo, ".")(ndo, "%c", s)'\r''\n'.'\t'' '%cHEXDUMP_HEXSTUFF_PER_LINE(HEXDUMP_HEXSTUFF_PER_SHORT * HEXDUMP_SHORTS_PER_LINE)(HEXDUMP_BYTES_PER_LINE / 2)MAIN/* MAIN *//*
 * just for completeness
 *//*
 * telnet_print() wants this.  It is essentially default_print_unaligned()
 *//*
			 * Don't print CRs at the end of the line; they
			 * don't belong at the ends of lines on UN*X,
			 * and the standard I/O library will give us one
			 * on Windows so we don't need to print one
			 * ourselves.
			 *
			 * In the middle of a line, just print a '.'.
			 *//* 4 hex digits and a space *//* \summary: ASCII packet dump printer *//*-
 * Copyright (c) 1997, 1998 The NetBSD Foundation, Inc.
 * All rights reserved.
 *
 * This code is derived from software contributed to The NetBSD Foundation
 * by Alan Barrett and Simon J. Gerraty.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *        This product includes software developed by the NetBSD
 *        Foundation, Inc. and its contributors.
 * 4. Neither the name of The NetBSD Foundation nor the names of its
 *    contributors may be used to endorse or promote products derived
 *    from this software without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE NETBSD FOUNDATION, INC. AND CONTRIBUTORS
 * ``AS IS'' AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED
 * TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
 * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL THE FOUNDATION OR CONTRIBUTORS
 * BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
 * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
 * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
 * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
 * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
 * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
 * POSSIBILITY OF SUCH DAMAGE.
 *//*	$NetBSD: print-ascii.c,v 1.1 1999/09/30 14:49:12 sjg Exp $ 	*/identoset/Users/owura/Repos/codeql_eval/proj_repos/the-tcpdump-group-tcpdump-commit-9ba91381954ad325ea4fd26b9c65a8bd9a2a85b6/tcpdump/appletalk.hzipHeaderatNBPtupleatNBPatEchoatATPatShortDDPatDDPLAPnetcountenumeratorsktnodenetidcontrolechoDataechoFunctionuserDatatransIDsrcSktdstSktsrcNodedstNodesrcNetdstNetatalk_port(p)(((unsigned)((p) - 16512) < 128) || ((unsigned)((p) - 200) < 128) || ((unsigned)((p) - 768) < 128))GetZoneListGetMyZonezipSktddpZIPzipBringupzipTakedownzipReplyzipQueryzipHeaderSizertmpTupleSizertmpSizertmpSktnbpSktnbpTupleSizenbpHeaderSizenbpTupleMaxnbpNISnbpLkUpReply0x30nbpLkUpnbpBrRqechoReplyechoRequestechoSizeechoSktatpMaxData578atpMaxNumatpControlMaskatpFlagMaskatpSTSatpEOMatpXOatpRelCodeatpRspCodeatpReqCodeddpKLAP0x4bddpEIGRPddpARPddpIPddpECHOddpATPddpNBPddpRTMPrequestddpRTMPddpWKSddpSSizeddpSizeddpHopShiftddpLengthMask0x3FFddpMaxData586ddpMaxWKS0x7FlapKLAP'K'lapDDPlapShortDDP/*
 * UDP port range used for ddp-in-udp encapsulation is 16512-16639
 * for client sockets (128-255) and 200-327 for server sockets
 * (0-127).  We also try to recognize the pre-April 88 server
 * socket range of 768-895.
 *//* Zone Information Protocol *//* minimum size *//* number of RTMP socket *//* Routing Table Maint. Protocol *//* NIS *//* Name Binding Protocol *//* echo request *//* size of echo header *//* the echoer socket *//* AppleTalk Echo Protocol *//* AppleTalk Transaction Protocol *//* Kinetics KLAP type *//* EIGRP over Appletalk *//* ARP type *//* IP type *//* ECHO type *//* ATP type *//* NBP type *//* RTMP request type *//* RTMP type *//* boundary of DDP well known sockets *//* size of DDP header (avoid struct padding) *//* Datagram Delivery Protocol *//* DDP type *//* short DDP type *//*
 * Copyright (c) 1988, 1989, 1990, 1993, 1994, 1995, 1996
 *	The Regents of the University of California.  All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that: (1) source code distributions
 * retain the above copyright notice and this paragraph in its entirety, (2)
 * distributions including binary code include the above copyright notice and
 * this paragraph in its entirety in the documentation or other materials
 * provided with the distribution, and (3) all advertising materials mentioning
 * features or use of this software display the following acknowledgement:
 * ``This product includes software developed by the University of California,
 * Lawrence Berkeley Laboratory and its contributors.'' Neither the name of
 * the University nor the names of its contributors may be used to endorse
 * or promote products derived from this software without specific prior
 * written permission.
 * THIS SOFTWARE IS PROVIDED ``AS IS'' AND WITHOUT ANY EXPRESS OR IMPLIED
 * WARRANTIES, INCLUDING, WITHOUT LIMITATION, THE IMPLIED WARRANTIES OF
 * MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE.
 *
 * AppleTalk protocol formats (courtesy Bill Croft of Stanford/SUMEX).
 *//Users/owura/Repos/codeql_eval/proj_repos/the-tcpdump-group-tcpdump-commit-9ba91381954ad325ea4fd26b9c65a8bd9a2a85b6/tcpdump/print-atalk.c"appletalk.h"ddpskt_string"%d", skt"%d"ataddr_stringtp2char[257]256+1nambuffirst/etc/atalk.names"/etc/atalk.names"char[256]linei1i2sizeof(line)'#'%d.%d %256s"%d.%d %256s"%d %256s"%d %256s"ataddr_string: strdup(nambuf)"ataddr_string: strdup(nambuf)"sizeof(nambuf)"%s.%d", tp2->name, athost%s.%d"%d.%d", atnet, athost"%d", atnet%d.%dconst atNBPtupleconst atNBPtuple *atNBPtuple *nbp_name_print(ndo, "\"")"(ndo, ":")(ndo, "@"):@nbp_tuple_printtpn(ndo, "(%d)", tp->enumerator)(%d)(ndo, " %d", tp->skt) %d&tp->net(ndo, " [addr=%s]", ataddr_string(ndo, EXTRACT_16BITS(&tp->net), tp->node))(ndo, " [addr=%s]", ataddr_string(ndo, ((uint16_t)(((uint16_t)(*((const uint8_t *)(&tp->net) + 0)) << 8) | ((uint16_t)(*((const uint8_t *)(&tp->net) + 1)) << 0))), tp->node))atnetathostsnetsnode [addr=%s]print_cstring(ndo, "[len=%u]", length)[len=%u](ndo, "%c", *cp++)nbp_printconst atNBPconst atNBP *atNBP *(ndo, " truncated-nbp %u", length) truncated-nbp %u(ndo, " truncated-nbp %u", length + nbpHeaderSize)(ndo, " truncated-nbp %u", length + 2)(ndo, i == nbpLkUp? " nbp-lkup %d:":" nbp-brRq %d:", np->id)(ndo, i == 0x20? " nbp-lkup %d:":" nbp-brRq %d:", np->id)(ndo, " [ntup=%d]", np->control & 0xf)(ndo, " [enum=%d]", tp->enumerator)(ndo, " [addr=%s.%d]", ataddr_string(ndo, EXTRACT_16BITS(&tp->net), tp->node), tp->skt)(ndo, " [addr=%s.%d]", ataddr_string(ndo, ((uint16_t)(((uint16_t)(*((const uint8_t *)(&tp->net) + 0)) << 8) | ((uint16_t)(*((const uint8_t *)(&tp->net) + 1)) << 0))), tp->node), tp->skt)(ndo, " nbp-reply %d:", np->id)(ndo, " nbp-0x%x  %d (%u)", np->control, np->id, length) nbp-lkup %d: nbp-brRq %d: [ntup=%d] [enum=%d] [addr=%s.%d] nbp-reply %d: nbp-0x%x  %d (%u)atp_bitmap_print(ndo, "%c%d", c, i)(ndo, ">")(ndo, "<0-%d>", i - 1)(ndo, "<0>")'<'%c%d','><0-%d><0>atp_printconst atATPconst atATP *atATP *data(ndo, " [|atp %u]", length) [|atp %u](ndo, " atp-req%s %d", ap->control & atpXO? " " : "*", EXTRACT_16BITS(&ap->transID))(ndo, " atp-req%s %d", ap->control & 0x20? " " : "*", ((uint16_t)(((uint16_t)(*((const uint8_t *)(&ap->transID) + 0)) << 8) | ((uint16_t)(*((const uint8_t *)(&ap->transID) + 1)) << 0))))&ap->transID(ndo, " [len=%u]", length)(ndo, " [EOM]")(ndo, " [STS]")(ndo, " [EOM,STS]")(ndo, " atp-resp%s%d:%d (%u)", ap->control & atpEOM? "*" : " ", EXTRACT_16BITS(&ap->transID), ap->bitmap, length)(ndo, " atp-resp%s%d:%d (%u)", ap->control & 0x10? "*" : " ", ((uint16_t)(((uint16_t)(*((const uint8_t *)(&ap->transID) + 0)) << 8) | ((uint16_t)(*((const uint8_t *)(&ap->transID) + 1)) << 0))), ap->bitmap, length)(ndo, " [XO]")(ndo, " [XO,STS]")(ndo, " atp-rel  %d", EXTRACT_16BITS(&ap->transID))(ndo, " atp-rel  %d", ((uint16_t)(((uint16_t)(*((const uint8_t *)(&ap->transID) + 0)) << 8) | ((uint16_t)(*((const uint8_t *)(&ap->transID) + 1)) << 0))))(ndo, "%cXO", c)(ndo, "%cEOM", c)(ndo, "%cSTS", c)(ndo, "]")(ndo, " atp-0x%x  %d (%u)", ap->control, EXTRACT_16BITS(&ap->transID), length)(ndo, " atp-0x%x  %d (%u)", ap->control, ((uint16_t)(((uint16_t)(*((const uint8_t *)(&ap->transID) + 0)) << 8) | ((uint16_t)(*((const uint8_t *)(&ap->transID) + 1)) << 0))), length)0xc0 atp-req%s %d [len=%u](atpEOM|atpSTS) [EOM] [STS] [EOM,STS] atp-resp%s%d:%d (%u)npbm(atpXO|atpSTS) [XO] [XO,STS] atp-rel  %d(atpXO|atpEOM|atpSTS)'['%cXO%cEOM%cSTS] atp-0x%x  %d (%u)&ap->userDataconst int32_tconst int32_t *(ndo, " 0x%x", data) 0x%xddp_print(ndo, " at-%s %d", tok2str(type2str, NULL, t), length)(ndo, " at-%s %d", tok2str(type2str, ((void *)0), t), length) at-%s %daarp_printconst aarpconst aarp *aarp *(ndo, "aarp ")aarp (ndo, " [|aarp]") [|aarp](ndo, " [|aarp %u]", length) [|aarp %u]&ap->htype&ap->ptype&ap->op(ndo, "who-has %s tell %s", AT(pdaddr), AT(psaddr))(ndo, "who-has %s tell %s", ataddr_string(ndo, (ap->pdaddr[1]<<8)|ap->pdaddr[2],ap->pdaddr[3]), ataddr_string(ndo, (ap->psaddr[1]<<8)|ap->psaddr[2],ap->psaddr[3]))pdaddrpsaddr(ndo, "reply %s is-at %s", AT(psaddr), etheraddr_string(ndo, ap->hsaddr))(ndo, "reply %s is-at %s", ataddr_string(ndo, (ap->psaddr[1]<<8)|ap->psaddr[2],ap->psaddr[3]), etheraddr_string(ndo, ap->hsaddr))(ndo, "probe %s tell %s", AT(pdaddr), AT(psaddr))(ndo, "probe %s tell %s", ataddr_string(ndo, (ap->pdaddr[1]<<8)|ap->pdaddr[2],ap->pdaddr[3]), ataddr_string(ndo, (ap->psaddr[1]<<8)|ap->psaddr[2],ap->psaddr[3]))who-has %s tell %sreply %s is-at %sprobe %s tell %s(ndo, "len %u op %u htype %u ptype %#x halen %u palen %u", length, EXTRACT_16BITS(&ap->op), EXTRACT_16BITS(&ap->htype), EXTRACT_16BITS(&ap->ptype), ap->halen, ap->palen)(ndo, "len %u op %u htype %u ptype %#x halen %u palen %u", length, ((uint16_t)(((uint16_t)(*((const uint8_t *)(&ap->op) + 0)) << 8) | ((uint16_t)(*((const uint8_t *)(&ap->op) + 1)) << 0))), ((uint16_t)(((uint16_t)(*((const uint8_t *)(&ap->htype) + 0)) << 8) | ((uint16_t)(*((const uint8_t *)(&ap->htype) + 1)) << 0))), ((uint16_t)(((uint16_t)(*((const uint8_t *)(&ap->ptype) + 0)) << 8) | ((uint16_t)(*((const uint8_t *)(&ap->ptype) + 1)) << 0))), ap->halen, ap->palen)len %u op %u htype %u ptype %#x halen %u palen %uatalk_printconst atDDPconst atDDP *atDDP *(ndo, "AT ")AT (ndo, " [|ddp %u]", length) [|ddp %u](ndo, " [|ddp]") [|ddp]&dp->srcNet(ndo, "%s.%s", ataddr_string(ndo, snet, dp->srcNode), ddpskt_string(ndo, dp->srcSkt))%s.%s(ndo, " > %s.%s: ", ataddr_string(ndo, EXTRACT_16BITS(&dp->dstNet), dp->dstNode), ddpskt_string(ndo, dp->dstSkt))(ndo, " > %s.%s: ", ataddr_string(ndo, ((uint16_t)(((uint16_t)(*((const uint8_t *)(&dp->dstNet) + 0)) << 8) | ((uint16_t)(*((const uint8_t *)(&dp->dstNet) + 1)) << 0))), dp->dstNode), ddpskt_string(ndo, dp->dstSkt)) > %s.%s: &dp->dstNetllap_printconst LAPconst LAP *LAP *lpconst atShortDDPconst atShortDDP *atShortDDP *sdp(ndo, " [|llap %u]", length)sizeof(*lp) [|llap %u](ndo, " [|llap]") [|llap](ndo, " [|sddp %u]", length)(ndo, " [|sddp]")(ndo, "%s.%s", ataddr_string(ndo, 0, lp->src), ddpskt_string(ndo, sdp->srcSkt))(ndo, " > %s.%s:", ataddr_string(ndo, 0, lp->dst), ddpskt_string(ndo, sdp->dstSkt))(ndo, " > %s.%s:", ataddr_string(ndo, EXTRACT_16BITS(&dp->dstNet), dp->dstNode), ddpskt_string(ndo, dp->dstSkt))(ndo, " > %s.%s:", ataddr_string(ndo, ((uint16_t)(((uint16_t)(*((const uint8_t *)(&dp->dstNet) + 0)) << 8) | ((uint16_t)(*((const uint8_t *)(&dp->dstNet) + 1)) << 0))), dp->dstNode), ddpskt_string(ndo, dp->dstSkt))(ndo, "%d > %d at-lap#%d %u", lp->src, lp->dst, lp->type, length) [|sddp %u] [|sddp] > %s.%s:%d > %d at-lap#%d %ultalk_if_printaarphdaddrhsaddrpalenhalenptypehtypertmp"rtmp"nis"nis"echo"echo"zip"zip"skt2strrtmpReq"rtmpReq"IP"IP"ARP"ARP"KLAP"KLAP"type2str[|atalk]"[|atalk]"AT(member)ataddr_string(ndo, (ap->member[1]<<8)|ap->member[2],ap->member[3])/* zone info protocol *//* AppleTalk echo protocol *//* name info socket *//* routing table maintenance *//* didn't have the node name -- see if we've got the net name *//* got a net name *//* got a hostname. *//*
	 * if this is the first call, see if there's an AppleTalk
	 * number to name map file.
	 *//* Zone *//* Object *//* if the address doesn't match the src address, it's an anomaly *//* if the socket doesn't match the src socket, print it *//* if the enumerator isn't 1, print it *//* Spec says string can be at most 32 bytes long *//* print a counted string *//* print each of the tuples in the reply *//*
		 * look for anomalies: the spec says there can only
		 * be one tuple, the address must match the source
		 * address and the enumerator should be zero.
		 *//* ep points to end of available data *//* must be room for at least one tuple *//*
	 * The '& 0xff' below is needed for compilers that want to sign
	 * extend a u_char, which is the case with the Ultrix compiler.
	 * (gcc is smart enough to eliminate it, at least on the Sparc).
	 *//* there shouldn't be any control flags *//* length should be zero *//* Just bail if we don't have the whole chunk. *//*
 * Print AppleTalk Datagram Delivery Protocol packets.
 *//* probe (oy!) *//* response *//* request *//* XXX should probably pass in the snap header and do checks like arp_print() *//*
 * Print EtherTalk/TokenTalk packets (or FDDITalk, or whatever it's called
 * when it runs over FDDI; yes, I've seen FDDI captures with AppleTalk
 * packets in them).
 *//* cut short by the snapshot length *//*
 * Print AppleTalk LLAP packets.
 *//* Cut short by the snapshot length. *//*
 * Print LLAP packets received on a physical LocalTalk interface.
 *//* \summary: AppleTalk printer *//Users/owura/Repos/codeql_eval/proj_repos/the-tcpdump-group-tcpdump-commit-9ba91381954ad325ea4fd26b9c65a8bd9a2a85b6/tcpdump/atm.hATM_HDR_LEN_NOHECATM_OAM_HECATM_OAM_NOHECATM_LLCATM_LANEATM_UNKNOWN/*
 * some OAM cell captures (most notably Juniper's)
 * do not deliver a heading HEC byte
 *//* LLC encapsulation *//* LANE *//* Unknown *//*
 * Traffic types for ATM.
 *//*
 * Copyright (c) 2002 Guy Harris.
 *                All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that: (1) source code
 * distributions retain the above copyright notice and this paragraph
 * in its entirety, and (2) distributions including binary code include
 * the above copyright notice and this paragraph in its entirety in
 * the documentation or other materials provided with the distribution.
 * The name of Guy Harris may not be used to endorse or promote products
 * derived from this software without specific prior written permission.
 * THIS SOFTWARE IS PROVIDED ``AS IS'' AND WITHOUT ANY EXPRESS OR IMPLIED
 * WARRANTIES, INCLUDING, WITHOUT LIMITATION, THE IMPLIED WARRANTIES OF
 * MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE.
 *//Users/owura/Repos/codeql_eval/proj_repos/the-tcpdump-group-tcpdump-commit-9ba91381954ad325ea4fd26b9c65a8bd9a2a85b6/tcpdump/print-atm.c"atm.h"oam_printcell_headervpivcicksumcksum_shouldbecell_typefunc_typepayloadclpoam_ptr*(p+ATM_HDR_LEN_NOHEC+hec)*(p+4+hec)sizeof(*(p+4+hec))p+hec(ndo, "%s, vpi %u, vci %u, payload [ %s ], clp %u, length %u", tok2str(oam_f_values, "OAM F5", vci), vpi, vci, tok2str(atm_pty_values, "Unknown", payload), clp, length)%s, vpi %u, vci %u, payload [ %s ], clp %u, length %uOAM F5(ndo, "\n\tcell-type %s (%u)", tok2str(oam_celltype_values, "unknown", cell_type), cell_type)
	cell-type %s (%u)unknown(ndo, ", func-type unknown (%u)", func_type)(ndo, ", func-type %s (%u)", tok2str(oam_functype_values[cell_type],"none",func_type), func_type)const tok *[16]tok *[16]const tok **tok **, func-type unknown (%u), func-type %s (%u)*oam_ptr.oam_fm_loopbacksizeof(*oam_ptr.oam_fm_loopback)(ndo, "\n\tLoopback-Indicator %s, Correlation-Tag 0x%08x", tok2str(oam_fm_loopback_indicator_values, "Unknown", oam_ptr.oam_fm_loopback->loopback_indicator & OAM_FM_LOOPBACK_INDICATOR_MASK), EXTRACT_32BITS(&oam_ptr.oam_fm_loopback->correlation_tag))(ndo, "\n\tLoopback-Indicator %s, Correlation-Tag 0x%08x", tok2str(oam_fm_loopback_indicator_values, "Unknown", oam_ptr.oam_fm_loopback->loopback_indicator & 0x1), ((uint32_t)(((uint32_t)(*((const uint8_t *)(&oam_ptr.oam_fm_loopback->correlation_tag) + 0)) << 24) | ((uint32_t)(*((const uint8_t *)(&oam_ptr.oam_fm_loopback->correlation_tag) + 1)) << 16) | ((uint32_t)(*((const uint8_t *)(&oam_ptr.oam_fm_loopback->correlation_tag) + 2)) << 8) | ((uint32_t)(*((const uint8_t *)(&oam_ptr.oam_fm_loopback->correlation_tag) + 3)) << 0))))&oam_ptr.oam_fm_loopback->correlation_tag(ndo, "\n\tLocation-ID ")(ndo, "%04x ", EXTRACT_16BITS(&oam_ptr.oam_fm_loopback->loopback_id[idx]))(ndo, "%04x ", ((uint16_t)(((uint16_t)(*((const uint8_t *)(&oam_ptr.oam_fm_loopback->loopback_id[idx]) + 0)) << 8) | ((uint16_t)(*((const uint8_t *)(&oam_ptr.oam_fm_loopback->loopback_id[idx]) + 1)) << 0))))&oam_ptr.oam_fm_loopback->loopback_id[idx](ndo, "\n\tSource-ID   ")(ndo, "%04x ", EXTRACT_16BITS(&oam_ptr.oam_fm_loopback->source_id[idx]))(ndo, "%04x ", ((uint16_t)(((uint16_t)(*((const uint8_t *)(&oam_ptr.oam_fm_loopback->source_id[idx]) + 0)) << 8) | ((uint16_t)(*((const uint8_t *)(&oam_ptr.oam_fm_loopback->source_id[idx]) + 1)) << 0))))&oam_ptr.oam_fm_loopback->source_id[idx]*oam_ptr.oam_fm_ais_rdisizeof(*oam_ptr.oam_fm_ais_rdi)(ndo, "\n\tFailure-type 0x%02x", oam_ptr.oam_fm_ais_rdi->failure_type)(ndo, "%04x ", EXTRACT_16BITS(&oam_ptr.oam_fm_ais_rdi->failure_location[idx]))(ndo, "%04x ", ((uint16_t)(((uint16_t)(*((const uint8_t *)(&oam_ptr.oam_fm_ais_rdi->failure_location[idx]) + 0)) << 8) | ((uint16_t)(*((const uint8_t *)(&oam_ptr.oam_fm_ais_rdi->failure_location[idx]) + 1)) << 0))))&oam_ptr.oam_fm_ais_rdi->failure_location[idx]OAM_CELLTYPE_FMOAM_FM_FUNCTYPE_LOOPBACK(OAM_CELLTYPE_FM << 4 | OAM_FM_FUNCTYPE_LOOPBACK)const oam_fm_loopback_tconst oam_fm_loopback_t *oam_fm_loopback_t *OAM_CELLTYPE_FUNCTYPE_LEN
	Loopback-Indicator %s, Correlation-Tag 0x%08x
	Location-ID uint8_t[12]unsigned char[12]const uint8_t[12]sizeof(oam_ptr.oam_fm_loopback->loopback_id)%04x 
	Source-ID   sizeof(oam_ptr.oam_fm_loopback->source_id)hecOAM_FM_FUNCTYPE_AIS(OAM_CELLTYPE_FM << 4 | OAM_FM_FUNCTYPE_AIS)OAM_FM_FUNCTYPE_RDI(OAM_CELLTYPE_FM << 4 | OAM_FM_FUNCTYPE_RDI)const oam_fm_ais_rdi_tconst oam_fm_ais_rdi_t *oam_fm_ais_rdi_t *
	Failure-type 0x%02xconst uint8_t[16]sizeof(oam_ptr.oam_fm_ais_rdi->failure_location)OAM_FM_FUNCTYPE_CONTCHECK(OAM_CELLTYPE_FM << 4 | OAM_FM_FUNCTYPE_CONTCHECK)*(p + OAM_CELLTYPE_FUNCTYPE_LEN + OAM_FUNCTION_SPECIFIC_LEN)*(p + 1 + 45)p + OAM_CELLTYPE_FUNCTYPE_LEN + OAM_FUNCTION_SPECIFIC_LENp + 1 + 45OAM_CRC10_MASKOAM_PAYLOAD_LEN(ndo, "\n\tcksum 0x%03x (%scorrect)", cksum, cksum_shouldbe == 0 ? "" : "in")
	cksum 0x%03x (%scorrect)in(ndo, "[|oam]")[|oam]atm_print(ndo, "VPI:%u VCI:%u ", vpi, vci)VPI:%u VCI:%u (ndo, "broadcast sig: ")(ndo, "meta: ")(ndo, "ilmi: ")VCI_PPCVCI_BCCbroadcast sig: VCI_OAMF4SCVCI_OAMF4ECVCI_METACmeta: VCI_ILMICilmi: sig_printcall_refp[PROTO_POS]p[0]sizeof(p[0])(ndo, "Q.2931")p[MSG_TYPE_POS]p[5]sizeof(p[5])(ndo, ":%s ", tok2str(msgtype2str, "msgtype#%d", p[MSG_TYPE_POS]))(ndo, ":%s ", tok2str(msgtype2str, "msgtype#%d", p[5]))&p[CALL_REF_POS]&p[2](ndo, "CALL_REF:0x%06x", call_ref)(ndo, "SSCOP, proto %d ", p[PROTO_POS])(ndo, "SSCOP, proto %d ", p[0])PROTO_POSQ2931Q.2931:%s msgtype#%dCALL_REF:0x%06xtraftypeSSCOP, proto %d (ndo, " %s", tstr)atm_if_printllchdr(ndo, "CNLPID ")CNLPID (ndo, "%08x%08x %08x%08x ", EXTRACT_32BITS(p), EXTRACT_32BITS(p+4), EXTRACT_32BITS(p+8), EXTRACT_32BITS(p+12))(ndo, "%08x%08x %08x%08x ", ((uint32_t)(((uint32_t)(*((const uint8_t *)(p) + 0)) << 24) | ((uint32_t)(*((const uint8_t *)(p) + 1)) << 16) | ((uint32_t)(*((const uint8_t *)(p) + 2)) << 8) | ((uint32_t)(*((const uint8_t *)(p) + 3)) << 0))), ((uint32_t)(((uint32_t)(*((const uint8_t *)(p+4) + 0)) << 24) | ((uint32_t)(*((const uint8_t *)(p+4) + 1)) << 16) | ((uint32_t)(*((const uint8_t *)(p+4) + 2)) << 8) | ((uint32_t)(*((const uint8_t *)(p+4) + 3)) << 0))), ((uint32_t)(((uint32_t)(*((const uint8_t *)(p+8) + 0)) << 24) | ((uint32_t)(*((const uint8_t *)(p+8) + 1)) << 16) | ((uint32_t)(*((const uint8_t *)(p+8) + 2)) << 8) | ((uint32_t)(*((const uint8_t *)(p+8) + 3)) << 0))), ((uint32_t)(((uint32_t)(*((const uint8_t *)(p+12) + 0)) << 24) | ((uint32_t)(*((const uint8_t *)(p+12) + 1)) << 16) | ((uint32_t)(*((const uint8_t *)(p+12) + 2)) << 8) | ((uint32_t)(*((const uint8_t *)(p+12) + 3)) << 0))))p+4p+8p+1211141120435201118464011184643LLC_UI_HDR(LLCSAP_SNAP)16646144650241671116816711171LLC_UI_HDR(LLCSAP_ISONS)393216394752394755LLC_UI_HDR(LLCSAP_IP)%08x%08x %08x%08x atm_llc_printoam_fm_ais_rdi_toam_fm_loopback_toam_fm_ais_rdioam_fm_loopbackuint8_t[28]unsigned char[28]failure_locationfailure_typesource_idloopback_idcorrelation_tagloopback_indicatorCALL_PROCEEDCall_proceeding"Call_proceeding"CONNECTConnect"Connect"CONNECT_ACKConnect_ack"Connect_ack"SETUPSetup"Setup"RELEASERELEASE_DONERelease_complete"Release_complete"RESTARTRestart"Restart"RESTART_ACKRestart_ack"Restart_ack"STATUSStatus"Status"STATUS_ENQStatus_enquiry"Status_enquiry"ADD_PARTYAdd_party"Add_party"ADD_PARTY_ACKAdd_party_ack"Add_party_ack"ADD_PARTY_REJAdd_party_reject"Add_party_reject"DROP_PARTYDrop_party"Drop_party"DROP_PARTY_ACKDrop_party_ack"Drop_party_ack"msgtype2stroam_functype_valuesoam_fm_loopback_indicator_valuesPerformance Monitoring"Performance Monitoring"Continuity Check"Continuity Check"oam_ad_functype_valuesForward Monitoring"Forward Monitoring"Backward Reporting"Backward Reporting"Monitoring and Reporting"Monitoring and Reporting"oam_pm_functype_valuesAIS"AIS"RDI"RDI"Loopback"Loopback"oam_fm_functype_valuesFault Management"Fault Management"OAM_CELLTYPE_PMPerformance Management"Performance Management"OAM_CELLTYPE_ADactivate/deactivate"activate/deactivate"OAM_CELLTYPE_SMSystem Management"System Management"oam_celltype_valuesuser data, uncongested, SDU 0"user data, uncongested, SDU 0"user data, uncongested, SDU 1"user data, uncongested, SDU 1"user data, congested, SDU 0"user data, congested, SDU 0"user data, congested, SDU 1"user data, congested, SDU 1"VCC OAM F5 flow segment"VCC OAM F5 flow segment"VCC OAM F5 flow end-to-end"VCC OAM F5 flow end-to-end"Traffic Control and resource Mgmt"Traffic Control and resource Mgmt"atm_pty_valuesOAM F4 (segment)"OAM F4 (segment)"OAM F4 (end)"OAM F4 (end)"oam_f_values[|atm]"[|atm]"LLC_UI_HDR(sap)((sap)<<16 | (sap<<8) | 0x03)OAM_FM_LOOPBACK_INDICATOR_MASKOAM_FUNCTION_SPECIFIC_LENFIELD_BEGIN_POSLEN_POSTYPE_POSIE_BEGIN_POSMSG_LEN_POSMSG_TYPE_POSCALL_REF_POSCALLED_PARTY0x70CALLING_PARTY0x6cB_LOWER0x5fB_BEARER0x5eB_HIGHER0x5dQOS_PARA0x5cCONNECT_ID0x5aTRAFF_DESCRIP0x59AAL_PARA0x58ENDPT_REF0x54CAUSE0x750x7d0x460x4d0x05/* crc10 checksum verification *//* FIXME *//*
		 * Assumes traffic is LLC if unknown.
		 *//* fall through *//*
 * Print an ATM PDU (such as an AAL5 PDU).
 *//* SCCOP with some unknown protocol atop it *//*
		 * The call reference comes before the message type,
		 * so if we know we have the message type, which we
		 * do from the caplen test above, we also know we have
		 * the call reference.
		 *//*
		 * protocol:Q.2931 for User to Network Interface
		 * (UNI 3.1) signalling
		 *//*
 * ATM signalling.
 *//*
		 * XXX - assume 802.6 MAC header from Fore driver.
		 *
		 * Unfortunately, the above list doesn't check for
		 * all known SAPs, doesn't check for headers where
		 * the source and destination SAP aren't the same,
		 * and doesn't check for non-UI frames.  It also
		 * runs the risk of an 802.6 MAC header that happens
		 * to begin with one of those values being
		 * incorrectly treated as an 802.2 header.
		 *
		 * So is that Fore driver still around?  And, if so,
		 * is it still putting 802.6 MAC headers on ATM
		 * packets?  If so, could it be changed to use a
		 * new DLT_IEEE802_6 value if we added it?
		 *//*
	 * Extract the presumed LLC header into a variable, for quick
	 * testing.
	 * Then check for a header that's neither a header for a SNAP
	 * packet nor an RFC 2684 routed NLPID-formatted PDU nor
	 * an 802.2-but-no-SNAP IP packet.
	 *//*
	 * Must have at least a DSAP, an SSAP, and the first byte of the
	 * control field.
	 *//* Cisco Style NLPID ? *//*
 * This is the top level routine of the printer.  'p' points
 * to the LLC/SNAP header of the packet, 'h->ts' is the timestamp,
 * 'h->len' is the length of the packet off the wire, and 'h->caplen'
 * is the number of bytes actually captured.
 *//*
 * Given a SAP value, generate the LLC header value for a UI packet
 * with that SAP as the source and destination SAP.
 *//* packet not known, print raw packet *//*
 * Print an RFC 1483 LLC-encapsulated ATM frame.
 *//* this excludes crc10 and cell-type/function-type *//* end of the original atmuni31.h *//* format of signalling messages *//* offset of first information element *//* offset of mesage length *//* offset of message type *//* offset of call reference value *//* offset of protocol discriminator *//* Q.2931 signalling general messages format *//* called party nmber *//* calling party number *//* broadband lower information *//* broadband bearer capability *//* broadband higher layer information *//* quality of service parameters *//* connection identifier *//* atm traffic descriptors *//* ATM adaptation layer parameters *//* endpoint reference *//* cause *//* Information Element Parameters in the signalling messages *//* drop party ack *//* drop party *//* add party rej *//* add party ack *//* add party *//* status ack *//* status *//* restart ack *//* restart *//* release_done *//* release *//* setup *//* connect_ack *//* connect *//* call proceeding *//* Q.2931 signalling messages *//* ILMI msg *//* Meta signal msg *//* End-to-end OAM F4 flow cell *//* Segment OAM F4 flow cell *//* Broadcast signal msg *//* Point-to-point signal msg *//* ATM traffic types based on VPI=0 and (the following VCI *//* Based on UNI3.1 standard by ATM Forum *//*
 * Copyright (c) 1997 Yen Yen Lim and North Dakota State University
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *      This product includes software developed by Yen Yen Lim and
        North Dakota State University
 * 4. The name of the author may not be used to endorse or promote products
 *    derived from this software without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
 * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
 * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT,
 * INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
 * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
 * SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
 * STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN
 * ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
 * POSSIBILITY OF SUCH DAMAGE.
 *//* start of the original atmuni31.h *//* \summary: Asynchronous Transfer Mode (ATM) printer *//*
 * Copyright (c) 1994, 1995, 1996, 1997
 *	The Regents of the University of California.  All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that: (1) source code distributions
 * retain the above copyright notice and this paragraph in its entirety, (2)
 * distributions including binary code include the above copyright notice and
 * this paragraph in its entirety in the documentation or other materials
 * provided with the distribution, and (3) all advertising materials mentioning
 * features or use of this software display the following acknowledgement:
 * ``This product includes software developed by the University of California,
 * Lawrence Berkeley Laboratory and its contributors.'' Neither the name of
 * the University nor the names of its contributors may be used to endorse
 * or promote products derived from this software without specific prior
 * written permission.
 * THIS SOFTWARE IS PROVIDED ``AS IS'' AND WITHOUT ANY EXPRESS OR IMPLIED
 * WARRANTIES, INCLUDING, WITHOUT LIMITATION, THE IMPLIED WARRANTIES OF
 * MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE.
 *//Users/owura/Repos/codeql_eval/proj_repos/the-tcpdump-group-tcpdump-commit-9ba91381954ad325ea4fd26b9c65a8bd9a2a85b6/tcpdump/print-babel.cbabel_print_v2bodylenu_char[16]v4_prefix0xFFv6_prefixcp + 2(ndo, " (%u)", bodylen) (%u)*message(ndo, ndo->ndo_vflag ? "\n\tPad 1" : " pad1")2 + len(ndo, " padN")(ndo, "\n\tPad %d", len + 2)(ndo, " ack-req")(ndo, "\n\tAcknowledgment Request ")message + 4message + 6(ndo, "%04x %s", nonce, format_interval(interval))(ndo, " ack")(ndo, "\n\tAcknowledgment ")message + 2(ndo, "%04x", nonce)(ndo, " hello")(ndo, "\n\tHello ")(ndo, "seqno %u interval %s", seqno, format_interval(interval))(ndo, " ihu")(ndo, "\n\tIHU ")(ndo, "%s txcost %u interval %s", format_address(ndo, address), txcost, format_interval(interval))(ndo, " router-id")(ndo, "\n\tRouter Id")(ndo, " %s", format_id(message + 4))(ndo, " nh")(ndo, "\n\tNext Hop")(ndo, " %s", format_address(ndo, nh))(ndo, " update")(ndo, "/truncated")(ndo, "%s%s%s", (message[3] & 0x80) ? "/prefix": "", (message[3] & 0x40) ? "/id" : "", (message[3] & 0x3f) ? "/unknown" : "")(ndo, "\n\tUpdate")message + 8message + 10(ndo, "%s%s%s %s metric %u seqno %u interval %s", (message[3] & 0x80) ? "/prefix": "", (message[3] & 0x40) ? "/id" : "", (message[3] & 0x3f) ? "/unknown" : "", format_prefix(ndo, prefix, plen), metric, seqno, format_interval_update(interval))prefix, 16(ndo, " request")(ndo, "\n\tRequest ")(ndo, "for %s", message[2] == 0 ? "any" : format_prefix(ndo, prefix, plen))(ndo, " mh-request")(ndo, "\n\tMH-Request ")(ndo, "(%u hops) for %s seqno %u id %s", message[6], format_prefix(ndo, prefix, plen), seqno, format_id(message + 8))(ndo, " tspc")(ndo, "\n\tTS/PC ")(ndo, "timestamp %u packetcounter %u", EXTRACT_32BITS (message + 4), EXTRACT_16BITS(message + 2))(ndo, "timestamp %u packetcounter %u", ((uint32_t)(((uint32_t)(*((const uint8_t *)(message + 4) + 0)) << 24) | ((uint32_t)(*((const uint8_t *)(message + 4) + 1)) << 16) | ((uint32_t)(*((const uint8_t *)(message + 4) + 2)) << 8) | ((uint32_t)(*((const uint8_t *)(message + 4) + 3)) << 0))), ((uint16_t)(((uint16_t)(*((const uint8_t *)(message + 2) + 0)) << 8) | ((uint16_t)(*((const uint8_t *)(message + 2) + 1)) << 0))))(ndo, " hmac")(ndo, "\n\tHMAC ")(ndo, "key-id %u digest-%u ", EXTRACT_16BITS(message + 2), len - 2)(ndo, "key-id %u digest-%u ", ((uint16_t)(((uint16_t)(*((const uint8_t *)(message + 2) + 0)) << 8) | ((uint16_t)(*((const uint8_t *)(message + 2) + 1)) << 0))), len - 2)(ndo, "%02X", message[4 + j])(ndo, " ss-update")(ndo, "\n\tSS-Update")(ndo, " %s from", format_prefix(ndo, prefix, plen))(ndo, " %s metric %u seqno %u interval %s", format_prefix(ndo, src_prefix, src_plen), metric, seqno, format_interval_update(interval))(ndo, " ss-request")(ndo, "\n\tSS-Request ")(ndo, "for any")(ndo, "for (%s, ", format_prefix(ndo, prefix, plen))(ndo, "%s)", format_prefix(ndo, src_prefix, src_plen))(ndo, " ss-mh-request")(ndo, "\n\tSS-MH-Request ")(ndo, "(%u hops) for (%s, ", hopc, format_prefix(ndo, prefix, plen))(ndo, "%s) seqno %u id %s", format_prefix(ndo, src_prefix, src_plen), seqno, format_id(router_id))(ndo, " unknown")(ndo, "\n\tUnknown message type %d", type)messageMESSAGE_PAD1
	Pad 1 pad1MESSAGE_PADN padN
	Pad %dMESSAGE_ACK_REQnonce ack-req
	Acknowledgment Request %04x %sMESSAGE_ACK ack
	Acknowledgment %04xMESSAGE_HELLOseqno hello
	Hello seqno %u interval %sMESSAGE_IHUtxcost ihuaddress
	IHU %s txcost %u interval %sMESSAGE_ROUTER_ID router-id
	Router IdMESSAGE_NH nhnh
	Next HopMESSAGE_UPDATE update/truncated%s%s%s/prefix/id/unknownmetricplenprefix
	Update%s%s%s %s metric %u seqno %u interval %sMESSAGE_REQUEST request
	Request for %sanyMESSAGE_MH_REQUEST mh-request
	MH-Request (%u hops) for %s seqno %u id %sMESSAGE_TSPC tspc
	TS/PC timestamp %u packetcounter %uMESSAGE_HMAC hmac
	HMAC key-id %u digest-%u %02XMESSAGE_UPDATE_SRC_SPECIFIC ss-updatesrc_prefixsrc_plenomittedparsed_len 10
	SS-Update %s from %s metric %u seqno %u interval %sMESSAGE_REQUEST_SRC_SPECIFIC ss-request 3
	SS-Request for anyfor (%s, %s)MESSAGE_MH_REQUEST_SRC_SPECIFIC ss-mh-request 14hopcrouter_id
	SS-MH-Request (%u hops) for (%s, %s) seqno %u id %s unknown
	Unknown message type %dsubtlvs_printsublent1t2(ndo, " sub-pad1")(ndo, " sub-padn")(ndo, " sub-diversity")(ndo, " empty")(ndo, "%s%s", sep, tok2str(diversity_str, "%u", *cp++))(ndo, " (bogus)")(ndo, " sub-timestamp")(ndo, " %s", format_timestamp(t1))cp + 4(ndo, "|%s", format_timestamp(t2))(ndo, " sub-unknown-0x%02x", subtype)MESSAGE_SUB_PAD1 sub-pad1MESSAGE_SUB_PADN sub-padnMESSAGE_SUB_DIVERSITY sub-diversity empty" "-"-" (bogus)MESSAGE_SUB_TIMESTAMP sub-timestamp|%s sub-unknown-0x%02xnetwork_addressnetwork_prefixpbconsumed0, 16v4prefix, 12dp, 12 + omittedprefix + 12 + omittedp, pb - omitteddp, omittedprefix + omittedprefix + 8p, pb - 8tlv_typea_rp_rconst unsigned char[16]format_timestampsizeof("0000.000000s")"%u.%06us", i / 1000000, i % 1000000%u.%06us1000000format_interval_updateinfinity"infinity"format_intervalsizeof("000.00s")0.0s (bogus)"0.0s (bogus)""%u.%02us", i / 100, i % 100%u.%02usformat_addressprefix + 12format_prefix"%s/%u", ipaddr_string(ndo, prefix + 12), plen - 96"%s/%u", getname(ndo, (const u_char *)(prefix + 12)), plen - 96"%s/%u", ip6addr_string(ndo, prefix), plen"%s/%u", getname6(ndo, (const u_char *)(prefix)), plen%s/%uformat_id"%02x:%02x:%02x:%02x:%02x:%02x:%02x:%02x", id[0], id[1], id[2], id[3], id[4], id[5], id[6], id[7]%02x:%02x:%02x:%02x:%02x:%02x:%02x:%02xbabel_print(ndo, "babel")babel(ndo, " invalid header")(ndo, " %d", cp[1]) invalid header(ndo, " unknown version") unknown versionv4prefixall"all"diversity_str[|babel]"[|babel]"ICHECK(i,l)if ((i) + (l) > bodylen || (i) + (l) > length) goto invalid;/* extra data? *//* Extra data. *//* Process the TLVs in the body *//* while *//* switch *//*
 * Sub-TLVs consume the "extra data" of Babel TLVs (see Section 4.3 of RFC6126),
 * their encoding is similar to the encoding of TLVs, but the type namespace is
 * different:
 *
 * o Type 0 stands for Pad1 sub-TLV with the same encoding as the Pad1 TLV.
 * o Type 1 stands for PadN sub-TLV with the same encoding as the PadN TLV.
 * o Type 2 stands for Diversity sub-TLV, which propagates diversity routing
 *   data. Its body is a variable-length sequence of 8-bit unsigned integers,
 *   each representing per-hop number of interferring radio channel for the
 *   prefix. Channel 0 is invalid and must not be used in the sub-TLV, channel
 *   255 interferes with any other channel.
 * o Type 3 stands for Timestamp sub-TLV, used to compute RTT between
 *   neighbours. In the case of a Hello TLV, the body stores a 32-bits
 *   timestamp, while in the case of a IHU TLV, two 32-bits timestamps are
 *   stored.
 *
 * Sub-TLV types 0 and 1 are valid for any TLV type, whether sub-TLV type 2 is
 * only valid for TLV type 8 (Update). Note that within an Update TLV a missing
 * Diversity sub-TLV is not the same as a Diversity sub-TLV with an empty body.
 * The former would mean a lack of any claims about the interference, and the
 * latter would state that interference is definitely absent.
 * A type 3 sub-TLV is valid both for Hello and IHU TLVs, though the exact
 * semantic of the sub-TLV is different in each case.
 *//* Return number of octets consumed from the input buffer (not the prefix length
 * in bytes), or -1 for encoding error. *//* Diversity sub-TLV channel codes *//* sub-TLVs *//* TLVs *//* \summary: Babel Routing Protocol printer *//*
 * Copyright (c) 2007-2011 GrÃ©goire Henry, Juliusz Chroboczek
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. Neither the name of the project nor the names of its contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE PROJECT AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE PROJECT OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 *//Users/owura/Repos/codeql_eval/proj_repos/the-tcpdump-group-tcpdump-commit-9ba91381954ad325ea4fd26b9c65a8bd9a2a85b6/tcpdump/print-beep.cbeep_print(ndo, " BEEP MSG")(ndo, " BEEP RPY")(ndo, " BEEP ERR")(ndo, " BEEP ANS")(ndo, " BEEP NUL")(ndo, " BEEP SEQ")(ndo, " BEEP END")(ndo, " BEEP (payload or undecoded)")MSG"MSG" BEEP MSGRPY "RPY " BEEP RPYERR "ERR " BEEP ERRANS "ANS " BEEP ANSNUL "NUL " BEEP NULSEQ "SEQ " BEEP SEQEND"END" BEEP END BEEP (payload or undecoded)l_strnstart*str2tl1/* A REQuest *//*
		 * We don't have tl1 bytes worth of captured data
		 * for the string, so we can't check for this
		 * string.
		 *//* Check for a string but not go beyond length
 * Return TRUE on match, FALSE otherwise
 *
 * Looks at the first few chars up to tl1 ...
 *//* \summary: Blocks Extensible Exchange Protocol (BEEP) printer *//*
 * Copyright (C) 2000, Richard Sharpe
 *
 * This software may be distributed either under the terms of the
 * BSD-style license that accompanies tcpdump or under the GNU GPL
 * version 2 or later.
 *
 * print-beep.c
 *
 */tstr1str2l2/Users/owura/Repos/codeql_eval/proj_repos/the-tcpdump-group-tcpdump-commit-9ba91381954ad325ea4fd26b9c65a8bd9a2a85b6/tcpdump/udp.hudphdruh_sumuh_ulenuh_dportuh_sportLWAPP_CONTROL_PORT12223LWAPP_DATA_PORT12222ISAKMP_PORT_USER28500OTV_PORT8472HNCP_PORT8231ISAKMP_PORT_USER17500RX_PORT_HIGH7009RX_PORT_LOW7000BABEL_PORT_OLD6697BABEL_PORT6696SFLOW_PORT6343GENEVE_PORT6081AHCP_PORT5359MULTICASTDNS_PORT5353SIP_PORT5060SIP_DS_PORT5059VXLAN_GPE_PORT4790VXLAN_PORT4789WB_PORT4567ISAKMP_PORT_NATT4500LISP_CONTROL_PORT4342NFS_LOCK_DAEMON_PORT4045RADIUS_COA_PORT3799BFD_ECHO_PORT3785BFD_CONTROL_PORT3784SUBVERSION_PORT3690MPLS_LSP_PING_PORT3503VAT_PORT3456MS_RDP_PORT3389MYSQL_PORT3306ZEPHYR_CLT_PORT2104ZEPHYR_SRV_PORT2103NFS_DAEMON_PORT2049HSRP_PORTRADIUS_NEW_ACCOUNTING_PORT1813RADIUS_NEW_PORT1812L2TP_PORT1701RADIUS_CISCO_COA_PORT1700RADIUS_ACCOUNTING_PORT1646RADIUS_PORT1645VQP_PORT1589INGRESLOCK_PORT1524MS_SQL_SERVER_MONITOR1434MS_SQL_SERVER_PORT1433LOTUS_NOTES_PORT1352OPENSSL_PORT1194LWRES_PORT921RSYNC_PORT873KERBEROS_SEC_PORT750KERBEROS_ADM_PORT749CISCO_TDP_PORT711LMP_PORT701OLSR_PORT698AODV_PORT654DHCP_FAILOVER_PORT647LDP_PORT646LDAPS_PORT636DHCP6_CLI_PORT547DHCP6_SERV_PORT546KERBEROS_SHELL_PORT544KERBEROS_LOGIN_PORT543TIMED_PORT525RIPNG_PORT521RIP_PORT520SYSLOG_PORT514ISAKMP_PORT500CISCO_AUTORP_PORTKERBEROS5_PASSWD_PORT464MICROSOFT_DS_PORT445HTTPS_PORT443LDAP_PORT389APPLETALK_ZONE_INFO_PORT206APPLETALK_ECHOAPPLETALK_NB_PORT202APPLETALK_RTMP_PORT201BGP_PORTSNMPTRAP_PORTSNMP_PORTNETBIOS_SSN_PORTNETBIOS_DGRAM_PORTNETBIOS_NS_PORTNTP_PORTSUNRPC_PORTKERBEROS_PORTTFTP_PORTBOOTPC_PORTBOOTPS_PORTORACLE_SQLNET_PORTTACACS_DB_PORTNAMESERVER_PORTAQDV_PORTZEPHYR_CLI_PORT/* RFC 5412 *//*XXX - nonstandard*//* draft-hasmit-otv-04 *//* RFC 7788 *//*XXX*//* RFC 6126 *//* RFC 6126 errata *//* http://www.sflow.org/developers/specifications.php *//* draft-gross-geneve-02 *//* draft-chroboczek-ahcp-00 *//* RFC 6762 *//* draft-ietf-nvo3-vxlan-gpe-01 *//* RFC 7348 *//* rfc3948 *//* RFC 6830 *//* RFC 5176 *//* RFC 5881 *//* draft-ietf-mpls-lsp-ping-02.txt *//*XXX - Kerberos v4 *//*XXX - Kerberos v5 *//* rfc4204 *//* rfc3626 *//*XXX - LDAP over TLS/SSL *//* RFC 2080 *//* rfc3164 *//* PER IANA *//* RFC 1001, RFC 1002 *//* RFC951 *//* udp checksum *//* udp length *//* destination port *//* source port *//*
 * Udp protocol header.
 * Per RFC 768, September, 1981.
 *//*
 * Copyright (c) 1982, 1986, 1993
 *	The Regents of the University of California.  All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *	This product includes software developed by the University of
 *	California, Berkeley and its contributors.
 * 4. Neither the name of the University nor the names of its contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 *
 *	@(#)udp.h	8.1 (Berkeley) 6/10/93
 *//Users/owura/Repos/codeql_eval/proj_repos/the-tcpdump-group-tcpdump-commit-9ba91381954ad325ea4fd26b9c65a8bd9a2a85b6/tcpdump/print-bfd.c"udp.h"bfd_print*bfd_headersizeof(*bfd_header)version_diag(ndo, "BFDv0, Control, Flags: [%s], length: %u", bittok2str(bfd_v0_flag_values, "none", flags), len)(ndo, "BFDv0, length: %u\n\tControl, Flags: [%s], Diagnostic: %s (0x%02x)", len, bittok2str(bfd_v0_flag_values, "none", flags), tok2str(bfd_diag_values,"unknown",BFD_EXTRACT_DIAG(version_diag)), BFD_EXTRACT_DIAG(version_diag))(ndo, "BFDv0, length: %u\n\tControl, Flags: [%s], Diagnostic: %s (0x%02x)", len, bittok2str(bfd_v0_flag_values, "none", flags), tok2str(bfd_diag_values,"unknown",((version_diag)&0x1f)), ((version_diag)&0x1f))(ndo, "\n\tDetection Timer Multiplier: %u (%u ms Detection time), BFD Length: %u", bfd_header->detect_time_multiplier, bfd_header->detect_time_multiplier * EXTRACT_32BITS(bfd_header->desired_min_tx_interval)/1000, bfd_header->length)(ndo, "\n\tDetection Timer Multiplier: %u (%u ms Detection time), BFD Length: %u", bfd_header->detect_time_multiplier, bfd_header->detect_time_multiplier * ((uint32_t)(((uint32_t)(*((const uint8_t *)(bfd_header->desired_min_tx_interval) + 0)) << 24) | ((uint32_t)(*((const uint8_t *)(bfd_header->desired_min_tx_interval) + 1)) << 16) | ((uint32_t)(*((const uint8_t *)(bfd_header->desired_min_tx_interval) + 2)) << 8) | ((uint32_t)(*((const uint8_t *)(bfd_header->desired_min_tx_interval) + 3)) << 0)))/1000, bfd_header->length)bfd_header->desired_min_tx_interval(ndo, "\n\tMy Discriminator: 0x%08x", EXTRACT_32BITS(bfd_header->my_discriminator))(ndo, "\n\tMy Discriminator: 0x%08x", ((uint32_t)(((uint32_t)(*((const uint8_t *)(bfd_header->my_discriminator) + 0)) << 24) | ((uint32_t)(*((const uint8_t *)(bfd_header->my_discriminator) + 1)) << 16) | ((uint32_t)(*((const uint8_t *)(bfd_header->my_discriminator) + 2)) << 8) | ((uint32_t)(*((const uint8_t *)(bfd_header->my_discriminator) + 3)) << 0))))bfd_header->my_discriminator(ndo, ", Your Discriminator: 0x%08x", EXTRACT_32BITS(bfd_header->your_discriminator))(ndo, ", Your Discriminator: 0x%08x", ((uint32_t)(((uint32_t)(*((const uint8_t *)(bfd_header->your_discriminator) + 0)) << 24) | ((uint32_t)(*((const uint8_t *)(bfd_header->your_discriminator) + 1)) << 16) | ((uint32_t)(*((const uint8_t *)(bfd_header->your_discriminator) + 2)) << 8) | ((uint32_t)(*((const uint8_t *)(bfd_header->your_discriminator) + 3)) << 0))))bfd_header->your_discriminator(ndo, "\n\t  Desired min Tx Interval:    %4u ms", EXTRACT_32BITS(bfd_header->desired_min_tx_interval)/1000)(ndo, "\n\t  Desired min Tx Interval:    %4u ms", ((uint32_t)(((uint32_t)(*((const uint8_t *)(bfd_header->desired_min_tx_interval) + 0)) << 24) | ((uint32_t)(*((const uint8_t *)(bfd_header->desired_min_tx_interval) + 1)) << 16) | ((uint32_t)(*((const uint8_t *)(bfd_header->desired_min_tx_interval) + 2)) << 8) | ((uint32_t)(*((const uint8_t *)(bfd_header->desired_min_tx_interval) + 3)) << 0)))/1000)(ndo, "\n\t  Required min Rx Interval:   %4u ms", EXTRACT_32BITS(bfd_header->required_min_rx_interval)/1000)(ndo, "\n\t  Required min Rx Interval:   %4u ms", ((uint32_t)(((uint32_t)(*((const uint8_t *)(bfd_header->required_min_rx_interval) + 0)) << 24) | ((uint32_t)(*((const uint8_t *)(bfd_header->required_min_rx_interval) + 1)) << 16) | ((uint32_t)(*((const uint8_t *)(bfd_header->required_min_rx_interval) + 2)) << 8) | ((uint32_t)(*((const uint8_t *)(bfd_header->required_min_rx_interval) + 3)) << 0)))/1000)bfd_header->required_min_rx_interval(ndo, "\n\t  Required min Echo Interval: %4u ms", EXTRACT_32BITS(bfd_header->required_min_echo_interval)/1000)(ndo, "\n\t  Required min Echo Interval: %4u ms", ((uint32_t)(((uint32_t)(*((const uint8_t *)(bfd_header->required_min_echo_interval) + 0)) << 24) | ((uint32_t)(*((const uint8_t *)(bfd_header->required_min_echo_interval) + 1)) << 16) | ((uint32_t)(*((const uint8_t *)(bfd_header->required_min_echo_interval) + 2)) << 8) | ((uint32_t)(*((const uint8_t *)(bfd_header->required_min_echo_interval) + 3)) << 0)))/1000)bfd_header->required_min_echo_interval(ndo, "BFDv1, Control, State %s, Flags: [%s], length: %u", tok2str(bfd_v1_state_values, "unknown (%u)", (flags & 0xc0) >> 6), bittok2str(bfd_v1_flag_values, "none", flags & 0x3f), len)(ndo, "BFDv1, length: %u\n\tControl, State %s, Flags: [%s], Diagnostic: %s (0x%02x)", len, tok2str(bfd_v1_state_values, "unknown (%u)", (flags & 0xc0) >> 6), bittok2str(bfd_v1_flag_values, "none", flags & 0x3f), tok2str(bfd_diag_values,"unknown",BFD_EXTRACT_DIAG(version_diag)), BFD_EXTRACT_DIAG(version_diag))(ndo, "BFDv1, length: %u\n\tControl, State %s, Flags: [%s], Diagnostic: %s (0x%02x)", len, tok2str(bfd_v1_state_values, "unknown (%u)", (flags & 0xc0) >> 6), bittok2str(bfd_v1_flag_values, "none", flags & 0x3f), tok2str(bfd_diag_values,"unknown",((version_diag)&0x1f)), ((version_diag)&0x1f))(ndo, "BFDv%u, Control, length: %u", version, len)(ndo, "BFD, Echo, length: %u", len)(ndo, "BFD, unknown (%u), length: %u", port, len)const bfd_header_tconst bfd_header_t *bfd_header_t *bfd_headerBFDv0, Control, Flags: [%s], length: %uBFDv0, length: %u
	Control, Flags: [%s], Diagnostic: %s (0x%02x)
	Detection Timer Multiplier: %u (%u ms Detection time), BFD Length: %u1000
	My Discriminator: 0x%08x, Your Discriminator: 0x%08x
	  Desired min Tx Interval:    %4u ms
	  Required min Rx Interval:   %4u ms
	  Required min Echo Interval: %4u msBFD_FLAG_AUTHBFDv1, Control, State %s, Flags: [%s], length: %uunknown (%u)BFDv1, length: %u
	Control, State %s, Flags: [%s], Diagnostic: %s (0x%02x)char[75]BFDv%u, Control, length: %u
	"\n\t"BFD, Echo, length: %uBFD, unknown (%u), length: %u(ndo, "[|BFD]")[|BFD]auth_printconst bfd_auth_header_tconst bfd_auth_header_t *bfd_auth_header_t *bfd_auth_headersizeof (const struct bfd_header_t)*bfd_auth_headersizeof(*bfd_auth_header)(ndo, "\n\tAuthentication: %s (%u), length: %u", tok2str(bfd_v1_authentication_values,"Unknown",bfd_auth_header->auth_type), bfd_auth_header->auth_type, bfd_auth_header->auth_len)
	Authentication: %s (%u), length: %u(ndo, "\n\t  Auth Key ID: %d", *pptr)
	  Auth Key ID: %d(ndo, "[invalid length %d]", bfd_auth_header->auth_len)(ndo, ", Password: ")*pptr(ndo, ", Sequence Number: 0x%08x", EXTRACT_32BITS(pptr))(ndo, ", Sequence Number: 0x%08x", ((uint32_t)(((uint32_t)(*((const uint8_t *)(pptr) + 0)) << 24) | ((uint32_t)(*((const uint8_t *)(pptr) + 1)) << 16) | ((uint32_t)(*((const uint8_t *)(pptr) + 2)) << 8) | ((uint32_t)(*((const uint8_t *)(pptr) + 3)) << 0))))AUTH_MD5_HASH_LEN(ndo, "\n\t  Digest: ")(ndo, "%02x", pptr[i])AUTH_SHA1_HASH_LEN(ndo, "\n\t  Hash: ")AUTH_PASSWORDAUTH_PASSWORD_FIELD_MIN_LENAUTH_PASSWORD_FIELD_MAX_LEN[invalid length %d], Password: AUTH_MD5AUTH_MET_MD5AUTH_MD5_FIELD_LEN, Sequence Number: 0x%08x
	  Digest: AUTH_SHA1AUTH_MET_SHA1AUTH_SHA1_FIELD_LEN
	  Hash: auth_lengthauth_typebfd_auth_header_tbfd_header_tdummyauth_dataauth_lenrequired_min_echo_intervalrequired_min_rx_intervaldesired_min_tx_intervalyour_discriminatormy_discriminatordetect_time_multiplierAdminDown"AdminDown"Down"Down"Init"Init"Up"Up"bfd_v1_state_values"Poll"Final"Final"Control Plane Independent"Control Plane Independent"Authentication Present"Authentication Present"Demand"Demand"Multipoint"Multipoint"bfd_v1_flag_valuesI Hear You"I Hear You"bfd_v0_flag_valuesNo Diagnostic"No Diagnostic"Control Detection Time Expired"Control Detection Time Expired"Echo Function Failed"Echo Function Failed"Neighbor Signaled Session Down"Neighbor Signaled Session Down"Forwarding Plane Reset"Forwarding Plane Reset"Path Down"Path Down"Concatenated Path Down"Concatenated Path Down"Administratively Down"Administratively Down"Reverse Concatenated Path Down"Reverse Concatenated Path Down"bfd_diag_valuesSimple Password"Simple Password"Keyed MD5"Keyed MD5"Meticulous Keyed MD5"Meticulous Keyed MD5"Keyed SHA1"Keyed SHA1"Meticulous Keyed SHA1"Meticulous Keyed SHA1"bfd_v1_authentication_valuesBFD_EXTRACT_DIAG(x)((x)&0x1f)BFD_EXTRACT_VERSION(x)(((x)&0xe0)>>5)/*
 * Local Variables:
 * c-style: whitesmith
 * c-basic-offset: 8
 * End:
 *//*
             * Unknown packet type.
             *//*
             * Echo packet.
             *//* BFDv1 *//* BFDv0 *//*
             * Control packet.
             *//*
 *    Keyed SHA1 and Meticulous Keyed SHA1 Authentication Section Format
 *
 *     0                   1                   2                   3
 *     0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
 *    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
 *    |   Auth Type   |   Auth Len    |  Auth Key ID  |   Reserved    |
 *    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
 *    |                        Sequence Number                        |
 *    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
 *    |                       Auth Key/Hash...                        |
 *    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
 *    |                              ...                              |
 *    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
 *//*
 *    Keyed MD5 and Meticulous Keyed MD5 Authentication Section Format
 *
 *     0                   1                   2                   3
 *     0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
 *    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
 *    |   Auth Type   |   Auth Len    |  Auth Key ID  |   Reserved    |
 *    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
 *    |                        Sequence Number                        |
 *    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
 *    |                      Auth Key/Digest...                       |
 *    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
 *    |                              ...                              |
 *    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
 *//* the length is equal to the password length plus three *//*
 *    Simple Password Authentication Section Format
 *
 *     0                   1                   2                   3
 *     0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
 *    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
 *    |   Auth Type   |   Auth Len    |  Auth Key ID  |  Password...  |
 *    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
 *    |                              ...                              |
 *    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
 *//* header + password max: 3 + 16 *//* header + password min: 3 + 1 *//* minimun 4 bytes *//*
 *    An optional Authentication Header may be present
 *
 *     0                   1                   2                   3
 *     0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
 *    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
 *    |   Auth Type   |   Auth Len    |    Authentication Data...     |
 *    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
 *//*
 *  Control packet, BFDv1, RFC 5880
 *
 *     0                   1                   2                   3
 *     0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
 *    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
 *    |Vers |  Diag   |Sta|P|F|C|A|D|M|  Detect Mult  |    Length     |
 *    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
 *    |                       My Discriminator                        |
 *    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
 *    |                      Your Discriminator                       |
 *    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
 *    |                    Desired Min TX Interval                    |
 *    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
 *    |                   Required Min RX Interval                    |
 *    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
 *    |                 Required Min Echo RX Interval                 |
 *    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
 *//*
 * Control packet, BFDv0, draft-ietf-bfd-base-01
 *
 *     0                   1                   2                   3
 *     0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
 *    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
 *    |Vers |  Diag   |H|D|P|F|C|A|Rsv|  Detect Mult  |    Length     |
 *    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
 *    |                       My Discriminator                        |
 *    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
 *    |                      Your Discriminator                       |
 *    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
 *    |                    Desired Min TX Interval                    |
 *    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
 *    |                   Required Min RX Interval                    |
 *    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
 *    |                 Required Min Echo RX Interval                 |
 *    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
 *//*
 * specification: draft-ietf-bfd-base-01 for version 0,
 * RFC 5880 for version 1, and RFC 5881
 *//* \summary: Bidirectional Forwarding Detection (BFD) printer *//Users/owura/Repos/codeql_eval/proj_repos/the-tcpdump-group-tcpdump-commit-9ba91381954ad325ea4fd26b9c65a8bd9a2a85b6/tcpdump/print-bgp.cbgp_printstartconst u_char[]markerconst u_char[16]bgphlen(ndo, ": BGP"): BGPsizeof(marker)BGP_SIZE&bgpp, BGP_SIZEp, 19bgp.bgp_len(ndo, "\n[|BGP Bogus header length %u < %u]", hlen, BGP_SIZE)(ndo, "\n[|BGP Bogus header length %u < %u]", hlen, 19)(ndo, "\n[|BGP %s]", tok2str(bgp_msg_values, "Unknown Message Type", bgp.bgp_type))bgp *
[|BGP Bogus header length %u < %u]char[36]
[|BGP %s]Unknown Message Typebgp_header_printdat[0]dat, BGP_SIZEdat, 19(ndo, "\n\t%s Message (%u), length: %u", tok2str(bgp_msg_values, "Unknown", bgp.bgp_type), bgp.bgp_type, length)
	%s Message (%u), length: %u(ndo, "\n\t  no Message %u decoder", bgp.bgp_type)BGP_OPENBGP_UPDATEBGP_NOTIFICATIONBGP_KEEPALIVEBGP_ROUTE_REFRESH
	  no Message %u decoder
	  "\n\t  "bgp_route_refresh_printconst bgp_route_refreshconst bgp_route_refresh *bgp_route_refresh *bgp_route_refresh_headerpptr[0]BGP_ROUTE_REFRESH_SIZE(ndo, "\n\t  AFI %s (%u), SAFI %s (%u)", tok2str(af_values,"Unknown", EXTRACT_16BITS(&bgp_route_refresh_header->afi)), EXTRACT_16BITS(&bgp_route_refresh_header->afi), tok2str(bgp_safi_values,"Unknown", bgp_route_refresh_header->safi), bgp_route_refresh_header->safi)(ndo, "\n\t  AFI %s (%u), SAFI %s (%u)", tok2str(af_values,"Unknown", ((uint16_t)(((uint16_t)(*((const uint8_t *)(&bgp_route_refresh_header->afi) + 0)) << 8) | ((uint16_t)(*((const uint8_t *)(&bgp_route_refresh_header->afi) + 1)) << 0)))), ((uint16_t)(((uint16_t)(*((const uint8_t *)(&bgp_route_refresh_header->afi) + 0)) << 8) | ((uint16_t)(*((const uint8_t *)(&bgp_route_refresh_header->afi) + 1)) << 0))), tok2str(bgp_safi_values,"Unknown", bgp_route_refresh_header->safi), bgp_route_refresh_header->safi)
	  AFI %s (%u), SAFI %s (%u)const uint8_t[2]const uint8_t(*)[2]unsigned char(*)[2]&bgp_route_refresh_header->aficonst tok[14]tok[14]bgp_notification_printbgpntptrBGP_NOTIFICATION_SIZE&bgpndat, BGP_NOTIFICATION_SIZEdat, 21bgp_notification *(ndo, ", %s (%u)", tok2str(bgp_notify_major_values, "Unknown Error", bgpn.bgpn_major), bgpn.bgpn_major), %s (%u)Unknown Error(ndo, ", subcode %s (%u)", tok2str(bgp_notify_minor_msg_values, "Unknown", bgpn.bgpn_minor), bgpn.bgpn_minor)(ndo, ", subcode %s (%u)", tok2str(bgp_notify_minor_open_values, "Unknown", bgpn.bgpn_minor), bgpn.bgpn_minor)(ndo, ", subcode %s (%u)", tok2str(bgp_notify_minor_update_values, "Unknown", bgpn.bgpn_minor), bgpn.bgpn_minor)(ndo, " subcode %s (%u)", tok2str(bgp_notify_minor_fsm_values, "Unknown", bgpn.bgpn_minor), bgpn.bgpn_minor)(ndo, " subcode %s (%u)", tok2str(bgp_notify_minor_cap_values, "Unknown", bgpn.bgpn_minor), bgpn.bgpn_minor)(ndo, ", subcode %s (%u)", tok2str(bgp_notify_minor_cease_values, "Unknown", bgpn.bgpn_minor), bgpn.bgpn_minor)*tptr(ndo, ", AFI %s (%u), SAFI %s (%u), Max Prefixes: %u", tok2str(af_values, "Unknown", EXTRACT_16BITS(tptr)), EXTRACT_16BITS(tptr), tok2str(bgp_safi_values, "Unknown", *(tptr+2)), *(tptr+2), EXTRACT_32BITS(tptr+3))(ndo, ", AFI %s (%u), SAFI %s (%u), Max Prefixes: %u", tok2str(af_values, "Unknown", ((uint16_t)(((uint16_t)(*((const uint8_t *)(tptr) + 0)) << 8) | ((uint16_t)(*((const uint8_t *)(tptr) + 1)) << 0)))), ((uint16_t)(((uint16_t)(*((const uint8_t *)(tptr) + 0)) << 8) | ((uint16_t)(*((const uint8_t *)(tptr) + 1)) << 0))), tok2str(bgp_safi_values, "Unknown", *(tptr+2)), *(tptr+2), ((uint32_t)(((uint32_t)(*((const uint8_t *)(tptr+3) + 0)) << 24) | ((uint32_t)(*((const uint8_t *)(tptr+3) + 1)) << 16) | ((uint32_t)(*((const uint8_t *)(tptr+3) + 2)) << 8) | ((uint32_t)(*((const uint8_t *)(tptr+3) + 3)) << 0))))tptr+3BGP_NOTIFY_MAJOR_MSG, subcode %s (%u)BGP_NOTIFY_MAJOR_OPENBGP_NOTIFY_MAJOR_UPDATEBGP_NOTIFY_MAJOR_FSM subcode %s (%u)BGP_NOTIFY_MAJOR_CAPBGP_NOTIFY_MAJOR_CEASEBGP_NOTIFY_MINOR_CEASE_MAXPRFX, AFI %s (%u), SAFI %s (%u), Max Prefixes: %ubgp_update_printwithdrawn_routes_len(ndo, "\n\t  Withdrawn routes: %d bytes", withdrawn_routes_len)
	  Withdrawn routes: %d bytes(ndo, "\n\t  End-of-Rib Marker (empty NLRI)")
	  End-of-Rib Marker (empty NLRI)aflagsalenlen(ndo, "\n\t  %s (%u), length: %u", tok2str(bgp_attr_values, "Unknown Attribute", atype), atype, alen)(ndo, ", Flags [%s%s%s%s", aflags & 0x80 ? "O" : "", aflags & 0x40 ? "T" : "", aflags & 0x20 ? "P" : "", aflags & 0x10 ? "E" : "")(ndo, "+%x", aflags & 0xf)(ndo, "]: ")atypealen
	  %s (%u), length: %uUnknown Attribute, Flags [%s%s%s%sOTPE+%x]: (ndo, "\n\t  Updated routes:")(ndo, "\n\t    (illegal prefix length)")(ndo, "\n\t    %s", buf)
	  Updated routes:char[356]MAXHOSTNAMELEN356
	    (illegal prefix length)-2-3
	    %sbgp_open_printbgpobgpoptoptBGP_OPEN_SIZE&bgpodat, BGP_OPEN_SIZEdat, 29bgp_open *(ndo, "\n\t  Version %d, ", bgpo.bgpo_version)
	  Version %d, (ndo, "my AS %s, ", as_printf(ndo, astostr, sizeof(astostr), ntohs(bgpo.bgpo_myas)))(ndo, "my AS %s, ", as_printf(ndo, astostr, sizeof(astostr), ((__uint16_t)(__builtin_constant_p(bgpo.bgpo_myas) ? ((__uint16_t)((((__uint16_t)(bgpo.bgpo_myas) & 0xff00U) >> 8) | (((__uint16_t)(bgpo.bgpo_myas) & 0x00ffU) << 8))) : _OSSwapInt16(bgpo.bgpo_myas)))))my AS %s, bgpo.bgpo_myas(ndo, "Holdtime %us, ", ntohs(bgpo.bgpo_holdtime))(ndo, "Holdtime %us, ", ((__uint16_t)(__builtin_constant_p(bgpo.bgpo_holdtime) ? ((__uint16_t)((((__uint16_t)(bgpo.bgpo_holdtime) & 0xff00U) >> 8) | (((__uint16_t)(bgpo.bgpo_holdtime) & 0x00ffU) << 8))) : _OSSwapInt16(bgpo.bgpo_holdtime))))Holdtime %us, bgpo.bgpo_holdtime(ndo, "ID %s", ipaddr_string(ndo, &bgpo.bgpo_id))(ndo, "ID %s", getname(ndo, (const u_char *)(&bgpo.bgpo_id)))ID %s&bgpo.bgpo_id(ndo, "\n\t  Optional parameters, length: %u", bgpo.bgpo_optlen)
	  Optional parameters, length: %uconst bgp_openconst bgp_open *opt[i]BGP_OPT_SIZE&bgpopt&opt[i], BGP_OPT_SIZE&opt[i], 2(ndo, "\n\t     Option %d, length: %u", bgpopt.bgpopt_type, bgpopt.bgpopt_len)(ndo, "\n\t    Option %s (%u), length: %u", tok2str(bgp_opt_values,"Unknown", bgpopt.bgpopt_type), bgpopt.bgpopt_type, bgpopt.bgpopt_len)(ndo, "\n\t      no decoder for option %u", bgpopt.bgpopt_type)bgp_opt *
	     Option %d, length: %u
	    Option %s (%u), length: %uBGP_OPT_CAPBGP_OPT_AUTH
	      no decoder for option %ubgp_capabilities_printcap_typecap_lentcap_lencap_offsetBGP_CAP_HEADER_SIZE(ndo, "\n\t      %s (%u), length: %u", tok2str(bgp_capcode_values, "Unknown", cap_type), cap_type, cap_len)opt[i+2]opt + i + 5*(opt + i + 5)(ndo, "\n\t\tAFI %s (%u), SAFI %s (%u)", tok2str(af_values, "Unknown", EXTRACT_16BITS(opt+i+2)), EXTRACT_16BITS(opt+i+2), tok2str(bgp_safi_values, "Unknown", opt[i+5]), opt[i+5])(ndo, "\n\t\tAFI %s (%u), SAFI %s (%u)", tok2str(af_values, "Unknown", ((uint16_t)(((uint16_t)(*((const uint8_t *)(opt+i+2) + 0)) << 8) | ((uint16_t)(*((const uint8_t *)(opt+i+2) + 1)) << 0)))), ((uint16_t)(((uint16_t)(*((const uint8_t *)(opt+i+2) + 0)) << 8) | ((uint16_t)(*((const uint8_t *)(opt+i+2) + 1)) << 0))), tok2str(bgp_safi_values, "Unknown", opt[i+5]), opt[i+5])opt+i+2opt + i + 2*(opt + i + 2)(ndo, "\n\t\tRestart Flags: [%s], Restart Time %us", ((opt[i+2])&0x80) ? "R" : "none", EXTRACT_16BITS(opt+i+2)&0xfff)(ndo, "\n\t\tRestart Flags: [%s], Restart Time %us", ((opt[i+2])&0x80) ? "R" : "none", ((uint16_t)(((uint16_t)(*((const uint8_t *)(opt+i+2) + 0)) << 8) | ((uint16_t)(*((const uint8_t *)(opt+i+2) + 1)) << 0)))&0xfff)opt + i + cap_offset + 3*(opt + i + cap_offset + 3)(ndo, "\n\t\t  AFI %s (%u), SAFI %s (%u), Forwarding state preserved: %s", tok2str(af_values,"Unknown", EXTRACT_16BITS(opt+i+cap_offset)), EXTRACT_16BITS(opt+i+cap_offset), tok2str(bgp_safi_values,"Unknown", opt[i+cap_offset+2]), opt[i+cap_offset+2], ((opt[i+cap_offset+3])&0x80) ? "yes" : "no" )(ndo, "\n\t\t  AFI %s (%u), SAFI %s (%u), Forwarding state preserved: %s", tok2str(af_values,"Unknown", ((uint16_t)(((uint16_t)(*((const uint8_t *)(opt+i+cap_offset) + 0)) << 8) | ((uint16_t)(*((const uint8_t *)(opt+i+cap_offset) + 1)) << 0)))), ((uint16_t)(((uint16_t)(*((const uint8_t *)(opt+i+cap_offset) + 0)) << 8) | ((uint16_t)(*((const uint8_t *)(opt+i+cap_offset) + 1)) << 0))), tok2str(bgp_safi_values,"Unknown", opt[i+cap_offset+2]), opt[i+cap_offset+2], ((opt[i+cap_offset+3])&0x80) ? "yes" : "no" )opt+i+cap_offset(ndo, "\n\t\t 4 Byte AS %s", as_printf(ndo, astostr, sizeof(astostr), EXTRACT_32BITS(opt + i + 2)))(ndo, "\n\t\t 4 Byte AS %s", as_printf(ndo, astostr, sizeof(astostr), ((uint32_t)(((uint32_t)(*((const uint8_t *)(opt + i + 2) + 0)) << 24) | ((uint32_t)(*((const uint8_t *)(opt + i + 2) + 1)) << 16) | ((uint32_t)(*((const uint8_t *)(opt + i + 2) + 2)) << 8) | ((uint32_t)(*((const uint8_t *)(opt + i + 2) + 3)) << 0)))))(ndo, "\n\t\t(invalid)")(ndo, "\n\t\tAFI %s (%u), SAFI %s (%u), Send/Receive: %s", tok2str(af_values,"Unknown",EXTRACT_16BITS(opt+i+cap_offset)), EXTRACT_16BITS(opt+i+cap_offset), tok2str(bgp_safi_values,"Unknown",opt[i+cap_offset+2]), opt[i+cap_offset+2], tok2str(bgp_add_path_recvsend,"Bogus (0x%02x)",opt[i+cap_offset+3]) )(ndo, "\n\t\tAFI %s (%u), SAFI %s (%u), Send/Receive: %s", tok2str(af_values,"Unknown",((uint16_t)(((uint16_t)(*((const uint8_t *)(opt+i+cap_offset) + 0)) << 8) | ((uint16_t)(*((const uint8_t *)(opt+i+cap_offset) + 1)) << 0)))), ((uint16_t)(((uint16_t)(*((const uint8_t *)(opt+i+cap_offset) + 0)) << 8) | ((uint16_t)(*((const uint8_t *)(opt+i+cap_offset) + 1)) << 0))), tok2str(bgp_safi_values,"Unknown",opt[i+cap_offset+2]), opt[i+cap_offset+2], tok2str(bgp_add_path_recvsend,"Bogus (0x%02x)",opt[i+cap_offset+3]) )(ndo, "\n\t\tno decoder for Capability %u", cap_type)
	      %s (%u), length: %uBGP_CAPCODE_MP
		AFI %s (%u), SAFI %s (%u)BGP_CAPCODE_RESTART
		Restart Flags: [%s], Restart Time %uscaps_lenR
		  AFI %s (%u), SAFI %s (%u), Forwarding state preserved: %schar[63]yesnoBGP_CAPCODE_RRBGP_CAPCODE_RR_CISCOBGP_CAPCODE_AS_NEW
		 4 Byte AS %sBGP_CAPCODE_ADD_PATH
		(invalid)
		AFI %s (%u), SAFI %s (%u), Send/Receive: %sBogus (0x%02x)
		no decoder for Capability %u
		"\n\t\t"bgp_attr_printafsafisnpanhlenbwadvancetlenas_size(ndo, "invalid len")sizeof(*tptr)(ndo, "%s", tok2str(bgp_origin_values, "Unknown Origin Typecode", tptr[0]))(ndo, "empty")tptr[0]sizeof(tptr[0])(ndo, "%s", tok2str(bgp_as_path_segment_open_values, "?", tptr[0]))tptr[1]sizeof(tptr[1])tptr[2 + i](ndo, "%s ", as_printf(ndo, astostr, sizeof(astostr), as_size == 2 ? EXTRACT_16BITS(&tptr[2 + i]) : EXTRACT_32BITS(&tptr[2 + i])))(ndo, "%s ", as_printf(ndo, astostr, sizeof(astostr), as_size == 2 ? ((uint16_t)(((uint16_t)(*((const uint8_t *)(&tptr[2 + i]) + 0)) << 8) | ((uint16_t)(*((const uint8_t *)(&tptr[2 + i]) + 1)) << 0))) : ((uint32_t)(((uint32_t)(*((const uint8_t *)(&tptr[2 + i]) + 0)) << 24) | ((uint32_t)(*((const uint8_t *)(&tptr[2 + i]) + 1)) << 16) | ((uint32_t)(*((const uint8_t *)(&tptr[2 + i]) + 2)) << 8) | ((uint32_t)(*((const uint8_t *)(&tptr[2 + i]) + 3)) << 0)))))&tptr[2 + i](ndo, "%s", tok2str(bgp_as_path_segment_close_values, "?", tptr[0]))(ndo, "%s", ipaddr_string(ndo, tptr))(ndo, "%s", getname(ndo, (const u_char *)(tptr)))(ndo, "%u", EXTRACT_32BITS(tptr))(ndo, "%u", ((uint32_t)(((uint32_t)(*((const uint8_t *)(tptr) + 0)) << 24) | ((uint32_t)(*((const uint8_t *)(tptr) + 1)) << 16) | ((uint32_t)(*((const uint8_t *)(tptr) + 2)) << 8) | ((uint32_t)(*((const uint8_t *)(tptr) + 3)) << 0))))(ndo, " AS #%s, origin %s", as_printf(ndo, astostr, sizeof(astostr), EXTRACT_16BITS(tptr)), ipaddr_string(ndo, tptr + 2))(ndo, " AS #%s, origin %s", as_printf(ndo, astostr, sizeof(astostr), ((uint16_t)(((uint16_t)(*((const uint8_t *)(tptr) + 0)) << 8) | ((uint16_t)(*((const uint8_t *)(tptr) + 1)) << 0)))), getname(ndo, (const u_char *)(tptr + 2)))tptr + 2(ndo, " AS #%s, origin %s", as_printf(ndo, astostr, sizeof(astostr), EXTRACT_32BITS(tptr)), ipaddr_string(ndo, tptr + 4))(ndo, " AS #%s, origin %s", as_printf(ndo, astostr, sizeof(astostr), ((uint32_t)(((uint32_t)(*((const uint8_t *)(tptr) + 0)) << 24) | ((uint32_t)(*((const uint8_t *)(tptr) + 1)) << 16) | ((uint32_t)(*((const uint8_t *)(tptr) + 2)) << 8) | ((uint32_t)(*((const uint8_t *)(tptr) + 3)) << 0)))), getname(ndo, (const u_char *)(tptr + 4)))tptr + 4(ndo, " NO_EXPORT")(ndo, " NO_ADVERTISE")(ndo, " NO_EXPORT_SUBCONFED")(ndo, "%u:%u%s", (comm >> 16) & 0xffff, comm & 0xffff, (tlen>4) ? ", " : "")(ndo, "%s",ipaddr_string(ndo, tptr))(ndo, "%s",getname(ndo, (const u_char *)(tptr)))(ndo, "%s%s", ipaddr_string(ndo, tptr), (tlen>4) ? ", " : "")(ndo, "%s%s", getname(ndo, (const u_char *)(tptr)), (tlen>4) ? ", " : "")(ndo, "\n\t    AFI: %s (%u), %sSAFI: %s (%u)", tok2str(af_values, "Unknown AFI", af), af, (safi>128) ? "vendor specific " : "", tok2str(bgp_safi_values, "Unknown SAFI", safi), safi)(ndo, "\n\t    no AFI %u / SAFI %u decoder", af, safi)(ndo, "\n\t    nexthop: ")(ndo, ", " )sizeof(struct in_addr)sizeof(struct in_addr)+BGP_VPN_RD_LENsizeof(struct in_addr)+8(ndo, "RD: %s, %s", bgp_vpn_rd_print(ndo, tptr), ipaddr_string(ndo, tptr+BGP_VPN_RD_LEN))(ndo, "RD: %s, %s", bgp_vpn_rd_print(ndo, tptr), getname(ndo, (const u_char *)(tptr+8)))tptr+BGP_VPN_RD_LENtptr+8sizeof(struct in6_addr)(ndo, "%s", ip6addr_string(ndo, tptr))(ndo, "%s", getname6(ndo, (const u_char *)(tptr)))sizeof(struct in6_addr)+BGP_VPN_RD_LENsizeof(struct in6_addr)+8(ndo, "RD: %s, %s", bgp_vpn_rd_print(ndo, tptr), ip6addr_string(ndo, tptr+BGP_VPN_RD_LEN))(ndo, "RD: %s, %s", bgp_vpn_rd_print(ndo, tptr), getname6(ndo, (const u_char *)(tptr+8)))(ndo, "%s", isonsap_string(ndo, tptr, tlen))(ndo, "RD: %s, %s", bgp_vpn_rd_print(ndo, tptr), isonsap_string(ndo, tptr+BGP_VPN_RD_LEN,tlen-BGP_VPN_RD_LEN))(ndo, "RD: %s, %s", bgp_vpn_rd_print(ndo, tptr), isonsap_string(ndo, tptr+8,tlen-8))(ndo, " = %s", ipaddr_string(ndo, tptr+BGP_VPN_RD_LEN+4))(ndo, " = %s", getname(ndo, (const u_char *)(tptr+8+4)))tptr+BGP_VPN_RD_LEN+4tptr+8+4(ndo, " = %s", ip6addr_string(ndo, tptr+BGP_VPN_RD_LEN+3))(ndo, " = %s", getname6(ndo, (const u_char *)(tptr+8+3)))tptr+BGP_VPN_RD_LEN+3tptr+8+3(ndo, "no AFI %u/SAFI %u decoder", af, safi)(ndo, ", nh-length: %u", nhlen)(ndo, "\n\t    %u SNPA", snpa)(ndo, "\n\t      %d bytes", tptr[0])(ndo, ", no SNPA")(ndo, "\n\t      %s", buf)(ndo, "\n\t    (illegal length)")BGP_MP_NLRI_MINSIZE(ndo, "\n\t      End-of-Rib Marker (empty NLRI)")*(tptr-3)(ndo, "no AFI %u / SAFI %u decoder", af, safi)(ndo, "\n\t    %s (0x%04x), Flags [%s]", tok2str(bgp_extd_comm_subtype_values, "unknown extd community typecode", extd_comm), extd_comm, bittok2str(bgp_extd_comm_flag_values, "none", extd_comm))*(tptr+2)(ndo, ": %u:%u (= %s)", EXTRACT_16BITS(tptr+2), EXTRACT_32BITS(tptr+4), ipaddr_string(ndo, tptr+4))(ndo, ": %u:%u (= %s)", ((uint16_t)(((uint16_t)(*((const uint8_t *)(tptr+2) + 0)) << 8) | ((uint16_t)(*((const uint8_t *)(tptr+2) + 1)) << 0))), ((uint32_t)(((uint32_t)(*((const uint8_t *)(tptr+4) + 0)) << 24) | ((uint32_t)(*((const uint8_t *)(tptr+4) + 1)) << 16) | ((uint32_t)(*((const uint8_t *)(tptr+4) + 2)) << 8) | ((uint32_t)(*((const uint8_t *)(tptr+4) + 3)) << 0))), getname(ndo, (const u_char *)(tptr+4)))tptr+2tptr+4(ndo, ": %s:%u", ipaddr_string(ndo, tptr+2), EXTRACT_16BITS(tptr+6))(ndo, ": %s:%u", getname(ndo, (const u_char *)(tptr+2)), ((uint16_t)(((uint16_t)(*((const uint8_t *)(tptr+6) + 0)) << 8) | ((uint16_t)(*((const uint8_t *)(tptr+6) + 1)) << 0))))tptr+6(ndo, ": %s:%u", as_printf(ndo, astostr, sizeof(astostr), EXTRACT_32BITS(tptr+2)), EXTRACT_16BITS(tptr+6))(ndo, ": %s:%u", as_printf(ndo, astostr, sizeof(astostr), ((uint32_t)(((uint32_t)(*((const uint8_t *)(tptr+2) + 0)) << 24) | ((uint32_t)(*((const uint8_t *)(tptr+2) + 1)) << 16) | ((uint32_t)(*((const uint8_t *)(tptr+2) + 2)) << 8) | ((uint32_t)(*((const uint8_t *)(tptr+2) + 3)) << 0)))), ((uint16_t)(((uint16_t)(*((const uint8_t *)(tptr+6) + 0)) << 8) | ((uint16_t)(*((const uint8_t *)(tptr+6) + 1)) << 0))))(ndo, ": bandwidth: %.3f Mbps", bw.f*8/1000000)(ndo, "%s", ipaddr_string(ndo, tptr+2))(ndo, "%s", getname(ndo, (const u_char *)(tptr+2)))(ndo, ": area:%s, router-type:%s, metric-type:%s%s", ipaddr_string(ndo, tptr+2), tok2str(bgp_extd_comm_ospf_rtype_values, "unknown (0x%02x)", *(tptr+6)), (*(tptr+7) & BGP_OSPF_RTYPE_METRIC_TYPE) ? "E2" : "", ((*(tptr+6) == BGP_OSPF_RTYPE_EXT) || (*(tptr+6) == BGP_OSPF_RTYPE_NSSA)) ? "E1" : "")(ndo, ": area:%s, router-type:%s, metric-type:%s%s", getname(ndo, (const u_char *)(tptr+2)), tok2str(bgp_extd_comm_ospf_rtype_values, "unknown (0x%02x)", *(tptr+6)), (*(tptr+7) & 0x1) ? "E2" : "", ((*(tptr+6) == 5) || (*(tptr+6) == 7)) ? "E1" : "")(ndo, ": %s Control Flags [0x%02x]:MTU %u", tok2str(l2vpn_encaps_values, "unknown encaps", *(tptr+2)), *(tptr+3), EXTRACT_16BITS(tptr+4))(ndo, ": %s Control Flags [0x%02x]:MTU %u", tok2str(l2vpn_encaps_values, "unknown encaps", *(tptr+2)), *(tptr+3), ((uint16_t)(((uint16_t)(*((const uint8_t *)(tptr+4) + 0)) << 8) | ((uint16_t)(*((const uint8_t *)(tptr+4) + 1)) << 0))))(ndo, ": AS %u", EXTRACT_16BITS(tptr+2))(ndo, ": AS %u", ((uint16_t)(((uint16_t)(*((const uint8_t *)(tptr+2) + 0)) << 8) | ((uint16_t)(*((const uint8_t *)(tptr+2) + 1)) << 0))))(ndo, "\n\t    Tunnel-type %s (%u), Flags [%s], MPLS Label %u", tok2str(bgp_pmsi_tunnel_values, "Unknown", tunnel_type), tunnel_type, bittok2str(bgp_pmsi_flag_values, "none", flags), EXTRACT_24BITS(tptr+2)>>4)(ndo, "\n\t    Tunnel-type %s (%u), Flags [%s], MPLS Label %u", tok2str(bgp_pmsi_tunnel_values, "Unknown", tunnel_type), tunnel_type, bittok2str(bgp_pmsi_flag_values, "none", flags), ((uint32_t)(((uint32_t)(*((const uint8_t *)(tptr+2) + 0)) << 16) | ((uint32_t)(*((const uint8_t *)(tptr+2) + 1)) << 8) | ((uint32_t)(*((const uint8_t *)(tptr+2) + 2)) << 0)))>>4)(ndo, "\n\t      Sender %s, P-Group %s", ipaddr_string(ndo, tptr), ipaddr_string(ndo, tptr+4))(ndo, "\n\t      Sender %s, P-Group %s", getname(ndo, (const u_char *)(tptr)), getname(ndo, (const u_char *)(tptr+4)))(ndo, "\n\t      Root-Node %s, P-Group %s", ipaddr_string(ndo, tptr), ipaddr_string(ndo, tptr+4))(ndo, "\n\t      Root-Node %s, P-Group %s", getname(ndo, (const u_char *)(tptr)), getname(ndo, (const u_char *)(tptr+4)))(ndo, "\n\t      Tunnel-Endpoint %s", ipaddr_string(ndo, tptr))(ndo, "\n\t      Tunnel-Endpoint %s", getname(ndo, (const u_char *)(tptr)))(ndo, "\n\t      Root-Node %s, LSP-ID 0x%08x", ipaddr_string(ndo, tptr), EXTRACT_32BITS(tptr+4))(ndo, "\n\t      Root-Node %s, LSP-ID 0x%08x", getname(ndo, (const u_char *)(tptr)), ((uint32_t)(((uint32_t)(*((const uint8_t *)(tptr+4) + 0)) << 24) | ((uint32_t)(*((const uint8_t *)(tptr+4) + 1)) << 16) | ((uint32_t)(*((const uint8_t *)(tptr+4) + 2)) << 8) | ((uint32_t)(*((const uint8_t *)(tptr+4) + 3)) << 0))))(ndo, "\n\t      Extended-Tunnel-ID %s, P2MP-ID 0x%08x", ipaddr_string(ndo, tptr), EXTRACT_32BITS(tptr+4))(ndo, "\n\t      Extended-Tunnel-ID %s, P2MP-ID 0x%08x", getname(ndo, (const u_char *)(tptr)), ((uint32_t)(((uint32_t)(*((const uint8_t *)(tptr+4) + 0)) << 24) | ((uint32_t)(*((const uint8_t *)(tptr+4) + 1)) << 16) | ((uint32_t)(*((const uint8_t *)(tptr+4) + 2)) << 8) | ((uint32_t)(*((const uint8_t *)(tptr+4) + 3)) << 0))))tptr+1(ndo, "\n\t    %s TLV (%u), length %u", tok2str(bgp_aigp_values, "Unknown", type), type, length)tptr[3](ndo, ", metric %" PRIu64, EXTRACT_64BITS(tptr))(ndo, ", metric %" "ll" "u", ((uint64_t)(((uint64_t)(*((const uint8_t *)(tptr) + 0)) << 56) | ((uint64_t)(*((const uint8_t *)(tptr) + 1)) << 48) | ((uint64_t)(*((const uint8_t *)(tptr) + 2)) << 40) | ((uint64_t)(*((const uint8_t *)(tptr) + 3)) << 32) | ((uint64_t)(*((const uint8_t *)(tptr) + 4)) << 24) | ((uint64_t)(*((const uint8_t *)(tptr) + 5)) << 16) | ((uint64_t)(*((const uint8_t *)(tptr) + 6)) << 8) | ((uint64_t)(*((const uint8_t *)(tptr) + 7)) << 0))))(ndo, "\n\t    Origin AS: %s", as_printf(ndo, astostr, sizeof(astostr), EXTRACT_32BITS(tptr)))(ndo, "\n\t    Origin AS: %s", as_printf(ndo, astostr, sizeof(astostr), ((uint32_t)(((uint32_t)(*((const uint8_t *)(tptr) + 0)) << 24) | ((uint32_t)(*((const uint8_t *)(tptr) + 1)) << 16) | ((uint32_t)(*((const uint8_t *)(tptr) + 2)) << 8) | ((uint32_t)(*((const uint8_t *)(tptr) + 3)) << 0)))))(ndo, "\n\t      %s (%u), length: %u", tok2str(bgp_attr_values, "Unknown Attribute", atype), atype, alen)(ndo, "\n\t    ")(ndo, "%u:%u:%u%s", EXTRACT_32BITS(tptr), EXTRACT_32BITS(tptr + 4), EXTRACT_32BITS(tptr + 8), (len > 12) ? ", " : "")(ndo, "%u:%u:%u%s", ((uint32_t)(((uint32_t)(*((const uint8_t *)(tptr) + 0)) << 24) | ((uint32_t)(*((const uint8_t *)(tptr) + 1)) << 16) | ((uint32_t)(*((const uint8_t *)(tptr) + 2)) << 8) | ((uint32_t)(*((const uint8_t *)(tptr) + 3)) << 0))), ((uint32_t)(((uint32_t)(*((const uint8_t *)(tptr + 4) + 0)) << 24) | ((uint32_t)(*((const uint8_t *)(tptr + 4) + 1)) << 16) | ((uint32_t)(*((const uint8_t *)(tptr + 4) + 2)) << 8) | ((uint32_t)(*((const uint8_t *)(tptr + 4) + 3)) << 0))), ((uint32_t)(((uint32_t)(*((const uint8_t *)(tptr + 8) + 0)) << 24) | ((uint32_t)(*((const uint8_t *)(tptr + 8) + 1)) << 16) | ((uint32_t)(*((const uint8_t *)(tptr + 8) + 2)) << 8) | ((uint32_t)(*((const uint8_t *)(tptr + 8) + 3)) << 0))), (len > 12) ? ", " : "")tptr + 8(ndo, "\n\t    no Attribute %u decoder", atype)BGPTYPE_ORIGINinvalid lenUnknown Origin TypecodeBGPTYPE_AS4_PATHBGPTYPE_AS_PATHempty?BGPTYPE_NEXT_HOPBGPTYPE_MULTI_EXIT_DISCBGPTYPE_LOCAL_PREFBGPTYPE_ATOMIC_AGGREGATEBGPTYPE_AGGREGATOR AS #%s, origin %sBGPTYPE_AGGREGATOR4BGPTYPE_COMMUNITIEScomm4294967041BGP_COMMUNITY_NO_EXPORT NO_EXPORT4294967042BGP_COMMUNITY_NO_ADVERT NO_ADVERTISE4294967043BGP_COMMUNITY_NO_EXPORT_SUBCONFED NO_EXPORT_SUBCONFED%u:%u%sBGPTYPE_ORIGINATOR_IDBGPTYPE_CLUSTER_LISTBGPTYPE_MP_REACH_NLRI
	    AFI: %s (%u), %sSAFI: %s (%u)Unknown AFIvendor specific Unknown SAFISAFNUM_UNICAST(AFNUM_INET<<8 | SAFNUM_UNICAST)SAFNUM_MULTICAST(AFNUM_INET<<8 | SAFNUM_MULTICAST)SAFNUM_UNIMULTICAST(AFNUM_INET<<8 | SAFNUM_UNIMULTICAST)SAFNUM_LABUNICAST260(AFNUM_INET<<8 | SAFNUM_LABUNICAST)SAFNUM_RT_ROUTING_INFO388(AFNUM_INET<<8 | SAFNUM_RT_ROUTING_INFO)SAFNUM_VPNUNICAST(AFNUM_INET<<8 | SAFNUM_VPNUNICAST)SAFNUM_VPNMULTICAST385(AFNUM_INET<<8 | SAFNUM_VPNMULTICAST)SAFNUM_VPNUNIMULTICAST386(AFNUM_INET<<8 | SAFNUM_VPNUNIMULTICAST)SAFNUM_MULTICAST_VPN261(AFNUM_INET<<8 | SAFNUM_MULTICAST_VPN)SAFNUM_MDT322(AFNUM_INET<<8 | SAFNUM_MDT)513(AFNUM_INET6<<8 | SAFNUM_UNICAST)(AFNUM_INET6<<8 | SAFNUM_MULTICAST)515(AFNUM_INET6<<8 | SAFNUM_UNIMULTICAST)516(AFNUM_INET6<<8 | SAFNUM_LABUNICAST)(AFNUM_INET6<<8 | SAFNUM_VPNUNICAST)641(AFNUM_INET6<<8 | SAFNUM_VPNMULTICAST)642(AFNUM_INET6<<8 | SAFNUM_VPNUNIMULTICAST)768769(AFNUM_NSAP<<8 | SAFNUM_UNICAST)770(AFNUM_NSAP<<8 | SAFNUM_MULTICAST)771(AFNUM_NSAP<<8 | SAFNUM_UNIMULTICAST)896(AFNUM_NSAP<<8 | SAFNUM_VPNUNICAST)897(AFNUM_NSAP<<8 | SAFNUM_VPNMULTICAST)898(AFNUM_NSAP<<8 | SAFNUM_VPNUNIMULTICAST)5017650304(AFNUM_L2VPN<<8 | SAFNUM_VPNUNICAST)50305(AFNUM_L2VPN<<8 | SAFNUM_VPNMULTICAST)50306(AFNUM_L2VPN<<8 | SAFNUM_VPNUNIMULTICAST)6400SAFNUM_VPLS6465(AFNUM_VPLS<<8 | SAFNUM_VPLS)
	    no AFI %u / SAFI %u decoder
	    "\n\t    "nnh
	    nexthop: (int)sizeof(struct in_addr)BGP_VPN_RD_LEN(int)(sizeof(struct in_addr)+BGP_VPN_RD_LEN)RD: %s, %s(sizeof(struct in_addr)+BGP_VPN_RD_LEN)(int)sizeof(struct in6_addr)(int)(sizeof(struct in6_addr)+BGP_VPN_RD_LEN)(sizeof(struct in6_addr)+BGP_VPN_RD_LEN)(sizeof(struct in_addr))11911838730x47000601 = %s34734080x350000no AFI %u/SAFI %u decoder, nh-length: %u
	    %u SNPA
	      %d bytes, no SNPA
	      %s517(AFNUM_INET6<<8 | SAFNUM_MULTICAST_VPN)
	    (illegal length)doneBGPTYPE_MP_UNREACH_NLRI
	      End-of-Rib Marker (empty NLRI)no AFI %u / SAFI %u decoderBGPTYPE_EXTD_COMMUNITIESextd_comm
	    %s (0x%04x), Flags [%s]const tok[27]tok[27]unknown extd community typecodeBGP_EXT_COM_RT_0BGP_EXT_COM_RO_0BGP_EXT_COM_L2VPN_RT_0: %u:%u (= %s)BGP_EXT_COM_RT_1BGP_EXT_COM_RO_161706BGP_EXT_COM_L2VPN_RT_1267BGP_EXT_COM_VRF_RT_IMP: %s:%uBGP_EXT_COM_RT_2BGP_EXT_COM_RO_216388BGP_EXT_COM_LINKBAND: bandwidth: %.3f Mbps8.01000000.0BGP_EXT_COM_VPN_ORIGINBGP_EXT_COM_VPN_ORIGIN2BGP_EXT_COM_VPN_ORIGIN332773BGP_EXT_COM_VPN_ORIGIN4BGP_EXT_COM_OSPF_RID32769BGP_EXT_COM_OSPF_RID2774BGP_EXT_COM_OSPF_RTYPEBGP_EXT_COM_OSPF_RTYPE2: area:%s, router-type:%s, metric-type:%s%sunknown (0x%02x)E2E132778BGP_EXT_COM_L2INFO: %s Control Flags [0x%02x]:MTU %uunknown encapsBGP_EXT_COM_SOURCE_AS: AS %u
	      "\n\t      "BGPTYPE_PMSI_TUNNELtunnel_type
	    Tunnel-type %s (%u), Flags [%s], MPLS Label %uconst tok[2]tok[2]BGP_PMSI_TUNNEL_PIM_SMBGP_PMSI_TUNNEL_PIM_BIDIR
	      Sender %s, P-Group %sBGP_PMSI_TUNNEL_PIM_SSM
	      Root-Node %s, P-Group %sBGP_PMSI_TUNNEL_INGRESS
	      Tunnel-Endpoint %sBGP_PMSI_TUNNEL_LDP_P2MPBGP_PMSI_TUNNEL_LDP_MP2MP
	      Root-Node %s, LSP-ID 0x%08xBGP_PMSI_TUNNEL_RSVP_P2MP
	      Extended-Tunnel-ID %s, P2MP-ID 0x%08xBGPTYPE_AIGP
	    %s TLV (%u), length %uBGP_AIGP_TLV, metric %lluBGPTYPE_ATTR_SET
	    Origin AS: %sBGPTYPE_LARGE_COMMUNITY%u:%u:%u%s
	    no Attribute %u decoderbgp_attr_get_as_sizebgpa_typedecode_labeled_vpn_clnp_prefixuint8_t[19]unsigned char[19]sizeof(pptr[0])24+64(24+64)0, sizeof(addr)uint8_t(*)[19]unsigned char(*)[19]pptr[12](plen + 7) / 8&pptr[12], (plen + 7) / 80xff00"RD: %s, %s/%d, label:%u %s", bgp_vpn_rd_print(ndo, pptr+4), isonsap_string(ndo, addr,(plen + 7) / 8), plen, EXTRACT_24BITS(pptr+1)>>4, ((pptr[3]&1)==0) ? "(BOGUS: Bottom of Stack NOT set!)" : "(bottom)""RD: %s, %s/%d, label:%u %s", bgp_vpn_rd_print(ndo, pptr+4), isonsap_string(ndo, addr,(plen + 7) / 8), plen, ((uint32_t)(((uint32_t)(*((const uint8_t *)(pptr+1) + 0)) << 16) | ((uint32_t)(*((const uint8_t *)(pptr+1) + 1)) << 8) | ((uint32_t)(*((const uint8_t *)(pptr+1) + 2)) << 0)))>>4, ((pptr[3]&1)==0) ? "(BOGUS: Bottom of Stack NOT set!)" : "(bottom)"RD: %s, %s/%d, label:%u %spptr+1(BOGUS: Bottom of Stack NOT set!)(bottom)decode_clnp_prefixpptr[4]&pptr[4], (plen + 7) / 8"%s/%d", isonsap_string(ndo, addr,(plen + 7) / 8), plen%s/%ddecode_labeled_vpn_prefix6__uint8_t[16]__uint8_t *"RD: %s, %s/%d, label:%u %s", bgp_vpn_rd_print(ndo, pptr+4), ip6addr_string(ndo, &addr), plen, EXTRACT_24BITS(pptr+1)>>4, ((pptr[3]&1)==0) ? "(BOGUS: Bottom of Stack NOT set!)" : "(bottom)""RD: %s, %s/%d, label:%u %s", bgp_vpn_rd_print(ndo, pptr+4), getname6(ndo, (const u_char *)(&addr)), plen, ((uint32_t)(((uint32_t)(*((const uint8_t *)(pptr+1) + 0)) << 16) | ((uint32_t)(*((const uint8_t *)(pptr+1) + 1)) << 8) | ((uint32_t)(*((const uint8_t *)(pptr+1) + 2)) << 0)))>>4, ((pptr[3]&1)==0) ? "(BOGUS: Bottom of Stack NOT set!)" : "(bottom)"decode_labeled_prefix6plenbytes&pptr[4], plenbytes"%s/%d, label:%u %s", ip6addr_string(ndo, &addr), plen, EXTRACT_24BITS(pptr+1)>>4, ((pptr[3]&1)==0) ? "(BOGUS: Bottom of Stack NOT set!)" : "(bottom)""%s/%d, label:%u %s", getname6(ndo, (const u_char *)(&addr)), plen, ((uint32_t)(((uint32_t)(*((const uint8_t *)(pptr+1) + 0)) << 16) | ((uint32_t)(*((const uint8_t *)(pptr+1) + 1)) << 8) | ((uint32_t)(*((const uint8_t *)(pptr+1) + 2)) << 0)))>>4, ((pptr[3]&1)==0) ? "(BOGUS: Bottom of Stack NOT set!)" : "(bottom)"%s/%d, label:%u %sbadtlvdecode_prefix6pd[0]sizeof(pd[0])itemlenpdpd[1]&pd[1], plenbytes"%s/%d", ip6addr_string(ndo, &addr), plen"%s/%d", getname6(ndo, (const u_char *)(&addr)), plendecode_labeled_vpn_l2stringlentlv_lenttlv_len"RD: %s, BGPNH: %s", bgp_vpn_rd_print(ndo, pptr), ipaddr_string(ndo, pptr+8)"RD: %s, BGPNH: %s", bgp_vpn_rd_print(ndo, pptr), getname(ndo, (const u_char *)(pptr+8))pptr+8"RD: %s, CE-ID: %u, Label-Block Offset: %u, Label Base %u", bgp_vpn_rd_print(ndo, pptr), EXTRACT_16BITS(pptr+8), EXTRACT_16BITS(pptr+10), EXTRACT_24BITS(pptr+12)>>4"RD: %s, CE-ID: %u, Label-Block Offset: %u, Label Base %u", bgp_vpn_rd_print(ndo, pptr), ((uint16_t)(((uint16_t)(*((const uint8_t *)(pptr+8) + 0)) << 8) | ((uint16_t)(*((const uint8_t *)(pptr+8) + 1)) << 0))), ((uint16_t)(((uint16_t)(*((const uint8_t *)(pptr+10) + 0)) << 8) | ((uint16_t)(*((const uint8_t *)(pptr+10) + 1)) << 0))), ((uint32_t)(((uint32_t)(*((const uint8_t *)(pptr+12) + 0)) << 16) | ((uint32_t)(*((const uint8_t *)(pptr+12) + 1)) << 8) | ((uint32_t)(*((const uint8_t *)(pptr+12) + 2)) << 0)))>>4pptr+10pptr+12"\n\t\tcircuit status vector (%u) length: %u: 0x", tlv_type, tlv_len"%02x",*pptr++"\n\t\tunknown TLV #%u, length: %u", tlv_type, tlv_lenRD: %s, BGPNH: %sRD: %s, CE-ID: %u, Label-Block Offset: %u, Label Base %uchar[57]
		circuit status vector (%u) length: %u: 0x
		unknown TLV #%u, length: %udecode_multicast_vpnroute_typeroute_lengthaddr_lengthsg_length"Route-Type: %s (%u), length: %u", tok2str(bgp_multicast_vpn_route_type_values, "Unknown", route_type), route_type, route_lengthRoute-Type: %s (%u), length: %ubuf + offsetbuflen - offset", RD: %s, Originator %s", bgp_vpn_rd_print(ndo, pptr), bgp_vpn_ip_print(ndo, pptr + BGP_VPN_RD_LEN, (route_length - BGP_VPN_RD_LEN) << 3)", RD: %s, Originator %s", bgp_vpn_rd_print(ndo, pptr), bgp_vpn_ip_print(ndo, pptr + 8, (route_length - 8) << 3)BGP_VPN_RD_LEN + 48 + 4", RD: %s, Source-AS %s", bgp_vpn_rd_print(ndo, pptr), as_printf(ndo, astostr, sizeof(astostr), EXTRACT_32BITS(pptr + BGP_VPN_RD_LEN))", RD: %s, Source-AS %s", bgp_vpn_rd_print(ndo, pptr), as_printf(ndo, astostr, sizeof(astostr), ((uint32_t)(((uint32_t)(*((const uint8_t *)(pptr + 8) + 0)) << 24) | ((uint32_t)(*((const uint8_t *)(pptr + 8) + 1)) << 16) | ((uint32_t)(*((const uint8_t *)(pptr + 8) + 2)) << 8) | ((uint32_t)(*((const uint8_t *)(pptr + 8) + 3)) << 0))))pptr + BGP_VPN_RD_LENpptr + 8", RD: %s", bgp_vpn_rd_print(ndo, pptr)", Originator %s", bgp_vpn_ip_print(ndo, pptr, addr_length << 3)BGP_MULTICAST_VPN_ROUTE_TYPE_INTRA_AS_I_PMSI, RD: %s, Originator %sBGP_MULTICAST_VPN_ROUTE_TYPE_INTER_AS_I_PMSI, RD: %s, Source-AS %sBGP_MULTICAST_VPN_ROUTE_TYPE_S_PMSI, RD: %s, Originator %sBGP_MULTICAST_VPN_ROUTE_TYPE_SOURCE_ACTIVEBGP_MULTICAST_VPN_ROUTE_TYPE_SHARED_TREE_JOINBGP_MULTICAST_VPN_ROUTE_TYPE_SOURCE_TREE_JOINBGP_MULTICAST_VPN_ROUTE_TYPE_INTRA_AS_SEG_LEAFdecode_mdt_vpn_nlrirdvpn_ipMDT_VPN_NLRI_LEN"RD: %s, VPN IP Address: %s, MC Group Address: %s", bgp_vpn_rd_print(ndo, rd), ipaddr_string(ndo, vpn_ip), ipaddr_string(ndo, pptr)"RD: %s, VPN IP Address: %s, MC Group Address: %s", bgp_vpn_rd_print(ndo, rd), getname(ndo, (const u_char *)(vpn_ip)), getname(ndo, (const u_char *)(pptr))RD: %s, VPN IP Address: %s, MC Group Address: %sdecode_labeled_vpn_prefix4in_addr *"RD: %s, %s/%d, label:%u %s", bgp_vpn_rd_print(ndo, pptr+4), ipaddr_string(ndo, &addr), plen, EXTRACT_24BITS(pptr+1)>>4, ((pptr[3]&1)==0) ? "(BOGUS: Bottom of Stack NOT set!)" : "(bottom)""RD: %s, %s/%d, label:%u %s", bgp_vpn_rd_print(ndo, pptr+4), getname(ndo, (const u_char *)(&addr)), plen, ((uint32_t)(((uint32_t)(*((const uint8_t *)(pptr+1) + 0)) << 16) | ((uint32_t)(*((const uint8_t *)(pptr+1) + 1)) << 8) | ((uint32_t)(*((const uint8_t *)(pptr+1) + 2)) << 0)))>>4, ((pptr[3]&1)==0) ? "(BOGUS: Bottom of Stack NOT set!)" : "(bottom)"decode_rt_routing_inforoute_targetsizeof(astostr)asbuf"default route target"default route targetpptr + 1*(pptr + 1)sizeof(asbuf)&route_target0, sizeof(route_target)pptr[5]&pptr[5], (plen + 7) / 8"origin AS: %s, route target %s", asbuf, bgp_vpn_rd_print(ndo, (u_char *)&route_target)origin AS: %s, route target %sbgp_vpn_rd_printsizeof("xxxxxxxxxx:xxxxx (xxx.xxx.xxx.xxx:xxxxx)")possizeof(rd) - (pos - rd)"%u:%u (= %u.%u.%u.%u)", EXTRACT_16BITS(pptr+2), EXTRACT_32BITS(pptr+4), *(pptr+4), *(pptr+5), *(pptr+6), *(pptr+7)"%u:%u (= %u.%u.%u.%u)", ((uint16_t)(((uint16_t)(*((const uint8_t *)(pptr+2) + 0)) << 8) | ((uint16_t)(*((const uint8_t *)(pptr+2) + 1)) << 0))), ((uint32_t)(((uint32_t)(*((const uint8_t *)(pptr+4) + 0)) << 24) | ((uint32_t)(*((const uint8_t *)(pptr+4) + 1)) << 16) | ((uint32_t)(*((const uint8_t *)(pptr+4) + 2)) << 8) | ((uint32_t)(*((const uint8_t *)(pptr+4) + 3)) << 0))), *(pptr+4), *(pptr+5), *(pptr+6), *(pptr+7)pptr+2pptr+4"%u.%u.%u.%u:%u", *(pptr+2), *(pptr+3), *(pptr+4), *(pptr+5), EXTRACT_16BITS(pptr+6)"%u.%u.%u.%u:%u", *(pptr+2), *(pptr+3), *(pptr+4), *(pptr+5), ((uint16_t)(((uint16_t)(*((const uint8_t *)(pptr+6) + 0)) << 8) | ((uint16_t)(*((const uint8_t *)(pptr+6) + 1)) << 0)))pptr+6"%s:%u (%u.%u.%u.%u:%u)", as_printf(ndo, astostr, sizeof(astostr), EXTRACT_32BITS(pptr+2)), EXTRACT_16BITS(pptr+6), *(pptr+2), *(pptr+3), *(pptr+4), *(pptr+5), EXTRACT_16BITS(pptr+6)"%s:%u (%u.%u.%u.%u:%u)", as_printf(ndo, astostr, sizeof(astostr), ((uint32_t)(((uint32_t)(*((const uint8_t *)(pptr+2) + 0)) << 24) | ((uint32_t)(*((const uint8_t *)(pptr+2) + 1)) << 16) | ((uint32_t)(*((const uint8_t *)(pptr+2) + 2)) << 8) | ((uint32_t)(*((const uint8_t *)(pptr+2) + 3)) << 0)))), ((uint16_t)(((uint16_t)(*((const uint8_t *)(pptr+6) + 0)) << 8) | ((uint16_t)(*((const uint8_t *)(pptr+6) + 1)) << 0))), *(pptr+2), *(pptr+3), *(pptr+4), *(pptr+5), ((uint16_t)(((uint16_t)(*((const uint8_t *)(pptr+6) + 0)) << 8) | ((uint16_t)(*((const uint8_t *)(pptr+6) + 1)) << 0)))"unknown RD format"%u:%u (= %u.%u.%u.%u)%u.%u.%u.%u:%u%s:%u (%u.%u.%u.%u:%u)unknown RD formatbgp_vpn_sg_printtotal_length(addr_length >> 3)", Source %s", bgp_vpn_ip_print(ndo, pptr, addr_length), Source %s", Group %s", bgp_vpn_ip_print(ndo, pptr, addr_length), Group %sbgp_vpn_ip_printsizeof("1234:5678:89ab:cdef:1234:5678:89ab:cdef")"%s", ipaddr_string(ndo, pptr)"%s", getname(ndo, (const u_char *)(pptr))"%s", ip6addr_string(ndo, pptr)"%s", getname6(ndo, (const u_char *)(pptr))"bogus address length %u", addr_lengthsizeof(struct in_addr) << 3(sizeof(struct in_addr) << 3)sizeof(struct in6_addr) << 3(sizeof(struct in6_addr) << 3)bogus address length %udecode_labeled_prefix4"%s/%d, label:%u %s", ipaddr_string(ndo, &addr), plen, EXTRACT_24BITS(pptr+1)>>4, ((pptr[3]&1)==0) ? "(BOGUS: Bottom of Stack NOT set!)" : "(bottom)""%s/%d, label:%u %s", getname(ndo, (const u_char *)(&addr)), plen, ((uint32_t)(((uint32_t)(*((const uint8_t *)(pptr+1) + 0)) << 16) | ((uint32_t)(*((const uint8_t *)(pptr+1) + 1)) << 8) | ((uint32_t)(*((const uint8_t *)(pptr+1) + 2)) << 0)))>>4, ((pptr[3]&1)==0) ? "(BOGUS: Bottom of Stack NOT set!)" : "(bottom)"decode_prefix4pptr[1]&pptr[1], plenbytes"%s/%d", ipaddr_string(ndo, &addr), plen"%s/%d", getname(ndo, (const u_char *)(&addr)), plenas_printfstr"%u", asnum"%u.%u", asnum >> 16, asnum & 0xFFFF%u.%ubgp_route_refreshbgp_notificationbgp_optbgp_openfresafibgp_markerbgpn_minorbgpn_majorbgpn_typebgpn_lenbgpn_markerbgpopt_lenbgpopt_typebgpo_optlenbgpo_idbgpo_holdtimebgpo_myasbgpo_versionbgpo_typebgpo_lenbgpo_markerbgp_typebgp_lenIntra-AS I-PMSI"Intra-AS I-PMSI"Inter-AS I-PMSI"Inter-AS I-PMSI"S-PMSI"S-PMSI"Intra-AS Segment-Leaf"Intra-AS Segment-Leaf"Source-Active"Source-Active"Shared Tree Join"Shared Tree Join"Source Tree Join"Source Tree Join"bgp_multicast_vpn_route_type_valuesastostrReceive"Receive"Send"Send"Both"Both"bgp_add_path_recvsendBGP_OSPF_RTYPE_RTRRouter"Router"BGP_OSPF_RTYPE_NETNetwork"Network"BGP_OSPF_RTYPE_SUMSummary"Summary"BGP_OSPF_RTYPE_EXTExternal"External"BGP_OSPF_RTYPE_NSSANSSA External"NSSA External"BGP_OSPF_RTYPE_SHAMMPLS-VPN Sham"MPLS-VPN Sham"bgp_extd_comm_ospf_rtype_valuestarget"target"origin"origin"link-BW"link-BW"ospf-domain"ospf-domain"ospf-route-type"ospf-route-type"ospf-router-id"ospf-router-id"layer2-info"layer2-info"34816BGP_EXT_COM_EIGRP_GENeigrp-general-route (flag, tag)"eigrp-general-route (flag, tag)"34817BGP_EXT_COM_EIGRP_METRIC_AS_DELAYeigrp-route-metric (AS, delay)"eigrp-route-metric (AS, delay)"34818BGP_EXT_COM_EIGRP_METRIC_REL_NH_BWeigrp-route-metric (reliability, nexthop, bandwidth)"eigrp-route-metric (reliability, nexthop, bandwidth)"34819BGP_EXT_COM_EIGRP_METRIC_LOAD_MTUeigrp-route-metric (load, MTU)"eigrp-route-metric (load, MTU)"34820BGP_EXT_COM_EIGRP_EXT_REMAS_REMIDeigrp-external-route (remote-AS, remote-ID)"eigrp-external-route (remote-AS, remote-ID)"34821BGP_EXT_COM_EIGRP_EXT_REMPROTO_REMMETRICeigrp-external-route (remote-proto, remote-metric)"eigrp-external-route (remote-proto, remote-metric)"source-AS"source-AS"vrf-route-import"vrf-route-import"l2vpn-id"l2vpn-id"bgp_extd_comm_subtype_values0x8000vendor-specific"vendor-specific"0x4000non-transitive"non-transitive"bgp_extd_comm_flag_valuesSAFNUM_RESUnicast"Unicast"Multicast"Multicast"Unicast+Multicast"Unicast+Multicast"labeled Unicast"labeled Unicast"SAFNUM_TUNNELTunnel"Tunnel"MDT"MDT"labeled VPN Unicast"labeled VPN Unicast"labeled VPN Multicast"labeled VPN Multicast"labeled VPN Unicast+Multicast"labeled VPN Unicast+Multicast"Route Target Routing Information"Route Target Routing Information"Multicast VPN"Multicast VPN"bgp_safi_valuesAIGP"AIGP"bgp_aigp_valuesLeaf Information required"Leaf Information required"bgp_pmsi_flag_valuesRSVP-TE P2MP LSP"RSVP-TE P2MP LSP"LDP P2MP LSP"LDP P2MP LSP"PIM-SSM Tree"PIM-SSM Tree"PIM-SM Tree"PIM-SM Tree"PIM-Bidir Tree"PIM-Bidir Tree"Ingress Replication"Ingress Replication"LDP MP2MP LSP"LDP MP2MP LSP"bgp_pmsi_tunnel_valuesIGP"IGP"Incomplete"Incomplete"bgp_origin_valuesInvalid Action Value"Invalid Action Value"Invalid Capability Length"Invalid Capability Length"Malformed Capability Value"Malformed Capability Value"Unsupported Capability Code"Unsupported Capability Code"bgp_notify_minor_cap_valuesIn OpenSent State"In OpenSent State"In OpenConfirm State"In OpenConfirm State"In Established State"In Established State"bgp_notify_minor_fsm_valuesMalformed Attribute List"Malformed Attribute List"Unrecognized Well-known Attribute"Unrecognized Well-known Attribute"Missing Well-known Attribute"Missing Well-known Attribute"Attribute Flags Error"Attribute Flags Error"asnumAttribute Length Error"Attribute Length Error"Invalid ORIGIN Attribute"Invalid ORIGIN Attribute"AS Routing Loop"AS Routing Loop"Invalid NEXT_HOP Attribute"Invalid NEXT_HOP Attribute"Optional Attribute Error"Optional Attribute Error"Invalid Network Field"Invalid Network Field"Malformed AS_PATH"Malformed AS_PATH"bgp_notify_minor_update_valuesUnsupported Version Number"Unsupported Version Number"Bad Peer AS"Bad Peer AS"Bad BGP Identifier"Bad BGP Identifier"Unsupported Optional Parameter"Unsupported Optional Parameter"Authentication Failure"Authentication Failure"Unacceptable Hold Time"Unacceptable Hold Time"Capability Message Error"Capability Message Error"bgp_notify_minor_open_valuesConnection Not Synchronized"Connection Not Synchronized"Bad Message Length"Bad Message Length"Bad Message Type"Bad Message Type"bgp_notify_minor_msg_valuesMaximum Number of Prefixes Reached"Maximum Number of Prefixes Reached"Administratively Shutdown"Administratively Shutdown"Peer Unconfigured"Peer Unconfigured"Administratively Reset"Administratively Reset"Connection Rejected"Connection Rejected"Other Configuration Change"Other Configuration Change"Connection Collision Resolution"Connection Collision Resolution"bgp_notify_minor_cease_valuesMessage Header Error"Message Header Error"OPEN Message Error"OPEN Message Error"UPDATE Message Error"UPDATE Message Error"BGP_NOTIFY_MAJOR_HOLDTIMEHold Timer Expired"Hold Timer Expired"Finite State Machine Error"Finite State Machine Error"Cease"Cease"bgp_notify_major_valuesMultiprotocol Extensions"Multiprotocol Extensions"Route Refresh"Route Refresh"BGP_CAPCODE_ORFCooperative Route Filtering"Cooperative Route Filtering"BGP_CAPCODE_MRMultiple Routes to a Destination"Multiple Routes to a Destination"BGP_CAPCODE_EXT_NHExtended Next Hop Encoding"Extended Next Hop Encoding"Graceful Restart"Graceful Restart"32-Bit AS Number"32-Bit AS Number"BGP_CAPCODE_DYN_CAPDynamic Capability"Dynamic Capability"BGP_CAPCODE_MULTISESSMultisession BGP"Multisession BGP"Multiple Paths"Multiple Paths"BGP_CAPCODE_ENH_RREnhanced Route Refresh"Enhanced Route Refresh"Route Refresh (Cisco)"Route Refresh (Cisco)"bgp_capcode_valuesAuthentication Information"Authentication Information"Capabilities Advertisement"Capabilities Advertisement"bgp_opt_valuesBGP_AS_SEQUENCE""BGP_AS_SET}"}"BGP_CONFED_AS_SEQUENCE")"BGP_CONFED_AS_SET})"})"bgp_as_path_segment_close_values{ "{ "( "( "({ "({ "bgp_as_path_segment_open_valuesOrigin"Origin"AS Path"AS Path"AS4 Path"AS4 Path"Next Hop"Next Hop"Multi Exit Discriminator"Multi Exit Discriminator"Local Preference"Local Preference"Atomic Aggregate"Atomic Aggregate"Aggregator"Aggregator"Aggregator4"Aggregator4"Community"Community"Originator ID"Originator ID"Cluster List"Cluster List"BGPTYPE_DPADPA"DPA"BGPTYPE_ADVERTISERSAdvertisers"Advertisers"BGPTYPE_RCID_PATHRCID Path / Cluster ID"RCID Path / Cluster ID"Multi-Protocol Reach NLRI"Multi-Protocol Reach NLRI"Multi-Protocol Unreach NLRI"Multi-Protocol Unreach NLRI"Extended Community"Extended Community"PMSI Tunnel"PMSI Tunnel"BGPTYPE_TUNNEL_ENCAPTunnel Encapsulation"Tunnel Encapsulation"BGPTYPE_TRAFFIC_ENGTraffic Engineering"Traffic Engineering"BGPTYPE_IPV6_EXTD_COMMUNITIESIPv6 Extended Community"IPv6 Extended Community"Accumulated IGP Metric"Accumulated IGP Metric"BGPTYPE_PE_DISTINGUISHER_LABELPE Distinguisher Label"PE Distinguisher Label"BGPTYPE_ENTROPY_LABELEntropy Label"Entropy Label"Large Community"Large Community"Attribute Set"Attribute Set"Reserved for development"Reserved for development"bgp_attr_valuesOpen"Open"Update"Update"Notification"Notification"Keepalive"Keepalive"bgp_msg_values[|BGP]"[|BGP]"UPDATE_BUF_BUFLEN(buf,buflen,stringlen)if (stringlen<0) buflen=0; else if ((u_int)stringlen>buflen) buflen=0; else { buflen-=stringlen; buf+=stringlen; }ITEMCHECK(minlen)if (itemlen < minlen) goto badtlv;BGP_OSPF_RTYPE_METRIC_TYPE0x88050x88040x88030x88020x88010x88000xF10a0x800a0x80010x03060x80050x02050x01050x40040x02030x02020xffffff030xffffff020xffffff01BGP_AS_SEG_TYPE_MAXBGP_AS_SEG_TYPE_MINbgp_attr_len(flags,p)(((flags) & 0x10) ? EXTRACT_16BITS(p) : *(p))bgp_attr_lenlen(flags,p)(((flags) & 0x10) ? 2 : 1)/*
 * Local Variables:
 * c-style: whitesmith
 * c-basic-offset: 4
 * End:
 *//* found BGP header *//* lets be less chatty *//* we have no decoder for the BGP message *//* this stinks but the compiler pads the structure
			   * weird *//* some little sanity checking *//* draft-ietf-idr-cease-subcode-02 mentions optionally 7 bytes
             * for the maxprefix subtype, which may contain AFI, SAFI and MAXPREFIXES
             *//* bytes left, but not enough *//*
		 * XXX - what if they're using the "Advertisement of
		 * Multiple Paths in BGP" feature:
		 *
		 * https://datatracker.ietf.org/doc/draft-ietf-idr-add-paths/
		 *
		 * http://tools.ietf.org/html/draft-ietf-idr-add-paths-06
		 *//* do something more useful!*//* No withdrawn routes, no path attributes, no NLRI *//*
		 * Without keeping state from the original NLRI message,
		 * it's not possible to tell if this a v4 or v6 route,
		 * so only try to decode it if we're not v6 enabled.
	         *//* Unfeasible routes *//* now let's decode the options we know*//* ugly! *//* length *//*
                     * Extract the 4 byte AS number encoded.
                     *//* Restart Flags (4 bits), Restart Time in seconds (12 bits) *//* AFI (16 bits), Reserved (8 bits), SAFI (8 bits) *//* omit zero length attributes*//* we have no decoder for the attribute *//* FIXME check for recursion *//*
		     * Check if we can read the TLV data.
		     *//* 128 is meanwhile wellknown *//*nothing*//* rfc1888 mapped IPv6 address ? *//* rfc986 mapped IPv4 address ? *//*
                 * Depending on the AS encoded is of 2 bytes or of 4 bytes,
                 * the length of this PA can be either 6 bytes or 8 bytes.
                 *//*
                 * BGP updates exchanged between New speakers that support 4
                 * byte AS, ASs are always encoded in 4 bytes. There is no
                 * definitive way to find this, just by the packet's
                 * contents. So, check for packet's TLV's sanity assuming
                 * 2 bytes first, and it does not pass, assume that ASs are
                 * encoded in 4 bytes format and move on.
                 *//*
         * Process AS4 byte path and AS2 byte path attributes here.
         *//* copy buffer for bandwidth values *//*
     * We can come here, either we did not have enough data, or if we
     * try to decode 4 byte ASs in 2 byte format. Either way, return 4,
     * so that calller can try to decode each AS as of 4 bytes. If indeed
     * there was not enough data, it will crib and end the parse anyways.
     *//*
     * If we correctly reached end of the AS path attribute data content,
     * then most likely ASs were indeed encoded as 2 bytes.
     *//*
         * If we do not find a valid segment type, our guess might be wrong.
         *//*
     * Let us assume that ASs are of 2 bytes in size, and check if the AS-Path
     * TLV is good. If not, ask the caller to try with AS encoded as 4 bytes
     * each.
     *//*
     * If the path attribute is the optional AS4 path type, then we already
     * know, that ASs must be encoded in 4 byte format.
     *//*
 * bgp_attr_get_as_size
 *
 * Try to find the size of the ASs encoded in an as-path. It is not obvious, as
 * both Old speakers that do not support 4 byte AS, and the new speakers that do
 * support, exchange AS-Path with the same path-attribute type value 0x02.
 *//* the label may get offsetted by 4 bits so lets shift it right *//* adjust prefixlen - labellength - RD len*//* get prefix length *//* adjust prefixlen - labellength *//* prefix length and label = 4 bytes *//* complain bitterly ? *//* the tlv-length is expressed in bits so lets shift it right *//* how many bytes do we need to read ? *//* ok now the variable part - lets read out TLVs*//* the label is offsetted by 4 bits so lets shift it right *//* RD, ID, LBLKOFF, LBLBASE *//* assume old format *//* assume AD-only with RD, BGPNH *//* Old and new L2VPN NLRI share AFI/SAFI
         *   -> Assume a 12 Byte-length NLRI is auto-discovery-only
         *      and > 17 as old format. Complain for the middle case
         *//*
 * As I remember, some versions of systems have an snprintf() that
 * returns -1 if the buffer would have overflowed.  If the return
 * value is negative, set buflen to 0, to indicate that we've filled
 * the buffer up.
 *
 * If the return value is greater than buflen, that means that
 * the buffer would have overflowed; again, set buflen to 0 in
 * that case.
 *//*
             * no per route-type printing yet.
             *//* MDT Group Address *//* RD *//* if the NLRI is not predefined length, quit.*//*
 * +-------------------------------+
 * |                               |
 * |  RD:IPv4-address (12 octets)  |
 * |                               |
 * +-------------------------------+
 * |  MDT Group-address (4 octets) |
 * +-------------------------------+
 *//* Which specification says to do this? *//* From now on (plen + 7) / 8 evaluates to { 0, 1, 2, ..., 8 }
	 * and gives the number of octets in the variable-length "route
	 * target" field inside this NLRI "prefix". Look for it.
	 *//* adjust prefix length *//* With at least "origin AS", possibly with "route target". *//* Without "origin AS", without "route target". *//* NLRI "prefix" (ibid), valid lengths are { 0, 32, 33, ..., 96 } bits.
	 * RFC 4684 Section 4 defines the layout of "origin AS" and "route
	 * target" fields inside the "prefix" depending on its length.
	 *//* NLRI "prefix length" from RFC 2858 Section 4. *//* bgp_vpn_rd_print() overwrites astostr *//* 4-byte-AS:number fmt*//* IP-address:AS fmt*//* 2-byte-AS:number fmt*//* ok lets load the RD format *//* allocate space for the largest possible string *//* RDs and RTs share the same semantics
 * we use bgp_vpn_rd_print for
 * printing route targets inside a NLRI *//* Group address *//* Group address length, encoded in bits *//* Source address *//* Source address length, encoded in bits *//*
 * bgp_vpn_sg_print
 *
 * print an multicast s,g entry into a buffer.
 * the s,g entry is encoded like this.
 *
 * +-----------------------------------+
 * | Multicast Source Length (1 octet) |
 * +-----------------------------------+
 * |   Multicast Source (Variable)     |
 * +-----------------------------------+
 * |  Multicast Group Length (1 octet) |
 * +-----------------------------------+
 * |  Multicast Group   (Variable)     |
 * +-----------------------------------+
 *
 * return the number of bytes read from the wire.
 *//* 128 *//* worst case string is s fully formatted v6 address *//*
 * bgp_vpn_ip_print
 *
 * print an ipv4 or ipv6 address into a buffer dependend on address length.
 *//* this is one of the weirdnesses of rfc3107
           the label length (actually the label + COS bits)
           is added to the prefix length;
           we also do only read out just one label -
           there is no real application for advertisement of
           stacked labels in a single BGP message
        *//*
 * as_printf
 *
 * Convert an AS number into a string and return string pointer.
 *
 * Depending on bflag is set or not, AS number is converted into ASDOT notation
 * or plain number notation.
 *
 *//* ADD-PATH Send/Receive field values *//* LSB of RTYPE Options Field *//* OSPF-MPLS-VPN Sham link *//* OSPF NSSA External*//* OSPF External LSA, note that ASBR doesn't apply to MPLS-VPN *//* OSPF Summary LSA *//* OSPF Network LSA *//* OSPF Router LSA *//* OSPF codes for  BGP_EXT_COM_OSPF_RTYPE draft-rosen-vpns-ospf-bgp-mpls  *//* http://www.cisco.com/en/US/tech/tk436/tk428/technologies_tech_note09186a00801eb09a.shtml  *//* L2VPN Identifier,Format IP address:AN(2bytes) *//* L2VPN Identifier,Format AS(2bytes):AN(4bytes) *//* RFC-ietf-l3vpn-2547bis-mcast-bgp-08.txt *//* duplicate - keep for backwards compatability *//* OSPF Router ID,Format RouterID(4B):Unused(2B) *//* OSPF Route Type,Format Area(4B):RouteType(1B):Options(1B) *//* OSPF Domain ID / VPN of Origin  - draft-rosen-vpns-ospf-bgp-mpls *//* rfc2547 bgp-mpls-vpns *//* Link Bandwidth,Format AS(2B):Bandwidth(4B) *//* Route Origin,Format AN(4bytes):local(2bytes) *//* Route Origin,Format IP address:AN(2bytes) *//* Route Origin,Format AS(2bytes):AN(4bytes) *//* Route Target,Format AN(4bytes):local(2bytes) *//* Route Target,Format IP address:AN(2bytes) *//* Route Target,Format AS(2bytes):AN(4bytes) *//* Extended community type - draft-ietf-idr-bgp-ext-communities-05 *//* well-known community *//* RFC4684 *//* deprecated now *//* RFC6513 *//* RFC4364 *//* RFC6037 *//* RFC4761 *//* draft-nalawade-kapoor-tunnel-safi *//* RFC6514 *//* labeled BGP RFC3107 *//* Subsequent address family identifier, RFC2283 section 7 *//* draft-ietf-idr-cease-subcode-02 *//* draft-keyur-bgp-enhanced-route-refresh *//* RFC7911 *//* draft-ietf-idr-bgp-multisession *//* draft-ietf-idr-dynamic-cap *//* RFC6793 *//* RFC4724  *//* RFC5549 *//* RFC3107 *//* RFC5291 *//* RFC2918 *//* RFC2858 *//* draft-ietf-idr-rfc3065bis-01  *//* draft-ietf-idr-rfc3065bis-01 *//* End of RIB Marker detection *//* RFC6368 *//* draft-ietf-idr-large-community-05 *//* RFC6790 *//* RFC7311 *//* RFC5701 *//* RFC5543 *//* RFC5512 *//* RFC4360 *//* RFC4760 *//* deprecated RFC1863 *//* deprecated, draft-ietf-idr-bgp-dpa *//* RFC4456 *//* RFC1997 *//* EXTRACT_16BITS(&bgp_route_refresh->afi) (sigh)      *//* afi should be int16 - so we have to access it using *//* when doing misaligned sequences of int8 and int16   *//* the compiler messes this structure up               *//* unaligned *//* some compilers may pad to 4 bytes *//* variable length *//* options should follow *//* \summary: Border Gateway Protocol (BGP) printer *//*
 * Copyright (C) 1999 WIDE Project.
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. Neither the name of the project nor the names of its contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE PROJECT AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE PROJECT OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 *
 * Extensively modified by Hannes Gredler (hannes@gredler.at) for more
 * complete BGP support.
 *//Users/owura/Repos/codeql_eval/proj_repos/the-tcpdump-group-tcpdump-commit-9ba91381954ad325ea4fd26b9c65a8bd9a2a85b6/tcpdump/print-bootp.cclient_fqdn_flags8+1CLIENT_FQDN_FLAGS_S'S'CLIENT_FQDN_FLAGS_O'O'CLIENT_FQDN_FLAGS_E'E'CLIENT_FQDN_FLAGS_N'N'cmu_printconst cmu_vendconst cmu_vend *cmu_vend *cmu(ndo, " vend-cmu") vend-cmucmu->v_flagssizeof(cmu->v_flags)(ndo, " F:0x%x", cmu->v_flags)VF_SMASK(VF_SMASK)4294967294~(VF_SMASK) F:0x%xv_dgate"DG"cmu->v_dgatesizeof(cmu->v_dgate)const in_addrconst in_addr *(ndo, " %s:%s", "DG", ipaddr_string(ndo, &cmu->v_dgate.s_addr))(ndo, " %s:%s", "DG", getname(ndo, (const u_char *)(&cmu->v_dgate.s_addr)))&cmu->v_dgate.s_addr %s:%sDGconst in_addr_tconst in_addr_t *v_smaskcmu->v_flags & VF_SMASK ? "SM" : "SM*"cmu->v_flags & 1 ? "SM" : "SM*"cmu->v_smasksizeof(cmu->v_smask)(ndo, " %s:%s", cmu->v_flags & 1 ? "SM" : "SM*", ipaddr_string(ndo, &cmu->v_smask.s_addr))(ndo, " %s:%s", cmu->v_flags & 1 ? "SM" : "SM*", getname(ndo, (const u_char *)(&cmu->v_smask.s_addr)))&cmu->v_smask.s_addrSMSM*v_dns1"NS1"cmu->v_dns1sizeof(cmu->v_dns1)(ndo, " %s:%s", "NS1", ipaddr_string(ndo, &cmu->v_dns1.s_addr))(ndo, " %s:%s", "NS1", getname(ndo, (const u_char *)(&cmu->v_dns1.s_addr)))&cmu->v_dns1.s_addrNS1v_dns2"NS2"cmu->v_dns2sizeof(cmu->v_dns2)(ndo, " %s:%s", "NS2", ipaddr_string(ndo, &cmu->v_dns2.s_addr))(ndo, " %s:%s", "NS2", getname(ndo, (const u_char *)(&cmu->v_dns2.s_addr)))&cmu->v_dns2.s_addrNS2v_ins1"IEN1"cmu->v_ins1sizeof(cmu->v_ins1)(ndo, " %s:%s", "IEN1", ipaddr_string(ndo, &cmu->v_ins1.s_addr))(ndo, " %s:%s", "IEN1", getname(ndo, (const u_char *)(&cmu->v_ins1.s_addr)))&cmu->v_ins1.s_addrIEN1v_ins2"IEN2"cmu->v_ins2sizeof(cmu->v_ins2)(ndo, " %s:%s", "IEN2", ipaddr_string(ndo, &cmu->v_ins2.s_addr))(ndo, " %s:%s", "IEN2", getname(ndo, (const u_char *)(&cmu->v_ins2.s_addr)))&cmu->v_ins2.s_addrIEN2v_ts1"TS1"cmu->v_ts1sizeof(cmu->v_ts1)(ndo, " %s:%s", "TS1", ipaddr_string(ndo, &cmu->v_ts1.s_addr))(ndo, " %s:%s", "TS1", getname(ndo, (const u_char *)(&cmu->v_ts1.s_addr)))&cmu->v_ts1.s_addrTS1v_ts2"TS2"cmu->v_ts2sizeof(cmu->v_ts2)(ndo, " %s:%s", "TS2", ipaddr_string(ndo, &cmu->v_ts2.s_addr))(ndo, " %s:%s", "TS2", getname(ndo, (const u_char *)(&cmu->v_ts2.s_addr)))&cmu->v_ts2.s_addrTS2rfc1048_printtagulusucsuboptsuboptlen(ndo, "\n\t  Vendor-rfc1048 Extensions")
	  Vendor-rfc1048 Extensions(ndo, "\n\t    Magic Cookie 0x%08x", EXTRACT_32BITS(bp))(ndo, "\n\t    Magic Cookie 0x%08x", ((uint32_t)(((uint32_t)(*((const uint8_t *)(bp) + 0)) << 24) | ((uint32_t)(*((const uint8_t *)(bp) + 1)) << 16) | ((uint32_t)(*((const uint8_t *)(bp) + 2)) << 8) | ((uint32_t)(*((const uint8_t *)(bp) + 3)) << 0))))
	    Magic Cookie 0x%08xsizeof(int32_t)*(bp + 1)bp + 1(ndo, "\n\t    %s Option %u, length %u%s", cp, tag, len, len > 0 ? ": " : "")(ndo, ", occurs %u", ntag)(ndo, "[|rfc1048 %u]", len)(ndo, "%s", tok2str(dhcp_msg_values, "Unknown (%u)", uc))(ndo, "\n\t      ")(ndo, ", ")(ndo, "%s", cp + 1)(ndo, "+")(ndo, ",")(ndo, "%s", ipaddr_string(ndo, &ul))(ndo, "%s", getname(ndo, (const u_char *)(&ul)))&ul(ndo, "%d", ul)(ndo, "%u", ul)(char *)&ul(const char *)bp, sizeof(ul)(ndo, "(%s:", ipaddr_string(ndo, &ul))(ndo, "(%s:", getname(ndo, (const u_char *)(&ul)))(ndo, "%s)", ipaddr_string(ndo, &ul))(ndo, "%s)", getname(ndo, (const u_char *)(&ul)))(ndo, "%u", us)(ndo, "N")(ndo, "Y")(ndo, "%u?", *bp)(ndo, c == 'x' ? ":" : ".")(ndo, "%02x", *bp)(ndo, "%u", *bp)(ndo, "ERROR: length < 1 bytes")(ndo, "%s", tok2str(nbo2str, NULL, tag))(ndo, "%s", tok2str(nbo2str, ((void *)0), tag))(ndo, "%s", tok2str(oo2str, NULL, tag))(ndo, "%s", tok2str(oo2str, ((void *)0), tag))(ndo, "ERROR: length < 3 bytes")(ndo, "[%s] ", client_fqdn_flags(*bp))(ndo, "%u/%u ", *bp, *(bp+1))(ndo, "%s ", tok2str(arp2str, "hardware-type %u,", type))(ndo, "\n\t      %s SubOption %u, length %u: length goes past end of option", tok2str(agent_suboption_values, "Unknown", subopt), subopt, suboptlen)(ndo, "\n\t      %s SubOption %u, length %u: ", tok2str(agent_suboption_values, "Unknown", subopt), subopt, suboptlen)(ndo, "ERROR: length < 5 bytes")(ndo, "[ERROR: Mask width (%d) > 32]", mask_width)(ndo, "[ERROR: Remaining length (%u) < %u bytes]", len, significant_octets + 4)(ndo, "(")(ndo, "default")(ndo, "%d", *bp++)(ndo, ".0")(ndo, "/%d", mask_width)(ndo, ":%s)", ipaddr_string(ndo, &ul))(ndo, ":%s)", getname(ndo, (const u_char *)(&ul)))(ndo, "ERROR: length < 2 bytes")(ndo, "instance#%u: ", suboptnumber)(ndo, "ERROR: suboption length must be non-zero")(ndo, "ERROR: invalid option")(ndo, ", length %d", suboptlen)(ndo, "[unknown special tag %u, size %u]", tag, len)(ndo, "\n\t  trailing data length %u", len)TAG_PADTAG_ENDTAG_EXTENDED_OPTIONconst tok[1]tok[1]?xT%u"?xT%u"const tok[110]tok[110]?T%u"?T%u"
	    %s Option %u, length %u%sntag, occurs %u[|rfc1048 %u]TAG_DHCP_MESSAGETAG_PARM_REQUEST?Option %u"?Option %u"TAG_EXTENDED_REQUEST+'?''b''s''l''a''i''L'sizeof(ul),'p'2*sizeof(ul)(%s:sizeof(us)'B'NY%u?'x''$'TAG_NETBIOS_NODEERROR: length < 1 bytesTAG_OPT_OVERLOADTAG_CLIENT_FQDNERROR: length < 3 bytes[%s] %u/%u TAG_CLIENT_IDhardware-type %u,TAG_AGENT_CIRCUIT
	      %s SubOption %u, length %u: length goes past end of option
	      %s SubOption %u, length %u: AGENT_SUBOPTION_CIRCUIT_IDAGENT_SUBOPTION_REMOTE_IDAGENT_SUBOPTION_SUBSCRIBER_IDTAG_CLASSLESS_STATIC_RT249TAG_CLASSLESS_STA_RT_MSmask_widthsignificant_octetsERROR: length < 5 bytes[ERROR: Mask width (%d) > 32][ERROR: Remaining length (%u) < %u bytes](default.0/%d:%s)TAG_USER_CLASSsuboptnumberERROR: length < 2 bytesinstance#%u: ERROR: suboption length must be non-zeroERROR: invalid option, length %d[unknown special tag %u, size %u]
	  trailing data length %u(ndo, "|[rfc1048]")|[rfc1048]bootp_printconst bootpconst bootp *bootp *const u_char[4]vm_cmuCMUVM_CMUvm_rfc1048bp->bp_opsizeof(bp->bp_op)(ndo, "BOOTP/DHCP, %s", tok2str(bootp_op_values, "unknown (0x%02x)", bp->bp_op))BOOTP/DHCP, %sbp->bp_hlensizeof(bp->bp_hlen)bp->bp_chaddr[0](ndo, " from %s", etheraddr_string(ndo, bp->bp_chaddr))BOOTPREQUEST from %sbp->bp_secssizeof(bp->bp_secs)(ndo, ", htype %d", bp->bp_htype), htype %d(ndo, ", hlen %d", bp->bp_hlen), hlen %d(ndo, ", hops %d", bp->bp_hops), hops %d&bp->bp_xid(ndo, ", xid 0x%x", EXTRACT_32BITS(&bp->bp_xid))(ndo, ", xid 0x%x", ((uint32_t)(((uint32_t)(*((const uint8_t *)(&bp->bp_xid) + 0)) << 24) | ((uint32_t)(*((const uint8_t *)(&bp->bp_xid) + 1)) << 16) | ((uint32_t)(*((const uint8_t *)(&bp->bp_xid) + 2)) << 8) | ((uint32_t)(*((const uint8_t *)(&bp->bp_xid) + 3)) << 0)))), xid 0x%x&bp->bp_secs(ndo, ", secs %d", EXTRACT_16BITS(&bp->bp_secs))(ndo, ", secs %d", ((uint16_t)(((uint16_t)(*((const uint8_t *)(&bp->bp_secs) + 0)) << 8) | ((uint16_t)(*((const uint8_t *)(&bp->bp_secs) + 1)) << 0)))), secs %dbp->bp_flagssizeof(bp->bp_flags)(ndo, ", Flags [%s]", bittok2str(bootp_flag_values, "none", EXTRACT_16BITS(&bp->bp_flags)))(ndo, ", Flags [%s]", bittok2str(bootp_flag_values, "none", ((uint16_t)(((uint16_t)(*((const uint8_t *)(&bp->bp_flags) + 0)) << 8) | ((uint16_t)(*((const uint8_t *)(&bp->bp_flags) + 1)) << 0))))), Flags [%s]&bp->bp_flags(ndo, " (0x%04x)", EXTRACT_16BITS(&bp->bp_flags))(ndo, " (0x%04x)", ((uint16_t)(((uint16_t)(*((const uint8_t *)(&bp->bp_flags) + 0)) << 8) | ((uint16_t)(*((const uint8_t *)(&bp->bp_flags) + 1)) << 0)))) (0x%04x)bp->bp_ciaddrsizeof(bp->bp_ciaddr)&bp->bp_ciaddr.s_addr(ndo, "\n\t  Client-IP %s", ipaddr_string(ndo, &bp->bp_ciaddr))(ndo, "\n\t  Client-IP %s", getname(ndo, (const u_char *)(&bp->bp_ciaddr)))&bp->bp_ciaddr
	  Client-IP %sbp->bp_yiaddrsizeof(bp->bp_yiaddr)&bp->bp_yiaddr.s_addr(ndo, "\n\t  Your-IP %s", ipaddr_string(ndo, &bp->bp_yiaddr))(ndo, "\n\t  Your-IP %s", getname(ndo, (const u_char *)(&bp->bp_yiaddr)))&bp->bp_yiaddr
	  Your-IP %sbp->bp_siaddrsizeof(bp->bp_siaddr)&bp->bp_siaddr.s_addr(ndo, "\n\t  Server-IP %s", ipaddr_string(ndo, &bp->bp_siaddr))(ndo, "\n\t  Server-IP %s", getname(ndo, (const u_char *)(&bp->bp_siaddr)))&bp->bp_siaddr
	  Server-IP %sbp->bp_giaddrsizeof(bp->bp_giaddr)&bp->bp_giaddr.s_addr(ndo, "\n\t  Gateway-IP %s", ipaddr_string(ndo, &bp->bp_giaddr))(ndo, "\n\t  Gateway-IP %s", getname(ndo, (const u_char *)(&bp->bp_giaddr)))&bp->bp_giaddr
	  Gateway-IP %s(ndo, "\n\t  Client-Ethernet-Address %s", etheraddr_string(ndo, bp->bp_chaddr))
	  Client-Ethernet-Address %sbp->bp_sname[0]uint8_t[64]unsigned char[64](ndo, "\n\t  sname \"")(ndo, "%s", tstr + 1)
	  sname "(u_int)sizeof bp->bp_snamebp->bp_file[0]uint8_t[128]unsigned char[128](ndo, "\n\t  file \"")
	  file "(u_int)sizeof bp->bp_filebp->bp_vend[0]&bp->bp_vend*(&bp->bp_vend)(ndo, "\n\t  Vendor-#0x%x", ul)sizeof(uint32_t)const uint8_t[64]const uint8_t(*)[64]unsigned char(*)[64]
	  Vendor-#0x%xcmu_vendpackedbootpuint8_t[24]unsigned char[24]v_unusedv_flagsv_magicbp_vendbp_filebp_snamebp_chaddrbp_giaddrbp_siaddrbp_yiaddrbp_ciaddrbp_flagsbp_secsbp_xidbp_hopsbp_hlenbp_htypebp_opCircuit-ID"Circuit-ID"Remote-ID"Remote-ID"Subscriber-ID"Subscriber-ID"agent_suboption_valuesDHCPDISCOVERDHCPOFFERDHCPREQUESTDHCPDECLINEDecline"Decline"DHCPACKDHCPNAKNACK"NACK"DHCPRELEASEDHCPINFORMInform"Inform"dhcp_msg_valuesether"ether"ieee802"ieee802"arcnet"arcnet"frelay"frelay"0x17strip"strip"0x18ieee1394"ieee1394"arp2strb-node"b-node"p-node"p-node"m-node"m-node"h-node"h-node"nbo2strfile"file"sname"sname"file+sname"file+sname"oo2strxtag2str PAD" PAD"TAG_SUBNET_MASKiSubnet-Mask"iSubnet-Mask"TAG_TIME_OFFSETLTime-Zone"LTime-Zone"TAG_GATEWAYiDefault-Gateway"iDefault-Gateway"TAG_TIME_SERVERiTime-Server"iTime-Server"TAG_NAME_SERVERiIEN-Name-Server"iIEN-Name-Server"TAG_DOMAIN_SERVERiDomain-Name-Server"iDomain-Name-Server"TAG_LOG_SERVERiLOG"iLOG"TAG_COOKIE_SERVERiCS"iCS"TAG_LPR_SERVERiLPR-Server"iLPR-Server"TAG_IMPRESS_SERVERiIM"iIM"TAG_RLP_SERVERiRL"iRL"TAG_HOSTNAMEaHostname"aHostname"TAG_BOOTSIZEsBS"sBS" END" END"TAG_DUMPPATHaDP"aDP"TAG_DOMAINNAMEaDomain-Name"aDomain-Name"TAG_SWAP_SERVERiSS"iSS"TAG_ROOTPATHaRP"aRP"TAG_EXTPATHaEP"aEP"TAG_IP_FORWARDBIPF"BIPF"TAG_NL_SRCRTBSRT"BSRT"TAG_PFILTERSpPF"pPF"TAG_REASS_SIZEsRSZ"sRSZ"TAG_DEF_TTLbTTL"bTTL"TAG_MTU_TIMEOUTlMTU-Timeout"lMTU-Timeout"TAG_MTU_TABLEsMTU-Table"sMTU-Table"TAG_INT_MTUsMTU"sMTU"TAG_LOCAL_SUBNETSBLSN"BLSN"TAG_BROAD_ADDRiBR"iBR"TAG_DO_MASK_DISCBMD"BMD"TAG_SUPPLY_MASKBMS"BMS"TAG_DO_RDISCBRouter-Discovery"BRouter-Discovery"TAG_RTR_SOL_ADDRiRSA"iRSA"TAG_STATIC_ROUTEpStatic-Route"pStatic-Route"TAG_USE_TRAILERSBUT"BUT"TAG_ARP_TIMEOUTlAT"lAT"TAG_ETH_ENCAPBIE"BIE"TAG_TCP_TTLbTT"bTT"TAG_TCP_KEEPALIVElKI"lKI"TAG_KEEPALIVE_GOBKG"BKG"TAG_NIS_DOMAINaYD"aYD"TAG_NIS_SERVERSiYS"iYS"TAG_NTP_SERVERSiNTP"iNTP"TAG_VENDOR_OPTSbVendor-Option"bVendor-Option"TAG_NETBIOS_NSiNetbios-Name-Server"iNetbios-Name-Server"TAG_NETBIOS_DDSiWDD"iWDD"$Netbios-Node"$Netbios-Node"TAG_NETBIOS_SCOPEaNetbios-Scope"aNetbios-Scope"TAG_XWIN_FSiXFS"iXFS"TAG_XWIN_DMiXDM"iXDM"TAG_NIS_P_DOMAINsN+D"sN+D"TAG_NIS_P_SERVERSiN+S"iN+S"TAG_MOBILE_HOMEiMH"iMH"TAG_SMPT_SERVERiSMTP"iSMTP"TAG_POP3_SERVERiPOP3"iPOP3"TAG_NNTP_SERVERiNNTP"iNNTP"TAG_WWW_SERVERiWWW"iWWW"TAG_FINGER_SERVERiFG"iFG"TAG_IRC_SERVERiIRC"iIRC"TAG_STREETTALK_SRVRiSTS"iSTS"TAG_STREETTALK_STDAiSTDA"iSTDA"TAG_REQUESTED_IPiRequested-IP"iRequested-IP"TAG_IP_LEASElLease-Time"lLease-Time"$OO"$OO"TAG_TFTP_SERVERaTFTP"aTFTP"TAG_BOOTFILENAMEaBF"aBF" DHCP-Message" DHCP-Message"TAG_SERVER_IDiServer-ID"iServer-ID"bParameter-Request"bParameter-Request"TAG_MESSAGEaMSG"aMSG"TAG_MAX_MSG_SIZEsMSZ"sMSZ"TAG_RENEWAL_TIMElRN"lRN"TAG_REBIND_TIMElRB"lRB"TAG_VENDOR_CLASSaVendor-Class"aVendor-Class"$Client-ID"$Client-ID"TAG_OPEN_GROUP_UAPaUAP"aUAP"TAG_DISABLE_AUTOCONFBNOAUTO"BNOAUTO"TAG_SLP_DAbSLP-DA"bSLP-DA"TAG_SLP_SCOPEbSLP-SCOPE"bSLP-SCOPE"TAG_NS_SEARCHsNSSEARCH"sNSSEARCH"$User-Class"$User-Class"TAG_IP4_SUBNET_SELECTiSUBNET"iSUBNET"$Classless-Static-Route"$Classless-Static-Route"$Classless-Static-Route-Microsoft"$Classless-Static-Route-Microsoft"TAG_TFTP_SERVER_ADDRESSiTFTP-Server-Address"iTFTP-Server-Address"TAG_SLP_NAMING_AUTHaSLP-NA"aSLP-NA"$FQDN"$FQDN"$Agent-Information"$Agent-Information"TAG_AGENT_REMOTEbARMT"bARMT"TAG_AGENT_MASKbAMSK"bAMSK"TAG_TZ_STRINGaTZSTR"aTZSTR"TAG_FQDN_OPTIONbFQDNS"bFQDNS"TAG_AUTHbAUTH"bAUTH"TAG_VINES_SERVERSiVINES"iVINES"TAG_SERVER_RANKsRANK"sRANK"TAG_CLIENT_ARCHsARCH"sARCH"TAG_CLIENT_NDIbNDI"bNDI"TAG_CLIENT_GUIDbGUID"bGUID"TAG_LDAP_URLaLDAP"aLDAP"TAG_6OVER4i6o4"i6o4"TAG_TZ_PCODEaPOSIX-TZ"aPOSIX-TZ"TAG_TZ_TCODEaTZ-Name"aTZ-Name"TAG_IPX_COMPATbIPX"bIPX"TAG_NETINFO_PARENTiNI"iNI"TAG_NETINFO_PARENT_TAGaNITAG"aNITAG"TAG_URLaURL"aURL"TAG_FAILOVERbFAIL"bFAIL"TAG_MUDURLaMUD-URL"aMUD-URL"tag2strBOOTPREPLYbootp_op_valuesbootp_flag_values [|bootp]" [|bootp]"PRINTCMUADDRPRINTCMUADDR(m,s){ ND_TCHECK(cmu->m); if (cmu->m.s_addr != 0) ND_PRINT((ndo, " %s:%s", s, ipaddr_string(ndo, &cmu->m.s_addr))); }((uint8_t) 161)((uint8_t) 127)((uint8_t) 126)((uint8_t) 115)((uint8_t) 114)((uint8_t) 113)((uint8_t) 112)((uint8_t) 110)((uint8_t) 101)((uint8_t) 100)((uint8_t) 96)((uint8_t) 95)((uint8_t) 97)((uint8_t) 94)((uint8_t) 93)((uint8_t) 92)((uint8_t) 91)((uint8_t) 90)((uint8_t) 89)((uint8_t) 88)((uint8_t) 84)((uint8_t) 83)((uint8_t) 82)((uint8_t) 81)((uint8_t) 80)((uint8_t) 150)((uint8_t) 249)((uint8_t) 121)((uint8_t) 118)((uint8_t) 77)((uint8_t) 117)((uint8_t) 79)((uint8_t) 78)((uint8_t) 116)((uint8_t) 98)TAG_NDS_IPINFO((uint8_t) 63)TAG_NDS_IPDOMAIN((uint8_t) 62)TAG_NDS_CONTEXT((uint8_t) 87)TAG_NDS_TREE_NAME((uint8_t) 86)TAG_NDS_SERVERS((uint8_t) 85)((uint8_t) 61)((uint8_t) 60)((uint8_t) 59)((uint8_t) 58)((uint8_t) 57)((uint8_t) 56)((uint8_t) 55)((uint8_t) 54)((uint8_t) 53)((uint8_t) 67)((uint8_t) 66)((uint8_t) 52)((uint8_t) 51)((uint8_t) 50)((uint8_t) 76)((uint8_t) 75)((uint8_t) 74)((uint8_t) 73)((uint8_t) 72)((uint8_t) 71)((uint8_t) 70)((uint8_t) 69)((uint8_t) 68)((uint8_t) 65)((uint8_t) 64)((uint8_t) 49)((uint8_t) 48)((uint8_t) 47)((uint8_t) 46)((uint8_t) 45)((uint8_t) 44)((uint8_t) 43)((uint8_t) 42)((uint8_t) 41)((uint8_t) 40)((uint8_t) 39)((uint8_t) 38)((uint8_t) 37)((uint8_t) 36)((uint8_t) 35)((uint8_t) 34)((uint8_t) 33)((uint8_t) 32)((uint8_t) 31)((uint8_t) 30)((uint8_t) 29)((uint8_t) 28)((uint8_t) 27)((uint8_t) 26)((uint8_t) 25)((uint8_t) 24)((uint8_t) 23)((uint8_t) 22)((uint8_t) 21)((uint8_t) 20)((uint8_t) 19)((uint8_t) 18)((uint8_t) 17)((uint8_t) 16)((uint8_t) 15)((uint8_t) 14)((uint8_t) 255)((uint8_t) 13)((uint8_t) 12)((uint8_t) 11)((uint8_t) 10)((uint8_t) 9)((uint8_t) 8)((uint8_t) 7)((uint8_t) 6)((uint8_t) 5)((uint8_t) 4)((uint8_t) 3)((uint8_t) 2)((uint8_t) 1)((uint8_t) 0)VM_RFC1048{ 99, 130, 83, 99 }"CMU"/* Only print if there are unknown bits *//* Data left over? *//* significant octets + router(4) *//* mask_width <= 32 *//* this option should be at least 5 bytes long *//* this option should be at least 1 byte long *//* this option should be at least 3 bytes long *//* Guys we can't handle with one of the usual cases *//* Bytes *//* boolean *//* shorts *//* IP address pairs *//* ip addresses/32-bit words *//* ascii strings *//* Base default formats for unknown tags on data size *//* Print data *//* Get the length; check for truncation *//* XXX we don't know yet if the IANA will
			 * preclude overlap of 1-byte and 2-byte spaces.
			 * If not, we need to offset tag after this step.
			 *//* Loop while we there is a tag left in the buffer *//* Step over magic cookie *//* RFC 3993 *//* RFC 3046 *//* ARP Hardware types, for Client-ID option *//* NETBIOS over TCP/IP node type options *//* DHCP "options overload" types *//* 2-byte extended tags *//* XXX 'b' *//* http://www.iana.org/assignments/bootp-dhcp-extensions/index.htm *//* RFC 5859 - TFTP Server Address Option for DHCPv4 *//* RFC 3442 *//* RFC 3011 *//* RFC 3004 - The User Class Option for DHCP *//* XXX 's' *//* RFC 2937 *//*"b" is a little wrong *//* RFC 2610 *//* RFC 2563 *//* RFC 2485 *//* RFC2132 tags *//* RFC1497 tags *//* 512 byte blocks *//* ascii hostname *//* resource location (RFC887) *//* impress servers (Imagen) *//* lpr server (RFC1179) *//* cookie servers (RFC865) *//* MIT log servers *//* domain name (RFC1035) *//* IEN name servers (IEN116) *//* time servers (RFC868) *//* default gateway *//* seconds from UTC *//* subnet mask (RFC950) *//* RFC1048 tags *//*
 * The first character specifies the format to print:
 *     i - ip address (32 bits)
 *     p - ip address pairs (32 bits + 32 bits)
 *     l - long (32 bits)
 *     L - unsigned long (32 bits)
 *     s - short (16 bits)
 *     b - period-seperated decimal bytes (variable length)
 *     x - colon-seperated hex bytes (variable length)
 *     a - ascii string (variable length)
 *     B - on/off (8 bits)
 *     $ - special (explicit code to handle)
 *//* Decode the vendor buffer *//* check first char only *//* Client's Ethernet address *//* Gateway's ip address *//* Server's ip address *//* 'your' ip address (bootp client) *//* Client's ip address *//* Only print interesting fields *//* The usual length for 10Mb Ethernet address is 6 bytes *//* The usual hardware address type is 1 (10Mb Ethernet) *//*
 * Print bootp requests
 *//* end of original bootp.h *//* RFC 4702 DHCP Client FQDN Option *//* Subnet mask field contains valid data *//* v_flags values *//* currently unused *//* Time servers *//* IEN-116 name servers *//* Domain name servers *//* Default gateway *//* Subnet mask *//* flags/opcodes, etc. *//* magic number *//*
 * "vendor" data permitted for CMU bootp clients.
 *//* DHCP Message types (values for TAG_DHCP_MESSAGE option) *//* RFC 4833, TZ codes *//* ftp://ftp.isi.edu/.../assignments/bootp-dhcp-extensions *//* RFC 2242 *//* RFC 2241 *//* DHCP options *//* RFC2132 *//*
 * RFC1048 tag values used to specify what information is being supplied in
 * the vendor field of the packet.
 *//*
 * Vendor magic cookie (v_magic) for RFC1048
 *//*
 * Vendor magic cookie (v_magic) for CMU
 *//* vendor-specific area *//* boot file name *//* server host name *//* client hardware address *//* gateway IP address *//* server IP address *//* 'your' IP address *//* client IP address *//* flags - see bootp_flag_values[]
					   in print-bootp.c *//* seconds since boot began *//* transaction ID *//* gateway hops *//* hardware addr length *//* hardware addr type *//* packet opcode type *//*
 * Bootstrap Protocol (BOOTP).  RFC951 and RFC1048.
 *
 * This file specifies the "implementation-independent" BOOTP protocol
 * information which is common to both client and server.
 *
 * Copyright 1988 by Carnegie Mellon.
 *
 * Permission to use, copy, modify, and distribute this program for any
 * purpose and without fee is hereby granted, provided that this copyright
 * and permission notice appear on all copies and supporting documentation,
 * the name of Carnegie Mellon not be used in advertising or publicity
 * pertaining to distribution of the program without specific prior
 * permission, and notice be given in supporting documentation that copying
 * and distribution is by permission of Carnegie Mellon and Stanford
 * University.  Carnegie Mellon makes no representations about the
 * suitability of this software for any purpose.  It is provided "as is"
 * without express or implied warranty.
 *//* \summary: BOOTP and IPv4 DHCP printer *//*
 * Copyright (c) 1990, 1991, 1993, 1994, 1995, 1996, 1997
 *	The Regents of the University of California.  All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that: (1) source code distributions
 * retain the above copyright notice and this paragraph in its entirety, (2)
 * distributions including binary code include the above copyright notice and
 * this paragraph in its entirety in the documentation or other materials
 * provided with the distribution, and (3) all advertising materials mentioning
 * features or use of this software display the following acknowledgement:
 * ``This product includes software developed by the University of California,
 * Lawrence Berkeley Laboratory and its contributors.'' Neither the name of
 * the University nor the names of its contributors may be used to endorse
 * or promote products derived from this software without specific prior
 * written permission.
 * THIS SOFTWARE IS PROVIDED ``AS IS'' AND WITHOUT ANY EXPRESS OR IMPLIED
 * WARRANTIES, INCLUDING, WITHOUT LIMITATION, THE IMPLIED WARRANTIES OF
 * MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE.
 *//Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX.sdk/usr/include/pcap/bluetooth.h<pcap/pcap-inttypes.h>pcap_bluetooth_linux_monitor_header_pcap_bluetooth_linux_monitor_headerpcap_bluetooth_h4_header_pcap_bluetooth_h4_headeropcodeadapter_iddirectionlib_pcap_bluetooth_h/*
 * Header prepended libpcap to each bluetooth linux monitor frame,
 * fields are in network byte order
 *//* if first bit is set direction is incoming *//*
 * Header prepended libpcap to each bluetooth h4 frame,
 * fields are in network byte order
 *//*
 * Copyright (c) 2006 Paolo Abeni (Italy)
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 *
 * 1. Redistributions of source code must retain the above copyright
 * notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 * notice, this list of conditions and the following disclaimer in the
 * documentation and/or other materials provided with the distribution.
 * 3. The name of the author may not be used to endorse or promote
 * products derived from this software without specific prior written
 * permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
 * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
 * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
 * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
 * OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
 * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
 * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
 * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
 * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 *
 * bluetooth data struct
 * By Paolo Abeni <paolo.abeni@email.it>
 *//Users/owura/Repos/codeql_eval/proj_repos/the-tcpdump-group-tcpdump-commit-9ba91381954ad325ea4fd26b9c65a8bd9a2a85b6/tcpdump/print-bt.c<pcap/bluetooth.h>bt_if_printconst pcap_bluetooth_h4_headerconst pcap_bluetooth_h4_header *_pcap_bluetooth_h4_header *(ndo, "[|bt]")BT_HDRLEN[|bt](BT_HDRLEN)(ndo, "hci length %d, direction %s, ", length, (EXTRACT_32BITS(&hdr->direction)&0x1)?"in":"out")(ndo, "hci length %d, direction %s, ", length, (((uint32_t)(((uint32_t)(*((const uint8_t *)(&hdr->direction) + 0)) << 24) | ((uint32_t)(*((const uint8_t *)(&hdr->direction) + 1)) << 16) | ((uint32_t)(*((const uint8_t *)(&hdr->direction) + 2)) << 8) | ((uint32_t)(*((const uint8_t *)(&hdr->direction) + 3)) << 0)))&0x1)?"in":"out")&hdr->directionhci length %d, direction %s, sizeof(pcap_bluetooth_h4_header)defined(DLT_BLUETOOTH_HCI_H4_WITH_PHDR) && defined(HAVE_PCAP_BLUETOOTH_H)/*
 * This is the top level routine of the printer.  'p' points
 * to the bluetooth header of the packet, 'h->ts' is the timestamp,
 * 'h->len' is the length of the packet off the wire, and 'h->caplen'
 * is the number of bytes actually captured.
 *//* \summary: Bluetooth printer *//*
 * Copyright (c) 2007
 *	paolo.abeni@email.it  All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that: (1) source code distributions
 * retain the above copyright notice and this paragraph in its entirety, (2)
 * distributions including binary code include the above copyright notice and
 * this paragraph in its entirety in the documentation or other materials
 * provided with the distribution, and (3) all advertising materials mentioning
 * features or use of this software display the following acknowledgement:
 * ``This product includes software developed by Paolo Abeni.''
 * The name of author may not be used to endorse or promote products derived
 * from this software without specific prior written permission.
 * THIS SOFTWARE IS PROVIDED ``AS IS'' AND WITHOUT ANY EXPRESS OR IMPLIED
 * WARRANTIES, INCLUDING, WITHOUT LIMITATION, THE IMPLIED WARRANTIES OF
 * MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE.
 *//Users/owura/Repos/codeql_eval/proj_repos/the-tcpdump-group-tcpdump-commit-9ba91381954ad325ea4fd26b9c65a8bd9a2a85b6/tcpdump/print-calm-fast.ccalm_fast_printsrcNwrefdstNwref(ndo, "CALM FAST")CALM FAST(ndo, " src:%s", (src->addr_string)(ndo, src->addr)) src:%s(ndo, "; "); (ndo, "SrcNwref:%d; ", srcNwref)SrcNwref:%d; (ndo, "DstNwref:%d; ", dstNwref)DstNwref:%d; (ndo, "[|calm fast]")[|calm fast]/*
 * This is the top level routine of the printer.  'bp' points
 * to the calm header of the packet.
 *//*
   ISO 29281:2009
   Intelligent Transport Systems . Communications access for land mobiles (CALM)
   CALM non-IP networking
*//* \summary: Communication access for land mobiles (CALM) printer *//*
 * Copyright (c) 2013 The TCPDUMP project
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that: (1) source code
 * distributions retain the above copyright notice and this paragraph
 * in its entirety, and (2) distributions including binary code include
 * the above copyright notice and this paragraph in its entirety in
 * the documentation or other materials provided with the distribution.
 * THIS SOFTWARE IS PROVIDED ``AS IS'' AND
 * WITHOUT ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, WITHOUT
 * LIMITATION, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS
 * FOR A PARTICULAR PURPOSE.
 *
 * Original code by Ola Martin Lykkja (ola.lykkja@q-free.com)
 *//Users/owura/Repos/codeql_eval/proj_repos/the-tcpdump-group-tcpdump-commit-9ba91381954ad325ea4fd26b9c65a8bd9a2a85b6/tcpdump/print-carp.ccarp_printtype_sbp[0]sizeof(bp[0])advertise"advertise""unknown"(ndo, "CARPv%d-%s %d: ", version, type_s, len)CARPv%d-%s %d: (ndo, "[ttl=%d!] ", ttl)[ttl=%d!] bp[2]sizeof(bp[2])bp[5]sizeof(bp[5])(ndo, "vhid=%d advbase=%d advskew=%d authlen=%d ", bp[1], bp[5], bp[2], bp[3])vhid=%d advbase=%d advskew=%d authlen=%d (ndo, " (bad carp cksum %x!)", EXTRACT_16BITS(&bp[6]))(ndo, " (bad carp cksum %x!)", ((uint16_t)(((uint16_t)(*((const uint8_t *)(&bp[6]) + 0)) << 8) | ((uint16_t)(*((const uint8_t *)(&bp[6]) + 1)) << 0))))&bp[6]cksum_vec[1] (bad carp cksum %x!)(ndo, "counter=%" PRIu64, EXTRACT_64BITS(&bp[8]))(ndo, "counter=%" "ll" "u", ((uint64_t)(((uint64_t)(*((const uint8_t *)(&bp[8]) + 0)) << 56) | ((uint64_t)(*((const uint8_t *)(&bp[8]) + 1)) << 48) | ((uint64_t)(*((const uint8_t *)(&bp[8]) + 2)) << 40) | ((uint64_t)(*((const uint8_t *)(&bp[8]) + 3)) << 32) | ((uint64_t)(*((const uint8_t *)(&bp[8]) + 4)) << 24) | ((uint64_t)(*((const uint8_t *)(&bp[8]) + 5)) << 16) | ((uint64_t)(*((const uint8_t *)(&bp[8]) + 6)) << 8) | ((uint64_t)(*((const uint8_t *)(&bp[8]) + 7)) << 0))))counter=%llu&bp[8](ndo, "[|carp]")[|carp]/* for checksum structure and functions *//* \summary: Common Address Redundancy Protocol (CARP) printer *//*
 * Copyright (c) 2000 William C. Fenner.
 *                All rights reserved.
 *
 * Kevin Steves <ks@hp.se> July 2000
 * Modified to:
 * - print version, type string and packet length
 * - print IP address count if > 1 (-v)
 * - verify checksum (-v)
 * - print authentication string (-v)
 *
 * Copyright (c) 2011 Advanced Computing Technologies
 * George V. Neille-Neil
 *
 * Modified to:
 * - work correctly with CARP
 * - compile into the latest tcpdump
 * - print out the counter
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that: (1) source code
 * distributions retain the above copyright notice and this paragraph
 * in its entirety, and (2) distributions including binary code include
 * the above copyright notice and this paragraph in its entirety in
 * the documentation or other materials provided with the distribution.
 * The name of William C. Fenner may not be used to endorse or
 * promote products derived from this software without specific prior
 * written permission.  THIS SOFTWARE IS PROVIDED ``AS IS'' AND
 * WITHOUT ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, WITHOUT
 * LIMITATION, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS
 * FOR A PARTICULAR PURPOSE.
 *
 *//*	$OpenBSD: print-carp.c,v 1.6 2009/10/27 23:59:55 deraadt Exp $	*//Users/owura/Repos/codeql_eval/proj_repos/the-tcpdump-group-tcpdump-commit-9ba91381954ad325ea4fd26b9c65a8bd9a2a85b6/tcpdump/print-cdp.ccdp_get_numbercdp_print_prefixes(ndo, " IPv4 Prefixes (%d):", l / 5) IPv4 Prefixes (%d):(ndo, " %u.%u.%u.%u/%u", p[0], p[1], p[2], p[3], p[4]) %u.%u.%u.%u/%ucdp_print_addrptalendpprot_ipv6p[pl]&p[pl](ndo, "IPv4 (%u) %s", num, ipaddr_string(ndo, p))(ndo, "IPv4 (%u) %s", num, getname(ndo, (const u_char *)(p)))(ndo, "IPv6 (%u) %s", num, ip6addr_string(ndo, p))(ndo, "IPv6 (%u) %s", num, getname6(ndo, (const u_char *)(p)))(ndo, "pt=0x%02x, pl=%d, pb=", *(p - 2), pl)(ndo, " %02x", *p++)(ndo, ", al=%d, a=", al)PT_NLPIDIPv4 (%u) %sPT_IEEE_802_2const u_char[8]IPv6 (%u) %spt=0x%02x, pl=%d, pb=, al=%d, a=0x860xddcdp_printCDP_HEADER_LEN(ndo, "CDPv%u, ttl: %us", *(tptr + CDP_HEADER_VERSION_OFFSET), *(tptr + CDP_HEADER_TTL_OFFSET))(ndo, "CDPv%u, ttl: %us", *(tptr + 0), *(tptr + 1))CDPv%u, ttl: %us(ndo, ", checksum: 0x%04x (unverified), length %u", EXTRACT_16BITS(tptr+CDP_HEADER_CHECKSUM_OFFSET), length)(ndo, ", checksum: 0x%04x (unverified), length %u", ((uint16_t)(((uint16_t)(*((const uint8_t *)(tptr+2) + 0)) << 8) | ((uint16_t)(*((const uint8_t *)(tptr+2) + 1)) << 0))), length)tptr+CDP_HEADER_CHECKSUM_OFFSET, checksum: 0x%04x (unverified), length %uCDP_TLV_HEADER_LENtptr+CDP_TLV_TYPE_OFFSETtptr+0tptr+CDP_TLV_LEN_OFFSET(ndo, "\n\t%s (0x%02x), TLV length: %u byte%s (too short)", tok2str(cdp_tlv_values,"unknown field type", type), type, len, PLURAL_SUFFIX(len))(ndo, "\n\t%s (0x%02x), TLV length: %u byte%s (too short)", tok2str(cdp_tlv_values,"unknown field type", type), type, len, (((len) != 1) ? "s" : ""))(ndo, ", %s TLV length %u too short", tok2str(cdp_tlv_values,"unknown field type", type), len)(ndo, "\n\t%s (0x%02x), value length: %u byte%s: ", tok2str(cdp_tlv_values,"unknown field type", type), type, len, PLURAL_SUFFIX(len))(ndo, "\n\t%s (0x%02x), value length: %u byte%s: ", tok2str(cdp_tlv_values,"unknown field type", type), type, len, (((len) != 1) ? "s" : ""))(ndo, ", Device-ID ")(ndo, "'")(ndo, "(0x%08x): %s", EXTRACT_32BITS(tptr), bittok2str(cdp_capability_values, "none", EXTRACT_32BITS(tptr)))(ndo, "(0x%08x): %s", ((uint32_t)(((uint32_t)(*((const uint8_t *)(tptr) + 0)) << 24) | ((uint32_t)(*((const uint8_t *)(tptr) + 1)) << 16) | ((uint32_t)(*((const uint8_t *)(tptr) + 2)) << 8) | ((uint32_t)(*((const uint8_t *)(tptr) + 3)) << 0))), bittok2str(cdp_capability_values, "none", ((uint32_t)(((uint32_t)(*((const uint8_t *)(tptr) + 0)) << 24) | ((uint32_t)(*((const uint8_t *)(tptr) + 1)) << 16) | ((uint32_t)(*((const uint8_t *)(tptr) + 2)) << 8) | ((uint32_t)(*((const uint8_t *)(tptr) + 3)) << 0)))))(ndo, "\n\t  ")(ndo, "%d", EXTRACT_16BITS(tptr))(ndo, "%d", ((uint16_t)(((uint16_t)(*((const uint8_t *)(tptr) + 0)) << 8) | ((uint16_t)(*((const uint8_t *)(tptr) + 1)) << 0))))(ndo, "%s", *(tptr) ? "full": "half")(ndo, "app %d, vlan %d", *(tptr), EXTRACT_16BITS(tptr + 1))(ndo, "app %d, vlan %d", *(tptr), ((uint16_t)(((uint16_t)(*((const uint8_t *)(tptr + 1) + 0)) << 8) | ((uint16_t)(*((const uint8_t *)(tptr + 1) + 1)) << 0))))tptr + 1(ndo, "%1.2fW", cdp_get_number(tptr, len) / 1000.0)(ndo, "%u bytes", EXTRACT_32BITS(tptr))(ndo, "%u bytes", ((uint32_t)(((uint32_t)(*((const uint8_t *)(tptr) + 0)) << 24) | ((uint32_t)(*((const uint8_t *)(tptr) + 1)) << 16) | ((uint32_t)(*((const uint8_t *)(tptr) + 2)) << 8) | ((uint32_t)(*((const uint8_t *)(tptr) + 3)) << 0))))(ndo, "0x%02x", *(tptr))(ndo, "/")
	%s (0x%02x), TLV length: %u byte%s (too short)const tok[22]tok[22]unknown field type, %s TLV length %u too short
	%s (0x%02x), value length: %u byte%s: , Device-ID '(0x%08x): %s0x0a0x0bfullhalfapp %d, vlan %d%1.2fW1000.00x11%u bytes0x120x%02x0x130x140x16(ndo, ", length %u", caplen)Transparent Bridge"Transparent Bridge"Source Route Bridge"Source Route Bridge"L2 Switch"L2 Switch"L3 capable"L3 capable"IGMP snooping"IGMP snooping"L1 capable"L1 capable"cdp_capability_valuesDevice-ID"Device-ID"Address"Address"Port-ID"Port-ID"Capability"Capability"Version String"Version String"Platform"Platform"Prefixes"Prefixes"Protocol-Hello option"Protocol-Hello option"VTP Management Domain"VTP Management Domain"Native VLAN ID"Native VLAN ID"Duplex"Duplex"ATA-186 VoIP VLAN request"ATA-186 VoIP VLAN request"ATA-186 VoIP VLAN assignment"ATA-186 VoIP VLAN assignment"power consumption"power consumption"MTU"MTU"AVVID trust bitmap"AVVID trust bitmap"AVVID untrusted ports CoS"AVVID untrusted ports CoS"System Name"System Name"0x15System Object ID (not decoded)"System Object ID (not decoded)"Management Addresses"Management Addresses"Physical Location"Physical Location"cdp_tlv_values[|cdp]"[|cdp]"CDP_TLV_LEN_OFFSETCDP_TLV_TYPE_OFFSETCDP_HEADER_CHECKSUM_OFFSETCDP_HEADER_TTL_OFFSETCDP_HEADER_VERSION_OFFSET/* read in a <n>-byte number, MSB first
 * (of course this can handle max sizeof(long))
 *//*
			 * Generic case: just print raw data
			 *//*
			 * IPv6: protocol type = IEEE 802.2 header,
			 * protocol length = 8 (size of LLC+SNAP header),
			 * protocol = LLC+SNAP header with the IPv6
			 * Ethertype, address length = 16
			 *//*
			 * IPv4: protocol type = NLPID, protocol length = 1
			 * (1-byte NLPID), protocol = 0xcc (NLPID for IPv4),
			 * address length = 4
			 *//* address length *//* length of "protocol" field *//* type of "protocol" field *//* IEEE 802.2 LLC header *//* OSI NLPID *//*
 * Protocol type values.
 *
 * PT_NLPID means that the protocol type field contains an OSI NLPID.
 *
 * PT_IEEE_802_2 means that the protocol type field contains an IEEE 802.2
 * LLC header that specifies that the payload is for that protocol.
 *//* Physical Location - not documented *//* System Object ID - not documented *//* System Name - not documented *//* AVVID untrusted port CoS - not documented *//* AVVID trust bitmap - not documented *//* MTU - not documented *//* ATA-186 VoIP VLAN assignment - incomplete doc. *//* ATA-186 VoIP VLAN request - incomplete doc. *//* http://www.cisco.com/c/en/us/td/docs/voice_ip_comm/cata/186/2_12_m/english/release/notes/186rn21m.html
		     * plus more details from other sources
		     *//* Duplex - CDPv2 *//* Native VLAN ID - CDPv2 *//* VTP Mgmt Domain  - CDPv2 *//* Protocol Hello Option - not documented *//* Prefixes *//* Platform *//* lets rework the version string to
					      get a nice indentation *//* Capabilities *//* Port-ID *//* Address *//* Device-ID *//* plural *//* in non-verbose mode just print Device-ID *//* object length includes the 4 bytes header length *//* read out Type and Length *//* temporary pointer *//* \summary: Cisco Discovery Protocol (CDP) printer *//*
 * Copyright (c) 1992, 1993, 1994, 1995, 1996, 1997
 *	The Regents of the University of California.  All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that: (1) source code distributions
 * retain the above copyright notice and this paragraph in its entirety, (2)
 * distributions including binary code include the above copyright notice and
 * this paragraph in its entirety in the documentation or other materials
 * provided with the distribution, and (3) all advertising materials mentioning
 * features or use of this software display the following acknowledgement:
 * ``This product includes software developed by the University of California,
 * Lawrence Berkeley Laboratory and its contributors.'' Neither the name of
 * the University nor the names of its contributors may be used to endorse
 * or promote products derived from this software without specific prior
 * written permission.
 * THIS SOFTWARE IS PROVIDED ``AS IS'' AND WITHOUT ANY EXPRESS OR IMPLIED
 * WARRANTIES, INCLUDING, WITHOUT LIMITATION, THE IMPLIED WARRANTIES OF
 * MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE.
 *
 * Code by Gert Doering, SpaceNet GmbH, gert@space.net
 *
 * Reference documentation:
 *    http://www.cisco.com/univercd/cc/td/doc/product/lan/trsrb/frames.htm
 *//Users/owura/Repos/codeql_eval/proj_repos/the-tcpdump-group-tcpdump-commit-9ba91381954ad325ea4fd26b9c65a8bd9a2a85b6/tcpdump/print-cfm.ccfm_printconst cfm_common_header_tconst cfm_common_header_t *cfm_common_header_t *cfm_common_headerconst cfm_tlv_header_tconst cfm_tlv_header_t *cfm_tlv_header_t *cfm_tlv_headertlv_ptrnamespnames_data_remainingmd_nameformatmd_namelengthmd_namema_nameformatma_namelengthma_namehexdumpcfm_tlv_lencfm_tlv_typeccm_intervalmsg_ptrsizeof(*cfm_common_header)*cfm_common_headercfm_common_header->mdlevel_version(ndo, "CFMv%u not supported, length %u", CFM_EXTRACT_VERSION(cfm_common_header->mdlevel_version), length)(ndo, "CFMv%u not supported, length %u", (((cfm_common_header->mdlevel_version)&0x1f)), length)CFM_VERSIONCFMv%u not supported, length %u(ndo, "CFMv%u %s, MD Level %u, length %u", CFM_EXTRACT_VERSION(cfm_common_header->mdlevel_version), tok2str(cfm_opcode_values, "unknown (%u)", cfm_common_header->opcode), CFM_EXTRACT_MD_LEVEL(cfm_common_header->mdlevel_version), length)(ndo, "CFMv%u %s, MD Level %u, length %u", (((cfm_common_header->mdlevel_version)&0x1f)), tok2str(cfm_opcode_values, "unknown (%u)", cfm_common_header->opcode), (((cfm_common_header->mdlevel_version)&0xe0)>>5), length)CFMv%u %s, MD Level %u, length %u(ndo, "\n\tFirst TLV offset %u", cfm_common_header->first_tlv_offset)
	First TLV offset %usizeof(const struct cfm_common_header_t)sizeof(struct cfm_common_header_t)(ndo, " (too large, must be <= %u)", tlen) (too large, must be <= %u)(ndo, " (too small 1, must be >= %lu)", (unsigned long) sizeof(*msg_ptr.cfm_ccm))*msg_ptr.cfm_ccmsizeof(*msg_ptr.cfm_ccm)cfm_common_header->flags(ndo, ", Flags [CCM Interval %u%s]", ccm_interval, cfm_common_header->flags & CFM_CCM_RDI_FLAG ? ", RDI" : "")(ndo, ", Flags [CCM Interval %u%s]", ccm_interval, cfm_common_header->flags & 0x80 ? ", RDI" : "")(ndo, "\n\t  CCM Interval %.3fs" ", min CCM Lifetime %.3fs, max CCM Lifetime %.3fs", ccm_interval_base[ccm_interval], ccm_interval_base[ccm_interval] * CCM_INTERVAL_MIN_MULTIPLIER, ccm_interval_base[ccm_interval] * CCM_INTERVAL_MAX_MULTIPLIER)(ndo, "\n\t  CCM Interval %.3fs" ", min CCM Lifetime %.3fs, max CCM Lifetime %.3fs", ccm_interval_base[ccm_interval], ccm_interval_base[ccm_interval] * 3.25, ccm_interval_base[ccm_interval] * 3.5)(ndo, "\n\t  Sequence Number 0x%08x, MA-End-Point-ID 0x%04x", EXTRACT_32BITS(msg_ptr.cfm_ccm->sequence), EXTRACT_16BITS(msg_ptr.cfm_ccm->ma_epi))(ndo, "\n\t  Sequence Number 0x%08x, MA-End-Point-ID 0x%04x", ((uint32_t)(((uint32_t)(*((const uint8_t *)(msg_ptr.cfm_ccm->sequence) + 0)) << 24) | ((uint32_t)(*((const uint8_t *)(msg_ptr.cfm_ccm->sequence) + 1)) << 16) | ((uint32_t)(*((const uint8_t *)(msg_ptr.cfm_ccm->sequence) + 2)) << 8) | ((uint32_t)(*((const uint8_t *)(msg_ptr.cfm_ccm->sequence) + 3)) << 0))), ((uint16_t)(((uint16_t)(*((const uint8_t *)(msg_ptr.cfm_ccm->ma_epi) + 0)) << 8) | ((uint16_t)(*((const uint8_t *)(msg_ptr.cfm_ccm->ma_epi) + 1)) << 0))))msg_ptr.cfm_ccm->sequencemsg_ptr.cfm_ccm->ma_epi(ndo, "\n\t  MD Name Format %s (%u), MD Name length %u", tok2str(cfm_md_nameformat_values, "Unknown", md_nameformat), md_nameformat, md_namelength)(ndo, " (too large, must be <= %u)", names_data_remaining - 2)(ndo, "\n\t  MD Name: ")(ndo, "\n\t  MAC %s", etheraddr_string(ndo, md_name))(ndo, "\n\t  MAC (length invalid)")(ndo, "\n\t  MD Name Format %s (%u)", tok2str(cfm_md_nameformat_values, "Unknown", md_nameformat), md_nameformat)(ndo, "\n\t  MA Name-Format %s (%u), MA name length %u", tok2str(cfm_ma_nameformat_values, "Unknown", ma_nameformat), ma_nameformat, ma_namelength)(ndo, " (too large, must be <= %u)", names_data_remaining)(ndo, "\n\t  MA Name: ")(ndo, " (too small 4, must be >= %lu)", (unsigned long) sizeof(*msg_ptr.cfm_ltm))*msg_ptr.cfm_ltmsizeof(*msg_ptr.cfm_ltm)(ndo, ", Flags [%s]", bittok2str(cfm_ltm_flag_values, "none", cfm_common_header->flags))(ndo, "\n\t  Transaction-ID 0x%08x, ttl %u", EXTRACT_32BITS(msg_ptr.cfm_ltm->transaction_id), msg_ptr.cfm_ltm->ttl)(ndo, "\n\t  Transaction-ID 0x%08x, ttl %u", ((uint32_t)(((uint32_t)(*((const uint8_t *)(msg_ptr.cfm_ltm->transaction_id) + 0)) << 24) | ((uint32_t)(*((const uint8_t *)(msg_ptr.cfm_ltm->transaction_id) + 1)) << 16) | ((uint32_t)(*((const uint8_t *)(msg_ptr.cfm_ltm->transaction_id) + 2)) << 8) | ((uint32_t)(*((const uint8_t *)(msg_ptr.cfm_ltm->transaction_id) + 3)) << 0))), msg_ptr.cfm_ltm->ttl)msg_ptr.cfm_ltm->transaction_id(ndo, "\n\t  Original-MAC %s, Target-MAC %s", etheraddr_string(ndo, msg_ptr.cfm_ltm->original_mac), etheraddr_string(ndo, msg_ptr.cfm_ltm->target_mac))(ndo, " (too small 5, must be >= %lu)", (unsigned long) sizeof(*msg_ptr.cfm_ltr))*msg_ptr.cfm_ltrsizeof(*msg_ptr.cfm_ltr)(ndo, ", Flags [%s]", bittok2str(cfm_ltr_flag_values, "none", cfm_common_header->flags))(ndo, "\n\t  Transaction-ID 0x%08x, ttl %u", EXTRACT_32BITS(msg_ptr.cfm_ltr->transaction_id), msg_ptr.cfm_ltr->ttl)(ndo, "\n\t  Transaction-ID 0x%08x, ttl %u", ((uint32_t)(((uint32_t)(*((const uint8_t *)(msg_ptr.cfm_ltr->transaction_id) + 0)) << 24) | ((uint32_t)(*((const uint8_t *)(msg_ptr.cfm_ltr->transaction_id) + 1)) << 16) | ((uint32_t)(*((const uint8_t *)(msg_ptr.cfm_ltr->transaction_id) + 2)) << 8) | ((uint32_t)(*((const uint8_t *)(msg_ptr.cfm_ltr->transaction_id) + 3)) << 0))), msg_ptr.cfm_ltr->ttl)msg_ptr.cfm_ltr->transaction_id(ndo, "\n\t  Replay-Action %s (%u)", tok2str(cfm_ltr_replay_action_values, "Unknown", msg_ptr.cfm_ltr->replay_action), msg_ptr.cfm_ltr->replay_action)CFM_OPCODE_CCMconst cfm_ccm_tconst cfm_ccm_t *cfm_ccm_t * (too small 1, must be >= %lu), Flags [CCM Interval %u%s], RDI
	  CCM Interval %.3fs, min CCM Lifetime %.3fs, max CCM Lifetime %.3fschar[71]const float[8]float[8]3.253.5
	  Sequence Number 0x%08x, MA-End-Point-ID 0x%04xuint8_t[48]unsigned char[48]const uint8_t[48]sizeof(msg_ptr.cfm_ccm->names)CFM_CCM_MD_FORMAT_NONE
	  MD Name Format %s (%u), MD Name length %u
	  MD Name: CFM_CCM_MD_FORMAT_DNSCFM_CCM_MD_FORMAT_CHARCFM_CCM_MD_FORMAT_MAC
	  MAC %s
	  MAC (length invalid)CFM_CCM_MA_FORMAT_8021
	  MD Name Format %s (%u)
	  MA Name-Format %s (%u), MA name length %u
	  MA Name: CFM_CCM_MA_FORMAT_CHARCFM_CCM_MA_FORMAT_VIDCFM_CCM_MA_FORMAT_INTCFM_CCM_MA_FORMAT_VPNCFM_OPCODE_LTMconst cfm_ltm_tconst cfm_ltm_t *cfm_ltm_t * (too small 4, must be >= %lu)
	  Transaction-ID 0x%08x, ttl %u
	  Original-MAC %s, Target-MAC %sCFM_OPCODE_LTRconst cfm_ltr_tconst cfm_ltr_t *cfm_ltr_t * (too small 5, must be >= %lu)
	  Replay-Action %s (%u)CFM_OPCODE_LBRCFM_OPCODE_LBM(ndo, "\n\t%s TLV (0x%02x)", tok2str(cfm_tlv_values, "Unknown", cfm_tlv_type), cfm_tlv_type)sizeof(struct cfm_tlv_header_t)&cfm_tlv_header->length(ndo, ", length %u", cfm_tlv_len)(ndo, " (too short, must be >= 1)")(ndo, ", Status: %s (%u)", tok2str(cfm_tlv_port_status_values, "Unknown", *tptr), *tptr)(ndo, ", Status: %s (%u)", tok2str(cfm_tlv_interface_status_values, "Unknown", *tptr), *tptr)(ndo, " (too short, must be >= 4)")(ndo, ", Vendor: %s (%u), Sub-Type %u", tok2str(oui_values,"Unknown", EXTRACT_24BITS(tptr)), EXTRACT_24BITS(tptr), *(tptr + 3))(ndo, ", Vendor: %s (%u), Sub-Type %u", tok2str(oui_values,"Unknown", ((uint32_t)(((uint32_t)(*((const uint8_t *)(tptr) + 0)) << 16) | ((uint32_t)(*((const uint8_t *)(tptr) + 1)) << 8) | ((uint32_t)(*((const uint8_t *)(tptr) + 2)) << 0)))), ((uint32_t)(((uint32_t)(*((const uint8_t *)(tptr) + 0)) << 16) | ((uint32_t)(*((const uint8_t *)(tptr) + 1)) << 8) | ((uint32_t)(*((const uint8_t *)(tptr) + 2)) << 0))), *(tptr + 3))(ndo, "\n\t  (TLV too short)")(ndo, "\n\t  Chassis-ID Type %s (%u), Chassis-ID length %u", tok2str(cfm_tlv_senderid_chassisid_values, "Unknown", chassis_id_type), chassis_id_type, chassis_id_length)(ndo, " (invalid MAC address length)")(ndo, "\n\t  MAC %s", etheraddr_string(ndo, tptr + 1))(ndo, "\n\t  Management Address Domain Length %u", mgmt_addr_length)(ndo, " (Management Address Length is missing)")(ndo, "\n\t  Management Address Length %u", mgmt_addr_length)
	%s TLV (0x%02x)CFM_TLV_ENDFALSECFM_TLV_PORT_STATUS (too short, must be >= 1), Status: %s (%u)CFM_TLV_INTERFACE_STATUSCFM_TLV_PRIVATE (too short, must be >= 4), Vendor: %s (%u), Sub-Type %uTRUECFM_TLV_SENDER_IDchassis_id_typechassis_id_lengthmgmt_addr_length
	  (TLV too short)
	  Chassis-ID Type %s (%u), Chassis-ID length %uCFM_CHASSIS_ID_MAC_ADDRESS (invalid MAC address length)CFM_CHASSIS_ID_NETWORK_ADDRESSCFM_CHASSIS_ID_INTERFACE_NAMECFM_CHASSIS_ID_INTERFACE_ALIASCFM_CHASSIS_ID_LOCALCFM_CHASSIS_ID_CHASSIS_COMPONENTCFM_CHASSIS_ID_PORT_COMPONENT
	  Management Address Domain Length %u
	  Management Address Domain: "\n\t  Management Address Domain: " (Management Address Length is missing)
	  Management Address Length %u
	  Management Address: "\n\t  Management Address: "CFM_TLV_DATACFM_TLV_REPLY_INGRESSCFM_TLV_REPLY_EGRESSnext_tlvtooshort(ndo, "\n\t\t packet is too short")
		 packet is too short(ndo, "\n\t\t packet exceeded snapshot")
		 packet exceeded snapshotcfm_network_addr_printnetwork_addr_type(ndo, "\n\t  Network Address Type (invalid, no data")
	  Network Address Type (invalid, no data(ndo, "\n\t  Network Address Type %s (%u)", tok2str(af_values, "Unknown", network_addr_type), network_addr_type)
	  Network Address Type %s (%u)(ndo, "(invalid IPv4 address length %u)", length - 1)(ndo, ", %s", ipaddr_string(ndo, tptr + 1))(ndo, ", %s", getname(ndo, (const u_char *)(tptr + 1)))(ndo, "(invalid IPv6 address length %u)", length - 1)(ndo, ", %s", ip6addr_string(ndo, tptr + 1))(ndo, ", %s", getname6(ndo, (const u_char *)(tptr + 1)))1 + 4(invalid IPv4 address length %u)1 + 16(invalid IPv6 address length %u)cfm_tlv_header_tcfm_ltr_tcfm_ltm_tcfm_lbm_tcfm_ccm_tcfm_common_header_tcfm_ltrcfm_ltmconst cfm_lbm_tconst cfm_lbm_t *cfm_lbm_t *cfm_lbmcfm_ccmreplay_actiontransaction_idtarget_macoriginal_macitu_t_y_1731namesma_episequencefirst_tlv_offsetmdlevel_versionChassis component"Chassis component"Interface alias"Interface alias"Port component"Port component"MAC address"MAC address"Network address"Network address"Interface name"Interface name"Locally assigned"Locally assigned"cfm_tlv_senderid_chassisid_valuesTesting"Testing"Dormant"Dormant"not present"not present"lower Layer down"lower Layer down"cfm_tlv_interface_status_valuesBlocked"Blocked"cfm_tlv_port_status_valuesEnd"End"Sender ID"Sender ID"Port status"Port status"Interface status"Interface status"Reply Ingress"Reply Ingress"Reply Egress"Reply Egress"Organization Specific"Organization Specific"cfm_tlv_valuesExact Match"Exact Match"Filtering DB"Filtering DB"MIP CCM DB"MIP CCM DB"cfm_ltr_replay_action_valuesUseFDB Only"UseFDB Only"FwdYes"FwdYes"Terminal MEP"Terminal MEP"cfm_ltr_flag_valuesUse Forwarding-DB only"Use Forwarding-DB only"cfm_ltm_flag_valuesIEEE 802.1"IEEE 802.1"Primary VID"Primary VID"Character string"Character string"16Bit Integer"16Bit Integer"RFC2685 VPN-ID"RFC2685 VPN-ID"cfm_ma_nameformat_valuesCFM_CCM_MD_FORMAT_8021No MD Name present"No MD Name present"DNS string"DNS string"MAC + 16Bit Integer"MAC + 16Bit Integer"cfm_md_nameformat_values0.0033330000000000000250.0033330.0033330000010.010000000000000000210.010.0099999997760.10000000000000000560.10.10000000151.010.060.0600600.0ccm_interval_baseContinouity Check Message"Continouity Check Message"Loopback Reply"Loopback Reply"Loopback Message"Loopback Message"Linktrace Reply"Linktrace Reply"Linktrace Message"Linktrace Message"cfm_opcode_valuesCFM_EXTRACT_CCM_INTERVAL(x)(((x)&0x07))CFM_CCM_RDI_FLAGCCM_INTERVAL_MAX_MULTIPLIERCCM_INTERVAL_MIN_MULTIPLIERCFM_EXTRACT_MD_LEVEL(x)CFM_EXTRACT_VERSION(x)(((x)&0x1f))/* do we want to see an additional hexdump ? *//*
             * FIXME those are the defined TLVs that lack a decoder
             * you are welcome to contribute code ;-)
             *//*
                     * XXX - this is a TransportDomain; print it as such.
                     *//* IEEE 802.1Q-2014 Section 21.5.3.7: Management Address *//* Here mgmt_addr_length stands for the management address length. *//*
                 * IEEE 802.1Q-2014 Section 21.5.3.6: Management Address Length
                 * This field is present if Management Address Domain Length is not 0.
                 *//*
                 * XXX - this is an OID; print it as such.
                 *//* IEEE 802.1Q-2014 Section 21.5.3.5: Management Address Domain *//* Here mgmt_addr_length stands for the management domain length. *//* No, there isn't; we're done. *//*
             * Check if there is a Management Address.
             * IEEE 802.1Q-2014 Section 21.5.3.4: Management Address Domain Length
             * This and all subsequent fields are not present if the TLV length
             * allows only the above fields.
             *//* IEEE 802.1Q-2014 Section 21.5.3.3: Chassis ID *//*
                 * IEEE 802.1Q-2014 Section 21.5.3.2: Chassis ID Subtype, references
                 * IEEE 802.1AB-2005 Section 9.5.2.2, subsequently
                 * IEEE 802.1AB-2016 Section 8.5.2.2: chassis ID subtype
                 *//*
             * Get the Chassis ID length and check it.
             * IEEE 802.1Q-2014 Section 21.5.3.1
             *//* do we have the full tlv ? *//* do we have the full tlv header ? *//* Length is "Not present if the Type field is 0." *//* Enough to read the tlv type ? *//*
         * No message decoder yet.
         * Hexdump everything up until the start of the TLVs
         *//* FIXME add printers for those MA formats - hexdump for now *//* We know this is != 0 *//*
         * Resolve the MA fields.
         *//* FIXME add printers for those MD formats - hexdump for now *//*
             * -3 for the MA short name format and length and one byte
             * of MA short name.
             *//* We know this is !=0 *//*
         * Resolve the MD fields.
         *//*
         * Resolve the CCM interval field.
         *//*
     * Sanity check the first TLV offset.
     *//*
     * In non-verbose mode just print the opcode and md-level.
     *//*
     * Sanity checking of the header.
     *//*
     * Resolve the passed in Address.
     *//* The calling function must make any due ND_TCHECK calls. *//*
     * Altough AFIs are tpically 2 octects wide,
     * 802.1ab specifies that this field width
     * is only once octet
     *//* FIXME define TLV formats *//*
 * TLVs
 *//*
 * Timer Bases for the CCM Interval field.
 * Expressed in units of seconds.
 *//*
 * Message Formats.
 *//* \summary: IEEE 802.1ag Connectivity Fault Management (CFM) protocols printer *//Users/owura/Repos/codeql_eval/proj_repos/the-tcpdump-group-tcpdump-commit-9ba91381954ad325ea4fd26b9c65a8bd9a2a85b6/tcpdump/chdlc.hCHDLC_TYPE_CDPCHDLC_TYPE_SLARPCHDLC_BCASTCHDLC_UNICASTCHDLC_HDRLEN/Users/owura/Repos/codeql_eval/proj_repos/the-tcpdump-group-tcpdump-commit-9ba91381954ad325ea4fd26b9c65a8bd9a2a85b6/tcpdump/print-chdlc.c"chdlc.h"chdlc_slarp_printconst cisco_slarpconst cisco_slarp *cisco_slarp *slarpsecminhrsdays(ndo, "SLARP (length: %u), ",length)SLARP (length: %u), SLARP_MIN_LEN*slarp&slarp->code(ndo, "request")(ndo, "reply %s/%s", ipaddr_string(ndo, &slarp->un.addr.addr), ipaddr_string(ndo, &slarp->un.addr.mask))(ndo, "reply %s/%s", getname(ndo, (const u_char *)(&slarp->un.addr.addr)), getname(ndo, (const u_char *)(&slarp->un.addr.mask)))&slarp->un.addr.addr&slarp->un.addr.mask(ndo, "keepalive: mineseen=0x%08x, yourseen=0x%08x, reliability=0x%04x", EXTRACT_32BITS(&slarp->un.keep.myseq), EXTRACT_32BITS(&slarp->un.keep.yourseq), EXTRACT_16BITS(&slarp->un.keep.rel))(ndo, "keepalive: mineseen=0x%08x, yourseen=0x%08x, reliability=0x%04x", ((uint32_t)(((uint32_t)(*((const uint8_t *)(&slarp->un.keep.myseq) + 0)) << 24) | ((uint32_t)(*((const uint8_t *)(&slarp->un.keep.myseq) + 1)) << 16) | ((uint32_t)(*((const uint8_t *)(&slarp->un.keep.myseq) + 2)) << 8) | ((uint32_t)(*((const uint8_t *)(&slarp->un.keep.myseq) + 3)) << 0))), ((uint32_t)(((uint32_t)(*((const uint8_t *)(&slarp->un.keep.yourseq) + 0)) << 24) | ((uint32_t)(*((const uint8_t *)(&slarp->un.keep.yourseq) + 1)) << 16) | ((uint32_t)(*((const uint8_t *)(&slarp->un.keep.yourseq) + 2)) << 8) | ((uint32_t)(*((const uint8_t *)(&slarp->un.keep.yourseq) + 3)) << 0))), ((uint16_t)(((uint16_t)(*((const uint8_t *)(&slarp->un.keep.rel) + 0)) << 8) | ((uint16_t)(*((const uint8_t *)(&slarp->un.keep.rel) + 1)) << 0))))&slarp->un.keep.myseq&slarp->un.keep.yourseq&slarp->un.keep.rel(ndo, ", link uptime=%ud%uh%um%us",days,hrs,min,sec)(ndo, "0x%02x unknown", EXTRACT_32BITS(&slarp->code))(ndo, "0x%02x unknown", ((uint32_t)(((uint32_t)(*((const uint8_t *)(&slarp->code) + 0)) << 24) | ((uint32_t)(*((const uint8_t *)(&slarp->code) + 1)) << 16) | ((uint32_t)(*((const uint8_t *)(&slarp->code) + 2)) << 8) | ((uint32_t)(*((const uint8_t *)(&slarp->code) + 3)) << 0))))SLARP_REQUESTrequestSLARP_REPLYreply %s/%sSLARP_KEEPALIVEkeepalive: mineseen=0x%08x, yourseen=0x%08x, reliability=0x%04xchar[64]SLARP_MAX_LEN, link uptime=%ud%uh%um%us0x%02x unknown(ndo, ", (trailing junk: %d bytes)", length - SLARP_MAX_LEN)(ndo, ", (trailing junk: %d bytes)", length - 18), (trailing junk: %d bytes)(ndo, "[|slarp]")[|slarp]chdlc_printproto(ndo, "%s, ethertype %s (0x%04x), length %u: ", tok2str(chdlc_cast_values, "0x%02x", p[0]), tok2str(ethertype_values, "Unknown", proto), proto, length)%s, ethertype %s (0x%04x), length %u: *(p)(ndo, "unknown CHDLC protocol (0x%04x)", proto)348873488865278unknown CHDLC protocol (0x%04x)(CHDLC_HDRLEN)(ndo, "[|chdlc]")[|chdlc]chdlc_if_printcisco_slarpuncodekeeprelyourseqmysequnicast"unicast"bcast"bcast"chdlc_cast_values/* uptime-stamp is optional *//*
		 * At least according to William "Chops" Westfield's
		 * message in
		 *
		 *	http://www.nethelp.no/net/cisco-hdlc.txt
		 *
		 * the address and mask aren't used in requests -
		 * they're just zero.
		 *//*
 * The fixed-length portion of a SLARP packet.
 *//* is the fudge byte set ? lets verify by spotting ISO headers *//* Standard CHDLC printer *//* \summary: Cisco HDLC printer *//Users/owura/Repos/codeql_eval/proj_repos/the-tcpdump-group-tcpdump-commit-9ba91381954ad325ea4fd26b9c65a8bd9a2a85b6/tcpdump/print-cip.ccip_if_printcmplenconst unsigned char[6]sizeof(rfcllc)(ndo, "[|cip]")[|cip]cip_print(ndo, "%u: ", length)%u: rfcllc/*
		 * LLC header is absent; treat it as just IP.
		 *//* packet type not known, print raw packet *//*
		 * LLC header is present.  Try to print it & higher layers.
		 *//*
 * This is the top level routine of the printer.  'p' points
 * to the LLC/SNAP or raw header of the packet, 'h->ts' is the timestamp,
 * 'h->len' is the length of the packet off the wire, and 'h->caplen'
 * is the number of bytes actually captured.
 *//*
	 * There is no MAC-layer header, so just print the length.
	 *//* OUI: EtherType *//* Ctrl: Unnumbered Information Command PDU *//* SSAP: non-ISO *//* DSAP: non-ISO *//* \summary: Classical-IP over ATM printer *//*
 * Marko Kiiskila carnil@cs.tut.fi
 *
 * Tampere University of Technology - Telecommunications Laboratory
 *
 * Permission to use, copy, modify and distribute this
 * software and its documentation is hereby granted,
 * provided that both the copyright notice and this
 * permission notice appear in all copies of the software,
 * derivative works or modified versions, and any portions
 * thereof, that both notices appear in supporting
 * documentation, and that the use of this software is
 * acknowledged in any publications resulting from using
 * the software.
 *
 * TUT ALLOWS FREE USE OF THIS SOFTWARE IN ITS "AS IS"
 * CONDITION AND DISCLAIMS ANY LIABILITY OF ANY KIND FOR
 * ANY DAMAGES WHATSOEVER RESULTING FROM THE USE OF THIS
 * SOFTWARE.
 *
 *//Users/owura/Repos/codeql_eval/proj_repos/the-tcpdump-group-tcpdump-commit-9ba91381954ad325ea4fd26b9c65a8bd9a2a85b6/tcpdump/tcp.htcphdrtcp_seqth_urpth_sumth_winth_flagsth_offx2th_ackth_seqth_dportth_sportREDIS_PORT6379BEEP_PORT10288RTSP_PORT_ALT8554HTTP_PORT_ALT8080OPENFLOW_PORT_IANA6653OPENFLOW_PORT_OLD6633NFS_PORTPPTP_PORT1723MSDP_PORT639RTSP_PORT554SMB_PORTRPKI_RTR_PORT323HTTP_PORTSMTP_PORTTELNET_PORTSSH_PORTFTP_PORTTCPOPT_TSTAMP_HDR(TCPOPT_NOP<<24|TCPOPT_NOP<<16|TCPOPT_TIMESTAMP<<8|TCPOLEN_TIMESTAMP)TCPOPT_EXPERIMENT2TCPOPT_FASTOPENTCPOPT_MPTCPTCPOPT_TCPAOTCPOLEN_UTOTCPOPT_UTOTCPOPT_SCPSTCP_SIGLENTCPOLEN_SIGNATURETCPOPT_SIGNATURETCPOPT_CCECHOTCPOPT_CCNEWTCPOPT_CCTCPOLEN_TSTAMP_APPA(TCPOLEN_TIMESTAMP+2)TCPOLEN_TIMESTAMPTCPOPT_TIMESTAMPTCPOPT_ECHOREPLYTCPOPT_ECHOTCPOPT_SACKTCPOPT_SACKOKTCPOPT_WSCALETCPOLEN_MAXSEGTCPOPT_MAXSEGTCPOPT_NOPTCPOPT_EOLTH_CWRTH_ECNECHOTH_URGTH_ACKTH_PUSHTH_RSTTH_SYNTH_FINTH_OFF(th)(((th)->th_offx2 & 0xf0) >> 4)/* experimental headers (rfc4727) *//* TCP Fast Open (rfc7413) *//* MPTCP options *//* TCP authentication option (rfc5925) *//* tcp user timeout (rfc5482) *//* SCPS-TP (CCSDS 714.0-B-2) *//* length of an option 19 digest *//* Keyed MD5 (rfc2385) *//* T/TCP CC options (rfc1644) *//* appendix A *//* timestamp (rfc1323) *//* echo (rfc1072) *//* selective ack (rfc2018) *//* selective ack ok (rfc2018) *//* window scale factor (rfc1323) *//* ECN Cwnd Reduced *//* ECN Echo *//* TCP flags *//* urgent pointer *//* checksum *//* window *//* data offset, rsvd *//* acknowledgement number *//*
 * TCP header.
 * Per RFC 793, September, 1981.
 *//*
 * Copyright (c) 1982, 1986, 1993
 *	The Regents of the University of California.  All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *	This product includes software developed by the University of
 *	California, Berkeley and its contributors.
 * 4. Neither the name of the University nor the names of its contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 *
 *	@(#)tcp.h	8.1 (Berkeley) 6/10/93
 *//Users/owura/Repos/codeql_eval/proj_repos/the-tcpdump-group-tcpdump-commit-9ba91381954ad325ea4fd26b9c65a8bd9a2a85b6/tcpdump/print-cnfp.c"tcp.h"cnfp_print(ndo, "NetFlow v%x", ver)NetFlow v%x(ndo, "[|cnfp]")[|cnfp]cnfp_v6_printconst nfhdr_v6const nfhdr_v6 *nfhdr_v6 *const nfrec_v6const nfrec_v6 *nfrec_v6 *nrnrecs*nhsizeof(*nh)&nh->version&nh->count(ndo, "NetFlow v%x, %u.%03u uptime, %u.%09u, ", ver, EXTRACT_32BITS(&nh->msys_uptime)/1000, EXTRACT_32BITS(&nh->msys_uptime)%1000, EXTRACT_32BITS(&nh->utc_sec), EXTRACT_32BITS(&nh->utc_nsec))(ndo, "NetFlow v%x, %u.%03u uptime, %u.%09u, ", ver, ((uint32_t)(((uint32_t)(*((const uint8_t *)(&nh->msys_uptime) + 0)) << 24) | ((uint32_t)(*((const uint8_t *)(&nh->msys_uptime) + 1)) << 16) | ((uint32_t)(*((const uint8_t *)(&nh->msys_uptime) + 2)) << 8) | ((uint32_t)(*((const uint8_t *)(&nh->msys_uptime) + 3)) << 0)))/1000, ((uint32_t)(((uint32_t)(*((const uint8_t *)(&nh->msys_uptime) + 0)) << 24) | ((uint32_t)(*((const uint8_t *)(&nh->msys_uptime) + 1)) << 16) | ((uint32_t)(*((const uint8_t *)(&nh->msys_uptime) + 2)) << 8) | ((uint32_t)(*((const uint8_t *)(&nh->msys_uptime) + 3)) << 0)))%1000, ((uint32_t)(((uint32_t)(*((const uint8_t *)(&nh->utc_sec) + 0)) << 24) | ((uint32_t)(*((const uint8_t *)(&nh->utc_sec) + 1)) << 16) | ((uint32_t)(*((const uint8_t *)(&nh->utc_sec) + 2)) << 8) | ((uint32_t)(*((const uint8_t *)(&nh->utc_sec) + 3)) << 0))), ((uint32_t)(((uint32_t)(*((const uint8_t *)(&nh->utc_nsec) + 0)) << 24) | ((uint32_t)(*((const uint8_t *)(&nh->utc_nsec) + 1)) << 16) | ((uint32_t)(*((const uint8_t *)(&nh->utc_nsec) + 2)) << 8) | ((uint32_t)(*((const uint8_t *)(&nh->utc_nsec) + 3)) << 0))))NetFlow v%x, %u.%03u uptime, %u.%09u, &nh->msys_uptime&nh->utc_sec&nh->utc_nsec(ndo, "#%u, ", EXTRACT_32BITS(&nh->sequence))(ndo, "#%u, ", ((uint32_t)(((uint32_t)(*((const uint8_t *)(&nh->sequence) + 0)) << 24) | ((uint32_t)(*((const uint8_t *)(&nh->sequence) + 1)) << 16) | ((uint32_t)(*((const uint8_t *)(&nh->sequence) + 2)) << 8) | ((uint32_t)(*((const uint8_t *)(&nh->sequence) + 3)) << 0))))#%u, &nh->sequence(ndo, "%2u recs", nrecs)%2u recs*nrsizeof(*nr)(ndo, "\n  started %u.%03u, last %u.%03u", EXTRACT_32BITS(&nr->start_time)/1000, EXTRACT_32BITS(&nr->start_time)%1000, EXTRACT_32BITS(&nr->last_time)/1000, EXTRACT_32BITS(&nr->last_time)%1000)(ndo, "\n  started %u.%03u, last %u.%03u", ((uint32_t)(((uint32_t)(*((const uint8_t *)(&nr->start_time) + 0)) << 24) | ((uint32_t)(*((const uint8_t *)(&nr->start_time) + 1)) << 16) | ((uint32_t)(*((const uint8_t *)(&nr->start_time) + 2)) << 8) | ((uint32_t)(*((const uint8_t *)(&nr->start_time) + 3)) << 0)))/1000, ((uint32_t)(((uint32_t)(*((const uint8_t *)(&nr->start_time) + 0)) << 24) | ((uint32_t)(*((const uint8_t *)(&nr->start_time) + 1)) << 16) | ((uint32_t)(*((const uint8_t *)(&nr->start_time) + 2)) << 8) | ((uint32_t)(*((const uint8_t *)(&nr->start_time) + 3)) << 0)))%1000, ((uint32_t)(((uint32_t)(*((const uint8_t *)(&nr->last_time) + 0)) << 24) | ((uint32_t)(*((const uint8_t *)(&nr->last_time) + 1)) << 16) | ((uint32_t)(*((const uint8_t *)(&nr->last_time) + 2)) << 8) | ((uint32_t)(*((const uint8_t *)(&nr->last_time) + 3)) << 0)))/1000, ((uint32_t)(((uint32_t)(*((const uint8_t *)(&nr->last_time) + 0)) << 24) | ((uint32_t)(*((const uint8_t *)(&nr->last_time) + 1)) << 16) | ((uint32_t)(*((const uint8_t *)(&nr->last_time) + 2)) << 8) | ((uint32_t)(*((const uint8_t *)(&nr->last_time) + 3)) << 0)))%1000)&nr->start_time&nr->last_time"/%u", nr->src_mask":%u", EXTRACT_16BITS(&nr->src_as)":%u", ((uint16_t)(((uint16_t)(*((const uint8_t *)(&nr->src_as) + 0)) << 8) | ((uint16_t)(*((const uint8_t *)(&nr->src_as) + 1)) << 0)))&nr->src_as(ndo, "\n    %s%s%s:%u ", intoa(nr->src_ina.s_addr), buf, asbuf, EXTRACT_16BITS(&nr->srcport))(ndo, "\n    %s%s%s:%u ", intoa(nr->src_ina.s_addr), buf, asbuf, ((uint16_t)(((uint16_t)(*((const uint8_t *)(&nr->srcport) + 0)) << 8) | ((uint16_t)(*((const uint8_t *)(&nr->srcport) + 1)) << 0))))&nr->srcport"/%d", nr->dst_mask":%u", EXTRACT_16BITS(&nr->dst_as)":%u", ((uint16_t)(((uint16_t)(*((const uint8_t *)(&nr->dst_as) + 0)) << 8) | ((uint16_t)(*((const uint8_t *)(&nr->dst_as) + 1)) << 0)))&nr->dst_as(ndo, "> %s%s%s:%u ", intoa(nr->dst_ina.s_addr), buf, asbuf, EXTRACT_16BITS(&nr->dstport))(ndo, "> %s%s%s:%u ", intoa(nr->dst_ina.s_addr), buf, asbuf, ((uint16_t)(((uint16_t)(*((const uint8_t *)(&nr->dstport) + 0)) << 8) | ((uint16_t)(*((const uint8_t *)(&nr->dstport) + 1)) << 0))))&nr->dstport(ndo, ">> %s\n    ", intoa(nr->nhop_ina.s_addr))(ndo, "%s ", p_name)(ndo, "%u ", nr->proto)(ndo, "%s%s%s%s%s%s%s", flags & TH_FIN ? "F" : "", flags & TH_SYN ? "S" : "", flags & TH_RST ? "R" : "", flags & TH_PUSH ? "P" : "", flags & TH_ACK ? "A" : "", flags & TH_URG ? "U" : "", flags ? " " : "")(ndo, "%s%s%s%s%s%s%s", flags & 0x01 ? "F" : "", flags & 0x02 ? "S" : "", flags & 0x04 ? "R" : "", flags & 0x08 ? "P" : "", flags & 0x10 ? "A" : "", flags & 0x20 ? "U" : "", flags ? " " : "")"(%u<>%u encaps)", (EXTRACT_16BITS(&nr->flags) >> 8) & 0xff, (EXTRACT_16BITS(&nr->flags)) & 0xff"(%u<>%u encaps)", (((uint16_t)(((uint16_t)(*((const uint8_t *)(&nr->flags) + 0)) << 8) | ((uint16_t)(*((const uint8_t *)(&nr->flags) + 1)) << 0))) >> 8) & 0xff, (((uint16_t)(((uint16_t)(*((const uint8_t *)(&nr->flags) + 0)) << 8) | ((uint16_t)(*((const uint8_t *)(&nr->flags) + 1)) << 0)))) & 0xff&nr->flags(ndo, "tos %u, %u (%u octets) %s", nr->tos, EXTRACT_32BITS(&nr->packets), EXTRACT_32BITS(&nr->octets), buf)(ndo, "tos %u, %u (%u octets) %s", nr->tos, ((uint32_t)(((uint32_t)(*((const uint8_t *)(&nr->packets) + 0)) << 24) | ((uint32_t)(*((const uint8_t *)(&nr->packets) + 1)) << 16) | ((uint32_t)(*((const uint8_t *)(&nr->packets) + 2)) << 8) | ((uint32_t)(*((const uint8_t *)(&nr->packets) + 3)) << 0))), ((uint32_t)(((uint32_t)(*((const uint8_t *)(&nr->octets) + 0)) << 24) | ((uint32_t)(*((const uint8_t *)(&nr->octets) + 1)) << 16) | ((uint32_t)(*((const uint8_t *)(&nr->octets) + 2)) << 8) | ((uint32_t)(*((const uint8_t *)(&nr->octets) + 3)) << 0))), buf)&nr->packets&nr->octets
  started %u.%03u, last %u.%03u/%u:%u
    %s%s%s:%u > %s%s%s:%u >> %s
    %u %s%s%s%s%s%s%sFSAU(%u<>%u encaps)tos %u, %u (%u octets) %scnfp_v5_printconst nfhdr_v5const nfhdr_v5 *nfhdr_v5 *const nfrec_v5const nfrec_v5 *nfrec_v5 *cnfp_v1_printconst nfhdr_v1const nfhdr_v1 *nfhdr_v1 *const nfrec_v1const nfrec_v1 *nfrec_v1 *nfrec_v6nfhdr_v6nfrec_v5nfhdr_v5nfrec_v1nfhdr_v1peer_nexthopdst_masksrc_maskdst_assrc_astostcp_flagspad1dstportsrcportlast_timestart_timeoctetspacketsoutputinputnhop_inadst_inasrc_inautc_nsecutc_secmsys_uptimepad2sampling_intervalengine_idengine_type/*
	 * First 2 bytes are the version number.
	 *//* tcp flags for tcp only *//*
		 * Make sure we have the entire record.
		 *//*
	 * This is seconds since the UN*X epoch, and is followed by
	 * nanoseconds.  XXX - format it, rather than just dumping the
	 * raw seconds-since-the-Epoch.
	 *//* v6: IP address of the nexthop within the peer (FIB)*//* destination address prefix mask bits *//* source address mask bits *//* AS number of the destination *//* AS number of the source *//* IP type of service *//* IP protocol type *//* cumulative OR of TCP flags *//* pad *//* TCP/UDP source port or equivalent *//* sys_uptime value when last packet of flow was received *//* sys_uptime value at start of flow *//* layer 3 octets in the packets of the flow *//* packets in the flow *//* SNMP index of output interface *//* SNMP index of input interface *//* v5 only *//* v5 flow sequence number *//* # of records *//* version number *//* sampling mode and interval *//* slot number of the flow-switching engine *//* type of flow-switching engine *//* flow sequence number *//* unused *//* padding *//*
 * Cisco NetFlow protocol
 *
 * See
 *
 *    http://www.cisco.com/c/en/us/td/docs/net_mgmt/netflow_collection_engine/3-6/user/guide/format.html#wp1005892
 *//* \summary: Cisco NetFlow protocol printer *//*
 * Copyright (c) 1998 Michael Shalayeff
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *	This product includes software developed by Michael Shalayeff.
 * 4. The name of the author may not be used to endorse or promote products
 *    derived from this software without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
 * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
 * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
 * IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
 * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
 * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
 * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
 * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
 * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 *//*	$OpenBSD: print-cnfp.c,v 1.2 1998/06/25 20:26:59 mickey Exp $	*//Users/owura/Repos/codeql_eval/proj_repos/the-tcpdump-group-tcpdump-commit-9ba91381954ad325ea4fd26b9c65a8bd9a2a85b6/tcpdump/print-dccp.c"ip6.h""ip.h"dccp_print_optionoptlen*optionsizeof(*option)*(option+1)sizeof(*(option+1))(ndo, "CCID option %u optlen too short", *option)(ndo, "%s optlen too short", tok2str(dccp_option_values, "Option %u", *option))CCID option %u optlen too short%s optlen too shortconst tok[17]tok[17]Option %u(ndo, "CCID option %u optlen goes past header length", *option)(ndo, "%s optlen goes past header length", tok2str(dccp_option_values, "Option %u", *option))CCID option %u optlen goes past header length%s optlen goes past header length(ndo, "CCID option %d", *option)(ndo, " %u", EXTRACT_16BITS(option + 2))(ndo, " %u", ((uint16_t)(((uint16_t)(*((const uint8_t *)(option + 2) + 0)) << 8) | ((uint16_t)(*((const uint8_t *)(option + 2) + 1)) << 0))))option + 2(ndo, " %u", EXTRACT_32BITS(option + 2))(ndo, " %u", ((uint32_t)(((uint32_t)(*((const uint8_t *)(option + 2) + 0)) << 24) | ((uint32_t)(*((const uint8_t *)(option + 2) + 1)) << 16) | ((uint32_t)(*((const uint8_t *)(option + 2) + 2)) << 8) | ((uint32_t)(*((const uint8_t *)(option + 2) + 3)) << 0))))(ndo, "%s", tok2str(dccp_option_values, "Option %u", *option))(ndo, " optlen too short")(ndo, " %s", dccp_feature_nums[*(option + 2)])(ndo, " %d", *(option + 3 + i))(ndo, " 0x")(ndo, "%02x", *(option + 2 + i))(ndo, " %d", *(option + 2 + i))(ndo, " optlen != 4")(ndo, " optlen != 4 or 6")CCID option %d %u optlen too shortconst char *[10]char *[10] 0xoption optlen != 4 optlen != 4 or 6dccp_printconst dccp_hdrconst dccp_hdr *dccp_hdr *dhconst ipconst ip *ip *const ip6_hdrconst ip6_hdr *ip6_hdr *sportdportfixed_hdrlendccph_type(ndo, "[Invalid packet|dccp]")[Invalid packet|dccp](ndo, "truncated-dccp - %u bytes missing!", len - (u_int)sizeof(struct dccp_hdr))sizeof(struct dccp_hdr)truncated-dccp - %u bytes missing!(ndo, "truncated-dccp - %u bytes missing!", len - fixed_hdrlen)*dh&dh->dccph_sport&dh->dccph_dport(ndo, "%s.%d > %s.%d: ", ip6addr_string(ndo, &ip6->ip6_src), sport, ip6addr_string(ndo, &ip6->ip6_dst), dport)(ndo, "%s.%d > %s.%d: ", getname6(ndo, (const u_char *)(&ip6->ip6_src)), sport, getname6(ndo, (const u_char *)(&ip6->ip6_dst)), dport)&ip6->ip6_src&ip6->ip6_dst(ndo, "%s.%d > %s.%d: ", ipaddr_string(ndo, &ip->ip_src), sport, ipaddr_string(ndo, &ip->ip_dst), dport)(ndo, "%s.%d > %s.%d: ", getname(ndo, (const u_char *)(&ip->ip_src)), sport, getname(ndo, (const u_char *)(&ip->ip_dst)), dport)&ip->ip_src&ip->ip_dst%s.%d > %s.%d: const nd_ipv4const nd_ipv4 *(ndo, "DCCP")(ndo, " %d", len - hlen)(ndo, " [bad hdr length %u - too long, > %u]", hlen, len)data2 [bad hdr length %u - too long, > %u](ndo, " (CCVal %d, CsCov %d, ", DCCPH_CCVAL(dh), DCCPH_CSCOV(dh))(ndo, " (CCVal %d, CsCov %d, ", (((dh)->dccph_ccval_cscov >> 4) & 0xF), (((dh)->dccph_ccval_cscov) & 0xF)) (CCVal %d, CsCov %d, &dh->dccph_checksum(ndo, "cksum 0x%04x ", dccp_sum)(ndo, "(incorrect -> 0x%04x)",in_cksum_shouldbe(dccp_sum, sum))(ndo, "(correct)")dccp_sumcksum 0x%04x (incorrect -> 0x%04x)(correct)(ndo, "truncated-%s - %u bytes missing!", tok2str(dccp_pkt_type_str, "", dccph_type), len - fixed_hdrlen)*dhrsizeof(*dhr)(ndo, "%s (service=%d) ", tok2str(dccp_pkt_type_str, "", dccph_type), EXTRACT_32BITS(&dhr->dccph_req_service))(ndo, "%s (service=%d) ", tok2str(dccp_pkt_type_str, "", dccph_type), ((uint32_t)(((uint32_t)(*((const uint8_t *)(&dhr->dccph_req_service) + 0)) << 24) | ((uint32_t)(*((const uint8_t *)(&dhr->dccph_req_service) + 1)) << 16) | ((uint32_t)(*((const uint8_t *)(&dhr->dccph_req_service) + 2)) << 8) | ((uint32_t)(*((const uint8_t *)(&dhr->dccph_req_service) + 3)) << 0))))&dhr->dccph_req_service(ndo, "%s (service=%d) ", tok2str(dccp_pkt_type_str, "", dccph_type), EXTRACT_32BITS(&dhr->dccph_resp_service))(ndo, "%s (service=%d) ", tok2str(dccp_pkt_type_str, "", dccph_type), ((uint32_t)(((uint32_t)(*((const uint8_t *)(&dhr->dccph_resp_service) + 0)) << 24) | ((uint32_t)(*((const uint8_t *)(&dhr->dccph_resp_service) + 1)) << 16) | ((uint32_t)(*((const uint8_t *)(&dhr->dccph_resp_service) + 2)) << 8) | ((uint32_t)(*((const uint8_t *)(&dhr->dccph_resp_service) + 3)) << 0))))&dhr->dccph_resp_service(ndo, "%s ", tok2str(dccp_pkt_type_str, "", dccph_type))(ndo, "%s (code=%s) ", tok2str(dccp_pkt_type_str, "", dccph_type), dccp_reset_code(dhr->dccph_reset_code))(ndo, "%s ", tok2str(dccp_pkt_type_str, "unknown-type-%u", dccph_type))DCCP_PKT_REQUESTconst dccp_hdr_requestconst dccp_hdr_request *dccp_hdr_request *dhrtruncated-%s - %u bytes missing!%s (service=%d) DCCP_PKT_RESPONSEconst dccp_hdr_responseconst dccp_hdr_response *dccp_hdr_response *DCCP_PKT_DATADCCP_PKT_ACKDCCP_PKT_DATAACKDCCP_PKT_CLOSEREQDCCP_PKT_CLOSEDCCP_PKT_RESETconst dccp_hdr_resetconst dccp_hdr_reset *dccp_hdr_reset *%s (code=%s) DCCP_PKT_SYNCDCCP_PKT_SYNCACKunknown-type-%u(ndo, "seq %" PRIu64, dccp_seqno(bp))(ndo, "seq %" "ll" "u", dccp_seqno(bp))seq %llu(ndo, " <") <dccp_print_ack_noackpackno*ackpackp + 2ackp + 1(ndo, "(ack=%" PRIu64 ") ", ackno)(ndo, "(ack=%" "ll" "u" ") ", ackno)(ack=%llu) dccp_basic_hdr_lensizeof(struct dccp_hdr_ext)dccp_seqnodhx->dccph_seqdh->dccph_seqconst dccp_hdr_extconst dccp_hdr_ext *dccp_hdr_ext *dhxdccp_reset_code__DCCP_RESET_CODE_LAST"invalid"const char *[12]char *[12]dccp6_cksumdccp_cksumdccp_csum_coveragecovdccp_reset_codesDCCP_RESET_CODE_UNSPECIFIEDDCCP_RESET_CODE_CLOSEDDCCP_RESET_CODE_ABORTEDDCCP_RESET_CODE_NO_CONNECTIONDCCP_RESET_CODE_PACKET_ERRORDCCP_RESET_CODE_OPTION_ERRORDCCP_RESET_CODE_MANDATORY_ERRORDCCP_RESET_CODE_CONNECTION_REFUSEDDCCP_RESET_CODE_BAD_SERVICE_CODEDCCP_RESET_CODE_TOO_BUSYDCCP_RESET_CODE_BAD_INIT_COOKIEDCCP_RESET_CODE_AGGRESSION_PENALTYdccp_pkt_typedccp_hdr_resetdccp_hdr_responsedccp_hdr_requestdccp_hdr_extdccp_hdrdccph_reset_datadccph_reset_codedccph_reset_ackdccph_resp_servicedccph_resp_ackdccph_req_servicedccph_seqdccph_xtrdccph_checksumdccph_ccval_cscovdccph_doffdccph_dportdccph_sportnop"nop"mandatory"mandatory"slowreceiver"slowreceiver"change_l"change_l"confirm_l"confirm_l"change_r"change_r"confirm_r"confirm_r"initcookie"initcookie"ndp_count"ndp_count"ack_vector0"ack_vector0"ack_vector1"ack_vector1"data_dropped"data_dropped""timestamp"timestamp_echo"timestamp_echo"elapsed_time"elapsed_time"data_checksum"data_checksum"dccp_option_valuesccid"ccid"allow_short_seqno"allow_short_seqno"sequence_window"sequence_window"ecn_incapable"ecn_incapable"ack_ratio"ack_ratio"send_ack_vector"send_ack_vector"send_ndp_count"send_ndp_count"minimum checksum coverage"minimum checksum coverage"check data checksum"check data checksum"dccp_feature_numsunspecified"unspecified"closed"closed"aborted"aborted"no_connection"no_connection"packet_error"packet_error"option_error"option_error"mandatory_error"mandatory_error"connection_refused"connection_refused"bad_service_code"bad_service_code"too_busy"too_busy"bad_init_cookie"bad_init_cookie"aggression_penalty"aggression_penalty"[|dccp]"[|dccp]"DCCP-Request"DCCP-Request"DCCP-Response"DCCP-Response"DCCP-Data"DCCP-Data"DCCP-Ack"DCCP-Ack"DCCP-DataAck"DCCP-DataAck"DCCP-CloseReq"DCCP-CloseReq"DCCP-Close"DCCP-Close"DCCP-Reset"DCCP-Reset"DCCP-Sync"DCCP-Sync"DCCP-SyncAck"DCCP-SyncAck"dccp_pkt_type_strDCCPH_TYPE(dh)(((dh)->dccph_xtr >> 1) & 0xF)DCCPH_X(dh)((dh)->dccph_xtr & 1)DCCPH_CSCOV(dh)(((dh)->dccph_ccval_cscov) & 0xF)DCCPH_CCVAL(dh)(((dh)->dccph_ccval_cscov >> 4) & 0xF)/* process options *//* checksum calculation *//* other variables in generic header *//* get the length of the generic header *//* make sure we have enough data to look at the X bit *//**
 * dccp_print - show dccp packet
 * @bp - beginning of dccp packet
 * @data2 - beginning of enclosing
 * @len - lenght of ip packet
 *//* always 8 bytes *//**
 * struct dccp_hdr_reset - Unconditionally shut down a connection
 *
 * @dccph_resp_ack - 48 bit ack number
 * @dccph_reset_service - Echoes the Service Code on a received DCCP-Request
 *//**
 * struct dccp_hdr_response - Conection initiation response header
 *
 * @dccph_resp_ack - 48 bit ack number, contains GSR
 * @dccph_resp_service - Echoes the Service Code on a received DCCP-Request
 *//**
 * struct dccp_hdr_request - Conection initiation request header
 *
 * @dccph_req_service - Service to which the client app wants to connect
 *//**
 * struct dccp_hdr_ext - generic part of DCCP packet header, with a 48-bit
 * sequence number
 *
 * @dccph_sport - Relevant port on the endpoint that sent this packet
 * @dccph_dport - Relevant port on the other endpoint
 * @dccph_doff - Data Offset from the start of the DCCP header, in 32-bit words
 * @dccph_ccval - Used by the HC-Sender CCID
 * @dccph_cscov - Parts of the packet that are covered by the Checksum field
 * @dccph_checksum - Internet checksum, depends on dccph_cscov
 * @dccph_x - 0 = 24 bit sequence number, 1 = 48
 * @dccph_type - packet type, see DCCP_PKT_ prefixed macros
 * @dccph_seq - 48-bit sequence number
 *//**
 * struct dccp_hdr - generic part of DCCP packet header, with a 24-bit
 * sequence number
 *
 * @dccph_sport - Relevant port on the endpoint that sent this packet
 * @dccph_dport - Relevant port on the other endpoint
 * @dccph_doff - Data Offset from the start of the DCCP header, in 32-bit words
 * @dccph_ccval - Used by the HC-Sender CCID
 * @dccph_cscov - Parts of the packet that are covered by the Checksum field
 * @dccph_checksum - Internet checksum, depends on dccph_cscov
 * @dccph_x - 0 = 24 bit sequence number, 1 = 48
 * @dccph_type - packet type, see DCCP_PKT_ prefixed macros
 * @dccph_seq - 24-bit sequence number
 *//* RFC4340: Datagram Congestion Control Protocol (DCCP) *//* \summary: Datagram Congestion Control Protocol (DCCP) printer *//*
 * Copyright (C) Arnaldo Carvalho de Melo 2004
 * Copyright (C) Ian McDonald 2005
 * Copyright (C) Yoshifumi Nishida 2005
 *
 * This software may be distributed either under the terms of the
 * BSD-style license that accompanies tcpdump or the GNU GPL version 2
 *//Users/owura/Repos/codeql_eval/proj_repos/the-tcpdump-group-tcpdump-commit-9ba91381954ad325ea4fd26b9c65a8bd9a2a85b6/tcpdump/print-decnet.cdnname_stringdnnum_stringsizarea64512AREAMASKAREASHIFTNODEMASK00.0000"00.0000""00.0000")sizeof("00.0000")dnnum_string: malloc"dnnum_string: malloc""%d.%d", area, nodeprint_reason(ndo, "%s ", tok2str(reason2str, "reason-%d", reason))const tok[23]tok[23]reason-%dprint_nspconst nsphdrconst nsphdr *nsphdr *nsphpsizeof(struct nsphdr)*nsphpsizeof(*nsphp)nsphp->nh_flagsnsphp->nh_dstnsphp->nh_src(ndo, "data %d>%d ", src, dst)shp->sh_seq[0]sizeof(shp->sh_seq[0])(ndo, "nak %d ", ack & SGQ_MASK)(ndo, "nak %d ", ack & 07777)(ndo, "ack %d ", ack & SGQ_MASK)(ndo, "ack %d ", ack & 07777)shp->sh_seq[1]sizeof(shp->sh_seq[1])(ndo, "onak %d ", ack & SGQ_MASK)(ndo, "onak %d ", ack & 07777)(ndo, "oack %d ", ack & SGQ_MASK)(ndo, "oack %d ", ack & 07777)shp->sh_seq[2]sizeof(shp->sh_seq[2])(ndo, "seg %d ", ack & SGQ_MASK)(ndo, "seg %d ", ack & 07777)(ndo, "intr ")(ndo, "nakdat %d ", ack & SGQ_MASK)(ndo, "nakdat %d ", ack & 07777)(ndo, "ackdat %d ", ack & SGQ_MASK)(ndo, "ackdat %d ", ack & 07777)(ndo, "link-service %d>%d ", src, dst)*lsmpsizeof(*lsmp)lsmp->ls_lsflagslsmp->ls_fcval(ndo, "dat seg count %d ", fcval)(ndo, "donotsend-data ")(ndo, "send-data ")(ndo, "reserved-fcmod? %x", lsflags)(ndo, "intr req count %d ", fcval)(ndo, "reserved-fcval-int? %x", lsflags)(ndo, "reserved-subtype? %x %d > %d", flags, src, dst)(ndo, "data-ack %d>%d ", src, dst)*ampsizeof(*amp)amp->ak_acknum[0]amp->ak_acknum[1](ndo, "ils-ack %d>%d ", src, dst)sizeof(amp->ak_acknum[1])(ndo, "conn-ack %d", dst)(ndo, "reserved-acktype? %x %d > %d", flags, src, dst)(ndo, "conn-initiate ")(ndo, "retrans-conn-initiate ")(ndo, "%d>%d ", src, dst)*cimpsizeof(*cimp)cimp->ci_servicescimp->ci_infocimp->ci_segsize(ndo, "seg ")(ndo, "msg ")(ndo, "ver 3.2 ")(ndo, "ver 3.1 ")(ndo, "ver 4.0 ")(ndo, "ver 4.1 ")(ndo, "segsize %d ", segsize)(ndo, "conn-confirm %d>%d ", src, dst)*ccmpsizeof(*ccmp)ccmp->cc_servicesccmp->cc_infoccmp->cc_segsizeccmp->cc_optlen(ndo, "optlen %d ", optlen)(ndo, "disconn-initiate %d>%d ", src, dst)*dimpsizeof(*dimp)dimp->di_reasondimp->di_optlen(ndo, "disconn-confirm %d>%d ", src, dst)*dcmpsizeof(*dcmp)dcmp->dc_reason(ndo, "reserved-ctltype? %x %d > %d", flags, src, dst)(ndo, "reserved-type? %x %d > %d", flags, src, dst)NSP_TYPEMASKMFT_DATANSP_SUBMASKMFS_BOMMFS_MOMMFS_EOMdata %d>%d const seghdrconst seghdr *seghdr *shpackdata_offsizeof(struct minseghdr)word[3]unsigned char[3][2]SGQ_ACKSGQ_NAKnak %d ack %d sizeof(short)40960SGQ_OACK45056SGQ_ONAKonak %d oack %d nsppnsplenseg %d MFS_ILSMFS_INTintr nakdat %d ackdat %d link-service %d>%d const lsmsgconst lsmsg *lsmsg *lsmpsizeof(struct seghdr)lsflagsfcvalsizeof(struct lsmsg)sizeof(struct seghdr) + sizeof(struct lsmsg)LSI_MASKLSI_DATAdat seg count %d LSM_MASKLSM_NOCHANGELSM_DONOTSENDdonotsend-data LSM_SENDsend-data reserved-fcmod? %xLSI_INTRintr req count %d reserved-fcval-int? %xreserved-subtype? %x %d > %dMFT_ACKMFS_DACKdata-ack %d>%d const ackmsgconst ackmsg *ackmsg *ampsizeof(struct ackmsg)word[2]unsigned char[2][2]MFS_IACKils-ack %d>%d MFS_CACKconn-ack %dreserved-acktype? %x %d > %dMFT_CTLMFS_CIMFS_RCIconn-initiate retrans-conn-initiate %d>%d const cimsgconst cimsg *cimsg *cimpservicesinfosegsizesizeof(struct cimsg)COS_MASKCOS_NONECOS_SEGMENTseg COS_MESSAGEmsg COI_MASKCOI_32ver 3.2 COI_31ver 3.1 COI_40ver 4.0 COI_41ver 4.1 segsize %d MFS_CCconn-confirm %d>%d const ccmsgconst ccmsg *ccmsg *ccmpsizeof(struct ccmsg)optlen %d MFS_DIdisconn-initiate %d>%d const dimsgconst dimsg *dimsg *dimpsizeof(struct dimsg)MFS_DCdisconn-confirm %d>%d const dcmsgconst dcmsg *dcmsg *dcmpreserved-ctltype? %x %d > %dreserved-type? %x %d > %dprint_elistprint_i_infontypeII_TYPEMASK(ndo, "reserved-ntype? ")(ndo, "l2rout ")(ndo, "l1rout ")(ndo, "endnode ")reserved-ntype? II_L2ROUTl2rout II_L1ROUTl1rout II_ENDNODEendnode (ndo, "verif ")II_VERIFverif (ndo, "nomcast ")II_NOMCASTnomcast (ndo, "blo ")II_BLOCKblo print_l2_routes*rp3 * sizeof(short)rp(ndo, "{areas %d-%d cost %d hops %d} ", area, area + count, RI_COST(info), RI_HOPS(info))(ndo, "{areas %d-%d cost %d hops %d} ", area, area + count, ((info)&0777), (((info)>>10)&037))(3 * sizeof(short)){areas %d-%d cost %d hops %d} 511print_l1_routes(ndo, "{ids %d-%d cost %d hops %d} ", id, id + count, RI_COST(info), RI_HOPS(info))(ndo, "{ids %d-%d cost %d hops %d} ", id, id + count, ((info)&0777), (((info)>>10)&037)){ids %d-%d cost %d hops %d} print_t_infoTI_L2ROUTTI_L1ROUTTI_ENDNODETI_VERIFTI_BLOCKprint_decnet_ctlmsgconst routehdrconst routehdr *routehdr *rhp->rh_short.sh_flagsmflagsconst controlmsgconst controlmsg *controlmsg *cmpblksizeecouecohellootherverssrcearteapriorityrhpx(ndo, "init ")cmp->cm_initsizeof(cmp->cm_init)cmp->cm_init.in_srccmp->cm_init.in_infocmp->cm_init.in_blksizecmp->cm_init.in_verscmp->cm_init.in_ecocmp->cm_init.in_uecocmp->cm_init.in_hello(ndo, "src %sblksize %d vers %d eco %d ueco %d hello %d", dnaddr_string(ndo, src), blksize, vers, eco, ueco, hello)(ndo, "verification ")cmp->cm_versizeof(cmp->cm_ver)cmp->cm_ver.ve_srccmp->cm_ver.ve_fcnval(ndo, "src %s fcnval %o", dnaddr_string(ndo, src), other)(ndo, "test ")cmp->cm_testsizeof(cmp->cm_test)cmp->cm_test.te_srccmp->cm_test.te_data(ndo, "src %s data %o", dnaddr_string(ndo, src), other)(ndo, "lev-1-routing ")cmp->cm_l1rousizeof(cmp->cm_l1rou)cmp->cm_l1rou.r1_src(ndo, "src %s ", dnaddr_string(ndo, src))(ndo, "lev-2-routing ")cmp->cm_l2routsizeof(cmp->cm_l2rout)cmp->cm_l2rout.r2_src(ndo, "router-hello ")cmp->cm_rhellosizeof(cmp->cm_rhello)cmp->cm_rhello.rh_verscmp->cm_rhello.rh_ecocmp->cm_rhello.rh_ueco(char *)&srcea(const char *)&(cmp->cm_rhello.rh_src), sizeof(srcea)srcea.dne_remote.dne_nodeaddrcmp->cm_rhello.rh_infocmp->cm_rhello.rh_blksizecmp->cm_rhello.rh_prioritycmp->cm_rhello.rh_hello(ndo, "vers %d eco %d ueco %d src %s blksize %d pri %d hello %d", vers, eco, ueco, dnaddr_string(ndo, src), blksize, priority, hello)(ndo, "endnode-hello ")cmp->cm_ehellosizeof(cmp->cm_ehello)cmp->cm_ehello.eh_verscmp->cm_ehello.eh_ecocmp->cm_ehello.eh_ueco(const char *)&(cmp->cm_ehello.eh_src), sizeof(srcea)cmp->cm_ehello.eh_infocmp->cm_ehello.eh_blksize(char *)&rtea(const char *)&(cmp->cm_ehello.eh_router), sizeof(rtea)rtea.dne_remote.dne_nodeaddrcmp->cm_ehello.eh_hellocmp->cm_ehello.eh_data(ndo, "vers %d eco %d ueco %d src %s blksize %d rtr %s hello %d data %o", vers, eco, ueco, dnaddr_string(ndo, src), blksize, dnaddr_string(ndo, dst), hello, other)(ndo, "unknown control message")(const u_char *)rhpmin(length, caplen)((length)>(caplen)?(caplen):(length))RMF_CTLMASKRMF_INITinit sizeof(struct initmsg)const initmsgconst initmsg *initmsg *src %sblksize %d vers %d eco %d ueco %d hello %dRMF_VERverification sizeof(struct verifmsg)const verifmsgelprhpconst verifmsg *verifmsg *src %s fcnval %oRMF_TESTtest sizeof(struct testmsg)const testmsgconst testmsg *testmsg *src %s data %oRMF_L1ROUTlev-1-routing sizeof(struct l1rout)const l1routconst l1rout *l1rout *src %s RMF_L2ROUTlev-2-routing sizeof(struct l2rout)const l2routconst l2rout *l2rout *RMF_RHELLOrouter-hello sizeof(struct rhellomsg)const rhellomsgconst rhellomsg *rhellomsg *etheraddr *etheraddress *const etheraddrconst etheraddr *vers %d eco %d ueco %d src %s blksize %d pri %d hello %dRMF_EHELLOendnode-hello sizeof(struct ehellomsg)const ehellomsgconst ehellomsg *ehellomsg *vers %d eco %d ueco %d src %s blksize %d rtr %s hello %d data %ounknown control messagedecnet_printhopspktlensizeof(struct shorthdr)sizeof(rhp->rh_short.sh_flags)const byteunsigned char[1]const byte *unsigned char(*)[1](ndo, "[pad:%d] ", padlen)ap[sizeof(short)]padlenRMF_PADRMF_PADMASK[pad:%d] (ndo, "future-version-decnet")RMF_FVERfuture-version-decnetRMF_CTLMSGrhp->rh_longsizeof(rhp->rh_long)rhp->rh_long.lg_dst.dne_remote.dne_nodeaddrrhp->rh_long.lg_src.dne_remote.dne_nodeaddrrhp->rh_long.lg_visitsrhp->rh_shortsizeof(rhp->rh_short)rhp->rh_short.sh_dstrhp->rh_short.sh_srcrhp->rh_short.sh_visits(ndo, "unknown message flags under mask")RMF_MASKRMF_LONGsizeof(struct longhdr)const longhdrconst longhdr *longhdr *sizeof(short) + sizeof(struct longhdr)RMF_SHORTconst shorthdrconst shorthdr *shorthdr *VIS_MASKsizeof(short) + sizeof(struct shorthdr)unknown message flags under mask(ndo, "%s > %s %d ", dnaddr_string(ndo, src), dnaddr_string(ndo, dst), pktlen)%s > %s %d (ndo, "RQR ")(ndo, "RTS ")(ndo, "IE ")(ndo, "%d hops ", hops)RMF_RQRRQR RMF_RTSRTS RMF_IEIE %d hops dnet_htoadn_naddr *dcmsgdimsgcnmsgccmsgcimsgciackmsgminackmsgackmsglsmsgminseghdrseghdrnsphdrcontrolmsgehellomsgrhellomsgl2routl1routtestmsgverifmsginitmsginitmsgIIIroutehdrlonghdrshorthdrdn_naddretheraddretheraddresslongwordworduint8_t[1]rtentrymbufdc_reasondc_srcdc_dstdc_flagsdi_optlendi_reasondi_srcdi_dstdi_flagscn_segsizecn_infocn_servicescn_srccn_dstcn_flagscc_optlencc_segsizecc_infocc_servicescc_srccc_dstcc_flagsci_segsizeci_infoci_servicesci_srcci_dstci_flagsck_dstck_flagsmk_acknummk_srcmk_dstmk_flagsak_acknumak_srcak_dstak_flagsls_fcvalls_lsflagsms_seqms_srcms_dstms_flagssh_seqsh_srcsh_dstsh_flagsnh_srcnh_dstnh_flagscm_ehellocm_rhellocm_l2routcm_l1roucm_testcm_vercm_initeh_dataeh_mpdeh_helloeh_routerbyte[8]unsigned char[8][1]eh_seedeh_areaeh_blksizeeh_infoeh_srceh_uecoeh_ecoeh_verseh_flagsrh_mpdrh_hellorh_arearh_priorityrh_blksizerh_inforh_srcrh_uecorh_ecorh_versrh_flagsr2_rsvdr2_srcr2_flagsr1_rsvdr1_srcr1_flagste_datate_srcte_flagsve_fcnvalve_srcve_flagsin_rsvdin_helloin_uecoin_ecoin_versin_blksizein_infoin_srcin_flagsinIII_rsvdinIII_uecoinIII_ecoinIII_versinIII_blksizeinIII_infoinIII_srcinIII_flagsrh_longrh_shortlg_ptlg_servicelg_visitslg_nextl2lg_srclg_ssarealg_sarealg_dstlg_dsarealg_darealg_flagssh_visitsuint8_t[20]unsigned char[20]DN_MAXADDLa_addra_lendne_remotedne_addrdne_nodeaddrdne_hiordUC_OBJREJECTobject rejected connect"object rejected connect"UC_RESOURCESinsufficient resources"insufficient resources"UC_NOSUCHNODEunrecognized node name"unrecognized node name"DI_SHUTnode is shutting down"node is shutting down"UC_NOSUCHOBJunrecognized object"unrecognized object"UC_INVOBJFORMATinvalid object name format"invalid object name format"UC_OBJTOOBUSYobject too busy"object too busy"DI_PROTOCOLprotocol error discovered"protocol error discovered"DI_TPAthird party abort"third party abort"UC_USERABORTuser abort"user abort"UC_INVNODEFORMATinvalid node name format"invalid node name format"UC_LOCALSHUTlocal node shutting down"local node shutting down"DI_LOCALRESRCinsufficient local resources"insufficient local resources"DI_REMUSERRESRCinsufficient remote user resources"insufficient remote user resources"UC_ACCESSREJECTinvalid access control information"invalid access control information"DI_BADACCNTbad ACCOUNT information"bad ACCOUNT information"UC_NORESPONSEno response from object"no response from object"UC_UNREACHABLEnode unreachable"node unreachable"DC_NOLINKno link terminate"no link terminate"DC_COMPLETEdisconnect complete"disconnect complete"DI_BADIMAGEbad image data in connect"bad image data in connect"DI_SERVMISMATCHcryptographic service mismatch"cryptographic service mismatch"reason2str[|decnet]"[|decnet]"UC_NETWORKABORTUC_REMOTESHUTUC_USERDISCONNECTDI_UNREACHABLEDI_TIMEDOUTDI_CONNECTABORTDI_BADACCESSDI_ABORTDI_REMRESRCDI_INVDESTDI_NOUSERDI_NOERRORDC_NORESOURCESMNU_UICPROXYMNU_INVKPROXYMNU_USRDATAMNU_ACCESSMNU_20040MNU_10000MNU_MASKCOS_DEFAULT01004014LSI_INTM037703SGQ_EOM0100000SGQ_DELAY010000SGQ_OTHER020000SGQ_MASK0777701300000120000011000001400100060020MFS_NOPNSP_SUBSHFT0160RI_HOPS(x)(((x)>>10)&037)RI_COST(x)((x)&0777)TESTLENTESTDATA02520201P3_UECOP3_ECOP3_VERSVE_UECOVE_ECOVE_VERS015013011070501707701770200017770176000HIORD0x000400aaHAVE_NETDNET_DNETDB_HHAVE_NETDNET_DNETDB_H_DNET_HTOAHAVE_DNET_HTOA/* punt *//* ackdat field *//* acknum field *//* ackoth field *//* Not enough examples available for me to debug this *//* seems to be bogus from here on *//* The last short is a checksum *//*seed*//* Our caller has already checked for mflags *//* is it a control message? *//* pad bytes of some sort in front of message *//* Forwards *//* reason code *//* source link address *//* destination link address *//* message flags *//* disconnect confirm message *//* optional data length *//* disconnect initiate message *//* maximum segment size *//* information *//* requested services *//* generic connect message *//* connect confirm message *//* destination link address (0) *//* connect initiate message *//* connect acknowledgement message *//* minimum acknowledgement message *//* acknowledgement numbers *//* acknowledgement message *//* flow control value *//* link service flags *//* link service message (after hdr) *//* minimum data segment header *//* sequence numbers *//* data segment header *//* general nsp header *//*
 * NSP message formats.
 *//* node unreachable *//* no response from object *//* invalid access control information *//* local node shutting down *//* invalid node name format *//* user abort *//* network abort *//* object too busy *//* invalid object name format *//* unrecognized object *//* remote node shutting down *//* unrecognized node name *//* insufficient resources (local or remote) *//* user disconnect *//* object rejected connect *//* cryptographic service mismatch *//* bad image data in connect *//* local timers expired due to ... *//* remote node or user crashed *//* connect request cancelled *//* bad ACCOUNT information *//* bad access control information *//* insufficient remote user resources *//* insufficient local resources *//* protocol error discovered *//* third party abort *//* insufficient remote resources *//* invalid end user destination *//* destination end user does not exist *//* node is shutting down *//* disconnect complete reason code *//* no link terminate reason code *//* no resource reason code *//* use uic-based proxy *//* invoke proxy field present *//* user data field present *//* access control present *//* session V2.0 *//* session V1.0 *//* mask for session control version *//* version 4.1 *//* version 4.0 *//* version 3.1 *//* version 3.2 *//* mask for version field *//* default value for field *//* message flow control *//* segment flow control *//* no flow control *//* mask for flow control field *//* funny marker for int. message *//* interrupt request count *//* data segment or message count *//* mask for interpretation field *//* send data *//* do not send data *//* no change *//* mask for modifier field *//* pseudo flag for end-of-message *//* ack delay flag *//* other channel qualifier *//* mask to isolate seq # *//* other channel negative ack *//* other channel ack *//* negative ack *//* ack *//* retransmitted connect initiate *//* disconnect confirm *//* disconnect initiate *//* connect confirm *//* connect initiate *//* no operation *//* connect acknowledgement *//* I/LS acknowledgement *//* data acknowledgement *//* interrupt message *//* end of message (data) *//* middle of message (data) *//* beginning of message (data) *//* data or I/LS indicator *//* control message *//* data message *//* shift to move subtype code *//* mask to isolate subtype code *//* mask to isolate type code *//*
 * NSP protocol fields and values.
 *//* Macros for decoding routing-info fields *//* endnode hello message *//* router hello message *//* level 2 routing message *//* level 1 routing message *//* hello and test message *//* verification message *//* initialization message *//* test data image field *//* (reserved) *//* hello timer *//* designated router *//* verification seed *//* area (reserved) *//* maximum data link block size *//* routing layer information *//* source id *//* user ECO number *//* ECO number *//* route flags *//* router's priority *//* reserved field *//* source node address *//* function value image field *//* reserved image field *//* phase III initialization message *//*
 * Define control message formats.
 *//* length of transmitted test data *//* test data bytes *//* mask for node type *//* blocking requested *//* no multicast traffic accepted *//* verification required *//* endnode *//* level 1 router *//* level 2 router *//* user ECO number (0) *//* ECO number (3) *//* phase III version number (1) *//* version number (2) *//* control message indicator *//* mask for message type *//*
 * 2. Control packet formats.
 *//* visit field mask *//* pad field mask *//* pad field *//* future version flag *//* RMR_RQR *//* intra-ethernet packet *//* returning to sender *//* request return to sender *//* long message format *//* short message format *//*
 * Define the values of various fields in the protocol messages.
 *
 * 1. Data packet formats.
 *//* long route header *//* short route header *//* protocol type (reserved) *//* service class (reserved) *//* visit count *//* next level 2 router (reserved) *//* source subarea (reserved) *//* source area (reserved) *//* destination id *//* destination subarea (reserved) *//* destination area (reserved) *//* destination node address *//*
 * Define long and short header formats.
 *//* address as bytes *//* length of address *//* max size of DECnet address *//* mask for node address field *//* bit-offset for area field *//* mask for area field *//* high 32-bits of address (swapped) *//* Ethernet address *//* DECnet node address *//* DECnet HIORD prefix *//* full ethernet address *//*
 * Definitions for DECNET Phase IV protocol headers
 *//* 4 bytes field *//* 2 byte field *//* single byte field *//*
 * the keyword 'byte' generates conflicts in Windows
 *//* \summary: DECnet printer *//*
 * Copyright (c) 1992, 1993, 1994, 1995, 1996, 1997
 *	The Regents of the University of California.  All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that: (1) source code distributions
 * retain the above copyright notice and this paragraph in its entirety, (2)
 * distributions including binary code include the above copyright notice and
 * this paragraph in its entirety in the documentation or other materials
 * provided with the distribution, and (3) all advertising materials mentioning
 * features or use of this software display the following acknowledgement:
 * ``This product includes software developed by the University of California,
 * Lawrence Berkeley Laboratory and its contributors.'' Neither the name of
 * the University nor the names of its contributors may be used to endorse
 * or promote products derived from this software without specific prior
 * written permission.
 * THIS SOFTWARE IS PROVIDED ``AS IS'' AND WITHOUT ANY EXPRESS OR IMPLIED
 * WARRANTIES, INCLUDING, WITHOUT LIMITATION, THE IMPLIED WARRANTIES OF
 * MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE.
 *//Users/owura/Repos/codeql_eval/proj_repos/the-tcpdump-group-tcpdump-commit-9ba91381954ad325ea4fd26b9c65a8bd9a2a85b6/tcpdump/print-dhcp6.cdhcp6_printconst dhcp6const dhcp6 *dhcp6 *dh6const dhcp6_relayconst dhcp6_relay *dhcp6_relay *dh6relayextp(ndo, "dhcp6")dhcp6dh6->dh6_xiddh6->dh6_msgtypexid.xsizeof(dh6->dh6_msgtypexid.x)const nd_uint32_tconst nd_uint32_t *msgtype-%u"msgtype-%u"(ndo, " %s", name)(ndo, " %s (", name) %s ((ndo, "xid=%x", EXTRACT_32BITS(&dh6->dh6_xid) & DH6_XIDMASK)(ndo, "xid=%x", ((uint32_t)(((uint32_t)(*((const uint8_t *)(&dh6->dh6_msgtypexid.x) + 0)) << 24) | ((uint32_t)(*((const uint8_t *)(&dh6->dh6_msgtypexid.x) + 1)) << 16) | ((uint32_t)(*((const uint8_t *)(&dh6->dh6_msgtypexid.x) + 2)) << 8) | ((uint32_t)(*((const uint8_t *)(&dh6->dh6_msgtypexid.x) + 3)) << 0))) & 0x00ffffff)&dh6->dh6_xid&dh6->dh6_msgtypexid.xdh6relay->dh6relay_peeraddrsizeof(dh6relay->dh6relay_peeraddr)&addr6dh6relay->dh6relay_linkaddr, sizeof (addr6)(ndo, "linkaddr=%s", ip6addr_string(ndo, &addr6))(ndo, "linkaddr=%s", getname6(ndo, (const u_char *)(&addr6)))dh6relay->dh6relay_peeraddr, sizeof (addr6)(ndo, " peeraddr=%s", ip6addr_string(ndo, &addr6))(ndo, " peeraddr=%s", getname6(ndo, (const u_char *)(&addr6)))DH6_RELAY_FORWDH6_RELAY_REPLYxid=%xnd_uint8_t[16]const nd_uint8_t[16]const nd_uint8_t(*)[16]const nd_uint8_t *linkaddr=%s peeraddr=%s(ndo, "[|dhcp6]")[|dhcp6]dhcp6opt_printconst dhcp6optconst dhcp6opt *dhcp6opt *dh6oopttypeauth_protoauthinfolenauthrealmlenremain_lenlabel_lensubopt_codesubopt_len*dh6osizeof(*dh6o)&dh6o->dh6opt_len&dh6o->dh6opt_type(ndo, " (%s", tok2str(dh6opt_str, "opt_%u", opttype))*(cp + sizeof(*dh6o))(ndo, " ?)")(ndo, " hwaddr/time type %u time %u ", EXTRACT_16BITS(&tp[2]), EXTRACT_32BITS(&tp[4]))(ndo, " hwaddr/time type %u time %u ", ((uint16_t)(((uint16_t)(*((const uint8_t *)(&tp[2]) + 0)) << 8) | ((uint16_t)(*((const uint8_t *)(&tp[2]) + 1)) << 0))), ((uint32_t)(((uint32_t)(*((const uint8_t *)(&tp[4]) + 0)) << 24) | ((uint32_t)(*((const uint8_t *)(&tp[4]) + 1)) << 16) | ((uint32_t)(*((const uint8_t *)(&tp[4]) + 2)) << 8) | ((uint32_t)(*((const uint8_t *)(&tp[4]) + 3)) << 0))))&tp[2]&tp[4](ndo, "%02x", tp[i])(ndo, " vid ")(ndo, " hwaddr type %u ", EXTRACT_16BITS(&tp[2]))(ndo, " hwaddr type %u ", ((uint16_t)(((uint16_t)(*((const uint8_t *)(&tp[2]) + 0)) << 8) | ((uint16_t)(*((const uint8_t *)(&tp[2]) + 1)) << 0))))(ndo, " type %d)", EXTRACT_16BITS(tp))(ndo, " type %d)", ((uint16_t)(((uint16_t)(*((const uint8_t *)(tp) + 0)) << 8) | ((uint16_t)(*((const uint8_t *)(tp) + 1)) << 0))))(ndo, " %s", ip6addr_string(ndo, &tp[0]))(ndo, " %s", getname6(ndo, (const u_char *)(&tp[0])))&tp[0](ndo, " pltime:%u vltime:%u", EXTRACT_32BITS(&tp[16]), EXTRACT_32BITS(&tp[20]))(ndo, " pltime:%u vltime:%u", ((uint32_t)(((uint32_t)(*((const uint8_t *)(&tp[16]) + 0)) << 24) | ((uint32_t)(*((const uint8_t *)(&tp[16]) + 1)) << 16) | ((uint32_t)(*((const uint8_t *)(&tp[16]) + 2)) << 8) | ((uint32_t)(*((const uint8_t *)(&tp[16]) + 3)) << 0))), ((uint32_t)(((uint32_t)(*((const uint8_t *)(&tp[20]) + 0)) << 24) | ((uint32_t)(*((const uint8_t *)(&tp[20]) + 1)) << 16) | ((uint32_t)(*((const uint8_t *)(&tp[20]) + 2)) << 8) | ((uint32_t)(*((const uint8_t *)(&tp[20]) + 3)) << 0))))&tp[16]&tp[20](ndo, " %s", tok2str(dh6opt_str, "opt_%u", EXTRACT_16BITS(&tp[i])))(ndo, " %s", tok2str(dh6opt_str, "opt_%u", ((uint16_t)(((uint16_t)(*((const uint8_t *)(&tp[i]) + 0)) << 8) | ((uint16_t)(*((const uint8_t *)(&tp[i]) + 1)) << 0)))))&tp[i](ndo, " %d)", *tp)(ndo, " %d)", EXTRACT_16BITS(tp))(ndo, " %d)", ((uint16_t)(((uint16_t)(*((const uint8_t *)(tp) + 0)) << 8) | ((uint16_t)(*((const uint8_t *)(tp) + 1)) << 0))))(ndo, " proto: delayed")(ndo, " proto: reconfigure")(ndo, " proto: %d", auth_proto)(ndo, ", alg: HMAC-MD5")(ndo, ", alg: %d", *tp)(ndo, ", RDM: mono")(ndo, ", RDM: %d", *tp)(ndo, ", RD:")(ndo, " %04x", EXTRACT_16BITS(tp))(ndo, " %04x", ((uint16_t)(((uint16_t)(*((const uint8_t *)(tp) + 0)) << 8) | ((uint16_t)(*((const uint8_t *)(tp) + 1)) << 0))))(ndo, " ??")(ndo, ", realm: ")(ndo, "%02x", *tp)(ndo, ", key ID: %08x", EXTRACT_32BITS(tp))(ndo, ", key ID: %08x", ((uint32_t)(((uint32_t)(*((const uint8_t *)(tp) + 0)) << 24) | ((uint32_t)(*((const uint8_t *)(tp) + 1)) << 16) | ((uint32_t)(*((const uint8_t *)(tp) + 2)) << 8) | ((uint32_t)(*((const uint8_t *)(tp) + 3)) << 0))))(ndo, ", HMAC-MD5:")(ndo, " %08x", EXTRACT_32BITS(tp))(ndo, " %08x", ((uint32_t)(((uint32_t)(*((const uint8_t *)(tp) + 0)) << 24) | ((uint32_t)(*((const uint8_t *)(tp) + 1)) << 16) | ((uint32_t)(*((const uint8_t *)(tp) + 2)) << 8) | ((uint32_t)(*((const uint8_t *)(tp) + 3)) << 0))))(ndo, " reconfig-key")(ndo, " type: HMAC-MD5")(ndo, " type: ??")(ndo, " value:")(ndo, "...)")(ndo, " for renew)")(ndo, " for inf-req)")(ndo, " for ?\?\?(%02x))", *tp)(ndo, " %s", ip6addr_string(ndo, &tp[i]))(ndo, " %s", getname6(ndo, (const u_char *)(&tp[i])))(ndo, " %s)", dhcp6stcode(EXTRACT_16BITS(&tp[0])))(ndo, " %s)", dhcp6stcode(((uint16_t)(((uint16_t)(*((const uint8_t *)(&tp[0]) + 0)) << 8) | ((uint16_t)(*((const uint8_t *)(&tp[0]) + 1)) << 0)))))(ndo, " IAID:%u T1:%u T2:%u", EXTRACT_32BITS(&tp[0]), EXTRACT_32BITS(&tp[4]), EXTRACT_32BITS(&tp[8]))(ndo, " IAID:%u T1:%u T2:%u", ((uint32_t)(((uint32_t)(*((const uint8_t *)(&tp[0]) + 0)) << 24) | ((uint32_t)(*((const uint8_t *)(&tp[0]) + 1)) << 16) | ((uint32_t)(*((const uint8_t *)(&tp[0]) + 2)) << 8) | ((uint32_t)(*((const uint8_t *)(&tp[0]) + 3)) << 0))), ((uint32_t)(((uint32_t)(*((const uint8_t *)(&tp[4]) + 0)) << 24) | ((uint32_t)(*((const uint8_t *)(&tp[4]) + 1)) << 16) | ((uint32_t)(*((const uint8_t *)(&tp[4]) + 2)) << 8) | ((uint32_t)(*((const uint8_t *)(&tp[4]) + 3)) << 0))), ((uint32_t)(((uint32_t)(*((const uint8_t *)(&tp[8]) + 0)) << 24) | ((uint32_t)(*((const uint8_t *)(&tp[8]) + 1)) << 16) | ((uint32_t)(*((const uint8_t *)(&tp[8]) + 2)) << 8) | ((uint32_t)(*((const uint8_t *)(&tp[8]) + 3)) << 0))))&tp[8](ndo, " IAID:%u", EXTRACT_32BITS(tp))(ndo, " IAID:%u", ((uint32_t)(((uint32_t)(*((const uint8_t *)(tp) + 0)) << 24) | ((uint32_t)(*((const uint8_t *)(tp) + 1)) << 16) | ((uint32_t)(*((const uint8_t *)(tp) + 2)) << 8) | ((uint32_t)(*((const uint8_t *)(tp) + 3)) << 0))))(ndo, " %s/%d", ip6addr_string(ndo, &tp[9]), tp[8])(ndo, " %s/%d", getname6(ndo, (const u_char *)(&tp[9])), tp[8])&tp[9](ndo, " pltime:%u vltime:%u", EXTRACT_32BITS(&tp[0]), EXTRACT_32BITS(&tp[4]))(ndo, " pltime:%u vltime:%u", ((uint32_t)(((uint32_t)(*((const uint8_t *)(&tp[0]) + 0)) << 24) | ((uint32_t)(*((const uint8_t *)(&tp[0]) + 1)) << 16) | ((uint32_t)(*((const uint8_t *)(&tp[0]) + 2)) << 8) | ((uint32_t)(*((const uint8_t *)(&tp[0]) + 3)) << 0))), ((uint32_t)(((uint32_t)(*((const uint8_t *)(&tp[4]) + 0)) << 24) | ((uint32_t)(*((const uint8_t *)(&tp[4]) + 1)) << 16) | ((uint32_t)(*((const uint8_t *)(&tp[4]) + 2)) << 8) | ((uint32_t)(*((const uint8_t *)(&tp[4]) + 3)) << 0))))(ndo, " %d)", EXTRACT_32BITS(tp))(ndo, " %d)", ((uint32_t)(((uint32_t)(*((const uint8_t *)(tp) + 0)) << 24) | ((uint32_t)(*((const uint8_t *)(tp) + 1)) << 16) | ((uint32_t)(*((const uint8_t *)(tp) + 2)) << 8) | ((uint32_t)(*((const uint8_t *)(tp) + 3)) << 0))))(ndo, " %d ", EXTRACT_32BITS(tp))(ndo, " %d ", ((uint32_t)(((uint32_t)(*((const uint8_t *)(tp) + 0)) << 24) | ((uint32_t)(*((const uint8_t *)(tp) + 1)) << 16) | ((uint32_t)(*((const uint8_t *)(tp) + 2)) << 8) | ((uint32_t)(*((const uint8_t *)(tp) + 3)) << 0))))(ndo, " by-address")(ndo, " by-clientID")(ndo, " type_%d", (int)*tp)(ndo, " %s", ip6addr_string(ndo, &tp[1]))(ndo, " %s", getname6(ndo, (const u_char *)(&tp[1])))&tp[1](ndo, " %s ", ip6addr_string(ndo, &tp[0]))(ndo, " %s ", getname6(ndo, (const u_char *)(&tp[0])))(ndo, " subopt:%d", subopt_code)(ndo, " ?")(ndo, "=")const nd_uint16_tconst nd_uint16_t * (%sconst tok[50]tok[50]opt_%uDH6OPT_CLIENTIDDH6OPT_SERVERID ?)2 + 6 hwaddr/time type %u time %u 2 + 8 vid  hwaddr type %u  type %d)DH6OPT_IA_ADDR pltime:%u vltime:%uDH6OPT_ORODH6OPT_ERODH6OPT_PREFERENCE %d)DH6OPT_ELAPSED_TIMEDH6OPT_RELAY_MSGDH6OPT_AUTHDH6OPT_AUTHPROTO_DELAYED proto: delayedDH6OPT_AUTHPROTO_RECONFIG proto: reconfigure proto: %dDH6OPT_AUTHALG_HMACMD5, alg: HMAC-MD5, alg: %dDH6OPT_AUTHRDM_MONOCOUNTER, RDM: mono, RDM: %d, RD: %04x ??, realm: , key ID: %08x, HMAC-MD5: %08xDH6OPT_AUTHRECONFIG_KEY reconfig-keyDH6OPT_AUTHRECONFIG_HMACMD5 type: HMAC-MD5 type: ?? value:DH6OPT_RAPID_COMMITDH6OPT_INTERFACE_IDDH6OPT_SUBSCRIBER_ID...)DH6OPT_RECONF_MSGDH6_RENEW for renew)DH6_INFORM_REQ for inf-req) for ???(%02x))DH6OPT_RECONF_ACCEPTDH6OPT_SIP_SERVER_ADH6OPT_DNS_SERVERSDH6OPT_SNTP_SERVERSDH6OPT_NIS_SERVERSDH6OPT_NISP_SERVERSDH6OPT_BCMCS_SERVER_ADH6OPT_PANA_AGENTDH6OPT_LQ_CLIENT_LINKDH6OPT_SIP_SERVER_DDH6OPT_DOMAIN_LISTDH6OPT_STATUS_CODE %s)DH6OPT_IA_NADH6OPT_IA_PD IAID:%u T1:%u T2:%uDH6OPT_IA_TA IAID:%uDH6OPT_IA_PD_PREFIX %s/%dDH6OPT_LIFETIMEDH6OPT_CLT_TIMEDH6OPT_REMOTE_ID %d DH6OPT_LQ_QUERY by-address by-clientID type_%dDH6OPT_CLIENT_DATADH6OPT_LQ_RELAY_DATA %s DH6OPT_NTP_SERVER subopt:%dDH6OPT_NTP_SUBOPTION_SRV_ADDRDH6OPT_NTP_SUBOPTION_MC_ADDR ?DH6OPT_NTP_SUBOPTION_SRV_FQDNDH6OPT_AFTR_NAMEDH6OPT_NEW_POSIX_TIMEZONEDH6OPT_NEW_TZDB_TIMEZONEDH6OPT_MUDURL=(ndo, "[|dhcp6ext]")[|dhcp6ext]dhcp6stcodeINVALID code"INVALID code"code%u"code%u"dhcp6optdhcp6_relaydh6opt_lendh6opt_typedh6relay_peeraddrdh6relay_linkaddrdh6relay_hcntdh6relay_msgtypedh6_msgtypexidmDH6OPT_STCODE_SUCCESSSuccess"Success"DH6OPT_STCODE_UNSPECFAILUnspecFail"UnspecFail"DH6OPT_STCODE_NOADDRAVAILNoAddrsAvail"NoAddrsAvail"DH6OPT_STCODE_NOBINDINGNoBinding"NoBinding"DH6OPT_STCODE_NOTONLINKNotOnLink"NotOnLink"DH6OPT_STCODE_USEMULTICASTUseMulticast"UseMulticast"DH6OPT_STCODE_NOPREFIXAVAILNoPrefixAvail"NoPrefixAvail"DH6OPT_STCODE_UNKNOWNQUERYTYPEUnknownQueryType"UnknownQueryType"DH6OPT_STCODE_MALFORMEDQUERYMalformedQuery"MalformedQuery"DH6OPT_STCODE_NOTCONFIGUREDNotConfigured"NotConfigured"DH6OPT_STCODE_NOTALLOWEDNotAllowed"NotAllowed"dh6opt_stcode_strclient-ID"client-ID"server-ID"server-ID"IA_NA"IA_NA"IA_TA"IA_TA"IA_ADDR"IA_ADDR"option-request"option-request"preference"preference"elapsed-time"elapsed-time"relay-message"relay-message"authentication"authentication"DH6OPT_UNICASTserver-unicast"server-unicast"status-code"status-code"rapid-commit"rapid-commit"DH6OPT_USER_CLASSuser-class"user-class"DH6OPT_VENDOR_CLASSvendor-class"vendor-class"DH6OPT_VENDOR_OPTSvendor-specific-info"vendor-specific-info"interface-ID"interface-ID"reconfigure-message"reconfigure-message"reconfigure-accept"reconfigure-accept"SIP-servers-domain"SIP-servers-domain"SIP-servers-address"SIP-servers-address"DNS-server"DNS-server"DNS-search-list"DNS-search-list"IA_PD"IA_PD"IA_PD-prefix"IA_PD-prefix"SNTP-servers"SNTP-servers"lifetime"lifetime"NIS-server"NIS-server"NIS+-server"NIS+-server"DH6OPT_NIS_NAMENIS-domain-name"NIS-domain-name"DH6OPT_NISP_NAMENIS+-domain-name"NIS+-domain-name"DH6OPT_BCMCS_SERVER_DBCMCS-domain-name"BCMCS-domain-name"BCMCS-server"BCMCS-server"DH6OPT_GEOCONF_CIVICGeoconf-Civic"Geoconf-Civic"DH6OPT_CLIENT_FQDNClient-FQDN"Client-FQDN"PANA-agent"PANA-agent"POSIX-timezone"POSIX-timezone"POSIX-tz-database"POSIX-tz-database"Echo-request-option"Echo-request-option"Lease-query"Lease-query"LQ-client-data"LQ-client-data"Clt-time"Clt-time"LQ-relay-data"LQ-relay-data"LQ-client-link"LQ-client-link"NTP-server"NTP-server"AFTR-Name"AFTR-Name"MUD-URL"MUD-URL"dh6opt_strDH6_SOLICITsolicit"solicit"DH6_ADVERTISEDH6_REQUEST"request"DH6_CONFIRMconfirm"confirm"renew"renew"DH6_REBINDrebind"rebind"DH6_REPLYreply"reply"DH6_RELEASErelease"release"DH6_DECLINEdecline"decline"DH6_RECONFIGUREreconfigure"reconfigure"inf-req"inf-req"relay-fwd"relay-fwd"relay-reply"relay-reply"DH6_LEASEQUERYleasequery"leasequery"DH6_LQ_REPLYleasequery-reply"leasequery-reply"dh6_msgtype_strDH6OPT_PREF_MAXDH6_XIDMASK0x00ffffffdh6_xiddh6_msgtypexid.xdh6_msgtypedh6_msgtypexid.mDH6ERR_OPTUNAVAILDH6ERR_UNAVAILDH6ERR_POORLYFORMEDDH6ERR_AUTHFAILDH6ERR_FAILUREDHCP6_DURATION_INFINITE0xffffffff/*(*//* relay messages *//*)*//* XXX relay agent messages have to be handled differently *//*
 * Print dhcp6 packets
 *//* although GMT might not work *//* are encoded similarly *//* all three of these options *//* Encoding is described in section 3.1 of RFC 1035 *//*
			 * Print hex dump first 10 characters.
			 *//* there are encapsulated options *//* there are query-options *//* there are sub-options *//* nothing todo *//*
			 * Since we cannot predict the encoding, print hex dump
			 * at most 10 characters.
			 *//* protocol dependent part *//* XXX: may depend on the protocol *//* Label length *//* Length of remaining options *//* type-dependent data follows *//* RFC5007 *//* RFC3633 *//* RFC3315 *//*#define DH6OPT_SERVER_MSG 10 deprecated *//* options *//* options follow *//* XXX: badly aligned *//* DHCPv6 relay messages *//* DHCP6 base packet format *//* Message type *//* Error Values *//* lease duration *//*
 * RFC3315: DHCPv6
 * supported DHCPv6 options:
 *  RFC3319: Session Initiation Protocol (SIP) Servers options,
 *  RFC3633: IPv6 Prefix options,
 *  RFC3646: DNS Configuration options,
 *  RFC3898: Network Information Service (NIS) Configuration options,
 *  RFC4075: Simple Network Time Protocol (SNTP) Configuration option,
 *  RFC4242: Information Refresh Time option,
 *  RFC4280: Broadcast and Multicast Control Servers options,
 *  RFC5908: Network Time Protocol (NTP) Server Option for DHCPv6
 *  RFC6334: Dual-Stack Lite option,
 *//* \summary: IPv6 DHCP printer *//*
 * Copyright (C) 1998 and 1999 WIDE Project.
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. Neither the name of the project nor the names of its contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE PROJECT AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE PROJECT OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 *//Users/owura/Repos/codeql_eval/proj_repos/the-tcpdump-group-tcpdump-commit-9ba91381954ad325ea4fd26b9c65a8bd9a2a85b6/tcpdump/nameser.h<sys/types.h>rrecHEADERr_datar_sizer_ttlr_typer_classr_zonearcountnscountancountqdcountflags2flags1PUTLONG(l,cp){ register uint32_t t_l = (uint32_t)(l); register u_char *t_cp = (u_char *)(cp); *t_cp++ = t_l >> 24; *t_cp++ = t_l >> 16; *t_cp++ = t_l >> 8; *t_cp = t_l; (cp) += 4; }PUTSHORT(s,cp){ register uint16_t t_s = (uint16_t)(s); register u_char *t_cp = (u_char *)(cp); *t_cp++ = t_s >> 8; *t_cp = t_s; (cp) += 2; }GETLONG(l,cp){ register u_char *t_cp = (u_char *)(cp); (l) = (((uint32_t)t_cp[0]) << 24) | (((uint32_t)t_cp[1]) << 16) | (((uint32_t)t_cp[2]) << 8) | (((uint32_t)t_cp[3])); (cp) += 4; }GETSHORT(s,cp){ register u_char *t_cp = (u_char *)(cp); (s) = ((uint16_t)t_cp[0] << 8) | (uint16_t)t_cp[1]; (cp) += 2; }EDNS0_ELT_BITLABELEDNS0_MASKINDIR_MASKDNS_RCODE(np)((np)->flags2 & 0xF)DNS_CD(np)((np)->flags2 & 0x10)DNS_AD(np)((np)->flags2 & 0x20)DNS_RA(np)((np)->flags2 & 0x80)DNS_RD(np)((np)->flags1 & 0x01)DNS_TC(np)((np)->flags1 & 0x02)DNS_AA(np)((np)->flags1 & 0x04)DNS_OPCODE(np)((((np)->flags1) >> 3) & 0xF)DNS_QR(np)((np)->flags1 & 0x80)CONV_BADBUFLENCONV_BADCKSUMCONV_BADFMTCONV_OVERFLOWCONV_SUCCESSC_CACHE_FLUSHC_QUC_ANYC_HSC_CHAOSC_INT_ANYT_MAILAT_MAILBT_AXFR252T_IXFRT_TSIGT_TKEYT_UNSPECAT_UNSPECT_GIDT_UIDT_UINFOT_SPFT_DNSKEYT_NSECT_RRSIGT_IPSECKEYT_SSHFPT_DST_APLT_OPTT_SINKT_DNAMET_A6T_CERTT_KXT_NAPTRT_ATMAT_SRVT_NIMLOCT_EIDT_NXTT_LOCT_AAAAT_GPOST_PXT_KEYT_SIGT_NSAP_PTRT_NSAPT_RTT_ISDNT_X25T_AFSDBT_RPT_TXTT_MXT_MINFOT_HINFOT_PTRT_WKST_NULLT_MRT_MGT_MBT_SOAT_CNAMET_MFT_MDT_NST_ANOCHANGEREFUSEDNOTIMPNXDOMAINSERVFAILFORMERRNOERRORZONEREFZONEINIT0xeUPDATEMA0xdUPDATEM0xcUPDATEDA0xbUPDATED0xaUPDATEAIQUERYQUERYRRFIXEDSZQFIXEDSZMAXLABELMAXCDNAMEMAXDNAMEPACKETSZ_NAMESER_H_/* !_NAMESER_H_ *//*
 * Warning: PUTLONG --no-longer-- destroys its first argument.  if you
 * were depending on this "feature", you will lose.
 *//*
 * Inline versions of get/put short/long.  Pointer is advanced.
 * We also assume that a "uint16_t" holds 2 "chars"
 * and that a "uint32_t" holds 4 "chars".
 *
 * These macros demonstrate the property of C whereby it can be
 * portable or it can be elegant but never both.
 *//* pointer to data *//* size of data area *//* time to live *//* type number *//* class number *//* zone number *//*
 * Structure for passing resource records around.
 *//* 01.... *//* 11.... *//*
 * Defines for handling compressed domain names, EDNS0 labels, etc.
 *//* response code *//* checking disabled by resolver *//* authentic data from named *//* recursion available *//* recursion desired *//* truncated message *//* authoritative answer *//* purpose of message *//* response flag *//*
 * Macros for subfields of flag fields.
 *//* number of resource entries *//* number of authority entries *//* number of answer entries *//* number of question entries *//* second byte of flags *//* first byte of flags *//* query identification number *//*
 * Structure for query header.
 *//*
 * Status return codes for T_UNSPEC conversion routines
 *//* mDNS cache flush flag in replies *//* mDNS QU flag in queries *//* wildcard match *//* Query class values which do not appear in resource records *//* for Hesiod name server (MIT) (XXX) *//* for chaos net (MIT) *//* the arpa internet *//*
 * Values for class field
 *//* transfer mail agent records *//* transfer mailbox records *//* transfer zone of authority *//* incremental transfer [RFC1995] *//* Transaction Signature [RFC2845] *//* Transaction Key [RFC2930] *//* Query type values which do not appear in resource records *//* "unspecified ascii". Ugly MIT hack *//* Unspecified format (binary data) *//* group ID *//* user ID *//* user (finger) information *//* sender policy framework *//* non standard *//* new security key *//* provable insecure information *//* new security signature *//* IPsec keying material *//* SSH Fingerprint *//* Delegation Signer *//* lists of address prefixes *//* EDNS0 option (meta-RR) *//* unknown *//* non-terminal redirection *//* IP6 address *//* Certificates in the DNS *//* Key Exchanger *//* Naming Authority PoinTeR *//* ATM Address *//* Server selection *//* Nimrod locator *//* Endpoint identifier *//* Next Valid Name in Zone *//* Location Information *//* IP6 Address *//* geographical position (withdrawn) *//* X.400 mail mapping *//* security key *//* security signature *//* reverse lookup for NSAP *//* NSAP address *//* router *//* ISDN calling address *//* X_25 calling address *//* AFS cell database *//* responsible person *//* text strings *//* mail routing information *//* mailbox information *//* host information *//* domain name pointer *//* well known service *//* null resource record *//* mail rename name *//* mail group member *//* mailbox domain name *//* start of authority zone *//* connonical name *//* mail forwarder *//* mail destination *//* authoritative server *//* host address *//*
 * Type values for resources and queries
 *//* update failed to change db *//* query refused *//* not implemented *//* non existent domain *//* server failure *//* format error *//* no error *//*
 * Currently defined response codes
 *//*
 * Undefine various #defines from various System V-flavored OSes (Solaris,
 * SINIX, HP-UX) so the compiler doesn't whine that we redefine them.
 *//* incremental zone referesh *//* initial zone transfer *//* modify all named resource record *//* modify a specific resource record *//* delete all named resource record *//* delete a specific resource record *//* add resource record *//* non standard - supports ALLOW_UPDATES stuff from Mike Schwartz *//* 0x3 reserved *//* nameserver status query *//* inverse query *//* standard query *//*
 * Currently defined opcodes
 *//* number of bytes of fixed size data in resource record *//* Number of bytes of fixed size data in query structure *//* maximum length of domain label *//* maximum compressed domain name *//* maximum domain name *//* maximum packet size *//*
 * Define constants based on rfc883
 *//*
 * Copyright (c) 1983, 1989, 1993
 *	The Regents of the University of California.  All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *	This product includes software developed by the University of
 *	California, Berkeley and its contributors.
 * 4. Neither the name of the University nor the names of its contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 *
 *      @(#)nameser.h	8.2 (Berkeley) 2/16/94
 * -
 * Portions Copyright (c) 1993 by Digital Equipment Corporation.
 *
 * Permission to use, copy, modify, and distribute this software for any
 * purpose with or without fee is hereby granted, provided that the above
 * copyright notice and this permission notice appear in all copies, and that
 * the name of Digital Equipment Corporation not be used in advertising or
 * publicity pertaining to distribution of the document or software without
 * specific, written prior permission.
 *
 * THE SOFTWARE IS PROVIDED "AS IS" AND DIGITAL EQUIPMENT CORP. DISCLAIMS ALL
 * WARRANTIES WITH REGARD TO THIS SOFTWARE, INCLUDING ALL IMPLIED WARRANTIES
 * OF MERCHANTABILITY AND FITNESS.   IN NO EVENT SHALL DIGITAL EQUIPMENT
 * CORPORATION BE LIABLE FOR ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL
 * DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR
 * PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS
 * ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS
 * SOFTWARE.
 * -
 * --Copyright--
 *//Users/owura/Repos/codeql_eval/proj_repos/the-tcpdump-group-tcpdump-commit-9ba91381954ad325ea4fd26b9c65a8bd9a2a85b6/tcpdump/print-domain.c"nameser.h"ns_printconst HEADERconst HEADER *b2(ndo, "domain")(ndo, " [length %u < %zu]", length, sizeof(*np))(ndo, " (invalid)")sizeof(*np)domain [length %u < %zu] (invalid)*np&np->qdcount&np->ancount&np->nscount&np->arcount(ndo, "%d%s%s%s%s%s%s", EXTRACT_16BITS(&np->id), ns_ops[DNS_OPCODE(np)], ns_resp[DNS_RCODE(np)], DNS_AA(np)? "*" : "", DNS_RA(np)? "" : "-", DNS_TC(np)? "|" : "", DNS_AD(np)? "$" : "")(ndo, "%d%s%s%s%s%s%s", ((uint16_t)(((uint16_t)(*((const uint8_t *)(&np->id) + 0)) << 8) | ((uint16_t)(*((const uint8_t *)(&np->id) + 1)) << 0))), ns_ops[((((np)->flags1) >> 3) & 0xF)], ns_resp[((np)->flags2 & 0xF)], ((np)->flags1 & 0x04)? "*" : "", ((np)->flags2 & 0x80)? "" : "-", ((np)->flags1 & 0x02)? "|" : "", ((np)->flags2 & 0x20)? "$" : "")&np->id(ndo, " [%dq]", qdcount)(ndo, " q:")(ndo, " %d/%d/%d", ancount, nscount, arcount)(ndo, " ns:")(ndo, " ar:")(ndo, "%d%s%s%s", EXTRACT_16BITS(&np->id), ns_ops[DNS_OPCODE(np)], DNS_RD(np) ? "+" : "", DNS_CD(np) ? "%" : "")(ndo, "%d%s%s%s", ((uint16_t)(((uint16_t)(*((const uint8_t *)(&np->id) + 0)) << 8) | ((uint16_t)(*((const uint8_t *)(&np->id) + 1)) << 0))), ns_ops[((((np)->flags1) >> 3) & 0xF)], ((np)->flags1 & 0x01) ? "+" : "", ((np)->flags2 & 0x10) ? "%" : "")((const u_short *)np)+1(ndo, " [b2&3=0x%x]", b2)(ndo, " [%da]", ancount)(ndo, " [%dn]", nscount)(ndo, " [%dau]", arcount)%d%s%s%s%s%s%sconst char *[16]char *[16]|$ [%dq] q: %d/%d/%d ns: ar:is_mdns%d%s%s%s%17430x6cf [b2&3=0x%x] [%da] [%dn] [%dau](ndo, " (%d)", length) (%d)(ndo, "[|domain]")[|domain]ns_rprintclassopt_flagstyp4294934527~C_CACHE_FLUSH(ndo, " %s", tok2str(ns_class2str, "(Class %d)", class))(Class %d)(ndo, " (Cache flush)") (Cache flush)(ndo, " [")(ndo, " %s", tok2str(ns_type2str, "Type%d", typ))const tok[62]tok[62]Type%d(ndo, " %s", intoa(htonl(EXTRACT_32BITS(cp))))(ndo, " %s", intoa((__builtin_constant_p(((uint32_t)(((uint32_t)(*((const uint8_t *)(cp) + 0)) << 24) | ((uint32_t)(*((const uint8_t *)(cp) + 1)) << 16) | ((uint32_t)(*((const uint8_t *)(cp) + 2)) << 8) | ((uint32_t)(*((const uint8_t *)(cp) + 3)) << 0)))) ? ((__uint32_t)((((__uint32_t)(((uint32_t)(((uint32_t)(*((const uint8_t *)(cp) + 0)) << 24) | ((uint32_t)(*((const uint8_t *)(cp) + 1)) << 16) | ((uint32_t)(*((const uint8_t *)(cp) + 2)) << 8) | ((uint32_t)(*((const uint8_t *)(cp) + 3)) << 0)))) & 0xff000000U) >> 24) | (((__uint32_t)(((uint32_t)(((uint32_t)(*((const uint8_t *)(cp) + 0)) << 24) | ((uint32_t)(*((const uint8_t *)(cp) + 1)) << 16) | ((uint32_t)(*((const uint8_t *)(cp) + 2)) << 8) | ((uint32_t)(*((const uint8_t *)(cp) + 3)) << 0)))) & 0x00ff0000U) >> 8) | (((__uint32_t)(((uint32_t)(((uint32_t)(*((const uint8_t *)(cp) + 0)) << 24) | ((uint32_t)(*((const uint8_t *)(cp) + 1)) << 16) | ((uint32_t)(*((const uint8_t *)(cp) + 2)) << 8) | ((uint32_t)(*((const uint8_t *)(cp) + 3)) << 0)))) & 0x0000ff00U) << 8) | (((__uint32_t)(((uint32_t)(((uint32_t)(*((const uint8_t *)(cp) + 0)) << 24) | ((uint32_t)(*((const uint8_t *)(cp) + 1)) << 16) | ((uint32_t)(*((const uint8_t *)(cp) + 2)) << 8) | ((uint32_t)(*((const uint8_t *)(cp) + 3)) << 0)))) & 0x000000ffU) << 24))) : _OSSwapInt32(((uint32_t)(((uint32_t)(*((const uint8_t *)(cp) + 0)) << 24) | ((uint32_t)(*((const uint8_t *)(cp) + 1)) << 16) | ((uint32_t)(*((const uint8_t *)(cp) + 2)) << 8) | ((uint32_t)(*((const uint8_t *)(cp) + 3)) << 0)))))))EXTRACT_32BITS(cp)((uint32_t)(((uint32_t)(*((const uint8_t *)(cp) + 0)) << 24) | ((uint32_t)(*((const uint8_t *)(cp) + 1)) << 16) | ((uint32_t)(*((const uint8_t *)(cp) + 2)) << 8) | ((uint32_t)(*((const uint8_t *)(cp) + 3)) << 0)))5 * 4(ndo, " %u", EXTRACT_32BITS(cp))(ndo, " %u", ((uint32_t)(((uint32_t)(*((const uint8_t *)(cp) + 0)) << 24) | ((uint32_t)(*((const uint8_t *)(cp) + 1)) << 16) | ((uint32_t)(*((const uint8_t *)(cp) + 2)) << 8) | ((uint32_t)(*((const uint8_t *)(cp) + 3)) << 0))))(ndo, " %d", EXTRACT_16BITS(cp))(ndo, " %d", ((uint16_t)(((uint16_t)(*((const uint8_t *)(cp) + 0)) << 8) | ((uint16_t)(*((const uint8_t *)(cp) + 1)) << 0))))(ndo, " \"")(ndo, ":%d %d %d", EXTRACT_16BITS(cp + 4), EXTRACT_16BITS(cp), EXTRACT_16BITS(cp + 2))(ndo, ":%d %d %d", ((uint16_t)(((uint16_t)(*((const uint8_t *)(cp + 4) + 0)) << 8) | ((uint16_t)(*((const uint8_t *)(cp + 4) + 1)) << 0))), ((uint16_t)(((uint16_t)(*((const uint8_t *)(cp) + 0)) << 8) | ((uint16_t)(*((const uint8_t *)(cp) + 1)) << 0))), ((uint16_t)(((uint16_t)(*((const uint8_t *)(cp + 2) + 0)) << 8) | ((uint16_t)(*((const uint8_t *)(cp + 2) + 1)) << 0))))(ndo, " %s", addrtostr6(cp, ntop_buf, sizeof(ntop_buf)))(ndo, " %u(bad plen)", pbit)*(cp + 1)sizeof(a) - pbyte&a0, sizeof(a)&a.s6_addr[pbyte]&a.__u6_addr.__u6_addr8[pbyte]cp + 1, sizeof(a) - pbyte(ndo, " %u %s", pbit, addrtostr6(&a, ntop_buf, sizeof(ntop_buf)))(ndo, " UDPsize=%u", class)(ndo, " DO")(ndo, " fudge=%u", EXTRACT_16BITS(cp))(ndo, " fudge=%u", ((uint16_t)(((uint16_t)(*((const uint8_t *)(cp) + 0)) << 8) | ((uint16_t)(*((const uint8_t *)(cp) + 1)) << 0))))(ndo, " maclen=%u", EXTRACT_16BITS(cp))(ndo, " maclen=%u", ((uint16_t)(((uint16_t)(*((const uint8_t *)(cp) + 0)) << 8) | ((uint16_t)(*((const uint8_t *)(cp) + 1)) << 0))))(ndo, " origid=%u", EXTRACT_16BITS(cp))(ndo, " origid=%u", ((uint16_t)(((uint16_t)(*((const uint8_t *)(cp) + 0)) << 8) | ((uint16_t)(*((const uint8_t *)(cp) + 1)) << 0))))(ndo, " error=%u", EXTRACT_16BITS(cp))(ndo, " error=%u", ((uint16_t)(((uint16_t)(*((const uint8_t *)(cp) + 0)) << 8) | ((uint16_t)(*((const uint8_t *)(cp) + 1)) << 0))))(ndo, " otherlen=%u", EXTRACT_16BITS(cp))(ndo, " otherlen=%u", ((uint16_t)(((uint16_t)(*((const uint8_t *)(cp) + 0)) << 8) | ((uint16_t)(*((const uint8_t *)(cp) + 1)) << 0)))) ":%d %d %dpbitpbyte-8~7 %u(bad plen) %u %ssizeof(a) UDPsize=%u DO fudge=%u maclen=%u origid=%u error=%u otherlen=%uns_qprint(ndo, " %s", tok2str(ns_type2str, "Type%d", i))~C_QU(ndo, i & C_QU ? " (QU)" : " (QM)")(ndo, i & 0x8000 ? " (QU)" : " (QM)") (QU) (QM)(ndo, "? ")? ns_cprintns_nprintcompresseltmax_offset4294967295(u_int)-1(ndo, "<BAD PTR>")(ndo, "<ELT %d>", elt)0x3fff<BAD PTR>4294967103~INDIR_MASK<ELT %d>labellenbitlenblabel_printslenbbitplimtc(ndo, "\\[x")\[x*bitpsizeof(*bitp)(ndo, "%02x", *bitp)(ndo, "%02x", tc & (0xff << (8 - b)))(ndo, "%1x", ((tc >> 4) & 0x0f) & (0x0f << (4 - b)))%1x(ndo, "/%d]", bitlen)/%d](ndo, ".../%d]", bitlen).../%d]ns_nskipbytelen-193IN"IN"CHAOS"CHAOS"HS"HS"ANY"ANY"ns_class2str"A"MD"MD"MF"MF"CNAME"CNAME"SOA"SOA"MB"MB"MG"MG"MR"MR"WKS"WKS"PTR"PTR"HINFO"HINFO"MINFO"MINFO"MX"MX"TXT"TXT"RP"RP"AFSDB"AFSDB"X25"X25"ISDN"ISDN"RT"RT"NSAP_PTR"NSAP_PTR"SIG"SIG"KEY"KEY"PX"PX"GPOS"GPOS"AAAA"AAAA"LOC"LOC"NXT"NXT"EID"EID"NIMLOC"NIMLOC"SRV"SRV"ATMA"ATMA"NAPTR"NAPTR"KX"KX"CERT"CERT"A6"A6"DNAME"DNAME"SINK"SINK"OPT"OPT"APL"APL"DS"DS"SSHFP"SSHFP"IPSECKEY"IPSECKEY"RRSIG"RRSIG"NSEC"NSEC"DNSKEY"DNSKEY"SPF"SPF"UINFO"UINFO"UID"UID"GID"GID"UNSPEC"UNSPEC"UNSPECA"UNSPECA"TKEY"TKEY"TSIG"TSIG"IXFR"IXFR"AXFR"AXFR"MAILB"MAILB"MAILA"MAILA"ns_type2str FormErr" FormErr" ServFail" ServFail" NXDomain" NXDomain" NotImp" NotImp" Refused" Refused" YXDomain" YXDomain" YXRRSet" YXRRSet" NXRRSet" NXRRSet" NotAuth" NotAuth" NotZone" NotZone" Resp11" Resp11" Resp12" Resp12" Resp13" Resp13" Resp14" Resp14" NoChange" NoChange"ns_resp inv_q" inv_q" stat" stat" op3" op3" notify" notify"" update" op6" op6" op7" op7" op8" op8" updateA" updateA" updateD" updateD" updateDA" updateDA" updateM" updateM" updateMA" updateMA" zoneInit" zoneInit" zoneRef" zoneRef"ns_ops/* Print remaining sections on -vv *//* any weirdness? *//* this is a request *//* Print NS and AR sections on -vv *//* skip QTYPE and QCLASS *//* Print QUESTION section on -vv *//* this is a response *//* get the byte-order right *//* XXX This isn't always right *//* One long string *//* ignore ttl *//* print ttl *//* ignore rest of ttl field *//* get opt flags *//* print the class (if it's not IN and the type isn't OPT) *//* print the type/qtype *//* print a reply *//* print the qclass (if it's not IN) *//* print the qtype *//* print a query *//* Not used *//* RFC 1035 *//* RFC 1995 *//* RFC 2845 *//* RFC 2930 *//* RFC-schlitt-spf-classic-02.txt *//* RFC 4034 *//* RFC 4025 *//* RFC 4255 *//* RFC 3123 *//* RFC 2671 *//* RFC 2672 *//* RFC 2874 *//* RFC 2538 *//* RFC 2230 *//* RFC 2168, RFC 2915 *//* RFC 2782 *//* Nimrod *//* RFC 2535 *//* RFC 1876 *//* RFC 1886 *//* RFC 1712 *//* RFC 2163 *//* RFC 1706 *//* RFC 1183 *//* http://www.iana.org/assignments/dns-parameters *//* print a <character-string> *//* unknown ELT *//*
				 * This must move backwards in the packet.
				 * No RFC explicitly says that, but BIND's
				 * name decompression code requires it,
				 * as a way of preventing infinite loops
				 * and other bad behavior, and it's probably
				 * what was intended (compress by pointing
				 * to domain name suffixes already seen in
				 * the packet).
				 *//* print the bit string as a hex string *//* print a <domain-name> *//* skip over a domain name *//* \summary: Domain Name System (DNS) printer *//Users/owura/Repos/codeql_eval/proj_repos/the-tcpdump-group-tcpdump-commit-9ba91381954ad325ea4fd26b9c65a8bd9a2a85b6/tcpdump/print-dtp.cdtp_printDTP_HEADER_LEN(ndo, "DTPv%u, length %u", (*tptr), length)DTPv%u, length %u(ndo, "\n\t%s (0x%04x) TLV, length %u", tok2str(dtp_tlv_values, "Unknown", type), type, len)(ndo, ", 0x%x", *(tptr+4))(ndo, ", %s", etheraddr_string(ndo, tptr+4))
	%s (0x%04x) TLV, length %uDTP_DOMAIN_TLVDTP_STATUS_TLVDTP_DTP_TYPE_TLV, 0x%xDTP_NEIGHBOR_TLVDomain TLV"Domain TLV"Status TLV"Status TLV"DTP type TLV"DTP type TLV"Neighbor TLV"Neighbor TLV"dtp_tlv_values [|dtp]" [|dtp]"/* infinite loop check *//* XXX: should not be but sometimes it is, see the test captures *//*
     * In non-verbose mode, just print version.
     *//* \summary: Dynamic Trunking Protocol (DTP) printer *//*
 * Copyright (c) 1998-2007 The TCPDUMP project
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that: (1) source code
 * distributions retain the above copyright notice and this paragraph
 * in its entirety, and (2) distributions including binary code include
 * the above copyright notice and this paragraph in its entirety in
 * the documentation or other materials provided with the distribution.
 * THIS SOFTWARE IS PROVIDED ``AS IS'' AND
 * WITHOUT ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, WITHOUT
 * LIMITATION, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS
 * FOR A PARTICULAR PURPOSE.
 *
 * Original code by Carles Kishimoto <carles.kishimoto@gmail.com>
 *//Users/owura/Repos/codeql_eval/proj_repos/the-tcpdump-group-tcpdump-commit-9ba91381954ad325ea4fd26b9c65a8bd9a2a85b6/tcpdump/print-dvmrp.cprint_graft_ack(ndo, " src %s grp %s", ipaddr_string(ndo, bp), ipaddr_string(ndo, bp + 4))(ndo, " src %s grp %s", getname(ndo, (const u_char *)(bp)), getname(ndo, (const u_char *)(bp + 4))) src %s grp %sbp + 4print_graftprint_prune(ndo, " timer ") timer print_neighbors2laddrthreshncount(ndo, " (v %d.%d):", major_version, minor_version) (v %d.%d):(ndo, " [%s -> ", ipaddr_string(ndo, laddr))(ndo, " [%s -> ", getname(ndo, (const u_char *)(laddr)))(ndo, "%s (%d/%d", ipaddr_string(ndo, bp), metric, thresh)(ndo, "%s (%d/%d", getname(ndo, (const u_char *)(bp)), metric, thresh)(ndo, "/tunnel")(ndo, "/srcrt")(ndo, "/querier")(ndo, "/disabled")(ndo, "/down")(ndo, ")]")(ndo, " [|]") [%s -> %s (%d/%dDVMRP_NF_TUNNEL/tunnelDVMRP_NF_SRCRT/srcrtDVMRP_NF_QUERIER/querierDVMRP_NF_DISABLED/disabledDVMRP_NF_DOWN/down)] [|]print_neighbors(ndo, " [%s ->", ipaddr_string(ndo, laddr))(ndo, " [%s ->", getname(ndo, (const u_char *)(laddr)))(ndo, " %s, (%d/%d)]", ipaddr_string(ndo, bp), metric, thresh)(ndo, " %s, (%d/%d)]", getname(ndo, (const u_char *)(bp)), metric, thresh)major_versionminor_version [%s -> %s, (%d/%d)]print_probegenid(ndo, " [|}") [|}(ndo, ndo->ndo_vflag > 1 ? "\n\t" : " ")(ndo, "genid %u", genid)genid %u(ndo, "\n\tneighbor %s", ipaddr_string(ndo, bp))(ndo, "\n\tneighbor %s", getname(ndo, (const u_char *)(bp)))
	neighbor %sprint_reportwidth(ndo, "\n\tMask %s", intoa(htonl(mask)))(ndo, "\n\tMask %s", intoa((__builtin_constant_p(mask) ? ((__uint32_t)((((__uint32_t)(mask) & 0xff000000U) >> 24) | (((__uint32_t)(mask) & 0x00ff0000U) >> 8) | (((__uint32_t)(mask) & 0x0000ff00U) << 8) | (((__uint32_t)(mask) & 0x000000ffU) << 24))) : _OSSwapInt32(mask))))(ndo, "\n\t  [Truncated Report]")sizeof(*bp)(ndo, "\n\t  %s metric %d", intoa(htonl(origin)), metric)(ndo, "\n\t  %s metric %d", intoa((__builtin_constant_p(origin) ? ((__uint32_t)((((__uint32_t)(origin) & 0xff000000U) >> 24) | (((__uint32_t)(origin) & 0x00ff0000U) >> 8) | (((__uint32_t)(origin) & 0x0000ff00U) << 8) | (((__uint32_t)(origin) & 0x000000ffU) << 24))) : _OSSwapInt32(origin))), metric)(uint32_t)0xff(uint32_t)0xff << 24
	Mask %s
	  [Truncated Report]0x7f
	  %s metric %ddvmrp_printbp[1]sizeof(bp[1])(ndo, " Probe")(ndo, " Report")(ndo, " Ask-neighbors(old)")(ndo, " Neighbors(old)")(ndo, " Ask-neighbors2")(ndo, " Neighbors2")(ndo, " Prune")(ndo, " Graft")(ndo, " Graft-ACK")(ndo, " [type %d]", type)DVMRP_PROBE ProbeDVMRP_REPORT ReportDVMRP_ASK_NEIGHBORS Ask-neighbors(old)DVMRP_NEIGHBORS Neighbors(old)DVMRP_ASK_NEIGHBORS2 Ask-neighbors2DVMRP_NEIGHBORS2 Neighbors2DVMRP_PRUNE PruneDVMRP_GRAFT GraftDVMRP_GRAFT_ACK Graft-ACK [type %d](ndo, "[|dvmrp]")[|dvmrp]/* { (ctags) *//*
		 * extract version from IGMP group address field
		 *//* Skip IGMP header *//* I am the subnet's querier *//* administratively disabled *//* kernel state of interface *//* tunnel uses IP source routing *//* neighbors reached via tunnel *//*
 * 'flags' byte values in DVMRP_NEIGHBORS2 reply.
 *//* graft acknowledgement *//* graft message *//* prune message *//* as above, want new format reply *//* response to such a request *//* of this router's neighbors *//* sent by mapper, asking for a list *//* for reporting some or all routes *//* for finding neighbors *//*
 * See: RFC 1075 and draft-ietf-idmr-dvmrp-v3
 *
 * DVMRP message types and flag values shamelessly stolen from
 * mrouted/dvmrp.h.
 *//* \summary: Distance Vector Multicast Routing Protocol printer *//*
 * Copyright (c) 1995, 1996
 *	The Regents of the University of California.  All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that: (1) source code distributions
 * retain the above copyright notice and this paragraph in its entirety, (2)
 * distributions including binary code include the above copyright notice and
 * this paragraph in its entirety in the documentation or other materials
 * provided with the distribution, and (3) all advertising materials mentioning
 * features or use of this software display the following acknowledgement:
 * ``This product includes software developed by the University of California,
 * Lawrence Berkeley Laboratory and its contributors.'' Neither the name of
 * the University nor the names of its contributors may be used to endorse
 * or promote products derived from this software without specific prior
 * written permission.
 * THIS SOFTWARE IS PROVIDED ``AS IS'' AND WITHOUT ANY EXPRESS OR IMPLIED
 * WARRANTIES, INCLUDING, WITHOUT LIMITATION, THE IMPLIED WARRANTIES OF
 * MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE.
 *//Users/owura/Repos/codeql_eval/proj_repos/the-tcpdump-group-tcpdump-commit-9ba91381954ad325ea4fd26b9c65a8bd9a2a85b6/tcpdump/print-eap.ceap_printconst eap_frame_tconst eap_frame_t *eap_frame_t *eap*eapsizeof(*eap)(ndo, "%s (%u) v%u, len %u", tok2str(eap_frame_type_values, "unknown", eap->type), eap->type, eap->version, EXTRACT_16BITS(eap->length))(ndo, "%s (%u) v%u, len %u", tok2str(eap_frame_type_values, "unknown", eap->type), eap->type, eap->version, ((uint16_t)(((uint16_t)(*((const uint8_t *)(eap->length) + 0)) << 8) | ((uint16_t)(*((const uint8_t *)(eap->length) + 1)) << 0))))eap->length%s (%u) v%u, len %usizeof(const struct eap_frame_t)*(tptr)(ndo, ", %s (%u), id %u, len %u", tok2str(eap_code_values, "unknown", type), type, *(tptr+1), len)*(tptr+4)(ndo, "\n\t\t Type %s (%u)", tok2str(eap_type_values, "unknown", subtype), subtype)(ndo, ", Identity: ")(ndo, ", Notification: ")tptr+count*(tptr+count)(ndo, " %s (%u),", tok2str(eap_type_values, "unknown", *(tptr+count)), *(tptr + count))tptr + 5*(tptr + 5)(ndo, " TTLSv%u", EAP_TTLS_VERSION(*(tptr + 5)))(ndo, " TTLSv%u", ((*(tptr + 5))&0x07))(ndo, " flags [%s] 0x%02x,", bittok2str(eap_tls_flags_values, "none", *(tptr+5)), *(tptr + 5))*(tptr+5)tptr + 6*(tptr + 6)(ndo, " len %u", EXTRACT_32BITS(tptr + 6))(ndo, " len %u", ((uint32_t)(((uint32_t)(*((const uint8_t *)(tptr + 6) + 0)) << 24) | ((uint32_t)(*((const uint8_t *)(tptr + 6) + 1)) << 16) | ((uint32_t)(*((const uint8_t *)(tptr + 6) + 2)) << 8) | ((uint32_t)(*((const uint8_t *)(tptr + 6) + 3)) << 0))))(ndo, " FASTv%u", EAP_TTLS_VERSION(*(tptr + 5)))(ndo, " FASTv%u", ((*(tptr + 5))&0x07))(ndo, " subtype [%s] 0x%02x,", tok2str(eap_aka_subtype_values, "unknown", *(tptr+5)), *(tptr + 5))EAP_FRAME_TYPE_PACKET, %s (%u), id %u, len %u
		 Type %s (%u)EAP_TYPE_IDENTITY, Identity: EAP_TYPE_NOTIFICATION, Notification: EAP_TYPE_NAK %s (%u),EAP_TYPE_TTLSEAP_TYPE_TLS TTLSv%u flags [%s] 0x%02x, len %uEAP_TYPE_FAST FASTv%uEAP_TYPE_AKAEAP_TYPE_SIM subtype [%s] 0x%02x,EAP_TYPE_MD5_CHALLENGEEAP_TYPE_OTPEAP_TYPE_GTCEAP_TYPE_EXPANDED_TYPESEAP_TYPE_EXPERIMENTALEAP_FRAME_TYPE_LOGOFFEAP_FRAME_TYPE_ENCAP_ASF_ALERT(ndo, "\n\t[|EAP]")
	[|EAP]eap_packet_teap_frame_tEAP_AKA_CHALLENGEChallenge"Challenge"EAP_AKA_AUTH_REJECTAuth reject"Auth reject"EAP_AKA_SYNC_FAILURESync failure"Sync failure"EAP_AKA_IDENTITYIdentity"Identity"EAP_SIM_STARTStart"Start"EAP_SIM_CHALLENGEEAP_AKA_NOTIFICATIONEAP_AKA_REAUTHReauth"Reauth"EAP_AKA_CLIENT_ERRORClient error"Client error"eap_aka_subtype_valuesEAP_TLS_FLAGS_LEN_INCLUDEDL bit"L bit"EAP_TLS_FLAGS_MORE_FRAGMENTSMore fragments bit"More fragments bit"EAP_TLS_FLAGS_STARTStart bit"Start bit"eap_tls_flags_valuesEAP_TYPE_NO_PROPOSEDNo proposed"No proposed"Nak"Nak"MD5-challenge"MD5-challenge"OTP"OTP"GTC"GTC"TLS"TLS"SIM"SIM"TTLS"TTLS"AKA"AKA"FAST"FAST"Expanded types"Expanded types"Experimental"Experimental"eap_type_valuesEAP_REQUESTEAP_RESPONSEEAP_SUCCESSEAP_FAILUREFailure"Failure"eap_code_valuesEAP packet"EAP packet"EAP_FRAME_TYPE_STARTEAPOL start"EAPOL start"EAPOL logoff"EAPOL logoff"EAP_FRAME_TYPE_KEYEAPOL key"EAPOL key"Encapsulated ASF alert"Encapsulated ASF alert"eap_frame_type_valuesEAP_TTLS_VERSION(x)((x)&0x07)(1 << 5)(1 << 6)(1 << 7)EAP_TLS_EXTRACT_BIT_L(x)(((x)&0x80)>>7)/*
 * Local Variables:
 * c-basic-offset: 4
 * End:
 *//* FIXME - TLV attributes follow *//*
                 * one or more octets indicating
                 * the desired authentication
                 * type one octet per type
                 *//* For EAP_REQUEST and EAP_RESPONSE only *//* in non-verbose mode just lets print the basic info *//*
 * Print EAP requests / responses
 *//* EAP-AKA and EAP-SIM - RFC 4187 *//* RFC 2716 - EAP TLS bits *//* RFC 4851 *//* RFC 4187 *//* draft-funk-eap-ttls-v0-01.txt *//* RFC 4186 *//* RFC 2716 *//* RFC 3748 *//* \summary: Extensible Authentication Protocol (EAP) printer *//*
 * Copyright (c) 2004 - Michael Richardson <mcr@xelerance.com>
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that: (1) source code distributions
 * retain the above copyright notice and this paragraph in its entirety, (2)
 * distributions including binary code include the above copyright notice and
 * this paragraph in its entirety in the documentation or other materials
 * provided with the distribution, and (3) all advertising materials mentioning
 * features or use of this software display the following acknowledgement:
 * ``This product includes software developed by the University of California,
 * Lawrence Berkeley Laboratory and its contributors.'' Neither the name of
 * the University nor the names of its contributors may be used to endorse
 * or promote products derived from this software without specific prior
 * written permission.
 * THIS SOFTWARE IS PROVIDED ``AS IS'' AND WITHOUT ANY EXPRESS OR IMPLIED
 * WARRANTIES, INCLUDING, WITHOUT LIMITATION, THE IMPLIED WARRANTIES OF
 * MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE.
 *//Users/owura/Repos/codeql_eval/proj_repos/the-tcpdump-group-tcpdump-commit-9ba91381954ad325ea4fd26b9c65a8bd9a2a85b6/tcpdump/print-egp.cegp_printconst egp_packetconst egp_packet *egp_packet *status*egpsizeof(*egp)(ndo, "[|egp]")[|egp](ndo, "EGPv%u, AS %u, seq %u, length %u", egp->egp_version, EXTRACT_16BITS(&egp->egp_as), EXTRACT_16BITS(&egp->egp_sequence), length)(ndo, "EGPv%u, AS %u, seq %u, length %u", egp->egp_version, ((uint16_t)(((uint16_t)(*((const uint8_t *)(&egp->egp_as) + 0)) << 8) | ((uint16_t)(*((const uint8_t *)(&egp->egp_as) + 1)) << 0))), ((uint16_t)(((uint16_t)(*((const uint8_t *)(&egp->egp_sequence) + 0)) << 8) | ((uint16_t)(*((const uint8_t *)(&egp->egp_sequence) + 1)) << 0))), length)&egp->egp_as&egp->egp_sequence(ndo, "EGPv%u, length %u", egp->egp_version, length)EGPv%u, AS %u, seq %u, length %uEGPv%u, length %u(ndo, "[version %d]", egp->egp_version)EGP_VERSION[version %d](ndo, " acquire")(ndo, " %s", egp_acquire_codes[code])(ndo, " %s", egp_acquire_status[status])(ndo, " [status %d]", status)(ndo, " hello:%d poll:%d", EXTRACT_16BITS(&egp->egp_hello), EXTRACT_16BITS(&egp->egp_poll))(ndo, " hello:%d poll:%d", ((uint16_t)(((uint16_t)(*((const uint8_t *)(&egp->egp_handg.egpu_hello) + 0)) << 8) | ((uint16_t)(*((const uint8_t *)(&egp->egp_handg.egpu_hello) + 1)) << 0))), ((uint16_t)(((uint16_t)(*((const uint8_t *)(&egp->egp_pands.egpu_poll) + 0)) << 8) | ((uint16_t)(*((const uint8_t *)(&egp->egp_pands.egpu_poll) + 1)) << 0))))&egp->egp_hello&egp->egp_handg.egpu_hello&egp->egp_poll&egp->egp_pands.egpu_poll(ndo, "[status %d]", status)(ndo, "[code %d]", code)(ndo, " %s", egp_reach_codes[code])(ndo, " state:%s", egp_status_updown[status])(ndo, "[reach code %d]", code)(ndo, " poll")(ndo, " net:%s", ipaddr_string(ndo, &egp->egp_sourcenet))(ndo, " net:%s", getname(ndo, (const u_char *)(&egp->egp_pands.egpu_sourcenet)))&egp->egp_sourcenet&egp->egp_pands.egpu_sourcenet(ndo, " unsolicited")(ndo, " %s int %d ext %d", ipaddr_string(ndo, &egp->egp_sourcenet), egp->egp_intgw, egp->egp_extgw)(ndo, " %s int %d ext %d", getname(ndo, (const u_char *)(&egp->egp_pands.egpu_sourcenet)), egp->egp_handg.egpu_gws[0], egp->egp_handg.egpu_gws[1])(ndo, " error")&egp->egp_reason&egp->egp_handg.egpu_reason(ndo, " %s", egp_reasons[EXTRACT_16BITS(&egp->egp_reason)])(ndo, " %s", egp_reasons[((uint16_t)(((uint16_t)(*((const uint8_t *)(&egp->egp_handg.egpu_reason) + 0)) << 8) | ((uint16_t)(*((const uint8_t *)(&egp->egp_handg.egpu_reason) + 1)) << 0)))])(ndo, " [reason %d]", EXTRACT_16BITS(&egp->egp_reason))(ndo, " [reason %d]", ((uint16_t)(((uint16_t)(*((const uint8_t *)(&egp->egp_handg.egpu_reason) + 0)) << 8) | ((uint16_t)(*((const uint8_t *)(&egp->egp_handg.egpu_reason) + 1)) << 0))))(ndo, "[type %d]", type)EGPT_ACQUIRE acquireEGPC_REQUESTEGPC_CONFIRMconst char *[5]char *[5]EGPS_UNSPECEGPS_ACTIVEEGPS_PASSIVE [status %d] hello:%d poll:%dEGPC_REFUSEEGPC_CEASEEGPC_CEASEACKEGPS_NORESEGPS_ADMINEGPS_GODOWNEGPS_PARAMEGPS_PROTO[status %d][code %d]EGPT_REACHEGPC_HELLOEGPC_HEARDUconst char *[2]char *[2]EGPS_DOWN state:%s[reach code %d]EGPT_POLL poll net:%sEGPT_UPDATEEGPS_UNSOL-129~EGPS_UNSOL unsolicited %s int %d ext %dEGPT_ERROR errorEGPR_UVERSIONconst char *[7]char *[7] [reason %d][type %d]egpnrprintnetlengatewaysdistancesnetworkst_gatewayscommaIN_CLASSA_NET32212254724294901760IN_CLASSB_NET37580963844294967040IN_CLASSC_NETcp[0]4 - netlen(ndo, " %s %s ", gateways < (int)egp->egp_intgw ? "int" : "ext", ipaddr_string(ndo, &addr))(ndo, " %s %s ", gateways < (int)egp->egp_handg.egpu_gws[0] ? "int" : "ext", getname(ndo, (const u_char *)(&addr)))(ndo, "%sd%d:", comma, (int)*cp++)(ndo, " %s", ipaddr_string(ndo, &addr))(ndo, " %s", getname(ndo, (const u_char *)(&addr))) %s %s ext%sd%d:(ndo, "[|]")[|]egp_packetegp_pandsegp_handgegp_sequenceegp_asegp_checksumegp_statusegp_codeegp_typeegp_versionegpu_sourcenetegpu_pollegpu_reasonegpu_gwsegpu_hellobad_EGP_header_format"bad_EGP_header_format"bad_EGP_data_field_format"bad_EGP_data_field_format"reachability_info_unavailable"reachability_info_unavailable"excessive_polling_rate"excessive_polling_rate"no_response"no_response"unsupported_version"unsupported_version"egp_reasonsindeterminate"indeterminate"up"up"down"down"egp_status_updown"hello"i-h-u"i-h-u"egp_reach_codesactive_mode"active_mode"passive_mode"passive_mode"insufficient_resources"insufficient_resources"administratively_prohibited"administratively_prohibited"going_down"going_down"parameter_violation"parameter_violation"protocol_violation"protocol_violation"egp_acquire_statusrefuse"refuse"cease"cease"cease_ack"cease_ack"egp_acquire_codesegp_sourcenetegp_pands.egpu_sourcenetegp_pollegp_pands.egpu_pollegp_reasonegp_handg.egpu_reasonegp_extgwegp_handg.egpu_gws[1]egp_intgwegp_handg.egpu_gws[0]egp_helloegp_handg.egpu_helloEGPR_NORESPEGPR_XSPOLLEGPR_NOREACHEGPR_BADDATAEGPR_BADHEADEGPR_UNSPECEGPS_UPEGPS_INDET/* Pickup network number *//* Pickup host part of gateway address *//* \summary: Exterior Gateway Protocol (EGP) printer *//*
 * Copyright (c) 1991, 1992, 1993, 1994, 1995, 1996
 *	The Regents of the University of California.  All rights reserved.
 *
 * Redistribution and use in source and binary forms are permitted
 * provided that the above copyright notice and this paragraph are
 * duplicated in all such forms and that any documentation,
 * advertising materials, and other materials related to such
 * distribution and use acknowledge that the software was developed
 * by the University of California, Lawrence Berkeley Laboratory,
 * Berkeley, CA.  The name of the University may not be used to
 * endorse or promote products derived from this software without
 * specific prior written permission.
 * THIS SOFTWARE IS PROVIDED ``AS IS'' AND WITHOUT ANY EXPRESS OR
 * IMPLIED WARRANTIES, INCLUDING, WITHOUT LIMITATION, THE IMPLIED
 * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE.
 *
 * Initial contribution from Jeff Honig (jch@MITCHELL.CIT.CORNELL.EDU).
 *//Users/owura/Repos/codeql_eval/proj_repos/the-tcpdump-group-tcpdump-commit-9ba91381954ad325ea4fd26b9c65a8bd9a2a85b6/tcpdump/print-eigrp.ceigrp_printconst eigrp_common_headerconst eigrp_common_header *eigrp_common_header *eigrp_com_headerconst eigrp_tlv_headerconst eigrp_tlv_header *eigrp_tlv_header *eigrp_tlv_headertlv_tptreigrp_tlv_leneigrp_tlv_typetlv_tlenbyte_lengthbit_length*eigrp_com_headersizeof(*eigrp_com_header)(ndo, "EIGRP version %u packet not supported",eigrp_com_header->version)EIGRP_VERSIONEIGRP version %u packet not supported(ndo, "EIGRP %s, length: %u", tok2str(eigrp_opcode_values, "unknown (%u)",eigrp_com_header->opcode), len)EIGRP %s, length: %u(ndo, "EIGRP %s, length: %u (too short, < %u)", tok2str(eigrp_opcode_values, "unknown (%u)",eigrp_com_header->opcode), len, (u_int) sizeof(struct eigrp_common_header))sizeof(struct eigrp_common_header)EIGRP %s, length: %u (too short, < %u)(ndo, "\n\tEIGRP v%u, opcode: %s (%u), chksum: 0x%04x, Flags: [%s]\n\tseq: 0x%08x, ack: 0x%08x, AS: %u, length: %u", eigrp_com_header->version, tok2str(eigrp_opcode_values, "unknown, type: %u",eigrp_com_header->opcode), eigrp_com_header->opcode, EXTRACT_16BITS(&eigrp_com_header->checksum), tok2str(eigrp_common_header_flag_values, "none", EXTRACT_32BITS(&eigrp_com_header->flags)), EXTRACT_32BITS(&eigrp_com_header->seq), EXTRACT_32BITS(&eigrp_com_header->ack), EXTRACT_32BITS(&eigrp_com_header->asn), tlen)(ndo, "\n\tEIGRP v%u, opcode: %s (%u), chksum: 0x%04x, Flags: [%s]\n\tseq: 0x%08x, ack: 0x%08x, AS: %u, length: %u", eigrp_com_header->version, tok2str(eigrp_opcode_values, "unknown, type: %u",eigrp_com_header->opcode), eigrp_com_header->opcode, ((uint16_t)(((uint16_t)(*((const uint8_t *)(&eigrp_com_header->checksum) + 0)) << 8) | ((uint16_t)(*((const uint8_t *)(&eigrp_com_header->checksum) + 1)) << 0))), tok2str(eigrp_common_header_flag_values, "none", ((uint32_t)(((uint32_t)(*((const uint8_t *)(&eigrp_com_header->flags) + 0)) << 24) | ((uint32_t)(*((const uint8_t *)(&eigrp_com_header->flags) + 1)) << 16) | ((uint32_t)(*((const uint8_t *)(&eigrp_com_header->flags) + 2)) << 8) | ((uint32_t)(*((const uint8_t *)(&eigrp_com_header->flags) + 3)) << 0)))), ((uint32_t)(((uint32_t)(*((const uint8_t *)(&eigrp_com_header->seq) + 0)) << 24) | ((uint32_t)(*((const uint8_t *)(&eigrp_com_header->seq) + 1)) << 16) | ((uint32_t)(*((const uint8_t *)(&eigrp_com_header->seq) + 2)) << 8) | ((uint32_t)(*((const uint8_t *)(&eigrp_com_header->seq) + 3)) << 0))), ((uint32_t)(((uint32_t)(*((const uint8_t *)(&eigrp_com_header->ack) + 0)) << 24) | ((uint32_t)(*((const uint8_t *)(&eigrp_com_header->ack) + 1)) << 16) | ((uint32_t)(*((const uint8_t *)(&eigrp_com_header->ack) + 2)) << 8) | ((uint32_t)(*((const uint8_t *)(&eigrp_com_header->ack) + 3)) << 0))), ((uint32_t)(((uint32_t)(*((const uint8_t *)(&eigrp_com_header->asn) + 0)) << 24) | ((uint32_t)(*((const uint8_t *)(&eigrp_com_header->asn) + 1)) << 16) | ((uint32_t)(*((const uint8_t *)(&eigrp_com_header->asn) + 2)) << 8) | ((uint32_t)(*((const uint8_t *)(&eigrp_com_header->asn) + 3)) << 0))), tlen)
	EIGRP v%u, opcode: %s (%u), chksum: 0x%04x, Flags: [%s]
	seq: 0x%08x, ack: 0x%08x, AS: %u, length: %uchar[104]unknown, type: %u&eigrp_com_header->checksum&eigrp_com_header->flags&eigrp_com_header->seq&eigrp_com_header->ack&eigrp_com_header->asnsizeof(const struct eigrp_common_header)sizeof(struct eigrp_tlv_header)&eigrp_tlv_header->length&eigrp_tlv_header->type(ndo, "\n\t  %s TLV (0x%04x), length: %u", tok2str(eigrp_tlv_values, "Unknown", eigrp_tlv_type), eigrp_tlv_type, eigrp_tlv_len)(ndo, " (too short, < %u)", (u_int) sizeof(struct eigrp_tlv_header))(ndo, " (too short, < %u)", (u_int) (sizeof(struct eigrp_tlv_header) + sizeof(*tlv_ptr.eigrp_tlv_general_parm)))(ndo, "\n\t    holdtime: %us, k1 %u, k2 %u, k3 %u, k4 %u, k5 %u", EXTRACT_16BITS(tlv_ptr.eigrp_tlv_general_parm->holdtime), tlv_ptr.eigrp_tlv_general_parm->k1, tlv_ptr.eigrp_tlv_general_parm->k2, tlv_ptr.eigrp_tlv_general_parm->k3, tlv_ptr.eigrp_tlv_general_parm->k4, tlv_ptr.eigrp_tlv_general_parm->k5)(ndo, "\n\t    holdtime: %us, k1 %u, k2 %u, k3 %u, k4 %u, k5 %u", ((uint16_t)(((uint16_t)(*((const uint8_t *)(tlv_ptr.eigrp_tlv_general_parm->holdtime) + 0)) << 8) | ((uint16_t)(*((const uint8_t *)(tlv_ptr.eigrp_tlv_general_parm->holdtime) + 1)) << 0))), tlv_ptr.eigrp_tlv_general_parm->k1, tlv_ptr.eigrp_tlv_general_parm->k2, tlv_ptr.eigrp_tlv_general_parm->k3, tlv_ptr.eigrp_tlv_general_parm->k4, tlv_ptr.eigrp_tlv_general_parm->k5)tlv_ptr.eigrp_tlv_general_parm->holdtime(ndo, " (too short, < %u)", (u_int) (sizeof(struct eigrp_tlv_header) + sizeof(*tlv_ptr.eigrp_tlv_sw_version)))(ndo, "\n\t    IOS version: %u.%u, EIGRP version %u.%u", tlv_ptr.eigrp_tlv_sw_version->ios_major, tlv_ptr.eigrp_tlv_sw_version->ios_minor, tlv_ptr.eigrp_tlv_sw_version->eigrp_major, tlv_ptr.eigrp_tlv_sw_version->eigrp_minor)(ndo, " (too short, < %u)", (u_int) (sizeof(struct eigrp_tlv_header) + sizeof(*tlv_ptr.eigrp_tlv_ip_int)))(ndo, "\n\t    illegal prefix length %u",bit_length)0, 4tlv_ptr.eigrp_tlv_ip_int->destination&tlv_ptr.eigrp_tlv_ip_int->destination,byte_length(ndo, "\n\t    IPv4 prefix: %15s/%u, nexthop: ", ipaddr_string(ndo, prefix), bit_length)(ndo, "\n\t    IPv4 prefix: %15s/%u, nexthop: ", getname(ndo, (const u_char *)(prefix)), bit_length)&tlv_ptr.eigrp_tlv_ip_int->nexthop(ndo, "self")(ndo, "%s",ipaddr_string(ndo, &tlv_ptr.eigrp_tlv_ip_int->nexthop))(ndo, "%s",getname(ndo, (const u_char *)(&tlv_ptr.eigrp_tlv_ip_int->nexthop)))(ndo, "\n\t      delay %u ms, bandwidth %u Kbps, mtu %u, hop %u, reliability %u, load %u", (EXTRACT_32BITS(&tlv_ptr.eigrp_tlv_ip_int->delay)/100), EXTRACT_32BITS(&tlv_ptr.eigrp_tlv_ip_int->bandwidth), EXTRACT_24BITS(&tlv_ptr.eigrp_tlv_ip_int->mtu), tlv_ptr.eigrp_tlv_ip_int->hopcount, tlv_ptr.eigrp_tlv_ip_int->reliability, tlv_ptr.eigrp_tlv_ip_int->load)(ndo, "\n\t      delay %u ms, bandwidth %u Kbps, mtu %u, hop %u, reliability %u, load %u", (((uint32_t)(((uint32_t)(*((const uint8_t *)(&tlv_ptr.eigrp_tlv_ip_int->delay) + 0)) << 24) | ((uint32_t)(*((const uint8_t *)(&tlv_ptr.eigrp_tlv_ip_int->delay) + 1)) << 16) | ((uint32_t)(*((const uint8_t *)(&tlv_ptr.eigrp_tlv_ip_int->delay) + 2)) << 8) | ((uint32_t)(*((const uint8_t *)(&tlv_ptr.eigrp_tlv_ip_int->delay) + 3)) << 0)))/100), ((uint32_t)(((uint32_t)(*((const uint8_t *)(&tlv_ptr.eigrp_tlv_ip_int->bandwidth) + 0)) << 24) | ((uint32_t)(*((const uint8_t *)(&tlv_ptr.eigrp_tlv_ip_int->bandwidth) + 1)) << 16) | ((uint32_t)(*((const uint8_t *)(&tlv_ptr.eigrp_tlv_ip_int->bandwidth) + 2)) << 8) | ((uint32_t)(*((const uint8_t *)(&tlv_ptr.eigrp_tlv_ip_int->bandwidth) + 3)) << 0))), ((uint32_t)(((uint32_t)(*((const uint8_t *)(&tlv_ptr.eigrp_tlv_ip_int->mtu) + 0)) << 16) | ((uint32_t)(*((const uint8_t *)(&tlv_ptr.eigrp_tlv_ip_int->mtu) + 1)) << 8) | ((uint32_t)(*((const uint8_t *)(&tlv_ptr.eigrp_tlv_ip_int->mtu) + 2)) << 0))), tlv_ptr.eigrp_tlv_ip_int->hopcount, tlv_ptr.eigrp_tlv_ip_int->reliability, tlv_ptr.eigrp_tlv_ip_int->load)&tlv_ptr.eigrp_tlv_ip_int->delay&tlv_ptr.eigrp_tlv_ip_int->bandwidth&tlv_ptr.eigrp_tlv_ip_int->mtu(ndo, " (too short, < %u)", (u_int) (sizeof(struct eigrp_tlv_header) + sizeof(*tlv_ptr.eigrp_tlv_ip_ext)))tlv_ptr.eigrp_tlv_ip_ext->destination&tlv_ptr.eigrp_tlv_ip_ext->destination,byte_length&tlv_ptr.eigrp_tlv_ip_ext->nexthop(ndo, "%s",ipaddr_string(ndo, &tlv_ptr.eigrp_tlv_ip_ext->nexthop))(ndo, "%s",getname(ndo, (const u_char *)(&tlv_ptr.eigrp_tlv_ip_ext->nexthop)))(ndo, "\n\t      origin-router %s, origin-as %u, origin-proto %s, flags [0x%02x], tag 0x%08x, metric %u", ipaddr_string(ndo, tlv_ptr.eigrp_tlv_ip_ext->origin_router), EXTRACT_32BITS(tlv_ptr.eigrp_tlv_ip_ext->origin_as), tok2str(eigrp_ext_proto_id_values,"unknown",tlv_ptr.eigrp_tlv_ip_ext->proto_id), tlv_ptr.eigrp_tlv_ip_ext->flags, EXTRACT_32BITS(tlv_ptr.eigrp_tlv_ip_ext->tag), EXTRACT_32BITS(tlv_ptr.eigrp_tlv_ip_ext->metric))(ndo, "\n\t      origin-router %s, origin-as %u, origin-proto %s, flags [0x%02x], tag 0x%08x, metric %u", getname(ndo, (const u_char *)(tlv_ptr.eigrp_tlv_ip_ext->origin_router)), ((uint32_t)(((uint32_t)(*((const uint8_t *)(tlv_ptr.eigrp_tlv_ip_ext->origin_as) + 0)) << 24) | ((uint32_t)(*((const uint8_t *)(tlv_ptr.eigrp_tlv_ip_ext->origin_as) + 1)) << 16) | ((uint32_t)(*((const uint8_t *)(tlv_ptr.eigrp_tlv_ip_ext->origin_as) + 2)) << 8) | ((uint32_t)(*((const uint8_t *)(tlv_ptr.eigrp_tlv_ip_ext->origin_as) + 3)) << 0))), tok2str(eigrp_ext_proto_id_values,"unknown",tlv_ptr.eigrp_tlv_ip_ext->proto_id), tlv_ptr.eigrp_tlv_ip_ext->flags, ((uint32_t)(((uint32_t)(*((const uint8_t *)(tlv_ptr.eigrp_tlv_ip_ext->tag) + 0)) << 24) | ((uint32_t)(*((const uint8_t *)(tlv_ptr.eigrp_tlv_ip_ext->tag) + 1)) << 16) | ((uint32_t)(*((const uint8_t *)(tlv_ptr.eigrp_tlv_ip_ext->tag) + 2)) << 8) | ((uint32_t)(*((const uint8_t *)(tlv_ptr.eigrp_tlv_ip_ext->tag) + 3)) << 0))), ((uint32_t)(((uint32_t)(*((const uint8_t *)(tlv_ptr.eigrp_tlv_ip_ext->metric) + 0)) << 24) | ((uint32_t)(*((const uint8_t *)(tlv_ptr.eigrp_tlv_ip_ext->metric) + 1)) << 16) | ((uint32_t)(*((const uint8_t *)(tlv_ptr.eigrp_tlv_ip_ext->metric) + 2)) << 8) | ((uint32_t)(*((const uint8_t *)(tlv_ptr.eigrp_tlv_ip_ext->metric) + 3)) << 0))))tlv_ptr.eigrp_tlv_ip_ext->origin_routertlv_ptr.eigrp_tlv_ip_ext->origin_astlv_ptr.eigrp_tlv_ip_ext->tagtlv_ptr.eigrp_tlv_ip_ext->metric(ndo, "\n\t      delay %u ms, bandwidth %u Kbps, mtu %u, hop %u, reliability %u, load %u", (EXTRACT_32BITS(&tlv_ptr.eigrp_tlv_ip_ext->delay)/100), EXTRACT_32BITS(&tlv_ptr.eigrp_tlv_ip_ext->bandwidth), EXTRACT_24BITS(&tlv_ptr.eigrp_tlv_ip_ext->mtu), tlv_ptr.eigrp_tlv_ip_ext->hopcount, tlv_ptr.eigrp_tlv_ip_ext->reliability, tlv_ptr.eigrp_tlv_ip_ext->load)(ndo, "\n\t      delay %u ms, bandwidth %u Kbps, mtu %u, hop %u, reliability %u, load %u", (((uint32_t)(((uint32_t)(*((const uint8_t *)(&tlv_ptr.eigrp_tlv_ip_ext->delay) + 0)) << 24) | ((uint32_t)(*((const uint8_t *)(&tlv_ptr.eigrp_tlv_ip_ext->delay) + 1)) << 16) | ((uint32_t)(*((const uint8_t *)(&tlv_ptr.eigrp_tlv_ip_ext->delay) + 2)) << 8) | ((uint32_t)(*((const uint8_t *)(&tlv_ptr.eigrp_tlv_ip_ext->delay) + 3)) << 0)))/100), ((uint32_t)(((uint32_t)(*((const uint8_t *)(&tlv_ptr.eigrp_tlv_ip_ext->bandwidth) + 0)) << 24) | ((uint32_t)(*((const uint8_t *)(&tlv_ptr.eigrp_tlv_ip_ext->bandwidth) + 1)) << 16) | ((uint32_t)(*((const uint8_t *)(&tlv_ptr.eigrp_tlv_ip_ext->bandwidth) + 2)) << 8) | ((uint32_t)(*((const uint8_t *)(&tlv_ptr.eigrp_tlv_ip_ext->bandwidth) + 3)) << 0))), ((uint32_t)(((uint32_t)(*((const uint8_t *)(&tlv_ptr.eigrp_tlv_ip_ext->mtu) + 0)) << 16) | ((uint32_t)(*((const uint8_t *)(&tlv_ptr.eigrp_tlv_ip_ext->mtu) + 1)) << 8) | ((uint32_t)(*((const uint8_t *)(&tlv_ptr.eigrp_tlv_ip_ext->mtu) + 2)) << 0))), tlv_ptr.eigrp_tlv_ip_ext->hopcount, tlv_ptr.eigrp_tlv_ip_ext->reliability, tlv_ptr.eigrp_tlv_ip_ext->load)&tlv_ptr.eigrp_tlv_ip_ext->delay&tlv_ptr.eigrp_tlv_ip_ext->bandwidth&tlv_ptr.eigrp_tlv_ip_ext->mtu(ndo, " (too short, < %u)", (u_int) (sizeof(struct eigrp_tlv_header) + sizeof(*tlv_ptr.eigrp_tlv_at_cable_setup)))(ndo, "\n\t    Cable-range: %u-%u, Router-ID %u", EXTRACT_16BITS(&tlv_ptr.eigrp_tlv_at_cable_setup->cable_start), EXTRACT_16BITS(&tlv_ptr.eigrp_tlv_at_cable_setup->cable_end), EXTRACT_32BITS(&tlv_ptr.eigrp_tlv_at_cable_setup->router_id))(ndo, "\n\t    Cable-range: %u-%u, Router-ID %u", ((uint16_t)(((uint16_t)(*((const uint8_t *)(&tlv_ptr.eigrp_tlv_at_cable_setup->cable_start) + 0)) << 8) | ((uint16_t)(*((const uint8_t *)(&tlv_ptr.eigrp_tlv_at_cable_setup->cable_start) + 1)) << 0))), ((uint16_t)(((uint16_t)(*((const uint8_t *)(&tlv_ptr.eigrp_tlv_at_cable_setup->cable_end) + 0)) << 8) | ((uint16_t)(*((const uint8_t *)(&tlv_ptr.eigrp_tlv_at_cable_setup->cable_end) + 1)) << 0))), ((uint32_t)(((uint32_t)(*((const uint8_t *)(&tlv_ptr.eigrp_tlv_at_cable_setup->router_id) + 0)) << 24) | ((uint32_t)(*((const uint8_t *)(&tlv_ptr.eigrp_tlv_at_cable_setup->router_id) + 1)) << 16) | ((uint32_t)(*((const uint8_t *)(&tlv_ptr.eigrp_tlv_at_cable_setup->router_id) + 2)) << 8) | ((uint32_t)(*((const uint8_t *)(&tlv_ptr.eigrp_tlv_at_cable_setup->router_id) + 3)) << 0))))&tlv_ptr.eigrp_tlv_at_cable_setup->cable_start&tlv_ptr.eigrp_tlv_at_cable_setup->cable_end&tlv_ptr.eigrp_tlv_at_cable_setup->router_id(ndo, " (too short, < %u)", (u_int) (sizeof(struct eigrp_tlv_header) + sizeof(*tlv_ptr.eigrp_tlv_at_int)))(ndo, "\n\t     Cable-Range: %u-%u, nexthop: ", EXTRACT_16BITS(&tlv_ptr.eigrp_tlv_at_int->cable_start), EXTRACT_16BITS(&tlv_ptr.eigrp_tlv_at_int->cable_end))(ndo, "\n\t     Cable-Range: %u-%u, nexthop: ", ((uint16_t)(((uint16_t)(*((const uint8_t *)(&tlv_ptr.eigrp_tlv_at_int->cable_start) + 0)) << 8) | ((uint16_t)(*((const uint8_t *)(&tlv_ptr.eigrp_tlv_at_int->cable_start) + 1)) << 0))), ((uint16_t)(((uint16_t)(*((const uint8_t *)(&tlv_ptr.eigrp_tlv_at_int->cable_end) + 0)) << 8) | ((uint16_t)(*((const uint8_t *)(&tlv_ptr.eigrp_tlv_at_int->cable_end) + 1)) << 0))))&tlv_ptr.eigrp_tlv_at_int->cable_start&tlv_ptr.eigrp_tlv_at_int->cable_end&tlv_ptr.eigrp_tlv_at_int->nexthop(ndo, "%u.%u", EXTRACT_16BITS(&tlv_ptr.eigrp_tlv_at_int->nexthop), EXTRACT_16BITS(&tlv_ptr.eigrp_tlv_at_int->nexthop[2]))(ndo, "%u.%u", ((uint16_t)(((uint16_t)(*((const uint8_t *)(&tlv_ptr.eigrp_tlv_at_int->nexthop) + 0)) << 8) | ((uint16_t)(*((const uint8_t *)(&tlv_ptr.eigrp_tlv_at_int->nexthop) + 1)) << 0))), ((uint16_t)(((uint16_t)(*((const uint8_t *)(&tlv_ptr.eigrp_tlv_at_int->nexthop[2]) + 0)) << 8) | ((uint16_t)(*((const uint8_t *)(&tlv_ptr.eigrp_tlv_at_int->nexthop[2]) + 1)) << 0))))&tlv_ptr.eigrp_tlv_at_int->nexthop[2](ndo, "\n\t      delay %u ms, bandwidth %u Kbps, mtu %u, hop %u, reliability %u, load %u", (EXTRACT_32BITS(&tlv_ptr.eigrp_tlv_at_int->delay)/100), EXTRACT_32BITS(&tlv_ptr.eigrp_tlv_at_int->bandwidth), EXTRACT_24BITS(&tlv_ptr.eigrp_tlv_at_int->mtu), tlv_ptr.eigrp_tlv_at_int->hopcount, tlv_ptr.eigrp_tlv_at_int->reliability, tlv_ptr.eigrp_tlv_at_int->load)(ndo, "\n\t      delay %u ms, bandwidth %u Kbps, mtu %u, hop %u, reliability %u, load %u", (((uint32_t)(((uint32_t)(*((const uint8_t *)(&tlv_ptr.eigrp_tlv_at_int->delay) + 0)) << 24) | ((uint32_t)(*((const uint8_t *)(&tlv_ptr.eigrp_tlv_at_int->delay) + 1)) << 16) | ((uint32_t)(*((const uint8_t *)(&tlv_ptr.eigrp_tlv_at_int->delay) + 2)) << 8) | ((uint32_t)(*((const uint8_t *)(&tlv_ptr.eigrp_tlv_at_int->delay) + 3)) << 0)))/100), ((uint32_t)(((uint32_t)(*((const uint8_t *)(&tlv_ptr.eigrp_tlv_at_int->bandwidth) + 0)) << 24) | ((uint32_t)(*((const uint8_t *)(&tlv_ptr.eigrp_tlv_at_int->bandwidth) + 1)) << 16) | ((uint32_t)(*((const uint8_t *)(&tlv_ptr.eigrp_tlv_at_int->bandwidth) + 2)) << 8) | ((uint32_t)(*((const uint8_t *)(&tlv_ptr.eigrp_tlv_at_int->bandwidth) + 3)) << 0))), ((uint32_t)(((uint32_t)(*((const uint8_t *)(&tlv_ptr.eigrp_tlv_at_int->mtu) + 0)) << 16) | ((uint32_t)(*((const uint8_t *)(&tlv_ptr.eigrp_tlv_at_int->mtu) + 1)) << 8) | ((uint32_t)(*((const uint8_t *)(&tlv_ptr.eigrp_tlv_at_int->mtu) + 2)) << 0))), tlv_ptr.eigrp_tlv_at_int->hopcount, tlv_ptr.eigrp_tlv_at_int->reliability, tlv_ptr.eigrp_tlv_at_int->load)&tlv_ptr.eigrp_tlv_at_int->delay&tlv_ptr.eigrp_tlv_at_int->bandwidth&tlv_ptr.eigrp_tlv_at_int->mtu(ndo, " (too short, < %u)", (u_int) (sizeof(struct eigrp_tlv_header) + sizeof(*tlv_ptr.eigrp_tlv_at_ext)))(ndo, "\n\t     Cable-Range: %u-%u, nexthop: ", EXTRACT_16BITS(&tlv_ptr.eigrp_tlv_at_ext->cable_start), EXTRACT_16BITS(&tlv_ptr.eigrp_tlv_at_ext->cable_end))(ndo, "\n\t     Cable-Range: %u-%u, nexthop: ", ((uint16_t)(((uint16_t)(*((const uint8_t *)(&tlv_ptr.eigrp_tlv_at_ext->cable_start) + 0)) << 8) | ((uint16_t)(*((const uint8_t *)(&tlv_ptr.eigrp_tlv_at_ext->cable_start) + 1)) << 0))), ((uint16_t)(((uint16_t)(*((const uint8_t *)(&tlv_ptr.eigrp_tlv_at_ext->cable_end) + 0)) << 8) | ((uint16_t)(*((const uint8_t *)(&tlv_ptr.eigrp_tlv_at_ext->cable_end) + 1)) << 0))))&tlv_ptr.eigrp_tlv_at_ext->cable_start&tlv_ptr.eigrp_tlv_at_ext->cable_end&tlv_ptr.eigrp_tlv_at_ext->nexthop(ndo, "%u.%u", EXTRACT_16BITS(&tlv_ptr.eigrp_tlv_at_ext->nexthop), EXTRACT_16BITS(&tlv_ptr.eigrp_tlv_at_ext->nexthop[2]))(ndo, "%u.%u", ((uint16_t)(((uint16_t)(*((const uint8_t *)(&tlv_ptr.eigrp_tlv_at_ext->nexthop) + 0)) << 8) | ((uint16_t)(*((const uint8_t *)(&tlv_ptr.eigrp_tlv_at_ext->nexthop) + 1)) << 0))), ((uint16_t)(((uint16_t)(*((const uint8_t *)(&tlv_ptr.eigrp_tlv_at_ext->nexthop[2]) + 0)) << 8) | ((uint16_t)(*((const uint8_t *)(&tlv_ptr.eigrp_tlv_at_ext->nexthop[2]) + 1)) << 0))))&tlv_ptr.eigrp_tlv_at_ext->nexthop[2](ndo, "\n\t      origin-router %u, origin-as %u, origin-proto %s, flags [0x%02x], tag 0x%08x, metric %u", EXTRACT_32BITS(tlv_ptr.eigrp_tlv_at_ext->origin_router), EXTRACT_32BITS(tlv_ptr.eigrp_tlv_at_ext->origin_as), tok2str(eigrp_ext_proto_id_values,"unknown",tlv_ptr.eigrp_tlv_at_ext->proto_id), tlv_ptr.eigrp_tlv_at_ext->flags, EXTRACT_32BITS(tlv_ptr.eigrp_tlv_at_ext->tag), EXTRACT_16BITS(tlv_ptr.eigrp_tlv_at_ext->metric))(ndo, "\n\t      origin-router %u, origin-as %u, origin-proto %s, flags [0x%02x], tag 0x%08x, metric %u", ((uint32_t)(((uint32_t)(*((const uint8_t *)(tlv_ptr.eigrp_tlv_at_ext->origin_router) + 0)) << 24) | ((uint32_t)(*((const uint8_t *)(tlv_ptr.eigrp_tlv_at_ext->origin_router) + 1)) << 16) | ((uint32_t)(*((const uint8_t *)(tlv_ptr.eigrp_tlv_at_ext->origin_router) + 2)) << 8) | ((uint32_t)(*((const uint8_t *)(tlv_ptr.eigrp_tlv_at_ext->origin_router) + 3)) << 0))), ((uint32_t)(((uint32_t)(*((const uint8_t *)(tlv_ptr.eigrp_tlv_at_ext->origin_as) + 0)) << 24) | ((uint32_t)(*((const uint8_t *)(tlv_ptr.eigrp_tlv_at_ext->origin_as) + 1)) << 16) | ((uint32_t)(*((const uint8_t *)(tlv_ptr.eigrp_tlv_at_ext->origin_as) + 2)) << 8) | ((uint32_t)(*((const uint8_t *)(tlv_ptr.eigrp_tlv_at_ext->origin_as) + 3)) << 0))), tok2str(eigrp_ext_proto_id_values,"unknown",tlv_ptr.eigrp_tlv_at_ext->proto_id), tlv_ptr.eigrp_tlv_at_ext->flags, ((uint32_t)(((uint32_t)(*((const uint8_t *)(tlv_ptr.eigrp_tlv_at_ext->tag) + 0)) << 24) | ((uint32_t)(*((const uint8_t *)(tlv_ptr.eigrp_tlv_at_ext->tag) + 1)) << 16) | ((uint32_t)(*((const uint8_t *)(tlv_ptr.eigrp_tlv_at_ext->tag) + 2)) << 8) | ((uint32_t)(*((const uint8_t *)(tlv_ptr.eigrp_tlv_at_ext->tag) + 3)) << 0))), ((uint16_t)(((uint16_t)(*((const uint8_t *)(tlv_ptr.eigrp_tlv_at_ext->metric) + 0)) << 8) | ((uint16_t)(*((const uint8_t *)(tlv_ptr.eigrp_tlv_at_ext->metric) + 1)) << 0))))tlv_ptr.eigrp_tlv_at_ext->origin_routertlv_ptr.eigrp_tlv_at_ext->origin_astlv_ptr.eigrp_tlv_at_ext->tagtlv_ptr.eigrp_tlv_at_ext->metric(ndo, "\n\t      delay %u ms, bandwidth %u Kbps, mtu %u, hop %u, reliability %u, load %u", (EXTRACT_32BITS(&tlv_ptr.eigrp_tlv_at_ext->delay)/100), EXTRACT_32BITS(&tlv_ptr.eigrp_tlv_at_ext->bandwidth), EXTRACT_24BITS(&tlv_ptr.eigrp_tlv_at_ext->mtu), tlv_ptr.eigrp_tlv_at_ext->hopcount, tlv_ptr.eigrp_tlv_at_ext->reliability, tlv_ptr.eigrp_tlv_at_ext->load)(ndo, "\n\t      delay %u ms, bandwidth %u Kbps, mtu %u, hop %u, reliability %u, load %u", (((uint32_t)(((uint32_t)(*((const uint8_t *)(&tlv_ptr.eigrp_tlv_at_ext->delay) + 0)) << 24) | ((uint32_t)(*((const uint8_t *)(&tlv_ptr.eigrp_tlv_at_ext->delay) + 1)) << 16) | ((uint32_t)(*((const uint8_t *)(&tlv_ptr.eigrp_tlv_at_ext->delay) + 2)) << 8) | ((uint32_t)(*((const uint8_t *)(&tlv_ptr.eigrp_tlv_at_ext->delay) + 3)) << 0)))/100), ((uint32_t)(((uint32_t)(*((const uint8_t *)(&tlv_ptr.eigrp_tlv_at_ext->bandwidth) + 0)) << 24) | ((uint32_t)(*((const uint8_t *)(&tlv_ptr.eigrp_tlv_at_ext->bandwidth) + 1)) << 16) | ((uint32_t)(*((const uint8_t *)(&tlv_ptr.eigrp_tlv_at_ext->bandwidth) + 2)) << 8) | ((uint32_t)(*((const uint8_t *)(&tlv_ptr.eigrp_tlv_at_ext->bandwidth) + 3)) << 0))), ((uint32_t)(((uint32_t)(*((const uint8_t *)(&tlv_ptr.eigrp_tlv_at_ext->mtu) + 0)) << 16) | ((uint32_t)(*((const uint8_t *)(&tlv_ptr.eigrp_tlv_at_ext->mtu) + 1)) << 8) | ((uint32_t)(*((const uint8_t *)(&tlv_ptr.eigrp_tlv_at_ext->mtu) + 2)) << 0))), tlv_ptr.eigrp_tlv_at_ext->hopcount, tlv_ptr.eigrp_tlv_at_ext->reliability, tlv_ptr.eigrp_tlv_at_ext->load)&tlv_ptr.eigrp_tlv_at_ext->delay&tlv_ptr.eigrp_tlv_at_ext->bandwidth&tlv_ptr.eigrp_tlv_at_ext->mtu
	  %s TLV (0x%04x), length: %u (too short, < %u)EIGRP_TLV_GENERAL_PARMconst eigrp_tlv_general_parm_tconst eigrp_tlv_general_parm_t *eigrp_tlv_general_parm_t *sizeof(*tlv_ptr.eigrp_tlv_general_parm)
	    holdtime: %us, k1 %u, k2 %u, k3 %u, k4 %u, k5 %uEIGRP_TLV_SW_VERSIONconst eigrp_tlv_sw_version_tconst eigrp_tlv_sw_version_t *eigrp_tlv_sw_version_t *sizeof(*tlv_ptr.eigrp_tlv_sw_version)
	    IOS version: %u.%u, EIGRP version %u.%uEIGRP_TLV_IP_INTconst eigrp_tlv_ip_int_tconst eigrp_tlv_ip_int_t *eigrp_tlv_ip_int_t *sizeof(*tlv_ptr.eigrp_tlv_ip_int)
	    illegal prefix length %u
	    IPv4 prefix: %15s/%u, nexthop: self
	      delay %u ms, bandwidth %u Kbps, mtu %u, hop %u, reliability %u, load %uconst uint8_t[3]const uint8_t(*)[3]unsigned char(*)[3]EIGRP_TLV_IP_EXTconst eigrp_tlv_ip_ext_tconst eigrp_tlv_ip_ext_t *eigrp_tlv_ip_ext_t *sizeof(*tlv_ptr.eigrp_tlv_ip_ext)
	      origin-router %s, origin-as %u, origin-proto %s, flags [0x%02x], tag 0x%08x, metric %uchar[95]EIGRP_TLV_AT_CABLE_SETUPconst eigrp_tlv_at_cable_setup_tconst eigrp_tlv_at_cable_setup_t *eigrp_tlv_at_cable_setup_t *sizeof(*tlv_ptr.eigrp_tlv_at_cable_setup)
	    Cable-range: %u-%u, Router-ID %uEIGRP_TLV_AT_INTconst eigrp_tlv_at_int_tconst eigrp_tlv_at_int_t *eigrp_tlv_at_int_t *sizeof(*tlv_ptr.eigrp_tlv_at_int)
	     Cable-Range: %u-%u, nexthop: EIGRP_TLV_AT_EXTconst eigrp_tlv_at_ext_tconst eigrp_tlv_at_ext_t *eigrp_tlv_at_ext_t *sizeof(*tlv_ptr.eigrp_tlv_at_ext)
	      origin-router %u, origin-as %u, origin-proto %s, flags [0x%02x], tag 0x%08x, metric %uEIGRP_TLV_AUTHEIGRP_TLV_SEQEIGRP_TLV_MCAST_SEQEIGRP_TLV_IPX_INTEIGRP_TLV_IPX_EXTeigrp_tlv_at_ext_teigrp_tlv_at_int_teigrp_tlv_at_cable_setup_teigrp_tlv_ip_ext_teigrp_tlv_ip_int_teigrp_tlv_sw_version_teigrp_tlv_general_parm_teigrp_common_headereigrp_tlv_at_exteigrp_tlv_at_inteigrp_tlv_at_cable_setupeigrp_tlv_ip_exteigrp_tlv_ip_inteigrp_tlv_sw_versioneigrp_tlv_general_parmcable_endcable_startreserved2loadreliabilityhopcountmtudelayproto_idorigin_asorigin_routernexthopdestinationeigrp_minoreigrp_majorios_minorios_majorholdtimek5k4k3k2k1asnStatic"Static"RIP"RIP"Hello"Hello"BGP"BGP"Connected"Connected"eigrp_ext_proto_id_valuesGeneral Parameters"General Parameters"Sequence"Sequence"Software Version"Software Version"Next Multicast Sequence"Next Multicast Sequence"IP Internal routes"IP Internal routes"IP External routes"IP External routes"AppleTalk Internal routes"AppleTalk Internal routes"AppleTalk External routes"AppleTalk External routes"AppleTalk Cable setup"AppleTalk Cable setup"IPX Internal routes"IPX Internal routes"IPX External routes"IPX External routes"eigrp_tlv_valuesConditionally Received"Conditionally Received"eigrp_common_header_flag_valuesEIGRP_OPCODE_UPDATEEIGRP_OPCODE_QUERYQuery"Query"EIGRP_OPCODE_REPLYEIGRP_OPCODE_HELLOEIGRP_OPCODE_IPXSAPIPX SAP"IPX SAP"EIGRP_OPCODE_PROBEProbe"Probe"eigrp_opcode_values0x03030x03020x0204/* do we want to see an additionally hexdump ? *//* variable length encoding *//* did we capture enough for fully decoding the object ? *//* did we capture enough for fully decoding the object header ? *//* FIXME print other header info *//* ok they seem to want to know everything - lets fully decode it *//* in non-verbose mode just lets print the basic Message Type*//* variable length [1-4] bytes encoding *//*
 * packet format documented at
 * http://www.rhyshaden.com/eigrp.htm
 * RFC 7868
 *//* \summary: Enhanced Interior Gateway Routing Protocol (EIGRP) printer *//*
 * Copyright (c) 1998-2004  Hannes Gredler <hannes@gredler.at>
 *      The TCPDUMP project
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that: (1) source code
 * distributions retain the above copyright notice and this paragraph
 * in its entirety, and (2) distributions including binary code include
 * the above copyright notice and this paragraph in its entirety in
 * the documentation or other materials provided with the distribution.
 * THIS SOFTWARE IS PROVIDED ``AS IS'' AND
 * WITHOUT ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, WITHOUT
 * LIMITATION, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS
 * FOR A PARTICULAR PURPOSE.
 *//Users/owura/Repos/codeql_eval/proj_repos/the-tcpdump-group-tcpdump-commit-9ba91381954ad325ea4fd26b9c65a8bd9a2a85b6/tcpdump/print-enc.cenc_if_printconst enchdrconst enchdr *enchdr *(ndo, "[|enc]")ENC_HDRLEN[|enc](ndo, "(unprotected): ")(unprotected): M_AUTH"authentic"(ndo, "%s%s", "authentic", (flags) == (0x0800) ? "): " : ",")authentic-2049M_CONF0x0400"confidential"(ndo, "%s%s", "confidential", (flags) == (0x0400) ? "): " : ",")confidential-1025(ndo, "SPI 0x%08x: ", EXTRACT_32BITS(&hdr->spi))(ndo, "SPI 0x%08x: ", ((uint32_t)(((uint32_t)(*((const uint8_t *)(&hdr->spi) + 0)) << 24) | ((uint32_t)(*((const uint8_t *)(&hdr->spi) + 1)) << 16) | ((uint32_t)(*((const uint8_t *)(&hdr->spi) + 2)) << 8) | ((uint32_t)(*((const uint8_t *)(&hdr->spi) + 3)) << 0))))SPI 0x%08x: &hdr->spi(ENC_HDRLEN)enchdrspiENC_PRINT_TYPE(wh,xf,nam)if ((wh) & (xf)) { ND_PRINT((ndo, "%s%s", nam, (wh) == (xf) ? "): " : ",")); (wh) &= ~(xf); }/* ENC_PRINT_TYPE(flags, M_TUNNEL, "tunnel"); *//* packet was authenticated (AH) *//* packet was encrypted (ESP-transport) *//* From $OpenBSD: mbuf.h,v 1.56 2002/01/25 15:50:23 art Exp $	*//*
 * The authors of this code are John Ioannidis (ji@tla.org),
 * Angelos D. Keromytis (kermit@csd.uch.gr) and
 * Niels Provos (provos@physnet.uni-hamburg.de).
 *
 * This code was written by John Ioannidis for BSD/OS in Athens, Greece,
 * in November 1995.
 *
 * Ported to OpenBSD and NetBSD, with additional transforms, in December 1996,
 * by Angelos D. Keromytis.
 *
 * Additional transforms and features in 1997 and 1998 by Angelos D. Keromytis
 * and Niels Provos.
 *
 * Copyright (C) 1995, 1996, 1997, 1998 by John Ioannidis, Angelos D. Keromytis
 * and Niels Provos.
 * Copyright (c) 2001, Angelos D. Keromytis.
 *
 * Permission to use, copy, and modify this software with or without fee
 * is hereby granted, provided that this entire notice is included in
 * all copies of any software which is or includes a copy or
 * modification of this software.
 * You may use this code under the GNU public license if you so wish. Please
 * contribute changes back to the authors under this freer than GPL license
 * so that we may further the use of strong encryption without limitations to
 * all.
 *
 * THIS SOFTWARE IS BEING PROVIDED "AS IS", WITHOUT ANY EXPRESS OR
 * IMPLIED WARRANTY. IN PARTICULAR, NONE OF THE AUTHORS MAKES ANY
 * REPRESENTATION OR WARRANTY OF ANY KIND CONCERNING THE
 * MERCHANTABILITY OF THIS SOFTWARE OR ITS FITNESS FOR ANY PARTICULAR
 * PURPOSE.
 *//* From $OpenBSD: if_enc.h,v 1.8 2001/06/25 05:14:00 angelos Exp $ *//* \summary: OpenBSD IPsec encapsulation BPF layer printer *//*
 * Copyright (c) 1990, 1991, 1993, 1994, 1995, 1996
 *	The Regents of the University of California.  All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that: (1) source code distributions
 * retain the above copyright notice and this paragraph in its entirety, (2)
 * distributions including binary code include the above copyright notice and
 * this paragraph in its entirety in the documentation or other materials
 * provided with the distribution, and (3) all advertising materials mentioning
 * features or use of this software display the following acknowledgement:
 * ``This product includes software developed by the University of California,
 * Lawrence Berkeley Laboratory and its contributors.'' Neither the name of
 * the University nor the names of its contributors may be used to endorse
 * or promote products derived from this software without specific prior
 * written permission.
 * THIS SOFTWARE IS PROVIDED ``AS IS'' AND WITHOUT ANY EXPRESS OR IMPLIED
 * WARRANTIES, INCLUDING, WITHOUT LIMITATION, THE IMPLIED WARRANTIES OF
 * MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE.
 *//*	$OpenBSD: print-enc.c,v 1.7 2002/02/19 19:39:40 millert Exp $	*//Users/owura/Repos/codeql_eval/proj_repos/the-tcpdump-group-tcpdump-commit-9ba91381954ad325ea4fd26b9c65a8bd9a2a85b6/tcpdump/strtoaddr.hstrtoaddr6strtoaddr/* Text string to address translation routines. *//*
 * Copyright (c) 2004 by Internet Systems Consortium, Inc. ("ISC")
 * Copyright (c) 1996,1999 by Internet Software Consortium.
 *
 * Permission to use, copy, modify, and distribute this software for any
 * purpose with or without fee is hereby granted, provided that the above
 * copyright notice and this permission notice appear in all copies.
 *
 * THE SOFTWARE IS PROVIDED "AS IS" AND ISC DISCLAIMS ALL WARRANTIES
 * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
 * MERCHANTABILITY AND FITNESS.  IN NO EVENT SHALL ISC BE LIABLE FOR
 * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
 * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
 * ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT
 * OF OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
 *//Users/owura/Repos/codeql_eval/proj_repos/the-tcpdump-group-tcpdump-commit-9ba91381954ad325ea4fd26b9c65a8bd9a2a85b6/tcpdump/print-esp.c"strtoaddr.h"esp_printconst intconst newespconst newesp *newesp *(ndo, "[|ESP]")[|ESP](ndo, "ESP(spi=0x%08x", EXTRACT_32BITS(&esp->esp_spi))(ndo, "ESP(spi=0x%08x", ((uint32_t)(((uint32_t)(*((const uint8_t *)(&esp->esp_spi) + 0)) << 24) | ((uint32_t)(*((const uint8_t *)(&esp->esp_spi) + 1)) << 16) | ((uint32_t)(*((const uint8_t *)(&esp->esp_spi) + 2)) << 8) | ((uint32_t)(*((const uint8_t *)(&esp->esp_spi) + 3)) << 0))))ESP(spi=0x%08x&esp->esp_spi(ndo, ",seq=0x%x)", EXTRACT_32BITS(&esp->esp_seq))(ndo, ",seq=0x%x)", ((uint32_t)(((uint32_t)(*((const uint8_t *)(&esp->esp_seq) + 0)) << 24) | ((uint32_t)(*((const uint8_t *)(&esp->esp_seq) + 1)) << 16) | ((uint32_t)(*((const uint8_t *)(&esp->esp_seq) + 2)) << 8) | ((uint32_t)(*((const uint8_t *)(&esp->esp_seq) + 3)) << 0)))),seq=0x%x)&esp->esp_seqfailnewespesp_seqesp_spiHAVE_LIBCRYPTOHAVE_OPENSSL_EVP_HHAVE_EVP_CIPHER_CTX_NEWHAVE_EVP_CIPHERINIT_EX!defined(OPENSSL_API_COMPAT) || OPENSSL_API_COMPAT < 0x10100000L/* sanity check for pad length *//*
			 * XXX - of course this is wrong, because buf is a
			 * const buffer, but changing this would require a
			 * more complicated fix.
			 *//*
			 * Attempt to allocate the output buffer.
			 *//*
			 * Copy the input data to the encrypted data buffer,
			 * and pad it with zeroes.
			 *//*
			 * Attempt to allocate the input buffer.
			 *//*
			 * Allocate buffers for the encrypted and decrypted
			 * data.  Both buffers' sizes must be a multiple of
			 * the cipher block size, and the output buffer must
			 * be separate from the input buffer.
			 *//* length of the IV, if there is one; 0, if there isn't *//* pointer to the IV, if there is one *//* FCS included at end of frame (NetBSD 1.6 or later) *//* if we can't get nexthdr, we do not need to decrypt it *//* if not found fail *//* if we didn't find the specific one, then look for
	 * an unspecified one.
	 *//* see if we can find the SA, and if so, decode it *//* nexthdr & padding are in the last fragment *//* we do not attempt to decrypt jumbograms *//* initiailize SAs *//* 'ep' points to the end of available data. *//* keep secret out of a register *//* pick out the first line or first thing until a comma *//*
	 * 0.9.6 doesn't appear to define OPENSSL_API_COMPAT, so
	 * we check whether it's undefined or it's less than the
	 * value for 1.1.0.
	 *//* skip any blank spaces *//* remove newline from the line *//* open file and read it *//* sa1.spi = 0; *//* memset(&sa1.daddr, 0, sizeof(sa1.daddr)); *//* sa1.daddr.version = 0; *//* if there is only one token, then it is an algo:key token *//*
 *
 * special form: file /name
 * causes us to go read from this file instead.
 *
 *//* if any fields are missing *//* it's an IKEv2 secret, store it instead *//*
 * for the moment, ignore the auth algorithm, just hard code the authenticator
 * length. Need to research how openssl looks up HMAC stuff.
 *//* decode some hex! *//*
 * decode the form:    SPINUM@IP <tab> ALGONAME:0xsecret
 *//*
 * returns size of binary, 0 on failure.
 *//* copy the "sa" *//*
	 * XXX - of course this is wrong, because buf is a const buffer,
	 * but changing this would require a more complicated fix.
	 *//*
	 * Attempt to allocate the output buffer.
	 *//*
	 * Copy the input data to the encrypted data buffer, and pad it
	 * with zeroes.
	 *//*
	 * Attempt to allocate the input buffer.
	 *//*
	 * Allocate buffers for the encrypted and decrypted data.
	 * Both buffers' sizes must be a multiple of the cipher block
	 * size, and the output buffer must be separate from the input
	 * buffer.
	 *//*
	 * remove authenticator, and see if we still have something to
	 * work with
	 *//* initiator arg is any non-zero value *//*
 * this will adjust ndo_packetp and ndo_snapend to new buffer!
 *//*
 * Initialize the cipher by calling EVP_CipherInit(), because we don't
 * have EVP_CipherInit_ex(); we rely on it not trashing the context.
 *//*
 * Initialize the cipher by calling EVP_CipherInit_ex(), because
 * calling EVP_CipherInit() will reset the cipher context, clearing
 * the cipher, so calling it twice, with the second call having a
 * null cipher, will clear the already-set cipher.  EVP_CipherInit_ex(),
 * however, won't reset the cipher context, so you can use it to specify
 * the IV oin a second call after a first call to EVP_CipherInit_ex()
 * to set the cipher and the key.
 *
 * XXX - is there some reason why we need to make two calls?
 *//*
 * Allocate an EVP_CIPHER_CTX.
 * Used if we have an older version of OpenSSL that doesn't provide
 * routines to allocate and free them.
 *//* is that big enough for all secrets? *//* for IKEv2 *//* if == 0, then IKEv2 *//*variable size, 32bit bound*//* next header *//*8bit*//* pad size *//*variable size*//* (IV and) Payload data *//* Sequence number *//* ESP *//*
 * RFC1827/2406 Encapsulated Security Payload.
 *//* Any code in this file that depends on HAVE_LIBCRYPTO depends on
 * HAVE_OPENSSL_EVP_H too. Undefining the former when the latter isn't defined
 * is the simplest way of handling the dependency.
 *//* \summary: IPSEC Encapsulating Security Payload (ESP) printer */bp2nhdr/Users/owura/Repos/codeql_eval/proj_repos/the-tcpdump-group-tcpdump-commit-9ba91381954ad325ea4fd26b9c65a8bd9a2a85b6/tcpdump/print-ether.cethertype_print(ndo, "(NOV-ETHII) ")(ndo, " [|osi]")33079(NOV-ETHII)  [|osi]34915349161537815379349583496934827348243482535074439813502035018349271799351434369349785602635130netanalyzer_transparent_if_print(ndo, "[|netanalyzer-transparent]")[|netanalyzer-transparent]netanalyzer_if_print(ndo, "[|netanalyzer]")[|netanalyzer]ether_if_printether_printconst ether_headerconst ether_header *ether_header *orig_lengthlength_type(ndo, "[|ether]")[|ether]&ep->ether_length_typerecurse(ndo, "[|vlan]")(ndo, "%s, ", ieee8021q_tci_string(tag))(ndo, "ethertype %s, ", tok2str(ethertype_values,"0x%04x", length_type))33024371203737634984[|vlan]print_encap_headerencap_header_arg%s, ethertype %s, const tok[52]tok[52]0x%04x34928ether_hdr_print(ndo, "%s > %s", etheraddr_string(ndo, ESRC(ep)), etheraddr_string(ndo, EDST(ep)))(ndo, "%s > %s", etheraddr_string(ndo, ((ep)->ether_shost)), etheraddr_string(ndo, ((ep)->ether_dhost)))(ndo, ", 802.3")(ndo, ", ethertype %s (0x%04x)", tok2str(ethertype_values,"Unknown", length_type), length_type)(ndo, ", %s", tok2str(ethertype_values,"Unknown Ethertype (0x%04x)", length_type)), 802.3MPLS unicast"MPLS unicast"MPLS multicast"MPLS multicast"802.1Q"802.1Q"802.1Q-9100"802.1Q-9100"802.1Q-QinQ"802.1Q-QinQ"802.1Q-9200"802.1Q-9200"VMAN"VMAN"PUP"PUP"Reverse ARP"Reverse ARP"Sprite"Sprite"Trail"Trail"MOP DL"MOP DL"MOP RC"MOP RC"DN"DN"LAT"LAT"SCA"SCA"25944TEB"TEB"Lanbridge"Lanbridge"DEC DNS"DEC DNS"DEC DTS"DEC DTS"VEXP"VEXP"VPROD"VPROD"Appletalk ARP"Appletalk ARP"MPCP"MPCP"Slow Protocols"Slow Protocols"PPPoE D"PPPoE D"PPPoE S"PPPoE S"EAPOL"EAPOL"RRCP"RRCP"MS NLB heartbeat"MS NLB heartbeat"Jumbo"Jumbo"OSI"OSI"GRE-OSI"GRE-OSI"CFM (old)"CFM (old)"CFM"CFM"IEEE1905.1"IEEE1905.1"LLDP"LLDP"TIPC"TIPC"GeoNet (old)"GeoNet (old)"GeoNet"GeoNet""CALM FAST"AoE"AoE"MEDSA"MEDSA"/* default_print for now *//*
 * Prints the packet payload, given an Ethernet type code for the payload's
 * protocol.
 *
 * Returns non-zero if it can do so, zero if the ethertype is unknown.
 *//* Skip the pseudo-header, preamble, and SOF. *//*
	 * Fail if we don't have enough data for the Hilscher pseudo-header,
	 * preamble, and SOF.
	 *//*
 * This is the top level routine of the printer.  'p' points
 * to the ether header of the packet, 'h->len' is the length
 * of the packet off the wire, and 'h->caplen' is the number
 * of bytes actually captured.
 *
 * This is for DLT_NETANALYZER_TRANSPARENT, which has a 4-byte
 * pseudo-header, a 7-byte Ethernet preamble, and a 1-byte Ethernet SOF
 * before the Ethernet header.
 *//* Skip the pseudo-header. *//*
	 * Fail if we don't have enough data for the Hilscher pseudo-header.
	 *//*
 * This is the top level routine of the printer.  'p' points
 * to the ether header of the packet, 'h->len' is the length
 * of the packet off the wire, and 'h->caplen' is the number
 * of bytes actually captured.
 *
 * This is for DLT_NETANALYZER, which has a 4-byte pseudo-header
 * before the Ethernet header.
 *//*
 * This is the top level routine of the printer.  'p' points
 * to the ether header of the packet, 'h->len' is the length
 * of the packet off the wire, and 'h->caplen' is the number
 * of bytes actually captured.
 *//* type not known, print raw packet *//* Try to print the LLC-layer header & higher layers *//*
		 * Alteon jumbo frames.
		 * See
		 *
		 *	http://tools.ietf.org/html/draft-ietf-isis-ext-eth-01
		 *
		 * which indicates that, following the type field,
		 * there's an LLC header and payload.
		 *//*
		 * Print VLAN information, and then go back and process
		 * the enclosed type field.
		 *//*
	 * Is it (gag) an 802.3 encapsulation?
	 *//*
 * Print an Ethernet frame.
 * This might be encapsulated within another frame; we might be passed
 * a pointer to a function that can print header information for that
 * frame's protocol, and an argument to pass to that function.
 *
 * FIXME: caplen can and should be derived from ndo->ndo_snapend and p.
 *//* \summary: Ethernet printer *//Users/owura/Repos/codeql_eval/proj_repos/the-tcpdump-group-tcpdump-commit-9ba91381954ad325ea4fd26b9c65a8bd9a2a85b6/tcpdump/print-fddi.cfddi_if_printfddi_printconst fddi_headerconst fddi_header *fddi_header *fddipehdr(ndo, "[|fddi]")FDDI_HDRLEN[|fddi]&ehdrFDDIFC_CLFFFDDIFC_LLC_ASYNCFDDIFC_SMTfddi_smt_print(ndo, "<SMT printer not yet implemented>")<SMT printer not yet implemented>fddi_hdr_printsrcnamedstname(ndo, "%s > %s, length %u: ", srcname, dstname, length)%s > %s, length %u: extract_fddi_addrsfdst(const char *)fddip->fddi_dhost, 6fsrc(const char *)fddip->fddi_shost, 6const u_char[256]print_fddi_fc(ndo, "void ")(ndo, "nrt ")(ndo, "rt ")(ndo, "info ")(ndo, "nsa ")(ndo, "beacon ")(ndo, "claim ")(ndo, "mac%1x ", fc & FDDIFC_ZZZZ)(ndo, "mac%1x ", fc & 0x0F)(ndo, "smt%1x ", fc & FDDIFC_ZZZZ)(ndo, "smt%1x ", fc & 0x0F)(ndo, "async%1x ", fc & FDDIFC_ZZZZ)(ndo, "async%1x ", fc & 0x0F)(ndo, "sync%1x ", fc & FDDIFC_ZZZZ)(ndo, "sync%1x ", fc & 0x0F)(ndo, "imp_async%1x ", fc & FDDIFC_ZZZZ)(ndo, "imp_async%1x ", fc & 0x0F)(ndo, "imp_sync%1x ", fc & FDDIFC_ZZZZ)(ndo, "imp_sync%1x ", fc & 0x0F)(ndo, "%02x ", fc)FDDIFC_VOIDvoid FDDIFC_NRTnrt FDDIFC_RTrt FDDIFC_SMT_INFOinfo FDDIFC_SMT_NSAnsa 194FDDIFC_MAC_BEACONbeacon 195FDDIFC_MAC_CLAIMclaim FDDIFC_MACmac%1x smt%1x async%1x 208FDDIFC_LLC_SYNCsync%1x FDDIFC_IMP_ASYNCimp_async%1x FDDIFC_IMP_SYNCimp_sync%1x %02x fddi_headerfddi_shostfddi_dhostfddi_fcfddi_bit_swapfddi_bitswapFDDIFC_ZZZZ0xd00x500xc30xc20x4F0x41FDDIFC_ZFDDIFC_FFDDIFC_LFDDIFC_Cdefined(ultrix) || defined(__alpha) || defined(__bsdi) || defined(__NetBSD__) || defined(__linux__)/*
 * This is the top level routine of the printer.  'p' points
 * to the FDDI header of the packet, 'h->ts' is the timestamp,
 * 'h->len' is the length of the packet off the wire, and 'h->caplen'
 * is the number of bytes actually captured.
 *//* Some kinds of FDDI packet we cannot handle intelligently *//*
			 * Some kinds of LLC packet we cannot
			 * handle intelligently
			 *//* Frame Control field determines interpretation of packet *//* Skip over FDDI MAC header *//*
	 * Get the FDDI addresses into a canonical form
	 *//*
 * Print the FDDI MAC header
 *//*
		 * bit-swap the fddi addresses (isn't the IEEE standards
		 * process wonderful!) then convert them to names.
		 *//* Extract src, dst addresses *//* MAC Claim frame *//* MAC Beacon frame *//* SMT Next station adrs *//* SMT Info *//* Restricted token *//* Nonrestricted token *//* Void frame *//*
 * Print FDDI frame-control bits
 *//*
 * FDDI support for tcpdump, by Jeffrey Mogul [DECWRL], June 1992
 *
 * Based in part on code by Van Jacobson, which bears this note:
 *
 * NOTE:  This is a very preliminary hack for FDDI support.
 * There are all sorts of wired in constants & nothing (yet)
 * to print SMT packets as anything other than hex dumps.
 * Most of the necessary changes are waiting on my redoing
 * the "header" that a kernel fddi driver supplies to bpf:  I
 * want it to look like one byte of 'direction' (0 or 1
 * depending on whether the packet was inbound or outbound),
 * two bytes of system/driver dependent data (anything an
 * implementor thinks would be useful to filter on and/or
 * save per-packet, then the real 21-byte FDDI header.
 * Steve McCanne & I have also talked about adding the
 * 'direction' byte to all bpf headers (e.g., in the two
 * bytes of padding on an ethernet header).  It's not clear
 * we could do this in a backwards compatible way & we hate
 * the idea of an incompatible bpf change.  Discussions are
 * proceeding.
 *
 * Also, to really support FDDI (and better support 802.2
 * over ethernet) we really need to re-think the rather simple
 * minded assumptions about fixed length & fixed format link
 * level headers made in gencode.c.  One day...
 *
 *  - vj
 *//*
 * Some FDDI interfaces use bit-swapped addresses.
 *//* Control bits *//* Class/Length/Format bits *//* MAC frame *//* SMT frame *//* Implementor Synch. *//* Implementor Async. *//* Sync. LLC frame *//* Async. LLC frame *//*
 * FDDI Frame Control values. (48-bit addressing only).
 *//* Frame format bits *//* Address length bit *//* Class bit *//*
 * FDDI Frame Control bits
 *//* Useful values for fddi_fc (frame control) field *//*
 * Length of an FDDI header; note that some compilers may pad
 * "struct fddi_header" to a multiple of 4 bytes, for example, so
 * "sizeof (struct fddi_header)" may not give the right
 * answer.
 *//* frame control *//*
 * Based on Ultrix if_fddi.h
 *//* \summary: Fiber Distributed Data Interface (FDDI) printer *//*
 * Copyright (c) 1991, 1992, 1993, 1994, 1995, 1996, 1997
 *	The Regents of the University of California.  All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that: (1) source code distributions
 * retain the above copyright notice and this paragraph in its entirety, (2)
 * distributions including binary code include the above copyright notice and
 * this paragraph in its entirety in the documentation or other materials
 * provided with the distribution, and (3) all advertising materials mentioning
 * features or use of this software display the following acknowledgement:
 * ``This product includes software developed by the University of California,
 * Lawrence Berkeley Laboratory and its contributors.'' Neither the name of
 * the University nor the names of its contributors may be used to endorse
 * or promote products derived from this software without specific prior
 * written permission.
 * THIS SOFTWARE IS PROVIDED ``AS IS'' AND WITHOUT ANY EXPRESS OR IMPLIED
 * WARRANTIES, INCLUDING, WITHOUT LIMITATION, THE IMPLIED WARRANTIES OF
 * MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE.
 *//Users/owura/Repos/codeql_eval/proj_repos/the-tcpdump-group-tcpdump-commit-9ba91381954ad325ea4fd26b9c65a8bd9a2a85b6/tcpdump/print-forces.cforces_printconst forceshconst forcesh *forcesh *fhdrflg_rawconst tom_hconst tom_h *tom_h *tops*fhdrsizeof(*fhdr)(ndo, "Invalid ForCES message type %d\n", fhdr->fm_tom)Invalid ForCES message type %d
&(fhdr)->fm_len(ndo, "\n\tUnknown ForCES message type=0x%x", fhdr->fm_tom)TOM_RSVD
	Unknown ForCES message type=0x%x(ndo, "\n\tForCES %s ", tops->s)
	ForCES %s (ndo, "Illegal ForCES pkt len - min %u, total recvd %d, advertised %d ", ForCES_HDRL, len, ForCES_BLN(fhdr))(ndo, "Illegal ForCES pkt len - min %u, total recvd %d, advertised %d ", 24, len, ((uint32_t)(((uint16_t)(((uint16_t)(*((const uint8_t *)(&(fhdr)->fm_len) + 0)) << 8) | ((uint16_t)(*((const uint8_t *)(&(fhdr)->fm_len) + 1)) << 0))) << 2)))Illegal ForCES pkt len - min %u, total recvd %d, advertised %d *(pptr + 20)pptr + 20(ndo, "\n\tForCES Version %d len %uB flags 0x%08x ", ForCES_V(fhdr), mlen, flg_raw)(ndo, "\n\tForCES Version %d len %uB flags 0x%08x ", ((fhdr)->fm_vrsvd >> 4), mlen, flg_raw)(ndo, "\n\tSrcID 0x%x(%s) DstID 0x%x(%s) Correlator 0x%" PRIx64, ForCES_SID(fhdr), ForCES_node(ForCES_SID(fhdr)), ForCES_DID(fhdr), ForCES_node(ForCES_DID(fhdr)), EXTRACT_64BITS(fhdr->fm_cor))(ndo, "\n\tSrcID 0x%x(%s) DstID 0x%x(%s) Correlator 0x%" "ll" "x", ((uint32_t)(((uint32_t)(*((const uint8_t *)(&(fhdr)->fm_sid) + 0)) << 24) | ((uint32_t)(*((const uint8_t *)(&(fhdr)->fm_sid) + 1)) << 16) | ((uint32_t)(*((const uint8_t *)(&(fhdr)->fm_sid) + 2)) << 8) | ((uint32_t)(*((const uint8_t *)(&(fhdr)->fm_sid) + 3)) << 0))), ForCES_node(((uint32_t)(((uint32_t)(*((const uint8_t *)(&(fhdr)->fm_sid) + 0)) << 24) | ((uint32_t)(*((const uint8_t *)(&(fhdr)->fm_sid) + 1)) << 16) | ((uint32_t)(*((const uint8_t *)(&(fhdr)->fm_sid) + 2)) << 8) | ((uint32_t)(*((const uint8_t *)(&(fhdr)->fm_sid) + 3)) << 0)))), ((uint32_t)(((uint32_t)(*((const uint8_t *)(&(fhdr)->fm_did) + 0)) << 24) | ((uint32_t)(*((const uint8_t *)(&(fhdr)->fm_did) + 1)) << 16) | ((uint32_t)(*((const uint8_t *)(&(fhdr)->fm_did) + 2)) << 8) | ((uint32_t)(*((const uint8_t *)(&(fhdr)->fm_did) + 3)) << 0))), ForCES_node(((uint32_t)(((uint32_t)(*((const uint8_t *)(&(fhdr)->fm_did) + 0)) << 24) | ((uint32_t)(*((const uint8_t *)(&(fhdr)->fm_did) + 1)) << 16) | ((uint32_t)(*((const uint8_t *)(&(fhdr)->fm_did) + 2)) << 8) | ((uint32_t)(*((const uint8_t *)(&(fhdr)->fm_did) + 3)) << 0)))), ((uint64_t)(((uint64_t)(*((const uint8_t *)(fhdr->fm_cor) + 0)) << 56) | ((uint64_t)(*((const uint8_t *)(fhdr->fm_cor) + 1)) << 48) | ((uint64_t)(*((const uint8_t *)(fhdr->fm_cor) + 2)) << 40) | ((uint64_t)(*((const uint8_t *)(fhdr->fm_cor) + 3)) << 32) | ((uint64_t)(*((const uint8_t *)(fhdr->fm_cor) + 4)) << 24) | ((uint64_t)(*((const uint8_t *)(fhdr->fm_cor) + 5)) << 16) | ((uint64_t)(*((const uint8_t *)(fhdr->fm_cor) + 6)) << 8) | ((uint64_t)(*((const uint8_t *)(fhdr->fm_cor) + 7)) << 0))))&(fhdr)->fm_sid&(fhdr)->fm_didfhdr->fm_cor
	ForCES Version %d len %uB flags 0x%08x 
	SrcID 0x%x(%s) DstID 0x%x(%s) Correlator 0x%llxnd_uint8_t[8](ndo, "\n\tForCES flags:\n\t  %s(0x%x), prio=%d, %s(0x%x),\n\t  %s(0x%x), %s(0x%x)\n", tok2str(ForCES_ACKs, "ACKUnknown", ForCES_ACK(fhdr)), ForCES_ACK(fhdr), ForCES_PRI(fhdr), tok2str(ForCES_EMs, "EMUnknown", ForCES_EM(fhdr)), ForCES_EM(fhdr), tok2str(ForCES_ATs, "ATUnknown", ForCES_AT(fhdr)), ForCES_AT(fhdr), tok2str(ForCES_TPs, "TPUnknown", ForCES_TP(fhdr)), ForCES_TP(fhdr))(ndo, "\n\tForCES flags:\n\t  %s(0x%x), prio=%d, %s(0x%x),\n\t  %s(0x%x), %s(0x%x)\n", tok2str(ForCES_ACKs, "ACKUnknown", ((((uint32_t)(((uint32_t)(*((const uint8_t *)(&(fhdr)->fm_flags) + 0)) << 24) | ((uint32_t)(*((const uint8_t *)(&(fhdr)->fm_flags) + 1)) << 16) | ((uint32_t)(*((const uint8_t *)(&(fhdr)->fm_flags) + 2)) << 8) | ((uint32_t)(*((const uint8_t *)(&(fhdr)->fm_flags) + 3)) << 0)))&0xC0000000) >> 30)), ((((uint32_t)(((uint32_t)(*((const uint8_t *)(&(fhdr)->fm_flags) + 0)) << 24) | ((uint32_t)(*((const uint8_t *)(&(fhdr)->fm_flags) + 1)) << 16) | ((uint32_t)(*((const uint8_t *)(&(fhdr)->fm_flags) + 2)) << 8) | ((uint32_t)(*((const uint8_t *)(&(fhdr)->fm_flags) + 3)) << 0)))&0xC0000000) >> 30), ((((uint32_t)(((uint32_t)(*((const uint8_t *)(&(fhdr)->fm_flags) + 0)) << 24) | ((uint32_t)(*((const uint8_t *)(&(fhdr)->fm_flags) + 1)) << 16) | ((uint32_t)(*((const uint8_t *)(&(fhdr)->fm_flags) + 2)) << 8) | ((uint32_t)(*((const uint8_t *)(&(fhdr)->fm_flags) + 3)) << 0)))&0x38000000) >> 27), tok2str(ForCES_EMs, "EMUnknown", ((((uint32_t)(((uint32_t)(*((const uint8_t *)(&(fhdr)->fm_flags) + 0)) << 24) | ((uint32_t)(*((const uint8_t *)(&(fhdr)->fm_flags) + 1)) << 16) | ((uint32_t)(*((const uint8_t *)(&(fhdr)->fm_flags) + 2)) << 8) | ((uint32_t)(*((const uint8_t *)(&(fhdr)->fm_flags) + 3)) << 0)))&0x00C00000) >> 22)), ((((uint32_t)(((uint32_t)(*((const uint8_t *)(&(fhdr)->fm_flags) + 0)) << 24) | ((uint32_t)(*((const uint8_t *)(&(fhdr)->fm_flags) + 1)) << 16) | ((uint32_t)(*((const uint8_t *)(&(fhdr)->fm_flags) + 2)) << 8) | ((uint32_t)(*((const uint8_t *)(&(fhdr)->fm_flags) + 3)) << 0)))&0x00C00000) >> 22), tok2str(ForCES_ATs, "ATUnknown", ((((uint32_t)(((uint32_t)(*((const uint8_t *)(&(fhdr)->fm_flags) + 0)) << 24) | ((uint32_t)(*((const uint8_t *)(&(fhdr)->fm_flags) + 1)) << 16) | ((uint32_t)(*((const uint8_t *)(&(fhdr)->fm_flags) + 2)) << 8) | ((uint32_t)(*((const uint8_t *)(&(fhdr)->fm_flags) + 3)) << 0)))&0x00200000) >> 21)), ((((uint32_t)(((uint32_t)(*((const uint8_t *)(&(fhdr)->fm_flags) + 0)) << 24) | ((uint32_t)(*((const uint8_t *)(&(fhdr)->fm_flags) + 1)) << 16) | ((uint32_t)(*((const uint8_t *)(&(fhdr)->fm_flags) + 2)) << 8) | ((uint32_t)(*((const uint8_t *)(&(fhdr)->fm_flags) + 3)) << 0)))&0x00200000) >> 21), tok2str(ForCES_TPs, "TPUnknown", ((((uint32_t)(((uint32_t)(*((const uint8_t *)(&(fhdr)->fm_flags) + 0)) << 24) | ((uint32_t)(*((const uint8_t *)(&(fhdr)->fm_flags) + 1)) << 16) | ((uint32_t)(*((const uint8_t *)(&(fhdr)->fm_flags) + 2)) << 8) | ((uint32_t)(*((const uint8_t *)(&(fhdr)->fm_flags) + 3)) << 0)))&0x00180000) >> 19)), ((((uint32_t)(((uint32_t)(*((const uint8_t *)(&(fhdr)->fm_flags) + 0)) << 24) | ((uint32_t)(*((const uint8_t *)(&(fhdr)->fm_flags) + 1)) << 16) | ((uint32_t)(*((const uint8_t *)(&(fhdr)->fm_flags) + 2)) << 8) | ((uint32_t)(*((const uint8_t *)(&(fhdr)->fm_flags) + 3)) << 0)))&0x00180000) >> 19))&(fhdr)->fm_flags(ndo, "\t  Extra flags: rsv(b5-7) 0x%x rsv(b13-31) 0x%x\n", ForCES_RS1(fhdr), ForCES_RS2(fhdr))(ndo, "\t  Extra flags: rsv(b5-7) 0x%x rsv(b13-31) 0x%x\n", ((((uint32_t)(((uint32_t)(*((const uint8_t *)(&(fhdr)->fm_flags) + 0)) << 24) | ((uint32_t)(*((const uint8_t *)(&(fhdr)->fm_flags) + 1)) << 16) | ((uint32_t)(*((const uint8_t *)(&(fhdr)->fm_flags) + 2)) << 8) | ((uint32_t)(*((const uint8_t *)(&(fhdr)->fm_flags) + 3)) << 0)))&0x07000000) >> 24), ((((uint32_t)(((uint32_t)(*((const uint8_t *)(&(fhdr)->fm_flags) + 0)) << 24) | ((uint32_t)(*((const uint8_t *)(&(fhdr)->fm_flags) + 1)) << 16) | ((uint32_t)(*((const uint8_t *)(&(fhdr)->fm_flags) + 2)) << 8) | ((uint32_t)(*((const uint8_t *)(&(fhdr)->fm_flags) + 3)) << 0)))&0x0007FFFF) >> 0))
	ForCES flags:
	  %s(0x%x), prio=%d, %s(0x%x),
	  %s(0x%x), %s(0x%x)
ACKUnknown939524096EMUnknown12582912ATUnknown2097152TPUnknown1572864	  Extra flags: rsv(b5-7) 0x%x rsv(b13-31) 0x%x
117440512524287(ndo, "\n\t]")error
	["\n\t["
	](ndo, "\n\t  Raw ForCES message\n\t [")(ndo, "\n\t ]")
	  Raw ForCES message
	 [
	 "\n\t "
	 ]forces_type_printconst forces_tlvconst forces_tlv *forces_tlv *tltlvrleninvtlvttlvForCES_HDRL(ndo, "<0x%x>Illegal Top level TLV!\n", tops->flags)(ndo, "\tTop level TLV Data missing!\n")TLV_HLNZERO_TTLV<0x%x>Illegal Top level TLV!
ZERO_MORE_TTLVONE_MORE_TTLV	Top level TLV Data missing!
*tltlvsizeof(*tltlv)&tltlv->type(ndo, "\n\tInvalid ForCES Top TLV type=0x%x", EXTRACT_16BITS(&tltlv->type))(ndo, "\n\tInvalid ForCES Top TLV type=0x%x", ((uint16_t)(((uint16_t)(*((const uint8_t *)(&tltlv->type) + 0)) << 8) | ((uint16_t)(*((const uint8_t *)(&tltlv->type) + 1)) << 0))))(ndo, "\t%s, length %d (data length %d Bytes)", tok2str(ForCES_TLV, NULL, EXTRACT_16BITS(&tltlv->type)), EXTRACT_16BITS(&tltlv->length), EXTRACT_16BITS(&tltlv->length) - TLV_HDRL)(ndo, "\t%s, length %d (data length %d Bytes)", tok2str(ForCES_TLV, ((void *)0), ((uint16_t)(((uint16_t)(*((const uint8_t *)(&tltlv->type) + 0)) << 8) | ((uint16_t)(*((const uint8_t *)(&tltlv->type) + 1)) << 0)))), ((uint16_t)(((uint16_t)(*((const uint8_t *)(&tltlv->length) + 0)) << 8) | ((uint16_t)(*((const uint8_t *)(&tltlv->length) + 1)) << 0))), ((uint16_t)(((uint16_t)(*((const uint8_t *)(&tltlv->length) + 0)) << 8) | ((uint16_t)(*((const uint8_t *)(&tltlv->length) + 1)) << 0))) - 4)&tltlv->lengthTLV_HDRLEXTRACT_16BITS(&(tltlv)->length)((uint16_t)(((uint16_t)(*((const uint8_t *)(&(tltlv)->length) + 0)) << 8) | ((uint16_t)(*((const uint8_t *)(&(tltlv)->length) + 1)) << 0)))&(tltlv)->length
	Invalid ForCES Top TLV type=0x%x	%s, length %d (data length %d Bytes)(ndo, "\tMess TopTLV header: min %u, total %d advertised %d ", TLV_HDRL, rlen, EXTRACT_16BITS(&tltlv->length))(ndo, "\tMess TopTLV header: min %u, total %d advertised %d ", 4, rlen, ((uint16_t)(((uint16_t)(*((const uint8_t *)(&tltlv->length) + 0)) << 8) | ((uint16_t)(*((const uint8_t *)(&tltlv->length) + 1)) << 0))))	Mess TopTLV header: min %u, total %d advertised %d lfbselect_printconst forces_lfbshconst forces_lfbsh *forces_lfbsh *lfbsotlvibdlen(ndo, "\n\t\ttruncated lfb selector: %d bytes missing! ", OP_MIN - dlen)(ndo, "\n\t\ttruncated lfb selector: %d bytes missing! ", 12 - dlen)OP_MIN
		truncated lfb selector: %d bytes missing! OP_OFF*lfbssizeof(*lfbs)(ndo, "\n%s%s(Classid %x) instance %x\n", ib, tok2str(ForCES_LFBs, NULL, EXTRACT_32BITS(&lfbs->class)), EXTRACT_32BITS(&lfbs->class), EXTRACT_32BITS(&lfbs->instance))(ndo, "\n%s%s(Classid %x) instance %x\n", ib, tok2str(ForCES_LFBs, ((void *)0), ((uint32_t)(((uint32_t)(*((const uint8_t *)(&lfbs->class) + 0)) << 24) | ((uint32_t)(*((const uint8_t *)(&lfbs->class) + 1)) << 16) | ((uint32_t)(*((const uint8_t *)(&lfbs->class) + 2)) << 8) | ((uint32_t)(*((const uint8_t *)(&lfbs->class) + 3)) << 0)))), ((uint32_t)(((uint32_t)(*((const uint8_t *)(&lfbs->class) + 0)) << 24) | ((uint32_t)(*((const uint8_t *)(&lfbs->class) + 1)) << 16) | ((uint32_t)(*((const uint8_t *)(&lfbs->class) + 2)) << 8) | ((uint32_t)(*((const uint8_t *)(&lfbs->class) + 3)) << 0))), ((uint32_t)(((uint32_t)(*((const uint8_t *)(&lfbs->instance) + 0)) << 24) | ((uint32_t)(*((const uint8_t *)(&lfbs->instance) + 1)) << 16) | ((uint32_t)(*((const uint8_t *)(&lfbs->instance) + 2)) << 8) | ((uint32_t)(*((const uint8_t *)(&lfbs->instance) + 3)) << 0))))&lfbs->class&lfbs->instance
%s%s(Classid %x) instance %x
*otlvsizeof(*otlv)&otlv->type(ndo, "\t\tINValid oper-TLV type 0x%x length %d for this ForCES message\n", EXTRACT_16BITS(&otlv->type), EXTRACT_16BITS(&otlv->length))(ndo, "\t\tINValid oper-TLV type 0x%x length %d for this ForCES message\n", ((uint16_t)(((uint16_t)(*((const uint8_t *)(&otlv->type) + 0)) << 8) | ((uint16_t)(*((const uint8_t *)(&otlv->type) + 1)) << 0))), ((uint16_t)(((uint16_t)(*((const uint8_t *)(&otlv->length) + 0)) << 8) | ((uint16_t)(*((const uint8_t *)(&otlv->length) + 1)) << 0))))&otlv->lengthEXTRACT_16BITS(&(otlv)->length)((uint16_t)(((uint16_t)(*((const uint8_t *)(&(otlv)->length) + 0)) << 8) | ((uint16_t)(*((const uint8_t *)(&(otlv)->length) + 1)) << 0)))&(otlv)->lengthop_mskindent		INValid oper-TLV type 0x%x length %d for this ForCES message
(ndo, "\n\t\tMessy oper TLV header, type (0x%x)\n\t\texcess of %d Bytes ", EXTRACT_16BITS(&otlv->type), rlen - EXTRACT_16BITS(&otlv->length))(ndo, "\n\t\tMessy oper TLV header, type (0x%x)\n\t\texcess of %d Bytes ", ((uint16_t)(((uint16_t)(*((const uint8_t *)(&otlv->type) + 0)) << 8) | ((uint16_t)(*((const uint8_t *)(&otlv->type) + 1)) << 0))), rlen - ((uint16_t)(((uint16_t)(*((const uint8_t *)(&otlv->length) + 0)) << 8) | ((uint16_t)(*((const uint8_t *)(&otlv->length) + 1)) << 0))))
		Messy oper TLV header, type (0x%x)
		excess of %d Bytes char[60]redirect_printtlv(ndo, "\n\t\ttruncated Redirect TLV: %d bytes missing! ", RD_MIN - dlen)(ndo, "\n\t\ttruncated Redirect TLV: %d bytes missing! ", 8 - dlen)RD_MIN
		truncated Redirect TLV: %d bytes missing! *tlvsizeof(*tlv)(ndo, "Bad Redirect data\n")&tlv->type&tlv->length(ndo, "Unknown REDIRECT TLV 0x%x len %d\n", EXTRACT_16BITS(&tlv->type), EXTRACT_16BITS(&tlv->length))(ndo, "Unknown REDIRECT TLV 0x%x len %d\n", ((uint16_t)(((uint16_t)(*((const uint8_t *)(&tlv->type) + 0)) << 8) | ((uint16_t)(*((const uint8_t *)(&tlv->type) + 1)) << 0))), ((uint16_t)(((uint16_t)(*((const uint8_t *)(&tlv->length) + 0)) << 8) | ((uint16_t)(*((const uint8_t *)(&tlv->length) + 1)) << 0))))EXTRACT_16BITS(&(tlv)->length)((uint16_t)(((uint16_t)(*((const uint8_t *)(&(tlv)->length) + 0)) << 8) | ((uint16_t)(*((const uint8_t *)(&(tlv)->length) + 1)) << 0)))&(tlv)->lengthBad Redirect data
F_TLV_METDF_TLV_REDDUnknown REDIRECT TLV 0x%x len %d
(ndo, "\n\t\tMessy Redirect TLV header, type (0x%x)\n\t\texcess of %d Bytes ", EXTRACT_16BITS(&tlv->type), rlen - EXTRACT_16BITS(&tlv->length))(ndo, "\n\t\tMessy Redirect TLV header, type (0x%x)\n\t\texcess of %d Bytes ", ((uint16_t)(((uint16_t)(*((const uint8_t *)(&tlv->type) + 0)) << 8) | ((uint16_t)(*((const uint8_t *)(&tlv->type) + 1)) << 0))), rlen - ((uint16_t)(((uint16_t)(*((const uint8_t *)(&tlv->length) + 0)) << 8) | ((uint16_t)(*((const uint8_t *)(&tlv->length) + 1)) << 0))))
		Messy Redirect TLV header, type (0x%x)
		excess of %d Bytes print_reddata(ndo, "\n%s Redirect Data length %d \n", ib, rlen)
%s Redirect Data length %d 
(ndo, "\t\t[")(ndo, "\n\t\t]")		[
		]print_metatlvconst forces_ilvconst forces_ilv *forces_ilv *ilvinvilv(ndo, "\n%s METADATA length %d \n", ib, rlen)
%s METADATA length %d 
*ilvsizeof(*ilv)EXTRACT_32BITS(&(ilv)->length)((uint32_t)(((uint32_t)(*((const uint8_t *)(&(ilv)->length) + 0)) << 24) | ((uint32_t)(*((const uint8_t *)(&(ilv)->length) + 1)) << 16) | ((uint32_t)(*((const uint8_t *)(&(ilv)->length) + 2)) << 8) | ((uint32_t)(*((const uint8_t *)(&(ilv)->length) + 3)) << 0)))&(ilv)->lengthprint_metailv&ilv->lengthILV_HDRL(ndo, "%sMetaID 0x%x length %d\n", ib, EXTRACT_32BITS(&ilv->type), EXTRACT_32BITS(&ilv->length))(ndo, "%sMetaID 0x%x length %d\n", ib, ((uint32_t)(((uint32_t)(*((const uint8_t *)(&ilv->type) + 0)) << 24) | ((uint32_t)(*((const uint8_t *)(&ilv->type) + 1)) << 16) | ((uint32_t)(*((const uint8_t *)(&ilv->type) + 2)) << 8) | ((uint32_t)(*((const uint8_t *)(&ilv->type) + 3)) << 0))), ((uint32_t)(((uint32_t)(*((const uint8_t *)(&ilv->length) + 0)) << 24) | ((uint32_t)(*((const uint8_t *)(&ilv->length) + 1)) << 16) | ((uint32_t)(*((const uint8_t *)(&ilv->length) + 2)) << 8) | ((uint32_t)(*((const uint8_t *)(&ilv->length) + 3)) << 0))))%sMetaID 0x%x length %d
&ilv->type(ndo, " ]\n")"\t\t[" ]
asrtlv_printrescode(ndo, "illegal ASRresult-TLV: %d bytes!\n", dlen)ASRDLNillegal ASRresult-TLV: %d bytes!
(ndo, "illegal ASRresult result code: %d!\n", rescode)ASRMCDillegal ASRresult result code: %d!
(ndo, "\n%s", ib)(ndo, "Success ")(ndo, "FE ID invalid ")(ndo, "permission denied ")(ndo, "Unknown ")(ndo, "(%x)\n%s", rescode, ib)
%sSuccess FE ID invalid permission denied Unknown (%x)
%sasttlv_print(ndo, "illegal ASTresult-TLV: %d bytes!\n", dlen)ASTDLNillegal ASTresult-TLV: %d bytes!
(ndo, "illegal ASTresult result code: %d!\n", rescode)ASTMCDillegal ASTresult result code: %d!
(ndo, "Teardown reason:\n%s", ib)(ndo, "Normal Teardown")(ndo, "Loss of Heartbeats")(ndo, "Out of bandwidth")(ndo, "Out of Memory")(ndo, "Application Crash")(ndo, "Unknown Teardown reason")Teardown reason:
%sNormal TeardownLoss of HeartbeatsOut of bandwidthOut of MemoryApplication CrashUnknown Teardown reasonotlv_printtllconst optlv_hconst optlv_h *optlv_h *ops(ndo, "%sOper TLV %s(0x%x) length %d\n", ib, ops->s, type, EXTRACT_16BITS(&otlv->length))(ndo, "%sOper TLV %s(0x%x) length %d\n", ib, ops->s, type, ((uint16_t)(((uint16_t)(*((const uint8_t *)(&otlv->length) + 0)) << 8) | ((uint16_t)(*((const uint8_t *)(&otlv->length) + 1)) << 0))))%sOper TLV %s(0x%x) length %d
(ndo, "\t\tOper TLV %s(0x%x) length %d\n", ops->s, type, EXTRACT_16BITS(&otlv->length))(ndo, "\t\tOper TLV %s(0x%x) length %d\n", ops->s, type, ((uint16_t)(((uint16_t)(*((const uint8_t *)(&otlv->length) + 0)) << 8) | ((uint16_t)(*((const uint8_t *)(&otlv->length) + 1)) << 0))))(ndo, "\t\tTruncated data size %d minimum required %d\n", tll, OP_MIN_SIZ)(ndo, "\t\tTruncated data size %d minimum required %d\n", tll, 8)OP_MIN_SIZ		Oper TLV %s(0x%x) length %d
		Truncated data size %d minimum required %d
invoptlv_print(ndo, "%sData[", &ib[1])(ndo, "%s]\n", ib)%sData[%s]
recpdoptlv_printpdtlv*pdtlvsizeof(*pdtlv)&pdtlv->type&pdtlv->length(ndo, "%s%s, length %d (data encapsulated %d Bytes)", ib, tok2str(ForCES_TLV, NULL, type), EXTRACT_16BITS(&pdtlv->length), EXTRACT_16BITS(&pdtlv->length) - TLV_HDRL)(ndo, "%s%s, length %d (data encapsulated %d Bytes)", ib, tok2str(ForCES_TLV, ((void *)0), type), ((uint16_t)(((uint16_t)(*((const uint8_t *)(&pdtlv->length) + 0)) << 8) | ((uint16_t)(*((const uint8_t *)(&pdtlv->length) + 1)) << 0))), ((uint16_t)(((uint16_t)(*((const uint8_t *)(&pdtlv->length) + 0)) << 8) | ((uint16_t)(*((const uint8_t *)(&pdtlv->length) + 1)) << 0))) - 4)EXTRACT_16BITS(&(pdtlv)->length)((uint16_t)(((uint16_t)(*((const uint8_t *)(&(pdtlv)->length) + 0)) << 8) | ((uint16_t)(*((const uint8_t *)(&(pdtlv)->length) + 1)) << 0)))&(pdtlv)->length%s%s, length %d (data encapsulated %d Bytes)(ndo, "\n\t\tMessy PATHDATA TLV header, type (0x%x)\n\t\texcess of %d Bytes ", EXTRACT_16BITS(&pdtlv->type), len - EXTRACT_16BITS(&pdtlv->length))(ndo, "\n\t\tMessy PATHDATA TLV header, type (0x%x)\n\t\texcess of %d Bytes ", ((uint16_t)(((uint16_t)(*((const uint8_t *)(&pdtlv->type) + 0)) << 8) | ((uint16_t)(*((const uint8_t *)(&pdtlv->type) + 1)) << 0))), len - ((uint16_t)(((uint16_t)(*((const uint8_t *)(&pdtlv->length) + 0)) << 8) | ((uint16_t)(*((const uint8_t *)(&pdtlv->length) + 1)) << 0))))
		Messy PATHDATA TLV header, type (0x%x)
		excess of %d Bytes genoptlv_print(ndo, "genoptlvprint - %s TLV type 0x%x len %d\n", tok2str(ForCES_TLV, NULL, type), type, EXTRACT_16BITS(&pdtlv->length))(ndo, "genoptlvprint - %s TLV type 0x%x len %d\n", tok2str(ForCES_TLV, ((void *)0), type), type, ((uint16_t)(((uint16_t)(*((const uint8_t *)(&pdtlv->length) + 0)) << 8) | ((uint16_t)(*((const uint8_t *)(&pdtlv->length) + 1)) << 0))))genoptlvprint - %s TLV type 0x%x len %d
(ndo, "%s TLV type 0x%x len %d\n", tok2str(ForCES_TLV_err, NULL, invtlv), type, EXTRACT_16BITS(&pdtlv->length))(ndo, "%s TLV type 0x%x len %d\n", tok2str(ForCES_TLV_err, ((void *)0), invtlv), type, ((uint16_t)(((uint16_t)(*((const uint8_t *)(&pdtlv->length) + 0)) << 8) | ((uint16_t)(*((const uint8_t *)(&pdtlv->length) + 1)) << 0))))(ndo, "%s%s, length %d (data length %d Bytes)", ib, tok2str(ForCES_TLV, NULL, type), EXTRACT_16BITS(&pdtlv->length), tll)(ndo, "%s%s, length %d (data length %d Bytes)", ib, tok2str(ForCES_TLV, ((void *)0), type), ((uint16_t)(((uint16_t)(*((const uint8_t *)(&pdtlv->length) + 0)) << 8) | ((uint16_t)(*((const uint8_t *)(&pdtlv->length) + 1)) << 0))), tll)(ndo, "\t\t\tInvalid ForCES TLV type=%x", type)%s TLV type 0x%x len %d
%s%s, length %d (data length %d Bytes)			Invalid ForCES TLV type=%xpdata_printconst pathdata_hconst pathdata_h *pathdata_h *pdhminsizemore_pdidcnt*pdhsizeof(*pdh)sizeof(struct pathdata_h)(ndo, "\n%sPathdata: Flags 0x%x ID count %d\n", ib, EXTRACT_16BITS(&pdh->pflags), EXTRACT_16BITS(&pdh->pIDcnt))(ndo, "\n%sPathdata: Flags 0x%x ID count %d\n", ib, ((uint16_t)(((uint16_t)(*((const uint8_t *)(&pdh->pflags) + 0)) << 8) | ((uint16_t)(*((const uint8_t *)(&pdh->pflags) + 1)) << 0))), ((uint16_t)(((uint16_t)(*((const uint8_t *)(&pdh->pIDcnt) + 0)) << 8) | ((uint16_t)(*((const uint8_t *)(&pdh->pIDcnt) + 1)) << 0))))&pdh->pflags&pdh->pIDcnt
%sPathdata: Flags 0x%x ID count %d
F_SELKEYB_KEYINF_SELTABRANGEB_TRNGF_TABAPPENDB_APPND(ndo, "\t\t\ttruncated IDs expected %uB got %uB\n", minsize, len)(ndo, "]\n")			truncated IDs expected %uB got %uB
			ID Data["\t\t\tID Data["]
(ndo, "\t\t\tIllegal to have both Table ranges and keys\n")			Illegal to have both Table ranges and keys
pdatacnt_print(ndo, "%sTABLE APPEND\n", ib)%sTABLE APPEND
(ndo, "%sID#%02u: %d\n", ib, i + 1, id)%sID#%02u: %d
(ndo, "pathlength %d with key/range too short %d\n", len, PTH_DESC_SIZE)(ndo, "pathlength %d with key/range too short %d\n", len, 12)(ndo, "%sTable range: [%d,%d]\n", ib, starti, endi)&keytlv->length(ndo, "key content length %u < %u\n", tll, TLV_HDRL)(ndo, "key content length %u < %u\n", tll, 4)(ndo, "key content too short\n")startiendiPTH_DESC_SIZEpathlength %d with key/range too short %d
sizeof(struct forces_tlv)%sTable range: [%d,%d]
keytlvkey content length %u < %u
key content too short
(ndo, "%s Outstanding bytes %d for TLV type 0x%x TLV len %d\n", tok2str(ForCES_TLV_err, NULL, invtlv), len, type, EXTRACT_16BITS(&pdtlv->length))(ndo, "%s Outstanding bytes %d for TLV type 0x%x TLV len %d\n", tok2str(ForCES_TLV_err, ((void *)0), invtlv), len, type, ((uint16_t)(((uint16_t)(*((const uint8_t *)(&pdtlv->length) + 0)) << 8) | ((uint16_t)(*((const uint8_t *)(&pdtlv->length) + 1)) << 0))))EXTRACT_16BITS(&pdtlv->length)((uint16_t)(((uint16_t)(*((const uint8_t *)(&pdtlv->length) + 0)) << 8) | ((uint16_t)(*((const uint8_t *)(&pdtlv->length) + 1)) << 0)))(ndo, "Invalid padded pathdata TLV type 0x%x len %d missing %d pad bytes\n", type, EXTRACT_16BITS(&pdtlv->length), aln - len)(ndo, "Invalid padded pathdata TLV type 0x%x len %d missing %d pad bytes\n", type, ((uint16_t)(((uint16_t)(*((const uint8_t *)(&pdtlv->length) + 0)) << 8) | ((uint16_t)(*((const uint8_t *)(&pdtlv->length) + 1)) << 0))), aln - len)(ndo, "%s  %s (Length %d DataLen %d pad %d Bytes)\n", ib, ops->s, EXTRACT_16BITS(&pdtlv->length), tll, pad)(ndo, "%s  %s (Length %d DataLen %d pad %d Bytes)\n", ib, ops->s, ((uint16_t)(((uint16_t)(*((const uint8_t *)(&pdtlv->length) + 0)) << 8) | ((uint16_t)(*((const uint8_t *)(&pdtlv->length) + 1)) << 0))), tll, pad)(ndo, "%s  %s (Length %d DataLen %d Bytes)\n", ib, ops->s, EXTRACT_16BITS(&pdtlv->length), tll)(ndo, "%s  %s (Length %d DataLen %d Bytes)\n", ib, ops->s, ((uint16_t)(((uint16_t)(*((const uint8_t *)(&pdtlv->length) + 0)) << 8) | ((uint16_t)(*((const uint8_t *)(&pdtlv->length) + 1)) << 0))), tll)(ndo, "Invalid path data content type 0x%x len %d\n", type, EXTRACT_16BITS(&pdtlv->length))(ndo, "Invalid path data content type 0x%x len %d\n", type, ((uint16_t)(((uint16_t)(*((const uint8_t *)(&pdtlv->length) + 0)) << 8) | ((uint16_t)(*((const uint8_t *)(&pdtlv->length) + 1)) << 0))))aln%s Outstanding bytes %d for TLV type 0x%x TLV len %d
IDcntInvalid padded pathdata TLV type 0x%x len %d missing %d pad bytes
const pdata_opsconst pdata_ops *pdata_ops *272F_TLV_PDAT%s  %s (Length %d DataLen %d pad %d Bytes)
%s  %s (Length %d DataLen %d Bytes)
Invalid path data content type 0x%x len %d
pd_errBad Data val
	  ["Bad Data val\n\t  ["pkeyitlv_printtdpkdtlv*tdpsizeof(*tdp)(ndo, "%sKeyinfo: Key 0x%x\n", ib, id)%sKeyinfo: Key 0x%x
*kdtlvsizeof(*kdtlv)&kdtlv->type(ndo, "%s TLV type 0x%x len %d\n", tok2str(ForCES_TLV_err, NULL, invtlv), type, EXTRACT_16BITS(&kdtlv->length))(ndo, "%s TLV type 0x%x len %d\n", tok2str(ForCES_TLV_err, ((void *)0), invtlv), type, ((uint16_t)(((uint16_t)(*((const uint8_t *)(&kdtlv->length) + 0)) << 8) | ((uint16_t)(*((const uint8_t *)(&kdtlv->length) + 1)) << 0))))&kdtlv->lengthsdatatlv_print(ndo, "Error: expecting SPARSEDATA!\n")275F_TLV_SPADError: expecting SPARSEDATA!
sdatailv_print(ndo, "Error: BAD SPARSEDATA-TLV!\n")Error: BAD SPARSEDATA-TLV!
(ndo, "%s[", &ib[1])(ndo, "\n%s]\n", &ib[1])(ndo, "\n%s ILV: type %x length %d\n", &ib[1], EXTRACT_32BITS(&ilv->type), ilvl)(ndo, "\n%s ILV: type %x length %d\n", &ib[1], ((uint32_t)(((uint32_t)(*((const uint8_t *)(&ilv->type) + 0)) << 24) | ((uint32_t)(*((const uint8_t *)(&ilv->type) + 1)) << 16) | ((uint32_t)(*((const uint8_t *)(&ilv->type) + 2)) << 8) | ((uint32_t)(*((const uint8_t *)(&ilv->type) + 3)) << 0))), ilvl)%s[
%s]
ilvl
%s ILV: type %x length %d
fdatatlv_print(ndo, "Error: expecting FULLDATA!\n")F_TLV_FULDError: expecting FULLDATA!
prestlv_printconst res_valconst res_val *res_val *(ndo, "illegal RESULT-TLV: %d bytes!\n", dlen)RESLENillegal RESULT-TLV: %d bytes!
*rsizeof(*r)(ndo, "illegal reserved result code: 0x%x!\n", r->result)0xFEillegal reserved result code: 0x%x!
(ndo, "%s  Result: %s (code 0x%x)\n", ib, tok2str(ForCES_errs, NULL, r->result), r->result)(ndo, "%s  Result: %s (code 0x%x)\n", ib, tok2str(ForCES_errs, ((void *)0), r->result), r->result)%s  Result: %s (code 0x%x)
const tok[26]tok[26]get_forces_pdPD_MAX_INDpdoconst pdata_ops[11]pdata_ops[11]PD_RSV_IPD_RSV_I + 1TOM_RSV_Ichk_op_type(ndo, "Based on flags expected KEYINFO TLV!\n")(ndo, "Illegal DATA encoding for type 0x%x programmed %x got %x \n", type, omsk, msk)F_TLV_KEYIBased on flags expected KEYINFO TLV!
Illegal DATA encoding for type 0x%x programmed %x got %x 
pd_validF_TLV_RESTget_forces_tomTOM_MAX_INDthconst tom_h[11]tom_h[11]ilv_validINVALID_RLENINVALID_STLNINVALID_LTLNEXTRACT_32BITS(&ilv->length)((uint32_t)(((uint32_t)(*((const uint8_t *)(&ilv->length) + 0)) << 24) | ((uint32_t)(*((const uint8_t *)(&ilv->length) + 1)) << 16) | ((uint32_t)(*((const uint8_t *)(&ilv->length) + 2)) << 8) | ((uint32_t)(*((const uint8_t *)(&ilv->length) + 3)) << 0)))INVALID_ALENtlv_validEXTRACT_16BITS(&tlv->length)((uint16_t)(((uint16_t)(*((const uint8_t *)(&tlv->length) + 0)) << 8) | ((uint16_t)(*((const uint8_t *)(&tlv->length) + 1)) << 0)))mskomsktomttlv_valid0x1100x116op_validopbindent_prIND_SIZE(IND_SIZE - 1)IND_PREFIND_CHRIND_SUFget_forces_optlv_hF_OP_MAXF_OP_RSVconst optlv_h[15]optlv_h[15]ForCES_node10737418230x3FFFFFFFFE"FE"0x4000000021474836470x7FFFFFFFCE"CE"0xC000000042949672790xFFFFFFEFAllMulticast"AllMulticast"42949672930xFFFFFFFDAllCEsBroadcast"AllCEsBroadcast"0xFFFFFFFEAllFEsBroadcast"AllFEsBroadcast"0xFFFFFFFFAllBroadcast"AllBroadcast"ForCESreserved"ForCESreserved"tom_validE_SUCCESSE_INVALID_HEADERE_LENGTH_MISMATCHE_VERSION_MISMATCHE_INVALID_DESTINATION_PIDE_LFB_UNKNOWNE_LFB_NOT_FOUNDE_LFB_INSTANCE_ID_NOT_FOUNDE_INVALID_PATHE_COMPONENT_DOES_NOT_EXISTE_EXISTSE_NOT_FOUNDE_READ_ONLYE_INVALID_ARRAY_CREATIONE_VALUE_OUT_OF_RANGEE_CONTENTS_TOO_LONGE_INVALID_PARAMETERSE_INVALID_MESSAGE_TYPEE_INVALID_FLAGSE_INVALID_TLVE_EVENT_ERRORE_NOT_SUPPORTEDE_MEMORY_ERRORE_INTERNAL_ERRORE_UNSPECIFIED_ERROR0XFFres_valPD_SEL_IPD_FDT_IPD_SDT_IPD_RES_IPD_PDT_I_PD_RSV_MAXpdata_opsforces_lfbshforces_tlvforces_ilvpathdata_hoptlv_hB_OP_SETF_OP_SETF_OP_SET - 1(F_OP_SET - 1)1 << (F_OP_SET - 1)B_OP_SETPROPF_OP_SETPROPF_OP_SETPROP - 1(F_OP_SETPROP - 1)1 << (F_OP_SETPROP - 1)B_OP_SETRESPF_OP_SETRESPF_OP_SETRESP - 1(F_OP_SETRESP - 1)1 << (F_OP_SETRESP - 1)B_OP_SETPRESPF_OP_SETPRESPF_OP_SETPRESP - 1(F_OP_SETPRESP - 1)1 << (F_OP_SETPRESP - 1)B_OP_DELF_OP_DELF_OP_DEL - 1(F_OP_DEL - 1)1 << (F_OP_DEL - 1)B_OP_DELRESPF_OP_DELRESPF_OP_DELRESP - 1(F_OP_DELRESP - 1)1 << (F_OP_DELRESP - 1)B_OP_GETF_OP_GETF_OP_GET - 1(F_OP_GET - 1)1 << (F_OP_GET - 1)B_OP_GETPROPF_OP_GETPROPF_OP_GETPROP - 1(F_OP_GETPROP - 1)1 << (F_OP_GETPROP - 1)B_OP_GETRESPF_OP_GETRESPF_OP_GETRESP - 1(F_OP_GETRESP - 1)1 << (F_OP_GETRESP - 1)B_OP_GETPRESPF_OP_GETPRESPF_OP_GETPRESP - 1(F_OP_GETPRESP - 1)1 << (F_OP_GETPRESP - 1)B_OP_REPORTF_OP_REPORTF_OP_REPORT - 1(F_OP_REPORT - 1)1 << (F_OP_REPORT - 1)B_OP_COMMITF_OP_COMMITF_OP_COMMIT - 1(F_OP_COMMIT - 1)1 << (F_OP_COMMIT - 1)B_OP_RCOMMITF_OP_RCOMMITF_OP_RCOMMIT - 1(F_OP_RCOMMIT - 1)1 << (F_OP_RCOMMIT - 1)B_OP_RTRCOMPF_OP_RTRCOMPF_OP_RTRCOMP - 1(F_OP_RTRCOMP - 1)1 << (F_OP_RTRCOMP - 1)_F_OP_MAXforceshTOM_ASS_ITOM_AST_ITOM_CFG_ITOM_QRY_ITOM_EVN_ITOM_RED_ITOM_HBT_ITOM_ASR_ITOM_CNR_ITOM_QRR_I_TOM_RSV_MAXtom_hresv2resv1resultprintvinstancepIDcntpflagsfm_flagsfm_corfm_didfm_sidfm_lenfm_tomfm_vrsvdSUCCESS"SUCCESS"INVALID HEADER"INVALID HEADER"LENGTH MISMATCH"LENGTH MISMATCH"VERSION MISMATCH"VERSION MISMATCH"INVALID DESTINATION PID"INVALID DESTINATION PID"LFB UNKNOWN"LFB UNKNOWN"LFB NOT FOUND"LFB NOT FOUND"LFB INSTANCE ID NOT FOUND"LFB INSTANCE ID NOT FOUND"INVALID PATH"INVALID PATH"COMPONENT DOES NOT EXIST"COMPONENT DOES NOT EXIST"EXISTS ALREADY"EXISTS ALREADY"NOT FOUND"NOT FOUND"READ ONLY"READ ONLY"INVALID ARRAY CREATION"INVALID ARRAY CREATION"VALUE OUT OF RANGE"VALUE OUT OF RANGE"CONTENTS TOO LONG"CONTENTS TOO LONG"INVALID PARAMETERS"INVALID PARAMETERS"INVALID MESSAGE TYPE"INVALID MESSAGE TYPE"INVALID FLAGS"INVALID FLAGS"INVALID TLV"INVALID TLV"EVENT ERROR"EVENT ERROR"NOT SUPPORTED"NOT SUPPORTED"MEMORY ERROR"MEMORY ERROR"INTERNAL ERROR"INTERNAL ERROR"UNSPECIFIED ERROR"UNSPECIFIED ERROR"ForCES_errsInvalid message"Invalid message"KEYINFO TLV"KEYINFO TLV"B_FULLDFULLDATA TLV"FULLDATA TLV"B_SPARDSPARSEDATA TLV"SPARSEDATA TLV"B_RESTVRESULT TLV"RESULT TLV"Inner PATH-DATA TLV"Inner PATH-DATA TLV"ForCES_pdataTOM_ASSNSETUPTWO_TLVASSNS_OPSAssociation Setup"Association Setup"TOM_ASSNTEARDTTLV_T1Association TearDown"Association TearDown"TOM_CONFIG244TTLV_T2206710259CFG_OPSConfig"Config"TOM_QUERYCFG_QYTOM_EVENTNOTCFG_EVNEvent Notification"Event Notification"TOM_PKTREDIRPacket Redirect"Packet Redirect"TOM_HEARTBTHeartBeat"HeartBeat"TOM_ASSNSETREPAssociation Response"Association Response"TOM_CONFIGREP4140nlprefCFG_ROPSConfig Response"Config Response"TOM_QUERYREPCFG_QYRQuery Response"Query Response"ForCES_msgInvalid total length"Invalid total length"xLV too short"xLV too short"xLV too long"xLV too long"data padding missing"data padding missing"ForCES_TLV_errF_TLV_RSVDInvalid TLV"Invalid TLV"F_TLV_REDRREDIRECT TLV"REDIRECT TLV"F_TLV_ASRSASResult TLV"ASResult TLV"F_TLV_ASRTASTreason TLV"ASTreason TLV"F_TLV_LFBSLFBselect TLV"LFBselect TLV"PATH-DATA TLV"PATH-DATA TLV"METADATA TLV"METADATA TLV"REDIRECTDATA TLV"REDIRECTDATA TLV"ForCES_TLVind_bufInvalid OPTLV"Invalid OPTLV" Set" Set" SetProp" SetProp" SetResp" SetResp" SetPropResp" SetPropResp" Del" Del" DelResp" DelResp" Get" Get" GetProp" GetProp" GetResp" GetResp" GetPropResp" GetPropResp"" Report" Commit" Commit" RCommit" RCommit" RTRCOMP" RTRCOMP"OPTLV_msgF_LFB_RSVDF_LFB_FEOFEObj LFB"FEObj LFB"F_LFB_FEPOFEProtoObj LFB"FEProtoObj LFB"ForCES_LFBsStartofTransaction"StartofTransaction"MiddleofTransaction"MiddleofTransaction"EndofTransaction"EndofTransaction"abort"abort"ForCES_TPsStandalone"Standalone"2PCtransaction"2PCtransaction"ForCES_ATsEMReserved"EMReserved"execute-all-or-none"execute-all-or-none"execute-until-failure"execute-until-failure"continue-execute-on-failure"continue-execute-on-failure"ForCES_EMsNoACK"NoACK"SuccessACK"SuccessACK"FailureACK"FailureACK"AlwaysACK"AlwaysACK"ForCES_ACKs[|forces]"[|forces]"(_TOM_RSV_MAX - 1)(B_OP_REPORT)(B_OP_GETRESP|B_OP_GETPRESP)(B_OP_GET|B_OP_GETPROP)(B_OP_SETRESP|B_OP_SETPRESP|B_OP_DELRESP|B_OP_RCOMMIT)(B_OP_SET|B_OP_SETPROP|B_OP_DEL|B_OP_COMMIT|B_OP_RTRCOMP)GO_NXT_ILV(ilv,rlen)((rlen) -= F_ALN_LEN(EXTRACT_32BITS(&(ilv)->length)), (const struct forces_ilv *)(((const char*)(ilv)) + F_ALN_LEN(EXTRACT_32BITS(&(ilv)->length))))ILV_DATA(ilvp)((const void*)(((const char*)(ilvp)) + ILV_SET_LEN(0)))ILV_RDAT_LEN(ilv)((int)(EXTRACT_32BITS(&(ilv)->length)) - ILV_SET_LEN(0))ILV_ALN_LEN(len)F_ALN_LEN(ILV_SET_LEN(len))ILV_SET_LEN(len)(F_ALN_LEN(ILV_HDRL) + (len))GO_NXT_TLV(tlv,rlen)((rlen) -= F_ALN_LEN(EXTRACT_16BITS(&(tlv)->length)), (const struct forces_tlv*)(((const char*)(tlv)) + F_ALN_LEN(EXTRACT_16BITS(&(tlv)->length))))TLV_DATA(tlvp)((const void*)(((const char*)(tlvp)) + TLV_SET_LEN(0)))TLV_RDAT_LEN(tlv)((int)(EXTRACT_16BITS(&(tlv)->length) - TLV_SET_LEN(0))TLV_ALN_LEN(len)F_ALN_LEN(TLV_SET_LEN(len))TLV_SET_LEN(len)(F_ALN_LEN(TLV_HDRL) + (len))GET_TOP_TLV(fhdr)((const struct forces_tlv *)((fhdr) + sizeof (struct forcesh)))F_ALN_LEN(len)( ((len)+ForCES_ALNL-1) & ~(ForCES_ALNL-1) )F_TLV_VNSTF_TLV_TRNG0x01130x0110(_F_OP_MAX - 1)ForCES_HLN_VALID(fhl,tlen)((tlen) >= ForCES_HDRL && (fhl) >= ForCES_HDRL && (fhl) == (tlen))ForCES_RS2(forcesh)((EXTRACT_32BITS(&(forcesh)->fm_flags)&0x0007FFFF) >> 0)ForCES_TP(forcesh)((EXTRACT_32BITS(&(forcesh)->fm_flags)&0x00180000) >> 19)ForCES_AT(forcesh)((EXTRACT_32BITS(&(forcesh)->fm_flags)&0x00200000) >> 21)ForCES_EM(forcesh)((EXTRACT_32BITS(&(forcesh)->fm_flags)&0x00C00000) >> 22)ForCES_RS1(forcesh)((EXTRACT_32BITS(&(forcesh)->fm_flags)&0x07000000) >> 24)ForCES_PRI(forcesh)((EXTRACT_32BITS(&(forcesh)->fm_flags)&0x38000000) >> 27)ForCES_ACK(forcesh)((EXTRACT_32BITS(&(forcesh)->fm_flags)&0xC0000000) >> 30)ForCES_DID(forcesh)EXTRACT_32BITS(&(forcesh)->fm_did)ForCES_SID(forcesh)EXTRACT_32BITS(&(forcesh)->fm_sid)ForCES_BLN(forcesh)((uint32_t)(EXTRACT_16BITS(&(forcesh)->fm_len) << 2))ForCES_V(forcesh)((forcesh)->fm_vrsvd >> 4)(ONE_MORE_TTLV|MAX_TLV)(ONE_MORE_TTLV|ONE_TLV)MAX_TLVONE_TLVZERO_TLVForCES_ALNLForCES_VERS/*
	 * XXX - if ttlv != 0, does that mean that the packet was too
	 * short, and didn't have *enough* TLVs in it?
	 *//*
		 * At this point, tlv_valid() has ensured that the TLV
		 * length is large enough but not too large (it doesn't
		 * go past the end of the packet).
		 *//*XXX: 15 top level tlvs will probably be fine
	   You are nuts if you send more ;-> *//*
	 * forces_print() has already checked that mlen >= ForCES_HDRL
	 * by calling ForCES_HLN_VALID().
	 *//*
		 * At this point, tlv_valid() has ensured that the TLV
		 * length is large enough but not too large (it doesn't
		 * go past the end of the containing TLV).
		 *//*
	 * At this point, we know that dlen > OP_MIN; OP_OFF < OP_MIN, so
	 * we also know that it's > OP_OFF.
	 *//* id, instance, oper tlv header .. *//*
	 * forces_type_print() has ensured that len (the TLV length)
	 * >= TLV_HDRL.
	 *//*
		 * At this point, ilv_valid() has ensured that the ILV
		 * length is large enough but not too large (it doesn't
		 * go past the end of the containing TLV).
		 *//*
	 * redirect_print() has ensured that len (what remains in the
	 * TLV) >= TLV_HDRL.
	 *//*
	 * print_metatlv() has ensured that len (what remains in the
	 * ILV) >= ILV_HDRL.
	 *//* XXX: check header length *//* at least 32 bits must exist *//*
 * XXX - not used.
 *//* id, instance, oper tlv *//* XXX - do anything with ops->flags? *//* rest of ops must at least have 12B {pathinfo} *//*
	 * lfbselect_print() has ensured that EXTRACT_16BITS(&otlv->length)
	 * >= TLV_HDRL.
	 *//* XXX: Argh, recurse some more *//* Table SET append operation *//* Table GET Range operation *//* skip key content *//* skip header *//* skip keyid *//*
	 * At this point, tlv_valid() has ensured that the TLV
	 * length is large enough but not too large (it doesn't
	 * go past the end of the containing TLV).
	 *//*
	 * pdatacnt_print() has ensured that len (the TLV length)
	 * >= TLV_HDRL.
	 *//*
	 * pdatacnt_print() or pkeyitlv_print() has ensured that len
	 * (the TLV length) >= TLV_HDRL.
	 *//* 0x18-0xFE are reserved .. *//* PD_PDT_I *//* PD_RES_I *//* PD_SDT_I *//* PD_FDT_I *//* PD_SEL_I *//* PD_RSV_I *//* TOM_QRR_I *//* TOM_CNR_I *//* TOM_ASR_I *//* TOM_HBT_I *//* TOM_RED_I *//* TOM_EVN_I *//* TOM_QRY_I *//* TOM_CFG_I *//* TOM_AST_I *//* TOM_ASS_I *//* TOM_RSV_I *//* XXX: *//* I guess we should allow vendor operations? *//* F_OP_RTRCOMP *//* F_OP_RCOMMIT *//* F_OP_COMMIT *//* F_OP_REPORT *//* F_OP_GETPRESP *//* F_OP_GETRESP *//* F_OP_GETPROP *//* F_OP_GET *//* F_OP_DELRESP *//* F_OP_DEL *//* F_OP_SETPRESP *//* F_OP_SETRESP *//* F_OP_SETPROP *//* F_OP_SET *//* F_OP_RSV *//*   http://www.iana.org/assignments/forces/forces.xhtml#oper-tlv-types *//* this is defined in RFC5810 section A.2 *//* flags *//* correlator *//* Destination ID *//* Source ID *//* total length * 4 bytes *//* type of message *//* version and reserved *//*
 * Structure of forces header, naked of TLVs.
 *//*
 * tom_h Flags: resv1(8b):maxtlvs(4b):resv2(2b):mintlv(2b)
*//* specification: RFC 5810 *//* \summary: Forwarding and Control Element Separation (ForCES) Protocol printer *//*
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that: (1) source code
 * distributions retain the above copyright notice and this paragraph
 * in its entirety, and (2) distributions including binary code include
 * the above copyright notice and this paragraph in its entirety in
 * the documentation or other materials provided with the distribution.
 * THIS SOFTWARE IS PROVIDED ``AS IS'' AND
 * WITHOUT ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, WITHOUT
 * LIMITATION, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS
 * FOR A PARTICULAR PURPOSE.
 *
 * Copyright (c) 2009 Mojatatu Networks, Inc
 *
 *//Users/owura/Repos/codeql_eval/proj_repos/the-tcpdump-group-tcpdump-commit-9ba91381954ad325ea4fd26b9c65a8bd9a2a85b6/tcpdump/print-fr.cfr_q933_print_ie_codeset_0_5dlci(ndo, "Invalid REPORT TYPE IE")(ndo, "%s (%u)", tok2str(fr_lmi_report_type_ie_values,"unknown",p[0]), p[0])(ndo, "Invalid LINK VERIFY IE")(ndo, "TX Seq: %3d, RX Seq: %3d", p[0], p[1])(ndo, "Invalid DLCI in PVC STATUS IE")(ndo, "DLCI %u: status %s%s", dlci, p[ielength - 1] & 0x8 ? "New, " : "", p[ielength - 1] & 0x2 ? "Active" : "Inactive")FR_LMI_ANSI_REPORT_TYPE_IEFR_LMI_CCITT_REPORT_TYPE_IEInvalid REPORT TYPE IE%s (%u)FR_LMI_ANSI_LINK_VERIFY_IEFR_LMI_CCITT_LINK_VERIFY_IEFR_LMI_ANSI_LINK_VERIFY_IE_91Invalid LINK VERIFY IETX Seq: %3d, RX Seq: %3dFR_LMI_ANSI_PVC_STATUS_IEFR_LMI_CCITT_PVC_STATUS_IEInvalid DLCI in PVC STATUS IE0x780x7EDLCI %u: status %s%sNew, ActiveInactiveq933_printolencall_ref_lengthuint8_t[15]unsigned char[15]msgtypeiecodeielengthcodesetis_ansiie_is_knownnon_locking_shiftunshift_codeset(ndo, "%s", ndo->ndo_eflag ? "" : "Q.933")sizeof(*p)(ndo, "length %u", length)length %u(ndo, "length %u", olen)(ndo, "%s, codeset %u", is_ansi ? "ANSI" : "CCITT", codeset)%s, codeset %uANSICCITT(ndo, ", Call Ref: 0x")(ndo, "%02x", call_ref[i]), Call Ref: 0x(ndo, ", %s (0x%02x), length %u", tok2str(fr_q933_msg_values, "unknown message", msgtype), msgtype, olen)(ndo, ", %s", tok2str(fr_q933_msg_values, "unknown message 0x%02x", msgtype)), %s (0x%02x), length %uunknown messageunknown message 0x%02x(ndo, ", length %u", olen)(ndo, "\n\t%s IE (0x%02x), length %u: ", tok2str(fr_q933_ie_codesets[codeset], "unknown", iecode), iecode, ielength)
	%s IE (0x%02x), length %u: const codeset_pr_func_tconst codeset_pr_func_t[16]..(*[16])(..)const codeset_pr_func_t *(ndo, "[|q.933]")[|q.933]frf15_printsequence_numMFR_BEC_MASK0x1e(ndo, "FRF.15, seq 0x%03x, Flags [%s],%s Fragmentation, length %u", sequence_num, bittok2str(frf_flag_values,"none",flags), p[0]&FR_FRF15_FRAGTYPE ? "Interface" : "End-to-End", length)(ndo, "FRF.15, seq 0x%03x, Flags [%s],%s Fragmentation, length %u", sequence_num, bittok2str(frf_flag_values,"none",flags), p[0]&0x01 ? "Interface" : "End-to-End", length)FRF.15, seq 0x%03x, Flags [%s],%s Fragmentation, length %uInterfaceEnd-to-End(ndo, "[|frf.15]")[|frf.15]mfr_printhdr_lenie_typeie_len(ndo, "Message too short (%u bytes)", length)Message too short (%u bytes)(ndo, "FRF.16 Control, Flags [%s], %s, length %u", bittok2str(frf_flag_values,"none",(p[0] & MFR_BEC_MASK)), tok2str(mfr_ctrl_msg_values,"Unknown Message (0x%02x)",p[2]), length)(ndo, "FRF.16 Control, Flags [%s], %s, length %u", bittok2str(frf_flag_values,"none",(p[0] & (0x80 | 0x40 | 0x20))), tok2str(mfr_ctrl_msg_values,"Unknown Message (0x%02x)",p[2]), length)sizeof(struct ie_tlv_header_t)(ndo, "\n\tIE %s (%u), length %u: ", tok2str(mfr_ctrl_ie_values,"Unknown",ie_type), ie_type, ie_len)(ndo, "(invalid length)")(ndo, "0x%08x", EXTRACT_32BITS(tptr))(ndo, "0x%08x", ((uint32_t)(((uint32_t)(*((const uint8_t *)(tptr) + 0)) << 24) | ((uint32_t)(*((const uint8_t *)(tptr) + 1)) << 16) | ((uint32_t)(*((const uint8_t *)(tptr) + 2)) << 8) | ((uint32_t)(*((const uint8_t *)(tptr) + 3)) << 0))))MFR_CTRL_FRAMEFRF.16 Control, Flags [%s], %s, length %uUnknown Message (0x%02x)
	IE %s (%u), length %u: MFR_CTRL_IE_MAGIC_NUM(invalid length)0x%08xMFR_CTRL_IE_BUNDLE_IDMFR_CTRL_IE_LINK_IDMFR_ID_STRING_MAXLENMFR_CTRL_IE_TIMESTAMPsizeof(struct timeval)const timevalconst timeval *timeval *MFR_CTRL_IE_VENDOR_EXTMFR_CTRL_IE_CAUSE(ndo, "FRF.16 Frag, seq %u, Flags [%s], ", sequence_num, bittok2str(frf_flag_values,"none",(p[0] & MFR_BEC_MASK)))(ndo, "FRF.16 Frag, seq %u, Flags [%s], ", sequence_num, bittok2str(frf_flag_values,"none",(p[0] & (0x80 | 0x40 | 0x20))))MFR_FRAG_FRAMEMFR_B_BITFRF.16 Frag, seq %u, Flags [%s], (ndo, "FRF.16 Frag, seq %u, Flags [%s]", sequence_num, bittok2str(frf_flag_values,"none",(p[0] & MFR_BEC_MASK)))(ndo, "FRF.16 Frag, seq %u, Flags [%s]", sequence_num, bittok2str(frf_flag_values,"none",(p[0] & (0x80 | 0x40 | 0x20))))FRF.16 Frag, seq %u, Flags [%s](ndo, "[|mfr]")[|mfr]mfr_if_printfr_printextracted_ethertypeaddr_lennlpidu_int *(ndo, "Q.922, invalid address")Q.922, invalid addressp[addr_len]sizeof(p[addr_len])(ndo, "UI %02x! ", p[addr_len])p+addr_lenUI %02x! p[addr_len+1]sizeof(p[addr_len+1])(ndo, "Pad! ")(ndo, "No pad! ")Pad! No pad! p[hdr_len - 1]sizeof(p[hdr_len - 1])p - hdr_lenlength + hdr_len(ndo, "[|fr]")[|fr]fr_if_printfr_hdr_print(ndo, "Q.922, DLCI %u, length %u: ", dlci, length)(ndo, "Q.922, hdr-len %u, DLCI %u, Flags [%s], NLPID %s (0x%02x), length %u: ", addr_len, dlci, bittok2str(fr_header_flag_values, "none", EXTRACT_32BITS(flags)), tok2str(nlpid_values,"unknown", nlpid), nlpid, length)(ndo, "Q.922, hdr-len %u, DLCI %u, Flags [%s], NLPID %s (0x%02x), length %u: ", addr_len, dlci, bittok2str(fr_header_flag_values, "none", ((uint32_t)(((uint32_t)(*((const uint8_t *)(flags) + 0)) << 24) | ((uint32_t)(*((const uint8_t *)(flags) + 1)) << 16) | ((uint32_t)(*((const uint8_t *)(flags) + 2)) << 8) | ((uint32_t)(*((const uint8_t *)(flags) + 3)) << 0)))), tok2str(nlpid_values,"unknown", nlpid), nlpid, length)(ndo, "Q.922, hdr-len %u, DLCI %u, Flags [%s], cisco-ethertype %s (0x%04x), length %u: ", addr_len, dlci, bittok2str(fr_header_flag_values, "none", EXTRACT_32BITS(flags)), tok2str(ethertype_values, "unknown", nlpid), nlpid, length)(ndo, "Q.922, hdr-len %u, DLCI %u, Flags [%s], cisco-ethertype %s (0x%04x), length %u: ", addr_len, dlci, bittok2str(fr_header_flag_values, "none", ((uint32_t)(((uint32_t)(*((const uint8_t *)(flags) + 0)) << 24) | ((uint32_t)(*((const uint8_t *)(flags) + 1)) << 16) | ((uint32_t)(*((const uint8_t *)(flags) + 2)) << 8) | ((uint32_t)(*((const uint8_t *)(flags) + 3)) << 0)))), tok2str(ethertype_values, "unknown", nlpid), nlpid, length)Q.922, DLCI %u, length %u: Q.922, hdr-len %u, DLCI %u, Flags [%s], NLPID %s (0x%02x), length %u: Q.922, hdr-len %u, DLCI %u, Flags [%s], cisco-ethertype %s (0x%04x), length %u: q922_stringsizeof("DLCI xxxxxxxxxx")buffer0, sizeof(buffer)sizeof(buffer)"DLCI %u", dlciDLCI %uparse_q922_addrFR_EA_BITsizeof(p[1])0xFCcodeset_pr_func_tie_tlv_header_tconst codeset_pr_func_t[]..(*[])(..)fr_q933_print_ie_codesetconst tok *[]tok *[]fr_q933_ie_codesetsFR_LMI_REPORT_TYPE_IE_FULL_STATUSFull Status"Full Status"FR_LMI_REPORT_TYPE_IE_LINK_VERIFYLink verify"Link verify"FR_LMI_REPORT_TYPE_IE_ASYNC_PVCAsync PVC Status"Async PVC Status"fr_lmi_report_type_ie_valuesANSI Report Type"ANSI Report Type"ANSI Link Verify"ANSI Link Verify"ANSI PVC Status"ANSI PVC Status"CCITT Report Type"CCITT Report Type"CCITT Link Verify"CCITT Link Verify"CCITT PVC Status"CCITT PVC Status"fr_q933_ie_values_codeset_0_5MSG_TYPE_ESC_TO_NATIONALESC to National"ESC to National"MSG_TYPE_ALERTAlert"Alert"MSG_TYPE_CALL_PROCEEDINGCall proceeding"Call proceeding"MSG_TYPE_CONNECTMSG_TYPE_CONNECT_ACKConnect ACK"Connect ACK"MSG_TYPE_PROGRESSProgress"Progress"MSG_TYPE_SETUPMSG_TYPE_DISCONNECTDisconnect"Disconnect"MSG_TYPE_RELEASEMSG_TYPE_RELEASE_COMPLETERelease Complete"Release Complete"MSG_TYPE_RESTARTMSG_TYPE_RESTART_ACKRestart ACK"Restart ACK"MSG_TYPE_STATUSStatus Reply"Status Reply"MSG_TYPE_STATUS_ENQStatus Enquiry"Status Enquiry"fr_q933_msg_valuesBundle ID"Bundle ID"Link ID"Link ID"Magic Number"Magic Number"Timestamp"Timestamp"Vendor Extension"Vendor Extension"Cause"Cause"mfr_ctrl_ie_valuesMFR_CTRL_MSG_ADD_LINKAdd Link"Add Link"MFR_CTRL_MSG_ADD_LINK_ACKAdd Link ACK"Add Link ACK"MFR_CTRL_MSG_ADD_LINK_REJAdd Link Reject"Add Link Reject"MFR_CTRL_MSG_HELLOMFR_CTRL_MSG_HELLO_ACKHello ACK"Hello ACK"MFR_CTRL_MSG_REMOVE_LINKRemove Link"Remove Link"MFR_CTRL_MSG_REMOVE_LINK_ACKRemove Link ACK"Remove Link ACK"mfr_ctrl_msg_valuesBegin"Begin"MFR_E_BITMFR_C_BITControl"Control"frf_flag_values33554432FR_CR_BITC!"C!"FR_DE_BITDE"DE"FR_BECN_BITBECN"BECN"FR_FECN_BITFECN"FECN"FR_SDLC_BITsdlcore"sdlcore"fr_header_flag_values0x570x530x510x19IE_SHIFT_CODESET(iecode)((iecode) & 0x07)IE_SHIFT_IS_LOCKING(iecode)(!(IE_SHIFT_IS_NON_LOCKING(iecode)))IE_SHIFT_IS_NON_LOCKING(iecode)((iecode) & 0x08)IE_IS_SHIFT(iecode)(((iecode) & 0xF0) == 0x90)IE_IS_SINGLE_OCTET(iecode)((iecode) & 0x80)0x7D0x4E0x5A0x4D0x45FR_FRF15_FRAGTYPE(MFR_B_BIT | MFR_E_BIT )(MFR_B_BIT | MFR_E_BIT | MFR_C_BIT)0x000000020x000800000x000400000x000200000x02000000/* now parse the DLCI information element. *//*
				 * Unknown IE; if we're printing verbosely,
				 * print its content in hex.
				 *//* Yes. *//*
				 * Known IE; do we want to see a hexdump
				 * of it?
				 *//* sanity checks *//* lets do the full IE parsing only in verbose mode
			 * however some IEs (DLCI Status, Link Verify)
			 * are also interesting in non-verbose mode *//*
			 * No.  Get the IE length.
			 *//*
				 * Get the codeset.
				 *//*
					 * No.  Remember the current
					 * codeset, so we can revert
					 * to it after the next IE.
					 *//*
					 * Yes.
					 *//*
				 * Yes.  Is it locking?
				 *//*
			 * Yes.  Is it a shift?
			 *//* Single-octet IE? *//*
		 * Get the first octet of the IE.
		 *//*
			 * Unshift.
			 *//*
			 * There's a non-locking shift in effect for
			 * this IE.  Count it, so we reset the codeset
			 * before the next IE.
			 *//*
		 * What's the state of any non-locking shifts?
		 *//* Loop through the rest of the IEs *//*
			 * Not a dummy call reference.
			 *//* printing out header part *//*
				 * It's a non-locking shift.
				 * Remember the current codeset, so we
				 * can revert to it after the next IE.
				 *//*
					 * It's a locking shift to
					 * codeset 5, so this is
					 * T1.617 Annex D.
					 *//*
				 * It's a locking shift.
				 *//*
			 * If it's a locking shift to codeset 5,
			 * mark this as ANSI.  (XXX - 5 is actually
			 * for national variants in general, not
			 * the US variant in particular, but maybe
			 * this is more American exceptionalism. :-))
			 *//*
			 * Get the codeset.
			 *//*
			 * It's a shift.  Skip over it.
			 *//*
	 * Peek ahead to see if we start with a shift.
	 *//*
	 * Get the message type.
	 *//*
	 * Get the call reference value.
	 *//* preserve the original length for display *//*
	 * Get the length of the call reference value.
	 *//* maximum length - length field is 4 bits *//*
 * ITU-T Q.933.
 *
 * p points to octet 2, the octet containing the length of the
 * call reference value, so p[n] is octet n+2 ("octet X" is as
 * used in Q.931/Q.933).
 *
 * XXX - actually used both for Q.931 and Q.933.
 *//* array of 16 codesets - currently we only support codepage 0 and 5 *//* details? *//* Status *//* Call Clear *//* Call Establish *//*
 * L2 (Octet 2)- Message Types definition 1 byte long.
 *//* L2 (Octet 1)- Call Reference Usually is 0x0 *//* Q.933 packet format
                      Format of Other Protocols
                          using Q.933 NLPID
                  +-------------------------------+
                  |        Q.922 Address          |
                  +---------------+---------------+
                  |Control  0x03  | NLPID   0x08  |
                  +---------------+---------------+
                  |          L2 Protocol ID       |
                  | octet 1       |  octet 2      |
                  +-------------------------------+
                  |          L3 Protocol ID       |
                  | octet 2       |  octet 2      |
                  +-------------------------------+
                  |         Protocol Data         |
                  +-------------------------------+
                  | FCS                           |
                  +-------------------------------+
 *//*
 * Q.933 decoding portion for framerelay specific.
 *//* TODO:
 * depending on all permutations of the B, E and C bit
 * dig as deep as we can - e.g. on the first (B) fragment
 * there is enough payload to print the IP header
 * on non (B) fragments it depends if the fragmentation
 * model is end-to-end or interface based wether we want to print
 * another Q.922 header
 *//* an NLPID of 0xb1 indicates a 2-byte
 * FRF.15 header
 *
 *      7    6    5    4    3    2    1    0
 *    +----+----+----+----+----+----+----+----+
 *    ~              Q.922 header             ~
 *    +----+----+----+----+----+----+----+----+
 *    |             NLPID (8 bits)            | NLPID=0xb1
 *    +----+----+----+----+----+----+----+----+
 *    | B  | E  | C  |seq. (high 4 bits) | R  |
 *    +----+----+----+----+----+----+----+----+
 *    |        sequence  (low 8 bits)         |
 *    +----+----+----+----+----+----+----+----+
 *//* must be a middle or the last fragment *//* whole packet or first fragment ? *//*
 * FRF.16 Fragmentation Frame
 *
 *      7    6    5    4    3    2    1    0
 *    +----+----+----+----+----+----+----+----+
 *    | B  | E  | C=0|seq. (high 4 bits) | EA  |
 *    +----+----+----+----+----+----+----+----+
 *    |        sequence  (low 8 bits)         |
 *    +----+----+----+----+----+----+----+----+
 *    |        DLCI (6 bits)        | CR | EA  |
 *    +----+----+----+----+----+----+----+----+
 *    |   DLCI (4 bits)   |FECN|BECN| DE | EA |
 *    +----+----+----+----+----+----+----+----+
 *//* do we want to see a hexdump of the IE ? *//*
                 * FIXME those are the defined IEs that lack a decoder
                 * you are welcome to contribute code ;-)
                 *//* fall through and hexdump if no unix timestamp *//* don't print null termination *//* same message format *//* FRF.16.1 Section 3.4.3 Magic Number Information Element *//* tlv len includes header *//* minimum frame header length *//*
 * FRF.16 Link Integrity Control Frame
 *
 *      7    6    5    4    3    2    1    0
 *    +----+----+----+----+----+----+----+----+
 *    | B  | E  | C=1| 0    0    0    0  | EA |
 *    +----+----+----+----+----+----+----+----+
 *    | 0    0    0    0    0    0    0    0  |
 *    +----+----+----+----+----+----+----+----+
 *    |              message type             |
 *    +----+----+----+----+----+----+----+----+
 *//* OSI printers need the NLPID field *//* NLPID *//* UI *//*
		 * Not a pad byte.
		 * A pad byte should be used with 3-byte Q.922.
		 *//*
		 * Assume a pad byte after the control (UI) byte.
		 * A pad byte should only be used with 3-byte Q.922.
		 *//* ether_type not known, probably it wasn't one *//* no Ethertype *//*
                 * Let's figure out if we have Cisco-style encapsulation,
                 * with an Ethernet type (Cisco HDLC type?) following the
                 * address.
                 *//* must be an ethertype *//* if its smaller than 256 then its a NLPID *//* Frame Relay packet structure, with flags and CRC removed

                  +---------------------------+
                  |       Q.922 Address*      |
                  +--                       --+
                  |                           |
                  +---------------------------+
                  | Control (UI = 0x03)       |
                  +---------------------------+
                  | Optional Pad      (0x00)  |
                  +---------------------------+
                  | NLPID                     |
                  +---------------------------+
                  |             .             |
                  |             .             |
                  |             .             |
                  |           Data            |
                  |             .             |
                  |             .             |
                  +---------------------------+

           * Q.922 addresses, as presently defined, are two octets and
             contain a 10-bit DLCI.  In some networks Q.922 addresses
             may optionally be increased to three or four octets.
*//* more than 4 bytes of Q.922 address? *//* 4-byte Q.922 address *//* 3- or 4-byte Q.922 address *//* 2-byte Q.922 address *//* clear the rest of the flags *//* populate the first flag fields *//* Finds out Q.922 address length, DLCI and flags. Returns 1 on success,
 * 0 on invalid address, -1 on truncated packet
 * save the flags dep. on address length
 *//* FRF.15 / FRF.16 *//*
 * the frame relay header has a variable length
 *
 * the EA bit determines if there is another byte
 * in the header
 *
 * minimum header length is 2 bytes
 * maximum header length is 4 bytes
 *
 *      7    6    5    4    3    2    1    0
 *    +----+----+----+----+----+----+----+----+
 *    |        DLCI (6 bits)        | CR | EA |
 *    +----+----+----+----+----+----+----+----+
 *    |   DLCI (4 bits)   |FECN|BECN| DE | EA |
 *    +----+----+----+----+----+----+----+----+
 *    |           DLCI (7 bits)          | EA |
 *    +----+----+----+----+----+----+----+----+
 *    |        DLCI (6 bits)        |SDLC| EA |
 *    +----+----+----+----+----+----+----+----+
 *//* \summary: Frame Relay printer *//Users/owura/Repos/codeql_eval/proj_repos/the-tcpdump-group-tcpdump-commit-9ba91381954ad325ea4fd26b9c65a8bd9a2a85b6/tcpdump/print-frag6.cfrag6_printconst ip6_fragconst ip6_frag *ip6_frag *(ndo, "frag (0x%08x:%d|%ld)", EXTRACT_32BITS(&dp->ip6f_ident), EXTRACT_16BITS(&dp->ip6f_offlg) & IP6F_OFF_MASK, sizeof(struct ip6_hdr) + EXTRACT_16BITS(&ip6->ip6_plen) - (long)(bp - bp2) - sizeof(struct ip6_frag))(ndo, "frag (0x%08x:%d|%ld)", ((uint32_t)(((uint32_t)(*((const uint8_t *)(&dp->ip6f_ident) + 0)) << 24) | ((uint32_t)(*((const uint8_t *)(&dp->ip6f_ident) + 1)) << 16) | ((uint32_t)(*((const uint8_t *)(&dp->ip6f_ident) + 2)) << 8) | ((uint32_t)(*((const uint8_t *)(&dp->ip6f_ident) + 3)) << 0))), ((uint16_t)(((uint16_t)(*((const uint8_t *)(&dp->ip6f_offlg) + 0)) << 8) | ((uint16_t)(*((const uint8_t *)(&dp->ip6f_offlg) + 1)) << 0))) & 0xfff8, sizeof(struct ip6_hdr) + ((uint16_t)(((uint16_t)(*((const uint8_t *)(&ip6->ip6_ctlun.ip6_un1.ip6_un1_plen) + 0)) << 8) | ((uint16_t)(*((const uint8_t *)(&ip6->ip6_ctlun.ip6_un1.ip6_un1_plen) + 1)) << 0))) - (long)(bp - bp2) - sizeof(struct ip6_frag))&dp->ip6f_ident&dp->ip6f_offlg&ip6->ip6_plen&ip6->ip6_ctlun.ip6_un1.ip6_un1_plen(ndo, "frag (%d|%ld)", EXTRACT_16BITS(&dp->ip6f_offlg) & IP6F_OFF_MASK, sizeof(struct ip6_hdr) + EXTRACT_16BITS(&ip6->ip6_plen) - (long)(bp - bp2) - sizeof(struct ip6_frag))(ndo, "frag (%d|%ld)", ((uint16_t)(((uint16_t)(*((const uint8_t *)(&dp->ip6f_offlg) + 0)) << 8) | ((uint16_t)(*((const uint8_t *)(&dp->ip6f_offlg) + 1)) << 0))) & 0xfff8, sizeof(struct ip6_hdr) + ((uint16_t)(((uint16_t)(*((const uint8_t *)(&ip6->ip6_ctlun.ip6_un1.ip6_un1_plen) + 0)) << 8) | ((uint16_t)(*((const uint8_t *)(&ip6->ip6_ctlun.ip6_un1.ip6_un1_plen) + 1)) << 0))) - (long)(bp - bp2) - sizeof(struct ip6_frag))frag (0x%08x:%d|%ld)65528frag (%d|%ld)IP6F_OFF_MASKsizeof(struct ip6_frag)(ndo, "[|frag]")[|frag]/* it is meaningless to decode non-first fragment *//* \summary: IPv6 fragmentation header printer *//*
 * Copyright (c) 1988, 1989, 1990, 1991, 1993, 1994
 *	The Regents of the University of California.  All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that: (1) source code distributions
 * retain the above copyright notice and this paragraph in its entirety, (2)
 * distributions including binary code include the above copyright notice and
 * this paragraph in its entirety in the documentation or other materials
 * provided with the distribution, and (3) all advertising materials mentioning
 * features or use of this software display the following acknowledgement:
 * ``This product includes software developed by the University of California,
 * Lawrence Berkeley Laboratory and its contributors.'' Neither the name of
 * the University nor the names of its contributors may be used to endorse
 * or promote products derived from this software without specific prior
 * written permission.
 * THIS SOFTWARE IS PROVIDED ``AS IS'' AND WITHOUT ANY EXPRESS OR IMPLIED
 * WARRANTIES, INCLUDING, WITHOUT LIMITATION, THE IMPLIED WARRANTIES OF
 * MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE.
 *//Users/owura/Repos/codeql_eval/proj_repos/the-tcpdump-group-tcpdump-commit-9ba91381954ad325ea4fd26b9c65a8bd9a2a85b6/tcpdump/print-ftp.cftp_printftp"ftp"/* \summary: File Transfer Protocol (FTP) printer *//*
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that: (1) source code
 * distributions retain the above copyright notice and this paragraph
 * in its entirety, and (2) distributions including binary code include
 * the above copyright notice and this paragraph in its entirety in
 * the documentation or other materials provided with the distribution.
 * THIS SOFTWARE IS PROVIDED ``AS IS'' AND
 * WITHOUT ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, WITHOUT
 * LIMITATION, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS
 * FOR A PARTICULAR PURPOSE.
 *//Users/owura/Repos/codeql_eval/proj_repos/the-tcpdump-group-tcpdump-commit-9ba91381954ad325ea4fd26b9c65a8bd9a2a85b6/tcpdump/print-geneve.cgeneve_printver_optprotvniopts_len(ndo, "Geneve")GeneveVER_SHIFT(ndo, " ERROR: unknown-version %u", version) ERROR: unknown-version %u(ndo, ", Flags [%s]", bittok2str_nosep(geneve_flag_values, "none", flags))(ndo, ", vni 0x%x", vni), vni 0x%x(ndo, ", rsvd 0x%x", reserved), rsvd 0x%x(ndo, ", proto %s (0x%04x)", tok2str(ethertype_values, "unknown", prot), prot), proto %s (0x%04x)HDR_OPTS_LEN_MASK(ndo, " truncated-geneve - %u bytes missing", opts_len - len) truncated-geneve - %u bytes missing(ndo, ", options [")(ndo, "%u bytes", opts_len), options [(ndo, "\n\t")(ndo, "geneve-proto-0x%x", prot)geneve-proto-0x%x(ndo, " [|geneve]") [|geneve]geneve_opts_print(ndo, "%s", sep)(ndo, "class %s (0x%x) type 0x%x%s len %u", format_opt_class(opt_class), opt_class, opt_type, opt_type & OPT_TYPE_CRITICAL ? "(C)" : "", opt_len)(ndo, "class %s (0x%x) type 0x%x%s len %u", format_opt_class(opt_class), opt_class, opt_type, opt_type & (1 << 7) ? "(C)" : "", opt_len)(ndo, " [bad length]")(ndo, " data")(ndo, " %08x", EXTRACT_32BITS(data))(ndo, " %08x", ((uint32_t)(((uint32_t)(*((const uint8_t *)(data) + 0)) << 24) | ((uint32_t)(*((const uint8_t *)(data) + 1)) << 16) | ((uint32_t)(*((const uint8_t *)(data) + 2)) << 8) | ((uint32_t)(*((const uint8_t *)(data) + 3)) << 0))))opt_classopt_typeopt_lenOPT_LEN_MASKclass %s (0x%x) type 0x%x%s len %u(C) [bad length] dataformat_opt_classLinux"Linux"0x0101Open vSwitch"Open vSwitch"Open Virtual Networking (OVN)"Open Virtual Networking (OVN)"In-band Network Telemetry (INT)"In-band Network Telemetry (INT)"0x0104VMware"VMware"0x00ffStandard"Standard"655200xfff0FLAG_OAM"O"FLAG_CRITICALC"C"FLAG_R1R1"R1"FLAG_R2R2"R2"FLAG_R3R3"R3"FLAG_R4R4"R4"FLAG_R5R5"R5"FLAG_R6R6"R6"geneve_flag_valuesOPT_TYPE_CRITICAL(1 << 0)(1 << 1)(1 << 2)(1 << 3)(1 << 4)/*
 * Geneve header, draft-ietf-nvo3-geneve
 *
 *    0                   1                   2                   3
 *    0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
 *    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
 *    |Ver|  Opt Len  |O|C|    Rsvd.  |          Protocol Type        |
 *    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
 *    |        Virtual Network Identifier (VNI)       |    Reserved   |
 *    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
 *    |                    Variable Length Options                    |
 *    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
 *
 * Options:
 *    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
 *    |          Option Class         |      Type     |R|R|R| Length  |
 *    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
 *    |                      Variable Option Data                     |
 *    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
 *//* \summary: Generic Network Virtualization Encapsulation (Geneve) printer *//*
 * Copyright (c) 2014 VMware, Inc. All Rights Reserved.
 *
 * Jesse Gross <jesse@nicira.com>
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that: (1) source code
 * distributions retain the above copyright notice and this paragraph
 * in its entirety, and (2) distributions including binary code include
 * the above copyright notice and this paragraph in its entirety in
 * the documentation or other materials provided with the distribution.
 * THIS SOFTWARE IS PROVIDED ``AS IS'' AND
 * WITHOUT ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, WITHOUT
 * LIMITATION, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS
 * FOR A PARTICULAR PURPOSE.
 *//Users/owura/Repos/codeql_eval/proj_repos/the-tcpdump-group-tcpdump-commit-9ba91381954ad325ea4fd26b9c65a8bd9a2a85b6/tcpdump/print-geonet.cgeonet_printnext_hdrhdr_typehdr_subtypepayload_lengthhop_limitnext_hdr_txthdr_type_txthdr_size(ndo, "GeoNet ")GeoNet (ndo, "src:%s", (src->addr_string)(ndo, src->addr))src:%sbp+4Any"Any"BTP-A"BTP-A"BTP-B"BTP-B"GeoUnicast"GeoUnicast"GeoAnycastCircle"GeoAnycastCircle"GeoAnycastRect"GeoAnycastRect"GeoAnycastElipse"GeoAnycastElipse"GeoBroadcastCircle"GeoBroadcastCircle"GeoBroadcastRect"GeoBroadcastRect"GeoBroadcastElipse"GeoBroadcastElipse"TopoScopeBcast-SH"TopoScopeBcast-SH"TopoScopeBcast-MH"TopoScopeBcast-MH"LocService-Request"LocService-Request"LocService-Reply"LocService-Reply"(ndo, "v:%d ", version)v:%d (ndo, "NH:%d-%s ", next_hdr, next_hdr_txt)NH:%d-%s (ndo, "HT:%d-%d-%s ", hdr_type, hdr_subtype, hdr_type_txt)HT:%d-%d-%s (ndo, "HopLim:%d ", hop_limit)HopLim:%d (ndo, "Payload:%d ", payload_length)Payload:%d 68 - 36(ndo, " Malformed (small) ") Malformed (small) (ndo, "[|geonet]")[|geonet]print_long_pos_vectorlonGEONET_ADDR_LEN(ndo, "GN_ADDR:%s ", linkaddr_string (ndo, bp, 0, GEONET_ADDR_LEN))(ndo, "GN_ADDR:%s ", linkaddr_string (ndo, bp, 0, 8))GN_ADDR:%s *(bp+12)bp+12(ndo, "lat:%d ", lat)lat:%d bp+16(ndo, "lon:%d", lon)lon:%dprint_btpbp+0destbp+2(ndo, "; BTP Dst:%u Src:%u", dest, src); BTP Dst:%u Src:%uprint_btp_bodymsg_type_str"unknown (%u)"(ndo, "; ItsPduHeader v:%d t:%d-%s", version, msg_type, msg_type_str); ItsPduHeader v:%d t:%d-%sCAM"CAM"DENM"DENM"TPEGM"TPEGM"TSPDM"TSPDM"VPM"VPM"SRM"SRM"SLAM"SLAM"ecoCAM"ecoCAM"ITM"ITM"SA"SA"msg_type_values/* XXX - print the remaining data as hex? *//* Print user data part *//* IPv6 *//*
					 * XXX - did print_btp_body()
					 * return if length < 2
					 * because this is optional,
					 * or was that just not
					 * reporting genuine errors?
					 *//* BTP A/B *//* Any *//* Skip Extended headers *//* LocService-Reply *//* LocService-Request *//* TopoScopeBcast-MH *//* TopoScopeBcast-SH *//* GeoBroadcastElipse *//* GeoBroadcastRect *//* GeoBroadcastCircle *//* GeoAnycastElipse *//* GeoAnycastRect *//* GeoAnycastCircle *//* GeoUnicast *//* Beacon *//* Process Extended Headers *//* Skip Common Header *//* Process Common Header *//*
 * This is the top level routine of the printer.  'p' points
 * to the geonet header of the packet.
 *//* Assuming ItsDpuHeader *//*
   ETSI TS 102 636-5-1 V1.1.1 (2011-02)
   Intelligent Transport Systems (ITS); Vehicular Communications; GeoNetworking;
   Part 5: Transport Protocols; Sub-part 1: Basic Transport Protocol

   ETSI TS 102 636-4-1 V1.1.1 (2011-06)
   Intelligent Transport Systems (ITS); Vehicular communications; GeoNetworking;
   Part 4: Geographical addressing and forwarding for point-to-point and point-to-multipoint communications;
   Sub-part 1: Media-Independent Functionality
*//* \summary: ISO CALM FAST and ETSI GeoNetworking printer *//Users/owura/Repos/codeql_eval/proj_repos/the-tcpdump-group-tcpdump-commit-9ba91381954ad325ea4fd26b9c65a8bd9a2a85b6/tcpdump/print-gre.cgre_sre_asn_print(ndo, ", badoffset=%u", sreoff), badoffset=%u(ndo, ", badlength=%u", srelen), badlength=%u(ndo, ", badoff/len=%u/%u", sreoff, srelen), badoff/len=%u/%u(ndo, " %s%x", ((bp - up) == sreoff) ? "*" : "", EXTRACT_16BITS(bp))(ndo, " %s%x", ((bp - up) == sreoff) ? "*" : "", ((uint16_t)(((uint16_t)(*((const uint8_t *)(bp) + 0)) << 8) | ((uint16_t)(*((const uint8_t *)(bp) + 1)) << 0)))) %s%xgre_sre_ip_print(ndo, " %s%s", ((bp - up) == sreoff) ? "*" : "", buf) %s%sgre_sre_print(ndo, ", (rtaf=ip")(ndo, ", (rtaf=asn")(ndo, ", (rtaf=0x%x)", af)GRESRE_IP, (rtaf=ip65534GRESRE_ASN, (rtaf=asn, (rtaf=0x%x)gre_print_1(ndo, ", Flags [%s]", bittok2str(gre_flag_values,"none",flags))(ndo, ", call %d", k & 0xffff)GRE_KPsreoffsrelen, call %d(ndo, ", seq %u", EXTRACT_32BITS(bp))(ndo, ", seq %u", ((uint32_t)(((uint32_t)(*((const uint8_t *)(bp) + 0)) << 24) | ((uint32_t)(*((const uint8_t *)(bp) + 1)) << 16) | ((uint32_t)(*((const uint8_t *)(bp) + 2)) << 8) | ((uint32_t)(*((const uint8_t *)(bp) + 3)) << 0))))GRE_SP, seq %u(ndo, ", ack %u", EXTRACT_32BITS(bp))(ndo, ", ack %u", ((uint32_t)(((uint32_t)(*((const uint8_t *)(bp) + 0)) << 24) | ((uint32_t)(*((const uint8_t *)(bp) + 1)) << 16) | ((uint32_t)(*((const uint8_t *)(bp) + 2)) << 8) | ((uint32_t)(*((const uint8_t *)(bp) + 3)) << 0))))GRE_AP, ack %u(ndo, ", no-payload"), no-payload(ndo, ", proto %s (0x%04x)", tok2str(ethertype_values,"unknown",prot), prot)(ndo, ", length %u",length)(ndo, "gre-proto-0x%x", prot)gre-proto-0x%xgre_print_0(ndo, ", sum 0x%x", EXTRACT_16BITS(bp))(ndo, ", sum 0x%x", ((uint16_t)(((uint16_t)(*((const uint8_t *)(bp) + 0)) << 8) | ((uint16_t)(*((const uint8_t *)(bp) + 1)) << 0))))(ndo, ", off 0x%x", EXTRACT_16BITS(bp))(ndo, ", off 0x%x", ((uint16_t)(((uint16_t)(*((const uint8_t *)(bp) + 0)) << 8) | ((uint16_t)(*((const uint8_t *)(bp) + 1)) << 0))))GRE_CPGRE_RP, sum 0x%x, off 0x%x(ndo, ", key=0x%x", EXTRACT_32BITS(bp))(ndo, ", key=0x%x", ((uint32_t)(((uint32_t)(*((const uint8_t *)(bp) + 0)) << 24) | ((uint32_t)(*((const uint8_t *)(bp) + 1)) << 16) | ((uint32_t)(*((const uint8_t *)(bp) + 2)) << 8) | ((uint32_t)(*((const uint8_t *)(bp) + 3)) << 0)))), key=0x%xgre_printGRE_VERS_MASK(ndo, "GREv%u",vers)GREv%u(ndo, " ERROR: unknown-version") ERROR: unknown-versionchecksum present"checksum present"routing present"routing present"key present"key present"sequence# present"sequence# present"GRE_sPsource routing present"source routing present"1792GRE_RECRSrecursion count"recursion count"ack present"ack present"gre_flag_values[|gre]"[|gre]"0xfffe0x0700/* if verbose go multiline *//* put in a colon as protocol demarc *//* ASN *//* IP *//* source route entry types *//* protocol version *//* acknowledgment# present *//* recursion count *//* source routing *//* sequence# present *//* key present *//* routing present *//* checksum present *//*
 * netdissect printer for GRE - Generic Routing Encapsulation
 * RFC1701 (GRE), RFC1702 (GRE IPv4), and RFC2637 (Enhanced GRE)
 *//* \summary: Generic Routing Encapsulation (GRE) printer *//*
 * Copyright (c) 2002 Jason L. Wright (jason@thought.net)
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *	This product includes software developed by Jason L. Wright
 * 4. The name of the author may not be used to endorse or promote products
 *    derived from this software without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
 * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
 * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT,
 * INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
 * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
 * SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
 * STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN
 * ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
 * POSSIBILITY OF SUCH DAMAGE.
 *//*	$OpenBSD: print-gre.c,v 1.6 2002/10/30 03:04:04 fgsch Exp $	*//Users/owura/Repos/codeql_eval/proj_repos/the-tcpdump-group-tcpdump-commit-9ba91381954ad325ea4fd26b9c65a8bd9a2a85b6/tcpdump/print-hncp.chncp_print_recin_linefirst_one 1last_type_mask 0xffffffffUlast_type_countvaluetype_mask(ndo, "\t")tlv + 2*value(ndo,"%s", tok2str(type_values, "Easter Egg (42)", type_mask) )(ndo,": type=%u", type )(ndo," (%u)", bodylen + 4 )(ndo, " %s", istr)(ndo, " NID: %s", node_identifier)value + 4(ndo, " NID: %s EPID: %08x", node_identifier, endpoint_identifier )(ndo, " hash: %016" PRIx64, hash)(ndo, " hash: %016" "ll" "x", hash)value + 8value + 12(ndo, " NID: %s seqno: %u %s hash: %016" PRIx64, node_identifier, sequence_number, interval, hash )(ndo, " NID: %s seqno: %u %s hash: %016" "ll" "x", node_identifier, sequence_number, interval, hash )(ndo, " Peer-NID: %s Peer-EPID: %08x Local-EPID: %08x", peer_node_identifier, peer_endpoint_identifier, endpoint_identifier )(ndo, " EPID: %08x Interval: %s", endpoint_identifier, interval )(ndo, " Verdict: %u Fingerprint: %s Common Name: ", *value, format_256(value + 4))value + 2(ndo, " M: %u P: %u H: %u L: %u User-agent: ", M, P, H, L )(ndo, " VLSO: %s PLSO: %s Prefix: ", format_interval(EXTRACT_32BITS(value)), format_interval(EXTRACT_32BITS(value + 4)) )(ndo, " VLSO: %s PLSO: %s Prefix: ", format_interval(((uint32_t)(((uint32_t)(*((const uint8_t *)(value) + 0)) << 24) | ((uint32_t)(*((const uint8_t *)(value) + 1)) << 16) | ((uint32_t)(*((const uint8_t *)(value) + 2)) << 8) | ((uint32_t)(*((const uint8_t *)(value) + 3)) << 0)))), format_interval(((uint32_t)(((uint32_t)(*((const uint8_t *)(value + 4) + 0)) << 24) | ((uint32_t)(*((const uint8_t *)(value + 4) + 1)) << 16) | ((uint32_t)(*((const uint8_t *)(value + 4) + 2)) << 8) | ((uint32_t)(*((const uint8_t *)(value + 4) + 3)) << 0)))) )(ndo, "(length is invalid)")(ndo, " type: ")(ndo, "Internet connectivity")(ndo, "Dest-Prefix: ")(ndo, "DNS domain: ")(ndo, "Opaque UTF-8: ")(ndo, "Restrictive assignment")(ndo, "Unknown (%u)", policy)(ndo, " EPID: %08x Prty: %u", EXTRACT_32BITS(value), prty )(ndo, " EPID: %08x Prty: %u", ((uint32_t)(((uint32_t)(*((const uint8_t *)(value) + 0)) << 24) | ((uint32_t)(*((const uint8_t *)(value) + 1)) << 16) | ((uint32_t)(*((const uint8_t *)(value) + 2)) << 8) | ((uint32_t)(*((const uint8_t *)(value) + 3)) << 0))), prty )(ndo, " Prefix: ")(ndo, " EPID: %08x IP Address: %s", endpoint_identifier, ip_address )(ndo, " IP-Address: %s %c%c%c ", ip_address, (value[16] & 4) ? 'l' : '-', (value[16] & 2) ? 'b' : '-', (value[16] & 1) ? 's' : '-' )(ndo, " Domain: ")(ndo, " IP-Address: %s Name: ", format_ip6addr(ndo, value) )(ndo, " PSK: %s", format_256(value))	RANGE_DNCP_RESERVED65537RANGE_HNCP_UNASSIGNED65538RANGE_DNCP_PRIVATE_USE65539RANGE_DNCP_FUTURE_USEkeyEaster Egg (42): type=%uDNCP_REQUEST_NETWORK_STATEDNCP_REQUEST_NODE_STATEnode_identifier NID: %sDNCP_NODE_ENDPOINTendpoint_identifier NID: %s EPID: %08xDNCP_NETWORK_STATEhash hash: %016llxDNCP_NODE_STATEsequence_number NID: %s seqno: %u %s hash: %016llxDNCP_PEERpeer_node_identifierpeer_endpoint_identifier Peer-NID: %s Peer-EPID: %08x Local-EPID: %08xDNCP_KEEP_ALIVE_INTERVAL EPID: %08x Interval: %sDNCP_TRUST_VERDICT Verdict: %u Fingerprint: %s Common Name: HNCP_HNCP_VERSIONcapabilitiesMHL M: %u P: %u H: %u L: %u User-agent: HNCP_EXTERNAL_CONNECTIONHNCP_DELEGATED_PREFIX VLSO: %s PLSO: %s Prefix: (length is invalid)HNCP_PREFIX_POLICYpolicy type: Internet connectivityDest-Prefix: DNS domain: Opaque UTF-8: Restrictive assignmentHNCP_DHCPV4_DATAHNCP_DHCPV6_DATAHNCP_ASSIGNED_PREFIXprty EPID: %08x Prty: %u Prefix: HNCP_NODE_ADDRESSip_address EPID: %08x IP Address: %sHNCP_DNS_DELEGATED_ZONE IP-Address: %s %c%c%c HNCP_DOMAIN_NAME Domain: HNCP_NODE_NAME IP-Address: %s Name: '"'HNCP_MANAGED_PSK PSK: %sskip_multiline(ndo, "%s", "[|hncp]")[|hncp]print_type_in_line(ndo, "%s", tok2str(type_values, "Easter Egg", type))(ndo, " (x%d)", count)Easter Egg (x%d)is_in_linedhcpv6_print(ndo, "%s", tok2str(dh6opt_str, "Unknown", type))(ndo," (%u)", optlen + 4 )(ndo, " %s", ip6addr_string(ndo, value + t))(ndo, " %s", getname6(ndo, (const u_char *)(value + t)))value + tdhcpv4_print(ndo, "%s", tok2str(dh4opt_str, "Unknown", type))(ndo," (%u)", optlen + 2 )(ndo, " %s", ipaddr_string(ndo, value + t))(ndo, " %s", getname(ndo, (const u_char *)(value + t)))DH4OPT_DNS_SERVERSDH4OPT_NTP_SERVERSDH4OPT_DOMAIN_SEARCHprint_dns_labellab_length(ndo, "[|DNS]")[|DNS]print_prefixsizeof("xxxx:xxxx:xxxx:xxxx:xxxx:xxxx:xxxx:xxxx::/128")&prefix[1 + IPV4_MAPPED_HEADING_LEN], plenbytes&prefix[1 + 12], plenbytesIPV4_MAPPED_HEADING_LEN1 + IPV4_MAPPED_HEADING_LEN(ndo, "%s", buf)format_ip6addrcp + IPV4_MAPPED_HEADING_LENcp + 12sizeof("0000000.000s")char[4][13]buf[i]sizeof(buf[i])"%u.%03us", n / 1000, n % 1000char(*)[13]%u.%03usformat_256sizeof("0123456789abcdef0123456789abcdef0123456789abcdef0123456789abcdef")char[4][65]"%016" PRIx64 "%016" PRIx64 "%016" PRIx64 "%016" PRIx64, EXTRACT_64BITS(data), EXTRACT_64BITS(data + 8), EXTRACT_64BITS(data + 16), EXTRACT_64BITS(data + 24)"%016" "ll" "x" "%016" "ll" "x" "%016" "ll" "x" "%016" "ll" "x", ((uint64_t)(((uint64_t)(*((const uint8_t *)(data) + 0)) << 56) | ((uint64_t)(*((const uint8_t *)(data) + 1)) << 48) | ((uint64_t)(*((const uint8_t *)(data) + 2)) << 40) | ((uint64_t)(*((const uint8_t *)(data) + 3)) << 32) | ((uint64_t)(*((const uint8_t *)(data) + 4)) << 24) | ((uint64_t)(*((const uint8_t *)(data) + 5)) << 16) | ((uint64_t)(*((const uint8_t *)(data) + 6)) << 8) | ((uint64_t)(*((const uint8_t *)(data) + 7)) << 0))), ((uint64_t)(((uint64_t)(*((const uint8_t *)(data + 8) + 0)) << 56) | ((uint64_t)(*((const uint8_t *)(data + 8) + 1)) << 48) | ((uint64_t)(*((const uint8_t *)(data + 8) + 2)) << 40) | ((uint64_t)(*((const uint8_t *)(data + 8) + 3)) << 32) | ((uint64_t)(*((const uint8_t *)(data + 8) + 4)) << 24) | ((uint64_t)(*((const uint8_t *)(data + 8) + 5)) << 16) | ((uint64_t)(*((const uint8_t *)(data + 8) + 6)) << 8) | ((uint64_t)(*((const uint8_t *)(data + 8) + 7)) << 0))), ((uint64_t)(((uint64_t)(*((const uint8_t *)(data + 16) + 0)) << 56) | ((uint64_t)(*((const uint8_t *)(data + 16) + 1)) << 48) | ((uint64_t)(*((const uint8_t *)(data + 16) + 2)) << 40) | ((uint64_t)(*((const uint8_t *)(data + 16) + 3)) << 32) | ((uint64_t)(*((const uint8_t *)(data + 16) + 4)) << 24) | ((uint64_t)(*((const uint8_t *)(data + 16) + 5)) << 16) | ((uint64_t)(*((const uint8_t *)(data + 16) + 6)) << 8) | ((uint64_t)(*((const uint8_t *)(data + 16) + 7)) << 0))), ((uint64_t)(((uint64_t)(*((const uint8_t *)(data + 24) + 0)) << 56) | ((uint64_t)(*((const uint8_t *)(data + 24) + 1)) << 48) | ((uint64_t)(*((const uint8_t *)(data + 24) + 2)) << 40) | ((uint64_t)(*((const uint8_t *)(data + 24) + 3)) << 32) | ((uint64_t)(*((const uint8_t *)(data + 24) + 4)) << 24) | ((uint64_t)(*((const uint8_t *)(data + 24) + 5)) << 16) | ((uint64_t)(*((const uint8_t *)(data + 24) + 6)) << 8) | ((uint64_t)(*((const uint8_t *)(data + 24) + 7)) << 0)))char(*)[65]%016llx%016llx%016llx%016llxdata + 8data + 16data + 24max_lengthformat_nidsizeof("01:01:01:01")char[4][12]"%02x:%02x:%02x:%02x", data[0], data[1], data[2], data[3]char(*)[12]%02x:%02x:%02x:%02xis_ipv4_mapped_addressconst u_char[12]ipv4_mapped_headinghncp_print(ndo, "hncp (%d)", length)hncp (%d)DNS-search"DNS-search"dh4opt_strRequest network state"Request network state"Request node state"Request node state"Node endpoint"Node endpoint"Network state"Network state"Node state"Node state"Peer"Peer"Keep-alive interval"Keep-alive interval"Trust-Verdict"Trust-Verdict"HNCP-Version"HNCP-Version"External-Connection"External-Connection"Delegated-Prefix"Delegated-Prefix"Prefix-Policy"Prefix-Policy"DHCPv4-Data"DHCPv4-Data"DHCPv6-Data"DHCPv6-Data"Assigned-Prefix"Assigned-Prefix"Node-Address"Node-Address"DNS-Delegated-Zone"DNS-Delegated-Zone"Domain-Name"Domain-Name"Node-Name"Node-Name"Managed-PSK"Managed-PSK"Unassigned"Unassigned"Private use"Private use"Future use"Future use"type_values0x100030x100020x10001/* Reserved for future additions *//*
                     * We've already checked that we've captured the
                     * entire TLV, based on its length, so this will
                     * either be -1, meaning "the prefix length is
                     * greater than the longest possible address of
                     * that type" (i.e., > 32 for IPv4 or > 128 for
                     * IPv6", or -3, meaning "the prefix runs past
                     * the end of the TLV".
                     *//*
                 * We've already checked that we've captured the
                 * entire TLV, based on its length, so this will
                 * either be -1, meaning "the prefix length is
                 * greater than the longest possible address of
                 * that type" (i.e., > 32 for IPv4 or > 128 for
                 * IPv6", or -3, meaning "the prefix runs past
                 * the end of the TLV".
                 *//* Container TLV *//* defined types *//* Determine in-line mode *//* The value of the prefix *//*
 * Is an IPv6 address an IPv4-mapped address?
 *//*
 * For IPv4-mapped IPv6 addresses, length of the prefix that precedes
 * the 4 bytes of IPv4 address at the end of the IPv6 address.
 *//* RFC4075 *//* RFC3646 *//* RFC3397 *//* See type_mask in hncp_print_rec below *//* idem *//* This is correct, see RFC 7788 Errata ID 5113. *//* RFC7788 *//* RFC7787 *//* \summary: Home Networking Control Protocol (HNCP) printer *//*
 * Copyright (c) 2016 Antonin DÃ©cimo, Jean-RaphaÃ«l Gaglione
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. Neither the name of the project nor the names of its contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE PROJECT AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE PROJECT OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 *//Users/owura/Repos/codeql_eval/proj_repos/the-tcpdump-group-tcpdump-commit-9ba91381954ad325ea4fd26b9c65a8bd9a2a85b6/tcpdump/print-hsrp.chsrp_printconst hsrpconst hsrp *hsrp *hp->hsrp_versionsizeof(hp->hsrp_version)(ndo, "HSRPv%d", hp->hsrp_version)HSRPv%dhp->hsrp_op_codesizeof(hp->hsrp_op_code)(ndo, "-")(ndo, "%s ", tok2strary(op_code_str, "unknown (%d)", hp->hsrp_op_code))(ndo, "%s ", tok2strary_internal(op_code_str, sizeof(op_code_str)/sizeof(op_code_str[0]),"unknown (%d)",hp->hsrp_op_code))op_code_str"unknown (%d)"unknown (%d)(ndo, "%d: ", len)%d: hp->hsrp_statesizeof(hp->hsrp_state)(ndo, "state=%s ", tok2str(states, "Unknown (%d)", hp->hsrp_state))state=%s Unknown (%d)hp->hsrp_groupsizeof(hp->hsrp_group)(ndo, "group=%d ", hp->hsrp_group)group=%d hp->hsrp_reservedsizeof(hp->hsrp_reserved)(ndo, "[reserved=%d!] ", hp->hsrp_reserved)[reserved=%d!] hp->hsrp_virtaddrsizeof(hp->hsrp_virtaddr)(ndo, "addr=%s", ipaddr_string(ndo, &hp->hsrp_virtaddr))(ndo, "addr=%s", getname(ndo, (const u_char *)(&hp->hsrp_virtaddr)))addr=%s&hp->hsrp_virtaddr(ndo, " hellotime=")(ndo, " holdtime=")(ndo, " priority=%d", hp->hsrp_priority)(ndo, " auth=\"") hellotime= holdtime= priority=%d auth="HSRP_AUTH_SIZEconst uint8_t[8]sizeof(hp->hsrp_authdata)(ndo, "[|hsrp]")[|hsrp]hsrphsrp_virtaddrhsrp_authdatahsrp_reservedhsrp_grouphsrp_priorityhsrp_holdtimehsrp_hellotimehsrp_statehsrp_op_codehsrp_versioninitial"initial"learn"learn"listen"listen"speak"speak"standby"standby"active"active"statescoup"coup"resign"resign"/* HSRP protocol header. *//*
 * RFC 2281:
 *
 *  0                   1                   2                   3
 *  0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
 * +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
 * |   Version     |   Op Code     |     State     |   Hellotime   |
 * +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
 * |   Holdtime    |   Priority    |     Group     |   Reserved    |
 * +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
 * |                      Authentication  Data                     |
 * +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
 * |                      Authentication  Data                     |
 * +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
 * |                      Virtual IP Address                       |
 * +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
 *//* HSRP states and associated names. *//* HSRP op code types. *//* Cisco Hot Standby Router Protocol (HSRP). *//* \summary: Cisco Hot Standby Router Protocol (HSRP) printer *//*
 * Copyright (C) 2001 Julian Cowley
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. Neither the name of the project nor the names of its contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE PROJECT AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE PROJECT OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 *//Users/owura/Repos/codeql_eval/proj_repos/the-tcpdump-group-tcpdump-commit-9ba91381954ad325ea4fd26b9c65a8bd9a2a85b6/tcpdump/print-http.chttp_printhttp"http"const char *[39]char *[39]RESP_CODE_SECOND_TOKENGET"GET"PUT"PUT"COPY"COPY"HEAD"HEAD"LOCK"LOCK"MOVE"MOVE"POLL"POLL"POST"POST"BCOPY"BCOPY"BMOVE"BMOVE"MKCOL"MKCOL"TRACE"TRACE"LABEL"LABEL"MERGE"MERGE"DELETE"DELETE"SEARCH"SEARCH"UNLOCK"UNLOCK"REPORT"REPORT"UPDATE"UPDATE"NOTIFY"NOTIFY"BDELETE"BDELETE""CONNECT"OPTIONS"OPTIONS"CHECKIN"CHECKIN"PROPFIND"PROPFIND"CHECKOUT"CHECKOUT"CCM_POST"CCM_POST"SUBSCRIBE"SUBSCRIBE"PROPPATCH"PROPPATCH"BPROPFIND"BPROPFIND"BPROPPATCH"BPROPPATCH"UNCHECKOUT"UNCHECKOUT"MKACTIVITY"MKACTIVITY"MKWORKSPACE"MKWORKSPACE"UNSUBSCRIBE"UNSUBSCRIBE"RPC_CONNECT"RPC_CONNECT"VERSION-CONTROL"VERSION-CONTROL"BASELINE-CONTROL"BASELINE-CONTROL"httpcmds/*
 * Includes WebDAV requests.
 *//* \summary: Hypertext Transfer Protocol (HTTP) printer *//Users/owura/Repos/codeql_eval/proj_repos/the-tcpdump-group-tcpdump-commit-9ba91381954ad325ea4fd26b9c65a8bd9a2a85b6/tcpdump/mpls.hMPLS_TTL(x)(((x) & TTL_MASK) >> TTL_SHIFT)MPLS_STACK(x)(((x) & STACK_MASK) >> STACK_SHIFT)MPLS_EXP(x)(((x) & EXP_MASK) >> EXP_SHIFT)MPLS_LABEL(x)(((x) & LABEL_MASK) >> LABEL_SHIFT)TTL_SHIFTTTL_MASK0x000000ffSTACK_SHIFTSTACK_MASK0x00000100EXP_SHIFTEXP_MASK0x00000e00LABEL_SHIFTLABEL_MASK0xfffff000/*
 * Copyright (C) 2001 WIDE Project.  All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. Neither the name of the project nor the names of its contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE PROJECT AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE PROJECT OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 *//Users/owura/Repos/codeql_eval/proj_repos/the-tcpdump-group-tcpdump-commit-9ba91381954ad325ea4fd26b9c65a8bd9a2a85b6/tcpdump/print-icmp.c"mpls.h"icmp_printconst icmpconst icmp *icmp *const icmp_ext_tconst icmp_ext_t *icmp_ext_t *ext_dpfmtoipconst udphdrconst udphdr *udphdr *ouhobj_tptrraw_labelsnapend_saveconst icmp_mpls_ext_object_header_tconst icmp_mpls_ext_object_header_t *icmp_mpls_ext_object_header_t *icmp_mpls_ext_object_headerobj_tlenobj_class_numobj_ctypedp->icmp_codesizeof(dp->icmp_code)dp->icmp_seqdp->icmp_hun.ih_idseq.icd_seqsizeof(dp->icmp_hun.ih_idseq.icd_seq)"echo %s, id %u, seq %u", dp->icmp_type == ICMP_ECHO ? "request" : "reply", EXTRACT_16BITS(&dp->icmp_id), EXTRACT_16BITS(&dp->icmp_seq)"echo %s, id %u, seq %u", dp->icmp_type == 8 ? "request" : "reply", ((uint16_t)(((uint16_t)(*((const uint8_t *)(&dp->icmp_hun.ih_idseq.icd_id) + 0)) << 8) | ((uint16_t)(*((const uint8_t *)(&dp->icmp_hun.ih_idseq.icd_id) + 1)) << 0))), ((uint16_t)(((uint16_t)(*((const uint8_t *)(&dp->icmp_hun.ih_idseq.icd_seq) + 0)) << 8) | ((uint16_t)(*((const uint8_t *)(&dp->icmp_hun.ih_idseq.icd_seq) + 1)) << 0)))&dp->icmp_id&dp->icmp_hun.ih_idseq.icd_id&dp->icmp_seq&dp->icmp_hun.ih_idseq.icd_seqdp->icmp_ip.ip_dstdp->icmp_dun.id_ip.idi_ip.ip_dstsizeof(dp->icmp_dun.id_ip.idi_ip.ip_dst)dp->icmp_ip.ip_pdp->icmp_dun.id_ip.idi_ip.ip_psizeof(dp->icmp_dun.id_ip.idi_ip.ip_p)"%s protocol %d unreachable", ipaddr_string(ndo, &dp->icmp_ip.ip_dst), dp->icmp_ip.ip_p"%s protocol %d unreachable", getname(ndo, (const u_char *)(&dp->icmp_dun.id_ip.idi_ip.ip_dst)), dp->icmp_dun.id_ip.idi_ip.ip_p&dp->icmp_ip.ip_dst&dp->icmp_dun.id_ip.idi_ip.ip_dstouh->uh_dportsizeof(ouh->uh_dport)&ouh->uh_dport"%s tcp port %s unreachable", ipaddr_string(ndo, &oip->ip_dst), tcpport_string(ndo, dport)"%s tcp port %s unreachable", getname(ndo, (const u_char *)(&oip->ip_dst)), tcpport_string(ndo, dport)&oip->ip_dst"%s udp port %s unreachable", ipaddr_string(ndo, &oip->ip_dst), udpport_string(ndo, dport)"%s udp port %s unreachable", getname(ndo, (const u_char *)(&oip->ip_dst)), udpport_string(ndo, dport)"%s protocol %u port %u unreachable", ipaddr_string(ndo, &oip->ip_dst), oip->ip_p, dport"%s protocol %u port %u unreachable", getname(ndo, (const u_char *)(&oip->ip_dst)), oip->ip_p, dport&mp->nexthopmtu"%s unreachable - need to frag (mtu %d)", ipaddr_string(ndo, &dp->icmp_ip.ip_dst), mtu"%s unreachable - need to frag (mtu %d)", getname(ndo, (const u_char *)(&dp->icmp_dun.id_ip.idi_ip.ip_dst)), mtu"%s unreachable - need to frag", ipaddr_string(ndo, &dp->icmp_ip.ip_dst)"%s unreachable - need to frag", getname(ndo, (const u_char *)(&dp->icmp_dun.id_ip.idi_ip.ip_dst))fmt, ipaddr_string(ndo, &dp->icmp_ip.ip_dst)fmt, getname(ndo, (const u_char *)(&dp->icmp_dun.id_ip.idi_ip.ip_dst))fmt, ipaddr_string(ndo, &dp->icmp_ip.ip_dst), ipaddr_string(ndo, &dp->icmp_gwaddr)fmt, getname(ndo, (const u_char *)(&dp->icmp_dun.id_ip.idi_ip.ip_dst)), getname(ndo, (const u_char *)(&dp->icmp_hun.ih_gwaddr))&dp->icmp_gwaddr&dp->icmp_hun.ih_gwaddr"router advertisement"*ihpsizeof(*ihp)" lifetime ", sizeof(buf) - (cp - buf)&ihp->ird_lifetimesizeof(buf) - (cp - buf)"%u", lifetime"%u:%02u", lifetime / 60, lifetime % 60"%u:%02u:%02u", lifetime / 3600, (lifetime % 3600) / 60, lifetime % 60" %d:", num" [size %d]", size*idpsizeof(*idp)" {%s %u}", ipaddr_string(ndo, &idp->ird_addr), EXTRACT_32BITS(&idp->ird_pref)" {%s %u}", getname(ndo, (const u_char *)(&idp->ird_addr)), ((uint32_t)(((uint32_t)(*((const uint8_t *)(&idp->ird_pref) + 0)) << 24) | ((uint32_t)(*((const uint8_t *)(&idp->ird_pref) + 1)) << 16) | ((uint32_t)(*((const uint8_t *)(&idp->ird_pref) + 2)) << 8) | ((uint32_t)(*((const uint8_t *)(&idp->ird_pref) + 3)) << 0)))&idp->ird_addr&idp->ird_pref"time exceeded-#%u", dp->icmp_code"parameter problem - code %u", dp->icmp_codedp->icmp_pptrdp->icmp_hun.ih_pptrsizeof(dp->icmp_hun.ih_pptr)"parameter problem - octet %u", dp->icmp_pptr"parameter problem - octet %u", dp->icmp_hun.ih_pptrdp->icmp_maskdp->icmp_dun.id_masksizeof(dp->icmp_dun.id_mask)"address mask is 0x%08x", EXTRACT_32BITS(&dp->icmp_mask)"address mask is 0x%08x", ((uint32_t)(((uint32_t)(*((const uint8_t *)(&dp->icmp_dun.id_mask) + 0)) << 24) | ((uint32_t)(*((const uint8_t *)(&dp->icmp_dun.id_mask) + 1)) << 16) | ((uint32_t)(*((const uint8_t *)(&dp->icmp_dun.id_mask) + 2)) << 8) | ((uint32_t)(*((const uint8_t *)(&dp->icmp_dun.id_mask) + 3)) << 0)))&dp->icmp_mask&dp->icmp_dun.id_mask"time stamp query id %u seq %u", EXTRACT_16BITS(&dp->icmp_id), EXTRACT_16BITS(&dp->icmp_seq)"time stamp query id %u seq %u", ((uint16_t)(((uint16_t)(*((const uint8_t *)(&dp->icmp_hun.ih_idseq.icd_id) + 0)) << 8) | ((uint16_t)(*((const uint8_t *)(&dp->icmp_hun.ih_idseq.icd_id) + 1)) << 0))), ((uint16_t)(((uint16_t)(*((const uint8_t *)(&dp->icmp_hun.ih_idseq.icd_seq) + 0)) << 8) | ((uint16_t)(*((const uint8_t *)(&dp->icmp_hun.ih_idseq.icd_seq) + 1)) << 0)))dp->icmp_ttimedp->icmp_dun.id_ts.its_ttimesizeof(dp->icmp_dun.id_ts.its_ttime)"time stamp reply id %u seq %u: org %s", EXTRACT_16BITS(&dp->icmp_id), EXTRACT_16BITS(&dp->icmp_seq), icmp_tstamp_print(EXTRACT_32BITS(&dp->icmp_otime))"time stamp reply id %u seq %u: org %s", ((uint16_t)(((uint16_t)(*((const uint8_t *)(&dp->icmp_hun.ih_idseq.icd_id) + 0)) << 8) | ((uint16_t)(*((const uint8_t *)(&dp->icmp_hun.ih_idseq.icd_id) + 1)) << 0))), ((uint16_t)(((uint16_t)(*((const uint8_t *)(&dp->icmp_hun.ih_idseq.icd_seq) + 0)) << 8) | ((uint16_t)(*((const uint8_t *)(&dp->icmp_hun.ih_idseq.icd_seq) + 1)) << 0))), icmp_tstamp_print(((uint32_t)(((uint32_t)(*((const uint8_t *)(&dp->icmp_dun.id_ts.its_otime) + 0)) << 24) | ((uint32_t)(*((const uint8_t *)(&dp->icmp_dun.id_ts.its_otime) + 1)) << 16) | ((uint32_t)(*((const uint8_t *)(&dp->icmp_dun.id_ts.its_otime) + 2)) << 8) | ((uint32_t)(*((const uint8_t *)(&dp->icmp_dun.id_ts.its_otime) + 3)) << 0))))&dp->icmp_otime&dp->icmp_dun.id_ts.its_otimebuf+strlen(buf)sizeof(buf)-strlen(buf)", recv %s", icmp_tstamp_print(EXTRACT_32BITS(&dp->icmp_rtime))", recv %s", icmp_tstamp_print(((uint32_t)(((uint32_t)(*((const uint8_t *)(&dp->icmp_dun.id_ts.its_rtime) + 0)) << 24) | ((uint32_t)(*((const uint8_t *)(&dp->icmp_dun.id_ts.its_rtime) + 1)) << 16) | ((uint32_t)(*((const uint8_t *)(&dp->icmp_dun.id_ts.its_rtime) + 2)) << 8) | ((uint32_t)(*((const uint8_t *)(&dp->icmp_dun.id_ts.its_rtime) + 3)) << 0))))&dp->icmp_rtime&dp->icmp_dun.id_ts.its_rtime", xmit %s", icmp_tstamp_print(EXTRACT_32BITS(&dp->icmp_ttime))", xmit %s", icmp_tstamp_print(((uint32_t)(((uint32_t)(*((const uint8_t *)(&dp->icmp_dun.id_ts.its_ttime) + 0)) << 24) | ((uint32_t)(*((const uint8_t *)(&dp->icmp_dun.id_ts.its_ttime) + 1)) << 16) | ((uint32_t)(*((const uint8_t *)(&dp->icmp_dun.id_ts.its_ttime) + 2)) << 8) | ((uint32_t)(*((const uint8_t *)(&dp->icmp_dun.id_ts.its_ttime) + 3)) << 0))))&dp->icmp_ttime&dp->icmp_dun.id_ts.its_ttimeICMP_ECHOICMP_ECHOREPLYecho %s, id %u, seq %uICMP_UNREACHICMP_UNREACH_PROTOCOL%s protocol %d unreachableICMP_UNREACH_PORT%s tcp port %s unreachablefragmented%s udp port %s unreachable%s protocol %u port %u unreachableICMP_UNREACH_NEEDFRAGconst mtu_discoveryconst mtu_discovery *mtu_discovery *mp%s unreachable - need to frag (mtu %d)%s unreachable - need to frag#%d %%s unreachable"#%d %%s unreachable"ICMP_REDIRECTredirect-#%d %%s to net %%s"redirect-#%d %%s to net %%s"ICMP_ROUTERADVERTconst ih_rdiscoveryconst ih_rdiscovery *ih_rdiscovery *ihpconst id_rdiscoveryconst id_rdiscovery *id_rdiscovery *idprouter advertisement__builtin___strncpy_chk lifetime 360060 * 60%u:%02u%u:%02u:%02u %d: [size %d]const uint8_t[1]const uint8_t(*)[1] {%s %u}ICMP_TIMXCEEDICMP_TIMXCEED_INTRANStime exceeded in-transit"time exceeded in-transit"ICMP_TIMXCEED_REASSip reassembly time exceeded"ip reassembly time exceeded"time exceeded-#%uICMP_PARAMPROBparameter problem - code %uparameter problem - octet %uICMP_MASKREPLYaddress mask is 0x%08xICMP_TSTAMPtime stamp query id %u seq %uICMP_TSTAMPREPLYtime stamp reply id %u seq %u: org %s, recv %s, xmit %stype-#%d"type-#%d"(ndo, "ICMP %s, length %u", str, plen)ICMP %s, length %u&dp->icmp_cksum*(&dp->icmp_cksum)(ndo, " (wrong icmp cksum %x (->%x)!)", icmp_sum, in_cksum_shouldbe(icmp_sum, sum))icmp_sum (wrong icmp cksum %x (->%x)!)dp->icmp_type&ip->ip_len*(&ip->ip_len)*ext_dpsizeof(*ext_dp)ext_dp->icmp_ext_version_resplen - ICMP_EXTD_MINLENplen - (156 - sizeof (struct ip))(ndo, "\n\tMPLS extension v%u", ICMP_MPLS_EXT_EXTRACT_VERSION(*(ext_dp->icmp_ext_version_res)))(ndo, "\n\tMPLS extension v%u", (((*(ext_dp->icmp_ext_version_res))&0xf0)>>4))*(ext_dp->icmp_ext_version_res)(ndo, " packet not supported")(ndo, ", checksum 0x%04x (%scorrect), length %u", EXTRACT_16BITS(ext_dp->icmp_ext_checksum), in_cksum(vec, 1) ? "in" : "", hlen)(ndo, ", checksum 0x%04x (%scorrect), length %u", ((uint16_t)(((uint16_t)(*((const uint8_t *)(ext_dp->icmp_ext_checksum) + 0)) << 8) | ((uint16_t)(*((const uint8_t *)(ext_dp->icmp_ext_checksum) + 1)) << 0))), in_cksum(vec, 1) ? "in" : "", hlen)ext_dp->icmp_ext_checksum*icmp_mpls_ext_object_headersizeof(*icmp_mpls_ext_object_header)icmp_mpls_ext_object_header->length(ndo, "\n\t  %s Object (%u), Class-Type: %u, length %u", tok2str(icmp_mpls_ext_obj_values,"unknown",obj_class_num), obj_class_num, obj_ctype, obj_tlen)*obj_tptr(ndo, "\n\t    label %u, exp %u", MPLS_LABEL(raw_label), MPLS_EXP(raw_label))(ndo, "\n\t    label %u, exp %u", (((raw_label) & 0xfffff000) >> 12), (((raw_label) & 0x00000e00) >> 9))(ndo, ", [S]")(ndo, ", ttl %u", MPLS_TTL(raw_label))(ndo, ", ttl %u", (((raw_label) & 0x000000ff) >> 0))ICMP_EXTD_MINLEN
	MPLS extension v%uICMP_MPLS_EXT_VERSION packet not supported, checksum 0x%04x (%scorrect), length %usizeof(struct icmp_mpls_ext_object_header_t)
	  %s Object (%u), Class-Type: %u, length %u
	    label %u, exp %u42949632003584, [S], ttl %u(ndo, "[|icmp]")[|icmp]icmp_tstamp_printmsec"%02u:%02u:%02u.%03u",hrs,min,sec,msec%02u:%02u:%02u.%03uicmp_mpls_ext_object_header_ticmp_ext_tid_rdiscoveryih_rdiscoverymtu_discoveryid_ipid_tsih_idseqctypeclass_numicmp_ext_dataicmp_ext_checksumicmp_ext_version_resicmp_ext_legacy_headericmp_reserved2icmp_lengthicmp_reservedicmp_checksumicmp_codeicmp_typeird_prefird_addrird_lifetimeird_addrsizird_addrnumnexthopmtuicmp_dunicmp_hunicmp_cksumid_dataid_maskidi_ipits_ttimeits_rtimeits_otimeih_voidih_gwaddrih_pptricd_seqicd_idMPLS Stack Entry"MPLS Stack Entry"Extended Payload"Extended Payload"icmp_mpls_ext_obj_valuesICMP_REDIRECT_NETredirect %s to net %s"redirect %s to net %s"ICMP_REDIRECT_HOSTredirect %s to host %s"redirect %s to host %s"ICMP_REDIRECT_TOSNETredirect-tos %s to net %s"redirect-tos %s to net %s"ICMP_REDIRECT_TOSHOSTredirect-tos %s to host %s"redirect-tos %s to host %s"ICMP_UNREACH_NETnet %s unreachable"net %s unreachable"ICMP_UNREACH_HOSThost %s unreachable"host %s unreachable"ICMP_UNREACH_SRCFAIL%s unreachable - source route failed"%s unreachable - source route failed"ICMP_UNREACH_NET_UNKNOWNnet %s unreachable - unknown"net %s unreachable - unknown"ICMP_UNREACH_HOST_UNKNOWNhost %s unreachable - unknown"host %s unreachable - unknown"ICMP_UNREACH_ISOLATED%s unreachable - source host isolated"%s unreachable - source host isolated"ICMP_UNREACH_NET_PROHIBnet %s unreachable - admin prohibited"net %s unreachable - admin prohibited"ICMP_UNREACH_HOST_PROHIBhost %s unreachable - admin prohibited"host %s unreachable - admin prohibited"ICMP_UNREACH_TOSNETnet %s unreachable - tos prohibited"net %s unreachable - tos prohibited"ICMP_UNREACH_TOSHOSThost %s unreachable - tos prohibited"host %s unreachable - tos prohibited"ICMP_UNREACH_FILTER_PROHIBhost %s unreachable - admin prohibited filter"host %s unreachable - admin prohibited filter"ICMP_UNREACH_HOST_PRECEDENCEhost %s unreachable - host precedence violation"host %s unreachable - host precedence violation"ICMP_UNREACH_PRECEDENCE_CUTOFFhost %s unreachable - precedence cutoff"host %s unreachable - precedence cutoff"unreach2strecho reply"echo reply"ICMP_SOURCEQUENCHsource quench"source quench"echo request"echo request"ICMP_ROUTERSOLICITrouter solicitation"router solicitation"time stamp request"time stamp request"time stamp reply"time stamp reply"ICMP_IREQinformation request"information request"ICMP_IREQREPLYinformation reply"information reply"ICMP_MASKREQaddress mask request"address mask request"icmp2strICMP_MPLS_EXT_TYPE(type)((type) == ICMP_UNREACH || (type) == ICMP_TIMXCEED || (type) == ICMP_PARAMPROB)ICMP_ERRTYPE(type)((type) == ICMP_UNREACH || (type) == ICMP_SOURCEQUENCH || (type) == ICMP_REDIRECT || (type) == ICMP_TIMXCEED || (type) == ICMP_PARAMPROB)ICMP_MAXTYPEICMP_PARAMPROB_OPTABSENTICMP_ADVLEN(p)(8 + (IP_HL(&(p)->icmp_ip) << 2) + 8)ICMP_ADVLENMIN(8 + sizeof (struct ip) + 8)ICMP_MASKLENICMP_TSLEN(8 + 3 * sizeof (uint32_t))(156 - sizeof (struct ip))ICMP_MINLENICMP_MPLS_EXT_EXTRACT_VERSION(x)(((x)&0xf0)>>4)icmp_dataicmp_dun.id_dataicmp_maskicmp_dun.id_maskicmp_ipicmp_dun.id_ip.idi_ipicmp_ttimeicmp_dun.id_ts.its_ttimeicmp_rtimeicmp_dun.id_ts.its_rtimeicmp_otimeicmp_dun.id_ts.its_otimeicmp_voidicmp_hun.ih_voidicmp_seqicmp_hun.ih_idseq.icd_seqicmp_idicmp_hun.ih_idseq.icd_idicmp_gwaddricmp_hun.ih_gwaddricmp_pptricmp_hun.ih_pptr/*
                *  FIXME those are the defined objects that lack a decoder
                *  you are welcome to contribute code ;-)
                *//* infinite loop protection *//* length field includes tlv header *//* subtract common header size *//*
             * Sanity checking of the header.
             *//*
             * Check first if the mpls extension header shows a non-zero length.
             * If the length field is not set then silently verify the checksum
             * to check if an extension header is present. This is expedient,
             * however not all implementations set the length field proper.
             *//*
         * Attempt to decode the MPLS extensions only for some ICMP types.
         *//*
         * print the remnants of the IP packet.
         * save the snaplength as this may get overidden in the IP printer.
         *//* don't attempt checksumming if this is a frag *//* print the milliseconds since midnight UTC *//* prototypes *//* extension header starts 128 bytes after ICMP header *//*
 * draft-bonica-internet-icmp-08
 *
 * The Destination Unreachable, Time Exceeded
 * and Parameter Problem messages are slighly changed as per
 * the above draft. A new Length field gets added to give
 * the caller an idea about the length of the piggypacked
 * IP packet before the MPLS extension header starts.
 *
 * The Length field represents length of the padded "original datagram"
 * field  measured in 32-bit words.
 *
 * 0                   1                   2                   3
 * 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
 * +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
 * |     Type      |     Code      |          Checksum             |
 * +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
 * |     unused    |    Length     |          unused               |
 * +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
 * |      Internet Header + leading octets of original datagram    |
 * |                                                               |
 * |                           //                                  |
 * |                                                               |
 * +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
 *//* rfc1256 *//* rfc1191 *//* Formats for the ICMP_REDIRECT codes *//* Formats for most of the ICMP_UNREACH codes *//* Most of the icmp types *//* precedence cutoff *//* host precedence violation *//* admin prohibited filter *//* rfc1716 *//* tos prohibited host *//* tos prohibited net *//* admin prohibited host *//* admin prohibited net *//* source host isolated *//* destination host unknown *//* destination net unknown *//* rfc1700 *//* address mask reply *//* address mask request *//* information reply *//* information request *//* timestamp reply *//* timestamp request *//* req. opt. absent *//* ip header bad *//* ttl==0 in reass *//* ttl==0 in transit *//* time exceeded, code: *//* router solicitation *//* router advertisement *//* echo service *//* for tos and host *//* for tos and net *//* for host *//* for network *//* shorter route, codes: *//* packet lost, slow down *//* bad tos for host *//* bad tos for net *//* ditto *//* prohibited access *//* src host isolated *//* unknown host *//* unknown net *//* src route failed *//* IP_DF caused drop *//* bad port *//* bad protocol *//* bad host *//* bad net *//* dest unreachable, codes: *//* echo reply *//*
 * Definition of type and code field values.
 *//* N.B.: must separately check that ip_hl >= 5 *//* min *//* address mask *//* timestamp *//* draft-bonica-internet-icmp-08 *//* abs minimum *//*
 * Lower bounds on packet lengths for various types.
 * For the error advice packets must first insure that the
 * packet is large enought to contain the returned ip header.
 * Only then can we do the check to see if 64 bits of packet
 * data have been returned, since we need to check the returned
 * ip header length.
 *//* options and then 64 bits of data *//* ICMP_REDIRECT *//* ICMP_PARAMPROB *//* ones complement cksum of struct *//* type sub code *//* type of message, see below *//*
 * Structure of an icmp header.
 *//*
 * Interface Control Message Protocol Definitions.
 * Per RFC 792, September 1981.
 *//* \summary: Internet Control Message Protocol (ICMP) printer *//*
 * Copyright (c) 1988, 1989, 1990, 1991, 1993, 1994, 1995, 1996
 *	The Regents of the University of California.  All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that: (1) source code distributions
 * retain the above copyright notice and this paragraph in its entirety, (2)
 * distributions including binary code include the above copyright notice and
 * this paragraph in its entirety in the documentation or other materials
 * provided with the distribution, and (3) all advertising materials mentioning
 * features or use of this software display the following acknowledgement:
 * ``This product includes software developed by the University of California,
 * Lawrence Berkeley Laboratory and its contributors.'' Neither the name of
 * the University nor the names of its contributors may be used to endorse
 * or promote products derived from this software without specific prior
 * written permission.
 * THIS SOFTWARE IS PROVIDED ``AS IS'' AND WITHOUT ANY EXPRESS OR IMPLIED
 * WARRANTIES, INCLUDING, WITHOUT LIMITATION, THE IMPLIED WARRANTIES OF
 * MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE.
 */tstamp/Users/owura/Repos/codeql_eval/proj_repos/the-tcpdump-group-tcpdump-commit-9ba91381954ad325ea4fd26b9c65a8bd9a2a85b6/tcpdump/rpl.hnd_rpl_daoackrpl_dao_targetnd_rpl_daorpl_dio_destprefixrpl_dio_genoptionRPL_SUBOPTRPL_OPT_PAD0RPL_OPT_PADNRPL_DIO_METRICSRPL_DIO_ROUTINGINFORPL_DIO_CONFIGRPL_DAO_RPLTARGETRPL_DAO_TRANSITINFORPL_DIO_DESTPREFIXRPL_DAO_RPLTARGET_DESCRPL_DIO_MOPRPL_DIO_NONSTORINGRPL_DIO_STORINGRPL_DIO_NONSTORING_MULTICASTRPL_DIO_STORING_MULTICASTnd_rpl_diond_rpl_dis_isnd_rpl_securityND_RPL_DIO_FLAGSND_RPL_DIO_GROUNDEDND_RPL_DIO_DATRIGND_RPL_DIO_DASUPPORTND_RPL_DIO_RES4ND_RPL_DIO_RES3ND_RPL_DIO_PRF_MASKND_RPL_CODEND_RPL_DAG_ISND_RPL_DAG_IOND_RPL_DAOND_RPL_DAO_ACKND_RPL_SEC_DAG_ISND_RPL_SEC_DAG_IOND_RPL_SEC_DAGND_RPL_SEC_DAG_ACKND_RPL_SEC_CONSIST0x8ADAGID_LENrpl_dagidrpl_statusrpl_daoseqrpl_flagsrpl_instanceidrpl_dao_prefixlenrpl_dao_flagsrpl_dao_lenrpl_dao_typerpl_resvrpl_dio_prefixlifetimerpl_dio_prfrpl_dio_prefixlenrpl_dio_lenrpl_dio_typerpl_resv1rpl_dtsnrpl_mopprfrpl_dagrankrpl_versionrpl_dis_reservedrpl_dis_flagsrpl_sec_counterrpl_sec_kim_lvl_flagsrpl_sec_algorpl_sec_t_reserved_RPL_H_RPL_DAOACK_D(X)(((X)&RPL_DAOACK_D_MASK) >> RPL_DAOACK_D_SHIFT)RPL_DAOACK_D_MASK(1 << RPL_DAOACK_D_SHIFT)RPL_DAOACK_D_SHIFTND_RPL_DAOACK_MIN_LENRPL_DAO_D(X)(((X)&RPL_DAO_D_MASK) >> RPL_DAO_D_SHIFT)RPL_DAO_D_MASK(1 << RPL_DAO_D_SHIFT)RPL_DAO_D_SHIFTRPL_DAO_K(X)(((X)&RPL_DAO_K_MASK) >> RPL_DAO_K_SHIFT)RPL_DAO_K_MASK(1 << RPL_DAO_K_SHIFT)RPL_DAO_K_SHIFTND_RPL_DAO_MIN_LENRPL_DIO_LIFETIME_DISCONNECTRPL_DIO_LIFETIME_INFINITERPL_DIO_GENOPTION_LENRPL_DIO_PRF(X)(((X)&RPL_DIO_PRF_MASK) >> RPL_DIO_PRF_SHIFT)RPL_DIO_MOP(X)(enum RPL_DIO_MOP)(((X)&RPL_DIO_MOP_MASK) >> RPL_DIO_MOP_SHIFT)RPL_DIO_GROUNDED(X)((X)&RPL_DIO_GROUND_FLAG)RPL_DIO_PRF_MASK(7 << RPL_DIO_PRF_SHIFT)RPL_DIO_PRF_SHIFTRPL_DIO_MOP_MASK(7 << RPL_DIO_MOP_SHIFT)RPL_DIO_MOP_SHIFTRPL_DIO_GROUND_FLAGND_RPL_MESSAGE/*
 * Local Variables:
 * c-basic-offset:4
 * c-style: whitesmith
 * End:
 *//* _RPL_H_ *//* indicates if the DAGID is present *//* length without DAGID *//* present when D set. *//* bit 7=D *//* section 6.5.1, Destination Advertisement Object Acknowledgement (DAO-ACK) *//* variable number of bytes *//* in bits *//* indicates if this DAO is to be acK'ed *//* bit 7=K, 6=D *//* section 6.4.1, DODAG Information Object (DIO) *//* in seconds *//* flags, including Route Preference *//* suboption length, not including type/len *//* no flags defined yet *//* Dest. Advertisement Trigger Sequence Number *//* bit 7=G, 5-3=MOP, 2-0=PRF *//* section 6.3.1, DODAG Information Object (DIO) *//* section 6.2.1, DODAG Information Solication (DIS_IS) *//* depends upon kim *//* bit 10-8, LVL, bit 7-0 flags *//* bit 15/14, KIM *//* bit 7 is T-bit *//* section 6 of draft-ietf-roll-rpl-19 *//* 3-bit preference *//* 0x9B *//*
 * DIO: Updated to RFC6550, as published in 2012: section 6. (page 30)
 *//*
 * NOTE: the contents of this file are an interpretation of RFC6550.
 *       no copyright is asserted on this file, as it transcribes
 *       a public specification.
 *
 *//Users/owura/Repos/codeql_eval/proj_repos/the-tcpdump-group-tcpdump-commit-9ba91381954ad325ea4fd26b9c65a8bd9a2a85b6/tcpdump/print-icmp6.c"rpl.h"icmp6_rrenum_printconst icmp6_router_renumconst icmp6_router_renum *icmp6_router_renum *rr6const rr_pco_matchconst rr_pco_match *rr_pco_match *matchconst rr_pco_useconst rr_pco_use *rr_pco_use *usechar[1025]1025NI_MAXHOSThbufrr6->rr_reservedsizeof(rr6->rr_reserved)(ndo,"router renum: command")(ndo,"router renum: result")(ndo,"router renum: sequence number reset")(ndo,"router renum: code-#%d", rr6->rr_code)(ndo,"router renum: code-#%d", rr6->rr_hdr.icmp6_code)ICMP6_ROUTER_RENUMBERING_COMMANDrouter renum: commandICMP6_ROUTER_RENUMBERING_RESULTrouter renum: resultICMP6_ROUTER_RENUMBERING_SEQNUM_RESETrouter renum: sequence number resetrouter renum: code-#%d(ndo,", seq=%u", EXTRACT_32BITS(&rr6->rr_seqnum))(ndo,", seq=%u", ((uint32_t)(((uint32_t)(*((const uint8_t *)(&rr6->rr_hdr.icmp6_dataun.icmp6_un_data32[0]) + 0)) << 24) | ((uint32_t)(*((const uint8_t *)(&rr6->rr_hdr.icmp6_dataun.icmp6_un_data32[0]) + 1)) << 16) | ((uint32_t)(*((const uint8_t *)(&rr6->rr_hdr.icmp6_dataun.icmp6_un_data32[0]) + 2)) << 8) | ((uint32_t)(*((const uint8_t *)(&rr6->rr_hdr.icmp6_dataun.icmp6_un_data32[0]) + 3)) << 0)))), seq=%uuint32_t[1]unsigned int[1]&rr6->rr_seqnum&rr6->rr_hdr.icmp6_dataun.icmp6_un_data32[0](ndo,"[")(ndo,"%s%s%s%s%s,", F(ICMP6_RR_FLAGS_TEST, "T"), F(ICMP6_RR_FLAGS_REQRESULT, "R"), F(ICMP6_RR_FLAGS_FORCEAPPLY, "A"), F(ICMP6_RR_FLAGS_SPECSITE, "S"), F(ICMP6_RR_FLAGS_PREVDONE, "P"))(ndo,"%s%s%s%s%s,", ((rr6->rr_flags) & (0x80) ? ("T") : ""), ((rr6->rr_flags) & (0x40) ? ("R") : ""), ((rr6->rr_flags) & (0x20) ? ("A") : ""), ((rr6->rr_flags) & (0x10) ? ("S") : ""), ((rr6->rr_flags) & (0x08) ? ("P") : ""))ICMP6_RR_FLAGS_TEST"T"ICMP6_RR_FLAGS_REQRESULT"R"ICMP6_RR_FLAGS_FORCEAPPLYICMP6_RR_FLAGS_SPECSITE"S"ICMP6_RR_FLAGS_PREVDONE"P"(ndo,"seg=%u,", rr6->rr_segnum)(ndo,"maxdelay=%u", EXTRACT_16BITS(&rr6->rr_maxdelay))(ndo,"maxdelay=%u", ((uint16_t)(((uint16_t)(*((const uint8_t *)(&rr6->rr_maxdelay) + 0)) << 8) | ((uint16_t)(*((const uint8_t *)(&rr6->rr_maxdelay) + 1)) << 0))))&rr6->rr_maxdelay(ndo,"rsvd=0x%x", EXTRACT_32BITS(&rr6->rr_reserved))(ndo,"rsvd=0x%x", ((uint32_t)(((uint32_t)(*((const uint8_t *)(&rr6->rr_reserved) + 0)) << 24) | ((uint32_t)(*((const uint8_t *)(&rr6->rr_reserved) + 1)) << 16) | ((uint32_t)(*((const uint8_t *)(&rr6->rr_reserved) + 2)) << 8) | ((uint32_t)(*((const uint8_t *)(&rr6->rr_reserved) + 3)) << 0))))&rr6->rr_reserved(ndo,"]")[%s%s%s%s%s,seg=%u,maxdelay=%ursvd=0x%xmatch->rpm_prefixsizeof(match->rpm_prefix)(ndo,"\n\t")(ndo," ")(ndo,"match(")(ndo,"add")(ndo,"change")(ndo,"setglobal")(ndo,"#%u", match->rpm_code)(ndo,",ord=%u", match->rpm_ordinal)(ndo,",min=%u", match->rpm_minlen)(ndo,",max=%u", match->rpm_maxlen)(ndo,",%s/%u", hbuf, match->rpm_matchlen)(ndo,",?/%u", match->rpm_matchlen)(ndo,")")use->rpu_prefixsizeof(use->rpu_prefix)(ndo,"use(")(ndo,"%s%s,", F(ICMP6_RR_PCOUSE_FLAGS_DECRVLTIME, "V"), F(ICMP6_RR_PCOUSE_FLAGS_DECRPLTIME, "P"))(ndo,"%s%s,", ((use->rpu_flags) & (((uint32_t)(__builtin_constant_p(0x80000000) ? ((__uint32_t)((((__uint32_t)(0x80000000) & 0xff000000U) >> 24) | (((__uint32_t)(0x80000000) & 0x00ff0000U) >> 8) | (((__uint32_t)(0x80000000) & 0x0000ff00U) << 8) | (((__uint32_t)(0x80000000) & 0x000000ffU) << 24))) : _OSSwapInt32(0x80000000)))) ? ("V") : ""), ((use->rpu_flags) & (((uint32_t)(__builtin_constant_p(0x40000000) ? ((__uint32_t)((((__uint32_t)(0x40000000) & 0xff000000U) >> 24) | (((__uint32_t)(0x40000000) & 0x00ff0000U) >> 8) | (((__uint32_t)(0x40000000) & 0x0000ff00U) << 8) | (((__uint32_t)(0x40000000) & 0x000000ffU) << 24))) : _OSSwapInt32(0x40000000)))) ? ("P") : ""))ICMP6_RR_PCOUSE_FLAGS_DECRVLTIME((uint32_t)(__builtin_constant_p(0x80000000) ? ((__uint32_t)((((__uint32_t)(0x80000000) & 0xff000000U) >> 24) | (((__uint32_t)(0x80000000) & 0x00ff0000U) >> 8) | (((__uint32_t)(0x80000000) & 0x0000ff00U) << 8) | (((__uint32_t)(0x80000000) & 0x000000ffU) << 24))) : _OSSwapInt32(0x80000000)))"V"0x80000000ICMP6_RR_PCOUSE_FLAGS_DECRPLTIME((uint32_t)(__builtin_constant_p(0x40000000) ? ((__uint32_t)((((__uint32_t)(0x40000000) & 0xff000000U) >> 24) | (((__uint32_t)(0x40000000) & 0x00ff0000U) >> 8) | (((__uint32_t)(0x40000000) & 0x0000ff00U) << 8) | (((__uint32_t)(0x40000000) & 0x000000ffU) << 24))) : _OSSwapInt32(0x40000000)))(ndo,"mask=0x%x,", use->rpu_ramask)(ndo,"raflags=0x%x,", use->rpu_raflags)(ndo,"vltime=infty,")(ndo,"vltime=%u,", EXTRACT_32BITS(&use->rpu_vltime))(ndo,"vltime=%u,", ((uint32_t)(((uint32_t)(*((const uint8_t *)(&use->rpu_vltime) + 0)) << 24) | ((uint32_t)(*((const uint8_t *)(&use->rpu_vltime) + 1)) << 16) | ((uint32_t)(*((const uint8_t *)(&use->rpu_vltime) + 2)) << 8) | ((uint32_t)(*((const uint8_t *)(&use->rpu_vltime) + 3)) << 0))))&use->rpu_vltime(ndo,"pltime=infty,")(ndo,"pltime=%u,", EXTRACT_32BITS(&use->rpu_pltime))(ndo,"pltime=%u,", ((uint32_t)(((uint32_t)(*((const uint8_t *)(&use->rpu_pltime) + 0)) << 24) | ((uint32_t)(*((const uint8_t *)(&use->rpu_pltime) + 1)) << 16) | ((uint32_t)(*((const uint8_t *)(&use->rpu_pltime) + 2)) << 8) | ((uint32_t)(*((const uint8_t *)(&use->rpu_pltime) + 3)) << 0))))&use->rpu_pltime(ndo,"%s/%u/%u", hbuf, use->rpu_uselen, use->rpu_keeplen)(ndo,"?/%u/%u", use->rpu_uselen, use->rpu_keeplen)match(RPM_PCO_ADDaddRPM_PCO_CHANGEchangeRPM_PCO_SETGLOBALsetglobal#%u,ord=%u,min=%u,max=%usizeof(hbuf),%s/%u,?/%uuse(%s%s,Vmask=0x%x,raflags=0x%x,vltime=infty,vltime=%u,pltime=infty,pltime=%u,%s/%u/%u?/%u/%u(ndo,"[|icmp6]")[|icmp6]icmp6_nodeinfo_printconst icmp6_nodeinfoconst icmp6_nodeinfo *icmp6_nodeinfo *ni6const icmp6_hdrconst icmp6_hdr *icmp6_hdr *needcomma(ndo," who-are-you request")(ndo," node information query")sizeof(*ni6)(ndo," (")&ni6->ni_qtype&ni6->icmp6_ni_hdr.icmp6_dataun.icmp6_un_data16[0](ndo,"noop")(ndo,"supported qtypes")&ni6->ni_flags&ni6->icmp6_ni_hdr.icmp6_dataun.icmp6_un_data16[1](ndo," [%s]", (i & 0x01) ? "C" : "")(ndo,"DNS name")(ndo,"node addresses")(ndo," [%s%s%s%s%s%s]", (i & NI_NODEADDR_FLAG_ANYCAST) ? "a" : "", (i & NI_NODEADDR_FLAG_GLOBAL) ? "G" : "", (i & NI_NODEADDR_FLAG_SITELOCAL) ? "S" : "", (i & NI_NODEADDR_FLAG_LINKLOCAL) ? "L" : "", (i & NI_NODEADDR_FLAG_COMPAT) ? "C" : "", (i & NI_NODEADDR_FLAG_ALL) ? "A" : "")(ndo," [%s%s%s%s%s%s]", (i & ((uint16_t)((__uint16_t)(__builtin_constant_p(0x40) ? ((__uint16_t)((((__uint16_t)(0x40) & 0xff00U) >> 8) | (((__uint16_t)(0x40) & 0x00ffU) << 8))) : _OSSwapInt16(0x40))))) ? "a" : "", (i & ((uint16_t)((__uint16_t)(__builtin_constant_p(0x20) ? ((__uint16_t)((((__uint16_t)(0x20) & 0xff00U) >> 8) | (((__uint16_t)(0x20) & 0x00ffU) << 8))) : _OSSwapInt16(0x20))))) ? "G" : "", (i & ((uint16_t)((__uint16_t)(__builtin_constant_p(0x10) ? ((__uint16_t)((((__uint16_t)(0x10) & 0xff00U) >> 8) | (((__uint16_t)(0x10) & 0x00ffU) << 8))) : _OSSwapInt16(0x10))))) ? "S" : "", (i & ((uint16_t)((__uint16_t)(__builtin_constant_p(0x8) ? ((__uint16_t)((((__uint16_t)(0x8) & 0xff00U) >> 8) | (((__uint16_t)(0x8) & 0x00ffU) << 8))) : _OSSwapInt16(0x8))))) ? "L" : "", (i & ((uint16_t)((__uint16_t)(__builtin_constant_p(0x4) ? ((__uint16_t)((((__uint16_t)(0x4) & 0xff00U) >> 8) | (((__uint16_t)(0x4) & 0x00ffU) << 8))) : _OSSwapInt16(0x4))))) ? "C" : "", (i & ((uint16_t)((__uint16_t)(__builtin_constant_p(0x2) ? ((__uint16_t)((((__uint16_t)(0x2) & 0xff00U) >> 8) | (((__uint16_t)(0x2) & 0x00ffU) << 8))) : _OSSwapInt16(0x2))))) ? "A" : "")(ndo,"unknown")(ndo,", invalid len")(ndo,", 03 draft")sizeof(*ni6) + sizeof(struct in6_addr)(ndo,", invalid subject len")(ndo,", subject=%s", ip6addr_string(ndo, ni6 + 1))(ndo,", subject=%s", getname6(ndo, (const u_char *)(ni6 + 1)))ni6 + 1(ndo,", subject=DNS name")(ndo,", \"")(ndo,"\"")sizeof(*ni6) + sizeof(struct in_addr)(ndo,", subject=%s", ipaddr_string(ndo, ni6 + 1))(ndo,", subject=%s", getname(ndo, (const u_char *)(ni6 + 1)))(ndo,", unknown subject")(ndo,"[|icmp6: node information reply]")(ndo," node information reply")(ndo,"success")(ndo,"refused")(ndo,", invalid length")(ndo,", ")sizeof(cp[0])(ndo," [TTL=%u]", EXTRACT_32BITS(ni6 + 1))(ndo," [TTL=%u]", ((uint32_t)(((uint32_t)(*((const uint8_t *)(ni6 + 1) + 0)) << 24) | ((uint32_t)(*((const uint8_t *)(ni6 + 1) + 1)) << 16) | ((uint32_t)(*((const uint8_t *)(ni6 + 1) + 2)) << 8) | ((uint32_t)(*((const uint8_t *)(ni6 + 1) + 3)) << 0))))(ndo," %s", ip6addr_string(ndo, bp + i))(ndo," %s", getname6(ndo, (const u_char *)(bp + i)))bp + i(ndo,"(%d)", (int32_t)EXTRACT_32BITS(bp + i))(ndo,"(%d)", (int32_t)((uint32_t)(((uint32_t)(*((const uint8_t *)(bp + i) + 0)) << 24) | ((uint32_t)(*((const uint8_t *)(bp + i) + 1)) << 16) | ((uint32_t)(*((const uint8_t *)(bp + i) + 2)) << 8) | ((uint32_t)(*((const uint8_t *)(bp + i) + 3)) << 0))))(ndo," [%s%s%s%s%s%s%s]", (i & NI_NODEADDR_FLAG_ANYCAST) ? "a" : "", (i & NI_NODEADDR_FLAG_GLOBAL) ? "G" : "", (i & NI_NODEADDR_FLAG_SITELOCAL) ? "S" : "", (i & NI_NODEADDR_FLAG_LINKLOCAL) ? "L" : "", (i & NI_NODEADDR_FLAG_COMPAT) ? "C" : "", (i & NI_NODEADDR_FLAG_ALL) ? "A" : "", (i & NI_NODEADDR_FLAG_TRUNCATE) ? "T" : "")(ndo," [%s%s%s%s%s%s%s]", (i & ((uint16_t)((__uint16_t)(__builtin_constant_p(0x40) ? ((__uint16_t)((((__uint16_t)(0x40) & 0xff00U) >> 8) | (((__uint16_t)(0x40) & 0x00ffU) << 8))) : _OSSwapInt16(0x40))))) ? "a" : "", (i & ((uint16_t)((__uint16_t)(__builtin_constant_p(0x20) ? ((__uint16_t)((((__uint16_t)(0x20) & 0xff00U) >> 8) | (((__uint16_t)(0x20) & 0x00ffU) << 8))) : _OSSwapInt16(0x20))))) ? "G" : "", (i & ((uint16_t)((__uint16_t)(__builtin_constant_p(0x10) ? ((__uint16_t)((((__uint16_t)(0x10) & 0xff00U) >> 8) | (((__uint16_t)(0x10) & 0x00ffU) << 8))) : _OSSwapInt16(0x10))))) ? "S" : "", (i & ((uint16_t)((__uint16_t)(__builtin_constant_p(0x8) ? ((__uint16_t)((((__uint16_t)(0x8) & 0xff00U) >> 8) | (((__uint16_t)(0x8) & 0x00ffU) << 8))) : _OSSwapInt16(0x8))))) ? "L" : "", (i & ((uint16_t)((__uint16_t)(__builtin_constant_p(0x4) ? ((__uint16_t)((((__uint16_t)(0x4) & 0xff00U) >> 8) | (((__uint16_t)(0x4) & 0x00ffU) << 8))) : _OSSwapInt16(0x4))))) ? "C" : "", (i & ((uint16_t)((__uint16_t)(__builtin_constant_p(0x2) ? ((__uint16_t)((((__uint16_t)(0x2) & 0xff00U) >> 8) | (((__uint16_t)(0x2) & 0x00ffU) << 8))) : _OSSwapInt16(0x2))))) ? "A" : "", (i & ((uint16_t)((__uint16_t)(__builtin_constant_p(0x1) ? ((__uint16_t)((((__uint16_t)(0x1) & 0xff00U) >> 8) | (((__uint16_t)(0x1) & 0x00ffU) << 8))) : _OSSwapInt16(0x1))))) ? "T" : "")ICMP6_NI_QUERYsizeof(*dp) + 4 who-are-you request node information queryicmp6lenNI_QTYPE_NOOPnoopNI_QTYPE_SUPTYPESsupported qtypes [%s]NI_QTYPE_FQDNDNS nameNI_QTYPE_NODEADDRnode addresses [%s%s%s%s%s%s]G, invalid len, 03 draftICMP6_NI_SUBJ_IPV6, invalid subject len, subject=%sICMP6_NI_SUBJ_FQDN, subject=DNS name, "ICMP6_NI_SUBJ_IPV4, unknown subjectICMP6_NI_REPLY[|icmp6: node information reply] node information replyICMP6_NI_SUCCESSsuccessICMP6_NI_REFUSEDrefused, invalid lengthICMP6_NI_UNKNOWN [TTL=%u] [%s%s%s%s%s%s%s](ndo, "[|icmp6]")dnsname_print(ndo,"???")(ndo,".")???mldv2_query_printicpmrcmrtqqinsrcs(ndo," [invalid len %d]", len) [invalid len %d]icp->icmp6_data16[0]icp->icmp6_dataun.icmp6_un_data16[0]sizeof(icp->icmp6_dataun.icmp6_un_data16[0])&icp->icmp6_data16[0]&icp->icmp6_dataun.icmp6_un_data16[0]0x0fff286720x7000(ndo," [max resp delay=%d]", mrt) [max resp delay=%d]bp[8](ndo," [gaddr %s", ip6addr_string(ndo, &bp[8]))(ndo," [gaddr %s", getname6(ndo, (const u_char *)(&bp[8]))) [gaddr %sbp[25]sizeof(bp[25])(ndo," sflag")(ndo," robustness=%d", bp[24] & 0x07)(ndo," qqi=%d", qqi) sflag robustness=%d qqi=%dbp[26]&bp[26](ndo," [invalid number of sources]")(ndo," {")bp[28 + i * sizeof(struct in6_addr)](ndo," %s", ip6addr_string(ndo, &bp[28 + i * sizeof(struct in6_addr)]))(ndo," %s", getname6(ndo, (const u_char *)(&bp[28 + i * sizeof(struct in6_addr)])))&bp[28 + i * sizeof(struct in6_addr)](ndo," }")(ndo,", %d source(s)", nsrcs) [invalid number of sources] { }, %d source(s)mldv2_report_printgroupngroupsicp->icmp6_data16[1]icp->icmp6_dataun.icmp6_un_data16[1]sizeof(icp->icmp6_dataun.icmp6_un_data16[1])&icp->icmp6_data16[1]&icp->icmp6_dataun.icmp6_un_data16[1](ndo,", %d group record(s)", ngroups), %d group record(s)(ndo," [invalid number of groups]")bp[group + 4](ndo," [gaddr %s", ip6addr_string(ndo, &bp[group + 4]))(ndo," [gaddr %s", getname6(ndo, (const u_char *)(&bp[group + 4])))&bp[group + 4](ndo," %s", tok2str(mldv2report2str, " [v2-report-#%d]", bp[group]))(ndo," [invalid number of sources %d]", nsrcs)bp[group + 20 + j * sizeof(struct in6_addr)](ndo," %s", ip6addr_string(ndo, &bp[group + 20 + j * sizeof(struct in6_addr)]))(ndo," %s", getname6(ndo, (const u_char *)(&bp[group + 20 + j * sizeof(struct in6_addr)])))&bp[group + 20 + j * sizeof(struct in6_addr)] [invalid number of groups] [v2-report-#%d] [invalid number of sources %d]mld6_printconst mld6_hdrconst mld6_hdr *mld6_hdr *sizeof(*mp)(ndo,"max resp delay: %d ", EXTRACT_16BITS(&mp->mld6_maxdelay))(ndo,"max resp delay: %d ", ((uint16_t)(((uint16_t)(*((const uint8_t *)(&mp->mld6_hdr.icmp6_dataun.icmp6_un_data16[0]) + 0)) << 8) | ((uint16_t)(*((const uint8_t *)(&mp->mld6_hdr.icmp6_dataun.icmp6_un_data16[0]) + 1)) << 0))))max resp delay: %d &mp->mld6_maxdelay&mp->mld6_hdr.icmp6_dataun.icmp6_un_data16[0](ndo,"addr: %s", ip6addr_string(ndo, &mp->mld6_addr))(ndo,"addr: %s", getname6(ndo, (const u_char *)(&mp->mld6_addr)))addr: %s&mp->mld6_addricmp6_opt_printconst nd_opt_hdrconst nd_opt_hdr *nd_opt_hdr *const nd_opt_prefix_infoconst nd_opt_prefix_info *nd_opt_prefix_info *oppconst nd_opt_mtuconst nd_opt_mtu *nd_opt_mtu *opmconst nd_opt_rdnssconst nd_opt_rdnss *nd_opt_rdnss *oprdconst nd_opt_dnsslconst nd_opt_dnssl *nd_opt_dnssl *opdsconst nd_opt_advintervalconst nd_opt_advinterval *nd_opt_advinterval *opaconst nd_opt_homeagent_infoconst nd_opt_homeagent_info *nd_opt_homeagent_info *ophconst nd_opt_route_infoconst nd_opt_route_info *nd_opt_route_info *opridompin6in6pop->nd_opt_len(ndo,"\n\t  %s option (%u), length %u (%u): ", tok2str(icmp6_opt_values, "unknown", op->nd_opt_type), op->nd_opt_type, op->nd_opt_len << 3, op->nd_opt_len)opp->nd_opt_pi_prefixsizeof(opp->nd_opt_pi_prefix)(ndo,"%s/%u%s, Flags [%s], valid time %s", ip6addr_string(ndo, &opp->nd_opt_pi_prefix), opp->nd_opt_pi_prefix_len, (op->nd_opt_len != 4) ? "badlen" : "", bittok2str(icmp6_opt_pi_flag_values, "none", opp->nd_opt_pi_flags_reserved), get_lifetime(EXTRACT_32BITS(&opp->nd_opt_pi_valid_time)))(ndo,"%s/%u%s, Flags [%s], valid time %s", getname6(ndo, (const u_char *)(&opp->nd_opt_pi_prefix)), opp->nd_opt_pi_prefix_len, (op->nd_opt_len != 4) ? "badlen" : "", bittok2str(icmp6_opt_pi_flag_values, "none", opp->nd_opt_pi_flags_reserved), get_lifetime(((uint32_t)(((uint32_t)(*((const uint8_t *)(&opp->nd_opt_pi_valid_time) + 0)) << 24) | ((uint32_t)(*((const uint8_t *)(&opp->nd_opt_pi_valid_time) + 1)) << 16) | ((uint32_t)(*((const uint8_t *)(&opp->nd_opt_pi_valid_time) + 2)) << 8) | ((uint32_t)(*((const uint8_t *)(&opp->nd_opt_pi_valid_time) + 3)) << 0)))))&opp->nd_opt_pi_prefix&opp->nd_opt_pi_valid_time(ndo,", pref. time %s", get_lifetime(EXTRACT_32BITS(&opp->nd_opt_pi_preferred_time)))(ndo,", pref. time %s", get_lifetime(((uint32_t)(((uint32_t)(*((const uint8_t *)(&opp->nd_opt_pi_preferred_time) + 0)) << 24) | ((uint32_t)(*((const uint8_t *)(&opp->nd_opt_pi_preferred_time) + 1)) << 16) | ((uint32_t)(*((const uint8_t *)(&opp->nd_opt_pi_preferred_time) + 2)) << 8) | ((uint32_t)(*((const uint8_t *)(&opp->nd_opt_pi_preferred_time) + 3)) << 0)))))&opp->nd_opt_pi_preferred_timeopm->nd_opt_mtu_mtusizeof(opm->nd_opt_mtu_mtu)(ndo," %u%s", EXTRACT_32BITS(&opm->nd_opt_mtu_mtu), (op->nd_opt_len != 1) ? "bad option length" : "" )(ndo," %u%s", ((uint32_t)(((uint32_t)(*((const uint8_t *)(&opm->nd_opt_mtu_mtu) + 0)) << 24) | ((uint32_t)(*((const uint8_t *)(&opm->nd_opt_mtu_mtu) + 1)) << 16) | ((uint32_t)(*((const uint8_t *)(&opm->nd_opt_mtu_mtu) + 2)) << 8) | ((uint32_t)(*((const uint8_t *)(&opm->nd_opt_mtu_mtu) + 3)) << 0))), (op->nd_opt_len != 1) ? "bad option length" : "" )&opm->nd_opt_mtu_mtu(ndo," lifetime %us,", EXTRACT_32BITS(&oprd->nd_opt_rdnss_lifetime))(ndo," lifetime %us,", ((uint32_t)(((uint32_t)(*((const uint8_t *)(&oprd->nd_opt_rdnss_lifetime) + 0)) << 24) | ((uint32_t)(*((const uint8_t *)(&oprd->nd_opt_rdnss_lifetime) + 1)) << 16) | ((uint32_t)(*((const uint8_t *)(&oprd->nd_opt_rdnss_lifetime) + 2)) << 8) | ((uint32_t)(*((const uint8_t *)(&oprd->nd_opt_rdnss_lifetime) + 3)) << 0))))&oprd->nd_opt_rdnss_lifetimeoprd->nd_opt_rdnss_addr[i]sizeof(oprd->nd_opt_rdnss_addr[i])(ndo," addr: %s", ip6addr_string(ndo, &oprd->nd_opt_rdnss_addr[i]))(ndo," addr: %s", getname6(ndo, (const u_char *)(&oprd->nd_opt_rdnss_addr[i])))&oprd->nd_opt_rdnss_addr[i](ndo," lifetime %us, domain(s):", EXTRACT_32BITS(&opds->nd_opt_dnssl_lifetime))(ndo," lifetime %us, domain(s):", ((uint32_t)(((uint32_t)(*((const uint8_t *)(&opds->nd_opt_dnssl_lifetime) + 0)) << 24) | ((uint32_t)(*((const uint8_t *)(&opds->nd_opt_dnssl_lifetime) + 1)) << 16) | ((uint32_t)(*((const uint8_t *)(&opds->nd_opt_dnssl_lifetime) + 2)) << 8) | ((uint32_t)(*((const uint8_t *)(&opds->nd_opt_dnssl_lifetime) + 3)) << 0))))&opds->nd_opt_dnssl_lifetimeopa->nd_opt_adv_intervalsizeof(opa->nd_opt_adv_interval)(ndo," %ums", EXTRACT_32BITS(&opa->nd_opt_adv_interval))(ndo," %ums", ((uint32_t)(((uint32_t)(*((const uint8_t *)(&opa->nd_opt_adv_interval) + 0)) << 24) | ((uint32_t)(*((const uint8_t *)(&opa->nd_opt_adv_interval) + 1)) << 16) | ((uint32_t)(*((const uint8_t *)(&opa->nd_opt_adv_interval) + 2)) << 8) | ((uint32_t)(*((const uint8_t *)(&opa->nd_opt_adv_interval) + 3)) << 0))))&opa->nd_opt_adv_intervaloph->nd_opt_hai_lifetimesizeof(oph->nd_opt_hai_lifetime)(ndo," preference %u, lifetime %u", EXTRACT_16BITS(&oph->nd_opt_hai_preference), EXTRACT_16BITS(&oph->nd_opt_hai_lifetime))(ndo," preference %u, lifetime %u", ((uint16_t)(((uint16_t)(*((const uint8_t *)(&oph->nd_opt_hai_preference) + 0)) << 8) | ((uint16_t)(*((const uint8_t *)(&oph->nd_opt_hai_preference) + 1)) << 0))), ((uint16_t)(((uint16_t)(*((const uint8_t *)(&oph->nd_opt_hai_lifetime) + 0)) << 8) | ((uint16_t)(*((const uint8_t *)(&oph->nd_opt_hai_lifetime) + 1)) << 0))))&oph->nd_opt_hai_preference&oph->nd_opt_hai_lifetimeopri->nd_opt_rti_lifetimesizeof(opri->nd_opt_rti_lifetime)&in60, sizeof(in6)*in6popri + 1, 8sizeof(*in6p)opri + 1, sizeof(in6)(ndo," %s/%u", ip6addr_string(ndo, &in6), opri->nd_opt_rti_prefixlen)(ndo," %s/%u", getname6(ndo, (const u_char *)(&in6)), opri->nd_opt_rti_prefixlen)(ndo,", pref=%s", get_rtpref(opri->nd_opt_rti_flags))(ndo,", lifetime=%s", get_lifetime(EXTRACT_32BITS(&opri->nd_opt_rti_lifetime)))(ndo,", lifetime=%s", get_lifetime(((uint32_t)(((uint32_t)(*((const uint8_t *)(&opri->nd_opt_rti_lifetime) + 0)) << 24) | ((uint32_t)(*((const uint8_t *)(&opri->nd_opt_rti_lifetime) + 1)) << 16) | ((uint32_t)(*((const uint8_t *)(&opri->nd_opt_rti_lifetime) + 2)) << 8) | ((uint32_t)(*((const uint8_t *)(&opri->nd_opt_rti_lifetime) + 3)) << 0)))))&opri->nd_opt_rti_lifetime
	  %s option (%u), length %u (%u): ND_OPT_SOURCE_LINKADDRND_OPT_TARGET_LINKADDRND_OPT_PREFIX_INFORMATION%s/%u%s, Flags [%s], valid time %sbadlen, pref. time %sND_OPT_REDIRECTED_HEADERND_OPT_MTUresid %u%sbad option lengthND_OPT_RDNSS lifetime %us,in6_addr[1] addr: %sND_OPT_DNSSL lifetime %us, domain(s):ND_OPT_ADVINTERVAL %umsND_OPT_HOMEAGENT_INFO preference %u, lifetime %uconst int16_tconst int16_t *short *ND_OPT_ROUTE_INFO %s/%u, pref=%s, lifetime=%s(ndo, "[ndp opt]")[ndp opt]get_upperlayeruhconst ip6_hbhconst ip6_hbh *ip6_hbh *hbhfraghip6->ip6_nxtip6->ip6_ctlun.ip6_un1.ip6_un1_nxtsizeof(ip6->ip6_ctlun.ip6_un1.ip6_un1_nxt)sizeof(struct ip6_hdr)uh->uh_dportsizeof(uh->uh_dport)hbh->ip6h_lensizeof(hbh->ip6h_len)fragh->ip6f_offlgsizeof(fragh->ip6f_offlg)&fragh->ip6f_offlgah->ah_lensizeof(ah->ah_len)icmp6_printdp->icmp6_cksumsizeof(dp->icmp6_cksum)&dp->icmp6_cksum(ndo,"[bad icmp6 cksum 0x%04x -> 0x%04x!] ", udp_sum, in_cksum_shouldbe(udp_sum, sum))(ndo,"[icmp6 sum ok] ")udp_sum[bad icmp6 cksum 0x%04x -> 0x%04x!] [icmp6 sum ok] (ndo,"ICMP6, %s", tok2str(icmp6_type_values,"unknown icmp6 type (%u)",dp->icmp6_type))ICMP6, %sconst tok[30]tok[30]unknown icmp6 type (%u)(ndo,", length %u", length)ND_ROUTER_SOLICITND_ROUTER_ADVERTND_NEIGHBOR_ADVERTND_NEIGHBOR_SOLICITND_REDIRECTICMP6_HADISCOV_REPLYICMP6_MOBILEPREFIX_ADVERToip->ip6_dstsizeof(oip->ip6_dst)(ndo,", %s", tok2str(icmp6_dst_unreach_code_values,"unknown unreach code (%u)",dp->icmp6_code))(ndo," %s",ip6addr_string(ndo, &oip->ip6_dst))(ndo," %s",getname6(ndo, (const u_char *)(&oip->ip6_dst)))&oip->ip6_dst(ndo," %s, source address %s", ip6addr_string(ndo, &oip->ip6_dst), ip6addr_string(ndo, &oip->ip6_src))(ndo," %s, source address %s", getname6(ndo, (const u_char *)(&oip->ip6_dst)), getname6(ndo, (const u_char *)(&oip->ip6_src)))&oip->ip6_src(ndo,", %s tcp port %s", ip6addr_string(ndo, &oip->ip6_dst), tcpport_string(ndo, dport))(ndo,", %s tcp port %s", getname6(ndo, (const u_char *)(&oip->ip6_dst)), tcpport_string(ndo, dport))(ndo,", %s udp port %s", ip6addr_string(ndo, &oip->ip6_dst), udpport_string(ndo, dport))(ndo,", %s udp port %s", getname6(ndo, (const u_char *)(&oip->ip6_dst)), udpport_string(ndo, dport))(ndo,", %s protocol %d port %d unreachable", ip6addr_string(ndo, &oip->ip6_dst), oip->ip6_nxt, dport)(ndo,", %s protocol %d port %d unreachable", getname6(ndo, (const u_char *)(&oip->ip6_dst)), oip->ip6_ctlun.ip6_un1.ip6_un1_nxt, dport)dp->icmp6_mtudp->icmp6_dataun.icmp6_un_data32[0]sizeof(dp->icmp6_dataun.icmp6_un_data32[0])(ndo,", mtu %u", EXTRACT_32BITS(&dp->icmp6_mtu))(ndo,", mtu %u", ((uint32_t)(((uint32_t)(*((const uint8_t *)(&dp->icmp6_dataun.icmp6_un_data32[0]) + 0)) << 24) | ((uint32_t)(*((const uint8_t *)(&dp->icmp6_dataun.icmp6_un_data32[0]) + 1)) << 16) | ((uint32_t)(*((const uint8_t *)(&dp->icmp6_dataun.icmp6_un_data32[0]) + 2)) << 8) | ((uint32_t)(*((const uint8_t *)(&dp->icmp6_dataun.icmp6_un_data32[0]) + 3)) << 0))))&dp->icmp6_mtu&dp->icmp6_dataun.icmp6_un_data32[0](ndo," for %s", ip6addr_string(ndo, &oip->ip6_dst))(ndo," for %s", getname6(ndo, (const u_char *)(&oip->ip6_dst)))(ndo," (reassembly)")(ndo,", unknown code (%u)", dp->icmp6_code)(ndo,", erroneous - octet %u", EXTRACT_32BITS(&dp->icmp6_pptr))(ndo,", erroneous - octet %u", ((uint32_t)(((uint32_t)(*((const uint8_t *)(&dp->icmp6_dataun.icmp6_un_data32[0]) + 0)) << 24) | ((uint32_t)(*((const uint8_t *)(&dp->icmp6_dataun.icmp6_un_data32[0]) + 1)) << 16) | ((uint32_t)(*((const uint8_t *)(&dp->icmp6_dataun.icmp6_un_data32[0]) + 2)) << 8) | ((uint32_t)(*((const uint8_t *)(&dp->icmp6_dataun.icmp6_un_data32[0]) + 3)) << 0))))&dp->icmp6_pptr(ndo,", next header - octet %u", EXTRACT_32BITS(&dp->icmp6_pptr))(ndo,", next header - octet %u", ((uint32_t)(((uint32_t)(*((const uint8_t *)(&dp->icmp6_dataun.icmp6_un_data32[0]) + 0)) << 24) | ((uint32_t)(*((const uint8_t *)(&dp->icmp6_dataun.icmp6_un_data32[0]) + 1)) << 16) | ((uint32_t)(*((const uint8_t *)(&dp->icmp6_dataun.icmp6_un_data32[0]) + 2)) << 8) | ((uint32_t)(*((const uint8_t *)(&dp->icmp6_dataun.icmp6_un_data32[0]) + 3)) << 0))))(ndo,", option - octet %u", EXTRACT_32BITS(&dp->icmp6_pptr))(ndo,", option - octet %u", ((uint32_t)(((uint32_t)(*((const uint8_t *)(&dp->icmp6_dataun.icmp6_un_data32[0]) + 0)) << 24) | ((uint32_t)(*((const uint8_t *)(&dp->icmp6_dataun.icmp6_un_data32[0]) + 1)) << 16) | ((uint32_t)(*((const uint8_t *)(&dp->icmp6_dataun.icmp6_un_data32[0]) + 2)) << 8) | ((uint32_t)(*((const uint8_t *)(&dp->icmp6_dataun.icmp6_un_data32[0]) + 3)) << 0))))(ndo,", code-#%d", dp->icmp6_code)dp->icmp6_seqdp->icmp6_dataun.icmp6_un_data16[1]sizeof(dp->icmp6_dataun.icmp6_un_data16[1])(ndo,", seq %u", EXTRACT_16BITS(&dp->icmp6_seq))(ndo,", seq %u", ((uint16_t)(((uint16_t)(*((const uint8_t *)(&dp->icmp6_dataun.icmp6_un_data16[1]) + 0)) << 8) | ((uint16_t)(*((const uint8_t *)(&dp->icmp6_dataun.icmp6_un_data16[1]) + 1)) << 0))))&dp->icmp6_seq&dp->icmp6_dataun.icmp6_un_data16[1](ndo," v2")(ndo," unknown-version (len %u) ", length)p->nd_ra_retransmitsizeof(p->nd_ra_retransmit)(ndo,"\n\thop limit %u, Flags [%s]" ", pref %s, router lifetime %us, reachable time %ums, retrans timer %ums", (u_int)p->nd_ra_curhoplimit, bittok2str(icmp6_opt_ra_flag_values,"none",(p->nd_ra_flags_reserved)), get_rtpref(p->nd_ra_flags_reserved), EXTRACT_16BITS(&p->nd_ra_router_lifetime), EXTRACT_32BITS(&p->nd_ra_reachable), EXTRACT_32BITS(&p->nd_ra_retransmit))(ndo,"\n\thop limit %u, Flags [%s]" ", pref %s, router lifetime %us, reachable time %ums, retrans timer %ums", (u_int)p->nd_ra_hdr.icmp6_dataun.icmp6_un_data8[0], bittok2str(icmp6_opt_ra_flag_values,"none",(p->nd_ra_hdr.icmp6_dataun.icmp6_un_data8[1])), get_rtpref(p->nd_ra_hdr.icmp6_dataun.icmp6_un_data8[1]), ((uint16_t)(((uint16_t)(*((const uint8_t *)(&p->nd_ra_hdr.icmp6_dataun.icmp6_un_data16[1]) + 0)) << 8) | ((uint16_t)(*((const uint8_t *)(&p->nd_ra_hdr.icmp6_dataun.icmp6_un_data16[1]) + 1)) << 0))), ((uint32_t)(((uint32_t)(*((const uint8_t *)(&p->nd_ra_reachable) + 0)) << 24) | ((uint32_t)(*((const uint8_t *)(&p->nd_ra_reachable) + 1)) << 16) | ((uint32_t)(*((const uint8_t *)(&p->nd_ra_reachable) + 2)) << 8) | ((uint32_t)(*((const uint8_t *)(&p->nd_ra_reachable) + 3)) << 0))), ((uint32_t)(((uint32_t)(*((const uint8_t *)(&p->nd_ra_retransmit) + 0)) << 24) | ((uint32_t)(*((const uint8_t *)(&p->nd_ra_retransmit) + 1)) << 16) | ((uint32_t)(*((const uint8_t *)(&p->nd_ra_retransmit) + 2)) << 8) | ((uint32_t)(*((const uint8_t *)(&p->nd_ra_retransmit) + 3)) << 0))))&p->nd_ra_router_lifetime&p->nd_ra_hdr.icmp6_dataun.icmp6_un_data16[1]&p->nd_ra_reachable&p->nd_ra_retransmitp->nd_ns_targetsizeof(p->nd_ns_target)(ndo,", who has %s", ip6addr_string(ndo, &p->nd_ns_target))(ndo,", who has %s", getname6(ndo, (const u_char *)(&p->nd_ns_target)))&p->nd_ns_targetp->nd_na_targetsizeof(p->nd_na_target)(ndo,", tgt is %s", ip6addr_string(ndo, &p->nd_na_target))(ndo,", tgt is %s", getname6(ndo, (const u_char *)(&p->nd_na_target)))&p->nd_na_target(ndo,", Flags [%s]", bittok2str(icmp6_nd_na_flag_values, "none", EXTRACT_32BITS(&p->nd_na_flags_reserved)))(ndo,", Flags [%s]", bittok2str(icmp6_nd_na_flag_values, "none", ((uint32_t)(((uint32_t)(*((const uint8_t *)(&p->nd_na_hdr.icmp6_dataun.icmp6_un_data32[0]) + 0)) << 24) | ((uint32_t)(*((const uint8_t *)(&p->nd_na_hdr.icmp6_dataun.icmp6_un_data32[0]) + 1)) << 16) | ((uint32_t)(*((const uint8_t *)(&p->nd_na_hdr.icmp6_dataun.icmp6_un_data32[0]) + 2)) << 8) | ((uint32_t)(*((const uint8_t *)(&p->nd_na_hdr.icmp6_dataun.icmp6_un_data32[0]) + 3)) << 0)))))&p->nd_na_flags_reserved&p->nd_na_hdr.icmp6_dataun.icmp6_un_data32[0]RDR(dp)->nd_rd_dst((const struct nd_redirect *)(dp))->nd_rd_dstsizeof(((const struct nd_redirect *)(dp))->nd_rd_dst)(ndo,", %s", ip6addr_string(ndo, &RDR(dp)->nd_rd_dst))(ndo,", %s", getname6(ndo, (const u_char *)(&((const struct nd_redirect *)(dp))->nd_rd_dst)))&RDR(dp)->nd_rd_dst&((const struct nd_redirect *)(dp))->nd_rd_dstRDR(dp)->nd_rd_target((const struct nd_redirect *)(dp))->nd_rd_targetsizeof(((const struct nd_redirect *)(dp))->nd_rd_target)(ndo," to %s", ip6addr_string(ndo, &RDR(dp)->nd_rd_target))(ndo," to %s", getname6(ndo, (const u_char *)(&((const struct nd_redirect *)(dp))->nd_rd_target)))&RDR(dp)->nd_rd_target&((const struct nd_redirect *)(dp))->nd_rd_targetdp->icmp6_data16[0]dp->icmp6_dataun.icmp6_un_data16[0]sizeof(dp->icmp6_dataun.icmp6_un_data16[0])(ndo,", id 0x%04x", EXTRACT_16BITS(&dp->icmp6_data16[0]))(ndo,", id 0x%04x", ((uint16_t)(((uint16_t)(*((const uint8_t *)(&dp->icmp6_dataun.icmp6_un_data16[0]) + 0)) << 8) | ((uint16_t)(*((const uint8_t *)(&dp->icmp6_dataun.icmp6_un_data16[0]) + 1)) << 0))))&dp->icmp6_data16[0]&dp->icmp6_dataun.icmp6_un_data16[0]*in6sizeof(*in6)(ndo,", %s", ip6addr_string(ndo, in6))(ndo,", %s", getname6(ndo, (const u_char *)(in6)))dp->icmp6_data16[1](ndo,"M")(ndo,"O")ICMP6_DST_UNREACHunknown unreach code (%u)ICMP6_DST_UNREACH_NOROUTEICMP6_DST_UNREACH_ADMINICMP6_DST_UNREACH_ADDRICMP6_DST_UNREACH_BEYONDSCOPE %s, source address %sICMP6_DST_UNREACH_NOPORT, %s tcp port %s, %s udp port %s, %s protocol %d port %d unreachableICMP6_PACKET_TOO_BIG, mtu %uICMP6_TIME_EXCEEDEDICMP6_TIME_EXCEED_TRANSIT for %sICMP6_TIME_EXCEED_REASSEMBLY (reassembly), unknown code (%u)ICMP6_PARAM_PROBICMP6_PARAMPROB_HEADER, erroneous - octet %uICMP6_PARAMPROB_NEXTHEADER, next header - octet %uICMP6_PARAMPROB_OPTION, option - octet %u, code-#%dICMP6_ECHO_REQUESTICMP6_ECHO_REPLYICMP6_MEMBERSHIP_QUERYMLD_MINLENMLDV2_MINLEN v2 unknown-version (len %u) ICMP6_MEMBERSHIP_REPORTICMP6_MEMBERSHIP_REDUCTIONRTSOLLENconst nd_router_advertconst nd_router_advert *nd_router_advert *
	hop limit %u, Flags [%s], pref %s, router lifetime %us, reachable time %ums, retrans timer %umschar[98]RTADVLENconst nd_neighbor_solicitconst nd_neighbor_solicit *nd_neighbor_solicit *, who has %sNDSOLLENconst nd_neighbor_advertconst nd_neighbor_advert *nd_neighbor_advert *, tgt is %sNDADVLENconst nd_redirectconst nd_redirect *nd_redirect * to %sREDIRECTLENICMP6_ROUTER_RENUMBERINGIND_SOLICITIND_ADVERTICMP6_V2_MEMBERSHIP_REPORTICMP6_MOBILEPREFIX_SOLICITICMP6_HADISCOV_REQUEST, id 0x%04xMPADVLENsizeof(struct icmp6_hdr)rpl_printsecuredbasecode(ndo, ", (SEC) [worktodo]")(ndo, ", (CLR)"), (SEC) [worktodo], (CLR)(ndo, "DODAG Information Solicitation")(ndo, "DODAG Information Object")(ndo, "Destination Advertisement Object")(ndo, "Destination Advertisement Object Ack")(ndo, "RPL message, unknown code %u",hdr->icmp6_code)DODAG Information SolicitationDODAG Information ObjectDestination Advertisement ObjectDestination Advertisement Object AckRPL message, unknown code %urpl_daoack_printconst nd_rpl_daoackconst nd_rpl_daoack *nd_rpl_daoack *daoackdagid_str<elided>"<elided>"*daoackdaoack->rpl_flagsdaoack->rpl_dagidconst uint8_t(*)[16](ndo, " [dagid:%s,seq:%u,instance:%u,status:%u]", dagid_str, daoack->rpl_daoseq, daoack->rpl_instanceid, daoack->rpl_status) [dagid:%s,seq:%u,instance:%u,status:%u]const rpl_dio_genoptionconst rpl_dio_genoption *rpl_dio_genoption *(ndo," [|dao-truncated]") [|dao-truncated](ndo," [|dao-length too short]") [|dao-length too short]rpl_dao_printconst nd_rpl_daoconst nd_rpl_dao *nd_rpl_dao *dao*daosizeof(*dao)dao->rpl_flagsdao->rpl_dagid(ndo, " [dagid:%s,seq:%u,instance:%u%s%s,%02x]", dagid_str, dao->rpl_daoseq, dao->rpl_instanceid, RPL_DAO_K(dao->rpl_flags) ? ",acK":"", RPL_DAO_D(dao->rpl_flags) ? ",Dagid":"", dao->rpl_flags)(ndo, " [dagid:%s,seq:%u,instance:%u%s%s,%02x]", dagid_str, dao->rpl_daoseq, dao->rpl_instanceid, (((dao->rpl_flags)&(1 << 7)) >> 7) ? ",acK":"", (((dao->rpl_flags)&(1 << 6)) >> 6) ? ",Dagid":"", dao->rpl_flags) [dagid:%s,seq:%u,instance:%u%s%s,%02x],acK,Dagid(ndo," [|truncated]") [|truncated](ndo," [|length too short]") [|length too short]rpl_dio_printconst nd_rpl_dioconst nd_rpl_dio *nd_rpl_dio *dio*diosizeof(*dio)dio->rpl_dagid(ndo, " [dagid:%s,seq:%u,instance:%u,rank:%u,%smop:%s,prf:%u]", dagid_str, dio->rpl_dtsn, dio->rpl_instanceid, EXTRACT_16BITS(&dio->rpl_dagrank), RPL_DIO_GROUNDED(dio->rpl_mopprf) ? "grounded,":"", tok2str(rpl_mop_values, "mop%u", RPL_DIO_MOP(dio->rpl_mopprf)), RPL_DIO_PRF(dio->rpl_mopprf))(ndo, " [dagid:%s,seq:%u,instance:%u,rank:%u,%smop:%s,prf:%u]", dagid_str, dio->rpl_dtsn, dio->rpl_instanceid, ((uint16_t)(((uint16_t)(*((const uint8_t *)(&dio->rpl_dagrank) + 0)) << 8) | ((uint16_t)(*((const uint8_t *)(&dio->rpl_dagrank) + 1)) << 0))), ((dio->rpl_mopprf)&0x80) ? "grounded,":"", tok2str(rpl_mop_values, "mop%u", (enum RPL_DIO_MOP)(((dio->rpl_mopprf)&(7 << 3)) >> 3)), (((dio->rpl_mopprf)&(7 << 0)) >> 0)) [dagid:%s,seq:%u,instance:%u,rank:%u,%smop:%s,prf:%u]&dio->rpl_dagrankdio->rpl_mopprfgrounded,mop%urpl_dio_printoptopt->rpl_dio_lensizeof(opt->rpl_dio_len)*opt(opt->rpl_dio_len+2)(ndo, " opt:pad0")(ndo, " opt:%s len:%u ", tok2str(rpl_subopt_values, "subopt:%u", opt->rpl_dio_type), optlen) opt:pad0 opt:%s len:%u subopt:%upaylenicmp6_cksumprint_lladdrq(ndo,":")(ndo,"%02x", *q++)get_lifetime"%us", v0UL(uint32_t)~0UL%usget_rtprefrtpref_strND_RA_FLAG_RTPREF_MASKmedium"medium"high"high"rsv"rsv"low"low"rr_resultrr_pco_userr_pco_matchicmp6_router_renumni_reply_fqdnicmp6_nodeinfoicmp6_namelookupnd_opt_route_infond_opt_homeagent_infond_opt_advintervalnd_opt_dnsslnd_opt_rdnssnd_opt_mtund_opt_rd_hdrnd_opt_prefix_infond_opt_hdrnd_redirectnd_neighbor_advertnd_neighbor_solicitnd_router_advertnd_router_solicitmld6_hdricmp6_hdrrrr_prefixrrr_ifidrrr_matchedlenrrr_ordinalrrr_flagsrpu_prefixrpu_flagsrpu_pltimerpu_vltimerpu_raflagsrpu_ramaskrpu_keeplenrpu_uselenrpm_prefixrpm_reservedrpm_maxlenrpm_minlenrpm_matchlenrpm_ordinalrpm_lenrpm_coderr_reservedrr_maxdelayrr_flagsrr_segnumrr_hdrni_fqdn_nameni_fqdn_namelenni_fqdn_ttlicmp6_ni_nonceicmp6_ni_hdricmp6_nl_ttlicmp6_nl_nonceicmp6_nl_hdrnd_opt_rti_lifetimend_opt_rti_flagsnd_opt_rti_prefixlennd_opt_rti_lennd_opt_rti_typend_opt_hai_lifetimend_opt_hai_preferencend_opt_hai_reservednd_opt_hai_lennd_opt_hai_typend_opt_adv_intervalnd_opt_adv_reservednd_opt_adv_lennd_opt_adv_typend_opt_dnssl_lifetimend_opt_dnssl_reservednd_opt_dnssl_lennd_opt_dnssl_typend_opt_rdnss_addrnd_opt_rdnss_lifetimend_opt_rdnss_reservednd_opt_rdnss_lennd_opt_rdnss_typend_opt_mtu_mtund_opt_mtu_reservednd_opt_mtu_lennd_opt_mtu_typend_opt_rh_reserved2nd_opt_rh_reserved1nd_opt_rh_lennd_opt_rh_typend_opt_pi_prefixnd_opt_pi_reserved2nd_opt_pi_preferred_timend_opt_pi_valid_timend_opt_pi_flags_reservednd_opt_pi_prefix_lennd_opt_pi_lennd_opt_pi_typend_opt_lennd_opt_typend_rd_dstnd_rd_targetnd_rd_hdrnd_na_targetnd_na_hdrnd_ns_targetnd_ns_hdrnd_ra_retransmitnd_ra_reachablend_ra_hdrnd_rs_hdrmld6_addricmp6_dataunicmp6_codeicmp6_typeicmp6_un_data8icmp6_un_data16icmp6_un_data32pad0"pad0"padN"padN"metrics"metrics"routinginfo"routinginfo"config"config"rpltarget"rpltarget"transitinfo"transitinfo"destprefix"destprefix"rpltargetdesc"rpltargetdesc"rpl_subopt_valuesnonstoring"nonstoring"storing"storing"nonstoring-multicast"nonstoring-multicast"storing-multicast"storing-multicast"rpl_mop_valuesis_in"is_in"is_ex"is_ex"to_in"to_in"to_ex"to_ex"allow"allow"block"block"mldv2report2strsource link-address"source link-address"destination link-address"destination link-address"prefix info"prefix info"redirected header"redirected header""mtu"rdnss"rdnss"dnssl"dnssl"advertisement interval"advertisement interval"homeagent information"homeagent information"route info"route info"icmp6_opt_valuesND_NA_FLAG_ROUTERrouter"router"ND_NA_FLAG_SOLICITEDsolicited"solicited"ND_NA_FLAG_OVERRIDEoverride"override"icmp6_nd_na_flag_valuesND_RA_FLAG_MANAGEDmanaged"managed"ND_RA_FLAG_OTHERother stateful"other stateful"ND_RA_FLAG_HOME_AGENThome agent"home agent"icmp6_opt_ra_flag_valuesND_OPT_PI_FLAG_ONLINKonlink"onlink"ND_OPT_PI_FLAG_AUTOauto"auto"ND_OPT_PI_FLAG_ROUTERicmp6_opt_pi_flag_valuesunreachable route"unreachable route" unreachable prohibited" unreachable prohibited"beyond scope"beyond scope"unreachable address"unreachable address"unreachable port"unreachable port"icmp6_dst_unreach_code_valuesdestination unreachable"destination unreachable"packet too big"packet too big"parameter problem"parameter problem"MLD6_LISTENER_QUERYmulticast listener query"multicast listener query"MLD6_LISTENER_REPORTmulticast listener report"multicast listener report"MLD6_LISTENER_DONEmulticast listener done"multicast listener done"neighbor solicitation"neighbor solicitation"neighbor advertisement"neighbor advertisement"redirect"redirect"router renumbering"router renumbering"inverse neighbor solicitation"inverse neighbor solicitation"inverse neighbor advertisement"inverse neighbor advertisement"MLDV2_LISTENER_REPORTmulticast listener report v2"multicast listener report v2"ha discovery request"ha discovery request"ha discovery reply"ha discovery reply"mobile router solicitation"mobile router solicitation"mobile router advertisement"mobile router advertisement"ICMP6_WRUREQUESTwho-are-you request"who-are-you request"ICMP6_WRUREPLYwho-are-you reply"who-are-you reply"node information query"node information query"node information reply"node information reply"MLD6_MTRACEmtrace message"mtrace message"MLD6_MTRACE_RESPmtrace response"mtrace response"RPL"RPL"icmp6_type_valuesF(x,y)((use->rpu_flags) & (x) ? (y) : "")((rr6->rr_flags) & (x) ? (y) : "")ECHECKECHECK(var)if ((const u_char *)&(var) > ep - sizeof(var)) returnRDRRDR(i)((const struct nd_redirect *)(i))abs(a)((0 < (a)) ? (a) : -(a))ICMP6_RR_RESULT_FLAGS_FORBIDDEN((uint16_t)htons(0x0001))ICMP6_RR_RESULT_FLAGS_OOB((uint16_t)htons(0x0002))((uint32_t)htonl(0x40000000))((uint32_t)htonl(0x80000000))ICMP6_RR_PCOUSE_RAFLAGS_AUTOICMP6_RR_PCOUSE_RAFLAGS_ONLINKRPM_PCO_MAXrr_seqnumrr_hdr.icmp6_data32[0]rr_cksumrr_hdr.icmp6_cksumrr_coderr_hdr.icmp6_coderr_typerr_hdr.icmp6_typeNI_NODEADDR_FLAG_ANYCAST((uint16_t)htons(0x40))NI_NODEADDR_FLAG_GLOBAL((uint16_t)htons(0x20))NI_NODEADDR_FLAG_SITELOCAL((uint16_t)htons(0x10))NI_NODEADDR_FLAG_LINKLOCAL((uint16_t)htons(0x8))NI_NODEADDR_FLAG_COMPAT((uint16_t)htons(0x4))NI_NODEADDR_FLAG_ALL((uint16_t)htons(0x2))NI_NODEADDR_FLAG_TRUNCATE((uint16_t)htons(0x1))NI_FQDN_FLAG_VALIDTTLNI_SUPTYPE_FLAG_COMPRESSNI_QTYPE_IPV4ADDRNI_QTYPE_DNSNAMEni_flagsicmp6_ni_hdr.icmp6_data16[1]ni_qtypeicmp6_ni_hdr.icmp6_data16[0]ni_cksumicmp6_ni_hdr.icmp6_cksumni_codeicmp6_ni_hdr.icmp6_codeni_typeicmp6_ni_hdr.icmp6_typend_rd_reservednd_rd_hdr.icmp6_data32[0]nd_rd_cksumnd_rd_hdr.icmp6_cksumnd_rd_codend_rd_hdr.icmp6_codend_rd_typend_rd_hdr.icmp6_type0x20000000nd_na_flags_reservednd_na_hdr.icmp6_data32[0]nd_na_cksumnd_na_hdr.icmp6_cksumnd_na_codend_na_hdr.icmp6_codend_na_typend_na_hdr.icmp6_typend_ns_reservednd_ns_hdr.icmp6_data32[0]nd_ns_cksumnd_ns_hdr.icmp6_cksumnd_ns_codend_ns_hdr.icmp6_codend_ns_typend_ns_hdr.icmp6_typend_ra_router_lifetimend_ra_hdr.icmp6_data16[1]ND_RA_FLAG_RTPREF_RSVND_RA_FLAG_RTPREF_LOWND_RA_FLAG_RTPREF_MEDIUMND_RA_FLAG_RTPREF_HIGHnd_ra_flags_reservednd_ra_hdr.icmp6_data8[1]nd_ra_curhoplimitnd_ra_hdr.icmp6_data8[0]nd_ra_cksumnd_ra_hdr.icmp6_cksumnd_ra_codend_ra_hdr.icmp6_codend_ra_typend_ra_hdr.icmp6_typend_rs_reservednd_rs_hdr.icmp6_data32[0]nd_rs_cksumnd_rs_hdr.icmp6_cksumnd_rs_codend_rs_hdr.icmp6_codend_rs_typend_rs_hdr.icmp6_typemld6_reservedmld6_hdr.icmp6_data16[1]mld6_maxdelaymld6_hdr.icmp6_data16[0]mld6_cksummld6_hdr.icmp6_cksummld6_codemld6_hdr.icmp6_codemld6_typemld6_hdr.icmp6_typeND_REDIRECT_ROUTERND_REDIRECT_ONLINKICMP6_INFOMSG_MASKICMP6_DST_UNREACH_NOTNEIGHBORICMP6_MAXTYPEICMP6_FQDN_REPLYICMP6_FQDN_QUERYicmp6_maxdelayicmp6_data16[0]icmp6_seqicmp6_data16[1]icmp6_idicmp6_mtuicmp6_data32[0]icmp6_pptricmp6_data8icmp6_dataun.icmp6_un_data8icmp6_data16icmp6_dataun.icmp6_un_data16icmp6_data32icmp6_dataun.icmp6_un_data32abs/*[*//*]*//* icmp-name-lookup-03, pascal string *//* XXX backward compat, icmp-name-lookup-03 *//* NI_NODEADDR_FLAG_TRUNCATE undefined for query *//* KAME who-are-you *//* invalid *//* truncated *//* FQDN *//* DNS name decoding - no decompression *//* Minimum len is 28 *//* Next group record *//* Print the sources *//* Check the number of sources and print them *//* type(1) + auxlen(1) + numsrc(2) + grp(16) *//* Print the group records *//* Minimum len is 8 *//* skip option header *//* domain names, variable-sized, RFC1035-encoded *//* xxx *//* should be notreached, though *//* meaningless, but set here anyway *//* unknown or undecodable header *//* fragments with non-zero offset are meaningless *//* this should be odd, but try anyway *//* NOTREACHED *//* plus 4, because struct icmp6_hdr contains 4 bytes of icmp payload *//* display cosmetics: print the packet length for printer that use the vflag now *//* XXX
                 * the next header pointer needs to move forward to
                 * skip the secure part.
                 *//* no officially defined options for DAOACK, but print any we find *//* content of DIO option *//* 01 *//* 00 *//* mldv2 report types *//* network endian *//* router renumbering result message *//* use prefix part *//* match prefix part *//* router renumbering header *//*
 * Router Renumbering. as router-renum-08.txt
 *//* XXX: alignment *//* length in octets of the FQDN *//* TTL *//* just experimental. not in spec *//* IPv4 Addresses *//* Node Addresses *//* DNS Name *//* FQDN (draft 04) *//* Supported Qtypes *//* NOOP  *//* could be followed by reply data *//*
 * icmp6 node information
 *//* could be followed by options *//*
 * icmp6 namelookup
 *//* prefix follows *//* route info *//* Home Agent info *//* Advertisement interval option *//* followed by list of DNS search domains, variable-length *//* DNSSL RFC 6106 5.2 *//* variable-length *//* RDNSS RFC 6106 5.1 *//* MTU option *//* followed by IP header and data *//* redirected header *//*2292bis*//* prefix information *//* RFC4191 *//* followed by option specific data*//* Neighbor discovery option header *//* destination address *//* target address *//* redirect *//* neighbor advertisement *//*target address *//* neighbor solicitation *//* 00010000 *//* 00011000 *//* 00000000 *//* 00001000 *//*
 * Router preference values based on draft-draves-ipngwg-router-selection-01.
 * These are non-standard definitions.
 *//* retransmit timer *//* reachable time *//*
 * Neighbor Discovery
 *//* multicast address *//*
 * Multicast Listener Discovery
 *//* redirect to a better router *//* redirect to an on-link node *//* Used in kernel only *//* rr seq num reset *//* rr result *//* rr command *//* unknown Qtype *//* node information request is refused *//* node information successful reply *//* Query Subject is an IPv4 address *//* Query Subject is a Domain name *//* Query Subject is an IPv6 address *//* all informational messages *//* unrecognized option *//* unrecognized next header *//* erroneous header field *//* port unreachable *//* address unreachable *//* beyond scope of source address *//* not a neighbor(obsolete) *//* administratively prohibited *//* no route to destination *//* mtrace messages *//* mtrace response(to sender) *//* v2 multicast listener report *//* v2 membership report *//* inverse neighbor advertisement *//* inverse neighbor solicitation *//* node information reply *//* node information request *//* FQDN reply *//* FQDN query *//* who are you reply *//* who are you request *//* router renumbering *//* multicast listener done *//* group membership termination *//* multicast listener report *//* group membership report *//* multicast listener query *//* group membership query *//* ip6 header bad *//* packet too big *//* mcast group membership *//* echo request/reply *//* parameter prob *//* type-specific field *//* checksum field *//* code field *//* type field *//*	$KAME: icmp6.h,v 1.22 2000/08/03 15:25:16 jinmei Exp $	*//*	NetBSD: icmp6.h,v 1.13 2000/08/03 16:30:37 itojun Exp 	*//* \summary: IPv6 Internet Control Message Protocol (ICMPv6) printer *//Users/owura/Repos/codeql_eval/proj_repos/the-tcpdump-group-tcpdump-commit-9ba91381954ad325ea4fd26b9c65a8bd9a2a85b6/tcpdump/print-igmp.cigmp_print(ndo, "igmp")(ndo, "igmp query")(ndo, " v2")(ndo, " [max resp time %d]", bp[1])(ndo, " v1")bp[4]&bp[4](ndo, " [gaddr %s]", ipaddr_string(ndo, &bp[4]))(ndo, " [gaddr %s]", getname(ndo, (const u_char *)(&bp[4])))(ndo, " [len %d]", len)(ndo, "igmp v1 report %s", ipaddr_string(ndo, &bp[4]))(ndo, "igmp v1 report %s", getname(ndo, (const u_char *)(&bp[4])))(ndo, "igmp v2 report %s", ipaddr_string(ndo, &bp[4]))(ndo, "igmp v2 report %s", getname(ndo, (const u_char *)(&bp[4])))(ndo, "igmp v3 report")(ndo, "igmp leave %s", ipaddr_string(ndo, &bp[4]))(ndo, "igmp leave %s", getname(ndo, (const u_char *)(&bp[4])))(ndo, "igmp dvmrp")(ndo, "igmp pimv1")(ndo, "igmp-%d", bp[0])igmp query [max resp time %d] v1 [gaddr %s] [len %d]igmp v1 report %sigmp v2 report %s0x22igmp v3 reportigmp leave %sigmp dvmrpigmp pimv1igmp-%d(ndo, " bad igmp cksum %x!", EXTRACT_16BITS(&bp[2]))(ndo, " bad igmp cksum %x!", ((uint16_t)(((uint16_t)(*((const uint8_t *)(&bp[2]) + 0)) << 8) | ((uint16_t)(*((const uint8_t *)(&bp[2]) + 1)) << 0))))&bp[2] bad igmp cksum %x!print_igmpv3_query(ndo, " v3") v3(ndo, " [invalid len %d]", len)(ndo, " [max resp time ")(ndo, "%.1fs", mrt * 0.1) [max resp time %.1fs(ndo, " [gaddr %s", ipaddr_string(ndo, &bp[4]))(ndo, " [gaddr %s", getname(ndo, (const u_char *)(&bp[4])))bp[10]&bp[10](ndo, " [invalid number of sources]")(ndo, " {")bp[12+(i<<2)](ndo, " %s", ipaddr_string(ndo, &bp[12+(i<<2)]))(ndo, " %s", getname(ndo, (const u_char *)(&bp[12+(i<<2)])))&bp[12+(i<<2)](ndo, " }")(ndo, ", %d source(s)", nsrcs)print_igmpv3_reportbp[6](ndo, ", %d group record(s)", ngroups)(ndo, " [invalid number of groups]")bp[group+4](ndo, " [gaddr %s", ipaddr_string(ndo, &bp[group+4]))(ndo, " [gaddr %s", getname(ndo, (const u_char *)(&bp[group+4])))&bp[group+4](ndo, " %s", tok2str(igmpv3report2str, " [v3-report-#%d]", bp[group]))&bp[group+2](ndo, " [invalid number of sources %d]", nsrcs)bp[group+8+(j<<2)](ndo, " %s", ipaddr_string(ndo, &bp[group+8+(j<<2)]))(ndo, " %s", getname(ndo, (const u_char *)(&bp[group+8+(j<<2)])))&bp[group+8+(j<<2)] [v3-report-#%d]print_mrespconst tr_queryconst tr_query *tr_query *tr*trsizeof(*tr)sizeof (struct tr_query)8 + sizeof (struct tr_query)(ndo, "mresp %lu: %s to %s reply-to %s", (u_long)TR_GETQID(EXTRACT_32BITS(&tr->tr_rttlqid)), ipaddr_string(ndo, &tr->tr_src), ipaddr_string(ndo, &tr->tr_dst), ipaddr_string(ndo, &tr->tr_raddr))(ndo, "mresp %lu: %s to %s reply-to %s", (u_long)((((uint32_t)(((uint32_t)(*((const uint8_t *)(&tr->tr_rttlqid) + 0)) << 24) | ((uint32_t)(*((const uint8_t *)(&tr->tr_rttlqid) + 1)) << 16) | ((uint32_t)(*((const uint8_t *)(&tr->tr_rttlqid) + 2)) << 8) | ((uint32_t)(*((const uint8_t *)(&tr->tr_rttlqid) + 3)) << 0)))) & 0x00ffffff), getname(ndo, (const u_char *)(&tr->tr_src)), getname(ndo, (const u_char *)(&tr->tr_dst)), getname(ndo, (const u_char *)(&tr->tr_raddr)))mresp %lu: %s to %s reply-to %s&tr->tr_rttlqidEXTRACT_32BITS(&tr->tr_rttlqid)((uint32_t)(((uint32_t)(*((const uint8_t *)(&tr->tr_rttlqid) + 0)) << 24) | ((uint32_t)(*((const uint8_t *)(&tr->tr_rttlqid) + 1)) << 16) | ((uint32_t)(*((const uint8_t *)(&tr->tr_rttlqid) + 2)) << 8) | ((uint32_t)(*((const uint8_t *)(&tr->tr_rttlqid) + 3)) << 0)))&tr->tr_src&tr->tr_dst&tr->tr_raddrEXTRACT_32BITS(&tr->tr_raddr)((uint32_t)(((uint32_t)(*((const uint8_t *)(&tr->tr_raddr) + 0)) << 24) | ((uint32_t)(*((const uint8_t *)(&tr->tr_raddr) + 1)) << 16) | ((uint32_t)(*((const uint8_t *)(&tr->tr_raddr) + 2)) << 8) | ((uint32_t)(*((const uint8_t *)(&tr->tr_raddr) + 3)) << 0)))(ndo, " with-ttl %d", TR_GETTTL(EXTRACT_32BITS(&tr->tr_rttlqid)))(ndo, " with-ttl %d", (int)(((((uint32_t)(((uint32_t)(*((const uint8_t *)(&tr->tr_rttlqid) + 0)) << 24) | ((uint32_t)(*((const uint8_t *)(&tr->tr_rttlqid) + 1)) << 16) | ((uint32_t)(*((const uint8_t *)(&tr->tr_rttlqid) + 2)) << 8) | ((uint32_t)(*((const uint8_t *)(&tr->tr_rttlqid) + 3)) << 0)))) >> 24) & 0xff))4026531840 with-ttl %dprint_mtrace(ndo, "mtrace %u: %s to %s reply-to %s", TR_GETQID(EXTRACT_32BITS(&tr->tr_rttlqid)), ipaddr_string(ndo, &tr->tr_src), ipaddr_string(ndo, &tr->tr_dst), ipaddr_string(ndo, &tr->tr_raddr))(ndo, "mtrace %u: %s to %s reply-to %s", ((((uint32_t)(((uint32_t)(*((const uint8_t *)(&tr->tr_rttlqid) + 0)) << 24) | ((uint32_t)(*((const uint8_t *)(&tr->tr_rttlqid) + 1)) << 16) | ((uint32_t)(*((const uint8_t *)(&tr->tr_rttlqid) + 2)) << 8) | ((uint32_t)(*((const uint8_t *)(&tr->tr_rttlqid) + 3)) << 0)))) & 0x00ffffff), getname(ndo, (const u_char *)(&tr->tr_src)), getname(ndo, (const u_char *)(&tr->tr_dst)), getname(ndo, (const u_char *)(&tr->tr_raddr)))mtrace %u: %s to %s reply-to %str_resptr_querytr_rflagstr_smasktr_fttltr_rprototr_pktcnttr_vifouttr_vifintr_rmtaddrtr_outaddrtr_inaddrtr_qarrtr_rttlqidtr_raddrtr_dsttr_srcigmpv3report2str[|igmp]"[|igmp]"TR_PROTO_CBTTR_PROTO_PIMTR_PROTO_MOSPFTR_PROTO_DVMRPTR_OLD_ROUTERTR_NO_SPACETR_NO_FWDTR_NO_RTETR_SCOPEDTR_OPRUNEDTR_PRUNEDTR_WRONG_IFTR_NO_ERRTR_RESPTR_QUERYTR_GETQID(x)((x) & 0x00ffffff)TR_GETTTL(x)(int)(((x) >> 24) & 0xff)IN_CLASSD/* Check the IGMP checksum *//* Minimum len is 12, and should be a multiple of 4 *//* Minimum len is 16, and should be a multiple of 4 *//* igmpv3 report types *//* fields for tr_rproto (routing protocol) *//* fields for tr_rflags (forwarding error codes) *//* defs within mtrace *//* forwarding error codes *//* subnet mask for src addr *//* ttl required to forward on outvif *//* routing proto deployed on router *//* total incoming packets for src-grp *//* output packet count on interface *//* input packet count on interface *//* parent address in source tree *//* outgoing interface address *//* incoming interface address *//* query arrival time *//*
 * Traceroute response format.  A traceroute response has a tr_query at the
 * beginning, followed by one tr_resp for each hop taken.
 *//* response ttl and qid *//* traceroute response address *//* traceroute destination *//* traceroute source *//*
 * The packet format for a traceroute request.
 *//* (following from ipmulti/mrouted/prune.h) *//* \summary: Internet Group Management Protocol (IGMP) printer *//*
 * Copyright (c) 1988, 1989, 1990, 1991, 1993, 1994, 1995, 1996
 *  The Regents of the University of California.  All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that: (1) source code distributions
 * retain the above copyright notice and this paragraph in its entirety, (2)
 * distributions including binary code include the above copyright notice and
 * this paragraph in its entirety in the documentation or other materials
 * provided with the distribution, and (3) all advertising materials mentioning
 * features or use of this software display the following acknowledgement:
 * ``This product includes software developed by the University of California,
 * Lawrence Berkeley Laboratory and its contributors.'' Neither the name of
 * the University nor the names of its contributors may be used to endorse
 * or promote products derived from this software without specific prior
 * written permission.
 * THIS SOFTWARE IS PROVIDED ``AS IS'' AND WITHOUT ANY EXPRESS OR IMPLIED
 * WARRANTIES, INCLUDING, WITHOUT LIMITATION, THE IMPLIED WARRANTIES OF
 * MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE.
 *//Users/owura/Repos/codeql_eval/proj_repos/the-tcpdump-group-tcpdump-commit-9ba91381954ad325ea4fd26b9c65a8bd9a2a85b6/tcpdump/print-igrp.cigrp_printconst igrphdrconst igrphdr *igrphdr *nintnsys(ndo, "igrp:")igrp:*hdr&hdr->ig_ni&hdr->ig_ns&hdr->ig_nx(ndo, " %s V%d edit=%d AS=%d (%d/%d/%d)", tok2str(op2str, "op-#%d", IGRP_OP(hdr->ig_vop)), IGRP_V(hdr->ig_vop), hdr->ig_ed, EXTRACT_16BITS(&hdr->ig_as), nint, nsys, next)(ndo, " %s V%d edit=%d AS=%d (%d/%d/%d)", tok2str(op2str, "op-#%d", ((hdr->ig_vop) & 0x0f)), (((hdr->ig_vop) & 0xf0) >> 4), hdr->ig_ed, ((uint16_t)(((uint16_t)(*((const uint8_t *)(&hdr->ig_as) + 0)) << 8) | ((uint16_t)(*((const uint8_t *)(&hdr->ig_as) + 1)) << 0))), nint, nsys, next) %s V%d edit=%d AS=%d (%d/%d/%d)op-#%dhdr->ig_vop&hdr->ig_asIGRP_RTE_SIZE(ndo, " [extra bytes %d]", length)const igrprteconst igrprte *igrprte * [extra bytes %d](ndo, " [|igrp]") [|igrp]igrp_entry_print(ndo, " *.%d.%d.%d", igr->igr_net[0], igr->igr_net[1], igr->igr_net[2])(ndo, " X%d.%d.%d.0", igr->igr_net[0], igr->igr_net[1], igr->igr_net[2])(ndo, " %d.%d.%d.0", igr->igr_net[0], igr->igr_net[1], igr->igr_net[2]) *.%d.%d.%d X%d.%d.%d.0 %d.%d.%d.0igr->igr_dlyigr->igr_bwigris_interioris_exterior0xffffffigr->igr_mtu(ndo, " d=%d b=%d r=%d l=%d M=%d mtu=%d in %d hops", 10 * delay, bandwidth == 0 ? 0 : 10000000 / bandwidth, igr->igr_rel, igr->igr_ld, metric, mtu, igr->igr_hct) d=%d b=%d r=%d l=%d M=%d mtu=%d in %d hops10000000igrprteigrphdrigr_hctigr_ldigr_religr_mtuigr_bwigr_dlyigr_netig_sumig_nxig_nsig_niig_asig_edig_vopIGRP_UPDATEupdate"update"IGRP_REQUESTop2strIGRP_OP(x)((x) & 0x0f)IGRP_V(x)(((x) & 0xf0) >> 4)/* Header *//* don't believe sizeof ! *//* hop count *//* percent of channel occupied *//* percent packets successfully tx/rx *//* MTU in octets *//* bandwidth in units of 1 kb/s *//* delay in tens of microseconds *//* 3 significant octets of IP address *//* IGRP routing entry *//* checksum of IGRP header & data *//* number of networks ouside AS *//* number of networks in AS *//* number of subnet in local net *//* autonomous system number *//* edition number *//* protocol version number / opcode *//* IGRP Header *//* Cisco IGRP definitions *//* \summary: Interior Gateway Routing Protocol (IGRP) printer *//*
 * Copyright (c) 1996, 1997
 *	The Regents of the University of California.  All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that: (1) source code distributions
 * retain the above copyright notice and this paragraph in its entirety, (2)
 * distributions including binary code include the above copyright notice and
 * this paragraph in its entirety in the documentation or other materials
 * provided with the distribution, and (3) all advertising materials mentioning
 * features or use of this software display the following acknowledgement:
 * ``This product includes software developed by the University of California,
 * Lawrence Berkeley Laboratory and its contributors.'' Neither the name of
 * the University nor the names of its contributors may be used to endorse
 * or promote products derived from this software without specific prior
 * written permission.
 * THIS SOFTWARE IS PROVIDED ``AS IS'' AND WITHOUT ANY EXPRESS OR IMPLIED
 * WARRANTIES, INCLUDING, WITHOUT LIMITATION, THE IMPLIED WARRANTIES OF
 * MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE.
 *
 * Initial contribution from Francis Dupont (francis.dupont@inria.fr)
 *//Users/owura/Repos/codeql_eval/proj_repos/the-tcpdump-group-tcpdump-commit-9ba91381954ad325ea4fd26b9c65a8bd9a2a85b6/tcpdump/print-ip.cipN_print(ndo, "truncated-ip %d", length)truncated-ip %d(ndo, "unknown ip %d", (*bp & 0xF0) >> 4)unknown ip %dconst char[6]ip_printipdip_print_demux_state *ipdsipendip_sumipds->ip->ip_vhlsizeof(ipds->ip->ip_vhl)ipds->ip(ndo, "IP6, wrong link-layer encapsulation ")(ndo, "IP%u ", IP_V(ipds->ip))(ndo, "IP%u ", (((ipds->ip)->ip_vhl & 0xf0) >> 4))IP6, wrong link-layer encapsulation IP%u (ndo, "IP ")IP *ipds->ipsizeof(*ipds->ip)(ndo, "truncated-ip %u", length)sizeof (struct ip)truncated-ip %u(ndo, "bad-hlen %u", hlen)bad-hlen %u&ipds->ip->ip_len(ndo, "truncated-ip - %u bytes missing! ", ipds->len - length)truncated-ip - %u bytes missing! (ndo, "bad-len %u", ipds->len)bad-len %u&ipds->ip->ip_off(ndo, "(tos 0x%x", (int)ipds->ip->ip_tos)(ndo, ",ECT(1)")(ndo, ",ECT(0)")(ndo, ",CE")(ndo, ", ttl %u", ipds->ip->ip_ttl)(ndo, ", id %u, offset %u, flags [%s], proto %s (%u)", EXTRACT_16BITS(&ipds->ip->ip_id), (ipds->off & 0x1fff) * 8, bittok2str(ip_frag_values, "none", ipds->off&0xe000), tok2str(ipproto_values,"unknown",ipds->ip->ip_p), ipds->ip->ip_p)(ndo, ", id %u, offset %u, flags [%s], proto %s (%u)", ((uint16_t)(((uint16_t)(*((const uint8_t *)(&ipds->ip->ip_id) + 0)) << 8) | ((uint16_t)(*((const uint8_t *)(&ipds->ip->ip_id) + 1)) << 0))), (ipds->off & 0x1fff) * 8, bittok2str(ip_frag_values, "none", ipds->off&0xe000), tok2str(ipproto_values,"unknown",ipds->ip->ip_p), ipds->ip->ip_p)&ipds->ip->ip_id(ndo, ", length %u", EXTRACT_16BITS(&ipds->ip->ip_len))(ndo, ", length %u", ((uint16_t)(((uint16_t)(*((const uint8_t *)(&ipds->ip->ip_len) + 0)) << 8) | ((uint16_t)(*((const uint8_t *)(&ipds->ip->ip_len) + 1)) << 0))))(ndo, ", options (")&ipds->ip->ip_sum(ndo, ", bad cksum %x (->%x)!", ip_sum, in_cksum_shouldbe(ip_sum, sum))(ndo, ")\n    ")(tos 0x%x,ECT(1),ECT(0),CE, id %u, offset %u, flags [%s], proto %s (%u)819157344sizeof(struct ip), options (, bad cksum %x (->%x)!)
    (ndo, "%s > %s: ", ipaddr_string(ndo, &ipds->ip->ip_src), ipaddr_string(ndo, &ipds->ip->ip_dst))(ndo, "%s > %s: ", getname(ndo, (const u_char *)(&ipds->ip->ip_src)), getname(ndo, (const u_char *)(&ipds->ip->ip_dst)))&ipds->ip->ip_src&ipds->ip->ip_dst(ndo, "%s > %s:", ipaddr_string(ndo, &ipds->ip->ip_src), ipaddr_string(ndo, &ipds->ip->ip_dst))(ndo, "%s > %s:", getname(ndo, (const u_char *)(&ipds->ip->ip_src)), getname(ndo, (const u_char *)(&ipds->ip->ip_dst)))(ndo, " %s", p_name)(ndo, " ip-proto-%d", ipds->ip->ip_p)0x1fff%s > %s: %s > %s: ip-proto-%dip_print_innerip_print_demuxagain*ipds->cpsizeof(*ipds->cp)(ndo, " nd %d", ipds->len)(ndo, " (ipip-proto-4)")(ndo, "carp %s > %s: ", ipaddr_string(ndo, &ipds->ip->ip_src), ipaddr_string(ndo, &ipds->ip->ip_dst))(ndo, "carp %s > %s: ", getname(ndo, (const u_char *)(&ipds->ip->ip_src)), getname(ndo, (const u_char *)(&ipds->ip->ip_dst)))(ndo, "vrrp %s > %s: ", ipaddr_string(ndo, &ipds->ip->ip_src), ipaddr_string(ndo, &ipds->ip->ip_dst))(ndo, "vrrp %s > %s: ", getname(ndo, (const u_char *)(&ipds->ip->ip_src)), getname(ndo, (const u_char *)(&ipds->ip->ip_dst)))(ndo, " ip-proto-%d", ipds->nh)(ndo, " %d", ipds->len)enhIP_MFIP_OFFMASK(IP_MF|IP_OFFMASK) nd %d (ipip-proto-4)PT_CARPcarp %s > %s: vrrp %s > %s: ip_optprintsizeof(*cp)(ndo, "%s", tok2str(ip_option_values,"unknown %u",option_code))cp[1]sizeof(cp[1])(ndo, " [bad length %u]", option_len)cp[3]sizeof(cp[3])&cp[2](ndo, " value %u", EXTRACT_16BITS(&cp[2]))(ndo, " value %u", ((uint16_t)(((uint16_t)(*((const uint8_t *)(&cp[2]) + 0)) << 8) | ((uint16_t)(*((const uint8_t *)(&cp[2]) + 1)) << 0))))option_code","unknown %uIPOPT_NOPIPOPT_EOL [bad length %u]IPOPT_TSIPOPT_RRIPOPT_SSRRIPOPT_LSRRIPOPT_RA value %uIPOPT_SECURITYip_printtshoplen(ndo, "[bad length %u]", length)[bad length %u](ndo, " TS{") TS{IPOPT_TS_TSONLYcp[2]sizeof(cp[2])(ndo, "[bad ptr %u]", cp[2])[bad ptr %u](ndo, "TSONLY")(ndo, "TS+ADDR")(ndo, "PRESPEC2.0")(ndo, "PRESPEC")(ndo, "[bad ts type %d]", cp[3]&0xF)TSONLYIPOPT_TS_TSANDADDRTS+ADDRPRESPEC2.0PRESPEC[bad ts type %d]cp[len](ndo, "%s%d@%s", type, EXTRACT_32BITS(&cp[len+hoplen-4]), hoplen!=8 ? "" : ipaddr_string(ndo, &cp[len]))(ndo, "%s%d@%s", type, ((uint32_t)(((uint32_t)(*((const uint8_t *)(&cp[len+hoplen-4]) + 0)) << 24) | ((uint32_t)(*((const uint8_t *)(&cp[len+hoplen-4]) + 1)) << 16) | ((uint32_t)(*((const uint8_t *)(&cp[len+hoplen-4]) + 2)) << 8) | ((uint32_t)(*((const uint8_t *)(&cp[len+hoplen-4]) + 3)) << 0))), hoplen!=8 ? "" : getname(ndo, (const u_char *)(&cp[len])))&cp[len+hoplen-4]&cp[len] ^ " ^ "%s%d@%s(ndo, "%s", ptr == len ? " ^ " : "")(ndo, " [%d hops not recorded]} ", cp[3]>>4)(ndo, "}") [%d hops not recorded]} nextproto4_cksumphdrphcksum_vec[2](uint16_t)len&ph.src&ph.dstphdr *sizeof(ph)ip_finddstretval&retvalcp + len - 4ttip_printroute(ndo, " [bad length %u]", length)(ndo, " [bad ptr %u]", cp[2]) [bad ptr %u](ndo, " %s", ipaddr_string(ndo, &cp[len]))(ndo, " %s", getname(ndo, (const u_char *)(&cp[len])))ip_print_demux_stateoff"+"IP_DFDF"DF"IP_RESrsvd"rsvd"ip_frag_valuesEOL"EOL"NOP"NOP"covlennext_protosecurity"security"RR"RR"SSRR"SSRR"LSRR"LSRR"RA"RA"IPOPT_RFC1393traceroute"traceroute"ip_option_values[|ip]"[|ip]"GUESS_TSO/*
		 * This isn't the first frag, so we're missing the
		 * next level protocol header.  print the ip addr
		 * and the protocol.
		 *//*
		 * Ultra quiet now means that all this stuff should be
		 * suppressed.
		 *//*
	 * If this is fragment zero, hand it to the next higher
	 * level protocol.
	 *//*
	     * for the firewall guys, print id, offset.
             * On all but the last stick a "+" in the flags portion.
	     * For unfragmented datagrams, note the don't fragment flag.
	     *//* ECN bits *//*
	 * Cut off the snapshot length to the end of the IP payload.
	 *//* GUESS_TSO *//* we guess that it is a TSO send *//* print version and fail if != 4 *//*
 * print an IP datagram.
 *//* do it *//* ip6-in-ip encapsulation *//* DVMRP multicast tunnel (ip-in-ip encapsulation) *//*
		 * XXX - the current IANA protocol number assignments
		 * page lists 9 as "any private interior gateway
		 * (used by Cisco for their IGRP)" and 88 as
		 * "EIGRP" from Cisco.
		 *
		 * Recent BSD <netinet/in.h> headers define
		 * IP_PROTO_PIGP as 9 and IP_PROTO_IGRP as 88.
		 * We define IP_PROTO_PIGP as 9 and
		 * IP_PROTO_EIGRP as 88; those names better
		 * match was the current protocol number
		 * assignments say.
		 *//* pass on the MF bit plus the offset to detect fragments *//*
		 * Either this has decompressed the payload and
		 * printed it, in which case there's nothing more
		 * to do, or it hasn't, in which case there's
		 * nothing more to do.
		 *//* The RFC3514 evil ;-) bit *//* nothing to print - fall through *//*
 * print IP options.
 *//* IPOPT_TS_PRESPEC *//*
	 * prespecified should really be 3, but some ones might send 2
	 * instead, and the IPOPT_TS_PRESPEC constant can apparently
	 * have both values, so we have to hard-code it here.
	 *//* pseudo-header.. *//*
 * Compute a V4-style checksum by building a pseudoheader.
 *//*
 * If source-routing is present and valid, return the final destination.
 * Otherwise, return IP destination.
 *
 * This is used for UDP and TCP pseudo-header in the checksum
 * calculation.
 *//*
 * print the recorded route in an IP RR, LSRR or SSRR option.
 *//* \summary: IP printer *//Users/owura/Repos/codeql_eval/proj_repos/the-tcpdump-group-tcpdump-commit-9ba91381954ad325ea4fd26b9c65a8bd9a2a85b6/tcpdump/print-ip6.cip6_printpayload_lenflow*ip6sizeof(*ip6)(ndo, "truncated-ip6 %u", length)sizeof (struct ip6_hdr)truncated-ip6 %u(ndo, "IP6 ")IP6 (ndo,"version error: %u != 6", IP6_VERSION(ip6))(ndo,"version error: %u != 6", (((ip6)->ip6_ctlun.ip6_un2_vfc & 0xf0) >> 4))version error: %u != 6(ndo, "truncated-ip6 - %u bytes missing!", len - length)truncated-ip6 - %u bytes missing!&ip6->ip6_flow&ip6->ip6_ctlun.ip6_un1.ip6_un1_flow(ndo, "class 0x%02x, ", (flow & 0x0ff00000) >> 20)(ndo, "flowlabel 0x%05x, ", flow & 0x000fffff)(ndo, "hlim %u, next-header %s (%u) payload length: %u) ", ip6->ip6_hlim, tok2str(ipproto_values,"unknown",ip6->ip6_nxt), ip6->ip6_nxt, payload_len)(ndo, "hlim %u, next-header %s (%u) payload length: %u) ", ip6->ip6_ctlun.ip6_un1.ip6_un1_hlim, tok2str(ipproto_values,"unknown",ip6->ip6_ctlun.ip6_un1.ip6_un1_nxt), ip6->ip6_ctlun.ip6_un1.ip6_un1_nxt, payload_len)2673868800x0ff00000class 0x%02x, 0x000fffffflowlabel 0x%05x, hlim %u, next-header %s (%u) payload length: %u) (ndo, "%s > %s: ", ip6addr_string(ndo, &ip6->ip6_src), ip6addr_string(ndo, &ip6->ip6_dst))(ndo, "%s > %s: ", getname6(ndo, (const u_char *)(&ip6->ip6_src)), getname6(ndo, (const u_char *)(&ip6->ip6_dst)))(ndo, "no next header")(ndo, "ip-proto-%d %d", nh, len)no next headerip-proto-%d %d(ndo, "[|ip6]")[|ip6]nextproto6_cksum&ph0, sizeof(ph)&ph.ph_srcsizeof (struct in6_addr)&ph.ph_dstip6_finddstdst_addrconst ip6_rthdrconst ip6_rthdr *ip6_rthdr *const ip6_rthdr0const ip6_rthdr0 *ip6_rthdr0 *dp0IPV6_RTHDR_TYPE_0IPV6_RTHDR_TYPE_2ph_nxtph_zeroph_lenph_dstph_src/*
			 * Either this has decompressed the payload and
			 * printed it, in which case there's nothing more
			 * to do, or it hasn't, in which case there's
			 * nothing more to do.
			 *//*
			 * XXX - we don't use "advance"; RFC 3775 says that
			 * the next header field in a mobility header
			 * should be IPPROTO_NONE, but speaks of
			 * the possiblity of a future extension in
			 * which payload can be piggybacked atop a
			 * mobility header.
			 *//* RFC 2460 *//* rfc1883 *//*
 * print an IP6 datagram.
 *//*
                 * The next header is either a routing header or a header
                 * after which there might be a routing header, so scan
                 * for a routing header.
                 *//* pseudo-header *//*
 * Compute a V6-style checksum by building a pseudoheader.
 *//*
			 * AH and ESP are, in the RFCs that describe them,
			 * described as being "viewed as an end-to-end
			 * payload" "in the IPv6 context, so that they
			 * "should appear after hop-by-hop, routing, and
			 * fragmentation extension headers".  We assume
			 * that's the case, and stop as soon as we see
			 * one.  (We can't handle an ESP header in
			 * the general case anyway, as its length depends
			 * on the encryption algorithm.)
			 *
			 * IPComp is also "viewed as an end-to-end
			 * payload" "in the IPv6 context".
			 *
			 * All other protocols are assumed to be the final
			 * protocol.
			 *//*
			 * Only one routing header to a customer.
			 *//* Mobile IPv6 ID-20 *//*
			 * OK, we found it.
			 *//*
			 * The byte following the next header byte is
			 * marked as reserved, and the header is always
			 * the same size.
			 *//*
			 * These have a header length byte, following
			 * the next header byte, giving the length of
			 * the header, in units of 8 octets, excluding
			 * the first 8 octets.
			 *//*
 * If routing headers are presend and valid, set dst to the final destination.
 * Otherwise, set it to the IPv6 destination.
 *
 * This is used for UDP and TCP pseudo-header in the checksum
 * calculation.
 *//* \summary: IPv6 printer *//Users/owura/Repos/codeql_eval/proj_repos/the-tcpdump-group-tcpdump-commit-9ba91381954ad325ea4fd26b9c65a8bd9a2a85b6/tcpdump/print-ip6opts.cdstopt_printconst ip6_destconst ip6_dest *ip6_dest *dstoptlendp->ip6d_lensizeof(dp->ip6d_len)(ndo, "DSTOPT ")DSTOPT (ndo, "[|DSTOPT]")[|DSTOPT]hbhopt_printhbhlendp->ip6h_lensizeof(dp->ip6h_len)(ndo, "HBH ")HBH (ndo, "[|HBH]")[|HBH]ip6_opt_print(ndo, "(pad1)")(ndo, "(padn: trunc)")(ndo, "(padn)")(ndo, "(rtalert: trunc)")(ndo, "(rtalert: invalid len %d)", bp[i + 1])(ndo, "(rtalert: 0x%04x) ", EXTRACT_16BITS(&bp[i + 2]))(ndo, "(rtalert: 0x%04x) ", ((uint16_t)(((uint16_t)(*((const uint8_t *)(&bp[i + 2]) + 0)) << 8) | ((uint16_t)(*((const uint8_t *)(&bp[i + 2]) + 1)) << 0))))&bp[i + 2](ndo, "(jumbo: trunc)")(ndo, "(jumbo: invalid len %d)", bp[i + 1])(ndo, "(jumbo: %u) ", EXTRACT_32BITS(&bp[i + 2]))(ndo, "(jumbo: %u) ", ((uint32_t)(((uint32_t)(*((const uint8_t *)(&bp[i + 2]) + 0)) << 24) | ((uint32_t)(*((const uint8_t *)(&bp[i + 2]) + 1)) << 16) | ((uint32_t)(*((const uint8_t *)(&bp[i + 2]) + 2)) << 8) | ((uint32_t)(*((const uint8_t *)(&bp[i + 2]) + 3)) << 0))))(ndo, "(homeaddr: trunc)")(ndo, "(homeaddr: invalid len %d)", bp[i + 1])(ndo, "(homeaddr: %s", ip6addr_string(ndo, &bp[i + 2]))(ndo, "(homeaddr: %s", getname6(ndo, (const u_char *)(&bp[i + 2])))(ndo, "(type %d: trunc)", bp[i])(ndo, "(opt_type 0x%02x: len=%d)", bp[i], bp[i + 1])IP6OPT_PAD1(pad1)IP6OPT_PADNIP6OPT_MINLEN(padn: trunc)(padn)IP6OPT_ROUTER_ALERTIP6OPT_RTALERT_LEN(rtalert: trunc)(rtalert: invalid len %d)(rtalert: 0x%04x) IP6OPT_JUMBOIP6OPT_JUMBO_LEN(jumbo: trunc)(jumbo: invalid len %d)(jumbo: %u) IP6OPT_HOME_ADDRESSIP6OPT_HOMEADDR_MINLEN(homeaddr: trunc)(homeaddr: invalid len %d)(homeaddr: %s(type %d: trunc)(opt_type 0x%02x: len=%d)(ndo, "[trunc] ")[trunc] ip6_sopt_print(ndo, ", pad1")(ndo, ", padn: trunc")(ndo, ", padn")(ndo, ", sopt_type %d: trunc)", bp[i])(ndo, ", sopt_type 0x%02x: len=%d", bp[i], bp[i + 1]), pad1, padn: trunc, padn, sopt_type %d: trunc), sopt_type 0x%02x: len=%d/* \summary: IPv6 header option printer *//*
 * Copyright (C) 1998 WIDE Project.
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. Neither the name of the project nor the names of its contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE PROJECT AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE PROJECT OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 *//Users/owura/Repos/codeql_eval/proj_repos/the-tcpdump-group-tcpdump-commit-9ba91381954ad325ea4fd26b9c65a8bd9a2a85b6/tcpdump/print-ipcomp.cipcomp_printconst ipcompconst ipcomp *ipcomp *cpi*ipcompsizeof(*ipcomp)&ipcomp->comp_cpi(ndo, "IPComp(cpi=0x%04x)", cpi)IPComp(cpi=0x%04x)(ndo, "[|IPCOMP]")[|IPCOMP]comp_cpicomp_flagscomp_nxt/*
	 * XXX - based on the CPI, we could decompress the packet here.
	 * Packet buffer management is a headache (if we decompress,
	 * packet will become larger).
	 *
	 * We would decompress the packet and then call a routine that,
	 * based on ipcomp->comp_nxt, dissects the decompressed data.
	 *
	 * Until we do that, however, we just return -1, so that
	 * the loop that processes "protocol"/"next header" types
	 * stops - there's nothing more it can do with a compressed
	 * payload.
	 *//* Compression parameter index *//* \summary: IP Payload Compression Protocol (IPComp) printer *//Users/owura/Repos/codeql_eval/proj_repos/the-tcpdump-group-tcpdump-commit-9ba91381954ad325ea4fd26b9c65a8bd9a2a85b6/tcpdump/print-ipfc.cipfc_if_printipfc_printconst ipfc_headerconst ipfc_header *ipfc_header *ipfcp(ndo, "[|ipfc]")IPFC_HDRLEN[|ipfc]ipfc_hdr_printextract_ipfc_addrsipfcdst(const char *)&ipfcp->ipfc_dhost[2], 6ipfcsrc(const char *)&ipfcp->ipfc_shost[2], 6ipfc_headeripfc_shostipfc_dhost/*
 * This is the top level routine of the printer.  'p' points
 * to the Network_Header of the packet, 'h->ts' is the timestamp,
 * 'h->len' is the length of the packet off the wire, and 'h->caplen'
 * is the number of bytes actually captured.
 *//*
		 * Some kinds of LLC packet we cannot
		 * handle intelligently
		 *//* Skip over Network_Header *//*
	 * Get the network addresses into a canonical form
	 *//*
	 * XXX - should we show the upper 16 bits of the addresses?
	 * Do so only if "vflag" is set?
	 * Section 3.3 "FC Port and Node Network Addresses" says that
	 *
	 *    In this specification, both the Source and Destination
	 *    4-bit NAA identifiers SHALL be set to binary '0001'
	 *    indicating that an IEEE 48-bit MAC address is contained
	 *    in the lower 48 bits of the network address fields. The
	 *    high order 12 bits in the network address fields SHALL
	 *    be set to 0x0000.
	 *
	 * so, for captures following this specification, the upper 16
	 * bits should be 0x1000, followed by a MAC address.
	 *//*
 * Print the Network_Header
 *//*
	 * We assume that, as per RFC 2625, the lower 48 bits of the
	 * source and destination addresses are MAC addresses.
	 *//* specification: RFC 2625 *//* \summary: IP over Fibre Channel printer *//Users/owura/Repos/codeql_eval/proj_repos/the-tcpdump-group-tcpdump-commit-9ba91381954ad325ea4fd26b9c65a8bd9a2a85b6/tcpdump/print-ipnet.cipnet_if_printsizeof(ipnet_hdr_t)(sizeof(ipnet_hdr_t))ipnet_printconst ipnet_hdr_tconst ipnet_hdr_t *ipnet_hdr *hdr->iph_family&hdr->iph_familyIPH_AF_INETIPH_AF_INET6ipnet_hdr_print(ndo, "%d > %d", EXTRACT_32BITS(hdr->iph_zsrc), EXTRACT_32BITS(hdr->iph_zdst))(ndo, "%d > %d", ((uint32_t)(((uint32_t)(*((const uint8_t *)(hdr->iph_zsrc) + 0)) << 24) | ((uint32_t)(*((const uint8_t *)(hdr->iph_zsrc) + 1)) << 16) | ((uint32_t)(*((const uint8_t *)(hdr->iph_zsrc) + 2)) << 8) | ((uint32_t)(*((const uint8_t *)(hdr->iph_zsrc) + 3)) << 0))), ((uint32_t)(((uint32_t)(*((const uint8_t *)(hdr->iph_zdst) + 0)) << 24) | ((uint32_t)(*((const uint8_t *)(hdr->iph_zdst) + 1)) << 16) | ((uint32_t)(*((const uint8_t *)(hdr->iph_zdst) + 2)) << 8) | ((uint32_t)(*((const uint8_t *)(hdr->iph_zdst) + 3)) << 0))))%d > %dhdr->iph_zsrchdr->iph_zdst(ndo,", family %s (%d)", tok2str(ipnet_values, "Unknown", EXTRACT_8BITS(&hdr->iph_family)), EXTRACT_8BITS(&hdr->iph_family))(ndo,", family %s (%d)", tok2str(ipnet_values, "Unknown", (*(&hdr->iph_family))), (*(&hdr->iph_family)))(ndo,", %s", tok2str(ipnet_values, "Unknown Ethertype (0x%04x)", EXTRACT_8BITS(&hdr->iph_family)))(ndo,", %s", tok2str(ipnet_values, "Unknown Ethertype (0x%04x)", (*(&hdr->iph_family)))), family %s (%d)ipnet_hdr_tipnet_hdriph_zdstiph_zsrciph_grifindexiph_ifindexiph_pktleniph_htypeiph_familyiph_versionipnet_values[|ipnet]"[|ipnet]"DLT_IPNET/* DLT_IPNET *//* Matches Solaris's AF_INET6 *//* Matches Solaris's AF_INET *//* \summary: Solaris DLT_IPNET printer *//Users/owura/Repos/codeql_eval/proj_repos/the-tcpdump-group-tcpdump-commit-9ba91381954ad325ea4fd26b9c65a8bd9a2a85b6/tcpdump/print-ipx.cipx_rip_printipx[0]sizeof(ipx[0])(ndo, "ipx-rip-req")ipx[3]sizeof(ipx[3])(ndo, " %08x/%d.%d", EXTRACT_32BITS(&ipx[0]), EXTRACT_16BITS(&ipx[2]), EXTRACT_16BITS(&ipx[3]))(ndo, " %08x/%d.%d", ((uint32_t)(((uint32_t)(*((const uint8_t *)(&ipx[0]) + 0)) << 24) | ((uint32_t)(*((const uint8_t *)(&ipx[0]) + 1)) << 16) | ((uint32_t)(*((const uint8_t *)(&ipx[0]) + 2)) << 8) | ((uint32_t)(*((const uint8_t *)(&ipx[0]) + 3)) << 0))), ((uint16_t)(((uint16_t)(*((const uint8_t *)(&ipx[2]) + 0)) << 8) | ((uint16_t)(*((const uint8_t *)(&ipx[2]) + 1)) << 0))), ((uint16_t)(((uint16_t)(*((const uint8_t *)(&ipx[3]) + 0)) << 8) | ((uint16_t)(*((const uint8_t *)(&ipx[3]) + 1)) << 0))))&ipx[0]&ipx[2]&ipx[3](ndo, "ipx-rip-resp")(ndo, "ipx-rip-?%x", command)ipx-rip-req %08x/%d.%dipx-rip-respipx-rip-?%x(ndo, "[|ipx %d]", length)[|ipx %d]ipx_sap_print(ndo, "ipx-sap-req")(ndo, "ipx-sap-nearest-req")(ndo, " %s", ipxsap_string(ndo, htons(EXTRACT_16BITS(&ipx[0]))))(ndo, " %s", ipxsap_string(ndo, ((__uint16_t)(__builtin_constant_p(((uint16_t)(((uint16_t)(*((const uint8_t *)(&ipx[0]) + 0)) << 8) | ((uint16_t)(*((const uint8_t *)(&ipx[0]) + 1)) << 0)))) ? ((__uint16_t)((((__uint16_t)(((uint16_t)(((uint16_t)(*((const uint8_t *)(&ipx[0]) + 0)) << 8) | ((uint16_t)(*((const uint8_t *)(&ipx[0]) + 1)) << 0)))) & 0xff00U) >> 8) | (((__uint16_t)(((uint16_t)(((uint16_t)(*((const uint8_t *)(&ipx[0]) + 0)) << 8) | ((uint16_t)(*((const uint8_t *)(&ipx[0]) + 1)) << 0)))) & 0x00ffU) << 8))) : _OSSwapInt16(((uint16_t)(((uint16_t)(*((const uint8_t *)(&ipx[0]) + 0)) << 8) | ((uint16_t)(*((const uint8_t *)(&ipx[0]) + 1)) << 0))))))))EXTRACT_16BITS(&ipx[0])((uint16_t)(((uint16_t)(*((const uint8_t *)(&ipx[0]) + 0)) << 8) | ((uint16_t)(*((const uint8_t *)(&ipx[0]) + 1)) << 0)))(ndo, "ipx-sap-resp")(ndo, "ipx-sap-nearest-resp")(ndo, " %s '", ipxsap_string(ndo, htons(EXTRACT_16BITS(&ipx[0]))))(ndo, " %s '", ipxsap_string(ndo, ((__uint16_t)(__builtin_constant_p(((uint16_t)(((uint16_t)(*((const uint8_t *)(&ipx[0]) + 0)) << 8) | ((uint16_t)(*((const uint8_t *)(&ipx[0]) + 1)) << 0)))) ? ((__uint16_t)((((__uint16_t)(((uint16_t)(((uint16_t)(*((const uint8_t *)(&ipx[0]) + 0)) << 8) | ((uint16_t)(*((const uint8_t *)(&ipx[0]) + 1)) << 0)))) & 0xff00U) >> 8) | (((__uint16_t)(((uint16_t)(((uint16_t)(*((const uint8_t *)(&ipx[0]) + 0)) << 8) | ((uint16_t)(*((const uint8_t *)(&ipx[0]) + 1)) << 0)))) & 0x00ffU) << 8))) : _OSSwapInt16(((uint16_t)(((uint16_t)(*((const uint8_t *)(&ipx[0]) + 0)) << 8) | ((uint16_t)(*((const uint8_t *)(&ipx[0]) + 1)) << 0))))))))ipx[25](ndo, "' addr %s", ipxaddr_string(EXTRACT_32BITS(&ipx[25]), (const u_char *)&ipx[27]))(ndo, "' addr %s", ipxaddr_string(((uint32_t)(((uint32_t)(*((const uint8_t *)(&ipx[25]) + 0)) << 24) | ((uint32_t)(*((const uint8_t *)(&ipx[25]) + 1)) << 16) | ((uint32_t)(*((const uint8_t *)(&ipx[25]) + 2)) << 8) | ((uint32_t)(*((const uint8_t *)(&ipx[25]) + 3)) << 0))), (const u_char *)&ipx[27]))&ipx[25](ndo, "ipx-sap-?%x", command)ipx-sap-reqipx-sap-nearest-reqipx-sap-respipx-sap-nearest-resp %s '' addr %sipx-sap-?%xipx_decodeconst ipxHdrconst ipxHdr *ipxHdr *&ipx->dstSkt(ndo, "ipx-ncp %d", length)(ndo, "ipx-netbios %d", length)(ndo, "ipx-diags %d", length)(ndo, "ipx-nwlink-dgm %d", length)(ndo, "ipx-#%x %d", dstSkt, length)1105IPX_SKT_NCPipx-ncp %d1106IPX_SKT_SAP1107IPX_SKT_RIP1109IPX_SKT_NETBIOSipx-netbios %d1110IPX_SKT_DIAGNOSTICSipx-diags %d1363IPX_SKT_NWLINK_DGMipx-nwlink-dgm %dIPX_SKT_EIGRPipx-#%x %dipxaddr_string"%08x.%02x:%02x:%02x:%02x:%02x:%02x", net, node[0], node[1], node[2], node[3], node[4], node[5]%08x.%02x:%02x:%02x:%02x:%02x:%02xipx_print(ndo, "IPX ")IPX ipx->srcSktsizeof(ipx->srcSkt)(ndo, "%s.%04x > ", ipxaddr_string(EXTRACT_32BITS(ipx->srcNet), ipx->srcNode), EXTRACT_16BITS(&ipx->srcSkt))(ndo, "%s.%04x > ", ipxaddr_string(((uint32_t)(((uint32_t)(*((const uint8_t *)(ipx->srcNet) + 0)) << 24) | ((uint32_t)(*((const uint8_t *)(ipx->srcNet) + 1)) << 16) | ((uint32_t)(*((const uint8_t *)(ipx->srcNet) + 2)) << 8) | ((uint32_t)(*((const uint8_t *)(ipx->srcNet) + 3)) << 0))), ipx->srcNode), ((uint16_t)(((uint16_t)(*((const uint8_t *)(&ipx->srcSkt) + 0)) << 8) | ((uint16_t)(*((const uint8_t *)(&ipx->srcSkt) + 1)) << 0))))%s.%04x > ipx->srcNet&ipx->srcSkt(ndo, "%s.%04x: ", ipxaddr_string(EXTRACT_32BITS(ipx->dstNet), ipx->dstNode), EXTRACT_16BITS(&ipx->dstSkt))(ndo, "%s.%04x: ", ipxaddr_string(((uint32_t)(((uint32_t)(*((const uint8_t *)(ipx->dstNet) + 0)) << 24) | ((uint32_t)(*((const uint8_t *)(ipx->dstNet) + 1)) << 16) | ((uint32_t)(*((const uint8_t *)(ipx->dstNet) + 2)) << 8) | ((uint32_t)(*((const uint8_t *)(ipx->dstNet) + 3)) << 0))), ipx->dstNode), ((uint16_t)(((uint16_t)(*((const uint8_t *)(&ipx->dstSkt) + 0)) << 8) | ((uint16_t)(*((const uint8_t *)(&ipx->dstSkt) + 1)) << 0))))%s.%04x: ipx->dstNetdatapipx->lengthsizeof(ipx->length)&ipx->lengthipxSizeipxHdrpTypetCtl0x85be0x05530x04560x04550x04530x04520x0451ENABLE_SMB/* take length from ipx header *//*
 * Print IPX datagram packets.
 *//* source socket *//* source node *//* source net *//* destination socket *//* destination node *//* destination net *//* Packet Type (i.e. level 2 protocol) *//* Transport Control (i.e. hop count) *//* Length, in bytes, including header *//* Checksum *//* IPX transport header *//* Cisco EIGRP over IPX *//* NWLink datagram, may contain SMB *//* well-known sockets *//* \summary: Novell IPX printer *//*
 * Copyright (c) 1994, 1995, 1996
 *	The Regents of the University of California.  All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that: (1) source code distributions
 * retain the above copyright notice and this paragraph in its entirety, (2)
 * distributions including binary code include the above copyright notice and
 * this paragraph in its entirety in the documentation or other materials
 * provided with the distribution, and (3) all advertising materials mentioning
 * features or use of this software display the following acknowledgement:
 * ``This product includes software developed by the University of California,
 * Lawrence Berkeley Laboratory and its contributors.'' Neither the name of
 * the University nor the names of its contributors may be used to endorse
 * or promote products derived from this software without specific prior
 * written permission.
 * THIS SOFTWARE IS PROVIDED ``AS IS'' AND WITHOUT ANY EXPRESS OR IMPLIED
 * WARRANTIES, INCLUDING, WITHOUT LIMITATION, THE IMPLIED WARRANTIES OF
 * MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE.
 *
 * Contributed by Brad Parker (brad@fcr.com).
 *//Users/owura/Repos/codeql_eval/proj_repos/the-tcpdump-group-tcpdump-commit-9ba91381954ad325ea4fd26b9c65a8bd9a2a85b6/tcpdump/print-isakmp.cisakmp_rfc3948_print(ndo, "isakmp-nat-keep-alive")isakmp-nat-keep-alivebp[3]sizeof(bp[3])(ndo, "NONESP-encap: ")NONESP-encap: (ndo, "UDP-encap: ")UDP-encap: (ndo,"[|isakmp]")[|isakmp]isakmp_printconst isakmpconst isakmp *isakmp *majorminor&basesizeof(base)(ndo,"isakmp")isakmpISAKMP_VERS_MAJORISAKMP_VERS_MAJOR_SHIFTISAKMP_VERS_MINORISAKMP_VERS_MINOR_SHIFT(ndo," %d.%d", major, minor) %d.%d(ndo," msgid ") msgid msgid_t *sizeof(base.msgid)(ndo," cookie ")(ndo,"->") cookie cookie_t *sizeof(base.i_ck)->sizeof(base.r_ck)IKEv1_MAJOR_VERSIONIKEv2_MAJOR_VERSIONikev2_printphasebase->msgid(ndo, " parent_sa")(ndo, " child_sa ") parent_sa child_sa (ndo, " %s", ETYPESTR(base->etype))(ndo, " %s", (((base->etype) < sizeof(etypestr)/sizeof(etypestr[0]) && etypestr[(base->etype)]) ? etypestr[(base->etype)] : numstr(base->etype)))base->etypeetypestrconst char *[38]char *[38](ndo, "[%s%s%s]", base->flags & ISAKMP_FLAG_I ? "I" : "", base->flags & ISAKMP_FLAG_V ? "V" : "", base->flags & ISAKMP_FLAG_R ? "R" : "")(ndo, "[%s%s%s]", base->flags & (1 << 3) ? "I" : "", base->flags & (1 << 4) ? "V" : "", base->flags & (1 << 5) ? "R" : "")[%s%s%s]I(ndo, " [encrypted %s]", NPSTR(base->np))(ndo, " [encrypted %s]", (((base->np) < sizeof(npstr)/sizeof(npstr[0]) && npstr[(base->np)]) ? npstr[(base->np)] : numstr(base->np)))base->npnpstrp + 1(ndo," [|%s]", NPSTR(base->np))(ndo," [|%s]", (((base->np) < sizeof(npstr)/sizeof(npstr[0]) && npstr[(base->np)]) ? npstr[(base->np)] : numstr(base->np)))const isakmp_genconst isakmp_gen *isakmp_gen *ISAKMP_FLAG_E [encrypted %s]const char *[49]char *[49]392 [|%s]base->len(ndo, " (len mismatch: isakmp %u/ip %u)", (uint32_t)ntohl(base->len), length)(ndo, " (len mismatch: isakmp %u/ip %u)", (uint32_t)(__builtin_constant_p(base->len) ? ((__uint32_t)((((__uint32_t)(base->len) & 0xff000000U) >> 24) | (((__uint32_t)(base->len) & 0x00ff0000U) >> 8) | (((__uint32_t)(base->len) & 0x0000ff00U) << 8) | (((__uint32_t)(base->len) & 0x000000ffU) << 24))) : _OSSwapInt32(base->len)), length) (len mismatch: isakmp %u/ip %u)ikev2_sub_printe*extsizeof(*ext)&esizeof(e)ntohs(e.len)((__uint16_t)(__builtin_constant_p(e.len) ? ((__uint16_t)((((__uint16_t)(e.len) & 0xff00U) >> 8) | (((__uint16_t)(e.len) & 0x00ffU) << 8))) : _OSSwapInt16(e.len)))e.len(ndo,"\n")(ndo,"    ")(ndo,"(")    (ndo," [|%s]", NPSTR(np))(ndo," [|%s]", (((np) < sizeof(npstr)/sizeof(npstr[0]) && npstr[(np)]) ? npstr[(np)] : numstr(np)))doidepthikev2_sub0_printitem_len(ndo,"%s", NPSTR(np))(ndo,"%s", (((np) < sizeof(npstr)/sizeof(npstr[0]) && npstr[(np)]) ? npstr[(np)] : numstr(np)))ISAKMP_NPTYPE_v2E..(*[49])(..)(ndo," [|isakmp]") [|isakmp]ikev1_print(ndo," phase %d", phase)(ndo," phase %d/others", phase) phase %d phase %d/others(ndo," I")(ndo," ?")(ndo," R")sizeof(base->r_ck) I R(ndo," %s", ETYPESTR(base->etype))(ndo," %s", (((base->etype) < sizeof(etypestr)/sizeof(etypestr[0]) && etypestr[(base->etype)]) ? etypestr[(base->etype)] : numstr(base->etype)))(ndo,"[%s%s]", base->flags & ISAKMP_FLAG_E ? "E" : "", base->flags & ISAKMP_FLAG_C ? "C" : "")(ndo,"[%s%s]", base->flags & 0x01 ? "E" : "", base->flags & 0x02 ? "C" : "")[%s%s](ndo," [encrypted %s]", NPSTR(base->np))(ndo," [encrypted %s]", (((base->np) < sizeof(npstr)/sizeof(npstr[0]) && npstr[(base->np)]) ? npstr[(base->np)] : numstr(base->np)))(ndo," (len mismatch: isakmp %u/ip %u)", (uint32_t)ntohl(base->len), length)(ndo," (len mismatch: isakmp %u/ip %u)", (uint32_t)(__builtin_constant_p(base->len) ? ((__uint32_t)((((__uint32_t)(base->len) & 0xff000000U) >> 24) | (((__uint32_t)(base->len) & 0x00ff0000U) >> 8) | (((__uint32_t)(base->len) & 0x0000ff00U) << 8) | (((__uint32_t)(base->len) & 0x000000ffU) << 24))) : _OSSwapInt32(base->len)), length)numstr"#%d", x#%dikev1_sub_printike_sub0_printikev2_eap_printikev2_cp_printikev2_e_printvolatile inttpay(ndo," len=%d", dlen) len=%d(ndo," [|%s]", NPSTR(tpay))(ndo," [|%s]", (((tpay) < sizeof(npstr)/sizeof(npstr[0]) && npstr[(tpay)]) ? npstr[(tpay)] : numstr(tpay)))ikev2_TS_printikev2_vid_printvid(ndo," len=%d vid=", ntohs(e.len) - 4)(ndo," len=%d vid=", ((__uint16_t)(__builtin_constant_p(e.len) ? ((__uint16_t)((((__uint16_t)(e.len) & 0xff00U) >> 8) | (((__uint16_t)(e.len) & 0x00ffU) << 8))) : _OSSwapInt16(e.len))) - 4) len=%d vid=*vidvid[i](ndo, "%c", vid[i])ikev2_d_printikev2_n_printconst ikev2_nconst ikev2_n *ikev2_n *showspishowsomedatanotify_name&nsizeof(n)ISAKMP_NPTYPE_N(ndo," prot_id=%s", PROTOIDSTR(n.prot_id))(ndo," prot_id=%s", (((n.prot_id) < sizeof(protoidstr)/sizeof(protoidstr[0]) && protoidstr[(n.prot_id)]) ? protoidstr[(n.prot_id)] : numstr(n.prot_id))) prot_id=%sn.prot_idprotoidstrn.typeIV2_NOTIFY_UNSUPPORTED_CRITICAL_PAYLOADunsupported_critical_payload"unsupported_critical_payload"IV2_NOTIFY_INVALID_IKE_SPIinvalid_ike_spi"invalid_ike_spi"IV2_NOTIFY_INVALID_MAJOR_VERSIONinvalid_major_version"invalid_major_version"IV2_NOTIFY_INVALID_SYNTAXinvalid_syntax"invalid_syntax"IV2_NOTIFY_INVALID_MESSAGE_IDinvalid_message_id"invalid_message_id"IV2_NOTIFY_INVALID_SPIinvalid_spi"invalid_spi"IV2_NOTIFY_NO_PROPOSAL_CHOSENno_protocol_chosen"no_protocol_chosen"IV2_NOTIFY_INVALID_KE_PAYLOADinvalid_ke_payload"invalid_ke_payload"IV2_NOTIFY_AUTHENTICATION_FAILEDauthentication_failed"authentication_failed"IV2_NOTIFY_SINGLE_PAIR_REQUIREDsingle_pair_required"single_pair_required"IV2_NOTIFY_NO_ADDITIONAL_SASno_additional_sas"no_additional_sas"IV2_NOTIFY_INTERNAL_ADDRESS_FAILUREinternal_address_failure"internal_address_failure"IV2_NOTIFY_FAILED_CP_REQUIREDfailed:cp_required"failed:cp_required"IV2_NOTIFY_INVALID_SELECTORSinvalid_selectors"invalid_selectors"IV2_NOTIFY_INITIAL_CONTACTinitial_contact"initial_contact"16385IV2_NOTIFY_SET_WINDOW_SIZEset_window_size"set_window_size"16386IV2_NOTIFY_ADDITIONAL_TS_POSSIBLEadditional_ts_possible"additional_ts_possible"16387IV2_NOTIFY_IPCOMP_SUPPORTEDipcomp_supported"ipcomp_supported"IV2_NOTIFY_NAT_DETECTION_SOURCE_IPnat_detection_source_ip"nat_detection_source_ip"16389IV2_NOTIFY_NAT_DETECTION_DESTINATION_IPnat_detection_destination_ip"nat_detection_destination_ip"16390IV2_NOTIFY_COOKIEcookie"cookie"16391IV2_NOTIFY_USE_TRANSPORT_MODEuse_transport_mode"use_transport_mode"16392IV2_NOTIFY_HTTP_CERT_LOOKUP_SUPPORTEDhttp_cert_lookup_supported"http_cert_lookup_supported"16393IV2_NOTIFY_REKEY_SArekey_sa"rekey_sa"16394IV2_NOTIFY_ESP_TFC_PADDING_NOT_SUPPORTEDtfc_padding_not_supported"tfc_padding_not_supported"16395IV2_NOTIFY_NON_FIRST_FRAGMENTS_ALSOnon_first_fragment_also"non_first_fragment_also""error"private-error"private-error""status"private-status"private-status"(ndo," type=%u(%s)", type, notify_name) type=%u(%s)(ndo," spi=") spi=(ndo," data=(") data=((ndo," [|%s]", NPSTR(ISAKMP_NPTYPE_N))(ndo," [|%s]", (((11) < sizeof(npstr)/sizeof(npstr[0]) && npstr[(11)]) ? npstr[(11)] : numstr(11)))ikev2_nonce_print"nonce"(ndo," len=%d", ntohs(e.len) - 4)(ndo," len=%d", ((__uint16_t)(__builtin_constant_p(e.len) ? ((__uint16_t)((((__uint16_t)(e.len) & 0xff00U) >> 8) | (((__uint16_t)(e.len) & 0x00ffU) << 8))) : _OSSwapInt16(e.len))) - 4)(ndo," nonce=(")(ndo,") ") nonce=(ikev2_auth_printv2_authrsasig"rsasig"shared-secret"shared-secret"dsssig"dsssig"authdataikev2_auth *a.h.len(ndo," len=%u method=%s", len-4, STR_OR_ID(a.auth_method, v2_auth))(ndo," len=%u method=%s", len-4, (((a.auth_method) < sizeof(v2_auth)/sizeof(v2_auth[0]) && v2_auth[(a.auth_method)]) ? v2_auth[(a.auth_method)] : numstr(a.auth_method))) len=%u method=%sa.auth_method(ndo, " authdata=(") authdata=(ikev2_cr_printikev2_cert_printikev2_ID_printconst ikev2_idconst ikev2_id *ikev2_id *id_lenidtype_lendumpasciidumphextypedata&idsizeof(id)id.h.len(ndo," len=%d", id_len - 4)sizeof(struct ikev2_id)(ndo, " ipv4:")(ndo, " fqdn:")(ndo, " rfc822:")(ndo, " ipv6:")(ndo, " dn:")(ndo, " gn:")(ndo, " keyid:")ID_IPV4_ADDR ipv4:ID_FQDN fqdn:ID_RFC822_ADDR rfc822:ID_IPV6_ADDR ipv6:ID_DER_ASN1_DN dn:ID_DER_ASN1_GN gn:ID_KEY_ID keyid:*typedatatypedata[i](ndo, "%c", typedata[i])ikev2_ke_printkeconst ikev2_keconst ikev2_ke *ikev2_ke **ksizeof(*k)&kesizeof(ke)(ndo," len=%u group=%s", ntohs(ke.h.len) - 8, STR_OR_ID(ntohs(ke.ke_group), dh_p_map))(ndo," len=%u group=%s", ((__uint16_t)(__builtin_constant_p(ke.h.len) ? ((__uint16_t)((((__uint16_t)(ke.h.len) & 0xff00U) >> 8) | (((__uint16_t)(ke.h.len) & 0x00ffU) << 8))) : _OSSwapInt16(ke.h.len))) - 8, (((((__uint16_t)(__builtin_constant_p(ke.ke_group) ? ((__uint16_t)((((__uint16_t)(ke.ke_group) & 0xff00U) >> 8) | (((__uint16_t)(ke.ke_group) & 0x00ffU) << 8))) : _OSSwapInt16(ke.ke_group)))) < sizeof(dh_p_map)/sizeof(dh_p_map[0]) && dh_p_map[(((__uint16_t)(__builtin_constant_p(ke.ke_group) ? ((__uint16_t)((((__uint16_t)(ke.ke_group) & 0xff00U) >> 8) | (((__uint16_t)(ke.ke_group) & 0x00ffU) << 8))) : _OSSwapInt16(ke.ke_group))))]) ? dh_p_map[(((__uint16_t)(__builtin_constant_p(ke.ke_group) ? ((__uint16_t)((((__uint16_t)(ke.ke_group) & 0xff00U) >> 8) | (((__uint16_t)(ke.ke_group) & 0x00ffU) << 8))) : _OSSwapInt16(ke.ke_group))))] : numstr(((__uint16_t)(__builtin_constant_p(ke.ke_group) ? ((__uint16_t)((((__uint16_t)(ke.ke_group) & 0xff00U) >> 8) | (((__uint16_t)(ke.ke_group) & 0x00ffU) << 8))) : _OSSwapInt16(ke.ke_group)))))) len=%u group=%ske.h.lenke.ke_groupntohs(ke.ke_group)((__uint16_t)(__builtin_constant_p(ke.ke_group) ? ((__uint16_t)((((__uint16_t)(ke.ke_group) & 0xff00U) >> 8) | (((__uint16_t)(ke.ke_group) & 0x00ffU) << 8))) : _OSSwapInt16(ke.ke_group)))dh_p_mapconst char *[19]char *[19]ikev2_sa_printsa_lengthpcount*ext1sizeof(*ext1)ext1"sa"(ndo," len=%d", sa_length)(ndo, "%s", NPSTR(np))(ndo, "%s", (((np) < sizeof(npstr)/sizeof(npstr[0]) && npstr[(np)]) ? npstr[(np)] : numstr(np)))ISAKMP_NPTYPE_Posa_lengthtoolongikev2_p_printconst ikev2_pconst ikev2_p *ikev2_p *propprop_lengthtcount&propsizeof(prop)(ndo," #%u protoid=%s transform=%d len=%u", prop.p_no, PROTOIDSTR(prop.prot_id), prop.num_t, oprop_length)(ndo," #%u protoid=%s transform=%d len=%u", prop.p_no, (((prop.prot_id) < sizeof(protoidstr)/sizeof(protoidstr[0]) && protoidstr[(prop.prot_id)]) ? protoidstr[(prop.prot_id)] : numstr(prop.prot_id)), prop.num_t, oprop_length) #%u protoid=%s transform=%d len=%uprop.prot_idISAKMP_NPTYPE_T(ndo," [|%s]", NPSTR(ISAKMP_NPTYPE_P))(ndo," [|%s]", (((2) < sizeof(npstr)/sizeof(npstr[0]) && npstr[(2)]) ? npstr[(2)] : numstr(2)))oprop_lengthikev2_t_printconst ikev2_tconst ikev2_t *ikev2_t *t_ididstrconst attrmapconst attrmap *attrmap *mapnmapep2&tsizeof(t)t.t_idesp_p_mapprf_p_mapinteg_p_mapesn_p_mapIV2_T_ENCRconst char *[13]char *[13]const attrmap[15]attrmap[15]3840sizeof(encr_t_map)sizeof(encr_t_map[0])sizeof(encr_t_map)/sizeof(encr_t_map[0])IV2_T_PRFIV2_T_INTEGconst char *[6]char *[6]IV2_T_DHIV2_T_ESN(ndo," #%u type=%s id=%s ", tcount, STR_OR_ID(t.t_type, ikev2_t_type_map), idstr)(ndo," #%u type=%s id=%s ", tcount, (((t.t_type) < sizeof(ikev2_t_type_map)/sizeof(ikev2_t_type_map[0]) && ikev2_t_type_map[(t.t_type)]) ? ikev2_t_type_map[(t.t_type)] : numstr(t.t_type)), idstr)t.t_typeikev2_t_type_map(ndo," #%u type=%s id=%u ", tcount, STR_OR_ID(t.t_type, ikev2_t_type_map), t.t_id)(ndo," #%u type=%s id=%u ", tcount, (((t.t_type) < sizeof(ikev2_t_type_map)/sizeof(ikev2_t_type_map[0]) && ikev2_t_type_map[(t.t_type)]) ? ikev2_t_type_map[(t.t_type)] : numstr(t.t_type)), t.t_id) #%u type=%s id=%s  #%u type=%s id=%u (ndo,"...")...(ndo," [|%s]", NPSTR(ISAKMP_NPTYPE_T))(ndo," [|%s]", (((3) < sizeof(npstr)/sizeof(npstr[0]) && npstr[(3)]) ? npstr[(3)] : numstr(3)))ikev2_gen_printikev2_pay_print(ndo,"%s%s:", payname, critical&0x80 ? "[C]" : "")%s%s:[C]ikev1_vid_print(ndo,"%s:", NPSTR(ISAKMP_NPTYPE_VID))(ndo,"%s:", (((13) < sizeof(npstr)/sizeof(npstr[0]) && npstr[(13)]) ? npstr[(13)] : numstr(13)))%s:ISAKMP_NPTYPE_VID(ndo," [|%s]", NPSTR(ISAKMP_NPTYPE_VID))(ndo," [|%s]", (((13) < sizeof(npstr)/sizeof(npstr[0]) && npstr[(13)]) ? npstr[(13)] : numstr(13)))ikev1_d_printconst ikev1_pl_dconst ikev1_pl_d *ikev1_pl_d *(ndo,"%s:", NPSTR(ISAKMP_NPTYPE_D))(ndo,"%s:", (((12) < sizeof(npstr)/sizeof(npstr[0]) && npstr[(12)]) ? npstr[(12)] : numstr(12)))ISAKMP_NPTYPE_D&dsizeof(d)d.doi(ndo," doi=%u", doi)(ndo," proto=%u", proto)(ndo," doi=ipsec")(ndo," proto=%s", PROTOIDSTR(proto))(ndo," proto=%s", (((proto) < sizeof(protoidstr)/sizeof(protoidstr[0]) && protoidstr[(proto)]) ? protoidstr[(proto)] : numstr(proto))) doi=%u proto=%u doi=ipsec proto=%s(ndo," spilen=%u", d.spi_size) spilen=%u(ndo," nspi=%u", ntohs(d.num_spi))(ndo," nspi=%u", ((__uint16_t)(__builtin_constant_p(d.num_spi) ? ((__uint16_t)((((__uint16_t)(d.num_spi) & 0xff00U) >> 8) | (((__uint16_t)(d.num_spi) & 0x00ffU) << 8))) : _OSSwapInt16(d.num_spi)))) nspi=%upaynamecriticaldoi0proto0d.num_spi(ndo,",")(ndo," [|%s]", NPSTR(ISAKMP_NPTYPE_D))(ndo," [|%s]", (((12) < sizeof(npstr)/sizeof(npstr[0]) && npstr[(12)]) ? npstr[(12)] : numstr(12)))ikev1_n_printconst ikev1_pl_nconst ikev1_pl_n *ikev1_pl_n *notify_error_stripsec_notify_error_strnotify_status_stripsec_notify_status_str(ndo,"%s:", NPSTR(ISAKMP_NPTYPE_N))(ndo,"%s:", (((11) < sizeof(npstr)/sizeof(npstr[0]) && npstr[(11)]) ? npstr[(11)] : numstr(11)))n.doi(ndo," doi=%d", doi)(ndo," proto=%d", proto)(ndo," type=%s", NOTIFY_ERROR_STR(ntohs(n.type)))(ndo," type=%s", ((((((__uint16_t)(__builtin_constant_p(n.type) ? ((__uint16_t)((((__uint16_t)(n.type) & 0xff00U) >> 8) | (((__uint16_t)(n.type) & 0x00ffU) << 8))) : _OSSwapInt16(n.type))))) < sizeof(notify_error_str)/sizeof(notify_error_str[0]) && notify_error_str[((((__uint16_t)(__builtin_constant_p(n.type) ? ((__uint16_t)((((__uint16_t)(n.type) & 0xff00U) >> 8) | (((__uint16_t)(n.type) & 0x00ffU) << 8))) : _OSSwapInt16(n.type)))))]) ? notify_error_str[((((__uint16_t)(__builtin_constant_p(n.type) ? ((__uint16_t)((((__uint16_t)(n.type) & 0xff00U) >> 8) | (((__uint16_t)(n.type) & 0x00ffU) << 8))) : _OSSwapInt16(n.type)))))] : numstr((((__uint16_t)(__builtin_constant_p(n.type) ? ((__uint16_t)((((__uint16_t)(n.type) & 0xff00U) >> 8) | (((__uint16_t)(n.type) & 0x00ffU) << 8))) : _OSSwapInt16(n.type)))))))ntohs(n.type)((__uint16_t)(__builtin_constant_p(n.type) ? ((__uint16_t)((((__uint16_t)(n.type) & 0xff00U) >> 8) | (((__uint16_t)(n.type) & 0x00ffU) << 8))) : _OSSwapInt16(n.type)))(((__uint16_t)(__builtin_constant_p(n.type) ? ((__uint16_t)((((__uint16_t)(n.type) & 0xff00U) >> 8) | (((__uint16_t)(n.type) & 0x00ffU) << 8))) : _OSSwapInt16(n.type))))(ndo," type=%s", numstr(ntohs(n.type)))(ndo," type=%s", numstr(((__uint16_t)(__builtin_constant_p(n.type) ? ((__uint16_t)((((__uint16_t)(n.type) & 0xff00U) >> 8) | (((__uint16_t)(n.type) & 0x00ffU) << 8))) : _OSSwapInt16(n.type)))))(ndo," type=%s", NOTIFY_STATUS_STR(ntohs(n.type)))(ndo," type=%s", ((((u_int)((((__uint16_t)(__builtin_constant_p(n.type) ? ((__uint16_t)((((__uint16_t)(n.type) & 0xff00U) >> 8) | (((__uint16_t)(n.type) & 0x00ffU) << 8))) : _OSSwapInt16(n.type)))) - 16384)) < sizeof(notify_status_str)/sizeof(notify_status_str[0]) && notify_status_str[((u_int)((((__uint16_t)(__builtin_constant_p(n.type) ? ((__uint16_t)((((__uint16_t)(n.type) & 0xff00U) >> 8) | (((__uint16_t)(n.type) & 0x00ffU) << 8))) : _OSSwapInt16(n.type)))) - 16384))]) ? notify_status_str[((u_int)((((__uint16_t)(__builtin_constant_p(n.type) ? ((__uint16_t)((((__uint16_t)(n.type) & 0xff00U) >> 8) | (((__uint16_t)(n.type) & 0x00ffU) << 8))) : _OSSwapInt16(n.type)))) - 16384))] : numstr((u_int)((((__uint16_t)(__builtin_constant_p(n.type) ? ((__uint16_t)((((__uint16_t)(n.type) & 0xff00U) >> 8) | (((__uint16_t)(n.type) & 0x00ffU) << 8))) : _OSSwapInt16(n.type)))) - 16384))))(u_int)((((__uint16_t)(__builtin_constant_p(n.type) ? ((__uint16_t)((((__uint16_t)(n.type) & 0xff00U) >> 8) | (((__uint16_t)(n.type) & 0x00ffU) << 8))) : _OSSwapInt16(n.type)))) - 16384) doi=%d proto=%d type=%sconst char *[31]char *[31]24576const char *[1]char *[1](ndo," type=%s", IPSEC_NOTIFY_ERROR_STR(ntohs(n.type)))(ndo," type=%s", ((((u_int)((((__uint16_t)(__builtin_constant_p(n.type) ? ((__uint16_t)((((__uint16_t)(n.type) & 0xff00U) >> 8) | (((__uint16_t)(n.type) & 0x00ffU) << 8))) : _OSSwapInt16(n.type)))) - 8192)) < sizeof(ipsec_notify_error_str)/sizeof(ipsec_notify_error_str[0]) && ipsec_notify_error_str[((u_int)((((__uint16_t)(__builtin_constant_p(n.type) ? ((__uint16_t)((((__uint16_t)(n.type) & 0xff00U) >> 8) | (((__uint16_t)(n.type) & 0x00ffU) << 8))) : _OSSwapInt16(n.type)))) - 8192))]) ? ipsec_notify_error_str[((u_int)((((__uint16_t)(__builtin_constant_p(n.type) ? ((__uint16_t)((((__uint16_t)(n.type) & 0xff00U) >> 8) | (((__uint16_t)(n.type) & 0x00ffU) << 8))) : _OSSwapInt16(n.type)))) - 8192))] : numstr((u_int)((((__uint16_t)(__builtin_constant_p(n.type) ? ((__uint16_t)((((__uint16_t)(n.type) & 0xff00U) >> 8) | (((__uint16_t)(n.type) & 0x00ffU) << 8))) : _OSSwapInt16(n.type)))) - 8192))))(u_int)((((__uint16_t)(__builtin_constant_p(n.type) ? ((__uint16_t)((((__uint16_t)(n.type) & 0xff00U) >> 8) | (((__uint16_t)(n.type) & 0x00ffU) << 8))) : _OSSwapInt16(n.type)))) - 8192)(ndo," type=%s", IPSEC_NOTIFY_STATUS_STR(ntohs(n.type)))(ndo," type=%s", ((((u_int)((((__uint16_t)(__builtin_constant_p(n.type) ? ((__uint16_t)((((__uint16_t)(n.type) & 0xff00U) >> 8) | (((__uint16_t)(n.type) & 0x00ffU) << 8))) : _OSSwapInt16(n.type)))) - 24576)) < sizeof(ipsec_notify_status_str)/sizeof(ipsec_notify_status_str[0]) && ipsec_notify_status_str[((u_int)((((__uint16_t)(__builtin_constant_p(n.type) ? ((__uint16_t)((((__uint16_t)(n.type) & 0xff00U) >> 8) | (((__uint16_t)(n.type) & 0x00ffU) << 8))) : _OSSwapInt16(n.type)))) - 24576))]) ? ipsec_notify_status_str[((u_int)((((__uint16_t)(__builtin_constant_p(n.type) ? ((__uint16_t)((((__uint16_t)(n.type) & 0xff00U) >> 8) | (((__uint16_t)(n.type) & 0x00ffU) << 8))) : _OSSwapInt16(n.type)))) - 24576))] : numstr((u_int)((((__uint16_t)(__builtin_constant_p(n.type) ? ((__uint16_t)((((__uint16_t)(n.type) & 0xff00U) >> 8) | (((__uint16_t)(n.type) & 0x00ffU) << 8))) : _OSSwapInt16(n.type)))) - 24576))))(u_int)((((__uint16_t)(__builtin_constant_p(n.type) ? ((__uint16_t)((((__uint16_t)(n.type) & 0xff00U) >> 8) | (((__uint16_t)(n.type) & 0x00ffU) << 8))) : _OSSwapInt16(n.type)))) - 24576)(ndo," attrs=(")(ndo," status=(")*(cp)(ndo,"replay detection %sabled", EXTRACT_32BITS(cp) ? "en" : "dis")(ndo,"replay detection %sabled", ((uint32_t)(((uint32_t)(*((const uint8_t *)(cp) + 0)) << 24) | ((uint32_t)(*((const uint8_t *)(cp) + 1)) << 16) | ((uint32_t)(*((const uint8_t *)(cp) + 2)) << 8) | ((uint32_t)(*((const uint8_t *)(cp) + 3)) << 0))) ? "en" : "dis")IPSECDOI_NTYPE_RESPONDER_LIFETIMEconst attrmap[17]attrmap[17]4352sizeof(oakley_t_map)sizeof(oakley_t_map[0])sizeof(oakley_t_map)/sizeof(oakley_t_map[0]) attrs=(IPSECDOI_NTYPE_REPLAY_STATUS status=(replay detection %sabledendisRESPONDER-LIFETIME"RESPONDER-LIFETIME"REPLAY-STATUS"REPLAY-STATUS"INITIAL-CONTACT"INITIAL-CONTACT"CONNECTED"CONNECTED"RESERVED"RESERVED"INVALID-PAYLOAD-TYPE"INVALID-PAYLOAD-TYPE"DOI-NOT-SUPPORTED"DOI-NOT-SUPPORTED"SITUATION-NOT-SUPPORTED"SITUATION-NOT-SUPPORTED"INVALID-COOKIE"INVALID-COOKIE"INVALID-MAJOR-VERSION"INVALID-MAJOR-VERSION"INVALID-MINOR-VERSION"INVALID-MINOR-VERSION"INVALID-EXCHANGE-TYPE"INVALID-EXCHANGE-TYPE"INVALID-FLAGS"INVALID-FLAGS"INVALID-MESSAGE-ID"INVALID-MESSAGE-ID"INVALID-PROTOCOL-ID"INVALID-PROTOCOL-ID"INVALID-SPI"INVALID-SPI"INVALID-TRANSFORM-ID"INVALID-TRANSFORM-ID"ATTRIBUTES-NOT-SUPPORTED"ATTRIBUTES-NOT-SUPPORTED"NO-PROPOSAL-CHOSEN"NO-PROPOSAL-CHOSEN"BAD-PROPOSAL-SYNTAX"BAD-PROPOSAL-SYNTAX"PAYLOAD-MALFORMED"PAYLOAD-MALFORMED"INVALID-KEY-INFORMATION"INVALID-KEY-INFORMATION"INVALID-ID-INFORMATION"INVALID-ID-INFORMATION"INVALID-CERT-ENCODING"INVALID-CERT-ENCODING"INVALID-CERTIFICATE"INVALID-CERTIFICATE"CERT-TYPE-UNSUPPORTED"CERT-TYPE-UNSUPPORTED"INVALID-CERT-AUTHORITY"INVALID-CERT-AUTHORITY"INVALID-HASH-INFORMATION"INVALID-HASH-INFORMATION"AUTHENTICATION-FAILED"AUTHENTICATION-FAILED"INVALID-SIGNATURE"INVALID-SIGNATURE"ADDRESS-NOTIFICATION"ADDRESS-NOTIFICATION"NOTIFY-SA-LIFETIME"NOTIFY-SA-LIFETIME"CERTIFICATE-UNAVAILABLE"CERTIFICATE-UNAVAILABLE"UNSUPPORTED-EXCHANGE-TYPE"UNSUPPORTED-EXCHANGE-TYPE"UNEQUAL-PAYLOAD-LENGTHS"UNEQUAL-PAYLOAD-LENGTHS"ikev1_nonce_print(ndo,"%s:", NPSTR(ISAKMP_NPTYPE_NONCE))(ndo,"%s:", (((10) < sizeof(npstr)/sizeof(npstr[0]) && npstr[(10)]) ? npstr[(10)] : numstr(10)))ISAKMP_NPTYPE_NONCE(ndo," n len=%u", ntohs(e.len) - 4)(ndo," n len=%u", ((__uint16_t)(__builtin_constant_p(e.len) ? ((__uint16_t)((((__uint16_t)(e.len) & 0xff00U) >> 8) | (((__uint16_t)(e.len) & 0x00ffU) << 8))) : _OSSwapInt16(e.len))) - 4) n len=%u(ndo," [|%s]", NPSTR(ISAKMP_NPTYPE_NONCE))(ndo," [|%s]", (((10) < sizeof(npstr)/sizeof(npstr[0]) && npstr[(10)]) ? npstr[(10)] : numstr(10)))ikev1_sig_print(ndo,"%s:", NPSTR(ISAKMP_NPTYPE_SIG))(ndo,"%s:", (((9) < sizeof(npstr)/sizeof(npstr[0]) && npstr[(9)]) ? npstr[(9)] : numstr(9)))ISAKMP_NPTYPE_SIG(ndo," [|%s]", NPSTR(ISAKMP_NPTYPE_SIG))(ndo," [|%s]", (((9) < sizeof(npstr)/sizeof(npstr[0]) && npstr[(9)]) ? npstr[(9)] : numstr(9)))ikev1_hash_print(ndo,"%s:", NPSTR(ISAKMP_NPTYPE_HASH))(ndo,"%s:", (((8) < sizeof(npstr)/sizeof(npstr[0]) && npstr[(8)]) ? npstr[(8)] : numstr(8)))ISAKMP_NPTYPE_HASH(ndo," [|%s]", NPSTR(ISAKMP_NPTYPE_HASH))(ndo," [|%s]", (((8) < sizeof(npstr)/sizeof(npstr[0]) && npstr[(8)]) ? npstr[(8)] : numstr(8)))ikev1_cr_printconst ikev1_pl_certconst ikev1_pl_cert *ikev1_pl_cert *certcertstr(ndo,"%s:", NPSTR(ISAKMP_NPTYPE_CR))(ndo,"%s:", (((7) < sizeof(npstr)/sizeof(npstr[0]) && npstr[(7)]) ? npstr[(7)] : numstr(7)))ISAKMP_NPTYPE_CR&certsizeof(cert)(ndo," len=%d", item_len - 4)(ndo," type=%s", STR_OR_ID((cert.encode), certstr))(ndo," type=%s", ((((cert.encode)) < sizeof(certstr)/sizeof(certstr[0]) && certstr[((cert.encode))]) ? certstr[((cert.encode))] : numstr((cert.encode))))(cert.encode)const char *[11]char *[11](ndo," [|%s]", NPSTR(ISAKMP_NPTYPE_CR))(ndo," [|%s]", (((7) < sizeof(npstr)/sizeof(npstr[0]) && npstr[(7)]) ? npstr[(7)] : numstr(7)))"none"pkcs7"pkcs7"pgp"pgp"dns"dns"x509sign"x509sign"x509ke"x509ke"kerberos"kerberos"crl"crl"arl"arl"spki"spki"x509attr"x509attr"ikev1_cert_print(ndo,"%s:", NPSTR(ISAKMP_NPTYPE_CERT))(ndo,"%s:", (((6) < sizeof(npstr)/sizeof(npstr[0]) && npstr[(6)]) ? npstr[(6)] : numstr(6)))ISAKMP_NPTYPE_CERT(ndo," [|%s]", NPSTR(ISAKMP_NPTYPE_CERT))(ndo," [|%s]", (((6) < sizeof(npstr)/sizeof(npstr[0]) && npstr[(6)]) ? npstr[(6)] : numstr(6)))ikev1_id_printconst ikev1_pl_idconst ikev1_pl_id *ikev1_pl_id *idtypestripsecidtypestr(ndo,"%s:", NPSTR(ISAKMP_NPTYPE_ID))(ndo,"%s:", (((5) < sizeof(npstr)/sizeof(npstr[0]) && npstr[(5)]) ? npstr[(5)] : numstr(5)))ISAKMP_NPTYPE_ID(ndo," idtype=%s", STR_OR_ID(id.d.id_type, idtypestr))(ndo," idtype=%s", (((id.d.id_type) < sizeof(idtypestr)/sizeof(idtypestr[0]) && idtypestr[(id.d.id_type)]) ? idtypestr[(id.d.id_type)] : numstr(id.d.id_type)))id.d.id_type(ndo," doi_data=%u", (uint32_t)(ntohl(id.d.doi_data) & 0xffffff))(ndo," doi_data=%u", (uint32_t)((__builtin_constant_p(id.d.doi_data) ? ((__uint32_t)((((__uint32_t)(id.d.doi_data) & 0xff000000U) >> 24) | (((__uint32_t)(id.d.doi_data) & 0x00ff0000U) >> 8) | (((__uint32_t)(id.d.doi_data) & 0x0000ff00U) << 8) | (((__uint32_t)(id.d.doi_data) & 0x000000ffU) << 24))) : _OSSwapInt32(id.d.doi_data)) & 0xffffff))id.d.doi_data*doi_psizeof(*doi_p)&doi_idsizeof(doi_id)(ndo," idtype=%s", STR_OR_ID(doi_id.type, ipsecidtypestr))(ndo," idtype=%s", (((doi_id.type) < sizeof(ipsecidtypestr)/sizeof(ipsecidtypestr[0]) && ipsecidtypestr[(doi_id.type)]) ? ipsecidtypestr[(doi_id.type)] : numstr(doi_id.type)))doi_id.type(ndo," protoid=%s", p_name)(ndo," protoid=%u", doi_id.proto_id)(ndo," port=%d", ntohs(doi_id.port))(ndo," port=%d", ((__uint16_t)(__builtin_constant_p(doi_id.port) ? ((__uint16_t)((((__uint16_t)(doi_id.port) & 0xff00U) >> 8) | (((__uint16_t)(doi_id.port) & 0x00ffU) << 8))) : _OSSwapInt16(doi_id.port))))doi_id.port*data(ndo," len=%d [bad: < 4]", len)(ndo," len=%d %s", len, ipaddr_string(ndo, data))(ndo," len=%d %s", len, getname(ndo, (const u_char *)(data)))(ndo," len=%d ", len)(ndo," len=%d [bad: < 8]", len)(ndo," len=%d %s/%u.%u.%u.%u", len, ipaddr_string(ndo, data), mask[0], mask[1], mask[2], mask[3])(ndo," len=%d %s/%u.%u.%u.%u", len, getname(ndo, (const u_char *)(data)), mask[0], mask[1], mask[2], mask[3])(ndo," len=%d [bad: < 16]", len)(ndo," len=%d %s", len, ip6addr_string(ndo, data))(ndo," len=%d %s", len, getname6(ndo, (const u_char *)(data)))(ndo," len=%d [bad: < 32]", len)(ndo," len=%d %s/0x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x", len, ip6addr_string(ndo, data), mask[0], mask[1], mask[2], mask[3], mask[4], mask[5], mask[6], mask[7], mask[8], mask[9], mask[10], mask[11], mask[12], mask[13], mask[14], mask[15])(ndo," len=%d %s/0x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x", len, getname6(ndo, (const u_char *)(data)), mask[0], mask[1], mask[2], mask[3], mask[4], mask[5], mask[6], mask[7], mask[8], mask[9], mask[10], mask[11], mask[12], mask[13], mask[14], mask[15])(ndo," len=%d %s-%s", len, ipaddr_string(ndo, data), ipaddr_string(ndo, data + sizeof(struct in_addr)))(ndo," len=%d %s-%s", len, getname(ndo, (const u_char *)(data)), getname(ndo, (const u_char *)(data + sizeof(struct in_addr))))data + sizeof(struct in_addr)(ndo," len=%d %s-%s", len, ip6addr_string(ndo, data), ip6addr_string(ndo, data + sizeof(struct in6_addr)))(ndo," len=%d %s-%s", len, getname6(ndo, (const u_char *)(data)), getname6(ndo, (const u_char *)(data + sizeof(struct in6_addr))))data + sizeof(struct in6_addr) idtype=%s doi_data=%uconst ipsecdoi_idconst ipsecdoi_id *ipsecdoi_id *doi_pdoi_id protoid=%s protoid=%u port=%dIPSECDOI_ID_IPV4_ADDR len=%d [bad: < 4] len=%d %sIPSECDOI_ID_FQDNIPSECDOI_ID_USER_FQDN len=%d IPSECDOI_ID_IPV4_ADDR_SUBNET len=%d [bad: < 8] len=%d %s/%u.%u.%u.%uIPSECDOI_ID_IPV6_ADDR len=%d [bad: < 16]IPSECDOI_ID_IPV6_ADDR_SUBNET len=%d [bad: < 32] len=%d %s/0x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02xIPSECDOI_ID_IPV4_ADDR_RANGE len=%d %s-%sIPSECDOI_ID_IPV6_ADDR_RANGEIPSECDOI_ID_DER_ASN1_DNIPSECDOI_ID_DER_ASN1_GNIPSECDOI_ID_KEY_ID(ndo," len=%d", len)(ndo," [|%s]", NPSTR(ISAKMP_NPTYPE_ID))(ndo," [|%s]", (((5) < sizeof(npstr)/sizeof(npstr[0]) && npstr[(5)]) ? npstr[(5)] : numstr(5)))FQDN"FQDN"user FQDN"user FQDN"IPv4net"IPv4net"IPv6net"IPv6net"IPv4range"IPv4range"IPv6range"IPv6range"ASN1 DN"ASN1 DN"ASN1 GN"ASN1 GN"keyid"keyid"ikev1_ke_print(ndo,"%s:", NPSTR(ISAKMP_NPTYPE_KE))(ndo,"%s:", (((4) < sizeof(npstr)/sizeof(npstr[0]) && npstr[(4)]) ? npstr[(4)] : numstr(4)))ISAKMP_NPTYPE_KE(ndo," key len=%d", ntohs(e.len) - 4)(ndo," key len=%d", ((__uint16_t)(__builtin_constant_p(e.len) ? ((__uint16_t)((((__uint16_t)(e.len) & 0xff00U) >> 8) | (((__uint16_t)(e.len) & 0x00ffU) << 8))) : _OSSwapInt16(e.len))) - 4) key len=%d(ndo," [|%s]", NPSTR(ISAKMP_NPTYPE_KE))(ndo," [|%s]", (((4) < sizeof(npstr)/sizeof(npstr[0]) && npstr[(4)]) ? npstr[(4)] : numstr(4)))ikev1_t_printconst ikev1_pl_tconst ikev1_pl_t *ikev1_pl_t *(ndo,"%s:", NPSTR(ISAKMP_NPTYPE_T))(ndo,"%s:", (((3) < sizeof(npstr)/sizeof(npstr[0]) && npstr[(3)]) ? npstr[(3)] : numstr(3)))ikev1_p_mapah_p_mapipcomp_p_mapconst attrmap[10]attrmap[10]2560sizeof(ipsec_t_map)sizeof(ipsec_t_map[0])sizeof(ipsec_t_map)/sizeof(ipsec_t_map[0])(ndo," #%d id=%s ", t.t_no, idstr)(ndo," #%d id=%d ", t.t_no, t.t_id) #%d id=%s  #%d id=%d ikev1_p_printconst ikev1_pl_pconst ikev1_pl_p *ikev1_pl_p *(ndo,"%s:", NPSTR(ISAKMP_NPTYPE_P))(ndo,"%s:", (((2) < sizeof(npstr)/sizeof(npstr[0]) && npstr[(2)]) ? npstr[(2)] : numstr(2)))(ndo," #%d protoid=%s transform=%d", prop.p_no, PROTOIDSTR(prop.prot_id), prop.num_t)(ndo," #%d protoid=%s transform=%d", prop.p_no, (((prop.prot_id) < sizeof(protoidstr)/sizeof(protoidstr[0]) && protoidstr[(prop.prot_id)]) ? protoidstr[(prop.prot_id)] : numstr(prop.prot_id)), prop.num_t) #%d protoid=%s transform=%dikev1_sa_printconst ikev1_pl_saconst ikev1_pl_sa *ikev1_pl_sa *sit(ndo,"%s:", NPSTR(ISAKMP_NPTYPE_SA))(ndo,"%s:", (((1) < sizeof(npstr)/sizeof(npstr[0]) && npstr[(1)]) ? npstr[(1)] : numstr(1)))ISAKMP_NPTYPE_SA&sasizeof(sa)sa.doisa.sit(ndo," situation=%u", (uint32_t)ntohl(sa.sit))(ndo," situation=%u", (uint32_t)(__builtin_constant_p(sa.sit) ? ((__uint32_t)((((__uint32_t)(sa.sit) & 0xff000000U) >> 24) | (((__uint32_t)(sa.sit) & 0x00ff0000U) >> 8) | (((__uint32_t)(sa.sit) & 0x0000ff00U) << 8) | (((__uint32_t)(sa.sit) & 0x000000ffU) << 24))) : _OSSwapInt32(sa.sit))) situation=%u(ndo," situation=") situation=(ndo,"identity")identity(ndo,"%ssecrecy", t ? "+" : "")%ssecrecy(ndo,"%sintegrity", t ? "+" : "")%sintegrity*(ext + 1)sizeof(ident)&identext + 1(ndo," ident=%u", (uint32_t)ntohl(ident))(ndo," ident=%u", (uint32_t)(__builtin_constant_p(ident) ? ((__uint32_t)((((__uint32_t)(ident) & 0xff000000U) >> 24) | (((__uint32_t)(ident) & 0x00ff0000U) >> 8) | (((__uint32_t)(ident) & 0x0000ff00U) << 8) | (((__uint32_t)(ident) & 0x000000ffU) << 24))) : _OSSwapInt32(ident))) ident=%u(ndo," [|%s]", NPSTR(ISAKMP_NPTYPE_SA))(ndo," [|%s]", (((1) < sizeof(npstr)/sizeof(npstr[0]) && npstr[(1)]) ? npstr[(1)] : numstr(1)))ikev1_attr_printtotlen*(&p[2])(ndo,"[|attr]")[|attr]&p[0]*(&p[0])327670x7fff(ndo,"type=#%d ", t)type=#%d (ndo,"value=")(ndo,"len=%d value=", totlen - 4)value=len=%d value=ikev1_attrmap_print(ndo,"type=%s ", map[t].type)type=%s (ndo,"%s", map[t].value[v])const char *[30]char *[30]const char *constconst char *const *ike_show_somedataendelen 20(ndo, "...")rawprint*lochexprint(ndo,"%02x", p[i] & 0xff)cookie_sidecheck&cookiecache[i].iaddr.in4&cookiecache[i].raddr.in4&cookiecache[i].iaddr.in6&cookiecache[i].raddr.in6struct <unnamed>[20]MAXINITIATORScookie_record&cookiecache[ninitiator].iaddr.in4&cookiecache[ninitiator].raddr.in4&cookiecache[ninitiator].iaddr.in6&cookiecache[ninitiator].raddr.in6&cookiecache[ninitiator].initiatorsizeof(*in)cookie_findiszeroattrmapinaddr_uipsecdoi_idipsecdoi_secrecy_hipsecdoi_saikev2_auth_typeIV2_RSA_SIGIV2_SHAREDIV2_DSS_SIGikev2_authnotify_messagesikev2_n_typeikev2_nikev2_idikev2_id_typeikev2_keikev2_t_typeikev2_tikev2_pisakmp_ph2tabikev1_ph2ikev1_ph1tabikev1_ph1ikev1_pl_dikev1_pl_nikev1_pl_nonceikev1_pl_sigikev1_pl_hashikev1_pl_crikev1_pl_certikev1_pl_idikev1_pl_keikev1_pl_tikev1_pl_pikev1_pl_saisakmp_dataisakmp_genu_char[4]msgid_tcookie_tnvalueraddriaddrinitiatorin4auth_methodmsgspi_sizeprot_idres2res1ke_res1ke_groupt_typenum_tp_noikev1_ph2 *tailheadikev1_ph1 *num_spinum_certencodedoi_dataid_typet_nolorvmsgidr_cki_ckconst attrmap[]attrmap[]enc"enc"1des"1des"idea"idea"blowfish"blowfish"rc5"rc5"3des"3des"cast"cast"aes"aes""hash"md5"md5"sha1"sha1"tiger"tiger"sha2-256"sha2-256"sha2-384"sha2-384"sha2-512"sha2-512"auth"auth"preshared"preshared"dss"dss"rsa sig"rsa sig"rsa enc"rsa enc"rsa enc revised"rsa enc revised"group desc"group desc"modp768"modp768"modp1024"modp1024"EC2N 2^155"EC2N 2^155"EC2N 2^185"EC2N 2^185"modp1536"modp1536"iana-grp06"iana-grp06"iana-grp07"iana-grp07"iana-grp08"iana-grp08"iana-grp09"iana-grp09"iana-grp10"iana-grp10"iana-grp11"iana-grp11"iana-grp12"iana-grp12"iana-grp13"iana-grp13"modp2048"modp2048"modp3072"modp3072"modp4096"modp4096"modp6144"modp6144"modp8192"modp8192"group type"group type"MODP"MODP"ECP"ECP"EC2N"EC2N"group prime"group prime"group gen1"group gen1"group gen2"group gen2"group curve A"group curve A"group curve B"group curve B"lifetype"lifetype""sec"kb"kb"lifeduration"lifeduration"prf"prf"keylen"keylen"field"field"order"order"oakley_t_mapencr_t_maplife"life"enc mode"enc mode"tunnel"tunnel"transport"transport"hmac-md5"hmac-md5"hmac-sha1"hmac-sha1"1des-mac"1des-mac"keyed"keyed"rounds"rounds"dictsize"dictsize"privalg"privalg"ipsec_t_map"oui"deflate"deflate"lzs"lzs"1des-iv64"1des-iv64"3idea"3idea"1des-iv32"1des-iv32"rc4"rc4"null"null"no-esn"no-esn"esn"esn"hmac-sha"hmac-sha"dec-mac"dec-mac"kpdk-md5"kpdk-md5"aes-xcbc"aes-xcbc"hmac-tiger"hmac-tiger"aes128_xcbc"aes128_xcbc"(reserved)"(reserved)"sha"sha"encr"encr"integ"integ""dh"ike"ike""base""ident"agg"agg"inf"inf"oakley-quick"oakley-quick"oakley-newgroup"oakley-newgroup"ikev2_init"ikev2_init""ikev2_auth"child_sa"child_sa"inf2"inf2"npfunc"p""t""ke""id""cert"cr"cr"sig"sig""n""d""vid"pay14"pay14"pay15"pay15"pay16"pay16"pay17"pay17"pay18"pay18"pay19"pay19"pay20"pay20"pay21"pay21"pay22"pay22"pay23"pay23"pay24"pay24"pay25"pay25"pay26"pay26"pay27"pay27"pay28"pay28"pay29"pay29"pay30"pay30"pay31"pay31"pay32"pay32"v2sa"v2sa"v2ke"v2ke"v2IDi"v2IDi"v2IDr"v2IDr"v2cert"v2cert"v2cr"v2cr"v2auth"v2auth"v2nonce"v2nonce"v2n"v2n"v2d"v2d"v2vid"v2vid"v2TSi"v2TSi"v2TSr"v2TSr"v2e"v2e"v2cp"v2cp"v2eap"v2eap""isakmp"ipsec-ah"ipsec-ah"ipsec-esp"ipsec-esp"cookiecacheninitiatorIPSEC_NOTIFY_STATUS_STR(x)STR_OR_ID((u_int)((x) - 24576), ipsec_notify_status_str)NOTIFY_STATUS_STR(x)STR_OR_ID((u_int)((x) - 16384), notify_status_str)IPSEC_NOTIFY_ERROR_STR(x)STR_OR_ID((u_int)((x) - 8192), ipsec_notify_error_str)NOTIFY_ERROR_STR(x)STR_OR_ID((x), notify_error_str)USE_IPSECDOI_IN_PHASE1cookie_isresponder(x,y)cookie_sidecheck((x), (y), 0)cookie_isinitiator(x,y)cookie_sidecheck((x), (y), 1)NPFUNC(x)(((x) < sizeof(npfunc)/sizeof(npfunc[0]) && npfunc[(x)]) ? npfunc[(x)] : NULL)CHECKLEN(p,np)if (ep < (const u_char *)(p)) { ND_PRINT((ndo," [|%s]", NPSTR(np))); goto done; }ETYPESTR(x)STR_OR_ID(x, etypestr)NPSTR(x)STR_OR_ID(x, npstr)PROTOIDSTR(x)STR_OR_ID(x, protoidstr)STR_OR_ID(x,tab)(((x) < sizeof(tab)/sizeof(tab[0]) && tab[(x)]) ? tab[(x)] : numstr(x))DECLARE_PRINTER(func)static const u_char *ike ## func ## _print( netdissect_options *ndo, u_char tpay, const struct isakmp_gen *ext, u_int item_len, const u_char *end_pointer, uint32_t phase, uint32_t doi0, uint32_t proto0, int depth)IPSECDOI_NTYPE_INITIAL_CONTACTIPSECDOI_ATTR_COMP_PRIVALGIPSECDOI_ATTR_COMP_DICT_SIZEIPSECDOI_ATTR_KEY_ROUNDSIPSECDOI_ATTR_KEY_LENGTHIPSECDOI_ATTR_AUTH_KPDKIPSECDOI_ATTR_AUTH_DES_MACIPSECDOI_ATTR_AUTH_HMAC_SHA1IPSECDOI_ATTR_AUTH_HMAC_MD5IPSECDOI_ATTR_AUTHIPSECDOI_ATTR_ENC_MODE_TRNSIPSECDOI_ATTR_ENC_MODE_TUNNELIPSECDOI_ATTR_ENC_MODEIPSECDOI_ATTR_GRP_DESCIPSECDOI_ATTR_SA_LDUR_DEFAULT28800IPSECDOI_ATTR_SA_LDURIPSECDOI_ATTR_SA_LTYPE_KBIPSECDOI_ATTR_SA_LTYPE_SECIPSECDOI_ATTR_SA_LTYPE_DEFAULTIPSECDOI_ATTR_SA_LTYPEIPSECDOI_IPCOMP_LZSIPSECDOI_IPCOMP_DEFLATEIPSECDOI_IPCOMP_OUIIPSECDOI_PROTO_IPCOMPIPSECDOI_ESP_AESIPSECDOI_ESP_RIJNDAELIPSECDOI_ESP_NULLIPSECDOI_ESP_RC4IPSECDOI_ESP_DES_IV32IPSECDOI_ESP_3IDEAIPSECDOI_ESP_BLOWFISHIPSECDOI_ESP_CASTIPSECDOI_ESP_IDEAIPSECDOI_ESP_RC5IPSECDOI_ESP_3DESIPSECDOI_ESP_DESIPSECDOI_ESP_DES_IV64IPSECDOI_PROTO_IPSEC_ESPIPSECDOI_AH_SHA2_512IPSECDOI_AH_SHA2_384IPSECDOI_AH_SHA2_256IPSECDOI_AH_DESIPSECDOI_AH_SHAIPSECDOI_AH_MD5IPSECDOI_PROTO_IPSEC_AHIPSECDOI_KEY_IKEIPSECDOI_PROTO_ISAKMPIPSECDOI_SIT_INTEGRITY0x00000004IPSECDOI_SIT_SECRECYIPSECDOI_SIT_IDENTITY_ONLY0x00000001IPSEC_DOIISAKMP_NTYPE_ADDRESS_NOTIFICATIONISAKMP_NTYPE_INVALID_SIGNATUREISAKMP_NTYPE_AUTHENTICATION_FAILEDISAKMP_NTYPE_INVALID_HASH_INFORMATIONISAKMP_NTYPE_INVALID_CERT_AUTHORITYISAKMP_NTYPE_BAD_CERT_REQUEST_SYNTAXISAKMP_NTYPE_INVALID_CERTIFICATEISAKMP_NTYPE_INVALID_CERT_ENCODINGISAKMP_NTYPE_INVALID_ID_INFORMATIONISAKMP_NTYPE_INVALID_KEY_INFORMATIONISAKMP_NTYPE_PAYLOAD_MALFORMEDISAKMP_NTYPE_BAD_PROPOSAL_SYNTAXISAKMP_NTYPE_NO_PROPOSAL_CHOSENISAKMP_NTYPE_ATTRIBUTES_NOT_SUPPORTEDISAKMP_NTYPE_INVALID_TRANSFORM_IDISAKMP_NTYPE_INVALID_SPIISAKMP_NTYPE_INVALID_PROTOCOL_IDISAKMP_NTYPE_INVALID_MESSAGE_IDISAKMP_NTYPE_INVALID_FLAGSISAKMP_NTYPE_INVALID_EXCHANGE_TYPEISAKMP_NTYPE_INVALID_MINOR_VERSIONISAKMP_NTYPE_INVALID_MAJOR_VERSIONISAKMP_NTYPE_INVALID_COOKIEISAKMP_NTYPE_SITUATION_NOT_SUPPORTEDISAKMP_NTYPE_DOI_NOT_SUPPORTEDISAKMP_NTYPE_INVALID_PAYLOAD_TYPEISAKMP_FLAG_RISAKMP_FLAG_VISAKMP_FLAG_IISAKMP_FLAG_extraISAKMP_FLAG_CIKEv2_MINOR_VERSIONIKEv1_MINOR_VERSIONISAKMP_NPTYPE_NONEPORT_ISAKMPv2_eapv2_cpv2_TSv2_vidv2_dv2_nv2_noncev2_crv2_certv2_IDv2_kev2_sav1_vidv1_dv1_nv1_noncev1_hashv1_sigv1_crv1_certv1_idv1_kev1_tv1_pv1_sa/* must be an ESP packet *//*
	 * see if this is an IKE packet
	 *//* initialize SAs *//*
			 * encrypted, nothing we can do right now.
			 * we hope to decrypt the packet in the future...
			 *//* regardless of phase... *//* Zero-length subitem *//*
		 * XXX - what if item_len is too short, or too long,
		 * for this payload type?
		 *//*
	 * Since we can't have a payload length of less than 4 bytes,
	 * we need to bail out here if the generic header is nonsensical
	 * or truncated, otherwise we could loop forever processing
	 * zero-length items or otherwise misdissect the packet.
	 *//* the first packet *//* always return NULL, because E must be at end, and NP refers
	 * to what was inside.
	 *//* got it decrypted, print stuff inside. *//* try to decypt it! *//* Print the entire payload in hex *//* notify space is annoying sparse *//* notify payloads *//*
	 * Our caller has ensured that the length is >= 4.
	 *//*
	 * Skip the rest of the SA.
	 *//* error, already reported *//*
		 * Since we can't have a payload length of less than 4 bytes,
		 * we need to bail out here if the generic header is nonsensical
		 * or truncated, otherwise we could loop forever processing
		 * zero-length items or otherwise misdissect the packet.
		 *//*
	 * Print the payloads.
	 *//*
	 * ikev2_sub0_print() guarantees that this is >= 4.
	 *//*
	 * Skip the rest of the proposal.
	 *//*
	 * Print the transforms.
	 *//*
	 * ikev2_sa_print() guarantees that this is >= 4.
	 *//************************************************************//*                                                          *//*              IKE v2 - rfc4306 - dissector                *//*
			 * XXX - fill in more types here; see, for example,
			 * draft-ietf-ipsec-notifymsg-04.
			 *//* 24576 - 32767 *//* 16384 - 24575 *//* 8192 - 16383 *//* 0 - 8191 *//* NOTE: these macro must be called with x in proper range *//* A protocol ID of 0 DOES NOT mean IPPROTO_IP! *//*debug*//* group 18 *//* group 17 *//* group 16 *//* group 15 *//* group 14 *//* group 5 *//* group 4 *//* group 3 *//* group 2 *//* 12,13*//* 10,11*//* 8, 9 *//* 6, 7 *//* 4, 5 *//* 2, 3 *//* 0, 1 *//* really shouldn't happen because of above *//* there is too much data, just show some of it *//*
 * returns false if we run out of data buffer
 *//* record initiator *//* find cookie from initiator cache *//* 34-37 *//* IKEv2 exchange types *//* 32-33 *//* 24-31 *//* 16-23 *//*  8-15 *//* 0-7 *//* IKEv1 exchange types *//* isakmp->etype *//* 46 - special *//* ikev2_e_print,*//* 29- 32 *//* 24- 28 *//* 19- 23 *//* 14- 18 *//* isakmp->np *//* 43- 47 *//* 38- 42 *//* 33- 37 *//* 9 - 13 *//* 0 - 8 *//* protocol id *//* Notify Messages - Status Types *//* 4.6.3 IPSEC DOI Notify Message Types *//* Identification Data *//* Port *//* Protocol ID *//* ID Type *//* 4.6.2.1 Identification Type Values *//* Situation *//* Domain of Interpretation *//* 4.6.1 Security Association Payload *//* V *//* B *//*
	 * When negotiating ESP without authentication, the Auth
	 * Algorithm attribute MUST NOT be included in the proposal.
	 * When negotiating ESP without confidentiality, the Auth
	 * Algorithm attribute MUST be included in the proposal and
	 * the ESP transform ID must be ESP_NULL.
	*//*RFC-1826(Key/Pad/Data/Key)*//* 0 means not to use authentication. *//* default value: host dependent *//* 8 hours *//* 4.5 IPSEC Security Association Attributes *//* 4.4.5 IPSEC IPCOMP Transform Identifiers *//* 4.4.1 IPSEC Security Protocol Identifiers *//* 4.4.4 IPSEC ESP Transform Identifiers *//* 4.4.3 IPSEC AH Transform Values *//* 4.4.2 IPSEC ISAKMP Transform Values *//* 4.2 IPSEC Situation Definition *//* refer to RFC 2407 *//* life duration *//* type of duration of lifetime *//* type of cipher *//* type of hash *//* type of prf *//* method of authentication *//* DH; group *//* spi *//* OAKLEY *//* isakmp sa structure *//* refer to RFC 2409 *//* authentication data *//* Protocol-ID *//* 3.8 Authentication Payload *//* Notify Message Type *//* SPI Size *//* 3.10 Notification Payload *//* Notification Data *//* SPI *//* ID type *//* 3.5.  Identification Payloads *//* KE data *//* 3.4.  Key Exchange Payload *//* Transform ID *//* reserved byte *//* Transform Type (ENCR,PRF,INTEG,etc.*//* 3.3.2.  Transform Substructure *//* Number of Transforms *//* Protocol *//* Proposal # *//* 3.3.1.  Proposal Substructure *//* 3.3  Security Association Payload -- generic header *//* IKEv2 (RFC4306) *//* SPI(es) *//* # of SPIs *//* Protocol-Id *//* 3.15 Delete Payload *//* NOTIFY MESSAGES - ERROR TYPES *//* 3.14.1 Notify Message Types *//* 3.14 Notification Payload *//* Nonce Data *//* may not be used, because of having only data. *//* 3.13 Nonce Payload *//* Signature Data *//* 3.12 Signature Payload *//* Hash Data *//* 3.11 Hash Payload *//* Certificate Authorities (variable length) *//* # Certificate Authorities (1 octet) *//*
	Certificate Types (variable length)
	  -- Contains a list of the types of certificates requested,
	  sorted in order of preference.  Each individual certificate
	  type is 1 octet.  This field is NOT requiredo
	*//* # Cert. Types *//* 3.10 Certificate Request Payload *//*
		This field indicates the type of
		certificate or certificate-related information contained in the
		Certificate Data field.
		*//* Certificate Data *//* Cert Encoding *//* 3.9 Certificate Payload *//* DOI Specific ID Data *//* MUST NOT to be used, because of being defined in ipsec-doi. *//* 3.8 Identification Payload *//* Key Exchange Data *//* 3.7 Key Exchange Payload *//* SA Attributes *//* RESERVED2 *//* Transform-Id *//* Transform # *//*
	The value of the next payload field MUST only contain the value "3"
	or "0".  If there are additional Transform payloads in the proposal,
	then this field will be 3.  If the current Transform payload is the
	last within the proposal, then this field will be 0.
	*//* 3.6 Transform Payload *//*
	The value of the next payload field MUST only contain the value "2"
	or "0".  If there are additional Proposal payloads in the message,
	then this field will be 2.  If the current Proposal payload is the
	last within the security association proposal, then this field will
	be 0.
	*//* 3.5 Proposal Payload *//*
	If the current payload is the last in the message,
	then the value of the next payload field will be 0.
	This field MUST NOT contain the
	values for the Proposal or Transform payloads as they are considered
	part of the security association negotiation.  For example, this
	field would contain the value "10" (Nonce payload) in the first
	message of a Base Exchange (see Section 4.4) and the value "0" in the
	first message of an Identity Protect Exchange (see Section 4.5).
	*//* MAY NOT be used, because of being defined in ipsec-doi. *//* 3.4 Security Association Payload *//* if f equal 1, Attribute Value *//* if f equal 0, Attribute Value *//* if f equal 1, Attribute Length *//* defined by DOI-spec, and Attribute Format *//* 3.3 Data Attributes
         0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
        +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
        !A!       Attribute Type        !    AF=0  Attribute Length     !
        !F!                             !    AF=1  Attribute Value      !
        +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
        .                   AF=0  Attribute Value                       .
        .                   AF=1  Not Transmitted                       .
        +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
*//* Payload Length *//* bit 7 - critical, rest is RESERVED *//* Next Payload *//* 3.2 Payload Generic Header
         0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
        +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
        ! Next Payload  !   RESERVED    !         Payload Length        !
        +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
*//* (R)esponse  *//* (V)ersion   *//* (I)nitiator *//* IKEv2 *//* Commit Bit *//* Encryption Bit *//* v2 Encrypted payload *//* Vendor ID *//* Delete *//* Notification *//* Signature *//* Hash *//* Certificate Request *//* Certificate *//* Identification *//* Key Exchange *//* Transform *//* Proposal *//* Security Association *//* NONE*//* Next Payload Type *//* Exchange Type *//* Responder Cookie *//* Initiator Cookie *//* 3.1 ISAKMP Header Format (IKEv1 and IKEv2)
         0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
        +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
        !                          Initiator                            !
        !                            Cookie                             !
        +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
        !                          Responder                            !
        !                            Cookie                             !
        +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
        !  Next Payload ! MjVer ! MnVer ! Exchange Type !     Flags     !
        +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
        !                          Message ID                           !
        +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
        !                            Length                             !
        +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
*//* refer to RFC 2408 *//* The functions from print-esp.c used in this file are only defined when both
 * OpenSSL and evp.h are detected. Employ the same preprocessor device here.
 *//* \summary: Internet Security Association and Key Management Protocol (ISAKMP) printer *//*
 * Copyright (C) 1995, 1996, 1997, and 1998 WIDE Project.
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. Neither the name of the project nor the names of its contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE PROJECT AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE PROJECT OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 *
 */end_pointer/Users/owura/Repos/codeql_eval/proj_repos/the-tcpdump-group-tcpdump-commit-9ba91381954ad325ea4fd26b9c65a8bd9a2a85b6/tcpdump/signature.hsignature_verifysignature_check_valuesCANT_CHECK_SIGNATURECANT_ALLOCATE_COPYSIGNATURE_INVALIDSIGNATURE_VALID/* signature checking result codes *//* for netdissect_options *//*
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that: (1) source code
 * distributions retain the above copyright notice and this paragraph
 * in its entirety, and (2) distributions including binary code include
 * the above copyright notice and this paragraph in its entirety in
 * the documentation or other materials provided with the distribution.
 * THIS SOFTWARE IS PROVIDED ``AS IS'' AND
 * WITHOUT ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, WITHOUT
 * LIMITATION, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS
 * FOR A PARTICULAR PURPOSE.
 *
 * Functions for signature and digest verification.
 *
 * Original code by Hannes Gredler (hannes@gredler.at)
 *//Users/owura/Repos/codeql_eval/proj_repos/the-tcpdump-group-tcpdump-commit-9ba91381954ad325ea4fd26b9c65a8bd9a2a85b6/tcpdump/print-isoclns.c"signature.h"osi_print_cksumcalculated_checksum*(pptr + checksum_offset)(ndo, " (unverified)")(ndo, " (correct)")(ndo, " (incorrect should be 0x%04x)", calculated_checksum) (unverified) (correct) (incorrect should be 0x%04x)isis_printconst isis_common_headerconst isis_common_header *isis_common_header *isis_headerconst isis_iih_lan_headerconst isis_iih_lan_header *isis_iih_lan_header *header_iih_lanconst isis_iih_ptp_headerconst isis_iih_ptp_header *isis_iih_ptp_header *header_iih_ptpconst isis_lsp_headerconst isis_lsp_header *isis_lsp_header *header_lspconst isis_csnp_headerconst isis_csnp_header *isis_csnp_header *header_csnpconst isis_psnp_headerconst isis_psnp_header *isis_psnp_header *header_psnpconst isis_tlv_lspconst isis_tlv_lsp *isis_tlv_lsp *tlv_lspconst isis_tlv_ptp_adjconst isis_tlv_ptp_adj *isis_tlv_ptp_adj *tlv_ptp_adjconst isis_tlv_is_reachconst isis_tlv_is_reach *isis_tlv_is_reach *tlv_is_reachconst isis_tlv_es_reachconst isis_tlv_es_reach *isis_tlv_es_reach *tlv_es_reachpdu_typemax_areaid_lengthtmplan_alenprefix_lenext_is_lenext_ip_lenmt_lenoptrpacket_lenpdu_lenkey_idvendor_idsigcheck*isis_headersizeof(*isis_header)ISIS_COMMON_HEADER_SIZE(ISIS_COMMON_HEADER_SIZE)(ndo, "IS-IS")(ndo, "version %d packet not supported", isis_header->version)ISIS_VERSIONversion %d packet not supported(ndo, "system ID length of %d is not supported", isis_header->id_length)system ID length of %d is not supported(ndo, "version %d packet not supported", isis_header->pdu_version)(ndo, "fixed header length %u > packet length %u", isis_header->fixed_len, length)fixed header length %u > packet length %u(ndo, "fixed header length %u < minimum header size %u", isis_header->fixed_len, (u_int)ISIS_COMMON_HEADER_SIZE)(ndo, "fixed header length %u < minimum header size %u", isis_header->fixed_len, (u_int)(sizeof(struct isis_common_header)))fixed header length %u < minimum header size %u(ndo, "bad packet -- 255 areas")bad packet -- 255 areas(ndo, "bad packet -- illegal sys-ID length (%u)", id_length)bad packet -- illegal sys-ID length (%u)(ndo, "%s%s", ndo->ndo_eflag ? "" : ", ", tok2str(isis_pdu_values, "unknown PDU-Type %u", pdu_type))(ndo, "%slength %u", ndo->ndo_eflag ? "" : ", ", length)(ndo, "\n\t%s, hlen: %u, v: %u, pdu-v: %u, sys-id-len: %u (%u), max-area: %u (%u)", tok2str(isis_pdu_values, "unknown, type %u", pdu_type), isis_header->fixed_len, isis_header->version, isis_header->pdu_version, id_length, isis_header->id_length, max_area, isis_header->max_area)unknown PDU-Type %u%slength %u
	%s, hlen: %u, v: %u, pdu-v: %u, sys-id-len: %u (%u), max-area: %u (%u)unknown, type %u(ndo, ", bogus fixed header length %u should be %lu", isis_header->fixed_len, (unsigned long)(ISIS_COMMON_HEADER_SIZE+ISIS_IIH_LAN_HEADER_SIZE))(ndo, ", bogus fixed header length %u should be %lu", isis_header->fixed_len, (unsigned long)((sizeof(struct isis_common_header))+(sizeof(struct isis_iih_lan_header))))*header_iih_lansizeof(*header_iih_lan)(ndo, ", src-id %s", isis_print_id(header_iih_lan->source_id, SYSTEM_ID_LEN))(ndo, ", src-id %s", isis_print_id(header_iih_lan->source_id, 6))(ndo, ", lan-id %s, prio %u", isis_print_id(header_iih_lan->lan_id,NODE_ID_LEN), header_iih_lan->priority)(ndo, ", lan-id %s, prio %u", isis_print_id(header_iih_lan->lan_id,6+1), header_iih_lan->priority)header_iih_lan->pdu_len(ndo, "\n\t  source-id: %s,  holding time: %us, Flags: [%s]", isis_print_id(header_iih_lan->source_id,SYSTEM_ID_LEN), EXTRACT_16BITS(header_iih_lan->holding_time), tok2str(isis_iih_circuit_type_values, "unknown circuit type 0x%02x", header_iih_lan->circuit_type))(ndo, "\n\t  source-id: %s,  holding time: %us, Flags: [%s]", isis_print_id(header_iih_lan->source_id,6), ((uint16_t)(((uint16_t)(*((const uint8_t *)(header_iih_lan->holding_time) + 0)) << 8) | ((uint16_t)(*((const uint8_t *)(header_iih_lan->holding_time) + 1)) << 0))), tok2str(isis_iih_circuit_type_values, "unknown circuit type 0x%02x", header_iih_lan->circuit_type))header_iih_lan->holding_time(ndo, "\n\t  lan-id:    %s, Priority: %u, PDU length: %u", isis_print_id(header_iih_lan->lan_id, NODE_ID_LEN), (header_iih_lan->priority) & ISIS_LAN_PRIORITY_MASK, pdu_len)(ndo, "\n\t  lan-id:    %s, Priority: %u, PDU length: %u", isis_print_id(header_iih_lan->lan_id, 6+1), (header_iih_lan->priority) & 0x7F, pdu_len)(ndo, ", bogus fixed header length %u should be %lu", isis_header->fixed_len, (unsigned long)(ISIS_COMMON_HEADER_SIZE+ISIS_IIH_PTP_HEADER_SIZE))(ndo, ", bogus fixed header length %u should be %lu", isis_header->fixed_len, (unsigned long)((sizeof(struct isis_common_header))+(sizeof(struct isis_iih_ptp_header))))*header_iih_ptpsizeof(*header_iih_ptp)(ndo, ", src-id %s", isis_print_id(header_iih_ptp->source_id, SYSTEM_ID_LEN))(ndo, ", src-id %s", isis_print_id(header_iih_ptp->source_id, 6))header_iih_ptp->pdu_len(ndo, "\n\t  source-id: %s, holding time: %us, Flags: [%s]", isis_print_id(header_iih_ptp->source_id,SYSTEM_ID_LEN), EXTRACT_16BITS(header_iih_ptp->holding_time), tok2str(isis_iih_circuit_type_values, "unknown circuit type 0x%02x", header_iih_ptp->circuit_type))(ndo, "\n\t  source-id: %s, holding time: %us, Flags: [%s]", isis_print_id(header_iih_ptp->source_id,6), ((uint16_t)(((uint16_t)(*((const uint8_t *)(header_iih_ptp->holding_time) + 0)) << 8) | ((uint16_t)(*((const uint8_t *)(header_iih_ptp->holding_time) + 1)) << 0))), tok2str(isis_iih_circuit_type_values, "unknown circuit type 0x%02x", header_iih_ptp->circuit_type))header_iih_ptp->holding_time(ndo, "\n\t  circuit-id: 0x%02x, PDU length: %u", header_iih_ptp->circuit_id, pdu_len)(ndo, ", bogus fixed header length %u should be %lu", isis_header->fixed_len, (unsigned long)ISIS_LSP_HEADER_SIZE)(ndo, ", bogus fixed header length %u should be %lu", isis_header->fixed_len, (unsigned long)(sizeof(struct isis_lsp_header)))*header_lspsizeof(*header_lsp)(ndo, ", lsp-id %s, seq 0x%08x, lifetime %5us", isis_print_id(header_lsp->lsp_id, LSP_ID_LEN), EXTRACT_32BITS(header_lsp->sequence_number), EXTRACT_16BITS(header_lsp->remaining_lifetime))(ndo, ", lsp-id %s, seq 0x%08x, lifetime %5us", isis_print_id(header_lsp->lsp_id, 6+2), ((uint32_t)(((uint32_t)(*((const uint8_t *)(header_lsp->sequence_number) + 0)) << 24) | ((uint32_t)(*((const uint8_t *)(header_lsp->sequence_number) + 1)) << 16) | ((uint32_t)(*((const uint8_t *)(header_lsp->sequence_number) + 2)) << 8) | ((uint32_t)(*((const uint8_t *)(header_lsp->sequence_number) + 3)) << 0))), ((uint16_t)(((uint16_t)(*((const uint8_t *)(header_lsp->remaining_lifetime) + 0)) << 8) | ((uint16_t)(*((const uint8_t *)(header_lsp->remaining_lifetime) + 1)) << 0))))header_lsp->sequence_numberheader_lsp->remaining_lifetimeheader_lsp->pdu_len(ndo, "\n\t  lsp-id: %s, seq: 0x%08x, lifetime: %5us\n\t  chksum: 0x%04x", isis_print_id(header_lsp->lsp_id, LSP_ID_LEN), EXTRACT_32BITS(header_lsp->sequence_number), EXTRACT_16BITS(header_lsp->remaining_lifetime), EXTRACT_16BITS(header_lsp->checksum))(ndo, "\n\t  lsp-id: %s, seq: 0x%08x, lifetime: %5us\n\t  chksum: 0x%04x", isis_print_id(header_lsp->lsp_id, 6+2), ((uint32_t)(((uint32_t)(*((const uint8_t *)(header_lsp->sequence_number) + 0)) << 24) | ((uint32_t)(*((const uint8_t *)(header_lsp->sequence_number) + 1)) << 16) | ((uint32_t)(*((const uint8_t *)(header_lsp->sequence_number) + 2)) << 8) | ((uint32_t)(*((const uint8_t *)(header_lsp->sequence_number) + 3)) << 0))), ((uint16_t)(((uint16_t)(*((const uint8_t *)(header_lsp->remaining_lifetime) + 0)) << 8) | ((uint16_t)(*((const uint8_t *)(header_lsp->remaining_lifetime) + 1)) << 0))), ((uint16_t)(((uint16_t)(*((const uint8_t *)(header_lsp->checksum) + 0)) << 8) | ((uint16_t)(*((const uint8_t *)(header_lsp->checksum) + 1)) << 0))))header_lsp->checksum(ndo, ", PDU length: %u, Flags: [ %s", pdu_len, ISIS_MASK_LSP_OL_BIT(header_lsp->typeblock) ? "Overload bit set, " : "")(ndo, ", PDU length: %u, Flags: [ %s", pdu_len, ((header_lsp->typeblock)&0x4) ? "Overload bit set, " : "")header_lsp->typeblock(ndo, "%s", ISIS_MASK_LSP_ATT_DEFAULT_BIT(header_lsp->typeblock) ? "default " : "")(ndo, "%s", ((header_lsp->typeblock)&0x8) ? "default " : "")(ndo, "%s", ISIS_MASK_LSP_ATT_DELAY_BIT(header_lsp->typeblock) ? "delay " : "")(ndo, "%s", ((header_lsp->typeblock)&0x10) ? "delay " : "")(ndo, "%s", ISIS_MASK_LSP_ATT_EXPENSE_BIT(header_lsp->typeblock) ? "expense " : "")(ndo, "%s", ((header_lsp->typeblock)&0x20) ? "expense " : "")(ndo, "%s", ISIS_MASK_LSP_ATT_ERROR_BIT(header_lsp->typeblock) ? "error " : "")(ndo, "%s", ((header_lsp->typeblock)&0x40) ? "error " : "")(ndo, "ATT bit set, ")(ndo, "%s", ISIS_MASK_LSP_PARTITION_BIT(header_lsp->typeblock) ? "P bit set, " : "")(ndo, "%s", ((header_lsp->typeblock)&0x80) ? "P bit set, " : "")(ndo, "%s ]", tok2str(isis_lsp_istype_values, "Unknown(0x%x)", ISIS_MASK_LSP_ISTYPE_BITS(header_lsp->typeblock)))(ndo, "%s ]", tok2str(isis_lsp_istype_values, "Unknown(0x%x)", ((header_lsp->typeblock)&0x3)))(ndo, ", bogus fixed header length %u should be %lu", isis_header->fixed_len, (unsigned long)(ISIS_COMMON_HEADER_SIZE+ISIS_CSNP_HEADER_SIZE))(ndo, ", bogus fixed header length %u should be %lu", isis_header->fixed_len, (unsigned long)((sizeof(struct isis_common_header))+(sizeof(struct isis_csnp_header))))*header_csnpsizeof(*header_csnp)(ndo, ", src-id %s", isis_print_id(header_csnp->source_id, NODE_ID_LEN))(ndo, ", src-id %s", isis_print_id(header_csnp->source_id, 6+1))header_csnp->pdu_len(ndo, "\n\t  source-id:    %s, PDU length: %u", isis_print_id(header_csnp->source_id, NODE_ID_LEN), pdu_len)(ndo, "\n\t  source-id:    %s, PDU length: %u", isis_print_id(header_csnp->source_id, 6+1), pdu_len)(ndo, "\n\t  start lsp-id: %s", isis_print_id(header_csnp->start_lsp_id, LSP_ID_LEN))(ndo, "\n\t  start lsp-id: %s", isis_print_id(header_csnp->start_lsp_id, 6+2))(ndo, "\n\t  end lsp-id:   %s", isis_print_id(header_csnp->end_lsp_id, LSP_ID_LEN))(ndo, "\n\t  end lsp-id:   %s", isis_print_id(header_csnp->end_lsp_id, 6+2))(ndo, "- bogus fixed header length %u should be %lu", isis_header->fixed_len, (unsigned long)(ISIS_COMMON_HEADER_SIZE+ISIS_PSNP_HEADER_SIZE))(ndo, "- bogus fixed header length %u should be %lu", isis_header->fixed_len, (unsigned long)((sizeof(struct isis_common_header))+(sizeof(struct isis_psnp_header))))*header_psnpsizeof(*header_psnp)(ndo, ", src-id %s", isis_print_id(header_psnp->source_id, NODE_ID_LEN))(ndo, ", src-id %s", isis_print_id(header_psnp->source_id, 6+1))header_psnp->pdu_len(ndo, "\n\t  source-id:    %s, PDU length: %u", isis_print_id(header_psnp->source_id, NODE_ID_LEN), pdu_len)(ndo, "\n\t  source-id:    %s, PDU length: %u", isis_print_id(header_psnp->source_id, 6+1), pdu_len)ISIS_PDU_L1_LAN_IIHISIS_PDU_L2_LAN_IIHISIS_IIH_LAN_HEADER_SIZE(ISIS_COMMON_HEADER_SIZE+ISIS_IIH_LAN_HEADER_SIZE), bogus fixed header length %u should be %lu, src-id %s, lan-id %s, prio %uuint8_t[7]unsigned char[7]
	  source-id: %s,  holding time: %us, Flags: [%s]unknown circuit type 0x%02x
	  lan-id:    %s, Priority: %u, PDU length: %uISIS_PDU_PTP_IIHISIS_IIH_PTP_HEADER_SIZE(ISIS_COMMON_HEADER_SIZE+ISIS_IIH_PTP_HEADER_SIZE)
	  source-id: %s, holding time: %us, Flags: [%s]
	  circuit-id: 0x%02x, PDU length: %uISIS_PDU_L1_LSPISIS_PDU_L2_LSPISIS_LSP_HEADER_SIZE(ISIS_COMMON_HEADER_SIZE+ISIS_LSP_HEADER_SIZE), lsp-id %s, seq 0x%08x, lifetime %5us
	  lsp-id: %s, seq: 0x%08x, lifetime: %5us
	  chksum: 0x%04x, PDU length: %u, Flags: [ %sOverload bit set, default delay expense error ATT bit set, P bit set, %s ]Unknown(0x%x)ISIS_PDU_L1_CSNPISIS_PDU_L2_CSNPISIS_CSNP_HEADER_SIZE(ISIS_COMMON_HEADER_SIZE+ISIS_CSNP_HEADER_SIZE)
	  source-id:    %s, PDU length: %u
	  start lsp-id: %s
	  end lsp-id:   %sISIS_PDU_L1_PSNPISIS_PDU_L2_PSNPISIS_PSNP_HEADER_SIZE(ISIS_COMMON_HEADER_SIZE+ISIS_PSNP_HEADER_SIZE)- bogus fixed header length %u should be %lu(ndo, "\n\t    %s TLV #%u, length: %u", tok2str(isis_tlv_values, "unknown", tlv_type), tlv_type, tlv_len)(ndo, "\n\t      Area address (length: %u): %s", alen, isonsap_string(ndo, tptr, alen))(ndo, "\n\t      SNPA: %s", isis_print_id(tptr, ETHER_ADDR_LEN))(ndo, "\n\t      SNPA: %s", isis_print_id(tptr, 6))(ndo, "\n\t      LAN address length 0 bytes (invalid)")(ndo, "\n\t      LAN address length %u bytes ", lan_alen)(ndo, "\n\t\tIS Neighbor: %s", isis_print_id(tptr, lan_alen))(ndo, "\n\t      %s", tok2str(isis_is_reach_virtual_values, "bogus virtual flag 0x%02x", *tptr++))*tlv_is_reachsizeof(*tlv_is_reach)(ndo, "\n\t      IS Neighbor: %s", isis_print_id(tlv_is_reach->neighbor_nodeid, NODE_ID_LEN))(ndo, "\n\t      IS Neighbor: %s", isis_print_id(tlv_is_reach->neighbor_nodeid, 6+1))*tlv_es_reachsizeof(*tlv_es_reach)(ndo, "\n\t      ES Neighbor: %s", isis_print_id(tlv_es_reach->neighbor_sysid, SYSTEM_ID_LEN))(ndo, "\n\t      ES Neighbor: %s", isis_print_id(tlv_es_reach->neighbor_sysid, 6))(ndo, "\n\t      IPv6 interface address: %s", ip6addr_string(ndo, tptr))(ndo, "\n\t      IPv6 interface address: %s", getname6(ndo, (const u_char *)(tptr)))(ndo, "\n\t      %s: ", tok2str(isis_subtlv_auth_values, "unknown Authentication type 0x%02x", *tptr))*(tptr + i)(ndo, "%02x", *(tptr + i))(ndo, ", (invalid subTLV) ")(ndo, " (%s)", tok2str(signature_check_values, "Unknown", sigcheck))*(tptr + 1)(tptr+1)(ndo, "%u, password: ", key_id)(ndo, "\n\t      Adjacency State: %s (%u)", tok2str(isis_ptp_adjancey_values, "unknown", *tptr), *tptr)tlv_ptp_adj->extd_local_circuit_idsizeof(tlv_ptp_adj->extd_local_circuit_id)(ndo, "\n\t      Extended Local circuit-ID: 0x%08x", EXTRACT_32BITS(tlv_ptp_adj->extd_local_circuit_id))(ndo, "\n\t      Extended Local circuit-ID: 0x%08x", ((uint32_t)(((uint32_t)(*((const uint8_t *)(tlv_ptp_adj->extd_local_circuit_id) + 0)) << 24) | ((uint32_t)(*((const uint8_t *)(tlv_ptp_adj->extd_local_circuit_id) + 1)) << 16) | ((uint32_t)(*((const uint8_t *)(tlv_ptp_adj->extd_local_circuit_id) + 2)) << 8) | ((uint32_t)(*((const uint8_t *)(tlv_ptp_adj->extd_local_circuit_id) + 3)) << 0))))tlv_ptp_adj->neighbor_sysidSYSTEM_ID_LEN(ndo, "\n\t      Neighbor System-ID: %s", isis_print_id(tlv_ptp_adj->neighbor_sysid, SYSTEM_ID_LEN))(ndo, "\n\t      Neighbor System-ID: %s", isis_print_id(tlv_ptp_adj->neighbor_sysid, 6))tlv_ptp_adj->neighbor_extd_local_circuit_idsizeof(tlv_ptp_adj->neighbor_extd_local_circuit_id)(ndo, "\n\t      Neighbor Extended Local circuit-ID: 0x%08x", EXTRACT_32BITS(tlv_ptp_adj->neighbor_extd_local_circuit_id))(ndo, "\n\t      Neighbor Extended Local circuit-ID: 0x%08x", ((uint32_t)(((uint32_t)(*((const uint8_t *)(tlv_ptp_adj->neighbor_extd_local_circuit_id) + 0)) << 24) | ((uint32_t)(*((const uint8_t *)(tlv_ptp_adj->neighbor_extd_local_circuit_id) + 1)) << 16) | ((uint32_t)(*((const uint8_t *)(tlv_ptp_adj->neighbor_extd_local_circuit_id) + 2)) << 8) | ((uint32_t)(*((const uint8_t *)(tlv_ptp_adj->neighbor_extd_local_circuit_id) + 3)) << 0))))(ndo, "\n\t      NLPID(s): ")(ndo, "%s (0x%02x)", tok2str(nlpid_values, "unknown", *tptr), *tptr)(ndo, "\n\t       RES: %d, MTID(s): %d", (EXTRACT_16BITS (tptr) >> 12), (EXTRACT_16BITS (tptr) & 0x0fff))(ndo, "\n\t       RES: %d, MTID(s): %d", (((uint16_t)(((uint16_t)(*((const uint8_t *)(tptr) + 0)) << 8) | ((uint16_t)(*((const uint8_t *)(tptr) + 1)) << 0))) >> 12), (((uint16_t)(((uint16_t)(*((const uint8_t *)(tptr) + 0)) << 8) | ((uint16_t)(*((const uint8_t *)(tptr) + 1)) << 0))) & 0x0fff))(ndo, "\n\t      O: %d, RES: %d, MTID(s): %d", (EXTRACT_16BITS(tptr) >> 15) & 0x01, (EXTRACT_16BITS(tptr) >> 12) & 0x07, EXTRACT_16BITS(tptr) & 0x0fff)(ndo, "\n\t      O: %d, RES: %d, MTID(s): %d", (((uint16_t)(((uint16_t)(*((const uint8_t *)(tptr) + 0)) << 8) | ((uint16_t)(*((const uint8_t *)(tptr) + 1)) << 0))) >> 15) & 0x01, (((uint16_t)(((uint16_t)(*((const uint8_t *)(tptr) + 0)) << 8) | ((uint16_t)(*((const uint8_t *)(tptr) + 1)) << 0))) >> 12) & 0x07, ((uint16_t)(((uint16_t)(*((const uint8_t *)(tptr) + 0)) << 8) | ((uint16_t)(*((const uint8_t *)(tptr) + 1)) << 0))) & 0x0fff)(ndo, "\n\t      Traffic Engineering Router ID: %s", ipaddr_string(ndo, pptr))(ndo, "\n\t      Traffic Engineering Router ID: %s", getname(ndo, (const u_char *)(pptr)))(ndo, "\n\t      IPv4 interface address: %s", ipaddr_string(ndo, tptr))(ndo, "\n\t      IPv4 interface address: %s", getname(ndo, (const u_char *)(tptr)))(ndo, "\n\t      Hostname: ")NODE_ID_LEN6+1(ndo, "\n\t      IS Neighbor: %s", isis_print_id(tptr, NODE_ID_LEN))(ndo, "\n\t      IS Neighbor: %s", isis_print_id(tptr, 6+1))(ndo, ", Flags: [%s]", ISIS_MASK_TLV_SHARED_RISK_GROUP(*tptr++) ? "numbered" : "unnumbered")(ndo, ", Flags: [%s]", ((*tptr++)&0x1) ? "numbered" : "unnumbered")*tptr++(ndo, "\n\t      IPv4 neighbor address: %s", ipaddr_string(ndo, tptr))(ndo, "\n\t      IPv4 neighbor address: %s", getname(ndo, (const u_char *)(tptr)))(ndo, "\n\t      Link-ID: 0x%08x", EXTRACT_32BITS(tptr))(ndo, "\n\t      Link-ID: 0x%08x", ((uint32_t)(((uint32_t)(*((const uint8_t *)(tptr) + 0)) << 24) | ((uint32_t)(*((const uint8_t *)(tptr) + 1)) << 16) | ((uint32_t)(*((const uint8_t *)(tptr) + 2)) << 8) | ((uint32_t)(*((const uint8_t *)(tptr) + 3)) << 0))))(tlv_lsp->lsp_id)[LSP_ID_LEN-1](tlv_lsp->lsp_id)[6+2-1]sizeof((tlv_lsp->lsp_id)[6+2-1])(ndo, "\n\t      lsp-id: %s", isis_print_id(tlv_lsp->lsp_id, LSP_ID_LEN))(ndo, "\n\t      lsp-id: %s", isis_print_id(tlv_lsp->lsp_id, 6+2))tlv_lsp->sequence_number(ndo, ", seq: 0x%08x", EXTRACT_32BITS(tlv_lsp->sequence_number))(ndo, ", seq: 0x%08x", ((uint32_t)(((uint32_t)(*((const uint8_t *)(tlv_lsp->sequence_number) + 0)) << 24) | ((uint32_t)(*((const uint8_t *)(tlv_lsp->sequence_number) + 1)) << 16) | ((uint32_t)(*((const uint8_t *)(tlv_lsp->sequence_number) + 2)) << 8) | ((uint32_t)(*((const uint8_t *)(tlv_lsp->sequence_number) + 3)) << 0))))tlv_lsp->remaining_lifetime(ndo, ", lifetime: %5ds", EXTRACT_16BITS(tlv_lsp->remaining_lifetime))(ndo, ", lifetime: %5ds", ((uint16_t)(((uint16_t)(*((const uint8_t *)(tlv_lsp->remaining_lifetime) + 0)) << 8) | ((uint16_t)(*((const uint8_t *)(tlv_lsp->remaining_lifetime) + 1)) << 0))))tlv_lsp->checksum(ndo, ", chksum: 0x%04x", EXTRACT_16BITS(tlv_lsp->checksum))(ndo, ", chksum: 0x%04x", ((uint16_t)(((uint16_t)(*((const uint8_t *)(tlv_lsp->checksum) + 0)) << 8) | ((uint16_t)(*((const uint8_t *)(tlv_lsp->checksum) + 1)) << 0))))ISIS_TLV_CHECKSUM_MINLEN(ndo, "\n\t      checksum: 0x%04x ", EXTRACT_16BITS(tptr))(ndo, "\n\t      checksum: 0x%04x ", ((uint16_t)(((uint16_t)(*((const uint8_t *)(tptr) + 0)) << 8) | ((uint16_t)(*((const uint8_t *)(tptr) + 1)) << 0))))SYSTEM_ID_LEN + 16 + 1(ndo, "\n\t      Purge Originator System-ID: %s", isis_print_id(tptr + 1, SYSTEM_ID_LEN))(ndo, "\n\t      Purge Originator System-ID: %s", isis_print_id(tptr + 1, 6))2 * SYSTEM_ID_LEN + 12 * 6 + 1(ndo, "\n\t      Received from System-ID: %s", isis_print_id(tptr + SYSTEM_ID_LEN + 1, SYSTEM_ID_LEN))(ndo, "\n\t      Received from System-ID: %s", isis_print_id(tptr + 6 + 1, 6))(ndo, "\n\t      invalid MT-ID")ISIS_TLV_RESTART_SIGNALING_FLAGLEN(ndo, "\n\t      Flags [%s]", bittok2str(isis_restart_flag_values, "none", *tptr))ISIS_TLV_RESTART_SIGNALING_HOLDTIMELEN(ndo, ", Remaining holding time %us", EXTRACT_16BITS(tptr))(ndo, ", Remaining holding time %us", ((uint16_t)(((uint16_t)(*((const uint8_t *)(tptr) + 0)) << 8) | ((uint16_t)(*((const uint8_t *)(tptr) + 1)) << 0))))(ndo, ", for %s", isis_print_id(tptr,SYSTEM_ID_LEN))(ndo, ", for %s", isis_print_id(tptr,6))ISIS_TLV_IDRP_INFO_MINLEN(ndo, "\n\t      Inter-Domain Information Type: %s", tok2str(isis_subtlv_idrp_values, "Unknown (0x%02x)", *tptr))(ndo, "AS Number: %u", EXTRACT_16BITS(tptr))(ndo, "AS Number: %u", ((uint16_t)(((uint16_t)(*((const uint8_t *)(tptr) + 0)) << 8) | ((uint16_t)(*((const uint8_t *)(tptr) + 1)) << 0))))ISIS_TLV_LSP_BUFFERSIZE_MINLEN(ndo, "\n\t      LSP Buffersize: %u", EXTRACT_16BITS(tptr))(ndo, "\n\t      LSP Buffersize: %u", ((uint16_t)(((uint16_t)(*((const uint8_t *)(tptr) + 0)) << 8) | ((uint16_t)(*((const uint8_t *)(tptr) + 1)) << 0))))(ndo, "\n\t      %s", isis_print_id(tptr, SYSTEM_ID_LEN))(ndo, "\n\t      %s", isis_print_id(tptr, 6))sizeof(struct isis_metric_block)(ndo, "\n\t      Metric Block")(ndo, "\n\t\tAddress: prefix length %u < 2", prefix_len)prefix_len / 2(ndo, "\n\t\tAddress: %s/%u", isonsap_string(ndo, tptr, prefix_len / 2), prefix_len * 4)ISIS_TLV_IIH_SEQNR_MINLEN(ndo, "\n\t      Sequence number: %u", EXTRACT_32BITS(tptr))(ndo, "\n\t      Sequence number: %u", ((uint32_t)(((uint32_t)(*((const uint8_t *)(tptr) + 0)) << 24) | ((uint32_t)(*((const uint8_t *)(tptr) + 1)) << 16) | ((uint32_t)(*((const uint8_t *)(tptr) + 2)) << 8) | ((uint32_t)(*((const uint8_t *)(tptr) + 3)) << 0))))ISIS_TLV_VENDOR_PRIVATE_MINLEN(ndo, "\n\t      Vendor: %s (%u)", tok2str(oui_values, "Unknown", vendor_id), vendor_id)
	    %s TLV #%u, length: %uconst tok[42]tok[42]ISIS_TLV_AREA_ADDR
	      Area address (length: %u): %sISIS_TLV_ISNEIGH
	      SNPA: %sISIS_TLV_ISNEIGH_VARLEN
	      LAN address length 0 bytes (invalid)
	      LAN address length %u bytes 
		IS Neighbor: %sISIS_TLV_PADDING222ISIS_TLV_MT_IS_REACH2+NODE_ID_LEN2+NODE_ID_LEN+32+NODE_ID_LEN+3+1ISIS_TLV_IS_ALIAS_IDISIS_TLV_EXT_IS_REACHISIS_TLV_IS_REACHbogus virtual flag 0x%02xsizeof(struct isis_tlv_is_reach)
	      IS Neighbor: %sconst isis_metric_blockconst isis_metric_block *isis_metric_block *ISIS_TLV_ESNEIGHsizeof(struct isis_tlv_es_reach)
	      ES Neighbor: %sISIS_TLV_INT_IP_REACHISIS_TLV_EXT_IP_REACHISIS_TLV_EXTD_IP_REACH235ISIS_TLV_MT_IP_REACH236ISIS_TLV_IP6_REACH237ISIS_TLV_MT_IP6_REACH232ISIS_TLV_IP6ADDR
	      IPv6 interface address: %sISIS_TLV_AUTH
	      %s: unknown Authentication type 0x%02xISIS_SUBTLV_AUTH_SIMPLEISIS_SUBTLV_AUTH_MD5ISIS_SUBTLV_AUTH_MD5_LEN, (invalid subTLV) ISIS_SUBTLV_AUTH_GENERIC%u, password: sizeof(uint16_t)1 + sizeof(uint16_t)ISIS_SUBTLV_AUTH_PRIVATE
		  "\n\t\t  "ISIS_TLV_PTP_ADJ
	      Adjacency State: %s (%u)
	      Extended Local circuit-ID: 0x%08xconst uint8_t[6]const uint8_t(*)[6]
	      Neighbor System-ID: %s
	      Neighbor Extended Local circuit-ID: 0x%08xISIS_TLV_PROTOCOLS
	      NLPID(s): %s (0x%02x)ISIS_TLV_MT_PORT_CAP
	       RES: %d, MTID(s): %dISIS_TLV_MT_CAPABILITY
	      O: %d, RES: %d, MTID(s): %dISIS_TLV_TE_ROUTER_ID
	      Traffic Engineering Router ID: %sISIS_TLV_IPADDR
	      IPv4 interface address: %sISIS_TLV_HOSTNAME
	      Hostname: ISIS_TLV_SHARED_RISK_GROUP(NODE_ID_LEN)numberedunnumbered
	      IPv4 neighbor address: %s
	      Link-ID: 0x%08xISIS_TLV_LSPsizeof(struct isis_tlv_lsp)
	      lsp-id: %s, seq: 0x%08x, lifetime: %5ds, chksum: 0x%04xISIS_TLV_CHECKSUM
	      checksum: 0x%04x ISIS_TLV_POI
	      Purge Originator System-ID: %s2 * SYSTEM_ID_LEN
	      Received from System-ID: %s229ISIS_TLV_MT_SUPPORTEDISIS_TLV_MT_SUPPORTED_MINLEN
	      invalid MT-ID211ISIS_TLV_RESTART_SIGNALING
	      Flags [%s], Remaining holding time %us, for %sISIS_TLV_IDRP_INFO
	      Inter-Domain Information Type: %sISIS_SUBTLV_IDRP_ASNAS Number: %uISIS_SUBTLV_IDRP_LOCALISIS_SUBTLV_IDRP_RESISIS_TLV_LSP_BUFFERSIZE
	      LSP Buffersize: %uISIS_TLV_PART_DISISIS_TLV_PREFIX_NEIGH
	      Metric Block
		Address: prefix length %u < 2
		Address: %s/%uISIS_TLV_IIH_SEQNR
	      Sequence number: %uISIS_TLV_VENDOR_PRIVATE
	      Vendor: %s (%u)ISIS_TLV_DECNET_PHASE4ISIS_TLV_LUCENT_PRIVATEISIS_TLV_IPAUTHISIS_TLV_NORTEL_PRIVATE1ISIS_TLV_NORTEL_PRIVATE2(ndo, "\n\t      %u straggler bytes", packet_len)
	      %u straggler bytestrunctlv(ndo, "\n\t\t")isis_clear_checksum_lifetimeisis_print_extd_ip_reachident_bufferstatus_byteprocessedsubtlvtypesubtlvlen(ndo, "%sIPv4 prefix: bad bit length %u", ident, bit_length)(ndo, "%sIPv6 prefix: bad bit length %u", ident, bit_length)0x3f%sIPv4 prefix: bad bit length %u%sIPv6 prefix: bad bit length %u0, sizeof prefixtptr,byte_length(ndo, "%sIPv4 prefix: %15s/%u", ident, ipaddr_string(ndo, prefix), bit_length)(ndo, "%sIPv4 prefix: %15s/%u", ident, getname(ndo, (const u_char *)(prefix)), bit_length)(ndo, "%sIPv6 prefix: %s/%u", ident, ip6addr_string(ndo, prefix), bit_length)(ndo, "%sIPv6 prefix: %s/%u", ident, getname6(ndo, (const u_char *)(prefix)), bit_length)%sIPv4 prefix: %15s/%u%sIPv6 prefix: %s/%u(ndo, ", Distribution: %s, Metric: %u", ISIS_MASK_TLV_EXTD_IP_UPDOWN(status_byte) ? "down" : "up", metric)(ndo, ", Distribution: %s, Metric: %u", ((status_byte)&0x80) ? "down" : "up", metric), Distribution: %s, Metric: %u(ndo, ", sub-TLVs present")(ndo, ", %s%s", ISIS_MASK_TLV_EXTD_IP6_IE(status_byte) ? "External" : "Internal", ISIS_MASK_TLV_EXTD_IP6_SUBTLV(status_byte) ? ", sub-TLVs present" : "")(ndo, ", %s%s", ((status_byte)&0x40) ? "External" : "Internal", ((status_byte)&0x20) ? ", sub-TLVs present" : ""), sub-TLVs present, %s%sInternal(ndo, " (%u)", sublen)sizeof(ident_buffer)"%s  ",ident%s  isis_print_mtid(ndo, "%s%s", ident, tok2str(isis_mt_values, "Reserved for IETF Consensus", ISIS_MASK_MTID(EXTRACT_16BITS(tptr))))(ndo, "%s%s", ident, tok2str(isis_mt_values, "Reserved for IETF Consensus", ((((uint16_t)(((uint16_t)(*((const uint8_t *)(tptr) + 0)) << 8) | ((uint16_t)(*((const uint8_t *)(tptr) + 1)) << 0))))&0x0fff)))Reserved for IETF ConsensusEXTRACT_16BITS(tptr)((uint16_t)(((uint16_t)(*((const uint8_t *)(tptr) + 0)) << 8) | ((uint16_t)(*((const uint8_t *)(tptr) + 1)) << 0)))(ndo, " Topology (0x%03x), Flags: [%s]", ISIS_MASK_MTID(EXTRACT_16BITS(tptr)), bittok2str(isis_mt_flag_values, "none",ISIS_MASK_MTFLAGS(EXTRACT_16BITS(tptr))))(ndo, " Topology (0x%03x), Flags: [%s]", ((((uint16_t)(((uint16_t)(*((const uint8_t *)(tptr) + 0)) << 8) | ((uint16_t)(*((const uint8_t *)(tptr) + 1)) << 0))))&0x0fff), bittok2str(isis_mt_flag_values, "none",((((uint16_t)(((uint16_t)(*((const uint8_t *)(tptr) + 0)) << 8) | ((uint16_t)(*((const uint8_t *)(tptr) + 1)) << 0))))&0xf000))) Topology (0x%03x), Flags: [%s]header61440(2)isis_print_ext_is_reachsubtlv_typesubtlv_lensubtlv_sum_lenproc_bytes(ndo, "%sIS Neighbor: %s", ident, isis_print_id(tptr, NODE_ID_LEN))(ndo, "%sIS Neighbor: %s", ident, isis_print_id(tptr, 6+1))%sIS Neighbor: %s(ndo, ", Metric: %d", EXTRACT_24BITS(tptr))(ndo, ", Metric: %d", ((uint32_t)(((uint32_t)(*((const uint8_t *)(tptr) + 0)) << 16) | ((uint32_t)(*((const uint8_t *)(tptr) + 1)) << 8) | ((uint32_t)(*((const uint8_t *)(tptr) + 2)) << 0)))), Metric: %d(ndo, ", %ssub-TLVs present",subtlv_sum_len ? "" : "no "), %ssub-TLVs presentno (ndo, " (%u)", subtlv_sum_len)isis_print_is_reach_subtlvte_classpriority_levelgmpls_switch_cap(ndo, "%s%s subTLV #%u, length: %u", ident, tok2str(isis_ext_is_reach_subtlv_values, "unknown", subt), subt, subl)%s%s subTLV #%u, length: %usubl(ndo, ", 0x%08x", EXTRACT_32BITS(tptr))(ndo, ", 0x%08x", ((uint32_t)(((uint32_t)(*((const uint8_t *)(tptr) + 0)) << 24) | ((uint32_t)(*((const uint8_t *)(tptr) + 1)) << 16) | ((uint32_t)(*((const uint8_t *)(tptr) + 2)) << 8) | ((uint32_t)(*((const uint8_t *)(tptr) + 3)) << 0))))(ndo, ", 0x%08x", EXTRACT_32BITS(tptr+4))(ndo, ", 0x%08x", ((uint32_t)(((uint32_t)(*((const uint8_t *)(tptr+4) + 0)) << 24) | ((uint32_t)(*((const uint8_t *)(tptr+4) + 1)) << 16) | ((uint32_t)(*((const uint8_t *)(tptr+4) + 2)) << 8) | ((uint32_t)(*((const uint8_t *)(tptr+4) + 3)) << 0))))(ndo, ", %s", ipaddr_string(ndo, tptr))(ndo, ", %s", getname(ndo, (const u_char *)(tptr)))(ndo, ", %.3f Mbps", bw.f * 8 / 1000000)(ndo, "%s  TE-Class %u: %.3f Mbps", ident, te_class, bw.f * 8 / 1000000)(ndo, "%sBandwidth Constraints Model ID: %s (%u)", ident, tok2str(diffserv_te_bc_values, "unknown", *tptr), *tptr)(ndo, "%s  Bandwidth constraint CT%u: %.3f Mbps", ident, te_class, bw.f * 8 / 1000000)(ndo, ", %u", EXTRACT_24BITS(tptr))(ndo, ", %u", ((uint32_t)(((uint32_t)(*((const uint8_t *)(tptr) + 0)) << 16) | ((uint32_t)(*((const uint8_t *)(tptr) + 1)) << 8) | ((uint32_t)(*((const uint8_t *)(tptr) + 2)) << 0))))(ndo, ", [ %s ] (0x%04x)", bittok2str(isis_subtlv_link_attribute_values, "Unknown", EXTRACT_16BITS(tptr)), EXTRACT_16BITS(tptr))(ndo, ", [ %s ] (0x%04x)", bittok2str(isis_subtlv_link_attribute_values, "Unknown", ((uint16_t)(((uint16_t)(*((const uint8_t *)(tptr) + 0)) << 8) | ((uint16_t)(*((const uint8_t *)(tptr) + 1)) << 0)))), ((uint16_t)(((uint16_t)(*((const uint8_t *)(tptr) + 0)) << 8) | ((uint16_t)(*((const uint8_t *)(tptr) + 1)) << 0))))(ndo, ", %s, Priority %u", bittok2str(gmpls_link_prot_values, "none", *tptr), *(tptr+1))(ndo, ", LM: %u", EXTRACT_24BITS(tptr))(ndo, ", LM: %u", ((uint32_t)(((uint32_t)(*((const uint8_t *)(tptr) + 0)) << 16) | ((uint32_t)(*((const uint8_t *)(tptr) + 1)) << 8) | ((uint32_t)(*((const uint8_t *)(tptr) + 2)) << 0))))(ndo, ", P: %u", *(tptr))(ndo, ", P-ID: %u", EXTRACT_16BITS(tptr))(ndo, ", P-ID: %u", ((uint16_t)(((uint16_t)(*((const uint8_t *)(tptr) + 0)) << 8) | ((uint16_t)(*((const uint8_t *)(tptr) + 1)) << 0))))(ndo, "%s  Interface Switching Capability:%s", ident, tok2str(gmpls_switch_cap_values, "Unknown", gmpls_switch_cap))(ndo, ", LSP Encoding: %s", tok2str(gmpls_encoding_values, "Unknown", *(tptr + 1)))(ndo, "%s  Max LSP Bandwidth:", ident)(ndo, "%s    priority level %d: %.3f Mbps", ident, priority_level, bw.f * 8 / 1000000)(ndo, "%s  Min LSP Bandwidth: %.3f Mbps", ident, bw.f * 8 / 1000000)(ndo, "%s  Interface MTU: %u", ident, EXTRACT_16BITS(tptr + 4))(ndo, "%s  Interface MTU: %u", ident, ((uint16_t)(((uint16_t)(*((const uint8_t *)(tptr + 4) + 0)) << 8) | ((uint16_t)(*((const uint8_t *)(tptr + 4) + 1)) << 0))))(ndo, "%s  Indication %s", ident, tok2str(gmpls_switch_cap_tsc_indication_values, "Unknown (%u)", *(tptr + 4)))ISIS_SUBTLV_EXT_IS_REACH_ADMIN_GROUPISIS_SUBTLV_EXT_IS_REACH_LINK_LOCAL_REMOTE_IDISIS_SUBTLV_EXT_IS_REACH_LINK_REMOTE_ID, 0x%08xISIS_SUBTLV_EXT_IS_REACH_IPV4_INTF_ADDRISIS_SUBTLV_EXT_IS_REACH_IPV4_NEIGHBOR_ADDRISIS_SUBTLV_EXT_IS_REACH_MAX_LINK_BWISIS_SUBTLV_EXT_IS_REACH_RESERVABLE_BW, %.3f MbpsISIS_SUBTLV_EXT_IS_REACH_UNRESERVED_BW%s  TE-Class %u: %.3f MbpsISIS_SUBTLV_EXT_IS_REACH_BW_CONSTRAINTSISIS_SUBTLV_EXT_IS_REACH_BW_CONSTRAINTS_OLD%sBandwidth Constraints Model ID: %s (%u)%s  Bandwidth constraint CT%u: %.3f MbpsISIS_SUBTLV_EXT_IS_REACH_TE_METRIC, %uISIS_SUBTLV_EXT_IS_REACH_LINK_ATTRIBUTE, [ %s ] (0x%04x)ISIS_SUBTLV_EXT_IS_REACH_LINK_PROTECTION_TYPE, %s, Priority %uISIS_SUBTLV_SPB_METRIC, LM: %u, P: %u, P-ID: %uISIS_SUBTLV_EXT_IS_REACH_INTF_SW_CAP_DESCR%s  Interface Switching Capability:%s, LSP Encoding: %s%s  Max LSP Bandwidth:%s    priority level %d: %.3f Mbps%s  Min LSP Bandwidth: %.3f Mbps%s  Interface MTU: %usubt%s  Indication %s
		    "\n\t\t    "isis_print_ip_reach_subtlv(ndo, "%s%s subTLV #%u, length: %u", ident, tok2str(isis_ext_ip_reach_subtlv_values, "unknown", subt), subt, subl)(ndo, ", 0x%08x (=%u)", EXTRACT_32BITS(tptr), EXTRACT_32BITS(tptr))(ndo, ", 0x%08x (=%u)", ((uint32_t)(((uint32_t)(*((const uint8_t *)(tptr) + 0)) << 24) | ((uint32_t)(*((const uint8_t *)(tptr) + 1)) << 16) | ((uint32_t)(*((const uint8_t *)(tptr) + 2)) << 8) | ((uint32_t)(*((const uint8_t *)(tptr) + 3)) << 0))), ((uint32_t)(((uint32_t)(*((const uint8_t *)(tptr) + 0)) << 24) | ((uint32_t)(*((const uint8_t *)(tptr) + 1)) << 16) | ((uint32_t)(*((const uint8_t *)(tptr) + 2)) << 8) | ((uint32_t)(*((const uint8_t *)(tptr) + 3)) << 0))))(ndo, ", 0x%08x%08x", EXTRACT_32BITS(tptr), EXTRACT_32BITS(tptr+4))(ndo, ", 0x%08x%08x", ((uint32_t)(((uint32_t)(*((const uint8_t *)(tptr) + 0)) << 24) | ((uint32_t)(*((const uint8_t *)(tptr) + 1)) << 16) | ((uint32_t)(*((const uint8_t *)(tptr) + 2)) << 8) | ((uint32_t)(*((const uint8_t *)(tptr) + 3)) << 0))), ((uint32_t)(((uint32_t)(*((const uint8_t *)(tptr+4) + 0)) << 24) | ((uint32_t)(*((const uint8_t *)(tptr+4) + 1)) << 16) | ((uint32_t)(*((const uint8_t *)(tptr+4) + 2)) << 8) | ((uint32_t)(*((const uint8_t *)(tptr+4) + 3)) << 0))))ISIS_SUBTLV_EXTD_IP_REACH_MGMT_PREFIX_COLORISIS_SUBTLV_EXTD_IP_REACH_ADMIN_TAG32, 0x%08x (=%u)ISIS_SUBTLV_EXTD_IP_REACH_ADMIN_TAG64, 0x%08x%08x(ndo, "%s", ident)isis_print_tlv_ip_reachconst isis_tlv_ip_reachconst isis_tlv_ip_reach *isis_tlv_ip_reach *tlv_ip_reach(ndo, "short IPv4 Reachability (%d vs %lu)", length, (unsigned long)sizeof(*tlv_ip_reach))*tlv_ip_reachsizeof(*tlv_ip_reach)tlv_ip_reach->mask(ndo, "%sIPv4 prefix: %s mask %s", ident, ipaddr_string(ndo, (tlv_ip_reach->prefix)), ipaddr_string(ndo, (tlv_ip_reach->mask)))(ndo, "%sIPv4 prefix: %s mask %s", ident, getname(ndo, (const u_char *)((tlv_ip_reach->prefix))), getname(ndo, (const u_char *)((tlv_ip_reach->mask))))(tlv_ip_reach->prefix)(tlv_ip_reach->mask)(ndo, "%sIPv4 prefix: %15s/%u", ident, ipaddr_string(ndo, (tlv_ip_reach->prefix)), prefix_len)(ndo, "%sIPv4 prefix: %15s/%u", ident, getname(ndo, (const u_char *)((tlv_ip_reach->prefix))), prefix_len)(ndo, ", Distribution: %s, Metric: %u, %s", ISIS_LSP_TLV_METRIC_UPDOWN(tlv_ip_reach->isis_metric_block.metric_default) ? "down" : "up", ISIS_LSP_TLV_METRIC_VALUE(tlv_ip_reach->isis_metric_block.metric_default), ISIS_LSP_TLV_METRIC_IE(tlv_ip_reach->isis_metric_block.metric_default) ? "External" : "Internal")(ndo, ", Distribution: %s, Metric: %u, %s", ((tlv_ip_reach->isis_metric_block.metric_default)&0x80) ? "down" : "up", ((tlv_ip_reach->isis_metric_block.metric_default)&0x3f), ((tlv_ip_reach->isis_metric_block.metric_default)&0x40) ? "External" : "Internal")tlv_ip_reach->isis_metric_block.metric_defaulttlv_ip_reach->isis_metric_block.metric_delay(ndo, "%s  Delay Metric: %u, %s", ident, ISIS_LSP_TLV_METRIC_VALUE(tlv_ip_reach->isis_metric_block.metric_delay), ISIS_LSP_TLV_METRIC_IE(tlv_ip_reach->isis_metric_block.metric_delay) ? "External" : "Internal")(ndo, "%s  Delay Metric: %u, %s", ident, ((tlv_ip_reach->isis_metric_block.metric_delay)&0x3f), ((tlv_ip_reach->isis_metric_block.metric_delay)&0x40) ? "External" : "Internal")tlv_ip_reach->isis_metric_block.metric_expense(ndo, "%s  Expense Metric: %u, %s", ident, ISIS_LSP_TLV_METRIC_VALUE(tlv_ip_reach->isis_metric_block.metric_expense), ISIS_LSP_TLV_METRIC_IE(tlv_ip_reach->isis_metric_block.metric_expense) ? "External" : "Internal")(ndo, "%s  Expense Metric: %u, %s", ident, ((tlv_ip_reach->isis_metric_block.metric_expense)&0x3f), ((tlv_ip_reach->isis_metric_block.metric_expense)&0x40) ? "External" : "Internal")tlv_ip_reach->isis_metric_block.metric_error(ndo, "%s  Error Metric: %u, %s", ident, ISIS_LSP_TLV_METRIC_VALUE(tlv_ip_reach->isis_metric_block.metric_error), ISIS_LSP_TLV_METRIC_IE(tlv_ip_reach->isis_metric_block.metric_error) ? "External" : "Internal")(ndo, "%s  Error Metric: %u, %s", ident, ((tlv_ip_reach->isis_metric_block.metric_error)&0x3f), ((tlv_ip_reach->isis_metric_block.metric_error)&0x40) ? "External" : "Internal")short IPv4 Reachability (%d vs %lu)%sIPv4 prefix: %s mask %s, Distribution: %s, Metric: %u, %s%s  Delay Metric: %u, %s%s  Expense Metric: %u, %s%s  Error Metric: %u, %ssizeof(struct isis_tlv_ip_reach)isis_print_metric_block(ndo, ", Default Metric: %d, %s", ISIS_LSP_TLV_METRIC_VALUE(isis_metric_block->metric_default), ISIS_LSP_TLV_METRIC_IE(isis_metric_block->metric_default) ? "External" : "Internal")(ndo, ", Default Metric: %d, %s", ((isis_metric_block->metric_default)&0x3f), ((isis_metric_block->metric_default)&0x40) ? "External" : "Internal"), Default Metric: %d, %sisis_metric_block->metric_defaultisis_metric_block->metric_delay(ndo, "\n\t\t  Delay Metric: %d, %s", ISIS_LSP_TLV_METRIC_VALUE(isis_metric_block->metric_delay), ISIS_LSP_TLV_METRIC_IE(isis_metric_block->metric_delay) ? "External" : "Internal")(ndo, "\n\t\t  Delay Metric: %d, %s", ((isis_metric_block->metric_delay)&0x3f), ((isis_metric_block->metric_delay)&0x40) ? "External" : "Internal")
		  Delay Metric: %d, %sisis_metric_block->metric_expense(ndo, "\n\t\t  Expense Metric: %d, %s", ISIS_LSP_TLV_METRIC_VALUE(isis_metric_block->metric_expense), ISIS_LSP_TLV_METRIC_IE(isis_metric_block->metric_expense) ? "External" : "Internal")(ndo, "\n\t\t  Expense Metric: %d, %s", ((isis_metric_block->metric_expense)&0x3f), ((isis_metric_block->metric_expense)&0x40) ? "External" : "Internal")
		  Expense Metric: %d, %sisis_metric_block->metric_error(ndo, "\n\t\t  Error Metric: %d, %s", ISIS_LSP_TLV_METRIC_VALUE(isis_metric_block->metric_error), ISIS_LSP_TLV_METRIC_IE(isis_metric_block->metric_error) ? "External" : "Internal")(ndo, "\n\t\t  Error Metric: %d, %s", ((isis_metric_block->metric_error)&0x3f), ((isis_metric_block->metric_error)&0x40) ? "External" : "Internal")
		  Error Metric: %d, %sisis_print_idsizeof("xxxx.xxxx.xxxx.yy-zz")sysid_lensizeof(id) - (pos - id)"%02x", *cp++".%02x", *cp++.%02x"-%02x", *cp-%02xisis_print_mt_capability_subtlvstlv_typestlv_len(ndo, "\n\t      %s subTLV #%u, length: %u", tok2str(isis_mt_capability_subtlv_values, "unknown", stlv_type), stlv_type, stlv_len)(ndo, "\n\t        CIST Root-ID: %08x", EXTRACT_32BITS(tptr))(ndo, "\n\t        CIST Root-ID: %08x", ((uint32_t)(((uint32_t)(*((const uint8_t *)(tptr) + 0)) << 24) | ((uint32_t)(*((const uint8_t *)(tptr) + 1)) << 16) | ((uint32_t)(*((const uint8_t *)(tptr) + 2)) << 8) | ((uint32_t)(*((const uint8_t *)(tptr) + 3)) << 0))))(ndo, " %08x", EXTRACT_32BITS(tptr))(ndo, " %08x", ((uint32_t)(((uint32_t)(*((const uint8_t *)(tptr) + 0)) << 24) | ((uint32_t)(*((const uint8_t *)(tptr) + 1)) << 16) | ((uint32_t)(*((const uint8_t *)(tptr) + 2)) << 8) | ((uint32_t)(*((const uint8_t *)(tptr) + 3)) << 0))))(ndo, ", Path Cost: %08x", EXTRACT_32BITS(tptr))(ndo, ", Path Cost: %08x", ((uint32_t)(((uint32_t)(*((const uint8_t *)(tptr) + 0)) << 24) | ((uint32_t)(*((const uint8_t *)(tptr) + 1)) << 16) | ((uint32_t)(*((const uint8_t *)(tptr) + 2)) << 8) | ((uint32_t)(*((const uint8_t *)(tptr) + 3)) << 0))))(ndo, ", Prio: %d", EXTRACT_16BITS(tptr))(ndo, ", Prio: %d", ((uint16_t)(((uint16_t)(*((const uint8_t *)(tptr) + 0)) << 8) | ((uint16_t)(*((const uint8_t *)(tptr) + 1)) << 0))))(ndo, "\n\t        RES: %d", EXTRACT_16BITS(tptr) >> 5)(ndo, "\n\t        RES: %d", ((uint16_t)(((uint16_t)(*((const uint8_t *)(tptr) + 0)) << 8) | ((uint16_t)(*((const uint8_t *)(tptr) + 1)) << 0))) >> 5)(ndo, ", V: %d", (EXTRACT_16BITS(tptr) >> 4) & 0x0001)(ndo, ", V: %d", (((uint16_t)(((uint16_t)(*((const uint8_t *)(tptr) + 0)) << 8) | ((uint16_t)(*((const uint8_t *)(tptr) + 1)) << 0))) >> 4) & 0x0001)(ndo, ", SPSource-ID: %d", (EXTRACT_32BITS(tptr) & 0x000fffff))(ndo, ", SPSource-ID: %d", (((uint32_t)(((uint32_t)(*((const uint8_t *)(tptr) + 0)) << 24) | ((uint32_t)(*((const uint8_t *)(tptr) + 1)) << 16) | ((uint32_t)(*((const uint8_t *)(tptr) + 2)) << 8) | ((uint32_t)(*((const uint8_t *)(tptr) + 3)) << 0))) & 0x000fffff))(ndo, ", No of Trees: %x", *(tptr))(ndo, "\n\t         U:%d, M:%d, A:%d, RES:%d", *(tptr) >> 7, (*(tptr) >> 6) & 0x01, (*(tptr) >> 5) & 0x01, (*(tptr) & 0x1f))(ndo, ", ECT: %08x", EXTRACT_32BITS(tptr))(ndo, ", ECT: %08x", ((uint32_t)(((uint32_t)(*((const uint8_t *)(tptr) + 0)) << 24) | ((uint32_t)(*((const uint8_t *)(tptr) + 1)) << 16) | ((uint32_t)(*((const uint8_t *)(tptr) + 2)) << 8) | ((uint32_t)(*((const uint8_t *)(tptr) + 3)) << 0))))(ndo, ", BVID: %d, SPVID: %d", (EXTRACT_24BITS(tptr) >> 12) & 0x000fff, EXTRACT_24BITS(tptr) & 0x000fff)(ndo, ", BVID: %d, SPVID: %d", (((uint32_t)(((uint32_t)(*((const uint8_t *)(tptr) + 0)) << 16) | ((uint32_t)(*((const uint8_t *)(tptr) + 1)) << 8) | ((uint32_t)(*((const uint8_t *)(tptr) + 2)) << 0))) >> 12) & 0x000fff, ((uint32_t)(((uint32_t)(*((const uint8_t *)(tptr) + 0)) << 16) | ((uint32_t)(*((const uint8_t *)(tptr) + 1)) << 8) | ((uint32_t)(*((const uint8_t *)(tptr) + 2)) << 0))) & 0x000fff)(ndo, "\n\t        BMAC: %08x", EXTRACT_32BITS(tptr))(ndo, "\n\t        BMAC: %08x", ((uint32_t)(((uint32_t)(*((const uint8_t *)(tptr) + 0)) << 24) | ((uint32_t)(*((const uint8_t *)(tptr) + 1)) << 16) | ((uint32_t)(*((const uint8_t *)(tptr) + 2)) << 8) | ((uint32_t)(*((const uint8_t *)(tptr) + 3)) << 0))))(ndo, "%04x", EXTRACT_16BITS(tptr))(ndo, "%04x", ((uint16_t)(((uint16_t)(*((const uint8_t *)(tptr) + 0)) << 8) | ((uint16_t)(*((const uint8_t *)(tptr) + 1)) << 0))))(ndo, ", RES: %d, VID: %d", EXTRACT_16BITS(tptr) >> 12, (EXTRACT_16BITS(tptr)) & 0x0fff)(ndo, ", RES: %d, VID: %d", ((uint16_t)(((uint16_t)(*((const uint8_t *)(tptr) + 0)) << 8) | ((uint16_t)(*((const uint8_t *)(tptr) + 1)) << 0))) >> 12, (((uint16_t)(((uint16_t)(*((const uint8_t *)(tptr) + 0)) << 8) | ((uint16_t)(*((const uint8_t *)(tptr) + 1)) << 0)))) & 0x0fff)(ndo, "\n\t        T: %d, R: %d, RES: %d, ISID: %d", (EXTRACT_32BITS(tptr) >> 31), (EXTRACT_32BITS(tptr) >> 30) & 0x01, (EXTRACT_32BITS(tptr) >> 24) & 0x03f, (EXTRACT_32BITS(tptr)) & 0x0ffffff)(ndo, "\n\t        T: %d, R: %d, RES: %d, ISID: %d", (((uint32_t)(((uint32_t)(*((const uint8_t *)(tptr) + 0)) << 24) | ((uint32_t)(*((const uint8_t *)(tptr) + 1)) << 16) | ((uint32_t)(*((const uint8_t *)(tptr) + 2)) << 8) | ((uint32_t)(*((const uint8_t *)(tptr) + 3)) << 0))) >> 31), (((uint32_t)(((uint32_t)(*((const uint8_t *)(tptr) + 0)) << 24) | ((uint32_t)(*((const uint8_t *)(tptr) + 1)) << 16) | ((uint32_t)(*((const uint8_t *)(tptr) + 2)) << 8) | ((uint32_t)(*((const uint8_t *)(tptr) + 3)) << 0))) >> 30) & 0x01, (((uint32_t)(((uint32_t)(*((const uint8_t *)(tptr) + 0)) << 24) | ((uint32_t)(*((const uint8_t *)(tptr) + 1)) << 16) | ((uint32_t)(*((const uint8_t *)(tptr) + 2)) << 8) | ((uint32_t)(*((const uint8_t *)(tptr) + 3)) << 0))) >> 24) & 0x03f, (((uint32_t)(((uint32_t)(*((const uint8_t *)(tptr) + 0)) << 24) | ((uint32_t)(*((const uint8_t *)(tptr) + 1)) << 16) | ((uint32_t)(*((const uint8_t *)(tptr) + 2)) << 8) | ((uint32_t)(*((const uint8_t *)(tptr) + 3)) << 0)))) & 0x0ffffff)
	      %s subTLV #%u, length: %uISIS_SUBTLV_SPB_INSTANCEISIS_SUBTLV_SPB_INSTANCE_MIN_LEN
	        CIST Root-ID: %08x, Path Cost: %08x, Prio: %d
	        RES: %d, V: %disis_metric_block, SPSource-ID: %d, No of Trees: %xISIS_SUBTLV_SPB_INSTANCE_VLAN_TUPLE_LEN
	         U:%d, M:%d, A:%d, RES:%d, ECT: %08x, BVID: %d, SPVID: %dISIS_SUBTLV_SPBM_SI
	        BMAC: %08x, RES: %d, VID: %d
	        T: %d, R: %d, RES: %d, ISID: %disis_print_mt_port_cap_subtlvconst isis_subtlv_spb_mcidconst isis_subtlv_spb_mcid *isis_subtlv_spb_mcid *subtlv_spb_mcid(ndo, "\n\t       %s subTLV #%u, length: %u", tok2str(isis_mt_port_cap_subtlv_values, "unknown", stlv_type), stlv_type, stlv_len)(ndo, "\n\t         MCID: ")(ndo, "\n\t         AUX-MCID: ")(ndo, "\n\t        RES: %d V: %d A: %d D: %d", (*(tptr) >> 5), (((*tptr)>> 4) & 0x01), ((*(tptr) >> 2) & 0x03), ((*tptr) & 0x03))(ndo, "\n\t         Digest: ")(ndo, "%08x ", EXTRACT_32BITS(tptr))(ndo, "%08x ", ((uint32_t)(((uint32_t)(*((const uint8_t *)(tptr) + 0)) << 24) | ((uint32_t)(*((const uint8_t *)(tptr) + 1)) << 16) | ((uint32_t)(*((const uint8_t *)(tptr) + 2)) << 8) | ((uint32_t)(*((const uint8_t *)(tptr) + 3)) << 0))))(ndo, "\n\t                 ")(ndo, "\n\t           ECT: %08x", EXTRACT_32BITS(tptr))(ndo, "\n\t           ECT: %08x", ((uint32_t)(((uint32_t)(*((const uint8_t *)(tptr) + 0)) << 24) | ((uint32_t)(*((const uint8_t *)(tptr) + 1)) << 16) | ((uint32_t)(*((const uint8_t *)(tptr) + 2)) << 8) | ((uint32_t)(*((const uint8_t *)(tptr) + 3)) << 0))))(ndo, " BVID: %d, U:%01x M:%01x ", (EXTRACT_16BITS (tptr) >> 4) , (EXTRACT_16BITS (tptr) >> 3) & 0x01, (EXTRACT_16BITS (tptr) >> 2) & 0x01)(ndo, " BVID: %d, U:%01x M:%01x ", (((uint16_t)(((uint16_t)(*((const uint8_t *)(tptr) + 0)) << 8) | ((uint16_t)(*((const uint8_t *)(tptr) + 1)) << 0))) >> 4) , (((uint16_t)(((uint16_t)(*((const uint8_t *)(tptr) + 0)) << 8) | ((uint16_t)(*((const uint8_t *)(tptr) + 1)) << 0))) >> 3) & 0x01, (((uint16_t)(((uint16_t)(*((const uint8_t *)(tptr) + 0)) << 8) | ((uint16_t)(*((const uint8_t *)(tptr) + 1)) << 0))) >> 2) & 0x01)
	       %s subTLV #%u, length: %uISIS_SUBTLV_SPB_MCIDISIS_SUBTLV_SPB_MCID_MIN_LEN
	         MCID: const isis_spb_mcidconst isis_spb_mcid *isis_spb_mcid *
	         AUX-MCID: ISIS_SUBTLV_SPB_DIGESTISIS_SUBTLV_SPB_DIGEST_MIN_LEN
	        RES: %d V: %d A: %d D: %d
	         Digest: %08x 
	                 ISIS_SUBTLV_SPB_BVIDISIS_SUBTLV_SPB_BVID_MIN_LEN
	           ECT: %08x BVID: %d, U:%01x M:%01x isis_print_mcid*mcidsizeof(*mcid)(ndo, "ID: %d, Name: ", mcid->format_id)ID: %d, Name: uint8_t[32]unsigned char[32](ndo, "\n\t              Lvl: %d", EXTRACT_16BITS(mcid->revision_lvl))(ndo, "\n\t              Lvl: %d", ((uint16_t)(((uint16_t)(*((const uint8_t *)(mcid->revision_lvl) + 0)) << 8) | ((uint16_t)(*((const uint8_t *)(mcid->revision_lvl) + 1)) << 0))))
	              Lvl: %dmcid->revision_lvl(ndo, ", Digest: "), Digest: (ndo, "%.2x ", mcid->digest[i])%.2x mcidesis_printliesis_pdu_typesource_address_lengthsource_address_numberconst esis_header_tconst esis_header_t *esis_header_t *esis_header(ndo, "ES-IS")(ndo, ndo->ndo_qflag ? "bad pkt!" : "no header at all!")bad pkt!no header at all!*esis_headersizeof(*esis_header)(ndo, " nlpid 0x%02x packet not supported", esis_header->nlpid) nlpid 0x%02x packet not supported(ndo, " version %d packet not supported", esis_header->version)ESIS_VERSION version %d packet not supported(ndo, " length indicator(%u) > PDU size (%u)!", li, length) length indicator(%u) > PDU size (%u)!(ndo, " length indicator %u < min PDU size:", li)(ndo, "%02X", *pptr++)sizeof(struct esis_header_t)sizeof(struct esis_header_t) + 2 length indicator %u < min PDU size:ESIS_PDU_TYPE_MASK(ndo, "%s%s, length %u", ndo->ndo_eflag ? "" : ", ", tok2str(esis_pdu_values,"unknown type (%u)",esis_pdu_type), length)(ndo, "%slength %u\n\t%s (%u)", ndo->ndo_eflag ? "" : ", ", length, tok2str(esis_pdu_values,"unknown type: %u", esis_pdu_type), esis_pdu_type)%s%s, length %uunknown type (%u)%slength %u
	%s (%u)unknown type: %u(ndo, ", v: %u%s", esis_header->version, esis_header->version == ESIS_VERSION ? "" : "unsupported" )(ndo, ", v: %u%s", esis_header->version, esis_header->version == 1 ? "" : "unsupported" ), v: %u%sunsupported(ndo, ", checksum: 0x%04x", EXTRACT_16BITS(esis_header->cksum))(ndo, ", checksum: 0x%04x", ((uint16_t)(((uint16_t)(*((const uint8_t *)(esis_header->cksum) + 0)) << 8) | ((uint16_t)(*((const uint8_t *)(esis_header->cksum) + 1)) << 0)))), checksum: 0x%04xesis_header->cksum(ndo, ", holding time: %us, length indicator: %u", EXTRACT_16BITS(esis_header->holdtime), li)(ndo, ", holding time: %us, length indicator: %u", ((uint16_t)(((uint16_t)(*((const uint8_t *)(esis_header->holdtime) + 0)) << 8) | ((uint16_t)(*((const uint8_t *)(esis_header->holdtime) + 1)) << 0))), li), holding time: %us, length indicator: %uesis_header->holdtimesizeof(*pptr)(ndo, ", bad redirect/li")dstl(ndo, "\n\t  %s", isonsap_string(ndo, dst, dstl))snpalnetal(ndo, "\n\t  SNPA (length: %u): %s", snpal, etheraddr_string(ndo, snpa))(ndo, "\n\t  SNPA (length: %u): %s", snpal, linkaddr_string(ndo, snpa, LINKADDR_OTHER, snpal))(ndo, "\n\t  NET (length: %u) %s", netal, isonsap_string(ndo, neta, netal))(ndo, ", bad esh/li")(ndo, "\n\t  Number of Source Addresses: %u", source_address_number)(ndo, "\n\t  NET (length: %u): %s", source_address_length, isonsap_string(ndo, pptr, source_address_length))(ndo, ", bad ish/li")ESIS_PDU_REDIRECTneta, bad redirect/li
	  %s
	  SNPA (length: %u): %s
	  NET (length: %u) %sESIS_PDU_ESH, bad esh/li
	  Number of Source Addresses: %u
	  NET (length: %u): %sESIS_PDU_ISH, bad ish/li(ndo, ", bad opts/li")(ndo, ", opt (%d) too long", op)(ndo, "\n\t  %s Option #%u, length %u, value: ", tok2str(esis_option_values,"Unknown",op), op, opli)(ndo, "%us", EXTRACT_16BITS(tptr))(ndo, "%us", ((uint16_t)(((uint16_t)(*((const uint8_t *)(tptr) + 0)) << 8) | ((uint16_t)(*((const uint8_t *)(tptr) + 1)) << 0))))(ndo, "(bad length)")opli, bad opts/li, opt (%d) too long
	  %s Option #%u, length %u, value: 198ESIS_OPTION_ES_CONF_TIME(bad length)ESIS_OPTION_PROTOCOLSESIS_OPTION_QOS_MAINTENANCE197ESIS_OPTION_SECURITY205ESIS_OPTION_PRIORITY225ESIS_OPTION_ADDRESS_MASK226ESIS_OPTION_SNPA_MASK(ndo, "[|esis]")[|esis]clnp_printsource_addressdest_addressnsap_offsetdest_address_lengthclnp_pdu_typeclnp_flagsconst clnp_header_tconst clnp_header_t *clnp_header_t *clnp_headerconst clnp_segment_header_tconst clnp_segment_header_t *clnp_segment_header_t *clnp_segment_headerrfd_error_majorrfd_error_minor*clnp_headersizeof(*clnp_header)(ndo, "CLNP")(ndo, "version %d packet not supported", clnp_header->version)CLNP_VERSIONsizeof(struct clnp_header_t)CLNP_PDU_TYPE_MASKCLNP_FLAG_MASK(ndo, "li < size of fixed part of CLNP header and addresses")li < size of fixed part of CLNP header and addresses(ndo, "%s%s > %s, %s, length %u", ndo->ndo_eflag ? "" : ", ", isonsap_string(ndo, source_address, source_address_length), isonsap_string(ndo, dest_address, dest_address_length), tok2str(clnp_pdu_values,"unknown (%u)",clnp_pdu_type), length)%s%s > %s, %s, length %u(ndo, "\n\t%s PDU, hlen: %u, v: %u, lifetime: %u.%us, Segment PDU length: %u, checksum: 0x%04x", tok2str(clnp_pdu_values, "unknown (%u)",clnp_pdu_type), clnp_header->length_indicator, clnp_header->version, clnp_header->lifetime/2, (clnp_header->lifetime%2)*5, EXTRACT_16BITS(clnp_header->segment_length), EXTRACT_16BITS(clnp_header->cksum))(ndo, "\n\t%s PDU, hlen: %u, v: %u, lifetime: %u.%us, Segment PDU length: %u, checksum: 0x%04x", tok2str(clnp_pdu_values, "unknown (%u)",clnp_pdu_type), clnp_header->length_indicator, clnp_header->version, clnp_header->lifetime/2, (clnp_header->lifetime%2)*5, ((uint16_t)(((uint16_t)(*((const uint8_t *)(clnp_header->segment_length) + 0)) << 8) | ((uint16_t)(*((const uint8_t *)(clnp_header->segment_length) + 1)) << 0))), ((uint16_t)(((uint16_t)(*((const uint8_t *)(clnp_header->cksum) + 0)) << 8) | ((uint16_t)(*((const uint8_t *)(clnp_header->cksum) + 1)) << 0))))
	%s PDU, hlen: %u, v: %u, lifetime: %u.%us, Segment PDU length: %u, checksum: 0x%04xclnp_header->segment_lengthclnp_header->cksum(ndo, "\n\tFlags [%s]", bittok2str(clnp_flag_values, "none", clnp_flags))
	Flags [%s](ndo, "\n\tsource address (length %u): %s\n\tdest   address (length %u): %s", source_address_length, isonsap_string(ndo, source_address, source_address_length), dest_address_length, isonsap_string(ndo, dest_address, dest_address_length))
	source address (length %u): %s
	dest   address (length %u): %s(ndo, "li < size of fixed part of CLNP header, addresses, and segment part")*clnp_segment_headersizeof(*clnp_segment_header)(ndo, "\n\tData Unit ID: 0x%04x, Segment Offset: %u, Total PDU Length: %u", EXTRACT_16BITS(clnp_segment_header->data_unit_id), EXTRACT_16BITS(clnp_segment_header->segment_offset), EXTRACT_16BITS(clnp_segment_header->total_length))(ndo, "\n\tData Unit ID: 0x%04x, Segment Offset: %u, Total PDU Length: %u", ((uint16_t)(((uint16_t)(*((const uint8_t *)(clnp_segment_header->data_unit_id) + 0)) << 8) | ((uint16_t)(*((const uint8_t *)(clnp_segment_header->data_unit_id) + 1)) << 0))), ((uint16_t)(((uint16_t)(*((const uint8_t *)(clnp_segment_header->segment_offset) + 0)) << 8) | ((uint16_t)(*((const uint8_t *)(clnp_segment_header->segment_offset) + 1)) << 0))), ((uint16_t)(((uint16_t)(*((const uint8_t *)(clnp_segment_header->total_length) + 0)) << 8) | ((uint16_t)(*((const uint8_t *)(clnp_segment_header->total_length) + 1)) << 0))))clnp_segment_header->data_unit_idclnp_segment_header->segment_offsetclnp_segment_header->total_lengthCLNP_SEGMENT_PARTsizeof(const struct clnp_segment_header_t)li < size of fixed part of CLNP header, addresses, and segment part
	Data Unit ID: 0x%04x, Segment Offset: %u, Total PDU Length: %u(ndo, "\n\t  %s Option #%u, length %u, value: ", tok2str(clnp_option_values,"Unknown",op), op, opli)(ndo, ", bad opt len")(ndo, "%s %s", tok2str(clnp_option_sr_rr_values,"Unknown",*tptr), tok2str(clnp_option_sr_rr_string_values, "Unknown Option %u", op))(ndo, " Bad NSAP offset (0)")(ndo, " Bad NSAP offset (past end of option)")(ndo, "\n\t    NSAP address goes past end of option")*source_address(ndo, "\n\t    NSAP address (length %u): %s", source_address_length, isonsap_string(ndo, source_address, source_address_length))(ndo, "0x%1x", *tptr&0x0f)(ndo, "\n\t    Format Code: %s", tok2str(clnp_option_scope_values, "Reserved", *tptr&CLNP_OPTION_SCOPE_MASK))(ndo, "\n\t    Format Code: %s", tok2str(clnp_option_scope_values, "Reserved", *tptr&0xc0))(ndo, "\n\t    QoS Flags [%s]", bittok2str(clnp_option_qos_global_values, "none", *tptr&CLNP_OPTION_OPTION_QOS_MASK))(ndo, "\n\t    QoS Flags [%s]", bittok2str(clnp_option_qos_global_values, "none", *tptr&0x3f))(ndo, "\n\t    Format Code: %s, Security-Level %u", tok2str(clnp_option_scope_values,"Reserved",*tptr&CLNP_OPTION_SCOPE_MASK), *(tptr+1))(ndo, "\n\t    Format Code: %s, Security-Level %u", tok2str(clnp_option_scope_values,"Reserved",*tptr&0xc0), *(tptr+1))(ndo, "\n\t    Class: %s Error (0x%01x), %s (0x%01x)", tok2str(clnp_option_rfd_class_values,"Unknown",rfd_error_major), rfd_error_major, tok2str(clnp_option_rfd_error_class[rfd_error_major],"Unknown",rfd_error_minor), rfd_error_minor)(ndo, "padding data")203CLNP_OPTION_ROUTE_RECORDINGCLNP_OPTION_SOURCE_ROUTING, bad opt len%s %sUnknown Option %u Bad NSAP offset (0) Bad NSAP offset (past end of option)
	    NSAP address goes past end of option
	    NSAP address (length %u): %sCLNP_OPTION_PRIORITY0x%1xCLNP_OPTION_QOS_MAINTENANCE
	    Format Code: %sCLNP_OPTION_SCOPE_MASKCLNP_OPTION_SCOPE_GLOBAL
	    QoS Flags [%s]CLNP_OPTION_SECURITY
	    Format Code: %s, Security-Level %uCLNP_OPTION_DISCARD_REASON
	    Class: %s Error (0x%01x), %s (0x%01x)CLNP_OPTION_PADDINGpadding data(ndo, "\n\t-----original packet-----\n\t")(ndo, "\n\t  undecoded non-header data, length %u", length-clnp_header->length_indicator)CLNP_PDU_ERCLNP_PDU_ERP
	-----original packet-----
	CLNP_PDU_DTCLNP_PDU_MDCLNP_PDU_ERQ
	  undecoded non-header data, length %u(ndo, "[|clnp]")[|clnp]isoclns_print(ndo, "|OSI")|OSI(ndo, "OSI NLPID %s (0x%02x): ", tok2str(nlpid_values, "Unknown", *p), *p)OSI NLPID %s (0x%02x): (ndo, "%slength: %u", ndo->ndo_eflag ? "" : ", ", length)(ndo, "OSI NLPID 0x%02x unknown", *p)%slength: %uOSI NLPID 0x%02x unknownesis_header_tclnp_segment_header_tclnp_header_tisis_tlv_lspisis_psnp_headerisis_csnp_headerisis_lsp_headerisis_iih_ptp_headerisis_iih_lan_headerisis_common_headerisis_tlv_ip_reachisis_tlv_es_reachisis_tlv_is_reachisis_tlv_ptp_adjisis_subtlv_spb_instanceisis_subtlv_spb_mcidisis_spb_mcidlength_indicatorsegment_offsetdata_unit_idsegment_lengthlsp_idremaining_lifetimeend_lsp_idstart_lsp_idtypeblockcircuit_idholding_timecircuit_typelan_idpdu_versionfixed_lenneighbor_sysidneighbor_nodeidmetric_errormetric_expensemetric_delaymetric_defaultneighbor_extd_local_circuit_idextd_local_circuit_idadjacency_stateno_of_treesspsourceidbridge_prioritycist_external_root_path_costcist_root_idaux_mciddigestrevision_lvlESH"ESH"ISH"ISH"esis_pdu_valuesError Report"Error Report"Echo Request"Echo Request"Echo Response"Echo Response"clnp_pdu_valuesRestart Request"Restart Request"Restart Acknowledgement"Restart Acknowledgement"Suppress adjacency advertisement"Suppress adjacency advertisement"isis_restart_flag_valuesIsNotVirtual"IsNotVirtual"IsVirtual"IsVirtual"isis_is_reach_virtual_valuesISIS_PTP_ADJ_UPISIS_PTP_ADJ_INITInitializing"Initializing"ISIS_PTP_ADJ_DOWNisis_ptp_adjancey_valuesISIS_LSP_TYPE_UNUSED0Unused 0x0 (invalid)"Unused 0x0 (invalid)"ISIS_LSP_TYPE_LEVEL_1L1 IS"L1 IS"ISIS_LSP_TYPE_UNUSED2Unused 0x2 (invalid)"Unused 0x2 (invalid)"ISIS_LSP_TYPE_LEVEL_2L2 IS"L2 IS"isis_lsp_istype_valuesLevel 1 only"Level 1 only"Level 2 only"Level 2 only"Level 1, Level 2"Level 1, Level 2"isis_iih_circuit_type_valuesIPv4 unicast"IPv4 unicast"In-Band Management"In-Band Management"IPv6 unicast"IPv6 unicast"Development, Experimental or Proprietary"Development, Experimental or Proprietary"isis_mt_valuesATT bit set"ATT bit set"Overload bit set"Overload bit set"isis_mt_flag_valuesSegmentation permitted"Segmentation permitted"CLNP_MORE_SEGMENTSmore Segments"more Segments"CLNP_REQUEST_ERrequest Error Report"request Error Report"clnp_flag_valuesSPB Instance"SPB Instance"SPBM Service Identifier and Unicast Address"SPBM Service Identifier and Unicast Address"isis_mt_capability_subtlv_valuesSPB MCID"SPB MCID"SPB Digest"SPB Digest"SPB BVID"SPB BVID"isis_mt_port_cap_subtlv_valuesRouting-Domain Specific"Routing-Domain Specific"AS Number Tag"AS Number Tag"isis_subtlv_idrp_valuessimple text password"simple text password"Generic Crypto key-id"Generic Crypto key-id"HMAC-MD5 password"HMAC-MD5 password"Routing Domain private password"Routing Domain private password"isis_subtlv_auth_valuesLocal Protection Available"Local Protection Available"Link excluded from local protection path"Link excluded from local protection path"Local maintenance required"Local maintenance required"isis_subtlv_link_attribute_values32-Bit Administrative tag"32-Bit Administrative tag"64-Bit Administrative tag"64-Bit Administrative tag"Management Prefix Color"Management Prefix Color"isis_ext_ip_reach_subtlv_valuesAdministrative groups"Administrative groups"Link Local/Remote Identifier"Link Local/Remote Identifier"Link Remote Identifier"Link Remote Identifier"IPv4 interface address"IPv4 interface address"IPv4 neighbor address"IPv4 neighbor address"Maximum link bandwidth"Maximum link bandwidth"Reservable link bandwidth"Reservable link bandwidth"Unreserved bandwidth"Unreserved bandwidth"Traffic Engineering Metric"Traffic Engineering Metric"Link Attribute"Link Attribute"Link Protection Type"Link Protection Type"Interface Switching Capability"Interface Switching Capability"Bandwidth Constraints (old)"Bandwidth Constraints (old)"Bandwidth Constraints"Bandwidth Constraints"SPB Metric"SPB Metric"Reserved for cisco specific extensions"Reserved for cisco specific extensions"Reserved for future expansion"Reserved for future expansion"isis_ext_is_reach_subtlv_valuessequencing vs. delay"sequencing vs. delay"congested"congested"delay vs. cost"delay vs. cost"error vs. delay"error vs. delay"error vs. cost"error vs. cost"clnp_option_qos_global_valuessource routing"source routing"recording of route in progress"recording of route in progress"clnp_option_sr_rr_string_valuespartial"partial"complete"complete"clnp_option_sr_rr_valuesCLNP_OPTION_SCOPE_SA_SPECSource Address Specific"Source Address Specific"CLNP_OPTION_SCOPE_DA_SPECDestination Address Specific"Destination Address Specific"Globally unique"Globally unique"clnp_option_scope_valuesclnp_option_rfd_error_classReassembly interference"Reassembly interference"clnp_option_rfd_reassembly_valuesUnsupported option not specified"Unsupported option not specified"Unsupported protocol version"Unsupported protocol version"Unsupported security option"Unsupported security option"Unsupported source routeing option"Unsupported source routeing option"Unsupported recording of route option"Unsupported recording of route option"clnp_option_rfd_pdu_discard_valuesLifetime expired while data unit in transit"Lifetime expired while data unit in transit"Lifetime expired during reassembly"Lifetime expired during reassembly"clnp_option_rfd_lifetime_valuesUnspecified source routeing error"Unspecified source routeing error"Syntax error in source routeing field"Syntax error in source routeing field"Unknown address in source routeing field"Unknown address in source routeing field"Path not acceptable"Path not acceptable"clnp_option_rfd_source_routeing_valuesDestination address unreachable"Destination address unreachable"Destination address unknown"Destination address unknown"clnp_option_rfd_address_valuesReason not specified"Reason not specified"Protocol procedure error"Protocol procedure error"Incorrect checksum"Incorrect checksum"PDU discarded due to congestion"PDU discarded due to congestion"Header syntax error (cannot be parsed)"Header syntax error (cannot be parsed)"Segmentation needed but not permitted"Segmentation needed but not permitted"Incomplete PDU received"Incomplete PDU received"Duplicate option"Duplicate option"clnp_option_rfd_general_valuesGeneral"General"Source Routeing"Source Routeing"Lifetime"Lifetime"PDU Discarded"PDU Discarded"Reassembly"Reassembly"clnp_option_rfd_class_valuesDiscard Reason"Discard Reason"Priority"Priority"QoS Maintenance"QoS Maintenance"Security"Security"Source Routing"Source Routing"Route Recording"Route Recording"Padding"Padding"clnp_option_valuesProtocols supported"Protocols supported"ES Configuration Time"ES Configuration Time"Addressk Mask"Addressk Mask"SNPA Mask"SNPA Mask"esis_option_valuesArea address(es)"Area address(es)"IS Reachability"IS Reachability"ES Neighbor(s)"ES Neighbor(s)"Partition DIS"Partition DIS"Prefix Neighbors"Prefix Neighbors"IS Neighbor(s)"IS Neighbor(s)"IS Neighbor(s) (variable length)"IS Neighbor(s) (variable length)"LSP entries"LSP entries"Checksum"Checksum"Purge Originator Identifier"Purge Originator Identifier"LSP Buffersize"LSP Buffersize"Extended IS Reachability"Extended IS Reachability"IS Alias ID"IS Alias ID"DECnet Phase IV"DECnet Phase IV"Lucent Proprietary"Lucent Proprietary"IPv4 Internal Reachability"IPv4 Internal Reachability"IPv4 External Reachability"IPv4 External Reachability"Inter-Domain Information Type"Inter-Domain Information Type"IPv4 Interface address(es)"IPv4 Interface address(es)"IPv4 authentication (deprecated)"IPv4 authentication (deprecated)"Traffic Engineering Router ID"Traffic Engineering Router ID"Extended IPv4 Reachability"Extended IPv4 Reachability"Shared Risk Link Group"Shared Risk Link Group"Multi-Topology-Aware Port Capability"Multi-Topology-Aware Port Capability"Multi-Topology Capability"Multi-Topology Capability"Nortel Proprietary"Nortel Proprietary"Hostname"Hostname"Restart Signaling"Restart Signaling"Multi Topology IS Reachability"Multi Topology IS Reachability"Multi Topology"Multi Topology"IPv6 Interface address(es)"IPv6 Interface address(es)"Multi-Topology IPv4 Reachability"Multi-Topology IPv4 Reachability"IPv6 reachability"IPv6 reachability"Multi-Topology IP6 Reachability"Multi-Topology IP6 Reachability"Point-to-point Adjacency State"Point-to-point Adjacency State"Hello PDU Sequence Number"Hello PDU Sequence Number"Vendor Private"Vendor Private"isis_tlv_valuesL1 Lan IIH"L1 Lan IIH"L2 Lan IIH"L2 Lan IIH"p2p IIH"p2p IIH"L1 LSP"L1 LSP"L2 LSP"L2 LSP"L1 CSNP"L1 CSNP"L2 CSNP"L2 CSNP"L1 PSNP"L1 PSNP"L2 PSNP"L2 PSNP"isis_pdu_values [|isis]" [|isis]"(sizeof(struct isis_psnp_header))(sizeof(struct isis_csnp_header))(sizeof(struct isis_lsp_header))(sizeof(struct isis_iih_ptp_header))(sizeof(struct isis_iih_lan_header))(sizeof(struct isis_common_header))ISIS_MASK_TLV_SHARED_RISK_GROUP(x)((x)&0x1)ISIS_LSP_TLV_METRIC_VALUE(x)((x)&0x3f)ISIS_LSP_TLV_METRIC_UPDOWN(x)((x)&0x80)ISIS_LSP_TLV_METRIC_IE(x)((x)&0x40)ISIS_LSP_TLV_METRIC_SUPPORTED(x)ISIS_MASK_TLV_EXTD_IP6_SUBTLV(x)((x)&0x20)ISIS_MASK_TLV_EXTD_IP6_IE(x)ISIS_MASK_TLV_EXTD_IP_SUBTLV(x)ISIS_MASK_TLV_EXTD_IP_UPDOWN(x)ISIS_MASK_MTFLAGS(x)((x)&0xf000)ISIS_MASK_MTID(x)((x)&0x0fff)ISIS_MASK_LSP_ATT_DEFAULT_BIT(x)((x)&0x8)ISIS_MASK_LSP_ATT_DELAY_BIT(x)((x)&0x10)ISIS_MASK_LSP_ATT_EXPENSE_BIT(x)ISIS_MASK_LSP_ATT_ERROR_BIT(x)ISIS_MASK_LSP_ATT_BITS(x)((x)&0x78)ISIS_MASK_LSP_PARTITION_BIT(x)ISIS_MASK_LSP_ISTYPE_BITS(x)((x)&0x3)ISIS_MASK_LSP_OL_BIT(x)((x)&0x4)ISIS_SPB_MCID_LENCLNP_OPTION_OPTION_QOS_MASKISIS_LAN_PRIORITY_MASK0xE0ISIS_PDU_TYPE_MASKLSP_ID_LENSYSTEM_ID_LEN+2SYSTEM_ID_LEN+1/* do not attempt to verify the checksum if it is zero,
         * if the offset is nonsense,
         * or the base pointer is not sane
         *//* hexdump the rest *//* check if enough byte for a full oui *//* check if four bytes are on the wire *//* read out prefix length in semioctets*//* fetch AS number *//* is there an additional sysid field present ?*//* is there anything other than the flags field? *//* first attempt to decode the flags *//* did something go wrong ? *//* length can only be a multiple of 2, otherwise there is
		   something broken -> so decode down until length is 1 *//* do not attempt to verify the checksum if it is zero
             * most likely a HMAC-MD5 TLV is also present and
             * to avoid conflicts the checksum TLV is zeroed.
             * see rfc3358 for details
             *//* further NPLIDs ? - put comma *//* those two TLVs share the same format *//* check if there is one byte left to read out the virtual flag *//* is it worth attempting a decode ? *//* LAN address length *//* min. TLV length *//* if this is the last area address do not attemt a boundary check *//* now check if we have a decoder otherwise do a hexdump at the end*//* something is invalid *//* first lets see if we know the TLVs name*//* copy temporary len & pointer to packet data *//*
     * Now print the TLV's.
     *//* do TLV decoding as long as it makes sense *//* for optionally debugging the common header *//* provide the _o_riginal pointer *//* in non-verbose mode print the basic PDU Type plus PDU specific brief information*//* toss any non 6-byte sys-ID len PDUs *//* entirely useless *//* 1-8 are valid sys-ID lenghts *//* silly shit again *//* silly shit *//* initialize the _o_riginal pointer to the packet start -
                 need it for parsing the checksum TLV and authentication
                 TLV verification *//*
 * isis_print
 * Decode IS-IS packets.  Return 0 on error.
 *//*
 * Clear checksum and lifetime prior to signature verification.
 *//* prepend the indent string *//* print out subTLV length *//* assume that one prefix can hold more
           than one subTLV - therefore the first byte must reflect
           the aggregate bytecount of the subTLVs for this prefix
        *//* copy as much as is stored in the TLV *//* clear the copy buffer *//* prefix has variable length encoding *//* somebody is fooling us *//* fetch status & prefix_len byte *//* fetch status byte *//* shared copy buffer for IPv4 and IPv6 prefixes *//*
 * this is the common extended IP reach decoder
 * it is called from TLVs (135,235,236,237)
 * we process the TLV and optional subTLVs and return
 * the amount of processed bytes
 *//*
 * this is the common Multi Topology ID decoder
 * it is called from various MT-TLVs (222,229,235,237)
 *//* read out subTLV length *//* and is therefore skipped *//* the Alias TLV Metric field is implicit 0 *//* how many bytes did we process ? *//*
 * this is the common IS-REACH decoder it is called
 * from various EXTD-IS REACH style TLVs (22,24,222)
 *//* there is some optional stuff left to decode but this is as of yet
                   not specified so just lets hexdump what is left *//* decode BCs until the subTLV ends *//* first lets see if we know the subTLVs name*//* int to float conversion buffer for several subTLVs *//*
 * this is the common IS-REACH subTLV decoder it is called
 * from isis_print_ext_is_reach()
 *//*
 * this is the common IP-REACH subTLV decoder it is called
 * from various EXTD-IP REACH TLVs (135,235,236,237)
 *//* everything is ok *//* print the 4-byte metric block which is common found in the old-style TLVs *//* shared routine for printing system, node and lsp-ids *//* Make sure the entire subTLV is in the captured data *//* Make sure the subTLV fits within the space left *//*tptr += SPB_MCID_MIN_LEN;
            len -= SPB_MCID_MIN_LEN; *//*len -= TLV_TYPE_LEN_OFFSET;*//*
                 * FIXME those are the defined Options that lack a decoder
                 * you are welcome to contribute code ;-)
                 *//* now walk the options *//*
         * Sanity checking of the header.
         *//* dump the PDU specific data *//* FIXME recursion protection *//* offset to nsap list *//* those two options share the format *//*
             * We've already checked that the entire option is present
             * in the captured packet with the ND_TCHECK2() call.
             * Therefore, we don't need to do ND_TCHECK()/ND_TCHECK2()
             * checks.
             * We do, however, need to check tlen, to make sure we
             * don't run past the end of the option.
	     *//* FIXME further header sanity checking *//*
 * clnp_print
 * Decode CLNP packets.  Return 0 on error.
 *//* units of 500ms *//* enough bytes on the wire ? *//* Packet format version *//* 3 MSbits are reserved *//* Protocol version *//*
 * Katz's point to point adjacency TLV uses codes to tell us the state of
 * the remote adjacency.  Enumerate them.
 *//* rfc 5310 *//* draft-ietf-isis-wg-multi-topology-05 *//* draft-ietf-isis-admin-tags-01 *//* rfc6329 *//* rfc4124 *//* draft-ietf-isis-link-attr-01 *//* draft-ietf-isis-traffic-05 *//* draft-ietf-tewg-diff-te-proto-06 *//* array of 16 error-classes *//* iso8473 *//* iso9542 *//* draft-ietf-isis-experimental-tlv-01 *//* draft-shen-isis-iih-sequence-00 *//* rfc3373 *//* draft-ietf-isis-ipv6-02 *//* rfc3847 *//* rfc6165 *//* draft-ietf-isis-gmpls-extensions *//* rfc2763 *//* rfc1195 *//* rfc1195, rfc2966 *//* draft-ietf-isis-ext-lsp-frags-02 *//* iso10589 rev2 *//* rfc6232 *//* rfc3358 *//* iso10589, rfc3567 *//* iso10589 *//*
 * A TLV is a tuple of a type, length and a value and is normally used for
 * encoding information in all sorts of places.  This is an enumeration of
 * the well known types.
 *
 * list taken from rfc3359 plus some memory from veterans ;-)
 *//*
 * IS-IS is defined in ISO 10589.  Look there for protocol definitions.
 *//* \summary: ISO CLNS, ESIS, and ISIS printer *//*
 * Copyright (c) 1992, 1993, 1994, 1995, 1996
 *	The Regents of the University of California.  All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that: (1) source code distributions
 * retain the above copyright notice and this paragraph in its entirety, (2)
 * distributions including binary code include the above copyright notice and
 * this paragraph in its entirety in the documentation or other materials
 * provided with the distribution, and (3) all advertising materials mentioning
 * features or use of this software display the following acknowledgement:
 * ``This product includes software developed by the University of California,
 * Lawrence Berkeley Laboratory and its contributors.'' Neither the name of
 * the University nor the names of its contributors may be used to endorse
 * or promote products derived from this software without specific prior
 * written permission.
 * THIS SOFTWARE IS PROVIDED ``AS IS'' AND WITHOUT ANY EXPRESS OR IMPLIED
 * WARRANTIES, INCLUDING, WITHOUT LIMITATION, THE IMPLIED WARRANTIES OF
 * MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE.
 *
 * Original code by Matt Thomas, Digital Equipment Corporation
 *
 * Extensively modified by Hannes Gredler (hannes@gredler.at) for more
 * complete IS-IS & CLNP support.
 *//Users/owura/Repos/codeql_eval/proj_repos/the-tcpdump-group-tcpdump-commit-9ba91381954ad325ea4fd26b9c65a8bd9a2a85b6/tcpdump/ppp.hPPP_EAP0xc227PPP_SPAP_OLD0xc123PPP_MPCP0xc03dPPP_BAP0xc02dPPP_BACP0xc02bPPP_CHAP0xc223PPP_SPAP0xc027PPP_LQM0xc025PPP_PAP0xc023PPP_LCP0xc021PPP_MPLSCP0x8281PPP_CCP0x80fdPPP_IPV6CP0x8057PPP_VINESCPPPP_STIICP0x8033PPP_IPXCP0x802bPPP_APPLECP0x8029PPP_DECNETCP0x8027PPP_NSCP0x8025PPP_OSICP0x8023PPP_IPCP0x8021PPP_MPLS_MCAST0x0283PPP_MPLS_UCAST0x0281PPP_SNSPPP_LUXCOM0x0231PPP_HELLO0x0201PPP_COMP0x00fdPPP_IPV60x0057PPP_ML0x003dPPP_VINES0x0035PPP_STII0x0033PPP_BRPDU0x0031PPP_VJNC0x002fPPP_VJCPPP_IPX0x002bPPP_APPLEPPP_DECNETPPP_NS0x0025PPP_OSIPPP_IPPPP_WITHDIRECTION_OUTPPP_WITHDIRECTION_INPPP_CONTROLPPP_ADDRESSPPP_HDRLEN/* Multi-Link *//* BAP *//* Bandwidth Allocation Control Protocol *//* Challenge Handshake Authentication Protocol *//* Link Quality Monitoring *//* Password Authentication Protocol *//* Link Control Protocol *//* rfc 3022 *//* Compress Control Protocol *//* IPv6 Control Protocol *//* Banyan Vines Control Protocol *//* Strean Protocol Control Protocol *//* Novell IPX Control Protocol *//* Appletalk Control Protocol *//* DECnet Control Protocol *//* Xerox NS IDP Control Protocol *//* OSI Network Layer Control Protocol *//* IP Control Protocol *//* rfc 3032 *//* Sigma Network Systems *//* Luxcom *//* 802.1d Hello Packets *//* Compressed Datagram *//* Multi-Link PPP *//* Stream Protocol (ST-II) *//* Bridging PDU *//* Van Jacobson Uncompressed TCP/IP *//* Van Jacobson Compressed TCP/IP *//* DECnet Phase IV *//* Xerox NS IDP *//* OSI Network Layer *//* Raw IP *//* Protocol numbers *//* non-standard for DLT_PPP_WITHDIRECTION *//* The control byte value *//* The address byte value *//* length of PPP header *//*
 * Point to Point Protocol (PPP) RFC1331
 *
 * Copyright 1989 by Carnegie Mellon.
 *
 * Permission to use, copy, modify, and distribute this program for any
 * purpose and without fee is hereby granted, provided that this copyright
 * and permission notice appear on all copies and supporting documentation,
 * the name of Carnegie Mellon not be used in advertising or publicity
 * pertaining to distribution of the program without specific prior
 * permission, and notice be given in supporting documentation that copying
 * and distribution is by permission of Carnegie Mellon and Stanford
 * University.  Carnegie Mellon makes no representations about the
 * suitability of this software for any purpose.  It is provided "as is"
 * without express or implied warranty.
 *//Users/owura/Repos/codeql_eval/proj_repos/the-tcpdump-group-tcpdump-commit-9ba91381954ad325ea4fd26b9c65a8bd9a2a85b6/tcpdump/print-juniper.c"ppp.h"juniper_services_headerjuniper_monitor_headerjuniper_ipsec_headerjuniper_ggsn_headerjuniper_parse_headerjuniper_l2info_t *const juniper_cookie_table_tconst juniper_cookie_table_t *juniper_cookie_table_t *const juniper_cookie_table_t[12]juniper_cookie_table_t[12]jnx_ext_lenjnx_header_lencontrol_wordtlv_valueJUNIPER_BPF_PKT_IN(ndo, "no magic-number found!")5064515JUNIPER_MGC_NUMBERno magic-number found!(ndo, "%3s ", tok2str(juniper_direction_values, "---", l2info->direction))%3s ---(ndo, "\n\tJuniper PCAP Flags [%s]", bittok2str(jnx_flag_values, "none", l2info->flags))
	Juniper PCAP Flags [%s](ndo, ", PCAP Extension(s) total length %u", jnx_ext_len)(ndo, "\n\t  %s Extension TLV #%u, length %u, value ", tok2str(jnx_ext_tlv_values,"Unknown",tlv_type), tlv_type, tlv_len)(ndo, "%s (%u)", tok2str(juniper_ifmt_values, "Unknown", tlv_value), tlv_value)(ndo, "%s (%u)", tok2str(juniper_ifle_values, "Unknown", tlv_value), tlv_value)(ndo, "%u", tlv_value)JUNIPER_BPF_EXT, PCAP Extension(s) total length %uJUNIPER_EXT_TLV_OVERHEAD
	  %s Extension TLV #%u, length %u, value JUNIPER_EXT_TLV_IFD_NAMEJUNIPER_EXT_TLV_IFD_MEDIATYPEJUNIPER_EXT_TLV_TTP_IFD_MEDIATYPEconst tok[53]tok[53]JUNIPER_EXT_TLV_IFL_ENCAPSJUNIPER_EXT_TLV_TTP_IFL_ENCAPSJUNIPER_EXT_TLV_IFL_IDXJUNIPER_EXT_TLV_IFL_UNITJUNIPER_EXT_TLV_IFD_IDX(ndo, "no-L2-hdr, ")p[jnx_header_len + 4](ndo, "no IP-hdr found!")JUNIPER_BPF_NO_L2no-L2-hdr, no IP-hdr found!l2info(ndo, "%s-PIC, cookie-len %u", lp->s, l2info->cookie_len)l2info->cookie_len(ndo, ", cookie 0x")(ndo, "%02x", p[idx])p+l2info->cookie_len*(p+l2info->cookie_len)LS_COOKIE_IDAS_COOKIE_IDDLT_JUNIPER_MFRMFR_BE_MASK%s-PIC, cookie-len %u, cookie 0x&l2info->cookie[6](ndo, "control-word 0x%08x ", control_word)(ndo, "Unknown Juniper DLT_ type %u: ", l2info->pictype)DLT_JUNIPER_MLPPP0xfffJUNIPER_LSQ_L3_PROTO_MASKDLT_JUNIPER_MLFRDLT_JUNIPER_ATM2ATM2_PKT_TYPE_MASK1342177280x080000001378877440x08380000control-word 0x%08x DLT_JUNIPER_GGSNDLT_JUNIPER_ATM1DLT_JUNIPER_PPPDLT_JUNIPER_CHDLCDLT_JUNIPER_ETHERDLT_JUNIPER_FRELAYUnknown Juniper DLT_ type %u: (ndo, "hlen %u, proto 0x%04x, ", l2info->header_len, l2info->proto)hlen %u, proto 0x%04x, (ndo, "[|juniper_hdr], length %u", h->len)[|juniper_hdr], length %ujuniper_read_tlv_valueip_heuristic_guess0x470x480x490x4a0x4c0x4f0x610x620x640x650x660x670x680x690x6a0x6b0x6d0x6ejuniper_ppp_heuristic_guess64332801328033340949185491874969932855juniper_atm2_print0xfefe030xaaaa03l2info.cookieATM2_GAP_COUNT_MASK(ndo, "[|juniper_atm2]")[|juniper_atm2]juniper_atm1_print(ndo, "[|juniper_atm1]")[|juniper_atm1]juniper_mlfr_print(ndo, "Bundle-ID %u, ", l2info.bundle)Bundle-ID %u, (ndo, "unknown protocol 0x%04x, length %u", l2info.proto, l2info.length)(LLC_UI)(LLC_UI<<8)(LLC_UI<<8 | NLPID_Q933)972(LLC_UI<<8 | NLPID_IP)910(LLC_UI<<8 | NLPID_IP6)unknown protocol 0x%04x, length %ujuniper_mfr_print&l2info0, sizeof(l2info)AS_PIC_COOKIE_LENJUNIPER_LSQ_L3_PROTO_IPV4JUNIPER_LSQ_L3_PROTO_IPV6JUNIPER_LSQ_L3_PROTO_MPLSJUNIPER_LSQ_L3_PROTO_ISOLLCSAP_ISONS<<8 | LLCSAP_ISONS(LLCSAP_ISONS<<8 | LLCSAP_ISONS)juniper_mlppp_print&l2info.cookie(ndo, "Bundle-ID %u: ", l2info.bundle)65283(PPP_ADDRESS << 8 | PPP_CONTROL)Bundle-ID %u: JUNIPER_LSQ_COOKIE_REJUNIPER_LSQ_COOKIE_DIR(JUNIPER_LSQ_COOKIE_RE|JUNIPER_LSQ_COOKIE_DIR)juniper_pppoe_atm_printDLT_JUNIPER_PPPOE_ATM(ndo, "unknown ethertype 0x%04x", extracted_ethertype)unknown ethertype 0x%04x(ndo, "[|juniper_pppoe_atm]")[|juniper_pppoe_atm]juniper_chdlc_printjuniper_frelay_printjuniper_ppp_printjuniper_ether_printjuniper_pppoe_printDLT_JUNIPER_PPPOEjuniper_services_printconst juniper_services_headerconst juniper_services_header *juniper_services_header *shDLT_JUNIPER_SERVICES*shsizeof(*sh)(ndo, "service-id %u flags 0x%02x service-set-id 0x%04x iif %u: ", sh->svc_id, sh->flags_len, EXTRACT_16BITS(&sh->svc_set_id), EXTRACT_24BITS(&sh->dir_iif[1]))(ndo, "service-id %u flags 0x%02x service-set-id 0x%04x iif %u: ", sh->svc_id, sh->flags_len, ((uint16_t)(((uint16_t)(*((const uint8_t *)(&sh->svc_set_id) + 0)) << 8) | ((uint16_t)(*((const uint8_t *)(&sh->svc_set_id) + 1)) << 0))), ((uint32_t)(((uint32_t)(*((const uint8_t *)(&sh->dir_iif[1]) + 0)) << 16) | ((uint32_t)(*((const uint8_t *)(&sh->dir_iif[1]) + 1)) << 8) | ((uint32_t)(*((const uint8_t *)(&sh->dir_iif[1]) + 2)) << 0))))&sh->svc_set_id&sh->dir_iif[1]service-id %u flags 0x%02x service-set-id 0x%04x iif %u: char[58](ndo, "[|juniper_services]")[|juniper_services]juniper_monitor_printconst juniper_monitor_headerconst juniper_monitor_header *juniper_monitor_header *mhDLT_JUNIPER_MONITOR*mhsizeof(*mh)(ndo, "service-id %u, iif %u, pkt-type %u: ", EXTRACT_32BITS(&mh->service_id), EXTRACT_16BITS(&mh->iif), mh->pkt_type)(ndo, "service-id %u, iif %u, pkt-type %u: ", ((uint32_t)(((uint32_t)(*((const uint8_t *)(&mh->service_id) + 0)) << 24) | ((uint32_t)(*((const uint8_t *)(&mh->service_id) + 1)) << 16) | ((uint32_t)(*((const uint8_t *)(&mh->service_id) + 2)) << 8) | ((uint32_t)(*((const uint8_t *)(&mh->service_id) + 3)) << 0))), ((uint16_t)(((uint16_t)(*((const uint8_t *)(&mh->iif) + 0)) << 8) | ((uint16_t)(*((const uint8_t *)(&mh->iif) + 1)) << 0))), mh->pkt_type)&mh->service_id&mh->iifservice-id %u, iif %u, pkt-type %u: juniper_es_printrewrite_lenes_type_bundleconst juniper_ipsec_headerconst juniper_ipsec_header *juniper_ipsec_header *ihDLT_JUNIPER_ES*ihsizeof(*ih)(ndo, "ES Invalid type %u, length %u", ih->type, l2info.length)JUNIPER_IPSEC_O_ESP_ENCRYPT_ESP_AUTHEN_TYPEJUNIPER_IPSEC_O_ESP_ENCRYPT_AH_AUTHEN_TYPEJUNIPER_IPSEC_O_ESP_AUTHENTICATION_TYPEJUNIPER_IPSEC_O_AH_AUTHENTICATION_TYPEJUNIPER_IPSEC_O_ESP_ENCRYPTION_TYPEES Invalid type %u, length %u(ndo, "ES SA, index %u, ttl %u type %s (%u), spi %u, Tunnel %s > %s, length %u\n", EXTRACT_16BITS(&ih->sa_index), ih->ttl, tok2str(juniper_ipsec_type_values,"Unknown",ih->type), ih->type, EXTRACT_32BITS(&ih->spi), ipaddr_string(ndo, &ih->src_ip), ipaddr_string(ndo, &ih->dst_ip), l2info.length)(ndo, "ES SA, index %u, ttl %u type %s (%u), spi %u, Tunnel %s > %s, length %u\n", ((uint16_t)(((uint16_t)(*((const uint8_t *)(&ih->sa_index) + 0)) << 8) | ((uint16_t)(*((const uint8_t *)(&ih->sa_index) + 1)) << 0))), ih->ttl, tok2str(juniper_ipsec_type_values,"Unknown",ih->type), ih->type, ((uint32_t)(((uint32_t)(*((const uint8_t *)(&ih->spi) + 0)) << 24) | ((uint32_t)(*((const uint8_t *)(&ih->spi) + 1)) << 16) | ((uint32_t)(*((const uint8_t *)(&ih->spi) + 2)) << 8) | ((uint32_t)(*((const uint8_t *)(&ih->spi) + 3)) << 0))), getname(ndo, (const u_char *)(&ih->src_ip)), getname(ndo, (const u_char *)(&ih->dst_ip)), l2info.length)&ih->sa_index&ih->spi&ih->src_ip&ih->dst_ip(ndo, "ES SA, index %u, ttl %u type %s (%u), length %u\n", EXTRACT_16BITS(&ih->sa_index), ih->ttl, tok2str(juniper_ipsec_type_values,"Unknown",ih->type), ih->type, l2info.length)(ndo, "ES SA, index %u, ttl %u type %s (%u), length %u\n", ((uint16_t)(((uint16_t)(*((const uint8_t *)(&ih->sa_index) + 0)) << 8) | ((uint16_t)(*((const uint8_t *)(&ih->sa_index) + 1)) << 0))), ih->ttl, tok2str(juniper_ipsec_type_values,"Unknown",ih->type), ih->type, l2info.length)ES SA, index %u, ttl %u type %s (%u), spi %u, Tunnel %s > %s, length %u
ES SA, index %u, ttl %u type %s (%u), length %u
juniper_ggsn_printconst juniper_ggsn_headerconst juniper_ggsn_header *juniper_ggsn_header *gh*ghsizeof(*gh)(ndo, "proto %s (%u), vlan %u: ", tok2str(juniper_protocol_values,"Unknown",gh->proto), gh->proto, EXTRACT_16BITS(&gh->vlan_id[0]))(ndo, "proto %s (%u), vlan %u: ", tok2str(juniper_protocol_values,"Unknown",gh->proto), gh->proto, ((uint16_t)(((uint16_t)(*((const uint8_t *)(&gh->vlan_id[0]) + 0)) << 8) | ((uint16_t)(*((const uint8_t *)(&gh->vlan_id[0]) + 1)) << 0))))&gh->vlan_id[0]proto %s (%u), vlan %u: (ndo, "unknown GGSN proto (%u)", gh->proto)JUNIPER_PROTO_IPV4JUNIPER_PROTO_IPV6unknown GGSN proto (%u)juniper_l2info_tjuniper_cookie_table_tdir_iifsvc_set_idflags_lensvc_idservice_idiifpaddingpkt_typedst_ipsrc_ipsa_indexvlan_idbundlecookie_typecookie_lenheader_lenpictypeJUNIPER_PROTO_NULLNull"Null"juniper_protocol_valuesconst juniper_cookie_table_t[]juniper_cookie_table_t[]ATM1"ATM1"ATM2"ATM2"MLPPP"MLPPP"MLFR"MLFR"MFR"MFR"PPPoE"PPPoE"PPPoE ATM"PPPoE ATM"GGSN"GGSN"MONITOR"MONITOR"AS"AS"ES"ES"juniper_cookie_tableJUNIPER_IFLE_AGGREGATORJUNIPER_IFLE_ATM_CCCCCC over ATM"CCC over ATM"JUNIPER_IFLE_ATM_CELLRELAY_CCCATM CCC Cell Relay"ATM CCC Cell Relay"JUNIPER_IFLE_ATM_CISCO_NLPIDCISCO compatible NLPID"CISCO compatible NLPID"JUNIPER_IFLE_ATM_EOA_CCCEthernet over ATM CCC"Ethernet over ATM CCC"JUNIPER_IFLE_ATM_EOA_LLCEthernet over ATM LLC"Ethernet over ATM LLC"JUNIPER_IFLE_ATM_ETHER_VPLS_ATM_LLCEthernet VPLS over ATM LLC"Ethernet VPLS over ATM LLC"JUNIPER_IFLE_ATM_LLCATM LLC"ATM LLC"JUNIPER_IFLE_ATM_MLPPP_LLCMLPPP over ATM LLC"MLPPP over ATM LLC"JUNIPER_IFLE_ATM_NLPIDATM NLPID"ATM NLPID"JUNIPER_IFLE_ATM_PPPOE_LLCPPPoE over ATM LLC"PPPoE over ATM LLC"JUNIPER_IFLE_ATM_PPP_FUNIPPP over FUNI"PPP over FUNI"JUNIPER_IFLE_ATM_PPP_LLCPPP over ATM LLC"PPP over ATM LLC"JUNIPER_IFLE_ATM_PPP_VCMUXPPP over ATM VCMUX"PPP over ATM VCMUX"JUNIPER_IFLE_ATM_SNAPATM SNAP"ATM SNAP"JUNIPER_IFLE_ATM_SNAP_TCCATM SNAP TCC"ATM SNAP TCC"JUNIPER_IFLE_ATM_TCCATM VCMUX TCC"ATM VCMUX TCC"JUNIPER_IFLE_ATM_VCMUXATM VCMUX"ATM VCMUX"JUNIPER_IFLE_CISCOHDLCC-HDLC"C-HDLC"JUNIPER_IFLE_CISCOHDLC_CCCC-HDLC CCC"C-HDLC CCC"JUNIPER_IFLE_CISCOHDLC_SUBORDINATEC-HDLC via dialer"C-HDLC via dialer"JUNIPER_IFLE_CISCOHDLC_TCCC-HDLC TCC"C-HDLC TCC"JUNIPER_IFLE_COLLECTORCollector"Collector"JUNIPER_IFLE_CRYPTOCrypto"Crypto"JUNIPER_IFLE_ENET2JUNIPER_IFLE_ETHERNET_CCCEthernet CCC"Ethernet CCC"JUNIPER_IFLE_ETHERNET_EXTENDED_VLAN_VPLSExtended VLAN VPLS"Extended VLAN VPLS"JUNIPER_IFLE_ETHERNET_PPPOEPPPoE over Ethernet"PPPoE over Ethernet"JUNIPER_IFLE_ETHERNET_TCCEthernet TCC"Ethernet TCC"JUNIPER_IFLE_ETHERNET_VLAN_VPLSVLAN VPLS"VLAN VPLS"JUNIPER_IFLE_ETHERNET_VPLSJUNIPER_IFLE_EXTENDED_VLAN_CCCExtended VLAN CCC"Extended VLAN CCC"JUNIPER_IFLE_EXTENDED_VLAN_TCCExtended VLAN TCC"Extended VLAN TCC"JUNIPER_IFLE_FR_CCCFR CCC"FR CCC"JUNIPER_IFLE_FR_NLPIDFR NLPID"FR NLPID"JUNIPER_IFLE_FR_PORT_CCCJUNIPER_IFLE_FR_PPPFR PPP"FR PPP"JUNIPER_IFLE_FR_SNAPFR SNAP"FR SNAP"JUNIPER_IFLE_FR_TCCFR TCC"FR TCC"JUNIPER_IFLE_GGSNJUNIPER_IFLE_GRE_NULLGRE NULL"GRE NULL"JUNIPER_IFLE_GRE_PPPPPP over GRE"PPP over GRE"JUNIPER_IFLE_IPIP_NULLJUNIPER_IFLE_LAPDLAPD"LAPD"JUNIPER_IFLE_LSI_NULLLSI Null"LSI Null"JUNIPER_IFLE_LT_VLANLT VLAN"LT VLAN"JUNIPER_IFLE_MFRJUNIPER_IFLE_MLFRJUNIPER_IFLE_MLPPPJUNIPER_IFLE_MONITORMonitor"Monitor"JUNIPER_IFLE_PIMD_DECAPSPIMd"PIMd"JUNIPER_IFLE_PIM_NULLPIM Null"PIM Null"JUNIPER_IFLE_PPPJUNIPER_IFLE_PPPOEJUNIPER_IFLE_PPP_CCCPPP CCC"PPP CCC"JUNIPER_IFLE_PPP_SUBORDINATEJUNIPER_IFLE_PPP_TCCPPP TCC"PPP TCC"JUNIPER_IFLE_SERVICESGeneral Services"General Services"JUNIPER_IFLE_VLAN_CCCVLAN CCC"VLAN CCC"JUNIPER_IFLE_VLAN_TCCVLAN TCC"VLAN TCC"JUNIPER_IFLE_VTVT"VT"juniper_ifle_valuesJUNIPER_IFML_ETHERJUNIPER_IFML_FDDIJUNIPER_IFML_TOKENRINGToken-Ring"Token-Ring"JUNIPER_IFML_PPPJUNIPER_IFML_PPP_SUBORDINATEPPP-Subordinate"PPP-Subordinate"JUNIPER_IFML_FRAMERELAYFrame-Relay"Frame-Relay"JUNIPER_IFML_CISCOHDLCJUNIPER_IFML_SMDSDXISMDS-DXI"SMDS-DXI"JUNIPER_IFML_ATMPVCATM-PVC"ATM-PVC"JUNIPER_IFML_PPP_CCCPPP-CCC"PPP-CCC"JUNIPER_IFML_FRAMERELAY_CCCFrame-Relay-CCC"Frame-Relay-CCC"JUNIPER_IFML_FRAMERELAY_EXT_CCCExtended FR-CCC"Extended FR-CCC"JUNIPER_IFML_IPIPIP-over-IP"IP-over-IP"JUNIPER_IFML_GREJUNIPER_IFML_PIMPIM-Encapsulator"PIM-Encapsulator"JUNIPER_IFML_PIMDPIM-Decapsulator"PIM-Decapsulator"JUNIPER_IFML_CISCOHDLC_CCCCisco-HDLC-CCC"Cisco-HDLC-CCC"JUNIPER_IFML_VLAN_CCCVLAN-CCC"VLAN-CCC"JUNIPER_IFML_EXTENDED_VLAN_CCCExtended-VLAN-CCC"Extended-VLAN-CCC"JUNIPER_IFML_MLPPPMultilink-PPP"Multilink-PPP"JUNIPER_IFML_MLFRMultilink-FR"Multilink-FR"JUNIPER_IFML_MFRMultilink-FR-UNI-NNI"Multilink-FR-UNI-NNI"JUNIPER_IFML_MLMultilink"Multilink"JUNIPER_IFML_LSLinkService"LinkService"JUNIPER_IFML_LSILSI"LSI"JUNIPER_IFML_ATM_CELLRELAY_CCCATM-CCC-Cell-Relay"ATM-CCC-Cell-Relay"JUNIPER_IFML_CRYPTOIPSEC-over-IP"IPSEC-over-IP"JUNIPER_IFML_GGSNJUNIPER_IFML_PPP_TCCPPP-TCC"PPP-TCC"JUNIPER_IFML_FRAMERELAY_TCCFrame-Relay-TCC"Frame-Relay-TCC"JUNIPER_IFML_FRAMERELAY_EXT_TCCExtended FR-TCC"Extended FR-TCC"JUNIPER_IFML_CISCOHDLC_TCCCisco-HDLC-TCC"Cisco-HDLC-TCC"JUNIPER_IFML_ETHERNET_CCCEthernet-CCC"Ethernet-CCC"JUNIPER_IFML_VTVPN-Loopback-tunnel"VPN-Loopback-tunnel"JUNIPER_IFML_ETHER_OVER_ATMEthernet-over-ATM"Ethernet-over-ATM"JUNIPER_IFML_ETHER_VPLS_OVER_ATMEthernet-VPLS-over-ATM"Ethernet-VPLS-over-ATM"JUNIPER_IFML_MONITORJUNIPER_IFML_ETHERNET_TCCEthernet-TCC"Ethernet-TCC"JUNIPER_IFML_VLAN_TCCVLAN-TCC"VLAN-TCC"JUNIPER_IFML_EXTENDED_VLAN_TCCExtended-VLAN-TCC"Extended-VLAN-TCC"JUNIPER_IFML_CONTROLLERController"Controller"JUNIPER_IFML_ETHERNET_VPLSJUNIPER_IFML_ETHERNET_VLAN_VPLSVLAN-VPLS"VLAN-VPLS"JUNIPER_IFML_ETHERNET_EXTENDED_VLAN_VPLSExtended-VLAN-VPLS"Extended-VLAN-VPLS"JUNIPER_IFML_LTLogical-tunnel"Logical-tunnel"JUNIPER_IFML_SERVICESGeneral-Services"General-Services"JUNIPER_IFML_PPPOEJUNIPER_IFML_ETHERNET_FLEXFlexible-Ethernet-Services"Flexible-Ethernet-Services"JUNIPER_IFML_FRAMERELAY_FLEXFlexible-FrameRelay"Flexible-FrameRelay"JUNIPER_IFML_COLLECTORFlow-collection"Flow-collection"JUNIPER_IFML_PICPEERPIC Peer"PIC Peer"JUNIPER_IFML_DFCDynamic-Flow-Capture"Dynamic-Flow-Capture"juniper_ifmt_valuesExt"Ext"JUNIPER_BPF_FILTERFilter"Filter"JUNIPER_BPF_IIFIIF"IIF"no-L2"no-L2"In"In"jnx_flag_valuesDevice Interface Index"Device Interface Index"Device Interface Name"Device Interface Name"Device Media Type"Device Media Type"Logical Interface Index"Logical Interface Index"Logical Unit Number"Logical Unit Number"Logical Interface Encapsulation"Logical Interface Encapsulation"TTP derived Device Media Type"TTP derived Device Media Type"TTP derived Logical Interface Encapsulation"TTP derived Logical Interface Encapsulation"jnx_ext_tlv_valuesJUNIPER_BPF_INJUNIPER_BPF_OUTOut"Out"juniper_direction_valuesESP ENCR-AUTH"ESP ENCR-AUTH"ESP ENCR-AH AUTH"ESP ENCR-AH AUTH"ESP AUTH"ESP AUTH"AH AUTH"AH AUTH"ESP ENCR"ESP ENCR"juniper_ipsec_type_valuesATM2_COOKIE_LENATM1_COOKIE_LENLS_MFR_COOKIE_LENML_MLFR_COOKIE_LENLS_MLFR_COOKIE_LENJUNIPER_IFLE_PICPEERJUNIPER_IFLE_DFCJUNIPER_IFLE_AGGREGATE_UNUSEDJUNIPER_IFLE_IEEE8023_LLCJUNIPER_IFLE_IEEE8023_SNAPJUNIPER_IFML_CISCOHDLC_SUBORDINATEJUNIPER_IFML_LAPDJUNIPER_IFML_AGGREGATORJUNIPER_IFML_GGSNIJUNIPER_IFML_FR_PORT_CCCJUNIPER_IFML_LSI_CISCOHDLCJUNIPER_IFML_LSI_PPPJUNIPER_IFML_DFE(3 << JUNIPER_LSQ_L3_PROTO_SHIFT)(2 << JUNIPER_LSQ_L3_PROTO_SHIFT)(1 << JUNIPER_LSQ_L3_PROTO_SHIFT)(0 << JUNIPER_LSQ_L3_PROTO_SHIFT)(0x17 << JUNIPER_LSQ_L3_PROTO_SHIFT)JUNIPER_LSQ_L3_PROTO_SHIFT0x4d4743lint/* everything went ok so far. continue parsing *//* cntl word plus cell length (56) >= JUNOS 7.4*//* < JUNOS 7.4 control-word *//* zero control word *//* some control word heuristics *//* ATM cell relay control word present ? *//* DLT_ specific parsing *//* print demarc b/w L2/L3*//* copy cookie data *//* MFR child links don't carry cookies *//* search through the cookie table and copy values matching for our PIC type *//* stop parsing the output further *//* there is no link-layer present -
         * perform the v4/v6 heuristics
         * to figure out what it is
         *//* nail up the total length -
         * just in case something goes wrong
         * with TLV parsing *//* ok to read extension length ? *//* extensions present ?  - calculate how much bytes to skip *//* magic number + flags *//* print direction *//* magic number found ? *//* TLVs >= 128 are big endian encoded *//* TLVs < 128 are little endian encoded *//* we printed an v4/v6 packet *//* did not find a ip header *//* we printed a ppp packet *//* did not find a ppp header *//* try to guess, based on all PPP protos that are supported in
 * a juniper router if the payload data is encapsulated using PPP *//* last try - vcmux encaps ? *//* PPPoA vcmux encaps ? *//* FIXME check if frame was recognized *//* Cisco style NLPID encaps ? *//* ether-over-1483 encaps ? *//* SNAP encaps ? *//* NLPID encaps ? *//* OAM cell ? *//*
 *     ATM2 PIC cookie format
 *
 *     +-------------------------------+---------+---+-----+-----------+
 *     |     channel ID                |  reserv |AAL| CCRQ| gap cnt   |
 *     +-------------------------------+---------+---+-----+-----------+
 *//*
 *     ATM1 PIC cookie format
 *
 *     +-----+-------------------------+-------------------------------+
 *     |fmtid|     vc index            |  channel  ID                  |
 *     +-----+-------------------------+-------------------------------+
 *//* pass IP{4,6} to the OSI layer for proper link-layer printing *//* suppress Bundle-ID if frame was captured on a child-link *//* first try the LSQ protos *//* child-link ? *//* zero length cookie ? *//* IP traffic going to the RE would not have a cookie
             * -> this must be incoming IS-IS over PPP
             *//* suppress Bundle-ID if frame was captured on a child-link
         * best indicator if the cookie looks like a proto *//* this DLT contains nothing but raw PPPoE frames,
         * prepended with a type field*//* this DLT contains nothing but raw c-hdlc frames *//* this DLT contains nothing but raw frame-relay frames *//* this DLT contains nothing but raw ppp frames *//* this DLT contains nothing but raw Ethernet frames *//* this DLT contains nothing but raw ethernet frames *//* no proto field - lets guess by first byte of IP header*//* pic name *//* cookie len *//* pic type *//* 1 byte type and 1-byte length *//* codepoints for encoding extensions to a .pcap file *//* = "MGC" *//* extensions present *//* BPF filtering is supported *//* IIF is valid *//* L2 header stripped *//* Incoming packet *//* Outgoing packet *//* \summary: DLT_JUNIPER_* printers *//*     NetBSD: print-juniper.c,v 1.2 2007/07/24 11:53:45 drochner Exp        *//Users/owura/Repos/codeql_eval/proj_repos/the-tcpdump-group-tcpdump-commit-9ba91381954ad325ea4fd26b9c65a8bd9a2a85b6/tcpdump/print-krb.ckrb_printconst krbconst krb *krb *kpconst char[13](ndo, " v%d", kp->pvno)(ndo, " v5") v%d v5krb4_print5100xFF << 1(0xFF << 1)(ndo, " %s %s: ", IS_LENDIAN(kp) ? "le" : "be", tok2str(type2str, NULL, type))(ndo, " %s %s: ", (((kp)->type & 0x01) != 0) ? "le" : "be", tok2str(type2str, ((void *)0), type)) %s %s: lebe(ndo, " %dmin ", *cp++ * 5)(ndo, "v%d ", *cp++)(ndo, " (%d)", *cp++)(ndo, " (%d)", *cp)(ndo, " (%d)", len)(ndo, " %s ", tok2str(kerr2str, NULL, KTOHSP(kp, cp)))(ndo, " %s ", tok2str(kerr2str, ((void *)0), ((((kp)->type & 0x01) != 0) ? ((uint16_t)(((uint16_t)(*((const uint8_t *)(cp) + 1)) << 8) | ((uint16_t)(*((const uint8_t *)(cp) + 0)) << 0))) : ((uint16_t)(((uint16_t)(*((const uint8_t *)(cp) + 0)) << 8) | ((uint16_t)(*((const uint8_t *)(cp) + 1)) << 0))))))(ndo, "(unknown)")AUTH_MSG_KDC_REQUEST %dmin AUTH_MSG_APPL_REQUESTv%d AUTH_MSG_KDC_REPLYAUTH_MSG_ERR_REPLY(unknown)krb4_print_hdrc_print(ndo, "M-")(ndo, "^")(ndo, "%c", c)M-^krbpvnoKERB_ERR_OKOK"OK"KERB_ERR_NAME_EXPNAME_EXP"NAME_EXP"KERB_ERR_SERVICE_EXPSERVICE_EXP"SERVICE_EXP"KERB_ERR_AUTH_EXPAUTH_EXP"AUTH_EXP"KERB_ERR_PKT_VERPKT_VER"PKT_VER"KERB_ERR_NAME_MAST_KEY_VERNAME_MAST_KEY_VER"NAME_MAST_KEY_VER"KERB_ERR_SERV_MAST_KEY_VERSERV_MAST_KEY_VER"SERV_MAST_KEY_VER"KERB_ERR_BYTE_ORDERBYTE_ORDER"BYTE_ORDER"KERB_ERR_PRINCIPAL_UNKNOWNPRINCIPAL_UNKNOWN"PRINCIPAL_UNKNOWN"KERB_ERR_PRINCIPAL_NOT_UNIQUEPRINCIPAL_NOT_UNIQUE"PRINCIPAL_NOT_UNIQUE"KERB_ERR_NULL_KEYNULL_KEY"NULL_KEY"kerr2strKDC_REQUEST"KDC_REQUEST"KDC_REPLY"KDC_REPLY"APPL_REQUEST"APPL_REQUEST"AUTH_MSG_APPL_REQUEST_MUTUALAPPL_REQUEST_MUTUAL"APPL_REQUEST_MUTUAL"ERR_REPLY"ERR_REPLY"AUTH_MSG_PRIVATEPRIVATE"PRIVATE"AUTH_MSG_SAFESAFE"SAFE"AUTH_MSG_APPL_ERRAPPL_ERR"APPL_ERR"AUTH_MSG_DIEDIE"DIE" [|kerberos]" [|kerberos]"KTOHSP(kp,cp)(IS_LENDIAN(kp) ? EXTRACT_LE_16BITS(cp) : EXTRACT_16BITS(cp))IS_LENDIAN(kp)(((kp)->type & 0x01) != 0)PRINTif ((cp = c_print(ndo, cp, ndo->ndo_snapend)) == NULL) goto trunc63<<18<<17<<16<<15<<14<<13<<12<<11<<1/* Decode ASN.1 here "someday" *//* timestamp + n + exp + kvno *//* ctime *//*  True if struct krb is little endian *//* DEL to ?, others to alpha *//* Type+B *//* Protocol Version *//* \summary: Kerberos printer *//*
 * Copyright (c) 1995, 1996, 1997
 *	The Regents of the University of California.  All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that: (1) source code distributions
 * retain the above copyright notice and this paragraph in its entirety, (2)
 * distributions including binary code include the above copyright notice and
 * this paragraph in its entirety in the documentation or other materials
 * provided with the distribution, and (3) all advertising materials mentioning
 * features or use of this software display the following acknowledgement:
 * ``This product includes software developed by the University of California,
 * Lawrence Berkeley Laboratory and its contributors.'' Neither the name of
 * the University nor the names of its contributors may be used to endorse
 * or promote products derived from this software without specific prior
 * written permission.
 * THIS SOFTWARE IS PROVIDED ``AS IS'' AND WITHOUT ANY EXPRESS OR IMPLIED
 * WARRANTIES, INCLUDING, WITHOUT LIMITATION, THE IMPLIED WARRANTIES OF
 * MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE.
 *
 * Initial contribution from John Hawkinson (jhawk@mit.edu).
 *//Users/owura/Repos/codeql_eval/proj_repos/the-tcpdump-group-tcpdump-commit-9ba91381954ad325ea4fd26b9c65a8bd9a2a85b6/tcpdump/print-l2tp.cl2tp_printcntflag_tflag_lflag_sflag_ol2tp_len*ptr(ndo, " l2tp:")(ndo, " l2f:")(ndo, " Unknown Version, neither L2F(1) nor L2TP(2)")L2TP_VERSION_MASKL2TP_VERSION_L2TP l2tp:L2TP_VERSION_L2F l2f: Unknown Version, neither L2F(1) nor L2TP(2)(ndo, "[")(ndo, "T")L2TP_FLAG_TYPE(ndo, "L")L2TP_FLAG_LENGTH(ndo, "S")L2TP_FLAG_SEQUENCE(ndo, "O")L2TP_FLAG_OFFSET(ndo, "P")L2TP_FLAG_PRIORITY(ndo, "(%u/", EXTRACT_16BITS(ptr))(ndo, "(%u/", ((uint16_t)(((uint16_t)(*((const uint8_t *)(ptr) + 0)) << 8) | ((uint16_t)(*((const uint8_t *)(ptr) + 1)) << 0))))(%u/(ndo, "%u)", EXTRACT_16BITS(ptr))(ndo, "%u)", ((uint16_t)(((uint16_t)(*((const uint8_t *)(ptr) + 0)) << 8) | ((uint16_t)(*((const uint8_t *)(ptr) + 1)) << 0))))%u)(ndo, "Ns=%u,", EXTRACT_16BITS(ptr))(ndo, "Ns=%u,", ((uint16_t)(((uint16_t)(*((const uint8_t *)(ptr) + 0)) << 8) | ((uint16_t)(*((const uint8_t *)(ptr) + 1)) << 0))))(ndo, "Nr=%u", EXTRACT_16BITS(ptr))(ndo, "Nr=%u", ((uint16_t)(((uint16_t)(*((const uint8_t *)(ptr) + 0)) << 8) | ((uint16_t)(*((const uint8_t *)(ptr) + 1)) << 0))))Ns=%u,Nr=%u(ndo, " Length %u larger than packet", l2tp_len) Length %u larger than packet(ndo, " Length %u smaller than header length", length) Length %u smaller than header length(ndo, " No length")(ndo, " ZLB") No length ZLBavp_lengthl2tp_avp_printattr_typehidden FALSE*(dat)L2TP_AVP_HDR_LEN_MASK(ndo, "*")L2TP_AVP_HDR_FLAG_MANDATORY(ndo, "?")L2TP_AVP_HDR_FLAG_HIDDEN(ndo, "VENDOR%04x:", EXTRACT_16BITS(dat))(ndo, "VENDOR%04x:", ((uint16_t)(((uint16_t)(*((const uint8_t *)(dat) + 0)) << 8) | ((uint16_t)(*((const uint8_t *)(dat) + 1)) << 0))))(ndo, "ATTR%04x", EXTRACT_16BITS(dat))(ndo, "ATTR%04x", ((uint16_t)(((uint16_t)(*((const uint8_t *)(dat) + 0)) << 8) | ((uint16_t)(*((const uint8_t *)(dat) + 1)) << 0))))(ndo, "%s", tok2str(l2tp_avp2str, "AVP-#%u", attr_type))(ndo, "???")(ndo, "AVP too short")VENDOR%04x:ATTR%04xAVP-#%uL2TP_AVP_MSGTYPEL2TP_AVP_RESULT_CODEL2TP_AVP_PROTO_VERL2TP_AVP_FRAMING_CAPL2TP_AVP_BEARER_CAPL2TP_AVP_TIE_BREAKERAVP too shortL2TP_AVP_FIRM_VERL2TP_AVP_ASSND_TUN_IDL2TP_AVP_RECV_WIN_SIZEL2TP_AVP_ASSND_SESS_IDL2TP_AVP_HOST_NAMEL2TP_AVP_VENDOR_NAMEL2TP_AVP_CALLING_NUMBERL2TP_AVP_CALLED_NUMBERL2TP_AVP_SUB_ADDRESSL2TP_AVP_PROXY_AUTH_NAMEL2TP_AVP_PRIVATE_GRP_IDL2TP_AVP_CHALLENGEL2TP_AVP_INI_RECV_LCPL2TP_AVP_LAST_SENT_LCPL2TP_AVP_LAST_RECV_LCPL2TP_AVP_PROXY_AUTH_CHALL2TP_AVP_PROXY_AUTH_RESPL2TP_AVP_RANDOM_VECTORL2TP_AVP_Q931_CCL2TP_AVP_CHALLENGE_RESPL2TP_AVP_CALL_SER_NUML2TP_AVP_MINIMUM_BPSL2TP_AVP_MAXIMUM_BPSL2TP_AVP_TX_CONN_SPEEDL2TP_AVP_PHY_CHANNEL_IDL2TP_AVP_RX_CONN_SPEEDL2TP_AVP_BEARER_TYPEL2TP_AVP_FRAMING_TYPEL2TP_AVP_PACKET_PROC_DELAYL2TP_AVP_PROXY_AUTH_TYPEL2TP_AVP_PROXY_AUTH_IDL2TP_AVP_CALL_ERRORSL2TP_AVP_ACCML2TP_AVP_SEQ_REQUIREDL2TP_AVP_PPP_DISCON_CC(ndo, "|...")|...l2tp_ppp_discon_cc_print(ndo, "%04x, ", EXTRACT_16BITS(dat))(ndo, "%04x, ", ((uint16_t)(((uint16_t)(*((const uint8_t *)(dat) + 0)) << 8) | ((uint16_t)(*((const uint8_t *)(dat) + 1)) << 0))))%04x, (ndo, "%04x ", EXTRACT_16BITS(dat))(ndo, "%04x ", ((uint16_t)(((uint16_t)(*((const uint8_t *)(dat) + 0)) << 8) | ((uint16_t)(*((const uint8_t *)(dat) + 1)) << 0))))(ndo, "%s", tok2str(l2tp_cc_direction2str, "Direction-#%u", EXTRACT_8BITS(dat)))(ndo, "%s", tok2str(l2tp_cc_direction2str, "Direction-#%u", (*(dat))))Direction-#%ul2tp_accm_printval(ndo, "send=%08x ", val)send=%08x (ndo, "recv=%08x ", val)recv=%08x l2tp_call_errors_print(ndo, "CRCErr=%u ", val)CRCErr=%u (ndo, "FrameErr=%u ", val)FrameErr=%u (ndo, "HardOver=%u ", val)HardOver=%u (ndo, "BufOver=%u ", val)BufOver=%u (ndo, "Timeout=%u ", val)Timeout=%u (ndo, "AlignErr=%u ", val)AlignErr=%u l2tp_proxy_auth_id_print(ndo, "%u", EXTRACT_16BITS(dat) & L2TP_PROXY_AUTH_ID_MASK)(ndo, "%u", ((uint16_t)(((uint16_t)(*((const uint8_t *)(dat) + 0)) << 8) | ((uint16_t)(*((const uint8_t *)(dat) + 1)) << 0))) & 0x00ff)l2tp_proxy_auth_type_print(ndo, "%s", tok2str(l2tp_authentype2str, "AuthType-#%u", EXTRACT_16BITS(dat)))(ndo, "%s", tok2str(l2tp_authentype2str, "AuthType-#%u", ((uint16_t)(((uint16_t)(*((const uint8_t *)(dat) + 0)) << 8) | ((uint16_t)(*((const uint8_t *)(dat) + 1)) << 0)))))AuthType-#%ul2tp_packet_proc_delay_print(ndo, "obsolete")obsoletel2tp_framing_type_print(ndo, "A")L2TP_FRAMING_TYPE_ASYNC_MASKL2TP_FRAMING_TYPE_SYNC_MASKl2tp_bearer_type_printL2TP_BEARER_TYPE_ANALOG_MASK(ndo, "D")L2TP_BEARER_TYPE_DIGITAL_MASKDl2tp_q931_cc_print(ndo, ", %02x", EXTRACT_8BITS(dat + 2))(ndo, ", %02x", (*(dat + 2))), %02xdat + 2l2tp_bearer_cap_printL2TP_BEARER_CAP_ANALOG_MASKL2TP_BEARER_CAP_DIGITAL_MASKl2tp_framing_cap_printL2TP_FRAMING_CAP_ASYNC_MASKL2TP_FRAMING_CAP_SYNC_MASKl2tp_proto_ver_print(ndo, "%u.%u", (EXTRACT_16BITS(dat) >> 8), (EXTRACT_16BITS(dat) & 0xff))(ndo, "%u.%u", (((uint16_t)(((uint16_t)(*((const uint8_t *)(dat) + 0)) << 8) | ((uint16_t)(*((const uint8_t *)(dat) + 1)) << 0))) >> 8), (((uint16_t)(((uint16_t)(*((const uint8_t *)(dat) + 0)) << 8) | ((uint16_t)(*((const uint8_t *)(dat) + 1)) << 0))) & 0xff))l2tp_result_code_print(ndo, "%u", EXTRACT_16BITS(dat))(ndo, "%u", ((uint16_t)(((uint16_t)(*((const uint8_t *)(dat) + 0)) << 8) | ((uint16_t)(*((const uint8_t *)(dat) + 1)) << 0))))(ndo, " AVP too short") AVP too short(ndo, "/%u", EXTRACT_16BITS(dat))(ndo, "/%u", ((uint16_t)(((uint16_t)(*((const uint8_t *)(dat) + 0)) << 8) | ((uint16_t)(*((const uint8_t *)(dat) + 1)) << 0))))l2tp_msgtype_print(ndo, "%s", tok2str(l2tp_msgtype2str, "MSGTYPE-#%u", EXTRACT_16BITS(dat)))(ndo, "%s", tok2str(l2tp_msgtype2str, "MSGTYPE-#%u", ((uint16_t)(((uint16_t)(*((const uint8_t *)(dat) + 0)) << 8) | ((uint16_t)(*((const uint8_t *)(dat) + 1)) << 0)))))MSGTYPE-#%uprint_32bits_val(ndo, "%u", EXTRACT_32BITS(dat))(ndo, "%u", ((uint32_t)(((uint32_t)(*((const uint8_t *)(dat) + 0)) << 24) | ((uint32_t)(*((const uint8_t *)(dat) + 1)) << 16) | ((uint32_t)(*((const uint8_t *)(dat) + 2)) << 8) | ((uint32_t)(*((const uint8_t *)(dat) + 3)) << 0))))print_16bits_valprint_octets(ndo, "%02x", *dat++)print_string(ndo, "%c", *dat++)L2TP_PPP_DISCON_CC_DIRECTION_GLOBALglobal error"global error"L2TP_PPP_DISCON_CC_DIRECTION_AT_PEERat peer"at peer"L2TP_PPP_DISCON_CC_DIRECTION_AT_LOCALat local"at local"l2tp_cc_direction2strL2TP_AUTHEN_TYPE_RESERVEDL2TP_AUTHEN_TYPE_TEXTUALTextual"Textual"L2TP_AUTHEN_TYPE_CHAPCHAP"CHAP"L2TP_AUTHEN_TYPE_PAPPAP"PAP"L2TP_AUTHEN_TYPE_NO_AUTHNo Auth"No Auth"L2TP_AUTHEN_TYPE_MSCHAPv1MS-CHAPv1"MS-CHAPv1"l2tp_authentype2strMSGTYPE"MSGTYPE"RESULT_CODE"RESULT_CODE"PROTO_VER"PROTO_VER"FRAMING_CAP"FRAMING_CAP"BEARER_CAP"BEARER_CAP"TIE_BREAKER"TIE_BREAKER"FIRM_VER"FIRM_VER"HOST_NAME"HOST_NAME"VENDOR_NAME"VENDOR_NAME"ASSND_TUN_ID"ASSND_TUN_ID"RECV_WIN_SIZE"RECV_WIN_SIZE"CHALLENGE"CHALLENGE"Q931_CC"Q931_CC"CHALLENGE_RESP"CHALLENGE_RESP"ASSND_SESS_ID"ASSND_SESS_ID"CALL_SER_NUM"CALL_SER_NUM"MINIMUM_BPS"MINIMUM_BPS"MAXIMUM_BPS"MAXIMUM_BPS"BEARER_TYPE"BEARER_TYPE"FRAMING_TYPE"FRAMING_TYPE"PACKET_PROC_DELAY"PACKET_PROC_DELAY"CALLED_NUMBER"CALLED_NUMBER"CALLING_NUMBER"CALLING_NUMBER"SUB_ADDRESS"SUB_ADDRESS"TX_CONN_SPEED"TX_CONN_SPEED"PHY_CHANNEL_ID"PHY_CHANNEL_ID"INI_RECV_LCP"INI_RECV_LCP"LAST_SENT_LCP"LAST_SENT_LCP"LAST_RECV_LCP"LAST_RECV_LCP"PROXY_AUTH_TYPE"PROXY_AUTH_TYPE"PROXY_AUTH_NAME"PROXY_AUTH_NAME"PROXY_AUTH_CHAL"PROXY_AUTH_CHAL"PROXY_AUTH_ID"PROXY_AUTH_ID"PROXY_AUTH_RESP"PROXY_AUTH_RESP"CALL_ERRORS"CALL_ERRORS"ACCM"ACCM"RANDOM_VECTOR"RANDOM_VECTOR"PRIVATE_GRP_ID"PRIVATE_GRP_ID"RX_CONN_SPEED"RX_CONN_SPEED"SEQ_REQUIRED"SEQ_REQUIRED"PPP_DISCON_CC"PPP_DISCON_CC"l2tp_avp2strL2TP_MSGTYPE_SCCRQSCCRQ"SCCRQ"L2TP_MSGTYPE_SCCRPSCCRP"SCCRP"L2TP_MSGTYPE_SCCCNSCCCN"SCCCN"L2TP_MSGTYPE_STOPCCNStopCCN"StopCCN"L2TP_MSGTYPE_HELLOHELLO"HELLO"L2TP_MSGTYPE_OCRQOCRQ"OCRQ"L2TP_MSGTYPE_OCRPOCRP"OCRP"L2TP_MSGTYPE_OCCNOCCN"OCCN"L2TP_MSGTYPE_ICRQICRQ"ICRQ"L2TP_MSGTYPE_ICRPICRP"ICRP"L2TP_MSGTYPE_ICCNICCN"ICCN"L2TP_MSGTYPE_CDNCDN"CDN"L2TP_MSGTYPE_WENWEN"WEN"L2TP_MSGTYPE_SLISLI"SLI"l2tp_msgtype2str [|l2tp]" [|l2tp]"L2TP_PROXY_AUTH_ID_MASK0x03ff/*
					 * Truncated.
					 *//*
			 * Print AVPs.
			 *//* Offset Size *//* Nr *//* Ns *//* Session ID *//* Tunnel ID *//* nothing we can do *//* nothing to do *//* Flags & Version *//* total octets consumed *//* No Attribute Value *//* IETF-defined Attributes *//* Vendor Specific Attribute *//*
	 * After this point, we don't need to check whether we go past
	 * the length of the captured data; however, we *do* need to
	 * check whether we go past the end of the AVP.
	 *//* If it goes past the end of the remaining length of the captured
	   data, we'll give up. *//* If it goes past the end of the remaining length of the packet,
	   we'll give up. *//* If it is not long enough to contain the header, we'll give up. *//* Flags & Length *//* Direction *//* Control Protocol Number *//* Disconnect Code *//* skip "Reserved" *//* Error Message (opt) *//* Error Code (opt) *//* Result Code *//***********************************//* AVP-specific print out routines *//******************************//* generic print out routines *//* PPP Disconnect Cause Code - RFC 3145 *//* Sequencing Required *//* (Rx) Connect Speed *//* Private Group ID *//* Random Vector *//* ACCM *//* Call Errors *//* Proxy Authen Response *//* Proxy Authen ID *//* Proxy Authen Challenge *//* Proxy Authen Name *//* Proxy Authen Type *//* Last Received LCP CONFREQ *//* Last Sent LCP CONFREQ *//* Initial Received LCP CONFREQ *//* Physical Channel ID *//* (Tx) Connect Speed *//* Sub-Address *//* Calling Number *//* Called Number *//* Packet Processing Delay (OBSOLETE) *//* Framing Type *//* Bearer Type *//* Maximum BPS *//* Minimum BPS *//* Call Serial Number *//* Assigned Session ID *//* Challenge Response *//* Q.931 Cause Code *//* Challenge *//* Receive Window Size *//* Assigned Tunnel ID *//* Vendor Name *//* Host Name *//* Firmware Revision *//* Tie Breaker *//* Bearer Capabilities *//* Framing Capabilities *//* Message Type *//* Set-Link-Info *//* WAN-Error-Notify *//* Call-Disconnect-Notify *//* Incoming-Call-Connected *//* Incoming-Call-Reply *//* Incoming-Call-Request *//* Outgoing-Call-Connected *//* Outgoing-Call-Reply *//* Outgoing-Call-Request *//* Hello *//* Stop-Control-Connection-Notification *//* Start-Control-Connection-Connected *//* Start-Control-Connection-Reply *//* Start-Control-Connection-Request *//* MSCHAPv1 *//* No Authentication *//* PPP PAP *//* PPP CHAP *//* Textual username/password exchange *//* Authen Type *//* Analog *//* Digital *//* Asynchronous *//* Synchronous *//* Length Mask *//* Hidden Flag *//* Mandatory Flag *//* L2TP *//* L2F *//* Version Mask *//* Priority *//* Offset *//* Sequence *//* Type (0=Data, 1=Control) *//* specification: RFC 2661 *//* \summary: Layer Two Tunneling Protocol (L2TP) printer *//*
 * Copyright (c) 1991, 1993, 1994, 1995, 1996, 1997
 *      The Regents of the University of California.  All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that: (1) source code distributions
 * retain the above copyright notice and this paragraph in its entirety, (2)
 * distributions including binary code include the above copyright notice and
 * this paragraph in its entirety in the documentation or other materials
 * provided with the distribution, and (3) all advertising materials mentioning
 * features or use of this software display the following acknowledgement:
 * ``This product includes software developed by the University of California,
 * Lawrence Berkeley Laboratory and its contributors.'' Neither the name of
 * the University nor the names of its contributors may be used to endorse
 * or promote products derived from this software without specific prior
 * written permission.
 * THIS SOFTWARE IS PROVIDED ``AS IS'' AND WITHOUT ANY EXPRESS OR IMPLIED
 * WARRANTIES, INCLUDING, WITHOUT LIMITATION, THE IMPLIED WARRANTIES OF
 * MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE.
 *
 * L2TP support contributed by Motonori Shindo (mshindo@mshindo.net)
 *//Users/owura/Repos/codeql_eval/proj_repos/the-tcpdump-group-tcpdump-commit-9ba91381954ad325ea4fd26b9c65a8bd9a2a85b6/tcpdump/print-lane.clane_if_printsizeof(struct lecdatahdr_8023)(sizeof(struct lecdatahdr_8023))lane_printconst lane_controlhdrconst lane_controlhdr *lane_controlhdr *lec(ndo, "[|lane]")sizeof(struct lane_controlhdr)[|lane]&lec->lec_header(ndo, "lec: proto %x vers %x %s", lec->lec_proto, lec->lec_vers, tok2str(lecop2str, "opcode-#%u", EXTRACT_16BITS(&lec->lec_opcode)))(ndo, "lec: proto %x vers %x %s", lec->lec_proto, lec->lec_vers, tok2str(lecop2str, "opcode-#%u", ((uint16_t)(((uint16_t)(*((const uint8_t *)(&lec->lec_opcode) + 0)) << 8) | ((uint16_t)(*((const uint8_t *)(&lec->lec_opcode) + 1)) << 0)))))&lec->lec_opcodelec: proto %x vers %x %sopcode-#%ulane_hdr_print(ndo, "lecid:%x ", EXTRACT_16BITS(bp))(ndo, "lecid:%x ", ((uint16_t)(((uint16_t)(*((const uint8_t *)(bp) + 0)) << 8) | ((uint16_t)(*((const uint8_t *)(bp) + 1)) << 0))))lecid:%x lane_controlhdrlecdatahdr_8023lec_opcodelec_verslec_protolec_headerh_typeh_sourceh_destle_headerconfigure request"configure request"configure response"configure response"join request"join request"join response"join response"ready query"ready query"ready indication"ready indication"register request"register request"register response"register response"unregister request"unregister request"unregister response"unregister response"ARP request"ARP request"2620x0106ARP response"ARP response"flush request"flush request"flush response"flush response"NARP request"NARP request"topology request"topology request"lecop2str/*
	 * Now print the encapsulated frame, under the assumption
	 * that it's an Ethernet frame.
	 *//*
	 * Go past the LE header.
	 *//*
		 * LE Control.
		 *//*
 * This is the top level routine of the printer.  'p' points
 * to the LANE header of the packet, 'h->ts' is the timestamp,
 * 'h->len' is the length of the packet off the wire, and 'h->caplen'
 * is the number of bytes actually captured.
 *
 * This assumes 802.3, not 802.5, LAN emulation.
 *//* \summary: ATM LANE printer *//Users/owura/Repos/codeql_eval/proj_repos/the-tcpdump-group-tcpdump-commit-9ba91381954ad325ea4fd26b9c65a8bd9a2a85b6/tcpdump/print-ldp.cldp_tlv_headerldp_pdu_printconst ldp_common_headerconst ldp_common_header *ldp_common_header *ldp_com_headerconst ldp_msg_headerconst ldp_msg_header *ldp_msg_header *ldp_msg_headermsg_tptrmsg_lenmsg_tlen*ldp_com_headersizeof(*ldp_com_header)&ldp_com_header->version(ndo, "%sLDP version %u packet not supported", (ndo->ndo_vflag < 1) ? "" : "\n\t", EXTRACT_16BITS(&ldp_com_header->version))(ndo, "%sLDP version %u packet not supported", (ndo->ndo_vflag < 1) ? "" : "\n\t", ((uint16_t)(((uint16_t)(*((const uint8_t *)(&ldp_com_header->version) + 0)) << 8) | ((uint16_t)(*((const uint8_t *)(&ldp_com_header->version) + 1)) << 0))))LDP_VERSION%sLDP version %u packet not supported&ldp_com_header->pdu_length(ndo, "%sLDP, pdu-length: %u (too short, < %u)", (ndo->ndo_vflag < 1) ? "" : "\n\t", pdu_len, (u_int)(sizeof(const struct ldp_common_header)-4))sizeof(const struct ldp_common_header)sizeof(const struct ldp_common_header)-4%sLDP, pdu-length: %u (too short, < %u)(ndo, "%sLDP, Label-Space-ID: %s:%u, pdu-length: %u", (ndo->ndo_vflag < 1) ? "" : "\n\t", ipaddr_string(ndo, &ldp_com_header->lsr_id), EXTRACT_16BITS(&ldp_com_header->label_space), pdu_len)(ndo, "%sLDP, Label-Space-ID: %s:%u, pdu-length: %u", (ndo->ndo_vflag < 1) ? "" : "\n\t", getname(ndo, (const u_char *)(&ldp_com_header->lsr_id)), ((uint16_t)(((uint16_t)(*((const uint8_t *)(&ldp_com_header->label_space) + 0)) << 8) | ((uint16_t)(*((const uint8_t *)(&ldp_com_header->label_space) + 1)) << 0))), pdu_len)%sLDP, Label-Space-ID: %s:%u, pdu-length: %u&ldp_com_header->lsr_id&ldp_com_header->label_space(sizeof(const struct ldp_common_header)-4)sizeof(struct ldp_msg_header)ldp_msg_header->lengthEXTRACT_16BITS(ldp_msg_header->type)((uint16_t)(((uint16_t)(*((const uint8_t *)(ldp_msg_header->type) + 0)) << 8) | ((uint16_t)(*((const uint8_t *)(ldp_msg_header->type) + 1)) << 0)))ldp_msg_header->type(ndo, "\n\t  %s Message (0x%04x), length: %u (too short, < %u)", tok2str(ldp_msg_values, "Unknown", msg_type), msg_type, msg_len, (u_int)(sizeof(struct ldp_msg_header)-4))(ndo, "\n\t  %s Message (0x%04x), length: %u, Message ID: 0x%08x, Flags: [%s if unknown]", tok2str(ldp_msg_values, "Unknown", msg_type), msg_type, msg_len, EXTRACT_32BITS(&ldp_msg_header->id), LDP_MASK_U_BIT(EXTRACT_16BITS(&ldp_msg_header->type)) ? "continue processing" : "ignore")(ndo, "\n\t  %s Message (0x%04x), length: %u, Message ID: 0x%08x, Flags: [%s if unknown]", tok2str(ldp_msg_values, "Unknown", msg_type), msg_type, msg_len, ((uint32_t)(((uint32_t)(*((const uint8_t *)(&ldp_msg_header->id) + 0)) << 24) | ((uint32_t)(*((const uint8_t *)(&ldp_msg_header->id) + 1)) << 16) | ((uint32_t)(*((const uint8_t *)(&ldp_msg_header->id) + 2)) << 8) | ((uint32_t)(*((const uint8_t *)(&ldp_msg_header->id) + 3)) << 0))), ((((uint16_t)(((uint16_t)(*((const uint8_t *)(&ldp_msg_header->type) + 0)) << 8) | ((uint16_t)(*((const uint8_t *)(&ldp_msg_header->type) + 1)) << 0))))&0x8000) ? "continue processing" : "ignore")&ldp_msg_header->idEXTRACT_16BITS(&ldp_msg_header->type)((uint16_t)(((uint16_t)(*((const uint8_t *)(&ldp_msg_header->type) + 0)) << 8) | ((uint16_t)(*((const uint8_t *)(&ldp_msg_header->type) + 1)) << 0)))&ldp_msg_header->typesizeof(struct ldp_msg_header)-4
	  %s Message (0x%04x), length: %u (too short, < %u)
	  %s Message (0x%04x), length: %u, Message ID: 0x%08x, Flags: [%s if unknown]continue processingignore(sizeof(struct ldp_msg_header)-4)LDP_MSG_NOTIFLDP_MSG_HELLOLDP_MSG_INITLDP_MSG_KEEPALIVELDP_MSG_ADDRESSLDP_MSG_LABEL_MAPPINGLDP_MSG_ADDRESS_WITHDRAW1026LDP_MSG_LABEL_WITHDRAWLDP_MSG_LABEL_REQUEST1027LDP_MSG_LABEL_RELEASE1028LDP_MSG_LABEL_ABORT_REQUESTldp_print(ndo, " [remaining length %u < %u]", len, processed)sizeof(struct ldp_common_header)sizeof(struct ldp_common_header) + sizeof(struct ldp_msg_header)(sizeof(struct ldp_common_header) + sizeof(struct ldp_msg_header)) [remaining length %u < %u]ldp_tlv_printconst ldp_tlv_headerconst ldp_tlv_header *ldp_tlv_header *ft_flagsfec_typeuivc_info_lenvc_info_tlv_typevc_info_tlv_lenchar[100]*ldp_tlv_headersizeof(*ldp_tlv_header)ldp_tlv_header->length(ndo, "\n\t\t TLV contents go past end of message")
		 TLV contents go past end of messageEXTRACT_16BITS(ldp_tlv_header->type)((uint16_t)(((uint16_t)(*((const uint8_t *)(ldp_tlv_header->type) + 0)) << 8) | ((uint16_t)(*((const uint8_t *)(ldp_tlv_header->type) + 1)) << 0)))ldp_tlv_header->type(ndo, "\n\t    %s TLV (0x%04x), length: %u, Flags: [%s and %s forward if unknown]", tok2str(ldp_tlv_values, "Unknown", tlv_type), tlv_type, tlv_len, LDP_MASK_U_BIT(EXTRACT_16BITS(&ldp_tlv_header->type)) ? "continue processing" : "ignore", LDP_MASK_F_BIT(EXTRACT_16BITS(&ldp_tlv_header->type)) ? "do" : "don't")(ndo, "\n\t    %s TLV (0x%04x), length: %u, Flags: [%s and %s forward if unknown]", tok2str(ldp_tlv_values, "Unknown", tlv_type), tlv_type, tlv_len, ((((uint16_t)(((uint16_t)(*((const uint8_t *)(&ldp_tlv_header->type) + 0)) << 8) | ((uint16_t)(*((const uint8_t *)(&ldp_tlv_header->type) + 1)) << 0))))&0x8000) ? "continue processing" : "ignore", ((((uint16_t)(((uint16_t)(*((const uint8_t *)(&ldp_tlv_header->type) + 0)) << 8) | ((uint16_t)(*((const uint8_t *)(&ldp_tlv_header->type) + 1)) << 0))))&0x4000) ? "do" : "don't")
	    %s TLV (0x%04x), length: %u, Flags: [%s and %s forward if unknown]&ldp_tlv_header->typeEXTRACT_16BITS(&ldp_tlv_header->type)((uint16_t)(((uint16_t)(*((const uint8_t *)(&ldp_tlv_header->type) + 0)) << 8) | ((uint16_t)(*((const uint8_t *)(&ldp_tlv_header->type) + 1)) << 0)))dodon'tsizeof(struct ldp_tlv_header)(ndo, "\n\t      Hold Time: %us, Flags: [%s Hello%s]", EXTRACT_16BITS(tptr), (EXTRACT_16BITS(tptr+2)&0x8000) ? "Targeted" : "Link", (EXTRACT_16BITS(tptr+2)&0x4000) ? ", Request for targeted Hellos" : "")(ndo, "\n\t      Hold Time: %us, Flags: [%s Hello%s]", ((uint16_t)(((uint16_t)(*((const uint8_t *)(tptr) + 0)) << 8) | ((uint16_t)(*((const uint8_t *)(tptr) + 1)) << 0))), (((uint16_t)(((uint16_t)(*((const uint8_t *)(tptr+2) + 0)) << 8) | ((uint16_t)(*((const uint8_t *)(tptr+2) + 1)) << 0)))&0x8000) ? "Targeted" : "Link", (((uint16_t)(((uint16_t)(*((const uint8_t *)(tptr+2) + 0)) << 8) | ((uint16_t)(*((const uint8_t *)(tptr+2) + 1)) << 0)))&0x4000) ? ", Request for targeted Hellos" : "")(ndo, "\n\t      IPv4 Transport Address: %s", ipaddr_string(ndo, tptr))(ndo, "\n\t      IPv4 Transport Address: %s", getname(ndo, (const u_char *)(tptr)))(ndo, "\n\t      IPv6 Transport Address: %s", ip6addr_string(ndo, tptr))(ndo, "\n\t      IPv6 Transport Address: %s", getname6(ndo, (const u_char *)(tptr)))(ndo, "\n\t      Sequence Number: %u", EXTRACT_32BITS(tptr))(ndo, "\n\t      Sequence Number: %u", ((uint32_t)(((uint32_t)(*((const uint8_t *)(tptr) + 0)) << 24) | ((uint32_t)(*((const uint8_t *)(tptr) + 1)) << 16) | ((uint32_t)(*((const uint8_t *)(tptr) + 2)) << 8) | ((uint32_t)(*((const uint8_t *)(tptr) + 3)) << 0))))LDP_TLV_ADDRESS_LIST_AFNUM_LEN(ndo, "\n\t      Address Family: %s, addresses", tok2str(af_values, "Unknown (%u)", af))(ndo, " %s", ipaddr_string(ndo, tptr))(ndo, " %s", getname(ndo, (const u_char *)(tptr)))(ndo, " %s", ip6addr_string(ndo, tptr))(ndo, " %s", getname6(ndo, (const u_char *)(tptr)))(ndo, "\n\t      Version: %u, Keepalive: %us, Flags: [Downstream %s, Loop Detection %s]", EXTRACT_16BITS(tptr), EXTRACT_16BITS(tptr+2), (EXTRACT_16BITS(tptr+6)&0x8000) ? "On Demand" : "Unsolicited", (EXTRACT_16BITS(tptr+6)&0x4000) ? "Enabled" : "Disabled" )(ndo, "\n\t      Version: %u, Keepalive: %us, Flags: [Downstream %s, Loop Detection %s]", ((uint16_t)(((uint16_t)(*((const uint8_t *)(tptr) + 0)) << 8) | ((uint16_t)(*((const uint8_t *)(tptr) + 1)) << 0))), ((uint16_t)(((uint16_t)(*((const uint8_t *)(tptr+2) + 0)) << 8) | ((uint16_t)(*((const uint8_t *)(tptr+2) + 1)) << 0))), (((uint16_t)(((uint16_t)(*((const uint8_t *)(tptr+6) + 0)) << 8) | ((uint16_t)(*((const uint8_t *)(tptr+6) + 1)) << 0)))&0x8000) ? "On Demand" : "Unsolicited", (((uint16_t)(((uint16_t)(*((const uint8_t *)(tptr+6) + 0)) << 8) | ((uint16_t)(*((const uint8_t *)(tptr+6) + 1)) << 0)))&0x4000) ? "Enabled" : "Disabled" )(ndo, "\n\t      %s FEC (0x%02x)", tok2str(ldp_fec_values, "Unknown", fec_type), fec_type)(ndo, ": IPv4 prefix (goes past end of TLV)")(ndo, ": IPv4 prefix (invalid length)")(ndo, ": IPv4 prefix %s", buf)(ndo, ": IPv6 prefix (invalid length)")(ndo, ": IPv6 prefix %s", buf)(ndo, ": Address family %u prefix", af)(ndo, ": %s, %scontrol word, group-ID %u, VC-info-length: %u", tok2str(mpls_pw_types_values, "Unknown", EXTRACT_16BITS(tptr)&0x7fff), EXTRACT_16BITS(tptr)&0x8000 ? "" : "no ", EXTRACT_32BITS(tptr+3), vc_info_len)(ndo, ": %s, %scontrol word, group-ID %u, VC-info-length: %u", tok2str(mpls_pw_types_values, "Unknown", ((uint16_t)(((uint16_t)(*((const uint8_t *)(tptr) + 0)) << 8) | ((uint16_t)(*((const uint8_t *)(tptr) + 1)) << 0)))&0x7fff), ((uint16_t)(((uint16_t)(*((const uint8_t *)(tptr) + 0)) << 8) | ((uint16_t)(*((const uint8_t *)(tptr) + 1)) << 0)))&0x8000 ? "" : "no ", ((uint32_t)(((uint32_t)(*((const uint8_t *)(tptr+3) + 0)) << 24) | ((uint32_t)(*((const uint8_t *)(tptr+3) + 1)) << 16) | ((uint32_t)(*((const uint8_t *)(tptr+3) + 2)) << 8) | ((uint32_t)(*((const uint8_t *)(tptr+3) + 3)) << 0))), vc_info_len)(ndo, ": %s, %scontrol word, group-ID %u, VC-ID %u, VC-info-length: %u", tok2str(mpls_pw_types_values, "Unknown", EXTRACT_16BITS(tptr)&0x7fff), EXTRACT_16BITS(tptr)&0x8000 ? "" : "no ", EXTRACT_32BITS(tptr+3), EXTRACT_32BITS(tptr+7), vc_info_len)(ndo, ": %s, %scontrol word, group-ID %u, VC-ID %u, VC-info-length: %u", tok2str(mpls_pw_types_values, "Unknown", ((uint16_t)(((uint16_t)(*((const uint8_t *)(tptr) + 0)) << 8) | ((uint16_t)(*((const uint8_t *)(tptr) + 1)) << 0)))&0x7fff), ((uint16_t)(((uint16_t)(*((const uint8_t *)(tptr) + 0)) << 8) | ((uint16_t)(*((const uint8_t *)(tptr) + 1)) << 0)))&0x8000 ? "" : "no ", ((uint32_t)(((uint32_t)(*((const uint8_t *)(tptr+3) + 0)) << 24) | ((uint32_t)(*((const uint8_t *)(tptr+3) + 1)) << 16) | ((uint32_t)(*((const uint8_t *)(tptr+3) + 2)) << 8) | ((uint32_t)(*((const uint8_t *)(tptr+3) + 3)) << 0))), ((uint32_t)(((uint32_t)(*((const uint8_t *)(tptr+7) + 0)) << 24) | ((uint32_t)(*((const uint8_t *)(tptr+7) + 1)) << 16) | ((uint32_t)(*((const uint8_t *)(tptr+7) + 2)) << 8) | ((uint32_t)(*((const uint8_t *)(tptr+7) + 3)) << 0))), vc_info_len)tptr+7(ndo, " (invalid, < 4")(ndo, "\n\t\tInterface Parameter: %s (0x%02x), len %u", tok2str(ldp_fec_martini_ifparm_values,"Unknown",vc_info_tlv_type), vc_info_tlv_type, vc_info_tlv_len)*(tptr + 2)(ndo, ": %u", EXTRACT_16BITS(tptr+2))(ndo, ": %u", ((uint16_t)(((uint16_t)(*((const uint8_t *)(tptr+2) + 0)) << 8) | ((uint16_t)(*((const uint8_t *)(tptr+2) + 1)) << 0))))tptr + idx*(tptr + idx)(ndo, "\n\t\t  Control Channels (0x%02x) = [%s]", *(tptr+2), bittok2str(ldp_fec_martini_ifparm_vccv_cc_values, "none", *(tptr+2)))tptr + 3*(tptr + 3)(ndo, "\n\t\t  CV Types (0x%02x) = [%s]", *(tptr+3), bittok2str(ldp_fec_martini_ifparm_vccv_cv_values, "none", *(tptr+3)))(ndo, "\n\t      Label: %u", EXTRACT_32BITS(tptr) & 0xfffff)(ndo, "\n\t      Label: %u", ((uint32_t)(((uint32_t)(*((const uint8_t *)(tptr) + 0)) << 24) | ((uint32_t)(*((const uint8_t *)(tptr) + 1)) << 16) | ((uint32_t)(*((const uint8_t *)(tptr) + 2)) << 8) | ((uint32_t)(*((const uint8_t *)(tptr) + 3)) << 0))) & 0xfffff)(ndo, "\n\t      Status: 0x%02x, Flags: [%s and %s forward]", ui&0x3fffffff, ui&0x80000000 ? "Fatal error" : "Advisory Notification", ui&0x40000000 ? "do" : "don't")(ndo, ", causing Message ID: 0x%08x", ui)(ndo, "\n\t      Flags: [%sReconnect, %sSave State, %sAll-Label Protection, %s Checkpoint, %sRe-Learn State]", ft_flags&0x8000 ? "" : "No ", ft_flags&0x8 ? "" : "Don't ", ft_flags&0x4 ? "" : "No ", ft_flags&0x2 ? "Sequence Numbered Label" : "All Labels", ft_flags&0x1 ? "" : "Don't ")(ndo, ", Reconnect Timeout: %ums", ui)(ndo, ", Recovery Time: %ums", ui)(ndo, "\n\t      MTU: %u", EXTRACT_16BITS(tptr))(ndo, "\n\t      MTU: %u", ((uint16_t)(((uint16_t)(*((const uint8_t *)(tptr) + 0)) << 8) | ((uint16_t)(*((const uint8_t *)(tptr) + 1)) << 0))))LDP_TLV_COMMON_HELLO
	      Hold Time: %us, Flags: [%s Hello%s]TargetedLink, Request for targeted HellosLDP_TLV_IPV4_TRANSPORT_ADDR
	      IPv4 Transport Address: %sLDP_TLV_IPV6_TRANSPORT_ADDR
	      IPv6 Transport Address: %sLDP_TLV_CONFIG_SEQ_NUMBER
	      Sequence Number: %uLDP_TLV_ADDRESS_LIST
	      Address Family: %s, addressesLDP_TLV_COMMON_SESSION
	      Version: %u, Keepalive: %us, Flags: [Downstream %s, Loop Detection %s]char[79]On DemandUnsolicitedEnabledDisabledLDP_TLV_FEC
	      %s FEC (0x%02x)LDP_FEC_WILDCARDLDP_FEC_PREFIX: IPv4 prefix (goes past end of TLV): IPv4 prefix (invalid length): IPv4 prefix %s: IPv6 prefix (invalid length): IPv6 prefix %s: Address family %u prefixLDP_FEC_HOSTADDRESSLDP_FEC_MARTINI_VC: %s, %scontrol word, group-ID %u, VC-info-length: %u: %s, %scontrol word, group-ID %u, VC-ID %u, VC-info-length: %u (invalid, < 4
		Interface Parameter: %s (0x%02x), len %uLDP_FEC_MARTINI_IFPARM_MTU: %uLDP_FEC_MARTINI_IFPARM_DESCLDP_FEC_MARTINI_IFPARM_VCCV
		  Control Channels (0x%02x) = [%s]
		  CV Types (0x%02x) = [%s]LDP_TLV_GENERIC_LABEL
	      Label: %uLDP_TLV_STATUS
	      Status: 0x%02x, Flags: [%s and %s forward]Fatal errorAdvisory Notification, causing Message ID: 0x%08x1283LDP_TLV_FT_SESSION
	      Flags: [%sReconnect, %sSave State, %sAll-Label Protection, %s Checkpoint, %sRe-Learn State]No Don't Sequence Numbered LabelAll Labels, Reconnect Timeout: %ums, Recovery Time: %ums1537LDP_TLV_MTU
	      MTU: %uLDP_TLV_HOP_COUNTLDP_TLV_PATH_VECTORLDP_TLV_ATM_LABELLDP_TLV_FR_LABELLDP_TLV_EXTD_STATUSLDP_TLV_RETURNED_PDULDP_TLV_RETURNED_MSG1281LDP_TLV_ATM_SESSION_PARM1282LDP_TLV_FR_SESSION_PARMLDP_TLV_LABEL_REQUEST_MSG_ID(ndo, "\n\t\t TLV contents go past end of TLV")
		 TLV contents go past end of TLVldp_common_headerlabel_spacelsr_idpdu_lengthICMP Ping"ICMP Ping"LSP Ping"LSP Ping"BFD"BFD"ldp_fec_martini_ifparm_vccv_cv_valuesPWE3 control word"PWE3 control word"MPLS Router Alert Label"MPLS Router Alert Label"MPLS inner label TTL = 1"MPLS inner label TTL = 1"ldp_fec_martini_ifparm_vccv_cc_valuesDescription"Description"VCCV"VCCV"ldp_fec_martini_ifparm_valuesWildcard"Wildcard"Prefix"Prefix"Host address"Host address"Martini VC"Martini VC"ldp_fec_valuesFEC"FEC"Address List"Address List"Hop Count"Hop Count"Path Vector"Path Vector"Generic Label"Generic Label"ATM Label"ATM Label"Frame-Relay Label"Frame-Relay Label"Extended Status"Extended Status"Returned PDU"Returned PDU"Returned Message"Returned Message"Common Hello Parameters"Common Hello Parameters"IPv4 Transport Address"IPv4 Transport Address"Configuration Sequence Number"Configuration Sequence Number"IPv6 Transport Address"IPv6 Transport Address"Common Session Parameters"Common Session Parameters"ATM Session Parameters"ATM Session Parameters"Frame-Relay Session Parameters"Frame-Relay Session Parameters"Fault-Tolerant Session Parameters"Fault-Tolerant Session Parameters"Label Request Message ID"Label Request Message ID"ldp_tlv_valuesInitialization"Initialization"Address Withdraw"Address Withdraw"Label Mapping"Label Mapping"Label Request"Label Request"Label Withdraw"Label Withdraw"Label Release"Label Release"Label Abort Request"Label Abort Request"ldp_msg_values [|LDP]" [|LDP]"TLV_TCHECK(minlen)ND_TCHECK2(*tptr, minlen); if (tlv_tlen < minlen) goto badtlv;0x06010x05030x05020x05010x04030x04020x04010x03010x0300LDP_MASK_F_BIT(x)((x)&0x4000)LDP_MASK_TLV_TYPE(x)((x)&0x3fff)LDP_EXPERIMENTAL_MAXLDP_EXPERIMENTAL_MIN0x3f00LDP_VENDOR_PRIVATE_MAX0x3effLDP_VENDOR_PRIVATE_MIN0x3e000x0404LDP_MASK_U_BIT(x)((x)&0x8000)LDP_MASK_MSG_TYPE(x)((x)&0x7fff)/*
         *  FIXME those are the defined messages that lack a decoder
         *  you are welcome to contribute code ;-)
         *//* did we capture enough for fully decoding the message ? *//* Type & Length fields not included *//* FIXME vendor private / experimental check *//* length too short *//* did we capture enough for fully decoding the msg header ? *//* bail out if non-verbose *//* print the LSR-ID, label-space & length *//*
     *  FIXME those are the defined TLVs that lack a decoder
     *  you are welcome to contribute code ;-)
     *//* 16 bits (FT Flags) + 16 bits (Reserved) *//* Skip past the fixed information and the VC ID *//* subtract out the VC ID, giving the length of the interface parameters *//* minimum 4, for the VC ID *//* Make sure we have the VC ID as well *//*
	     * According to RFC 4908, the VC info Length field can be zero,
	     * in which case not only are there no interface parameters,
	     * there's no VC ID.
	     *//*
             * We assume the type was supposed to be one of the MPLS
             * Pseudowire Types.
             *//* unknown AF *//*
 * ldp tlv header
 *
 *  0                   1                   2                   3
 *  0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
 * +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
 * |U|F|        Type               |            Length             |
 * +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
 * |                                                               |
 * |                             Value                             |
 * ~                                                               ~
 * |                                                               |
 * |                               +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
 * |                               |
 * +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
 *//* draft-ietf-pwe3-vccv-04.txt *//* From RFC 4906; should probably be updated to RFC 4447 (e.g., VC -> PW) *//* rfc 3988 *//*
 * ldp message header
 *
 *  0                   1                   2                   3
 *  0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
 * +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
 * |U|   Message Type              |      Message Length           |
 * +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
 * |                     Message ID                                |
 * +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
 * |                                                               |
 * +                                                               +
 * |                     Mandatory Parameters                      |
 * +                                                               +
 * |                                                               |
 * +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
 * |                                                               |
 * +                                                               +
 * |                     Optional Parameters                       |
 * +                                                               +
 * |                                                               |
 * +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
 *//*
 * ldp common header
 *
 *  0                   1                   2                   3
 *  0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
 * +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
 * |  Version                      |         PDU Length            |
 * +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
 * |                         LDP Identifier                        |
 * +                               +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
 * |                               |
 * +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
 *
 *//* \summary: Label Distribution Protocol (LDP) printer *//*
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that: (1) source code
 * distributions retain the above copyright notice and this paragraph
 * in its entirety, and (2) distributions including binary code include
 * the above copyright notice and this paragraph in its entirety in
 * the documentation or other materials provided with the distribution.
 * THIS SOFTWARE IS PROVIDED ``AS IS'' AND
 * WITHOUT ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, WITHOUT
 * LIMITATION, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS
 * FOR A PARTICULAR PURPOSE.
 *
 * Original code by Hannes Gredler (hannes@gredler.at)
 *  and Steinar Haug (sthaug@nethelp.no)
 *//Users/owura/Repos/codeql_eval/proj_repos/the-tcpdump-group-tcpdump-commit-9ba91381954ad325ea4fd26b9c65a8bd9a2a85b6/tcpdump/print-lisp.c<netdissect.h>loc_hdr_flag(ndo, " flags [%s],", bittok2str(lisp_loc_flag, "none", flag)) flags [%s],action_flagactionauthoritative(ndo, " Authoritative,")(ndo, " Non-Authoritative,") Authoritative, Non-Authoritative,(ndo, " %s,", tok2str(lisp_eid_action, "unknown", action)) %s,lisp_hdr_flagconst lisp_map_register_hdrconst lisp_map_register_hdr *map_register_hdr *(ndo, "%s,", tok2str(lisp_type, "unknown-type-%u", type))%s,(ndo, " flags [%s],", bittok2str(map_register_hdr_flag, "none", EXTRACT_32BITS(lisp_hdr)))(ndo, " flags [%s],", bittok2str(map_register_hdr_flag, "none", ((uint32_t)(((uint32_t)(*((const uint8_t *)(lisp_hdr) + 0)) << 24) | ((uint32_t)(*((const uint8_t *)(lisp_hdr) + 1)) << 16) | ((uint32_t)(*((const uint8_t *)(lisp_hdr) + 2)) << 8) | ((uint32_t)(*((const uint8_t *)(lisp_hdr) + 3)) << 0)))))lisp_hdr(ndo, " flags [%s],", bittok2str(map_notify_hdr_flag, "none", EXTRACT_32BITS(lisp_hdr)))(ndo, " flags [%s],", bittok2str(map_notify_hdr_flag, "none", ((uint32_t)(((uint32_t)(*((const uint8_t *)(lisp_hdr) + 0)) << 24) | ((uint32_t)(*((const uint8_t *)(lisp_hdr) + 1)) << 16) | ((uint32_t)(*((const uint8_t *)(lisp_hdr) + 2)) << 8) | ((uint32_t)(*((const uint8_t *)(lisp_hdr) + 3)) << 0)))))LISP_MAP_REGISTERLISP_MAP_NOTIFYis_xtr_data_presentxtr_presentLISP_MAP_REGISTER_IBIT_MASKLISP_MAP_NOTIFY_IBIT_MASKextract_lisp_typeTYPE_INDEXlisp_printmask_lenloc_countrecord_counteid_afiloc_afimap_versionpacket_offsetauth_data_lenpacket_iteratorloc_ip_pointerconst lisp_map_register_eidconst lisp_map_register_eid *map_register_eid *lisp_eidconst lisp_map_register_locconst lisp_map_register_loc *map_register_loc *lisp_locMAP_REGISTER_HDR_LENsizeof(lisp_map_register_hdr)&lisp_hdr->auth_data_len&lisp_hdr->key_id(ndo, "\n    %u record(s), ", record_count)(ndo, "Authentication %s,", tok2str(auth_type, "unknown-type", key_id))(ndo, " %u record(s),", record_count)
    %u record(s), Authentication %s,unknown-type
    Authentication-Data: "\n    Authentication-Data: " %u record(s),*(packet_iterator + packet_offset)MAP_REGISTER_EID_LENsizeof(lisp_map_register_eid)&lisp_eid->eid_prefix_afi&lisp_eid->ttl(ndo, "      Record TTL %u,", ttl)(ndo, " Map Version: %u,", map_version)(ndo, " EID %s/%u,", ipaddr_string(ndo, packet_iterator + packet_offset), mask_len)(ndo, " EID %s/%u,", getname(ndo, (const u_char *)(packet_iterator + packet_offset)), mask_len)packet_iterator + packet_offset(ndo, " EID %s/%u,", ip6addr_string(ndo, packet_iterator + packet_offset), mask_len)(ndo, " EID %s/%u,", getname6(ndo, (const u_char *)(packet_iterator + packet_offset)), mask_len)(ndo, " %u locator(s)", loc_count)MAP_REGISTER_LOC_LENsizeof(lisp_map_register_loc)&lisp_loc->locator_afi(ndo, "\n       ")(ndo, " LOC %s", ipaddr_string(ndo, loc_ip_pointer))(ndo, " LOC %s", getname(ndo, (const u_char *)(loc_ip_pointer)))(ndo, " LOC %s", ip6addr_string(ndo, loc_ip_pointer))(ndo, " LOC %s", getname6(ndo, (const u_char *)(loc_ip_pointer)))(ndo, "\n          Priority/Weight %u/%u," " Multicast Priority/Weight %u/%u,", lisp_loc->priority, lisp_loc->weight, lisp_loc->m_priority, lisp_loc->m_weight)&lisp_loc->unused_and_flagact_auth_inc_reslisp_hdr_flags      Record TTL %u, Map Version: %u,IPv4_AFI EID %s/%u,IPv6_AFI %u locator(s)
        LOC %s
          Priority/Weight %u/%u, Multicast Priority/Weight %u/%u,(ndo, "\n    SITE-ID: %" PRIu64, EXTRACT_64BITS(packet_iterator + packet_offset + 16))(ndo, "\n    SITE-ID: %" "ll" "u", ((uint64_t)(((uint64_t)(*((const uint8_t *)(packet_iterator + packet_offset + 16) + 0)) << 56) | ((uint64_t)(*((const uint8_t *)(packet_iterator + packet_offset + 16) + 1)) << 48) | ((uint64_t)(*((const uint8_t *)(packet_iterator + packet_offset + 16) + 2)) << 40) | ((uint64_t)(*((const uint8_t *)(packet_iterator + packet_offset + 16) + 3)) << 32) | ((uint64_t)(*((const uint8_t *)(packet_iterator + packet_offset + 16) + 4)) << 24) | ((uint64_t)(*((const uint8_t *)(packet_iterator + packet_offset + 16) + 5)) << 16) | ((uint64_t)(*((const uint8_t *)(packet_iterator + packet_offset + 16) + 6)) << 8) | ((uint64_t)(*((const uint8_t *)(packet_iterator + packet_offset + 16) + 7)) << 0))))packet_iterator + packet_offset + 16
    xTR-ID: "\n    xTR-ID: "
    SITE-ID: %llu
    Data: "\n    Data: "(ndo, "\n   %s", tstr)
   %s(ndo, "\n   %s", istr)lisp_map_register_locmap_register_loclisp_map_register_eidmap_register_eidlisp_map_register_hdrmap_register_hdrLISP_AUTH_NONELISP_AUTH_SHA1LISP_AUTH_SHA256LISP_MAP_REQUESTLISP_MAP_REPLYLISP_ENCAPSULATED_CONTROL_MESSAGElocator_afiunused_and_flagm_weightm_priorityweighteid_prefix_afiversion_lowreserved_version_hieid_prefix_mask_lengthlocator_countreserved_and_flag2type_and_flagLocal-Locator"Local-Locator"RLoc-Probed"RLoc-Probed"Reachable"Reachable"lisp_loc_flagNo-Action"No-Action"Natively-Forward"Natively-Forward"Send-Map-Request"Send-Map-Request"Drop"Drop"lisp_eid_actionNone"None"SHA1"SHA1"SHA256"SHA256"I-xTR-ID-Present"I-xTR-ID-Present"671088640x04000000R-Build-For-RTR"R-Build-For-RTR"map_notify_hdr_flagP-Proxy-Map-Reply"P-Proxy-Map-Reply"S-LISP-SEC-Capable"S-LISP-SEC-Capable"167772160x01000000M-Want-Map-Notify"M-Want-Map-Notify"map_register_hdr_flagLISP-Reserved"LISP-Reserved"LISP-Map-Request"LISP-Map-Request"LISP-Map-Reply"LISP-Map-Reply"LISP-Map-Register"LISP-Map-Register"LISP-Map-Notify"LISP-Map-Notify"LISP-Encapsulated-Contol-Message"LISP-Encapsulated-Contol-Message"lisp_type [|LISP]" [|LISP]"/* Check if packet isn't over yet *//*
	 * Print xTR and Site ID. Handle the fact that the packet could be invalid.
	 * If the xTR_ID_Present bit is not set, and we still have data to display,
	 * show it as hex data.
	 *//*
			 * No support for LCAF right now.
			 *//* Print all the EID records *//* Extract the number of EID records present *//* Find if the packet contains xTR and Site-ID data *//* Supporting only MAP NOTIFY and MAP REGISTER LISP packets *//* Check if enough bytes for header are available *//*
 * P-Bit : Request for Proxy Map-Reply from the MS/MR
 * S-Bit : Security Enhancement. ETR is LISP-SEC enabled. draft-ietf-lisp-sec
 * I-Bit : 128 bit xTR-ID and 64 bit Site-ID present.
 *	   xTR-ID and Site-ID help in differentiation of xTRs in multi xTR
 *	   and multi Site deployment scenarios.
 * R-Bit : Built for a Reencapsulating-Tunnel-Router. Used in Traffic
 *	   Engineering and Service Chaining
 *//*
 * specification: RFC 6830
 *
 *
 * The Map-Register message format is:
 *
 *       0                   1                   2                   3
 *       0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
 *      +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
 *      |Type=3 |P|S|I|R|      Reserved               |M| Record Count  |
 *      +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
 *      |                         Nonce . . .                           |
 *      +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
 *      |                         . . . Nonce                           |
 *      +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
 *      |            Key ID             |  Authentication Data Length   |
 *      +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
 *      ~                     Authentication Data                       ~
 *  +-> +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
 *  |   |                          Record TTL                           |
 *  |   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
 *  R   | Locator Count | EID mask-len  | ACT |A|      Reserved         |
 *  e   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
 *  c   | Rsvd  |  Map-Version Number   |        EID-Prefix-AFI         |
 *  o   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
 *  r   |                          EID-Prefix                           |
 *  d   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
 *  |  /|    Priority   |    Weight     |  M Priority   |   M Weight    |
 *  | L +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
 *  | o |        Unused Flags     |L|p|R|           Loc-AFI             |
 *  | c +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
 *  |  \|                             Locator                           |
 *  +-> +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
 *
 *
 * The Map-Notify message format is:
 *
 *       0                   1                   2                   3
 *       0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
 *      +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
 *      |Type=4 |I|R|          Reserved                 | Record Count  |
 *      +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
 *      |                         Nonce . . .                           |
 *      +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
 *      |                         . . . Nonce                           |
 *      +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
 *      |            Key ID             |  Authentication Data Length   |
 *      +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
 *      ~                     Authentication Data                       ~
 *  +-> +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
 *  |   |                          Record TTL                           |
 *  |   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
 *  R   | Locator Count | EID mask-len  | ACT |A|      Reserved         |
 *  e   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
 *  c   | Rsvd  |  Map-Version Number   |         EID-Prefix-AFI        |
 *  o   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
 *  r   |                          EID-Prefix                           |
 *  d   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
 *  |  /|    Priority   |    Weight     |  M Priority   |   M Weight    |
 *  | L +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
 *  | o |        Unused Flags     |L|p|R|           Loc-AFI             |
 *  | c +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
 *  |  \|                             Locator                           |
 *  +-> +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
 *//* \summary: - Locator/Identifier Separation Protocol (LISP) printer *//*
 * Copyright (c) 2015 Ritesh Ranjan (r.ranjan789@gmail.com)
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. The name of the author may not be used to endorse or promote products
 *    derived from this software without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
 * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
 * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT,
 * INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
 * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
 * SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
 * STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN
 * ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
 * POSSIBILITY OF SUCH DAMAGE.
 *//Users/owura/Repos/codeql_eval/proj_repos/the-tcpdump-group-tcpdump-commit-9ba91381954ad325ea4fd26b9c65a8bd9a2a85b6/tcpdump/print-llc.csnap_printorgcodeetp + 3(ndo, "oui %s (0x%06x), %s %s (0x%04x), length %u: ", tok2str(oui_values, "Unknown", orgcode), orgcode, (orgcode == 0x000000 ? "ethertype" : "pid"), tok2str(oui_to_struct_tok(orgcode), "Unknown", et), et, length - 5)oui %s (0x%06x), %s %s (0x%04x), length %u: ethertypepidbridge_padbridge_pad + 181968195268(ndo, "%s > %s ", (src->addr_string)(ndo, src->addr), (dst->addr_string)(ndo, dst->addr))(ndo, "SNAP, ethertype %s (0x%04x), length %u: ", tok2str(ethertype_values, "Unknown", et), et, length)(ndo, "SNAP, oui %s (0x%06x), pid %s (0x%04x), length %u: ", tok2str(oui_values, "Unknown", orgcode), orgcode, tok2str(oui_to_struct_tok(orgcode), "Unknown", et), et, length)%s > %s SNAP, ethertype %s (0x%04x), length %u: SNAP, oui %s (0x%06x), pid %s (0x%04x), length %u: (ndo, "[|snap]")[|snap]oui_to_struct_toktokconst oui_tokconst oui_tok *oui_tok *otpconst oui_tok[6]oui_tok[6]llc_printdsap_fielddsapssap_fieldssapis_u(ndo, "[|llc]")(const u_char *)p[|llc](ndo, "IPX 802.3: ")IPX 802.3: ~LLC_IG~LLC_GSAP(ndo, "LLC, dsap %s (0x%02x) %s, ssap %s (0x%02x) %s", tok2str(llc_values, "Unknown", dsap), dsap, tok2str(llc_ig_flag_values, "Unknown", dsap_field & LLC_IG), tok2str(llc_values, "Unknown", ssap), ssap, tok2str(llc_flag_values, "Unknown", ssap_field & LLC_GSAP))(ndo, "LLC, dsap %s (0x%02x) %s, ssap %s (0x%02x) %s", tok2str(llc_values, "Unknown", dsap), dsap, tok2str(llc_ig_flag_values, "Unknown", dsap_field & 1), tok2str(llc_values, "Unknown", ssap), ssap, tok2str(llc_flag_values, "Unknown", ssap_field & 1))(ndo, ", ctrl 0x%02x: ", control)(ndo, ", ctrl 0x%04x: ", control)LLC, dsap %s (0x%02x) %s, ssap %s (0x%02x) %s, ctrl 0x%02x: , ctrl 0x%04x: (ndo, "IPX 802.2: ")IPX 802.2: (ndo, "%s ", tok2str(llc_values, "Unknown DSAP 0x%02x", dsap))(ndo, "%s > %s %s ", (src->addr_string)(ndo, src->addr), (dst->addr_string)(ndo, dst->addr), tok2str(llc_values, "Unknown DSAP 0x%02x", dsap))(ndo, "%s > %s ", tok2str(llc_values, "Unknown SSAP 0x%02x", ssap), tok2str(llc_values, "Unknown DSAP 0x%02x", dsap))(ndo, "%s %s > %s %s ", (src->addr_string)(ndo, src->addr), tok2str(llc_values, "Unknown SSAP 0x%02x", ssap), (dst->addr_string)(ndo, dst->addr), tok2str(llc_values, "Unknown DSAP 0x%02x", dsap))Unknown DSAP 0x%02x%s > %s %s Unknown SSAP 0x%02x%s %s > %s %s (ndo, "Unnumbered, %s, Flags [%s], length %u", tok2str(llc_cmd_values, "%02x", LLC_U_CMD(control)), tok2str(llc_flag_values,"?",(ssap_field & LLC_GSAP) | (control & LLC_U_POLL)), length + hdrlen)(ndo, "Unnumbered, %s, Flags [%s], length %u", tok2str(llc_cmd_values, "%02x", ((control) & 0xef)), tok2str(llc_flag_values,"?",(ssap_field & 1) | (control & 0x10)), length + hdrlen)(ndo, ": %02x %02x", p[1], p[2])(ndo, "Supervisory, %s, rcv seq %u, Flags [%s], length %u", tok2str(llc_supervisory_values,"?",LLC_S_CMD(control)), LLC_IS_NR(control), tok2str(llc_flag_values,"?",(ssap_field & LLC_GSAP) | (control & LLC_IS_POLL)), length + hdrlen)(ndo, "Supervisory, %s, rcv seq %u, Flags [%s], length %u", tok2str(llc_supervisory_values,"?",(((control) >> 2) & 0x03)), (((control) >> 9) & 0x7f), tok2str(llc_flag_values,"?",(ssap_field & 1) | (control & 0x0100)), length + hdrlen)(ndo, "Information, send seq %u, rcv seq %u, Flags [%s], length %u", LLC_I_NS(control), LLC_IS_NR(control), tok2str(llc_flag_values,"?",(ssap_field & LLC_GSAP) | (control & LLC_IS_POLL)), length + hdrlen)(ndo, "Information, send seq %u, rcv seq %u, Flags [%s], length %u", (((control) >> 1) & 0x7f), (((control) >> 9) & 0x7f), tok2str(llc_flag_values,"?",(ssap_field & 1) | (control & 0x0100)), length + hdrlen)Unnumbered, %s, Flags [%s], length %u239-17~LLC_U_POLL: %02x %02xSupervisory, %s, rcv seq %u, Flags [%s], length %uInformation, send seq %u, rcv seq %u, Flags [%s], length %uoui_tokconst oui_tok[]oui_tok[]oui_to_toknull_valuesEthernet + FCS"Ethernet + FCS"Ethernet w/o FCS"Ethernet w/o FCS"802.4 + FCS"802.4 + FCS"802.4 w/o FCS"802.4 w/o FCS"Token Ring + FCS"Token Ring + FCS"Token Ring w/o FCS"Token Ring w/o FCS"FDDI + FCS"FDDI + FCS"FDDI w/o FCS"FDDI w/o FCS"802.6 + FCS"802.6 + FCS"802.6 w/o FCS"802.6 w/o FCS"BPDU"BPDU"bridged_valuesCDP"CDP"VTP"VTP"DTP"DTP"UDLD"UDLD"PVST"PVST"VLAN Bridge"VLAN Bridge"cisco_valuesReceiver Ready"Receiver Ready"Receiver not Ready"Receiver not Ready"Reject"Reject"llc_supervisory_valuesIndividual"Individual"Group"Group"llc_ig_flag_valuesllc_flag_values"ui"227test"test"xid"xid"ua"ua"disc"disc"dm"dm"sabme"sabme"frmr"frmr"llc_cmd_valuesGlobal"Global"802.1B I"802.1B I"802.1B G"802.1B G"SNA"SNA"ProWay NM"ProWay NM"STP"STP"RS511"RS511"ISO8208"ISO8208"ProWay"ProWay"NetBeui"NetBeui"llc_values/*
		 * Print the SNAP header, but if the OUI is 000000, don't
		 * bother printing it, and report the PID as being an
		 * ethertype.
		 *//*
		 * Nobody printed the link-layer addresses, so print them, if
		 * we have any.
		 *//*
			 * What remains is an FDDI packet.
			 *//*
			 * Skip the padding.
			 *//*
			 * XXX - remove the last two bytes for
			 * PID_RFC2684_ETH_FCS?
			 *//*
			 * What remains is an 802.5 Token Ring
			 * packet.
			 *//*
			 * Skip the padding, but not the Access
			 * Control field.
			 *//*
			 * What remains is an Ethernet packet.
			 *//*
			 * No, I have no idea why Apple used one
			 * of their own OUIs, rather than
			 * 0x000000, and an Ethernet packet
			 * type, for Appletalk data packets,
			 * but used 0x000000 and an Ethernet
			 * packet type for AARP packets.
			 *//*
		 * This is an encapsulated Ethernet packet,
		 * or a packet bridged by some piece of
		 * Cisco hardware; the protocol ID is
		 * an Ethernet protocol type.
		 *//*
		 * Somebody's already printed the MAC addresses, if there
		 * are any, so just print the SNAP header, not the MAC
		 * addresses.
		 *//* no payload to print *//*
				 * XID with no payload.
				 * This could, for example, be an SNA
				 * "short form" XID.
                                 *//*
		 * we don't actually have a full netbeui parser yet, but the
		 * smb parser can handle many smb-in-netbeui packets, which
		 * is very useful, so we call that
		 *
		 * We don't call it for S frames, however, just I frames
		 * (which are frames that don't have the low-order bit,
		 * LLC_S_FMT, set in the first byte of the control field)
		 * and UI frames (whose control field is just 3, LLC_U_FMT).
		 *//*
		 * This is an Ethernet_802.2 IPX frame, with an 802.3
		 * header and an 802.2 LLC header with the source and
		 * destination SAPs being the IPX SAP.
		 *//*
		 * This is an RFC 948-style IP packet, with
		 * an 802.3 header and an 802.2 LLC header
		 * with the source and destination SAPs being
		 * the IP SAP.
		 *//* include LLC and SNAP header *//*
			 * Unknown packet type; tell our caller, by
			 * returning a negative value, so they
			 * can print the raw packet.
			 *//*
		 * XXX - what *is* the right bridge pad value here?
		 * Does anybody ever bridge one form of LAN traffic
		 * over a networking type that uses 802.2 LLC?
		 *//*
	 * Skip LLC header.
	 *//* no LLC header *//*
		 * This is an Ethernet_802.3 IPX frame; it has an
		 * 802.3 header (i.e., an Ethernet header where the
		 * type/length field is <= ETHERMTU, i.e. it's a length
		 * field, not a type field), but has no 802.2 header -
		 * the IPX packet starts right after the Ethernet header,
		 * with a signature of two bytes of 0xFF (which is
		 * LLCSAP_GLOBAL).
		 *
		 * (It might also have been an Ethernet_802.3 IPX at
		 * one time, but got bridged onto another network,
		 * such as an 802.11 network; this has appeared in at
		 * least one capture file.)
		 *//* DSAP, SSAP, 2-byte control field *//*
		 * ...and is little-endian.
		 *//*
		 * The control field in I and S frames is
		 * 2 bytes...
		 *//* DSAP, SSAP, 1-byte control field *//*
		 * U frame.
		 *//*
	 * OK, what type of LLC frame is this?  The length
	 * of the control field depends on that - I frames
	 * have a two-byte control field, and U frames have
	 * a one-byte control field.
	 *//*
 * If we printed information about the payload, returns the length of the LLC
 * header, plus the length of any SNAP header following it.
 *
 * Otherwise (for example, if the packet has unknown SAPs or has a SNAP
 * header with an unknown OUI/PID combination), returns the *negative*
 * of that value.
 *//* bridged, RFC 2427 FR or RFC 2864 ATM *//* uses some Ethertype values *//* \summary: IEEE 802.2 LLC printer *//*
 * Copyright (c) 1992, 1993, 1994, 1995, 1996, 1997
 *	The Regents of the University of California.  All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that: (1) source code distributions
 * retain the above copyright notice and this paragraph in its entirety, (2)
 * distributions including binary code include the above copyright notice and
 * this paragraph in its entirety in the documentation or other materials
 * provided with the distribution, and (3) all advertising materials mentioning
 * features or use of this software display the following acknowledgement:
 * ``This product includes software developed by the University of California,
 * Lawrence Berkeley Laboratory and its contributors.'' Neither the name of
 * the University nor the names of its contributors may be used to endorse
 * or promote products derived from this software without specific prior
 * written permission.
 * THIS SOFTWARE IS PROVIDED ``AS IS'' AND WITHOUT ANY EXPRESS OR IMPLIED
 * WARRANTIES, INCLUDING, WITHOUT LIMITATION, THE IMPLIED WARRANTIES OF
 * MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE.
 *
 * Code by Matt Thomas, Digital Equipment Corporation
 *	with an awful lot of hacking by Jeffrey Mogul, DECWRL
 *//Users/owura/Repos/codeql_eval/proj_repos/the-tcpdump-group-tcpdump-commit-9ba91381954ad325ea4fd26b9c65a8bd9a2a85b6/tcpdump/print-lldp.clldp_printcapena_capnetwork_addr(ndo, "LLDP, length %u", len)LLDP, length %usizeof(tlv)(ndo, "\n\t%s TLV (%u), length %u", tok2str(lldp_tlv_values, "Unknown", tlv_type), tlv_type, tlv_len)(ndo, "\n\t  Subtype %s (%u): ", tok2str(lldp_chassis_subtype_values, "Unknown", subtype), subtype)(ndo, "%s", etheraddr_string(ndo, tptr + 1))(ndo, "%s", network_addr)(ndo, "\n\t  Subtype %s (%u): ", tok2str(lldp_port_subtype_values, "Unknown", subtype), subtype)(ndo, ": TTL %us", EXTRACT_16BITS(tptr))(ndo, ": TTL %us", ((uint16_t)(((uint16_t)(*((const uint8_t *)(tptr) + 0)) << 8) | ((uint16_t)(*((const uint8_t *)(tptr) + 1)) << 0))))(ndo, "\n\t  System  Capabilities [%s] (0x%04x)", bittok2str(lldp_cap_values, "none", cap), cap)(ndo, "\n\t  Enabled Capabilities [%s] (0x%04x)", bittok2str(lldp_cap_values, "none", ena_cap), ena_cap)(ndo, ": OUI %s (0x%06x)", tok2str(oui_values, "Unknown", oui), oui)
	%s TLV (%u), length %uLLDP_CHASSIS_ID_TLV
	  Subtype %s (%u): LLDP_CHASSIS_MAC_ADDR_SUBTYPE1+6LLDP_CHASSIS_INTF_NAME_SUBTYPELLDP_CHASSIS_LOCAL_SUBTYPELLDP_CHASSIS_CHASSIS_COMP_SUBTYPELLDP_CHASSIS_INTF_ALIAS_SUBTYPELLDP_CHASSIS_PORT_COMP_SUBTYPELLDP_CHASSIS_NETWORK_ADDR_SUBTYPELLDP_PORT_ID_TLVLLDP_PORT_MAC_ADDR_SUBTYPELLDP_PORT_INTF_NAME_SUBTYPELLDP_PORT_LOCAL_SUBTYPELLDP_PORT_AGENT_CIRC_ID_SUBTYPELLDP_PORT_INTF_ALIAS_SUBTYPELLDP_PORT_PORT_COMP_SUBTYPELLDP_PORT_NETWORK_ADDR_SUBTYPELLDP_TTL_TLV: TTL %usLLDP_PORT_DESCR_TLVLLDP_SYSTEM_NAME_TLVLLDP_SYSTEM_DESCR_TLVLLDP_SYSTEM_CAP_TLV
	  System  Capabilities [%s] (0x%04x)
	  Enabled Capabilities [%s] (0x%04x)LLDP_MGMT_ADDR_TLVLLDP_PRIVATE_TLV: OUI %s (0x%06x)(ndo, "\n\t[|LLDP]")
	[|LLDP]lldp_mgmt_addr_tlv_printmgmt_addr_lenintf_num_subtypeoid_lenmgmt_addr(ndo, "\n\t  Management Address length %u, %s", mgmt_addr_len, mgmt_addr)
	  Management Address length %u, %sLLDP_INTF_NUM_LEN(ndo, "\n\t  %s Interface Numbering (%u): %u", tok2str(lldp_intf_numb_subtype_values, "Unknown", intf_num_subtype), intf_num_subtype, EXTRACT_32BITS(tptr + 1))(ndo, "\n\t  %s Interface Numbering (%u): %u", tok2str(lldp_intf_numb_subtype_values, "Unknown", intf_num_subtype), intf_num_subtype, ((uint32_t)(((uint32_t)(*((const uint8_t *)(tptr + 1) + 0)) << 24) | ((uint32_t)(*((const uint8_t *)(tptr + 1) + 1)) << 16) | ((uint32_t)(*((const uint8_t *)(tptr + 1) + 2)) << 8) | ((uint32_t)(*((const uint8_t *)(tptr + 1) + 3)) << 0))))
	  %s Interface Numbering (%u): %u(ndo, "\n\t  OID length %u", oid_len)1U
	  OID length %ulldp_network_addr_printpfunc"AFI %s (%u), no AF printer !", tok2str(af_values, "Unknown", af), af"AFI %s (%u): %s", tok2str(af_values, "Unknown", af), af, (*pfunc)(ndo, tptr+1)AFI %s (%u), no AF printer !AFI %s (%u): %slldp_private_dcbx_printtvalpgvaluvalmptr(ndo, "\n\t  %s Subtype (%u)", tok2str(lldp_dcbx_subtype_values, "unknown", subtype), subtype)
	  %s Subtype (%u)LLDP_DCBX_SUBTYPE_1(ndo, "\n\t    Control - Protocol Control (type 0x%x, length %d)", LLDP_DCBX_CONTROL_TLV, tlv_len)(ndo, "\n\t    Control - Protocol Control (type 0x%x, length %d)", 1, tlv_len)(ndo, "\n\t      Oper_Version: %d", *tptr)(ndo, "\n\t      Max_Version: %d", *(tptr + 1))(ndo, "\n\t      Sequence Number: %d", EXTRACT_32BITS(tptr + 2))(ndo, "\n\t      Sequence Number: %d", ((uint32_t)(((uint32_t)(*((const uint8_t *)(tptr + 2) + 0)) << 24) | ((uint32_t)(*((const uint8_t *)(tptr + 2) + 1)) << 16) | ((uint32_t)(*((const uint8_t *)(tptr + 2) + 2)) << 8) | ((uint32_t)(*((const uint8_t *)(tptr + 2) + 3)) << 0))))(ndo, "\n\t      Acknowledgement Number: %d", EXTRACT_32BITS(tptr + 6))(ndo, "\n\t      Acknowledgement Number: %d", ((uint32_t)(((uint32_t)(*((const uint8_t *)(tptr + 6) + 0)) << 24) | ((uint32_t)(*((const uint8_t *)(tptr + 6) + 1)) << 16) | ((uint32_t)(*((const uint8_t *)(tptr + 6) + 2)) << 8) | ((uint32_t)(*((const uint8_t *)(tptr + 6) + 3)) << 0))))(ndo, "\n\t    Feature - Priority Group (type 0x%x, length %d)", LLDP_DCBX_PRIORITY_GROUPS_TLV, tlv_len)(ndo, "\n\t    Feature - Priority Group (type 0x%x, length %d)", 2, tlv_len)(ndo, "\n\t      Info block(0x%02X): ", *(tptr + 2))(ndo, "Enable bit: %d, Willing bit: %d, Error Bit: %d", (tval & 0x80) ? 1 : 0, (tval & 0x40) ? 1 : 0, (tval & 0x20) ? 1 : 0)(ndo, "\n\t      SubType: %d", *(tptr + 3))(ndo, "\n\t      Priority Allocation")(ndo, "\n\t          PgId_%d: %d", i, (pgval >> (28 - 4 * i)) & 0xF)(ndo, "\n\t      Priority Group Allocation")(ndo, "\n\t          Pg percentage[%d]: %d", i, *(tptr + 8 + i))(ndo, "\n\t      NumTCsSupported: %d", *(tptr + 8 + 8))(ndo, "\n\t    Feature - Priority Flow Control")(ndo, " (type 0x%x, length %d)", LLDP_DCBX_PRIORITY_FLOW_CONTROL_TLV, tlv_len)(ndo, " (type 0x%x, length %d)", 3, tlv_len)(ndo, "\n\t      PFC Config (0x%02X)", *(tptr + 4))(ndo, "\n\t          Priority Bit %d: %s", i, (tval & (1 << i)) ? "Enabled" : "Disabled")(ndo, "\n\t      NumTCPFCSupported: %d", *(tptr + 5))(ndo, "\n\t    Feature - Application (type 0x%x, length %d)", LLDP_DCBX_APPLICATION_TLV, tlv_len)(ndo, "\n\t    Feature - Application (type 0x%x, length %d)", 4, tlv_len)(ndo, "\n\t      Application Value")(ndo, "\n\t          Application Protocol ID: 0x%04x", EXTRACT_16BITS(mptr))(ndo, "\n\t          Application Protocol ID: 0x%04x", ((uint16_t)(((uint16_t)(*((const uint8_t *)(mptr) + 0)) << 8) | ((uint16_t)(*((const uint8_t *)(mptr) + 1)) << 0))))mptr+2(ndo, "\n\t          SF (0x%x) Application Protocol ID is %s", (uval >> 22), (uval >> 22) ? "Socket Number" : "L2 EtherType")(ndo, "\n\t          OUI: 0x%06x", uval & 0x3fffff)(ndo, "\n\t          User Priority Map: 0x%02x", *(mptr + 5))LLDP_DCBX_CONTROL_TLV
	    Control - Protocol Control (type 0x%x, length %d)char[56]
	      Oper_Version: %d
	      Max_Version: %d
	      Sequence Number: %d
	      Acknowledgement Number: %dLLDP_DCBX_PRIORITY_GROUPS_TLV
	    Feature - Priority Group (type 0x%x, length %d)
	      Info block(0x%02X): Enable bit: %d, Willing bit: %d, Error Bit: %d
	      SubType: %d
	      Priority Allocation
	          PgId_%d: %d
	      Priority Group Allocation
	          Pg percentage[%d]: %d
	      NumTCsSupported: %dLLDP_DCBX_PRIORITY_FLOW_CONTROL_TLV
	    Feature - Priority Flow Control (type 0x%x, length %d)
	      PFC Config (0x%02X)
	          Priority Bit %d: %s
	      NumTCPFCSupported: %dLLDP_DCBX_APPLICATION_TLV
	    Feature - Application (type 0x%x, length %d)
	      Application Value
	          Application Protocol ID: 0x%04x
	          SF (0x%x) Application Protocol ID is %sSocket NumberL2 EtherType
	          OUI: 0x%06x4194303
	          User Priority Map: 0x%02xlldp_private_tia_printlocation_formatpower_vallci_lenca_typeca_len(ndo, "\n\t  %s Subtype (%u)", tok2str(lldp_tia_subtype_values, "unknown", subtype), subtype)(ndo, "\n\t    Media capabilities [%s] (0x%04x)", bittok2str(lldp_tia_capabilities_values, "none", EXTRACT_16BITS(tptr + 4)), EXTRACT_16BITS(tptr + 4))(ndo, "\n\t    Media capabilities [%s] (0x%04x)", bittok2str(lldp_tia_capabilities_values, "none", ((uint16_t)(((uint16_t)(*((const uint8_t *)(tptr + 4) + 0)) << 8) | ((uint16_t)(*((const uint8_t *)(tptr + 4) + 1)) << 0)))), ((uint16_t)(((uint16_t)(*((const uint8_t *)(tptr + 4) + 0)) << 8) | ((uint16_t)(*((const uint8_t *)(tptr + 4) + 1)) << 0))))(ndo, "\n\t    Device type [%s] (0x%02x)", tok2str(lldp_tia_device_type_values, "unknown", *(tptr+6)), *(tptr + 6))(ndo, "\n\t    Application type [%s] (0x%02x)", tok2str(lldp_tia_application_type_values, "none", *(tptr+4)), *(tptr + 4))(ndo, ", Flags [%s]", bittok2str( lldp_tia_network_policy_bits_values, "none", *(tptr + 5)))(ndo, "\n\t    Vlan id %u", LLDP_EXTRACT_NETWORK_POLICY_VLAN(EXTRACT_16BITS(tptr + 5)))(ndo, "\n\t    Vlan id %u", (((((uint16_t)(((uint16_t)(*((const uint8_t *)(tptr + 5) + 0)) << 8) | ((uint16_t)(*((const uint8_t *)(tptr + 5) + 1)) << 0))))&0x1ffe)>>1))EXTRACT_16BITS(tptr + 5)((uint16_t)(((uint16_t)(*((const uint8_t *)(tptr + 5) + 0)) << 8) | ((uint16_t)(*((const uint8_t *)(tptr + 5) + 1)) << 0)))(ndo, ", L2 priority %u", LLDP_EXTRACT_NETWORK_POLICY_L2_PRIORITY(EXTRACT_16BITS(tptr + 6)))(ndo, ", L2 priority %u", (((((uint16_t)(((uint16_t)(*((const uint8_t *)(tptr + 6) + 0)) << 8) | ((uint16_t)(*((const uint8_t *)(tptr + 6) + 1)) << 0))))&0x01ff)>>6))EXTRACT_16BITS(tptr + 6)((uint16_t)(((uint16_t)(*((const uint8_t *)(tptr + 6) + 0)) << 8) | ((uint16_t)(*((const uint8_t *)(tptr + 6) + 1)) << 0)))(ndo, ", DSCP value %u", LLDP_EXTRACT_NETWORK_POLICY_DSCP(EXTRACT_16BITS(tptr + 6)))(ndo, ", DSCP value %u", ((((uint16_t)(((uint16_t)(*((const uint8_t *)(tptr + 6) + 0)) << 8) | ((uint16_t)(*((const uint8_t *)(tptr + 6) + 1)) << 0))))&0x003f))(ndo, "\n\t    Location data format %s (0x%02x)", tok2str(lldp_tia_location_data_format_values, "unknown", location_format), location_format)(ndo, "\n\t    Latitude resolution %u, latitude value %" PRIu64, (*(tptr + 5) >> 2), lldp_extract_latlon(tptr + 5))(ndo, "\n\t    Latitude resolution %u, latitude value %" "ll" "u", (*(tptr + 5) >> 2), lldp_extract_latlon(tptr + 5))(ndo, "\n\t    Longitude resolution %u, longitude value %" PRIu64, (*(tptr + 10) >> 2), lldp_extract_latlon(tptr + 10))(ndo, "\n\t    Longitude resolution %u, longitude value %" "ll" "u", (*(tptr + 10) >> 2), lldp_extract_latlon(tptr + 10))(ndo, "\n\t    Altitude type %s (%u)", tok2str(lldp_tia_location_altitude_type_values, "unknown",(*(tptr+15)>>4)), (*(tptr + 15) >> 4))(ndo, "\n\t    Altitude resolution %u, altitude value 0x%x", (EXTRACT_16BITS(tptr+15)>>6)&0x3f, ((EXTRACT_32BITS(tptr + 16) & 0x3fffffff)))(ndo, "\n\t    Altitude resolution %u, altitude value 0x%x", (((uint16_t)(((uint16_t)(*((const uint8_t *)(tptr+15) + 0)) << 8) | ((uint16_t)(*((const uint8_t *)(tptr+15) + 1)) << 0)))>>6)&0x3f, ((((uint32_t)(((uint32_t)(*((const uint8_t *)(tptr + 16) + 0)) << 24) | ((uint32_t)(*((const uint8_t *)(tptr + 16) + 1)) << 16) | ((uint32_t)(*((const uint8_t *)(tptr + 16) + 2)) << 8) | ((uint32_t)(*((const uint8_t *)(tptr + 16) + 3)) << 0))) & 0x3fffffff)))tptr+15tptr + 16(ndo, "\n\t    Datum %s (0x%02x)", tok2str(lldp_tia_location_datum_type_values, "unknown", *(tptr+20)), *(tptr + 20))(ndo, "\n\t    LCI length %u, LCI what %s (0x%02x), Country-code ", lci_len, tok2str(lldp_tia_location_lci_what_values, "unknown", *(tptr+6)), *(tptr + 6))(ndo, "\n\t      CA type \'%s\' (%u), length %u: ", tok2str(lldp_tia_location_lci_catype_values, "unknown", ca_type), ca_type, ca_len)(ndo, "\n\t    ECS ELIN id ")(ndo, "\n\t    Location ID ")(ndo, "\n\t    Power type [%s]", (*(tptr + 4) & 0xC0 >> 6) ? "PD device" : "PSE device")(ndo, ", Power source [%s]", tok2str(lldp_tia_power_source_values, "none", (*(tptr + 4) & 0x30) >> 4))(ndo, "\n\t    Power priority [%s] (0x%02x)", tok2str(lldp_tia_power_priority_values, "none", *(tptr+4)&0x0f), *(tptr + 4) & 0x0f)tptr+5(ndo, ", Power %.1f Watts", ((float)power_val) / 10)(ndo, ", Power %u (Reserved)", power_val)(ndo, "\n\t  %s ", tok2str(lldp_tia_inventory_values, "unknown", subtype))LLDP_PRIVATE_TIA_SUBTYPE_CAPABILITIES
	    Media capabilities [%s] (0x%04x)
	    Device type [%s] (0x%02x)LLDP_PRIVATE_TIA_SUBTYPE_NETWORK_POLICY
	    Application type [%s] (0x%02x)
	    Vlan id %u8190, L2 priority %u, DSCP value %uLLDP_PRIVATE_TIA_SUBTYPE_LOCAL_ID
	    Location data format %s (0x%02x)LLDP_TIA_LOCATION_DATA_FORMAT_COORDINATE_BASED
	    Latitude resolution %u, latitude value %llu
	    Longitude resolution %u, longitude value %llu
	    Altitude type %s (%u)
	    Altitude resolution %u, altitude value 0x%x
	    Datum %s (0x%02x)LLDP_TIA_LOCATION_DATA_FORMAT_CIVIC_ADDRESS
	    LCI length %u, LCI what %s (0x%02x), Country-code 
	      CA type '%s' (%u), length %u: LLDP_TIA_LOCATION_DATA_FORMAT_ECS_ELIN
	    ECS ELIN id 
	    Location ID LLDP_PRIVATE_TIA_SUBTYPE_EXTENDED_POWER_MDI
	    Power type [%s]PD devicePSE device, Power source [%s]
	    Power priority [%s] (0x%02x)LLDP_TIA_POWER_VAL_MAX, Power %.1f Watts, Power %u (Reserved)LLDP_PRIVATE_TIA_SUBTYPE_INVENTORY_HARDWARE_REVLLDP_PRIVATE_TIA_SUBTYPE_INVENTORY_FIRMWARE_REVLLDP_PRIVATE_TIA_SUBTYPE_INVENTORY_SOFTWARE_REVLLDP_PRIVATE_TIA_SUBTYPE_INVENTORY_SERIAL_NUMBERLLDP_PRIVATE_TIA_SUBTYPE_INVENTORY_MANUFACTURER_NAMELLDP_PRIVATE_TIA_SUBTYPE_INVENTORY_MODEL_NAMELLDP_PRIVATE_TIA_SUBTYPE_INVENTORY_ASSET_ID
	  %s lldp_private_iana_print(ndo, "\n\t  %s Subtype (%u)", tok2str(lldp_iana_subtype_values, "unknown", subtype), subtype)(ndo, "\n\t  MUD-URL=")LLDP_IANA_SUBTYPE_MUDURL
	  MUD-URL=lldp_extract_latlonlatlonlldp_private_8023_print(ndo, "\n\t  %s Subtype (%u)", tok2str(lldp_8023_subtype_values, "unknown", subtype), subtype)(ndo, "\n\t    autonegotiation [%s] (0x%02x)", bittok2str(lldp_8023_autonegotiation_values, "none", *(tptr+4)), *(tptr + 4))(ndo, "\n\t    PMD autoneg capability [%s] (0x%04x)", bittok2str(lldp_pmd_capability_values,"unknown", EXTRACT_16BITS(tptr+5)), EXTRACT_16BITS(tptr + 5))(ndo, "\n\t    PMD autoneg capability [%s] (0x%04x)", bittok2str(lldp_pmd_capability_values,"unknown", ((uint16_t)(((uint16_t)(*((const uint8_t *)(tptr+5) + 0)) << 8) | ((uint16_t)(*((const uint8_t *)(tptr+5) + 1)) << 0)))), ((uint16_t)(((uint16_t)(*((const uint8_t *)(tptr + 5) + 0)) << 8) | ((uint16_t)(*((const uint8_t *)(tptr + 5) + 1)) << 0))))(ndo, "\n\t    MAU type %s (0x%04x)", tok2str(lldp_mau_types_values, "unknown", EXTRACT_16BITS(tptr+7)), EXTRACT_16BITS(tptr + 7))(ndo, "\n\t    MAU type %s (0x%04x)", tok2str(lldp_mau_types_values, "unknown", ((uint16_t)(((uint16_t)(*((const uint8_t *)(tptr+7) + 0)) << 8) | ((uint16_t)(*((const uint8_t *)(tptr+7) + 1)) << 0)))), ((uint16_t)(((uint16_t)(*((const uint8_t *)(tptr + 7) + 0)) << 8) | ((uint16_t)(*((const uint8_t *)(tptr + 7) + 1)) << 0))))tptr + 7(ndo, "\n\t    MDI power support [%s], power pair %s, power class %s", bittok2str(lldp_mdi_values, "none", *(tptr+4)), tok2str(lldp_mdi_power_pairs_values, "unknown", *(tptr+5)), tok2str(lldp_mdi_power_class_values, "unknown", *(tptr + 6)))(ndo, "\n\t    aggregation status [%s], aggregation port ID %u", bittok2str(lldp_aggregation_values, "none", *(tptr+4)), EXTRACT_32BITS(tptr + 5))(ndo, "\n\t    aggregation status [%s], aggregation port ID %u", bittok2str(lldp_aggregation_values, "none", *(tptr+4)), ((uint32_t)(((uint32_t)(*((const uint8_t *)(tptr + 5) + 0)) << 24) | ((uint32_t)(*((const uint8_t *)(tptr + 5) + 1)) << 16) | ((uint32_t)(*((const uint8_t *)(tptr + 5) + 2)) << 8) | ((uint32_t)(*((const uint8_t *)(tptr + 5) + 3)) << 0))))(ndo, "\n\t    MTU size %u", EXTRACT_16BITS(tptr + 4))(ndo, "\n\t    MTU size %u", ((uint16_t)(((uint16_t)(*((const uint8_t *)(tptr + 4) + 0)) << 8) | ((uint16_t)(*((const uint8_t *)(tptr + 4) + 1)) << 0))))LLDP_PRIVATE_8023_SUBTYPE_MACPHY
	    autonegotiation [%s] (0x%02x)
	    PMD autoneg capability [%s] (0x%04x)
	    MAU type %s (0x%04x)LLDP_PRIVATE_8023_SUBTYPE_MDIPOWER
	    MDI power support [%s], power pair %s, power class %sLLDP_PRIVATE_8023_SUBTYPE_LINKAGGR
	    aggregation status [%s], aggregation port ID %uLLDP_PRIVATE_8023_SUBTYPE_MTU
	    MTU size %ulldp_private_8021_print(ndo, "\n\t  %s Subtype (%u)", tok2str(lldp_8021_subtype_values, "unknown", subtype), subtype)(ndo, "\n\t    port vlan id (PVID): %u", EXTRACT_16BITS(tptr + 4))(ndo, "\n\t    port vlan id (PVID): %u", ((uint16_t)(((uint16_t)(*((const uint8_t *)(tptr + 4) + 0)) << 8) | ((uint16_t)(*((const uint8_t *)(tptr + 4) + 1)) << 0))))(ndo, "\n\t    port and protocol vlan id (PPVID): %u, flags [%s] (0x%02x)", EXTRACT_16BITS(tptr+5), bittok2str(lldp_8021_port_protocol_id_values, "none", *(tptr+4)), *(tptr + 4))(ndo, "\n\t    port and protocol vlan id (PPVID): %u, flags [%s] (0x%02x)", ((uint16_t)(((uint16_t)(*((const uint8_t *)(tptr+5) + 0)) << 8) | ((uint16_t)(*((const uint8_t *)(tptr+5) + 1)) << 0))), bittok2str(lldp_8021_port_protocol_id_values, "none", *(tptr+4)), *(tptr + 4))(ndo, "\n\t    vlan id (VID): %u", EXTRACT_16BITS(tptr + 4))(ndo, "\n\t    vlan id (VID): %u", ((uint16_t)(((uint16_t)(*((const uint8_t *)(tptr + 4) + 0)) << 8) | ((uint16_t)(*((const uint8_t *)(tptr + 4) + 1)) << 0))))(ndo, "\n\t    vlan name: ")(ndo, "\n\t    protocol identity: ")(ndo, "\n\t    Pre-Priority CNPV Indicator")(ndo, "\n\t     Priority : 0  1  2  3  4  5  6  7")(ndo, "\n\t     Value    : ")(ndo, "%-2d ", (tval >> i) & 0x01)(ndo, "\n\t    Pre-Priority Ready Indicator")(ndo, "\n\t    Willing:%d, CBS:%d, RES:%d, Max TCs:%d", tval >> 7, (tval >> 6) & 0x02, (tval >> 3) & 0x07, tval & 0x07)(ndo, "\n\t    RES: %d", *(tptr + 4))(ndo, "\n\t    Willing: %d, MBC: %d, RES: %d, PFC cap:%d ", tval >> 7, (tval >> 6) & 0x01, (tval >> 4) & 0x03, (tval & 0x0f))(ndo, "\n\t    PFC Enable")(ndo, "\n\t    Application Priority Table")(ndo, "\n\t      Priority: %u, RES: %u, Sel: %u, Protocol ID: %u", tval >> 5, (tval >> 3) & 0x03, (tval & 0x07), EXTRACT_16BITS(tptr + i + 5))(ndo, "\n\t      Priority: %u, RES: %u, Sel: %u, Protocol ID: %u", tval >> 5, (tval >> 3) & 0x03, (tval & 0x07), ((uint16_t)(((uint16_t)(*((const uint8_t *)(tptr + i + 5) + 0)) << 8) | ((uint16_t)(*((const uint8_t *)(tptr + i + 5) + 1)) << 0))))tptr + i + 5(ndo, "\n\t    EVB Bridge Status")(ndo, "\n\t      RES: %d, BGID: %d, RRCAP: %d, RRCTR: %d", tval >> 3, (tval >> 2) & 0x01, (tval >> 1) & 0x01, tval & 0x01)(ndo, "\n\t    EVB Station Status")(ndo, "\n\t      RES: %d, SGID: %d, RRREQ: %d,RRSTAT: %d", tval >> 4, (tval >> 3) & 0x01, (tval >> 2) & 0x01, tval & 0x03)(ndo, "\n\t    R: %d, RTE: %d, ",tval >> 5, tval & 0x1f)(ndo, "EVB Mode: %s [%d]", tok2str(lldp_evb_mode_values, "unknown", tval >> 6), tval >> 6)(ndo, "\n\t    ROL: %d, RWD: %d, ", (tval >> 5) & 0x01, tval & 0x1f)(ndo, "RES: %d, ROL: %d, RKA: %d", tval >> 6, (tval >> 5) & 0x01, tval & 0x1f)(ndo, "\n\t    Role: %d, RES: %d, Scomp: %d ", tval >> 7, (tval >> 4) & 0x07, (tval >> 3) & 0x01)(ndo, "ChnCap: %d", EXTRACT_16BITS(tptr + 6) & 0x0fff)(ndo, "ChnCap: %d", ((uint16_t)(((uint16_t)(*((const uint8_t *)(tptr + 6) + 0)) << 8) | ((uint16_t)(*((const uint8_t *)(tptr + 6) + 1)) << 0))) & 0x0fff)tptr+i+8(ndo, "\n\t    SCID: %d, SVID: %d", tval >> 12, tval & 0x000fff)LLDP_PRIVATE_8021_SUBTYPE_PORT_VLAN_ID
	    port vlan id (PVID): %uLLDP_PRIVATE_8021_SUBTYPE_PROTOCOL_VLAN_ID
	    port and protocol vlan id (PPVID): %u, flags [%s] (0x%02x)LLDP_PRIVATE_8021_SUBTYPE_VLAN_NAME
	    vlan id (VID): %u
	    vlan name: LLDP_PRIVATE_8021_SUBTYPE_PROTOCOL_IDENTITY
	    protocol identity: LLDP_PRIVATE_8021_SUBTYPE_CONGESTION_NOTIFICATIONLLDP_PRIVATE_8021_SUBTYPE_CONGESTION_NOTIFICATION_LENGTH
	    Pre-Priority CNPV Indicator
	     Priority : 0  1  2  3  4  5  6  7
	     Value    : NO_OF_BITS%-2d 
	    Pre-Priority Ready IndicatorLLDP_PRIVATE_8021_SUBTYPE_ETS_CONFIGURATIONLLDP_PRIVATE_8021_SUBTYPE_ETS_CONFIGURATION_LENGTH
	    Willing:%d, CBS:%d, RES:%d, Max TCs:%dLLDP_PRIVATE_8021_SUBTYPE_ETS_RECOMMENDATIONLLDP_PRIVATE_8021_SUBTYPE_ETS_RECOMMENDATION_LENGTH
	    RES: %dLLDP_PRIVATE_8021_SUBTYPE_PFC_CONFIGURATIONLLDP_PRIVATE_8021_SUBTYPE_PFC_CONFIGURATION_LENGTH
	    Willing: %d, MBC: %d, RES: %d, PFC cap:%d 
	    PFC EnableLLDP_PRIVATE_8021_SUBTYPE_APPLICATION_PRIORITYLLDP_PRIVATE_8021_SUBTYPE_APPLICATION_PRIORITY_MIN_LENGTH
	    Application Priority Table
	      Priority: %u, RES: %u, Sel: %u, Protocol ID: %uLLDP_PRIVATE_8021_SUBTYPE_EVBLLDP_PRIVATE_8021_SUBTYPE_EVB_LENGTH
	    EVB Bridge Status
	      RES: %d, BGID: %d, RRCAP: %d, RRCTR: %d
	    EVB Station Status
	      RES: %d, SGID: %d, RRREQ: %d,RRSTAT: %d
	    R: %d, RTE: %d, EVB Mode: %s [%d]
	    ROL: %d, RWD: %d, RES: %d, ROL: %d, RKA: %dLLDP_PRIVATE_8021_SUBTYPE_CDCPLLDP_PRIVATE_8021_SUBTYPE_CDCP_MIN_LENGTH
	    Role: %d, RES: %d, Scomp: %d ChnCap: %d
	    SCID: %d, SVID: %dprint_tsa_assignment_table(ndo, "\n\t    TSA Assignment Table")
	    TSA Assignment Table(ndo, "\n\t     Traffic Class: 0   1   2   3   4   5   6   7")
	     Traffic Class: 0   1   2   3   4   5   6   7(ndo, "\n\t     Value        : %-3d %-3d %-3d %-3d %-3d %-3d %-3d %-3d", ptr[0], ptr[1], ptr[2], ptr[3], ptr[4], ptr[5], ptr[6], ptr[7])
	     Value        : %-3d %-3d %-3d %-3d %-3d %-3d %-3d %-3dprint_tc_bandwidth_table(ndo, "\n\t    TC Bandwidth Table")
	    TC Bandwidth Table(ndo, "\n\t     TC%%   : 0   1   2   3   4   5   6   7")
	     TC%%   : 0   1   2   3   4   5   6   7(ndo, "\n\t     Value : %-3d %-3d %-3d %-3d %-3d %-3d %-3d %-3d", ptr[0], ptr[1], ptr[2], ptr[3], ptr[4], ptr[5], ptr[6], ptr[7])
	     Value : %-3d %-3d %-3d %-3d %-3d %-3d %-3d %-3dprint_ets_priority_assignment_table(ndo, "\n\t    Priority Assignment Table")
	    Priority Assignment Table(ndo, "\n\t     Priority : 0   1   2   3   4   5   6   7")
	     Priority : 0   1   2   3   4   5   6   7(ndo, "\n\t     Value    : %-3d %-3d %-3d %-3d %-3d %-3d %-3d %-3d", ptr[0]>>4,ptr[0]&0x0f,ptr[1]>>4,ptr[1]&0x0f,ptr[2]>>4, ptr[2] & 0x0f, ptr[3] >> 4, ptr[3] & 0x0f)
	     Value    : %-3d %-3d %-3d %-3d %-3d %-3d %-3d %-3dlldp_iana_subtype_valuesLLDP_EVB_MODE_NOT_SUPPORTEDNot Supported"Not Supported"LLDP_EVB_MODE_EVB_BRIDGEEVB Bridge"EVB Bridge"LLDP_EVB_MODE_EVB_STATIONEVB Staion"EVB Staion"LLDP_EVB_MODE_RESERVEDReserved for future Standardization"Reserved for future Standardization"lldp_evb_mode_valuesLLDP_INTF_NUMB_IFX_SUBTYPEInterface Index"Interface Index"LLDP_INTF_NUMB_SYSPORT_SUBTYPESystem Port Number"System Port Number"lldp_intf_numb_subtype_valuesDCB Capability Exchange Protocol Rev 1"DCB Capability Exchange Protocol Rev 1"LLDP_DCBX_SUBTYPE_2DCB Capability Exchange Protocol Rev 1.01"DCB Capability Exchange Protocol Rev 1.01"lldp_dcbx_subtype_valuesLLDP_AGGREGATION_CAPABILTIYsupported"supported"LLDP_AGGREGATION_STATUSenabled"enabled"lldp_aggregation_valuesLLDP_MDI_POWER_CLASS0class0"class0"LLDP_MDI_POWER_CLASS1class1"class1"LLDP_MDI_POWER_CLASS2class2"class2"LLDP_MDI_POWER_CLASS3class3"class3"LLDP_MDI_POWER_CLASS4class4"class4"lldp_mdi_power_class_valuesLLDP_MDI_PSE_PORT_POWER_PAIRS_SIGNALsignal"signal"LLDP_MDI_PSE_PORT_POWER_PAIRS_SPAREspare"spare"lldp_mdi_power_pairs_valuesLLDP_MDI_PORT_CLASSPSE"PSE"LLDP_MDI_POWER_SUPPORTLLDP_MDI_POWER_STATELLDP_MDI_PAIR_CONTROL_ABILITYcan be controlled"can be controlled"lldp_mdi_valuesLLDP_MAU_PMD_10BASE_T10BASE-T hdx"10BASE-T hdx"LLDP_MAU_PMD_10BASE_T_FD10BASE-T fdx"10BASE-T fdx"LLDP_MAU_PMD_100BASE_T4100BASE-T4"100BASE-T4"LLDP_MAU_PMD_100BASE_TX100BASE-TX hdx"100BASE-TX hdx"LLDP_MAU_PMD_100BASE_TX_FD100BASE-TX fdx"100BASE-TX fdx"LLDP_MAU_PMD_100BASE_T2100BASE-T2 hdx"100BASE-T2 hdx"LLDP_MAU_PMD_100BASE_T2_FD100BASE-T2 fdx"100BASE-T2 fdx"LLDP_MAU_PMD_FDXPAUSEPause for fdx links"Pause for fdx links"LLDP_MAU_PMD_FDXAPAUSEAsym PAUSE for fdx"Asym PAUSE for fdx"LLDP_MAU_PMD_FDXSPAUSESym PAUSE for fdx"Sym PAUSE for fdx"LLDP_MAU_PMD_FDXBPAUSEAsym and Sym PAUSE for fdx"Asym and Sym PAUSE for fdx"LLDP_MAU_PMD_1000BASE_X1000BASE-{X LX SX CX} hdx"1000BASE-{X LX SX CX} hdx"LLDP_MAU_PMD_1000BASE_X_FD1000BASE-{X LX SX CX} fdx"1000BASE-{X LX SX CX} fdx"LLDP_MAU_PMD_1000BASE_T1000BASE-T hdx"1000BASE-T hdx"LLDP_MAU_PMD_1000BASE_T_FD1000BASE-T fdx"1000BASE-T fdx"lldp_pmd_capability_valuesHardware revision"Hardware revision"Firmware revision"Firmware revision"Software revision"Software revision"Serial number"Serial number"Manufacturer name"Manufacturer name"Model name"Model name"Asset ID"Asset ID"lldp_tia_inventory_valuesLLDP_TIA_POWER_PRIORITY_CRITICAL"critical"LLDP_TIA_POWER_PRIORITY_HIGHLLDP_TIA_POWER_PRIORITY_LOWlldp_tia_power_priority_valuesLLDP_TIA_POWER_SOURCE_PSEPSE - primary power source"PSE - primary power source"LLDP_TIA_POWER_SOURCE_LOCALlocal - backup power source"local - backup power source"LLDP_TIA_POWER_SOURCE_PSE_AND_LOCALPSE+local - reserved"PSE+local - reserved"lldp_tia_power_source_valuesLLDP_TIA_LOCATION_DATUM_WGS_84World Geodesic System 1984"World Geodesic System 1984"LLDP_TIA_LOCATION_DATUM_NAD_83_NAVD_88North American Datum 1983 (NAVD88)"North American Datum 1983 (NAVD88)"LLDP_TIA_LOCATION_DATUM_NAD_83_MLLWNorth American Datum 1983 (MLLW)"North American Datum 1983 (MLLW)"lldp_tia_location_datum_type_valuescoordinate-based LCI"coordinate-based LCI"civic address LCI"civic address LCI"ECS ELIN"ECS ELIN"lldp_tia_location_data_format_valuesLLDP_TIA_NETWORK_POLICY_U_BITLLDP_TIA_NETWORK_POLICY_T_BITTagged"Tagged"LLDP_TIA_NETWORK_POLICY_X_BITlldp_tia_network_policy_bits_valuesLLDP_TIA_APPLICATION_TYPE_VOICEvoice"voice"LLDP_TIA_APPLICATION_TYPE_VOICE_SIGNALINGvoice signaling"voice signaling"LLDP_TIA_APPLICATION_TYPE_GUEST_VOICEguest voice"guest voice"LLDP_TIA_APPLICATION_TYPE_GUEST_VOICE_SIGNALINGguest voice signaling"guest voice signaling"LLDP_TIA_APPLICATION_TYPE_SOFTPHONE_VOICEsoftphone voice"softphone voice"LLDP_TIA_APPLICATION_TYPE_VIDEO_CONFERENCINGvideo conferencing"video conferencing"LLDP_TIA_APPLICATION_TYPE_STREAMING_VIDEOstreaming video"streaming video"LLDP_TIA_APPLICATION_TYPE_VIDEO_SIGNALINGvideo signaling"video signaling"lldp_tia_application_type_valuesLLDP_TIA_DEVICE_TYPE_ENDPOINT_CLASS_1endpoint class 1"endpoint class 1"LLDP_TIA_DEVICE_TYPE_ENDPOINT_CLASS_2endpoint class 2"endpoint class 2"LLDP_TIA_DEVICE_TYPE_ENDPOINT_CLASS_3endpoint class 3"endpoint class 3"LLDP_TIA_DEVICE_TYPE_NETWORK_CONNECTIVITYnetwork connectivity"network connectivity"lldp_tia_device_type_valuesLLDP_TIA_CAPABILITY_MEDLLDP-MED capabilities"LLDP-MED capabilities"LLDP_TIA_CAPABILITY_NETWORK_POLICYnetwork policy"network policy"LLDP_TIA_CAPABILITY_LOCATION_IDENTIFICATIONlocation identification"location identification"LLDP_TIA_CAPABILITY_EXTENDED_POWER_MDI_PSEextended power via MDI-PSE"extended power via MDI-PSE"LLDP_TIA_CAPABILITY_EXTENDED_POWER_MDI_PDextended power via MDI-PD"extended power via MDI-PD"LLDP_TIA_CAPABILITY_INVENTORYInventory"Inventory"lldp_tia_capabilities_valuesLLDP_8023_AUTONEGOTIATION_SUPPORTLLDP_8023_AUTONEGOTIATION_STATUSlldp_8023_autonegotiation_valuesLLDP_MAU_TYPE_UNKNOWNLLDP_MAU_TYPE_AUIAUI"AUI"LLDP_MAU_TYPE_10BASE_510BASE_5"10BASE_5"LLDP_MAU_TYPE_FOIRLFOIRL"FOIRL"LLDP_MAU_TYPE_10BASE_210BASE2"10BASE2"LLDP_MAU_TYPE_10BASE_T10BASET duplex mode unknown"10BASET duplex mode unknown"LLDP_MAU_TYPE_10BASE_FP10BASEFP"10BASEFP"LLDP_MAU_TYPE_10BASE_FB10BASEFB"10BASEFB"LLDP_MAU_TYPE_10BASE_FL10BASEFL duplex mode unknown"10BASEFL duplex mode unknown"LLDP_MAU_TYPE_10BROAD3610BROAD36"10BROAD36"LLDP_MAU_TYPE_10BASE_T_HD10BASET hdx"10BASET hdx"LLDP_MAU_TYPE_10BASE_T_FD10BASET fdx"10BASET fdx"LLDP_MAU_TYPE_10BASE_FL_HD10BASEFL hdx"10BASEFL hdx"LLDP_MAU_TYPE_10BASE_FL_FD10BASEFL fdx"10BASEFL fdx"LLDP_MAU_TYPE_100BASE_T4100BASET4"100BASET4"LLDP_MAU_TYPE_100BASE_TX_HD100BASETX hdx"100BASETX hdx"LLDP_MAU_TYPE_100BASE_TX_FD100BASETX fdx"100BASETX fdx"LLDP_MAU_TYPE_100BASE_FX_HD100BASEFX hdx"100BASEFX hdx"LLDP_MAU_TYPE_100BASE_FX_FD100BASEFX fdx"100BASEFX fdx"LLDP_MAU_TYPE_100BASE_T2_HD100BASET2 hdx"100BASET2 hdx"LLDP_MAU_TYPE_100BASE_T2_FD100BASET2 fdx"100BASET2 fdx"LLDP_MAU_TYPE_1000BASE_X_HD1000BASEX hdx"1000BASEX hdx"LLDP_MAU_TYPE_1000BASE_X_FD1000BASEX fdx"1000BASEX fdx"LLDP_MAU_TYPE_1000BASE_LX_HD1000BASELX hdx"1000BASELX hdx"LLDP_MAU_TYPE_1000BASE_LX_FD1000BASELX fdx"1000BASELX fdx"LLDP_MAU_TYPE_1000BASE_SX_HD1000BASESX hdx"1000BASESX hdx"LLDP_MAU_TYPE_1000BASE_SX_FD1000BASESX fdx"1000BASESX fdx"LLDP_MAU_TYPE_1000BASE_CX_HD1000BASECX hdx"1000BASECX hdx"LLDP_MAU_TYPE_1000BASE_CX_FD1000BASECX fdx"1000BASECX fdx"LLDP_MAU_TYPE_1000BASE_T_HD1000BASET hdx"1000BASET hdx"LLDP_MAU_TYPE_1000BASE_T_FD1000BASET fdx"1000BASET fdx"LLDP_MAU_TYPE_10GBASE_X10GBASEX"10GBASEX"LLDP_MAU_TYPE_10GBASE_LX410GBASELX4"10GBASELX4"LLDP_MAU_TYPE_10GBASE_R10GBASER"10GBASER"LLDP_MAU_TYPE_10GBASE_ER10GBASEER"10GBASEER"LLDP_MAU_TYPE_10GBASE_LR10GBASELR"10GBASELR"LLDP_MAU_TYPE_10GBASE_SR10GBASESR"10GBASESR"LLDP_MAU_TYPE_10GBASE_W10GBASEW"10GBASEW"LLDP_MAU_TYPE_10GBASE_EW10GBASEEW"10GBASEEW"LLDP_MAU_TYPE_10GBASE_LW10GBASELW"10GBASELW"LLDP_MAU_TYPE_10GBASE_SW10GBASESW"10GBASESW"lldp_mau_types_valueslocation of DHCP server"location of DHCP server"location of the network element believed to be closest to the client"location of the network element believed to be closest to the client"location of the client"location of the client"lldp_tia_location_lci_what_valuesLLDP_PRIVATE_TIA_LOCATION_LCI_CATYPE_A1national subdivisions (state,canton,region,province,prefecture)"national subdivisions (state,canton,region,province,prefecture)"LLDP_PRIVATE_TIA_LOCATION_LCI_CATYPE_A2county, parish, gun, district"county, parish, gun, district"LLDP_PRIVATE_TIA_LOCATION_LCI_CATYPE_A3city, township, shi"city, township, shi"LLDP_PRIVATE_TIA_LOCATION_LCI_CATYPE_A4city division, borough, city district, ward chou"city division, borough, city district, ward chou"LLDP_PRIVATE_TIA_LOCATION_LCI_CATYPE_A5neighborhood, block"neighborhood, block"LLDP_PRIVATE_TIA_LOCATION_LCI_CATYPE_A6street"street"lldp_tia_location_lci_catype_valuesLLDP_PRIVATE_TIA_LOCATION_ALTITUDE_METERSmeters"meters"LLDP_PRIVATE_TIA_LOCATION_ALTITUDE_FLOORSfloors"floors"lldp_tia_location_altitude_type_valuesLLDP-MED Capabilities"LLDP-MED Capabilities"Network policy"Network policy"Location identification"Location identification"Extended power-via-MDI"Extended power-via-MDI"Inventory - hardware revision"Inventory - hardware revision"Inventory - firmware revision"Inventory - firmware revision"Inventory - software revision"Inventory - software revision"Inventory - serial number"Inventory - serial number"Inventory - manufacturer name"Inventory - manufacturer name"Inventory - model name"Inventory - model name"Inventory - asset ID"Inventory - asset ID"lldp_tia_subtype_valuesMAC/PHY configuration/status"MAC/PHY configuration/status"Power via MDI"Power via MDI"Link aggregation"Link aggregation"Max frame size"Max frame size"lldp_8023_subtype_valuesLLDP_8021_PORT_PROTOCOL_VLAN_SUPPORTLLDP_8021_PORT_PROTOCOL_VLAN_STATUSlldp_8021_port_protocol_id_valuesPort VLAN Id"Port VLAN Id"Port and Protocol VLAN ID"Port and Protocol VLAN ID"VLAN name"VLAN name"Protocol Identity"Protocol Identity"Congestion Notification"Congestion Notification"ETS Configuration"ETS Configuration"ETS Recommendation"ETS Recommendation"Priority Flow Control Configuration"Priority Flow Control Configuration"Application Priority"Application Priority"EVB"EVB"CDCP"CDCP"lldp_8021_subtype_valuesLLDP_CAP_OTHEROther"Other"LLDP_CAP_REPEATERRepeater"Repeater"LLDP_CAP_BRIDGEBridge"Bridge"LLDP_CAP_WLAN_APWLAN AP"WLAN AP"LLDP_CAP_ROUTERLLDP_CAP_PHONETelephone"Telephone"LLDP_CAP_DOCSISDocsis"Docsis"LLDP_CAP_STATION_ONLYStation Only"Station Only"lldp_cap_valuesNetwork Address"Network Address"Interface Name"Interface Name"Agent circuit ID"Agent circuit ID"Local"Local"lldp_port_subtype_valueslldp_chassis_subtype_valuesLLDP_END_TLVChassis ID"Chassis ID"Port ID"Port ID"Time to Live"Time to Live"Port Description"Port Description"System Description"System Description"System Capabilities"System Capabilities"Management Address"Management Address"Organization specific"Organization specific"lldp_tlv_values(1 << 8)(1 << 9)(1 << 10)(1 << 11)(1 << 12)(1 << 13)(1 << 14)LLDP_MAU_PMD_OTHER(1 << 15)LLDP_EXTRACT_NETWORK_POLICY_DSCP(x)((x)&0x003f)LLDP_EXTRACT_NETWORK_POLICY_L2_PRIORITY(x)(((x)&0x01ff)>>6)LLDP_EXTRACT_NETWORK_POLICY_VLAN(x)(((x)&0x1ffe)>>1)LLDP_EXTRACT_LEN(x)((x)&0x01ff)LLDP_EXTRACT_TYPE(x)(((x)&0xfe00)>>9)/* do we also want to see a hex dump ? *//*
                 * XXX - IEEE Std 802.1AB-2009 says the first octet
                 * if a chassis ID subtype, with the system
                 * capabilities and enabled capabilities following
                 * it.
                 *//*
             * The system name is also print in non-verbose mode
             * similar to the CDP printer.
             *//*
     * The OID is optional.
     *//* This cannot be assigned to ip6addr_string(), which is a macro. *//* This cannot be assigned to ipaddr_string(), which is a macro. *//*
	     * Array of 8 4-bit priority group ID values; we fetch all
	     * 32 bits and extract each nibble.
	     *//* decode every tlv *//* loop check *//* by passing old version *//*
 * Print DCBX Protocol fields (V 1.01).
 *//* basic sanity check *//* Decode each civic address element *//* Country code *//*
 * Print private TIA extensions.
 *//* objects defined in IANA subtype 00 00 5e
 * (right now there is only one)
 *//*
 * Extract 34bits of latitude/longitude coordinates.
 *//*
 * Print IEEE 802.3 private extensions. (802.3bc)
 *//*  Length of Application Priority Table *//* Print TSA Assignment Table *//*Print TC Bandwidth Table *//*Print Priority Assignment Table *//*Print TC Bandwidth Table*//*Print Priority Assignment Table*//*
 * Print IEEE 802.1 private extensions. (802.1AB annex E)
 *//*
 * Interface numbering subtypes.
 *//*
 * DCBX protocol subtypes.
 *//*
 * From RFC 3636 - ifMauAutoNegCapAdvertisedBits
 *//*
 * From RFC 3636 - dot3MauType
 *//* ANSI/TIA-1057 - Annex B *//*
 * System Capabilities
 *//*
 * Port ID subtypes
 *//*
 * Chassis ID subtypes
 *//*
 * TLV type codes
 *//* \summary: IEEE 802.1ab Link Layer Discovery Protocol (LLDP) printer *//*
 * Copyright (c) 1998-2007 The TCPDUMP project
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that: (1) source code
 * distributions retain the above copyright notice and this paragraph
 * in its entirety, and (2) distributions including binary code include
 * the above copyright notice and this paragraph in its entirety in
 * the documentation or other materials provided with the distribution.
 * THIS SOFTWARE IS PROVIDED ``AS IS'' AND
 * WITHOUT ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, WITHOUT
 * LIMITATION, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS
 * FOR A PARTICULAR PURPOSE.
 *
 * Original code by Hannes Gredler (hannes@gredler.at)
 * IEEE and TIA extensions by Carles Kishimoto <carles.kishimoto@gmail.com>
 * DCBX extensions by Kaladhar Musunuru <kaladharm@sourceforge.net>
 *//Users/owura/Repos/codeql_eval/proj_repos/the-tcpdump-group-tcpdump-commit-9ba91381954ad325ea4fd26b9c65a8bd9a2a85b6/tcpdump/print-lmp.clmp_printconst lmp_common_headerconst lmp_common_header *lmp_common_header *lmp_com_headerconst lmp_object_headerconst lmp_object_header *lmp_object_header *lmp_obj_headerlmp_obj_lenlmp_obj_ctypelink_type*lmp_com_headersizeof(*lmp_com_header)lmp_com_header->version_res[0](ndo, "LMP version %u packet not supported", LMP_EXTRACT_VERSION(lmp_com_header->version_res[0]))(ndo, "LMP version %u packet not supported", (((lmp_com_header->version_res[0])&0xf0)>>4))LMP_VERSIONLMP version %u packet not supported(ndo, "LMPv%u %s Message, length: %u", LMP_EXTRACT_VERSION(lmp_com_header->version_res[0]), tok2str(lmp_msg_type_values, "unknown (%u)",lmp_com_header->msg_type), len)(ndo, "LMPv%u %s Message, length: %u", (((lmp_com_header->version_res[0])&0xf0)>>4), tok2str(lmp_msg_type_values, "unknown (%u)",lmp_com_header->msg_type), len)LMPv%u %s Message, length: %uconst tok[24]tok[24]lmp_com_header->length(ndo, "\n\tLMPv%u, msg-type: %s, Flags: [%s], length: %u", LMP_EXTRACT_VERSION(lmp_com_header->version_res[0]), tok2str(lmp_msg_type_values, "unknown, type: %u",lmp_com_header->msg_type), bittok2str(lmp_header_flag_values,"none",lmp_com_header->flags), tlen)(ndo, "\n\tLMPv%u, msg-type: %s, Flags: [%s], length: %u", (((lmp_com_header->version_res[0])&0xf0)>>4), tok2str(lmp_msg_type_values, "unknown, type: %u",lmp_com_header->msg_type), bittok2str(lmp_header_flag_values,"none",lmp_com_header->flags), tlen)
	LMPv%u, msg-type: %s, Flags: [%s], length: %u(ndo, " (too short)")sizeof(const struct lmp_common_header) (too short)(ndo, " (too long)") (too long)sizeof(struct lmp_object_header)lmp_obj_header->length(ndo, "\n\t  %s Object (%u), Class-Type: %s (%u) Flags: [%snegotiable], length: %u", tok2str(lmp_obj_values, "Unknown", lmp_obj_header->class_num), lmp_obj_header->class_num, tok2str(lmp_ctype_values, "Unknown", ((lmp_obj_header->class_num)<<8)+lmp_obj_ctype), lmp_obj_ctype, (lmp_obj_header->ctype)&0x80 ? "" : "non-", lmp_obj_len)(ndo, " (not a multiple of 4)")(ndo, " (not correct for object)")(ndo, "\n\t    Control Channel ID: %u (0x%08x)", EXTRACT_32BITS(obj_tptr), EXTRACT_32BITS(obj_tptr))(ndo, "\n\t    Control Channel ID: %u (0x%08x)", ((uint32_t)(((uint32_t)(*((const uint8_t *)(obj_tptr) + 0)) << 24) | ((uint32_t)(*((const uint8_t *)(obj_tptr) + 1)) << 16) | ((uint32_t)(*((const uint8_t *)(obj_tptr) + 2)) << 8) | ((uint32_t)(*((const uint8_t *)(obj_tptr) + 3)) << 0))), ((uint32_t)(((uint32_t)(*((const uint8_t *)(obj_tptr) + 0)) << 24) | ((uint32_t)(*((const uint8_t *)(obj_tptr) + 1)) << 16) | ((uint32_t)(*((const uint8_t *)(obj_tptr) + 2)) << 8) | ((uint32_t)(*((const uint8_t *)(obj_tptr) + 3)) << 0))))(ndo, "\n\t    IPv4 Link ID: %s (0x%08x)", ipaddr_string(ndo, obj_tptr), EXTRACT_32BITS(obj_tptr))(ndo, "\n\t    IPv4 Link ID: %s (0x%08x)", getname(ndo, (const u_char *)(obj_tptr)), ((uint32_t)(((uint32_t)(*((const uint8_t *)(obj_tptr) + 0)) << 24) | ((uint32_t)(*((const uint8_t *)(obj_tptr) + 1)) << 16) | ((uint32_t)(*((const uint8_t *)(obj_tptr) + 2)) << 8) | ((uint32_t)(*((const uint8_t *)(obj_tptr) + 3)) << 0))))(ndo, "\n\t    IPv6 Link ID: %s (0x%08x)", ip6addr_string(ndo, obj_tptr), EXTRACT_32BITS(obj_tptr))(ndo, "\n\t    IPv6 Link ID: %s (0x%08x)", getname6(ndo, (const u_char *)(obj_tptr)), ((uint32_t)(((uint32_t)(*((const uint8_t *)(obj_tptr) + 0)) << 24) | ((uint32_t)(*((const uint8_t *)(obj_tptr) + 1)) << 16) | ((uint32_t)(*((const uint8_t *)(obj_tptr) + 2)) << 8) | ((uint32_t)(*((const uint8_t *)(obj_tptr) + 3)) << 0))))(ndo, "\n\t    Link ID: %u (0x%08x)", EXTRACT_32BITS(obj_tptr), EXTRACT_32BITS(obj_tptr))(ndo, "\n\t    Link ID: %u (0x%08x)", ((uint32_t)(((uint32_t)(*((const uint8_t *)(obj_tptr) + 0)) << 24) | ((uint32_t)(*((const uint8_t *)(obj_tptr) + 1)) << 16) | ((uint32_t)(*((const uint8_t *)(obj_tptr) + 2)) << 8) | ((uint32_t)(*((const uint8_t *)(obj_tptr) + 3)) << 0))), ((uint32_t)(((uint32_t)(*((const uint8_t *)(obj_tptr) + 0)) << 24) | ((uint32_t)(*((const uint8_t *)(obj_tptr) + 1)) << 16) | ((uint32_t)(*((const uint8_t *)(obj_tptr) + 2)) << 8) | ((uint32_t)(*((const uint8_t *)(obj_tptr) + 3)) << 0))))(ndo, "\n\t    Message ID: %u (0x%08x)", EXTRACT_32BITS(obj_tptr), EXTRACT_32BITS(obj_tptr))(ndo, "\n\t    Message ID: %u (0x%08x)", ((uint32_t)(((uint32_t)(*((const uint8_t *)(obj_tptr) + 0)) << 24) | ((uint32_t)(*((const uint8_t *)(obj_tptr) + 1)) << 16) | ((uint32_t)(*((const uint8_t *)(obj_tptr) + 2)) << 8) | ((uint32_t)(*((const uint8_t *)(obj_tptr) + 3)) << 0))), ((uint32_t)(((uint32_t)(*((const uint8_t *)(obj_tptr) + 0)) << 24) | ((uint32_t)(*((const uint8_t *)(obj_tptr) + 1)) << 16) | ((uint32_t)(*((const uint8_t *)(obj_tptr) + 2)) << 8) | ((uint32_t)(*((const uint8_t *)(obj_tptr) + 3)) << 0))))(ndo, "\n\t    Message ID Ack: %u (0x%08x)", EXTRACT_32BITS(obj_tptr), EXTRACT_32BITS(obj_tptr))(ndo, "\n\t    Message ID Ack: %u (0x%08x)", ((uint32_t)(((uint32_t)(*((const uint8_t *)(obj_tptr) + 0)) << 24) | ((uint32_t)(*((const uint8_t *)(obj_tptr) + 1)) << 16) | ((uint32_t)(*((const uint8_t *)(obj_tptr) + 2)) << 8) | ((uint32_t)(*((const uint8_t *)(obj_tptr) + 3)) << 0))), ((uint32_t)(((uint32_t)(*((const uint8_t *)(obj_tptr) + 0)) << 24) | ((uint32_t)(*((const uint8_t *)(obj_tptr) + 1)) << 16) | ((uint32_t)(*((const uint8_t *)(obj_tptr) + 2)) << 8) | ((uint32_t)(*((const uint8_t *)(obj_tptr) + 3)) << 0))))(ndo, "\n\t    Node ID: %s (0x%08x)", ipaddr_string(ndo, obj_tptr), EXTRACT_32BITS(obj_tptr))(ndo, "\n\t    Node ID: %s (0x%08x)", getname(ndo, (const u_char *)(obj_tptr)), ((uint32_t)(((uint32_t)(*((const uint8_t *)(obj_tptr) + 0)) << 24) | ((uint32_t)(*((const uint8_t *)(obj_tptr) + 1)) << 16) | ((uint32_t)(*((const uint8_t *)(obj_tptr) + 2)) << 8) | ((uint32_t)(*((const uint8_t *)(obj_tptr) + 3)) << 0))))(ndo, "\n\t    Hello Interval: %u\n\t    Hello Dead Interval: %u", EXTRACT_16BITS(obj_tptr), EXTRACT_16BITS(obj_tptr+2))(ndo, "\n\t    Hello Interval: %u\n\t    Hello Dead Interval: %u", ((uint16_t)(((uint16_t)(*((const uint8_t *)(obj_tptr) + 0)) << 8) | ((uint16_t)(*((const uint8_t *)(obj_tptr) + 1)) << 0))), ((uint16_t)(((uint16_t)(*((const uint8_t *)(obj_tptr+2) + 0)) << 8) | ((uint16_t)(*((const uint8_t *)(obj_tptr+2) + 1)) << 0))))obj_tptr+2(ndo, "\n\t    Tx Seq: %u, Rx Seq: %u", EXTRACT_32BITS(obj_tptr), EXTRACT_32BITS(obj_tptr+4))(ndo, "\n\t    Tx Seq: %u, Rx Seq: %u", ((uint32_t)(((uint32_t)(*((const uint8_t *)(obj_tptr) + 0)) << 24) | ((uint32_t)(*((const uint8_t *)(obj_tptr) + 1)) << 16) | ((uint32_t)(*((const uint8_t *)(obj_tptr) + 2)) << 8) | ((uint32_t)(*((const uint8_t *)(obj_tptr) + 3)) << 0))), ((uint32_t)(((uint32_t)(*((const uint8_t *)(obj_tptr+4) + 0)) << 24) | ((uint32_t)(*((const uint8_t *)(obj_tptr+4) + 1)) << 16) | ((uint32_t)(*((const uint8_t *)(obj_tptr+4) + 2)) << 8) | ((uint32_t)(*((const uint8_t *)(obj_tptr+4) + 3)) << 0))))obj_tptr+4(ndo, "\n\t    Flags: [%s]", bittok2str(lmp_obj_te_link_flag_values, "none", EXTRACT_8BITS(obj_tptr)))(ndo, "\n\t    Flags: [%s]", bittok2str(lmp_obj_te_link_flag_values, "none", (*(obj_tptr))))(ndo, "\n\t    Local Link-ID: %s (0x%08x)" "\n\t    Remote Link-ID: %s (0x%08x)", ipaddr_string(ndo, obj_tptr+4), EXTRACT_32BITS(obj_tptr+4), ipaddr_string(ndo, obj_tptr+8), EXTRACT_32BITS(obj_tptr+8))(ndo, "\n\t    Local Link-ID: %s (0x%08x)" "\n\t    Remote Link-ID: %s (0x%08x)", getname(ndo, (const u_char *)(obj_tptr+4)), ((uint32_t)(((uint32_t)(*((const uint8_t *)(obj_tptr+4) + 0)) << 24) | ((uint32_t)(*((const uint8_t *)(obj_tptr+4) + 1)) << 16) | ((uint32_t)(*((const uint8_t *)(obj_tptr+4) + 2)) << 8) | ((uint32_t)(*((const uint8_t *)(obj_tptr+4) + 3)) << 0))), getname(ndo, (const u_char *)(obj_tptr+8)), ((uint32_t)(((uint32_t)(*((const uint8_t *)(obj_tptr+8) + 0)) << 24) | ((uint32_t)(*((const uint8_t *)(obj_tptr+8) + 1)) << 16) | ((uint32_t)(*((const uint8_t *)(obj_tptr+8) + 2)) << 8) | ((uint32_t)(*((const uint8_t *)(obj_tptr+8) + 3)) << 0))))obj_tptr+8(ndo, "\n\t    Local Link-ID: %s (0x%08x)" "\n\t    Remote Link-ID: %s (0x%08x)", ip6addr_string(ndo, obj_tptr+4), EXTRACT_32BITS(obj_tptr+4), ip6addr_string(ndo, obj_tptr+20), EXTRACT_32BITS(obj_tptr+20))(ndo, "\n\t    Local Link-ID: %s (0x%08x)" "\n\t    Remote Link-ID: %s (0x%08x)", getname6(ndo, (const u_char *)(obj_tptr+4)), ((uint32_t)(((uint32_t)(*((const uint8_t *)(obj_tptr+4) + 0)) << 24) | ((uint32_t)(*((const uint8_t *)(obj_tptr+4) + 1)) << 16) | ((uint32_t)(*((const uint8_t *)(obj_tptr+4) + 2)) << 8) | ((uint32_t)(*((const uint8_t *)(obj_tptr+4) + 3)) << 0))), getname6(ndo, (const u_char *)(obj_tptr+20)), ((uint32_t)(((uint32_t)(*((const uint8_t *)(obj_tptr+20) + 0)) << 24) | ((uint32_t)(*((const uint8_t *)(obj_tptr+20) + 1)) << 16) | ((uint32_t)(*((const uint8_t *)(obj_tptr+20) + 2)) << 8) | ((uint32_t)(*((const uint8_t *)(obj_tptr+20) + 3)) << 0))))obj_tptr+20(ndo, "\n\t    Local Link-ID: %u (0x%08x)" "\n\t    Remote Link-ID: %u (0x%08x)", EXTRACT_32BITS(obj_tptr+4), EXTRACT_32BITS(obj_tptr+4), EXTRACT_32BITS(obj_tptr+8), EXTRACT_32BITS(obj_tptr+8))(ndo, "\n\t    Local Link-ID: %u (0x%08x)" "\n\t    Remote Link-ID: %u (0x%08x)", ((uint32_t)(((uint32_t)(*((const uint8_t *)(obj_tptr+4) + 0)) << 24) | ((uint32_t)(*((const uint8_t *)(obj_tptr+4) + 1)) << 16) | ((uint32_t)(*((const uint8_t *)(obj_tptr+4) + 2)) << 8) | ((uint32_t)(*((const uint8_t *)(obj_tptr+4) + 3)) << 0))), ((uint32_t)(((uint32_t)(*((const uint8_t *)(obj_tptr+4) + 0)) << 24) | ((uint32_t)(*((const uint8_t *)(obj_tptr+4) + 1)) << 16) | ((uint32_t)(*((const uint8_t *)(obj_tptr+4) + 2)) << 8) | ((uint32_t)(*((const uint8_t *)(obj_tptr+4) + 3)) << 0))), ((uint32_t)(((uint32_t)(*((const uint8_t *)(obj_tptr+8) + 0)) << 24) | ((uint32_t)(*((const uint8_t *)(obj_tptr+8) + 1)) << 16) | ((uint32_t)(*((const uint8_t *)(obj_tptr+8) + 2)) << 8) | ((uint32_t)(*((const uint8_t *)(obj_tptr+8) + 3)) << 0))), ((uint32_t)(((uint32_t)(*((const uint8_t *)(obj_tptr+8) + 0)) << 24) | ((uint32_t)(*((const uint8_t *)(obj_tptr+8) + 1)) << 16) | ((uint32_t)(*((const uint8_t *)(obj_tptr+8) + 2)) << 8) | ((uint32_t)(*((const uint8_t *)(obj_tptr+8) + 3)) << 0))))(ndo, "\n\t    Flags: [%s]", bittok2str(lmp_obj_data_link_flag_values, "none", EXTRACT_8BITS(obj_tptr)))(ndo, "\n\t    Flags: [%s]", bittok2str(lmp_obj_data_link_flag_values, "none", (*(obj_tptr))))(ndo, "\n\t    Local Interface ID: %s (0x%08x)" "\n\t    Remote Interface ID: %s (0x%08x)", ipaddr_string(ndo, obj_tptr+4), EXTRACT_32BITS(obj_tptr+4), ipaddr_string(ndo, obj_tptr+8), EXTRACT_32BITS(obj_tptr+8))(ndo, "\n\t    Local Interface ID: %s (0x%08x)" "\n\t    Remote Interface ID: %s (0x%08x)", getname(ndo, (const u_char *)(obj_tptr+4)), ((uint32_t)(((uint32_t)(*((const uint8_t *)(obj_tptr+4) + 0)) << 24) | ((uint32_t)(*((const uint8_t *)(obj_tptr+4) + 1)) << 16) | ((uint32_t)(*((const uint8_t *)(obj_tptr+4) + 2)) << 8) | ((uint32_t)(*((const uint8_t *)(obj_tptr+4) + 3)) << 0))), getname(ndo, (const u_char *)(obj_tptr+8)), ((uint32_t)(((uint32_t)(*((const uint8_t *)(obj_tptr+8) + 0)) << 24) | ((uint32_t)(*((const uint8_t *)(obj_tptr+8) + 1)) << 16) | ((uint32_t)(*((const uint8_t *)(obj_tptr+8) + 2)) << 8) | ((uint32_t)(*((const uint8_t *)(obj_tptr+8) + 3)) << 0))))(ndo, "\n\t    Local Interface ID: %s (0x%08x)" "\n\t    Remote Interface ID: %s (0x%08x)", ip6addr_string(ndo, obj_tptr+4), EXTRACT_32BITS(obj_tptr+4), ip6addr_string(ndo, obj_tptr+20), EXTRACT_32BITS(obj_tptr+20))(ndo, "\n\t    Local Interface ID: %s (0x%08x)" "\n\t    Remote Interface ID: %s (0x%08x)", getname6(ndo, (const u_char *)(obj_tptr+4)), ((uint32_t)(((uint32_t)(*((const uint8_t *)(obj_tptr+4) + 0)) << 24) | ((uint32_t)(*((const uint8_t *)(obj_tptr+4) + 1)) << 16) | ((uint32_t)(*((const uint8_t *)(obj_tptr+4) + 2)) << 8) | ((uint32_t)(*((const uint8_t *)(obj_tptr+4) + 3)) << 0))), getname6(ndo, (const u_char *)(obj_tptr+20)), ((uint32_t)(((uint32_t)(*((const uint8_t *)(obj_tptr+20) + 0)) << 24) | ((uint32_t)(*((const uint8_t *)(obj_tptr+20) + 1)) << 16) | ((uint32_t)(*((const uint8_t *)(obj_tptr+20) + 2)) << 8) | ((uint32_t)(*((const uint8_t *)(obj_tptr+20) + 3)) << 0))))(ndo, "\n\t    Local Interface ID: %u (0x%08x)" "\n\t    Remote Interface ID: %u (0x%08x)", EXTRACT_32BITS(obj_tptr+4), EXTRACT_32BITS(obj_tptr+4), EXTRACT_32BITS(obj_tptr+8), EXTRACT_32BITS(obj_tptr+8))(ndo, "\n\t    Local Interface ID: %u (0x%08x)" "\n\t    Remote Interface ID: %u (0x%08x)", ((uint32_t)(((uint32_t)(*((const uint8_t *)(obj_tptr+4) + 0)) << 24) | ((uint32_t)(*((const uint8_t *)(obj_tptr+4) + 1)) << 16) | ((uint32_t)(*((const uint8_t *)(obj_tptr+4) + 2)) << 8) | ((uint32_t)(*((const uint8_t *)(obj_tptr+4) + 3)) << 0))), ((uint32_t)(((uint32_t)(*((const uint8_t *)(obj_tptr+4) + 0)) << 24) | ((uint32_t)(*((const uint8_t *)(obj_tptr+4) + 1)) << 16) | ((uint32_t)(*((const uint8_t *)(obj_tptr+4) + 2)) << 8) | ((uint32_t)(*((const uint8_t *)(obj_tptr+4) + 3)) << 0))), ((uint32_t)(((uint32_t)(*((const uint8_t *)(obj_tptr+8) + 0)) << 24) | ((uint32_t)(*((const uint8_t *)(obj_tptr+8) + 1)) << 16) | ((uint32_t)(*((const uint8_t *)(obj_tptr+8) + 2)) << 8) | ((uint32_t)(*((const uint8_t *)(obj_tptr+8) + 3)) << 0))), ((uint32_t)(((uint32_t)(*((const uint8_t *)(obj_tptr+8) + 0)) << 24) | ((uint32_t)(*((const uint8_t *)(obj_tptr+8) + 1)) << 16) | ((uint32_t)(*((const uint8_t *)(obj_tptr+8) + 2)) << 8) | ((uint32_t)(*((const uint8_t *)(obj_tptr+8) + 3)) << 0))))(ndo, "\n\t    Flags: %s", bittok2str(lmp_obj_begin_verify_flag_values, "none", EXTRACT_16BITS(obj_tptr)))(ndo, "\n\t    Flags: %s", bittok2str(lmp_obj_begin_verify_flag_values, "none", ((uint16_t)(((uint16_t)(*((const uint8_t *)(obj_tptr) + 0)) << 8) | ((uint16_t)(*((const uint8_t *)(obj_tptr) + 1)) << 0)))))(ndo, "\n\t    Verify Interval: %u", EXTRACT_16BITS(obj_tptr+2))(ndo, "\n\t    Verify Interval: %u", ((uint16_t)(((uint16_t)(*((const uint8_t *)(obj_tptr+2) + 0)) << 8) | ((uint16_t)(*((const uint8_t *)(obj_tptr+2) + 1)) << 0))))(ndo, "\n\t    Data links: %u", EXTRACT_32BITS(obj_tptr+4))(ndo, "\n\t    Data links: %u", ((uint32_t)(((uint32_t)(*((const uint8_t *)(obj_tptr+4) + 0)) << 24) | ((uint32_t)(*((const uint8_t *)(obj_tptr+4) + 1)) << 16) | ((uint32_t)(*((const uint8_t *)(obj_tptr+4) + 2)) << 8) | ((uint32_t)(*((const uint8_t *)(obj_tptr+4) + 3)) << 0))))(ndo, "\n\t    Encoding type: %s", tok2str(gmpls_encoding_values, "Unknown", *(obj_tptr+8)))(ndo, "\n\t    Verify Transport Mechanism: %u (0x%x)%s", EXTRACT_16BITS(obj_tptr+10), EXTRACT_16BITS(obj_tptr+10), EXTRACT_16BITS(obj_tptr+10)&8000 ? " (Payload test messages capable)" : "")(ndo, "\n\t    Verify Transport Mechanism: %u (0x%x)%s", ((uint16_t)(((uint16_t)(*((const uint8_t *)(obj_tptr+10) + 0)) << 8) | ((uint16_t)(*((const uint8_t *)(obj_tptr+10) + 1)) << 0))), ((uint16_t)(((uint16_t)(*((const uint8_t *)(obj_tptr+10) + 0)) << 8) | ((uint16_t)(*((const uint8_t *)(obj_tptr+10) + 1)) << 0))), ((uint16_t)(((uint16_t)(*((const uint8_t *)(obj_tptr+10) + 0)) << 8) | ((uint16_t)(*((const uint8_t *)(obj_tptr+10) + 1)) << 0)))&8000 ? " (Payload test messages capable)" : "")obj_tptr+10obj_tptr+12(ndo, "\n\t    Transmission Rate: %.3f Mbps",bw.f*8/1000000)(ndo, "\n\t    Wavelength: %u", EXTRACT_32BITS(obj_tptr+16))(ndo, "\n\t    Wavelength: %u", ((uint32_t)(((uint32_t)(*((const uint8_t *)(obj_tptr+16) + 0)) << 24) | ((uint32_t)(*((const uint8_t *)(obj_tptr+16) + 1)) << 16) | ((uint32_t)(*((const uint8_t *)(obj_tptr+16) + 2)) << 8) | ((uint32_t)(*((const uint8_t *)(obj_tptr+16) + 3)) << 0))))obj_tptr+16(ndo, "\n\t    Verify Dead Interval: %u" "\n\t    Verify Transport Response: %u", EXTRACT_16BITS(obj_tptr), EXTRACT_16BITS(obj_tptr+2))(ndo, "\n\t    Verify Dead Interval: %u" "\n\t    Verify Transport Response: %u", ((uint16_t)(((uint16_t)(*((const uint8_t *)(obj_tptr) + 0)) << 8) | ((uint16_t)(*((const uint8_t *)(obj_tptr) + 1)) << 0))), ((uint16_t)(((uint16_t)(*((const uint8_t *)(obj_tptr+2) + 0)) << 8) | ((uint16_t)(*((const uint8_t *)(obj_tptr+2) + 1)) << 0))))(ndo, "\n\t    Verify ID: %u", EXTRACT_32BITS(obj_tptr))(ndo, "\n\t    Verify ID: %u", ((uint32_t)(((uint32_t)(*((const uint8_t *)(obj_tptr) + 0)) << 24) | ((uint32_t)(*((const uint8_t *)(obj_tptr) + 1)) << 16) | ((uint32_t)(*((const uint8_t *)(obj_tptr) + 2)) << 8) | ((uint32_t)(*((const uint8_t *)(obj_tptr) + 3)) << 0))))(ndo, "\n\t    Interface ID: %s (0x%08x)", ipaddr_string(ndo, obj_tptr+offset), EXTRACT_32BITS(obj_tptr+offset))(ndo, "\n\t    Interface ID: %s (0x%08x)", getname(ndo, (const u_char *)(obj_tptr+offset)), ((uint32_t)(((uint32_t)(*((const uint8_t *)(obj_tptr+offset) + 0)) << 24) | ((uint32_t)(*((const uint8_t *)(obj_tptr+offset) + 1)) << 16) | ((uint32_t)(*((const uint8_t *)(obj_tptr+offset) + 2)) << 8) | ((uint32_t)(*((const uint8_t *)(obj_tptr+offset) + 3)) << 0))))obj_tptr+offset(ndo, "\n\t\t    Active: %s (%u)", (EXTRACT_32BITS(obj_tptr+offset+4)>>31) ? "Allocated" : "Non-allocated", (EXTRACT_32BITS(obj_tptr+offset+4)>>31))(ndo, "\n\t\t    Active: %s (%u)", (((uint32_t)(((uint32_t)(*((const uint8_t *)(obj_tptr+offset+4) + 0)) << 24) | ((uint32_t)(*((const uint8_t *)(obj_tptr+offset+4) + 1)) << 16) | ((uint32_t)(*((const uint8_t *)(obj_tptr+offset+4) + 2)) << 8) | ((uint32_t)(*((const uint8_t *)(obj_tptr+offset+4) + 3)) << 0)))>>31) ? "Allocated" : "Non-allocated", (((uint32_t)(((uint32_t)(*((const uint8_t *)(obj_tptr+offset+4) + 0)) << 24) | ((uint32_t)(*((const uint8_t *)(obj_tptr+offset+4) + 1)) << 16) | ((uint32_t)(*((const uint8_t *)(obj_tptr+offset+4) + 2)) << 8) | ((uint32_t)(*((const uint8_t *)(obj_tptr+offset+4) + 3)) << 0)))>>31))obj_tptr+offset+4(ndo, "\n\t\t    Direction: %s (%u)", (EXTRACT_32BITS(obj_tptr+offset+4)>>30)&0x1 ? "Transmit" : "Receive", (EXTRACT_32BITS(obj_tptr+offset+4)>>30)&0x1)(ndo, "\n\t\t    Direction: %s (%u)", (((uint32_t)(((uint32_t)(*((const uint8_t *)(obj_tptr+offset+4) + 0)) << 24) | ((uint32_t)(*((const uint8_t *)(obj_tptr+offset+4) + 1)) << 16) | ((uint32_t)(*((const uint8_t *)(obj_tptr+offset+4) + 2)) << 8) | ((uint32_t)(*((const uint8_t *)(obj_tptr+offset+4) + 3)) << 0)))>>30)&0x1 ? "Transmit" : "Receive", (((uint32_t)(((uint32_t)(*((const uint8_t *)(obj_tptr+offset+4) + 0)) << 24) | ((uint32_t)(*((const uint8_t *)(obj_tptr+offset+4) + 1)) << 16) | ((uint32_t)(*((const uint8_t *)(obj_tptr+offset+4) + 2)) << 8) | ((uint32_t)(*((const uint8_t *)(obj_tptr+offset+4) + 3)) << 0)))>>30)&0x1)(ndo, "\n\t\t    Channel Status: %s (%u)", tok2str(lmp_obj_channel_status_values, "Unknown", EXTRACT_32BITS(obj_tptr+offset+4)&0x3FFFFFF), EXTRACT_32BITS(obj_tptr+offset+4)&0x3FFFFFF)(ndo, "\n\t\t    Channel Status: %s (%u)", tok2str(lmp_obj_channel_status_values, "Unknown", ((uint32_t)(((uint32_t)(*((const uint8_t *)(obj_tptr+offset+4) + 0)) << 24) | ((uint32_t)(*((const uint8_t *)(obj_tptr+offset+4) + 1)) << 16) | ((uint32_t)(*((const uint8_t *)(obj_tptr+offset+4) + 2)) << 8) | ((uint32_t)(*((const uint8_t *)(obj_tptr+offset+4) + 3)) << 0)))&0x3FFFFFF), ((uint32_t)(((uint32_t)(*((const uint8_t *)(obj_tptr+offset+4) + 0)) << 24) | ((uint32_t)(*((const uint8_t *)(obj_tptr+offset+4) + 1)) << 16) | ((uint32_t)(*((const uint8_t *)(obj_tptr+offset+4) + 2)) << 8) | ((uint32_t)(*((const uint8_t *)(obj_tptr+offset+4) + 3)) << 0)))&0x3FFFFFF)(ndo, "\n\t    Interface ID: %s (0x%08x)", ip6addr_string(ndo, obj_tptr+offset), EXTRACT_32BITS(obj_tptr+offset))(ndo, "\n\t    Interface ID: %s (0x%08x)", getname6(ndo, (const u_char *)(obj_tptr+offset)), ((uint32_t)(((uint32_t)(*((const uint8_t *)(obj_tptr+offset) + 0)) << 24) | ((uint32_t)(*((const uint8_t *)(obj_tptr+offset) + 1)) << 16) | ((uint32_t)(*((const uint8_t *)(obj_tptr+offset) + 2)) << 8) | ((uint32_t)(*((const uint8_t *)(obj_tptr+offset) + 3)) << 0))))(ndo, "\n\t\t    Active: %s (%u)", (EXTRACT_32BITS(obj_tptr+offset+16)>>31) ? "Allocated" : "Non-allocated", (EXTRACT_32BITS(obj_tptr+offset+16)>>31))(ndo, "\n\t\t    Active: %s (%u)", (((uint32_t)(((uint32_t)(*((const uint8_t *)(obj_tptr+offset+16) + 0)) << 24) | ((uint32_t)(*((const uint8_t *)(obj_tptr+offset+16) + 1)) << 16) | ((uint32_t)(*((const uint8_t *)(obj_tptr+offset+16) + 2)) << 8) | ((uint32_t)(*((const uint8_t *)(obj_tptr+offset+16) + 3)) << 0)))>>31) ? "Allocated" : "Non-allocated", (((uint32_t)(((uint32_t)(*((const uint8_t *)(obj_tptr+offset+16) + 0)) << 24) | ((uint32_t)(*((const uint8_t *)(obj_tptr+offset+16) + 1)) << 16) | ((uint32_t)(*((const uint8_t *)(obj_tptr+offset+16) + 2)) << 8) | ((uint32_t)(*((const uint8_t *)(obj_tptr+offset+16) + 3)) << 0)))>>31))obj_tptr+offset+16(ndo, "\n\t\t    Direction: %s (%u)", (EXTRACT_32BITS(obj_tptr+offset+16)>>30)&0x1 ? "Transmit" : "Receive", (EXTRACT_32BITS(obj_tptr+offset+16)>>30)&0x1)(ndo, "\n\t\t    Direction: %s (%u)", (((uint32_t)(((uint32_t)(*((const uint8_t *)(obj_tptr+offset+16) + 0)) << 24) | ((uint32_t)(*((const uint8_t *)(obj_tptr+offset+16) + 1)) << 16) | ((uint32_t)(*((const uint8_t *)(obj_tptr+offset+16) + 2)) << 8) | ((uint32_t)(*((const uint8_t *)(obj_tptr+offset+16) + 3)) << 0)))>>30)&0x1 ? "Transmit" : "Receive", (((uint32_t)(((uint32_t)(*((const uint8_t *)(obj_tptr+offset+16) + 0)) << 24) | ((uint32_t)(*((const uint8_t *)(obj_tptr+offset+16) + 1)) << 16) | ((uint32_t)(*((const uint8_t *)(obj_tptr+offset+16) + 2)) << 8) | ((uint32_t)(*((const uint8_t *)(obj_tptr+offset+16) + 3)) << 0)))>>30)&0x1)(ndo, "\n\t\t    Channel Status: %s (%u)", tok2str(lmp_obj_channel_status_values, "Unknown", EXTRACT_32BITS(obj_tptr+offset+16)&0x3FFFFFF), EXTRACT_32BITS(obj_tptr+offset+16)&0x3FFFFFF)(ndo, "\n\t\t    Channel Status: %s (%u)", tok2str(lmp_obj_channel_status_values, "Unknown", ((uint32_t)(((uint32_t)(*((const uint8_t *)(obj_tptr+offset+16) + 0)) << 24) | ((uint32_t)(*((const uint8_t *)(obj_tptr+offset+16) + 1)) << 16) | ((uint32_t)(*((const uint8_t *)(obj_tptr+offset+16) + 2)) << 8) | ((uint32_t)(*((const uint8_t *)(obj_tptr+offset+16) + 3)) << 0)))&0x3FFFFFF), ((uint32_t)(((uint32_t)(*((const uint8_t *)(obj_tptr+offset+16) + 0)) << 24) | ((uint32_t)(*((const uint8_t *)(obj_tptr+offset+16) + 1)) << 16) | ((uint32_t)(*((const uint8_t *)(obj_tptr+offset+16) + 2)) << 8) | ((uint32_t)(*((const uint8_t *)(obj_tptr+offset+16) + 3)) << 0)))&0x3FFFFFF)(ndo, "\n\t    Interface ID: %u (0x%08x)", EXTRACT_32BITS(obj_tptr+offset), EXTRACT_32BITS(obj_tptr+offset))(ndo, "\n\t    Interface ID: %u (0x%08x)", ((uint32_t)(((uint32_t)(*((const uint8_t *)(obj_tptr+offset) + 0)) << 24) | ((uint32_t)(*((const uint8_t *)(obj_tptr+offset) + 1)) << 16) | ((uint32_t)(*((const uint8_t *)(obj_tptr+offset) + 2)) << 8) | ((uint32_t)(*((const uint8_t *)(obj_tptr+offset) + 3)) << 0))), ((uint32_t)(((uint32_t)(*((const uint8_t *)(obj_tptr+offset) + 0)) << 24) | ((uint32_t)(*((const uint8_t *)(obj_tptr+offset) + 1)) << 16) | ((uint32_t)(*((const uint8_t *)(obj_tptr+offset) + 2)) << 8) | ((uint32_t)(*((const uint8_t *)(obj_tptr+offset) + 3)) << 0))))(ndo, "\n\t    Error Code: %s", bittok2str(lmp_obj_begin_verify_error_values, "none", EXTRACT_32BITS(obj_tptr)))(ndo, "\n\t    Error Code: %s", bittok2str(lmp_obj_begin_verify_error_values, "none", ((uint32_t)(((uint32_t)(*((const uint8_t *)(obj_tptr) + 0)) << 24) | ((uint32_t)(*((const uint8_t *)(obj_tptr) + 1)) << 16) | ((uint32_t)(*((const uint8_t *)(obj_tptr) + 2)) << 8) | ((uint32_t)(*((const uint8_t *)(obj_tptr) + 3)) << 0)))))(ndo, "\n\t    Error Code: %s", bittok2str(lmp_obj_link_summary_error_values, "none", EXTRACT_32BITS(obj_tptr)))(ndo, "\n\t    Error Code: %s", bittok2str(lmp_obj_link_summary_error_values, "none", ((uint32_t)(((uint32_t)(*((const uint8_t *)(obj_tptr) + 0)) << 24) | ((uint32_t)(*((const uint8_t *)(obj_tptr) + 1)) << 16) | ((uint32_t)(*((const uint8_t *)(obj_tptr) + 2)) << 8) | ((uint32_t)(*((const uint8_t *)(obj_tptr) + 3)) << 0)))))(ndo, "\n\t Flags: %s", bittok2str(lmp_obj_service_config_sp_flag_values, "none", EXTRACT_8BITS(obj_tptr)))(ndo, "\n\t Flags: %s", bittok2str(lmp_obj_service_config_sp_flag_values, "none", (*(obj_tptr))))(ndo, "\n\t  UNI Version: %u", EXTRACT_8BITS(obj_tptr + 1))(ndo, "\n\t  UNI Version: %u", (*(obj_tptr + 1)))obj_tptr + 1(ndo, "\n\t Link Type: %s (%u)", tok2str(lmp_sd_service_config_cpsa_link_type_values, "Unknown", link_type), link_type)(ndo, "\n\t Signal Type: %s (%u)", tok2str(lmp_sd_service_config_cpsa_signal_type_sdh_values, "Unknown", EXTRACT_8BITS(obj_tptr + 1)), EXTRACT_8BITS(obj_tptr + 1))(ndo, "\n\t Signal Type: %s (%u)", tok2str(lmp_sd_service_config_cpsa_signal_type_sdh_values, "Unknown", (*(obj_tptr + 1))), (*(obj_tptr + 1)))(ndo, "\n\t Signal Type: %s (%u)", tok2str(lmp_sd_service_config_cpsa_signal_type_sonet_values, "Unknown", EXTRACT_8BITS(obj_tptr + 1)), EXTRACT_8BITS(obj_tptr + 1))(ndo, "\n\t Signal Type: %s (%u)", tok2str(lmp_sd_service_config_cpsa_signal_type_sonet_values, "Unknown", (*(obj_tptr + 1))), (*(obj_tptr + 1)))(ndo, "\n\t Transparency: %s", bittok2str(lmp_obj_service_config_cpsa_tp_flag_values, "none", EXTRACT_8BITS(obj_tptr + 2)))(ndo, "\n\t Transparency: %s", bittok2str(lmp_obj_service_config_cpsa_tp_flag_values, "none", (*(obj_tptr + 2))))obj_tptr + 2(ndo, "\n\t Contiguous Concatenation Types: %s", bittok2str(lmp_obj_service_config_cpsa_cct_flag_values, "none", EXTRACT_8BITS(obj_tptr + 3)))(ndo, "\n\t Contiguous Concatenation Types: %s", bittok2str(lmp_obj_service_config_cpsa_cct_flag_values, "none", (*(obj_tptr + 3))))obj_tptr + 3(ndo, "\n\t Minimum NCC: %u", EXTRACT_16BITS(obj_tptr+4))(ndo, "\n\t Minimum NCC: %u", ((uint16_t)(((uint16_t)(*((const uint8_t *)(obj_tptr+4) + 0)) << 8) | ((uint16_t)(*((const uint8_t *)(obj_tptr+4) + 1)) << 0))))(ndo, "\n\t Maximum NCC: %u", EXTRACT_16BITS(obj_tptr+6))(ndo, "\n\t Maximum NCC: %u", ((uint16_t)(((uint16_t)(*((const uint8_t *)(obj_tptr+6) + 0)) << 8) | ((uint16_t)(*((const uint8_t *)(obj_tptr+6) + 1)) << 0))))obj_tptr+6(ndo, "\n\t Minimum NVC:%u", EXTRACT_16BITS(obj_tptr+8))(ndo, "\n\t Minimum NVC:%u", ((uint16_t)(((uint16_t)(*((const uint8_t *)(obj_tptr+8) + 0)) << 8) | ((uint16_t)(*((const uint8_t *)(obj_tptr+8) + 1)) << 0))))(ndo, "\n\t Maximum NVC:%u", EXTRACT_16BITS(obj_tptr+10))(ndo, "\n\t Maximum NVC:%u", ((uint16_t)(((uint16_t)(*((const uint8_t *)(obj_tptr+10) + 0)) << 8) | ((uint16_t)(*((const uint8_t *)(obj_tptr+10) + 1)) << 0))))(ndo, "\n\t    Local Interface ID: %s (0x%08x)", ipaddr_string(ndo, obj_tptr+12), EXTRACT_32BITS(obj_tptr+12))(ndo, "\n\t    Local Interface ID: %s (0x%08x)", getname(ndo, (const u_char *)(obj_tptr+12)), ((uint32_t)(((uint32_t)(*((const uint8_t *)(obj_tptr+12) + 0)) << 24) | ((uint32_t)(*((const uint8_t *)(obj_tptr+12) + 1)) << 16) | ((uint32_t)(*((const uint8_t *)(obj_tptr+12) + 2)) << 8) | ((uint32_t)(*((const uint8_t *)(obj_tptr+12) + 3)) << 0))))(ndo, "\n\t Transparency Flags: %s", bittok2str( lmp_obj_service_config_nsa_transparency_flag_values, "none", EXTRACT_32BITS(obj_tptr)))(ndo, "\n\t Transparency Flags: %s", bittok2str( lmp_obj_service_config_nsa_transparency_flag_values, "none", ((uint32_t)(((uint32_t)(*((const uint8_t *)(obj_tptr) + 0)) << 24) | ((uint32_t)(*((const uint8_t *)(obj_tptr) + 1)) << 16) | ((uint32_t)(*((const uint8_t *)(obj_tptr) + 2)) << 8) | ((uint32_t)(*((const uint8_t *)(obj_tptr) + 3)) << 0)))))(ndo, "\n\t TCM Monitoring Flags: %s", bittok2str( lmp_obj_service_config_nsa_tcm_flag_values, "none", EXTRACT_8BITS(obj_tptr + 7)))(ndo, "\n\t TCM Monitoring Flags: %s", bittok2str( lmp_obj_service_config_nsa_tcm_flag_values, "none", (*(obj_tptr + 7))))obj_tptr + 7(ndo, "\n\t Diversity: Flags: %s", bittok2str( lmp_obj_service_config_nsa_network_diversity_flag_values, "none", EXTRACT_8BITS(obj_tptr + 3)))(ndo, "\n\t Diversity: Flags: %s", bittok2str( lmp_obj_service_config_nsa_network_diversity_flag_values, "none", (*(obj_tptr + 3))))
	  %s Object (%u), Class-Type: %s (%u) Flags: [%snegotiable], length: %unon- (not a multiple of 4)LMP_OBJ_CC_IDLMP_CTYPE_LOCLMP_CTYPE_RMT (not correct for object)
	    Control Channel ID: %u (0x%08x)LMP_OBJ_LINK_IDLMP_OBJ_INTERFACE_IDLMP_CTYPE_IPV4_LOCLMP_CTYPE_IPV4_RMT
	    IPv4 Link ID: %s (0x%08x)LMP_CTYPE_IPV6_LOCLMP_CTYPE_IPV6_RMT
	    IPv6 Link ID: %s (0x%08x)LMP_CTYPE_UNMD_LOCLMP_CTYPE_UNMD_RMT
	    Link ID: %u (0x%08x)LMP_OBJ_MESSAGE_IDLMP_CTYPE_1
	    Message ID: %u (0x%08x)LMP_CTYPE_2
	    Message ID Ack: %u (0x%08x)LMP_OBJ_NODE_ID
	    Node ID: %s (0x%08x)LMP_OBJ_CONFIGLMP_CTYPE_HELLO_CONFIG
	    Hello Interval: %u
	    Hello Dead Interval: %uLMP_OBJ_HELLOLMP_CTYPE_HELLO
	    Tx Seq: %u, Rx Seq: %uLMP_OBJ_TE_LINKLMP_CTYPE_IPV4
	    Flags: [%s]
	    Local Link-ID: %s (0x%08x)
	    Remote Link-ID: %s (0x%08x)char[66]LMP_CTYPE_IPV6LMP_CTYPE_UNMD
	    Local Link-ID: %u (0x%08x)
	    Remote Link-ID: %u (0x%08x)LMP_OBJ_DATA_LINK
	    Local Interface ID: %s (0x%08x)
	    Remote Interface ID: %s (0x%08x)
	    Local Interface ID: %u (0x%08x)
	    Remote Interface ID: %u (0x%08x)LMP_OBJ_VERIFY_BEGIN
	    Flags: %s
	    Verify Interval: %u
	    Data links: %u
	    Encoding type: %s
	    Verify Transport Mechanism: %u (0x%x)%s8000 (Payload test messages capable)
	    Transmission Rate: %.3f Mbps
	    Wavelength: %uLMP_OBJ_VERIFY_BEGIN_ACK
	    Verify Dead Interval: %u
	    Verify Transport Response: %uLMP_OBJ_VERIFY_ID
	    Verify ID: %uLMP_OBJ_CHANNEL_STATUS
	    Interface ID: %s (0x%08x)
		    Active: %s (%u)AllocatedNon-allocated
		    Direction: %s (%u)Transmit
		    Channel Status: %s (%u)67108863
	    Interface ID: %u (0x%08x)LMP_OBJ_CHANNEL_STATUS_REQLMP_OBJ_ERROR_CODELMP_CTYPE_BEGIN_VERIFY_ERROR
	    Error Code: %sLMP_CTYPE_LINK_SUMMARY_ERRORLMP_OBJ_SERVICE_CONFIGLMP_CTYPE_SERVICE_CONFIG_SP
	 Flags: %s
	  UNI Version: %uLMP_CTYPE_SERVICE_CONFIG_CPSA
	 Link Type: %s (%u)LMP_SD_SERVICE_CONFIG_CPSA_LINK_TYPE_SDH
	 Signal Type: %s (%u)LMP_SD_SERVICE_CONFIG_CPSA_LINK_TYPE_SONET
	 Transparency: %s
	 Contiguous Concatenation Types: %s
	 Minimum NCC: %u
	 Maximum NCC: %u
	 Minimum NVC:%u
	 Maximum NVC:%u
	    Local Interface ID: %s (0x%08x)LMP_CTYPE_SERVICE_CONFIG_TRANSPARENCY_TCM
	 Transparency Flags: %s
	 TCM Monitoring Flags: %sLMP_CTYPE_SERVICE_CONFIG_NETWORK_DIVERSITY
	 Diversity: Flags: %slmp_print_data_link_subobjssubobj_typesubobj_lenobj_tptr + offset*(obj_tptr + offset)obj_tptr + offset + 1(ndo, "\n\t    Subobject, Type: %s (%u), Length: %u", tok2str(lmp_data_link_subobj, "Unknown", subobj_type), subobj_type, subobj_len)(ndo, " (goes past the end of the object)")obj_tptr + offset + 2*(obj_tptr + offset + 2)(ndo, "\n\t      Switching Type: %s (%u)", tok2str(gmpls_switch_cap_values, "Unknown", EXTRACT_8BITS(obj_tptr + offset + 2)), EXTRACT_8BITS(obj_tptr + offset + 2))(ndo, "\n\t      Switching Type: %s (%u)", tok2str(gmpls_switch_cap_values, "Unknown", (*(obj_tptr + offset + 2))), (*(obj_tptr + offset + 2)))obj_tptr + offset + 3*(obj_tptr + offset + 3)(ndo, "\n\t      Encoding Type: %s (%u)", tok2str(gmpls_encoding_values, "Unknown", EXTRACT_8BITS(obj_tptr + offset + 3)), EXTRACT_8BITS(obj_tptr + offset + 3))(ndo, "\n\t      Encoding Type: %s (%u)", tok2str(gmpls_encoding_values, "Unknown", (*(obj_tptr + offset + 3))), (*(obj_tptr + offset + 3)))obj_tptr + offset + 4*(obj_tptr + offset + 4)(ndo, "\n\t      Min Reservable Bandwidth: %.3f Mbps", bw.f*8/1000000)obj_tptr + offset + 8*(obj_tptr + offset + 8)obj_tptr+offset+8(ndo, "\n\t      Max Reservable Bandwidth: %.3f Mbps", bw.f*8/1000000)(ndo, "\n\t      Wavelength: %u", EXTRACT_32BITS(obj_tptr+offset+4))(ndo, "\n\t      Wavelength: %u", ((uint32_t)(((uint32_t)(*((const uint8_t *)(obj_tptr+offset+4) + 0)) << 24) | ((uint32_t)(*((const uint8_t *)(obj_tptr+offset+4) + 1)) << 16) | ((uint32_t)(*((const uint8_t *)(obj_tptr+offset+4) + 2)) << 8) | ((uint32_t)(*((const uint8_t *)(obj_tptr+offset+4) + 3)) << 0))))
	    Subobject, Type: %s (%u), Length: %u (goes past the end of the object)INT_SWITCHING_TYPE_SUBOBJ
	      Switching Type: %s (%u)
	      Encoding Type: %s (%u)
	      Min Reservable Bandwidth: %.3f Mbps
	      Max Reservable Bandwidth: %.3f MbpsWAVELENGTH_SUBOBJtotal_subobj_len
	      Wavelength: %ulmp_object_headerlmp_common_headerversion_res256*LMP_OBJ_CC_ID256*LMP_OBJ_CC_ID+LMP_CTYPE_LOC256*LMP_OBJ_CC_ID+LMP_CTYPE_RMTRemote"Remote"256*LMP_OBJ_NODE_ID256*LMP_OBJ_NODE_ID+LMP_CTYPE_LOC256*LMP_OBJ_NODE_ID+LMP_CTYPE_RMT256*LMP_OBJ_LINK_ID256*LMP_OBJ_LINK_ID+LMP_CTYPE_IPV4_LOCIPv4 Local"IPv4 Local"256*LMP_OBJ_LINK_ID+LMP_CTYPE_IPV4_RMTIPv4 Remote"IPv4 Remote"256*LMP_OBJ_LINK_ID+LMP_CTYPE_IPV6_LOCIPv6 Local"IPv6 Local"256*LMP_OBJ_LINK_ID+LMP_CTYPE_IPV6_RMTIPv6 Remote"IPv6 Remote"773256*LMP_OBJ_LINK_ID+LMP_CTYPE_UNMD_LOCUnnumbered Local"Unnumbered Local"256*LMP_OBJ_LINK_ID+LMP_CTYPE_UNMD_RMTUnnumbered Remote"Unnumbered Remote"256*LMP_OBJ_INTERFACE_ID256*LMP_OBJ_INTERFACE_ID+LMP_CTYPE_IPV4_LOC256*LMP_OBJ_INTERFACE_ID+LMP_CTYPE_IPV4_RMT256*LMP_OBJ_INTERFACE_ID+LMP_CTYPE_IPV6_LOC256*LMP_OBJ_INTERFACE_ID+LMP_CTYPE_IPV6_RMT1029256*LMP_OBJ_INTERFACE_ID+LMP_CTYPE_UNMD_LOC1030256*LMP_OBJ_INTERFACE_ID+LMP_CTYPE_UNMD_RMT256*LMP_OBJ_MESSAGE_ID256*LMP_OBJ_MESSAGE_ID+LMP_CTYPE_1"1"256*LMP_OBJ_MESSAGE_ID+LMP_CTYPE_2"2"256*LMP_OBJ_CONFIG256*LMP_OBJ_CONFIG+LMP_CTYPE_1256*LMP_OBJ_HELLO1793256*LMP_OBJ_HELLO+LMP_CTYPE_1256*LMP_OBJ_VERIFY_BEGIN256*LMP_OBJ_VERIFY_BEGIN+LMP_CTYPE_12304256*LMP_OBJ_VERIFY_BEGIN_ACK2305256*LMP_OBJ_VERIFY_BEGIN_ACK+LMP_CTYPE_1256*LMP_OBJ_VERIFY_ID2561256*LMP_OBJ_VERIFY_ID+LMP_CTYPE_12816256*LMP_OBJ_TE_LINK2817256*LMP_OBJ_TE_LINK+LMP_CTYPE_IPV42818256*LMP_OBJ_TE_LINK+LMP_CTYPE_IPV62819256*LMP_OBJ_TE_LINK+LMP_CTYPE_UNMDUnnumbered"Unnumbered"3072256*LMP_OBJ_DATA_LINK3073256*LMP_OBJ_DATA_LINK+LMP_CTYPE_IPV43074256*LMP_OBJ_DATA_LINK+LMP_CTYPE_IPV63075256*LMP_OBJ_DATA_LINK+LMP_CTYPE_UNMD3328256*LMP_OBJ_CHANNEL_STATUS3329256*LMP_OBJ_CHANNEL_STATUS+LMP_CTYPE_IPV43330256*LMP_OBJ_CHANNEL_STATUS+LMP_CTYPE_IPV63331256*LMP_OBJ_CHANNEL_STATUS+LMP_CTYPE_UNMD256*LMP_OBJ_CHANNEL_STATUS_REQ3585256*LMP_OBJ_CHANNEL_STATUS_REQ+LMP_CTYPE_IPV43586256*LMP_OBJ_CHANNEL_STATUS_REQ+LMP_CTYPE_IPV63587256*LMP_OBJ_CHANNEL_STATUS_REQ+LMP_CTYPE_UNMD5120256*LMP_OBJ_ERROR_CODE5121256*LMP_OBJ_ERROR_CODE+LMP_CTYPE_15122256*LMP_OBJ_ERROR_CODE+LMP_CTYPE_213056256*LMP_OBJ_SERVICE_CONFIG13057256*LMP_OBJ_SERVICE_CONFIG+LMP_CTYPE_SERVICE_CONFIG_SP13058256*LMP_OBJ_SERVICE_CONFIG+LMP_CTYPE_SERVICE_CONFIG_CPSA13059256*LMP_OBJ_SERVICE_CONFIG+LMP_CTYPE_SERVICE_CONFIG_TRANSPARENCY_TCM"3"13060256*LMP_OBJ_SERVICE_CONFIG+LMP_CTYPE_SERVICE_CONFIG_NETWORK_DIVERSITY"4"lmp_ctype_valuesInterface Switching Type"Interface Switching Type"Wavelength"Wavelength"lmp_data_link_subobjControl Channel ID"Control Channel ID"Node ID"Node ID"Interface ID"Interface ID"Message ID"Message ID"Configuration"Configuration"Verify Begin"Verify Begin"Verify Begin ACK"Verify Begin ACK"Verify ID"Verify ID"TE Link"TE Link"Data Link"Data Link"Channel Status"Channel Status"Channel Status Request"Channel Status Request"Error Code"Error Code"Service Config"Service Config"lmp_obj_valuesLMP_MSGTYPE_CONFIGLMP_MSGTYPE_CONFIG_ACKConfig ACK"Config ACK"LMP_MSGTYPE_CONFIG_NACKConfig NACK"Config NACK"LMP_MSGTYPE_HELLOLMP_MSGTYPE_VERIFY_BEGINBegin Verify"Begin Verify"LMP_MSGTYPE_VERIFY_BEGIN_ACKBegin Verify ACK"Begin Verify ACK"LMP_MSGTYPE_VERIFY_BEGIN_NACKBegin Verify NACK"Begin Verify NACK"LMP_MSGTYPE_VERIFY_ENDEnd Verify"End Verify"LMP_MSGTYPE_VERIFY_END_ACKEnd Verify ACK"End Verify ACK"LMP_MSGTYPE_TESTTest"Test"LMP_MSGTYPE_TEST_STATUS_SUCCESSTest Status Success"Test Status Success"LMP_MSGTYPE_TEST_STATUS_FAILURETest Status Failure"Test Status Failure"LMP_MSGTYPE_TEST_STATUS_ACKTest Status ACK"Test Status ACK"LMP_MSGTYPE_LINK_SUMMARYLink Summary"Link Summary"LMP_MSGTYPE_LINK_SUMMARY_ACKLink Summary ACK"Link Summary ACK"LMP_MSGTYPE_LINK_SUMMARY_NACKLink Summary NACK"Link Summary NACK"LMP_MSGTYPE_CHANNEL_STATUSLMP_MSGTYPE_CHANNEL_STATUS_ACKChannel Status ACK"Channel Status ACK"LMP_MSGTYPE_CHANNEL_STATUS_REQLMP_MSGTYPE_CHANNEL_STATUS_RESPChannel Status Response"Channel Status Response"LMP_MSGTYPE_SERVICE_CONFIGLMP_MSGTYPE_SERVICE_CONFIG_ACKService Config ACK"Service Config ACK"LMP_MSGTYPE_SERVICE_CONFIG_NACKService Config NACK"Service Config NACK"lmp_msg_type_valuesNode Diversity Supported"Node Diversity Supported"Link Diversity Supported"Link Diversity Supported"SRLG Diversity Supported"SRLG Diversity Supported"lmp_obj_service_config_nsa_network_diversity_flag_valuesTransparent Tandem Connection Monitoring Supported"Transparent Tandem Connection Monitoring Supported"lmp_obj_service_config_nsa_tcm_flag_valuesStandard SOH/RSOH Transparency Supported"Standard SOH/RSOH Transparency Supported"Standard LOH/MSOH Transparency Supported"Standard LOH/MSOH Transparency Supported"lmp_obj_service_config_nsa_transparency_flag_valuesContiguous Concatenation Types Supported"Contiguous Concatenation Types Supported"lmp_obj_service_config_cpsa_cct_flag_valuesPath/VC Overhead Transparency Supported"Path/VC Overhead Transparency Supported"Line/MS Overhead Transparency Supported"Line/MS Overhead Transparency Supported"Section/RS Overhead Transparency Supported"Section/RS Overhead Transparency Supported"lmp_obj_service_config_cpsa_tp_flag_valuesRSVP Supported"RSVP Supported"LDP Supported"LDP Supported"lmp_obj_service_config_sp_flag_valuesUnacceptable non-negotiable LINK-SUMMARY parameters"Unacceptable non-negotiable LINK-SUMMARY parameters"Renegotiate LINK-SUMMARY parameters"Renegotiate LINK-SUMMARY parameters"Invalid TE-LINK Object"Invalid TE-LINK Object"Invalid DATA-LINK Object"Invalid DATA-LINK Object"Unknown TE-LINK Object c-type"Unknown TE-LINK Object c-type"Unknown DATA-LINK Object c-type"Unknown DATA-LINK Object c-type"lmp_obj_link_summary_error_valuesLink Verification Procedure Not supported"Link Verification Procedure Not supported"Unwilling to verify"Unwilling to verify"Unsupported verification transport mechanism"Unsupported verification transport mechanism"Link-Id configuration error"Link-Id configuration error"Unknown object c-type"Unknown object c-type"lmp_obj_begin_verify_error_valuesVerify all links"Verify all links"Data link type"Data link type"lmp_obj_begin_verify_flag_valuesSignal Okay"Signal Okay"Signal Degraded"Signal Degraded"Signal Fail"Signal Fail"lmp_obj_channel_status_valuesData Link Port"Data Link Port"Allocated for user traffic"Allocated for user traffic"Failed link"Failed link"lmp_obj_data_link_flag_valuesFault Management Supported"Fault Management Supported"Link Verification Supported"Link Verification Supported"lmp_obj_te_link_flag_valuesControl Channel Down"Control Channel Down"LMP restart"LMP restart"lmp_header_flag_values [|LMP]" [|LMP]"LMP_EXTRACT_VERSION(x)/* Decode pairs: <Interface_ID (4 bytes), Channel_status (4 bytes)> *//* Decode pairs: <Interface_ID (16 bytes), Channel_status (4 bytes)> *//* int to float conversion buffer *//* Any Unknown Subobject ==> Exit loop *//*
 * the ctypes are not globally unique so for
 * translating it to strings we build a table based
 * on objects offsetted by the ctype
 *//* UNI 1.0 Sec 9.4.2 *//*
 * Different link types allowed in the Client Port Service Attributes
 * subobject defined for LMP Service Discovery in the UNI 1.0 spec
 *//* C-Types for Service Config Object *//* defined in UNI 1.0 *//*
 * LMP object header
 *
 *  0                   1                   2                   3
 *  0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
 * +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
 * |N|   C-Type    |     Class     |            Length             |
 * +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
 * |                                                               |
 * //                       (object contents)                     //
 * |                                                               |
 * +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
 *//* LMP Service Discovery message types defined by UNI 1.0 *//* Network Service Attributes Network Diversity Flags *//* Service Config Network Service Attributes TCM Monitoring Flags *//* Service Config Network Service Attributes Transparency Flags *//* Service Config Client Port Service Attribute Contiguous Concatenation Types Flags *//* Service Config Client Port Service Attribute Transparency Flags *//* Service Config Supported Protocols Flags *//*
 * LMP common header
 *
 *  0                   1                   2                   3
 *  0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
 * +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
 * | Vers  |      (Reserved)       |    Flags      |    Msg Type   |
 * +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
 * |          LMP Length           |          (Reserved)           |
 * +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
 *//* OIF UNI 1.0: http://www.oiforum.com/public/documents/OIF-UNI-01.0.pdf *//* specification: RFC 4204 *//* \summary: Link Management Protocol (LMP) printer *//*
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that: (1) source code
 * distributions retain the above copyright notice and this paragraph
 * in its entirety, and (2) distributions including binary code include
 * the above copyright notice and this paragraph in its entirety in
 * the documentation or other materials provided with the distribution.
 * THIS SOFTWARE IS PROVIDED ``AS IS'' AND
 * WITHOUT ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, WITHOUT
 * LIMITATION, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS
 * FOR A PARTICULAR PURPOSE.
 *
 * Original code by Hannes Gredler (hannes@gredler.at)
 * Support for LMP service discovery extensions (defined by OIF UNI 1.0)
 * added by Manu Pathak (mapathak@cisco.com), May 2005
 *//Users/owura/Repos/codeql_eval/proj_repos/the-tcpdump-group-tcpdump-commit-9ba91381954ad325ea4fd26b9c65a8bd9a2a85b6/tcpdump/print-loopback.cloopback_printskipCount(ndo, "Loopback")(ndo, ", skipCount %u", skipCount), skipCount %uloopback_message_printfunction(ndo, ", %s", tok2str(fcode_str, " invalid (%u)", function)) invalid (%u)(ndo, ", receipt number %u", EXTRACT_LE_16BITS(cp))(ndo, ", receipt number %u", ((uint16_t)(((uint16_t)(*((const uint8_t *)(cp) + 1)) << 8) | ((uint16_t)(*((const uint8_t *)(cp) + 0)) << 0))))(ndo, ", data (%u octets)", len - 4)len - 4(ndo, ", forwarding address %s", etheraddr_string(ndo, cp))(ndo, ", data (%u octets)", len - 8)len - 8len - 2LOOPBACK_REPLY, receipt number %u, data (%u octets)LOOPBACK_FWDDATA, forwarding address %sForward Data"Forward Data"fcode_str [|loopback]" [|loopback]"/* skipCount *//* forwarding address *//* receipt number *//* function *//*
 * originally defined as the Ethernet Configuration Testing Protocol.
 * specification: http://www.mit.edu/people/jhawk/ctp.pdf
 *//* \summary: Loopback Protocol printer *//Users/owura/Repos/codeql_eval/proj_repos/the-tcpdump-group-tcpdump-commit-9ba91381954ad325ea4fd26b9c65a8bd9a2a85b6/tcpdump/print-lspping.clspping_printconst lspping_common_headerconst lspping_common_header *lspping_common_header *lspping_com_headerconst lspping_tlv_headerconst lspping_tlv_header *lspping_tlv_header *lspping_tlv_headerlspping_subtlv_headersubtlv_tptrlspping_tlv_lenlspping_tlv_typetlv_hexdumpsubtlv_hexdumplspping_subtlv_lenlspping_subtlv_typesubtlv_ptrsizeof(const struct lspping_common_header)*lspping_com_headersizeof(*lspping_com_header)&lspping_com_header->version[0](ndo, "LSP-PING version %u packet not supported", EXTRACT_16BITS(&lspping_com_header->version[0]))(ndo, "LSP-PING version %u packet not supported", ((uint16_t)(((uint16_t)(*((const uint8_t *)(&lspping_com_header->version[0]) + 0)) << 8) | ((uint16_t)(*((const uint8_t *)(&lspping_com_header->version[0]) + 1)) << 0))))LSPPING_VERSIONLSP-PING version %u packet not supported(ndo, "LSP-PINGv%u, %s, seq %u, length: %u", EXTRACT_16BITS(&lspping_com_header->version[0]), tok2str(lspping_msg_type_values, "unknown (%u)",lspping_com_header->msg_type), EXTRACT_32BITS(lspping_com_header->seq_number), len)(ndo, "LSP-PINGv%u, %s, seq %u, length: %u", ((uint16_t)(((uint16_t)(*((const uint8_t *)(&lspping_com_header->version[0]) + 0)) << 8) | ((uint16_t)(*((const uint8_t *)(&lspping_com_header->version[0]) + 1)) << 0))), tok2str(lspping_msg_type_values, "unknown (%u)",lspping_com_header->msg_type), ((uint32_t)(((uint32_t)(*((const uint8_t *)(lspping_com_header->seq_number) + 0)) << 24) | ((uint32_t)(*((const uint8_t *)(lspping_com_header->seq_number) + 1)) << 16) | ((uint32_t)(*((const uint8_t *)(lspping_com_header->seq_number) + 2)) << 8) | ((uint32_t)(*((const uint8_t *)(lspping_com_header->seq_number) + 3)) << 0))), len)lspping_com_header->seq_numberLSP-PINGv%u, %s, seq %u, length: %u(ndo, "\n\tLSP-PINGv%u, msg-type: %s (%u), length: %u\n\t  reply-mode: %s (%u)", EXTRACT_16BITS(&lspping_com_header->version[0]), tok2str(lspping_msg_type_values, "unknown",lspping_com_header->msg_type), lspping_com_header->msg_type, len, tok2str(lspping_reply_mode_values, "unknown",lspping_com_header->reply_mode), lspping_com_header->reply_mode)(ndo, "\n\tLSP-PINGv%u, msg-type: %s (%u), length: %u\n\t  reply-mode: %s (%u)", ((uint16_t)(((uint16_t)(*((const uint8_t *)(&lspping_com_header->version[0]) + 0)) << 8) | ((uint16_t)(*((const uint8_t *)(&lspping_com_header->version[0]) + 1)) << 0))), tok2str(lspping_msg_type_values, "unknown",lspping_com_header->msg_type), lspping_com_header->msg_type, len, tok2str(lspping_reply_mode_values, "unknown",lspping_com_header->reply_mode), lspping_com_header->reply_mode)
	LSP-PINGv%u, msg-type: %s (%u), length: %u
	  reply-mode: %s (%u)(ndo, "\n\t  Return Code: %s %u (%u)\n\t  Return Subcode: (%u)", tok2str(lspping_return_code_values, "unknown",lspping_com_header->return_code), lspping_com_header->return_subcode, lspping_com_header->return_code, lspping_com_header->return_subcode)(ndo, "\n\t  Return Code: %s (%u)\n\t  Return Subcode: (%u)", tok2str(lspping_return_code_values, "unknown",lspping_com_header->return_code), lspping_com_header->return_code, lspping_com_header->return_subcode)
	  Return Code: %s %u (%u)
	  Return Subcode: (%u)
	  Return Code: %s (%u)
	  Return Subcode: (%u)(ndo, "\n\t  Sender Handle: 0x%08x, Sequence: %u", EXTRACT_32BITS(lspping_com_header->sender_handle), EXTRACT_32BITS(lspping_com_header->seq_number))(ndo, "\n\t  Sender Handle: 0x%08x, Sequence: %u", ((uint32_t)(((uint32_t)(*((const uint8_t *)(lspping_com_header->sender_handle) + 0)) << 24) | ((uint32_t)(*((const uint8_t *)(lspping_com_header->sender_handle) + 1)) << 16) | ((uint32_t)(*((const uint8_t *)(lspping_com_header->sender_handle) + 2)) << 8) | ((uint32_t)(*((const uint8_t *)(lspping_com_header->sender_handle) + 3)) << 0))), ((uint32_t)(((uint32_t)(*((const uint8_t *)(lspping_com_header->seq_number) + 0)) << 24) | ((uint32_t)(*((const uint8_t *)(lspping_com_header->seq_number) + 1)) << 16) | ((uint32_t)(*((const uint8_t *)(lspping_com_header->seq_number) + 2)) << 8) | ((uint32_t)(*((const uint8_t *)(lspping_com_header->seq_number) + 3)) << 0))))
	  Sender Handle: 0x%08x, Sequence: %ulspping_com_header->sender_handlelspping_com_header->ts_sent_seclspping_com_header->ts_sent_usec(ndo, "\n\t  Sender Timestamp: ")
	  Sender Timestamp: lspping_com_header->ts_rcvd_seclspping_com_header->ts_rcvd_usec(ndo, "Receiver Timestamp: ")Receiver Timestamp: (ndo, "no timestamp")no timestampsizeof(struct lspping_tlv_header)lspping_tlv_header->typelspping_tlv_header->length(ndo, "\n\t  %s TLV (%u), length: %u", tok2str(lspping_tlv_values, "Unknown", lspping_tlv_type), lspping_tlv_type, lspping_tlv_len)*tlv_tptr(ndo, "\n\t      TLV is too short")lspping_subtlv_header->typelspping_subtlv_header->length*subtlv_tptr(ndo, "\n\t    %s subTLV (%u), length: %u", tok2str(lspping_tlvtargetfec_subtlv_values, "Unknown", lspping_subtlv_type), lspping_subtlv_type, lspping_subtlv_len)(ndo, "\n\t      invalid subTLV length, should be 5")(ndo, "\n\t      %s/%u", ipaddr_string(ndo, subtlv_ptr.lspping_tlv_targetfec_subtlv_ldp_ipv4->prefix), subtlv_ptr.lspping_tlv_targetfec_subtlv_ldp_ipv4->prefix_len)(ndo, "\n\t      %s/%u", getname(ndo, (const u_char *)(subtlv_ptr.lspping_tlv_targetfec_subtlv_ldp_ipv4->prefix)), subtlv_ptr.lspping_tlv_targetfec_subtlv_ldp_ipv4->prefix_len)subtlv_ptr.lspping_tlv_targetfec_subtlv_ldp_ipv4->prefix(ndo, "\n\t      invalid subTLV length, should be 17")(ndo, "\n\t      %s/%u", ip6addr_string(ndo, subtlv_ptr.lspping_tlv_targetfec_subtlv_ldp_ipv6->prefix), subtlv_ptr.lspping_tlv_targetfec_subtlv_ldp_ipv6->prefix_len)(ndo, "\n\t      %s/%u", getname6(ndo, (const u_char *)(subtlv_ptr.lspping_tlv_targetfec_subtlv_ldp_ipv6->prefix)), subtlv_ptr.lspping_tlv_targetfec_subtlv_ldp_ipv6->prefix_len)subtlv_ptr.lspping_tlv_targetfec_subtlv_ldp_ipv6->prefix(ndo, "\n\t      %s/%u", ipaddr_string(ndo, subtlv_ptr.lspping_tlv_targetfec_subtlv_bgp_ipv4->prefix), subtlv_ptr.lspping_tlv_targetfec_subtlv_bgp_ipv4->prefix_len)(ndo, "\n\t      %s/%u", getname(ndo, (const u_char *)(subtlv_ptr.lspping_tlv_targetfec_subtlv_bgp_ipv4->prefix)), subtlv_ptr.lspping_tlv_targetfec_subtlv_bgp_ipv4->prefix_len)subtlv_ptr.lspping_tlv_targetfec_subtlv_bgp_ipv4->prefix(ndo, "\n\t      %s/%u", ip6addr_string(ndo, subtlv_ptr.lspping_tlv_targetfec_subtlv_bgp_ipv6->prefix), subtlv_ptr.lspping_tlv_targetfec_subtlv_bgp_ipv6->prefix_len)(ndo, "\n\t      %s/%u", getname6(ndo, (const u_char *)(subtlv_ptr.lspping_tlv_targetfec_subtlv_bgp_ipv6->prefix)), subtlv_ptr.lspping_tlv_targetfec_subtlv_bgp_ipv6->prefix_len)subtlv_ptr.lspping_tlv_targetfec_subtlv_bgp_ipv6->prefix(ndo, "\n\t      invalid subTLV length, should be 20")(ndo, "\n\t      tunnel end-point %s, tunnel sender %s, lsp-id 0x%04x" "\n\t      tunnel-id 0x%04x, extended tunnel-id %s", ipaddr_string(ndo, subtlv_ptr.lspping_tlv_targetfec_subtlv_rsvp_ipv4->tunnel_endpoint), ipaddr_string(ndo, subtlv_ptr.lspping_tlv_targetfec_subtlv_rsvp_ipv4->tunnel_sender), EXTRACT_16BITS(subtlv_ptr.lspping_tlv_targetfec_subtlv_rsvp_ipv4->lsp_id), EXTRACT_16BITS(subtlv_ptr.lspping_tlv_targetfec_subtlv_rsvp_ipv4->tunnel_id), ipaddr_string(ndo, subtlv_ptr.lspping_tlv_targetfec_subtlv_rsvp_ipv4->extended_tunnel_id))(ndo, "\n\t      tunnel end-point %s, tunnel sender %s, lsp-id 0x%04x" "\n\t      tunnel-id 0x%04x, extended tunnel-id %s", getname(ndo, (const u_char *)(subtlv_ptr.lspping_tlv_targetfec_subtlv_rsvp_ipv4->tunnel_endpoint)), getname(ndo, (const u_char *)(subtlv_ptr.lspping_tlv_targetfec_subtlv_rsvp_ipv4->tunnel_sender)), ((uint16_t)(((uint16_t)(*((const uint8_t *)(subtlv_ptr.lspping_tlv_targetfec_subtlv_rsvp_ipv4->lsp_id) + 0)) << 8) | ((uint16_t)(*((const uint8_t *)(subtlv_ptr.lspping_tlv_targetfec_subtlv_rsvp_ipv4->lsp_id) + 1)) << 0))), ((uint16_t)(((uint16_t)(*((const uint8_t *)(subtlv_ptr.lspping_tlv_targetfec_subtlv_rsvp_ipv4->tunnel_id) + 0)) << 8) | ((uint16_t)(*((const uint8_t *)(subtlv_ptr.lspping_tlv_targetfec_subtlv_rsvp_ipv4->tunnel_id) + 1)) << 0))), getname(ndo, (const u_char *)(subtlv_ptr.lspping_tlv_targetfec_subtlv_rsvp_ipv4->extended_tunnel_id)))subtlv_ptr.lspping_tlv_targetfec_subtlv_rsvp_ipv4->tunnel_endpointsubtlv_ptr.lspping_tlv_targetfec_subtlv_rsvp_ipv4->tunnel_sendersubtlv_ptr.lspping_tlv_targetfec_subtlv_rsvp_ipv4->lsp_idsubtlv_ptr.lspping_tlv_targetfec_subtlv_rsvp_ipv4->tunnel_idsubtlv_ptr.lspping_tlv_targetfec_subtlv_rsvp_ipv4->extended_tunnel_id(ndo, "\n\t      invalid subTLV length, should be 56")(ndo, "\n\t      tunnel end-point %s, tunnel sender %s, lsp-id 0x%04x" "\n\t      tunnel-id 0x%04x, extended tunnel-id %s", ip6addr_string(ndo, subtlv_ptr.lspping_tlv_targetfec_subtlv_rsvp_ipv6->tunnel_endpoint), ip6addr_string(ndo, subtlv_ptr.lspping_tlv_targetfec_subtlv_rsvp_ipv6->tunnel_sender), EXTRACT_16BITS(subtlv_ptr.lspping_tlv_targetfec_subtlv_rsvp_ipv6->lsp_id), EXTRACT_16BITS(subtlv_ptr.lspping_tlv_targetfec_subtlv_rsvp_ipv6->tunnel_id), ip6addr_string(ndo, subtlv_ptr.lspping_tlv_targetfec_subtlv_rsvp_ipv6->extended_tunnel_id))(ndo, "\n\t      tunnel end-point %s, tunnel sender %s, lsp-id 0x%04x" "\n\t      tunnel-id 0x%04x, extended tunnel-id %s", getname6(ndo, (const u_char *)(subtlv_ptr.lspping_tlv_targetfec_subtlv_rsvp_ipv6->tunnel_endpoint)), getname6(ndo, (const u_char *)(subtlv_ptr.lspping_tlv_targetfec_subtlv_rsvp_ipv6->tunnel_sender)), ((uint16_t)(((uint16_t)(*((const uint8_t *)(subtlv_ptr.lspping_tlv_targetfec_subtlv_rsvp_ipv6->lsp_id) + 0)) << 8) | ((uint16_t)(*((const uint8_t *)(subtlv_ptr.lspping_tlv_targetfec_subtlv_rsvp_ipv6->lsp_id) + 1)) << 0))), ((uint16_t)(((uint16_t)(*((const uint8_t *)(subtlv_ptr.lspping_tlv_targetfec_subtlv_rsvp_ipv6->tunnel_id) + 0)) << 8) | ((uint16_t)(*((const uint8_t *)(subtlv_ptr.lspping_tlv_targetfec_subtlv_rsvp_ipv6->tunnel_id) + 1)) << 0))), getname6(ndo, (const u_char *)(subtlv_ptr.lspping_tlv_targetfec_subtlv_rsvp_ipv6->extended_tunnel_id)))subtlv_ptr.lspping_tlv_targetfec_subtlv_rsvp_ipv6->tunnel_endpointsubtlv_ptr.lspping_tlv_targetfec_subtlv_rsvp_ipv6->tunnel_sendersubtlv_ptr.lspping_tlv_targetfec_subtlv_rsvp_ipv6->lsp_idsubtlv_ptr.lspping_tlv_targetfec_subtlv_rsvp_ipv6->tunnel_idsubtlv_ptr.lspping_tlv_targetfec_subtlv_rsvp_ipv6->extended_tunnel_id(ndo, "\n\t      invalid subTLV length, should be 13")(ndo, "\n\t      RD: %s, %s/%u", bgp_vpn_rd_print(ndo, subtlv_ptr.lspping_tlv_targetfec_subtlv_l3vpn_ipv4->rd), ipaddr_string(ndo, subtlv_ptr.lspping_tlv_targetfec_subtlv_l3vpn_ipv4->prefix), subtlv_ptr.lspping_tlv_targetfec_subtlv_l3vpn_ipv4->prefix_len)(ndo, "\n\t      RD: %s, %s/%u", bgp_vpn_rd_print(ndo, subtlv_ptr.lspping_tlv_targetfec_subtlv_l3vpn_ipv4->rd), getname(ndo, (const u_char *)(subtlv_ptr.lspping_tlv_targetfec_subtlv_l3vpn_ipv4->prefix)), subtlv_ptr.lspping_tlv_targetfec_subtlv_l3vpn_ipv4->prefix_len)subtlv_ptr.lspping_tlv_targetfec_subtlv_l3vpn_ipv4->prefix(ndo, "\n\t      invalid subTLV length, should be 25")(ndo, "\n\t      RD: %s, %s/%u", bgp_vpn_rd_print(ndo, subtlv_ptr.lspping_tlv_targetfec_subtlv_l3vpn_ipv6->rd), ip6addr_string(ndo, subtlv_ptr.lspping_tlv_targetfec_subtlv_l3vpn_ipv6->prefix), subtlv_ptr.lspping_tlv_targetfec_subtlv_l3vpn_ipv6->prefix_len)(ndo, "\n\t      RD: %s, %s/%u", bgp_vpn_rd_print(ndo, subtlv_ptr.lspping_tlv_targetfec_subtlv_l3vpn_ipv6->rd), getname6(ndo, (const u_char *)(subtlv_ptr.lspping_tlv_targetfec_subtlv_l3vpn_ipv6->prefix)), subtlv_ptr.lspping_tlv_targetfec_subtlv_l3vpn_ipv6->prefix_len)subtlv_ptr.lspping_tlv_targetfec_subtlv_l3vpn_ipv6->prefix(ndo, "\n\t      invalid subTLV length, should be 14")(ndo, "\n\t      RD: %s, Sender VE ID: %u, Receiver VE ID: %u" "\n\t      Encapsulation Type: %s (%u)", bgp_vpn_rd_print(ndo, subtlv_ptr.lspping_tlv_targetfec_subtlv_l2vpn_endpt->rd), EXTRACT_16BITS(subtlv_ptr.lspping_tlv_targetfec_subtlv_l2vpn_endpt->sender_ve_id), EXTRACT_16BITS(subtlv_ptr.lspping_tlv_targetfec_subtlv_l2vpn_endpt->receiver_ve_id), tok2str(mpls_pw_types_values, "unknown", EXTRACT_16BITS(subtlv_ptr.lspping_tlv_targetfec_subtlv_l2vpn_endpt->encapsulation)), EXTRACT_16BITS(subtlv_ptr.lspping_tlv_targetfec_subtlv_l2vpn_endpt->encapsulation))(ndo, "\n\t      RD: %s, Sender VE ID: %u, Receiver VE ID: %u" "\n\t      Encapsulation Type: %s (%u)", bgp_vpn_rd_print(ndo, subtlv_ptr.lspping_tlv_targetfec_subtlv_l2vpn_endpt->rd), ((uint16_t)(((uint16_t)(*((const uint8_t *)(subtlv_ptr.lspping_tlv_targetfec_subtlv_l2vpn_endpt->sender_ve_id) + 0)) << 8) | ((uint16_t)(*((const uint8_t *)(subtlv_ptr.lspping_tlv_targetfec_subtlv_l2vpn_endpt->sender_ve_id) + 1)) << 0))), ((uint16_t)(((uint16_t)(*((const uint8_t *)(subtlv_ptr.lspping_tlv_targetfec_subtlv_l2vpn_endpt->receiver_ve_id) + 0)) << 8) | ((uint16_t)(*((const uint8_t *)(subtlv_ptr.lspping_tlv_targetfec_subtlv_l2vpn_endpt->receiver_ve_id) + 1)) << 0))), tok2str(mpls_pw_types_values, "unknown", ((uint16_t)(((uint16_t)(*((const uint8_t *)(subtlv_ptr.lspping_tlv_targetfec_subtlv_l2vpn_endpt->encapsulation) + 0)) << 8) | ((uint16_t)(*((const uint8_t *)(subtlv_ptr.lspping_tlv_targetfec_subtlv_l2vpn_endpt->encapsulation) + 1)) << 0)))), ((uint16_t)(((uint16_t)(*((const uint8_t *)(subtlv_ptr.lspping_tlv_targetfec_subtlv_l2vpn_endpt->encapsulation) + 0)) << 8) | ((uint16_t)(*((const uint8_t *)(subtlv_ptr.lspping_tlv_targetfec_subtlv_l2vpn_endpt->encapsulation) + 1)) << 0))))subtlv_ptr.lspping_tlv_targetfec_subtlv_l2vpn_endpt->sender_ve_idsubtlv_ptr.lspping_tlv_targetfec_subtlv_l2vpn_endpt->receiver_ve_idsubtlv_ptr.lspping_tlv_targetfec_subtlv_l2vpn_endpt->encapsulation(ndo, "\n\t      invalid subTLV length, should be 10")(ndo, "\n\t      Remote PE: %s" "\n\t      PW ID: 0x%08x, PW Type: %s (%u)", ipaddr_string(ndo, subtlv_ptr.lspping_tlv_targetfec_subtlv_l2vpn_vcid_old->remote_pe_address), EXTRACT_32BITS(subtlv_ptr.lspping_tlv_targetfec_subtlv_l2vpn_vcid_old->pw_id), tok2str(mpls_pw_types_values, "unknown", EXTRACT_16BITS(subtlv_ptr.lspping_tlv_targetfec_subtlv_l2vpn_vcid_old->pw_type)), EXTRACT_16BITS(subtlv_ptr.lspping_tlv_targetfec_subtlv_l2vpn_vcid_old->pw_type))(ndo, "\n\t      Remote PE: %s" "\n\t      PW ID: 0x%08x, PW Type: %s (%u)", getname(ndo, (const u_char *)(subtlv_ptr.lspping_tlv_targetfec_subtlv_l2vpn_vcid_old->remote_pe_address)), ((uint32_t)(((uint32_t)(*((const uint8_t *)(subtlv_ptr.lspping_tlv_targetfec_subtlv_l2vpn_vcid_old->pw_id) + 0)) << 24) | ((uint32_t)(*((const uint8_t *)(subtlv_ptr.lspping_tlv_targetfec_subtlv_l2vpn_vcid_old->pw_id) + 1)) << 16) | ((uint32_t)(*((const uint8_t *)(subtlv_ptr.lspping_tlv_targetfec_subtlv_l2vpn_vcid_old->pw_id) + 2)) << 8) | ((uint32_t)(*((const uint8_t *)(subtlv_ptr.lspping_tlv_targetfec_subtlv_l2vpn_vcid_old->pw_id) + 3)) << 0))), tok2str(mpls_pw_types_values, "unknown", ((uint16_t)(((uint16_t)(*((const uint8_t *)(subtlv_ptr.lspping_tlv_targetfec_subtlv_l2vpn_vcid_old->pw_type) + 0)) << 8) | ((uint16_t)(*((const uint8_t *)(subtlv_ptr.lspping_tlv_targetfec_subtlv_l2vpn_vcid_old->pw_type) + 1)) << 0)))), ((uint16_t)(((uint16_t)(*((const uint8_t *)(subtlv_ptr.lspping_tlv_targetfec_subtlv_l2vpn_vcid_old->pw_type) + 0)) << 8) | ((uint16_t)(*((const uint8_t *)(subtlv_ptr.lspping_tlv_targetfec_subtlv_l2vpn_vcid_old->pw_type) + 1)) << 0))))subtlv_ptr.lspping_tlv_targetfec_subtlv_l2vpn_vcid_old->remote_pe_addresssubtlv_ptr.lspping_tlv_targetfec_subtlv_l2vpn_vcid_old->pw_idsubtlv_ptr.lspping_tlv_targetfec_subtlv_l2vpn_vcid_old->pw_type(ndo, "\n\t      Sender PE: %s, Remote PE: %s" "\n\t      PW ID: 0x%08x, PW Type: %s (%u)", ipaddr_string(ndo, subtlv_ptr.lspping_tlv_targetfec_subtlv_l2vpn_vcid->sender_pe_address), ipaddr_string(ndo, subtlv_ptr.lspping_tlv_targetfec_subtlv_l2vpn_vcid->remote_pe_address), EXTRACT_32BITS(subtlv_ptr.lspping_tlv_targetfec_subtlv_l2vpn_vcid->pw_id), tok2str(mpls_pw_types_values, "unknown", EXTRACT_16BITS(subtlv_ptr.lspping_tlv_targetfec_subtlv_l2vpn_vcid->pw_type)), EXTRACT_16BITS(subtlv_ptr.lspping_tlv_targetfec_subtlv_l2vpn_vcid->pw_type))(ndo, "\n\t      Sender PE: %s, Remote PE: %s" "\n\t      PW ID: 0x%08x, PW Type: %s (%u)", getname(ndo, (const u_char *)(subtlv_ptr.lspping_tlv_targetfec_subtlv_l2vpn_vcid->sender_pe_address)), getname(ndo, (const u_char *)(subtlv_ptr.lspping_tlv_targetfec_subtlv_l2vpn_vcid->remote_pe_address)), ((uint32_t)(((uint32_t)(*((const uint8_t *)(subtlv_ptr.lspping_tlv_targetfec_subtlv_l2vpn_vcid->pw_id) + 0)) << 24) | ((uint32_t)(*((const uint8_t *)(subtlv_ptr.lspping_tlv_targetfec_subtlv_l2vpn_vcid->pw_id) + 1)) << 16) | ((uint32_t)(*((const uint8_t *)(subtlv_ptr.lspping_tlv_targetfec_subtlv_l2vpn_vcid->pw_id) + 2)) << 8) | ((uint32_t)(*((const uint8_t *)(subtlv_ptr.lspping_tlv_targetfec_subtlv_l2vpn_vcid->pw_id) + 3)) << 0))), tok2str(mpls_pw_types_values, "unknown", ((uint16_t)(((uint16_t)(*((const uint8_t *)(subtlv_ptr.lspping_tlv_targetfec_subtlv_l2vpn_vcid->pw_type) + 0)) << 8) | ((uint16_t)(*((const uint8_t *)(subtlv_ptr.lspping_tlv_targetfec_subtlv_l2vpn_vcid->pw_type) + 1)) << 0)))), ((uint16_t)(((uint16_t)(*((const uint8_t *)(subtlv_ptr.lspping_tlv_targetfec_subtlv_l2vpn_vcid->pw_type) + 0)) << 8) | ((uint16_t)(*((const uint8_t *)(subtlv_ptr.lspping_tlv_targetfec_subtlv_l2vpn_vcid->pw_type) + 1)) << 0))))subtlv_ptr.lspping_tlv_targetfec_subtlv_l2vpn_vcid->sender_pe_addresssubtlv_ptr.lspping_tlv_targetfec_subtlv_l2vpn_vcid->remote_pe_addresssubtlv_ptr.lspping_tlv_targetfec_subtlv_l2vpn_vcid->pw_idsubtlv_ptr.lspping_tlv_targetfec_subtlv_l2vpn_vcid->pw_type(ndo, "\n\t\t TLV is too short")sizeof(struct lspping_tlv_downstream_map_t)(ndo, "\n\t    MTU: %u, Address-Type: %s (%u)", EXTRACT_16BITS(tlv_ptr.lspping_tlv_downstream_map->mtu), tok2str(lspping_tlv_downstream_addr_values, "unknown", tlv_ptr.lspping_tlv_downstream_map->address_type), tlv_ptr.lspping_tlv_downstream_map->address_type)(ndo, "\n\t    MTU: %u, Address-Type: %s (%u)", ((uint16_t)(((uint16_t)(*((const uint8_t *)(tlv_ptr.lspping_tlv_downstream_map->mtu) + 0)) << 8) | ((uint16_t)(*((const uint8_t *)(tlv_ptr.lspping_tlv_downstream_map->mtu) + 1)) << 0))), tok2str(lspping_tlv_downstream_addr_values, "unknown", tlv_ptr.lspping_tlv_downstream_map->address_type), tlv_ptr.lspping_tlv_downstream_map->address_type)tlv_ptr.lspping_tlv_downstream_map->mtusizeof(struct lspping_tlv_downstream_map_ipv4_t)(ndo, "\n\t    Downstream IP: %s" "\n\t    Downstream Interface IP: %s", ipaddr_string(ndo, tlv_ptr.lspping_tlv_downstream_map_ipv4->downstream_ip), ipaddr_string(ndo, tlv_ptr.lspping_tlv_downstream_map_ipv4->downstream_interface))(ndo, "\n\t    Downstream IP: %s" "\n\t    Downstream Interface IP: %s", getname(ndo, (const u_char *)(tlv_ptr.lspping_tlv_downstream_map_ipv4->downstream_ip)), getname(ndo, (const u_char *)(tlv_ptr.lspping_tlv_downstream_map_ipv4->downstream_interface)))tlv_ptr.lspping_tlv_downstream_map_ipv4->downstream_iptlv_ptr.lspping_tlv_downstream_map_ipv4->downstream_interfacesizeof(struct lspping_tlv_downstream_map_ipv4_unmb_t)(ndo, "\n\t    Downstream IP: %s" "\n\t    Downstream Interface Index: 0x%08x", ipaddr_string(ndo, tlv_ptr.lspping_tlv_downstream_map_ipv4_unmb->downstream_ip), EXTRACT_32BITS(tlv_ptr.lspping_tlv_downstream_map_ipv4_unmb->downstream_interface))(ndo, "\n\t    Downstream IP: %s" "\n\t    Downstream Interface Index: 0x%08x", getname(ndo, (const u_char *)(tlv_ptr.lspping_tlv_downstream_map_ipv4_unmb->downstream_ip)), ((uint32_t)(((uint32_t)(*((const uint8_t *)(tlv_ptr.lspping_tlv_downstream_map_ipv4_unmb->downstream_interface) + 0)) << 24) | ((uint32_t)(*((const uint8_t *)(tlv_ptr.lspping_tlv_downstream_map_ipv4_unmb->downstream_interface) + 1)) << 16) | ((uint32_t)(*((const uint8_t *)(tlv_ptr.lspping_tlv_downstream_map_ipv4_unmb->downstream_interface) + 2)) << 8) | ((uint32_t)(*((const uint8_t *)(tlv_ptr.lspping_tlv_downstream_map_ipv4_unmb->downstream_interface) + 3)) << 0))))tlv_ptr.lspping_tlv_downstream_map_ipv4_unmb->downstream_iptlv_ptr.lspping_tlv_downstream_map_ipv4_unmb->downstream_interfacesizeof(struct lspping_tlv_downstream_map_ipv6_t)(ndo, "\n\t    Downstream IP: %s" "\n\t    Downstream Interface IP: %s", ip6addr_string(ndo, tlv_ptr.lspping_tlv_downstream_map_ipv6->downstream_ip), ip6addr_string(ndo, tlv_ptr.lspping_tlv_downstream_map_ipv6->downstream_interface))(ndo, "\n\t    Downstream IP: %s" "\n\t    Downstream Interface IP: %s", getname6(ndo, (const u_char *)(tlv_ptr.lspping_tlv_downstream_map_ipv6->downstream_ip)), getname6(ndo, (const u_char *)(tlv_ptr.lspping_tlv_downstream_map_ipv6->downstream_interface)))tlv_ptr.lspping_tlv_downstream_map_ipv6->downstream_iptlv_ptr.lspping_tlv_downstream_map_ipv6->downstream_interfacesizeof(struct lspping_tlv_downstream_map_ipv6_unmb_t)(ndo, "\n\t    Downstream IP: %s" "\n\t    Downstream Interface Index: 0x%08x", ip6addr_string(ndo, tlv_ptr.lspping_tlv_downstream_map_ipv6_unmb->downstream_ip), EXTRACT_32BITS(tlv_ptr.lspping_tlv_downstream_map_ipv6_unmb->downstream_interface))(ndo, "\n\t    Downstream IP: %s" "\n\t    Downstream Interface Index: 0x%08x", getname6(ndo, (const u_char *)(tlv_ptr.lspping_tlv_downstream_map_ipv6_unmb->downstream_ip)), ((uint32_t)(((uint32_t)(*((const uint8_t *)(tlv_ptr.lspping_tlv_downstream_map_ipv6_unmb->downstream_interface) + 0)) << 24) | ((uint32_t)(*((const uint8_t *)(tlv_ptr.lspping_tlv_downstream_map_ipv6_unmb->downstream_interface) + 1)) << 16) | ((uint32_t)(*((const uint8_t *)(tlv_ptr.lspping_tlv_downstream_map_ipv6_unmb->downstream_interface) + 2)) << 8) | ((uint32_t)(*((const uint8_t *)(tlv_ptr.lspping_tlv_downstream_map_ipv6_unmb->downstream_interface) + 3)) << 0))))tlv_ptr.lspping_tlv_downstream_map_ipv6_unmb->downstream_iptlv_ptr.lspping_tlv_downstream_map_ipv6_unmb->downstream_interfacesizeof(struct lspping_tlv_downstream_map_info_t)LSPPING_TLV_BFD_DISCRIMINATOR_LEN(ndo, "\n\t    BFD Discriminator 0x%08x", EXTRACT_32BITS(tptr))(ndo, "\n\t    BFD Discriminator 0x%08x", ((uint32_t)(((uint32_t)(*((const uint8_t *)(tptr) + 0)) << 24) | ((uint32_t)(*((const uint8_t *)(tptr) + 1)) << 16) | ((uint32_t)(*((const uint8_t *)(tptr) + 2)) << 8) | ((uint32_t)(*((const uint8_t *)(tptr) + 3)) << 0))))LSPPING_TLV_VENDOR_ENTERPRISE_LEN(ndo, "\n\t    Vendor: %s (0x%04x)", tok2str(smi_values, "Unknown", vendor_id), vendor_id)
	  %s TLV (%u), length: %uLSPPING_TLV_TARGET_FEC_STACK
	      TLV is too short
	    %s subTLV (%u), length: %uLSPPING_TLV_TARGETFEC_SUBTLV_LDP_IPV4
	      invalid subTLV length, should be 5const lspping_tlv_targetfec_subtlv_ldp_ipv4_tconst lspping_tlv_targetfec_subtlv_ldp_ipv4_t *lspping_tlv_targetfec_subtlv_ldp_ipv4_t *
	      %s/%uLSPPING_TLV_TARGETFEC_SUBTLV_LDP_IPV6
	      invalid subTLV length, should be 17const lspping_tlv_targetfec_subtlv_ldp_ipv6_tconst lspping_tlv_targetfec_subtlv_ldp_ipv6_t *lspping_tlv_targetfec_subtlv_ldp_ipv6_t *LSPPING_TLV_TARGETFEC_SUBTLV_BGP_IPV4const lspping_tlv_targetfec_subtlv_bgp_ipv4_tconst lspping_tlv_targetfec_subtlv_bgp_ipv4_t *lspping_tlv_targetfec_subtlv_bgp_ipv4_t *LSPPING_TLV_TARGETFEC_SUBTLV_BGP_IPV6const lspping_tlv_targetfec_subtlv_bgp_ipv6_tconst lspping_tlv_targetfec_subtlv_bgp_ipv6_t *lspping_tlv_targetfec_subtlv_bgp_ipv6_t *LSPPING_TLV_TARGETFEC_SUBTLV_RSVP_IPV4
	      invalid subTLV length, should be 20const lspping_tlv_targetfec_subtlv_rsvp_ipv4_tconst lspping_tlv_targetfec_subtlv_rsvp_ipv4_t *lspping_tlv_targetfec_subtlv_rsvp_ipv4_t *
	      tunnel end-point %s, tunnel sender %s, lsp-id 0x%04x
	      tunnel-id 0x%04x, extended tunnel-id %schar[108]LSPPING_TLV_TARGETFEC_SUBTLV_RSVP_IPV6
	      invalid subTLV length, should be 56const lspping_tlv_targetfec_subtlv_rsvp_ipv6_tconst lspping_tlv_targetfec_subtlv_rsvp_ipv6_t *lspping_tlv_targetfec_subtlv_rsvp_ipv6_t *LSPPING_TLV_TARGETFEC_SUBTLV_L3VPN_IPV4
	      invalid subTLV length, should be 13const lspping_tlv_targetfec_subtlv_l3vpn_ipv4_tconst lspping_tlv_targetfec_subtlv_l3vpn_ipv4_t *lspping_tlv_targetfec_subtlv_l3vpn_ipv4_t *
	      RD: %s, %s/%uLSPPING_TLV_TARGETFEC_SUBTLV_L3VPN_IPV6
	      invalid subTLV length, should be 25const lspping_tlv_targetfec_subtlv_l3vpn_ipv6_tconst lspping_tlv_targetfec_subtlv_l3vpn_ipv6_t *lspping_tlv_targetfec_subtlv_l3vpn_ipv6_t *LSPPING_TLV_TARGETFEC_SUBTLV_L2VPN_ENDPT
	      invalid subTLV length, should be 14const lspping_tlv_targetfec_subtlv_l2vpn_endpt_tconst lspping_tlv_targetfec_subtlv_l2vpn_endpt_t *lspping_tlv_targetfec_subtlv_l2vpn_endpt_t *
	      RD: %s, Sender VE ID: %u, Receiver VE ID: %u
	      Encapsulation Type: %s (%u)char[88]LSPPING_TLV_TARGETFEC_SUBTLV_FEC_128_PW_OLD
	      invalid subTLV length, should be 10const lspping_tlv_targetfec_subtlv_fec_128_pw_oldconst lspping_tlv_targetfec_subtlv_fec_128_pw_old *lspping_tlv_targetfec_subtlv_fec_128_pw_old *
	      Remote PE: %s
	      PW ID: 0x%08x, PW Type: %s (%u)char[61]LSPPING_TLV_TARGETFEC_SUBTLV_FEC_128_PWconst lspping_tlv_targetfec_subtlv_fec_128_pwconst lspping_tlv_targetfec_subtlv_fec_128_pw *lspping_tlv_targetfec_subtlv_fec_128_pw *
	      Sender PE: %s, Remote PE: %s
	      PW ID: 0x%08x, PW Type: %s (%u)
		 TLV is too shortLSPPING_TLV_DOWNSTREAM_MAPPINGconst lspping_tlv_downstream_map_tconst lspping_tlv_downstream_map_t *lspping_tlv_downstream_map_t *
	    MTU: %u, Address-Type: %s (%u)LSPPING_AFI_IPV4const lspping_tlv_downstream_map_ipv4_tconst lspping_tlv_downstream_map_ipv4_t *lspping_tlv_downstream_map_ipv4_t *
	    Downstream IP: %s
	    Downstream Interface IP: %sLSPPING_AFI_IPV4_UNMBconst lspping_tlv_downstream_map_ipv4_unmb_tconst lspping_tlv_downstream_map_ipv4_unmb_t *lspping_tlv_downstream_map_ipv4_unmb_t *
	    Downstream IP: %s
	    Downstream Interface Index: 0x%08xLSPPING_AFI_IPV6const lspping_tlv_downstream_map_ipv6_tconst lspping_tlv_downstream_map_ipv6_t *lspping_tlv_downstream_map_ipv6_t *LSPPING_AFI_IPV6_UNMBconst lspping_tlv_downstream_map_ipv6_unmb_tconst lspping_tlv_downstream_map_ipv6_unmb_t *lspping_tlv_downstream_map_ipv6_unmb_t *const lspping_tlv_downstream_map_info_tconst lspping_tlv_downstream_map_info_t *lspping_tlv_downstream_map_info_t *LSPPING_TLV_BFD_DISCRIMINATOR
	    BFD Discriminator 0x%08xLSPPING_TLV_VENDOR_ENTERPRISE
	    Vendor: %s (0x%04x)LSPPING_TLV_PADLSPPING_TLV_ERROR_CODELSPPING_TLV_VENDOR_PRIVATEtlv_tooshortlspping_tlv_downstream_map_info_tlspping_tlv_downstream_map_ipv6_unmb_tlspping_tlv_downstream_map_ipv6_tlspping_tlv_downstream_map_ipv4_unmb_tlspping_tlv_downstream_map_ipv4_tlspping_tlv_downstream_map_tlspping_tlv_targetfec_subtlv_bgp_ipv6_tlspping_tlv_targetfec_subtlv_bgp_ipv4_tlspping_tlv_targetfec_subtlv_fec_128_pwlspping_tlv_targetfec_subtlv_fec_128_pw_oldlspping_tlv_targetfec_subtlv_l2vpn_endpt_tlspping_tlv_targetfec_subtlv_l3vpn_ipv6_tlspping_tlv_targetfec_subtlv_l3vpn_ipv4_tlspping_tlv_targetfec_subtlv_rsvp_ipv6_tlspping_tlv_targetfec_subtlv_rsvp_ipv4_tlspping_tlv_targetfec_subtlv_ldp_ipv6_tlspping_tlv_targetfec_subtlv_ldp_ipv4_tlspping_common_headerlspping_tlv_targetfec_subtlv_bgp_ipv6lspping_tlv_targetfec_subtlv_bgp_ipv4lspping_tlv_targetfec_subtlv_l2vpn_vcidlspping_tlv_targetfec_subtlv_l2vpn_vcid_oldlspping_tlv_targetfec_subtlv_l2vpn_endptlspping_tlv_targetfec_subtlv_l3vpn_ipv6lspping_tlv_targetfec_subtlv_l3vpn_ipv4lspping_tlv_targetfec_subtlv_rsvp_ipv6lspping_tlv_targetfec_subtlv_rsvp_ipv4lspping_tlv_targetfec_subtlv_ldp_ipv6lspping_tlv_targetfec_subtlv_ldp_ipv4lspping_tlv_downstream_map_infolspping_tlv_downstream_map_ipv6_unmblspping_tlv_downstream_map_ipv6lspping_tlv_downstream_map_ipv4_unmblspping_tlv_downstream_map_ipv4lspping_tlv_downstream_mapmultipath_lengthdepth_limitmultipath_typedownstream_interfacedownstream_ipds_flagsaddress_typepw_typepw_idremote_pe_addresssender_pe_addressencapsulationreceiver_ve_idsender_ve_idtunnel_senderextended_tunnel_idtunnel_idtunnel_endpointts_rcvd_usects_rcvd_sects_sent_usects_sent_secseq_numbersender_handlereturn_subcodereturn_codereply_modeglobal_flagsUnnumbered IPv4"Unnumbered IPv4"lspping_tlv_downstream_addr_valuesLDP IPv4 prefix"LDP IPv4 prefix"LDP IPv6 prefix"LDP IPv6 prefix"RSVP IPv4 Session Query"RSVP IPv4 Session Query"RSVP IPv6 Session Query"RSVP IPv6 Session Query"VPN IPv4 prefix"VPN IPv4 prefix"VPN IPv6 prefix"VPN IPv6 prefix"L2 VPN endpoint"L2 VPN endpoint"FEC 128 pseudowire (old)"FEC 128 pseudowire (old)"FEC 128 pseudowire"FEC 128 pseudowire"BGP labeled IPv4 prefix"BGP labeled IPv4 prefix"BGP labeled IPv6 prefix"BGP labeled IPv6 prefix"lspping_tlvtargetfec_subtlv_valuesTarget FEC Stack"Target FEC Stack"Downstream Mapping"Downstream Mapping"Vendor Enterprise Code"Vendor Enterprise Code"LSPPING_TLV_INTERFACE_LABEL_STACKInterface Label Stack"Interface Label Stack"LSPPING_TLV_REPLY_TOS_BYTEReply TOS Byte"Reply TOS Byte"BFD Discriminator"BFD Discriminator"Vendor Private Code"Vendor Private Code"lspping_tlv_valuesNo return code or return code contained in the Error Code TLV"No return code or return code contained in the Error Code TLV"Malformed echo request received"Malformed echo request received"One or more of the TLVs was not understood"One or more of the TLVs was not understood"Replying router is an egress for the FEC at stack depth"Replying router is an egress for the FEC at stack depth"Replying router has no mapping for the FEC at stack depth"Replying router has no mapping for the FEC at stack depth"Label switched at stack-depth"Label switched at stack-depth"Label switched but no MPLS forwarding at stack-depth"Label switched but no MPLS forwarding at stack-depth"Mapping for this FEC is not the given label at stack depth"Mapping for this FEC is not the given label at stack depth"No label entry at stack-depth"No label entry at stack-depth"Protocol not associated with interface at FEC stack depth"Protocol not associated with interface at FEC stack depth"Premature termination of ping due to label stack shrinking to a single label"Premature termination of ping due to label stack shrinking to a single label"lspping_return_code_valuesDo not reply"Do not reply"Reply via an IPv4/IPv6 UDP packet"Reply via an IPv4/IPv6 UDP packet"Reply via an IPv4/IPv6 UDP packet with Router Alert"Reply via an IPv4/IPv6 UDP packet with Router Alert"Reply via application level control channel"Reply via application level control channel"lspping_reply_mode_valuesMPLS Echo Request"MPLS Echo Request"MPLS Echo Reply"MPLS Echo Reply"lspping_msg_type_valuesLSPPING_TLV_TARGETFEC_SUBTLV_NIL_FECLSPPING_TLV_TARGETFEC_SUBTLV_GENERIC_IPV6LSPPING_TLV_TARGETFEC_SUBTLV_GENERIC_IPV4LSPPING_TLV_TARGETFEC_SUBTLV_FEC_129_PW0xfc00/* Does the TLV, including padding, go past the end of the packet? *//* All TLVs are aligned to four octet boundary *//* do we want to see an additionally tlv hexdump ? *//*
             *  FIXME those are the defined TLVs that lack a decoder
             *  you are welcome to contribute code ;-)
             *//* dump the TLV until code complete *//* FIXME print downstream labels *//* FIXME add hash-key type, depth limit, multipath processing *//* Did we capture enough for this part of the TLV? *//* Does the data go past the end of the TLV? *//* should not happen ! - no error message - tok2str() has barked already *//* that strange thing with the downstream map TLV is that until now
             * we do not know if its IPv4 or IPv6 or is unnumbered; after
             * we find the address-type, we recast the tlv_tptr and move on. *//* Did we capture enough to get the address family? *//* Does the header go past the end of the TLV? *//* Does the subTLV, including padding, go past the end of the TLV? *//* All subTLVs are aligned to four octet boundary *//* do we want to see an additionally subtlv hexdump ? *//* unknown subTLV just hexdump it *//* Is the subTLV length correct? *//* the old L2VPN VCID subTLV does not have support for the sender field *//* Did we capture enough for fully decoding the subTLV? *//* Does the subTLV go past the end of the TLV? *//* did we capture enough for fully decoding the subtlv header ? *//* Does the subTLV header go past the end of the TLV? *//* did we capture enough for fully decoding the tlv ? *//* Does the TLV go past the end of the packet? *//* header not included -> no adjustment *//* no value to dissect *//* did we capture enough for fully decoding the tlv header ? *//*
     *  the following return codes require that the subcode is attached
     *  at the end of the translated token output
     *//* Enough to get the address type *//*
 *  0                   1                   2                   3
 *  0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
 * +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
 * |               MTU             | Address Type  |  Resvd (SBZ)  |
 * +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
 * |             Downstream IP Address (4 or 16 octets)            |
 * +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
 * |         Downstream Interface Address (4 or 16 octets)         |
 * +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
 * | Multipath Type| Depth Limit   |        Multipath Length       |
 * +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
 * .                                                               .
 * .                     (Multipath Information)                   .
 * .                                                               .
 * +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
 * |               Downstream Label                |    Protocol   |
 * +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
 * .                                                               .
 * .                                                               .
 * .                                                               .
 * +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
 * |               Downstream Label                |    Protocol   |
 * +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
 *//*
 * 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
 * +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
 * |                          IPv6 prefix                          |
 * |                          (16 octets)                          |
 * |                                                               |
 * |                                                               |
 * +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
 * | Prefix Length |                 Must Be Zero                  |
 * +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
 *//*
 * 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
 * +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
 * |                         IPv4 prefix                           |
 * +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
 * | Prefix Length |                 Must Be Zero                  |
 * +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
 *//*
 *  0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
 * +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
 * |                     Sender's PE Address                       |
 * +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
 * |                      Remote PE Address                        |
 * +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
 * |                             PW ID                             |
 * +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
 * |            PW Type            |          Must Be Zero         |
 * +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
 *//*
 *  0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
 * +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
 * |                      Remote PE Address                        |
 * +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
 * |                             PW ID                             |
 *    5a    