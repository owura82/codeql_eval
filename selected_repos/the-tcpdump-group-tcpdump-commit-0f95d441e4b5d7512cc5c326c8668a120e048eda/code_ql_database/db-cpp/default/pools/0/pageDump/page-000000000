/Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX.sdk/usr/include/pcap/namedb.hpcap_nametollcconst charconst char *char *pcap_nametoeprotopcap_nametoprotopcap_nametoportrangeint *pcap_nametoportpcap_nametonetaddraddrinfo *pcap_nametoaddrinfobpf_u_int32 *unsigned int *bpf_u_int32 **unsigned int **pcap_nametoaddru_char *unsigned char *pcap_ether_atonpcap_ether_hosttonpcap_etherent *pcap_next_etherentFILE *__sFILE *pcap_etherentchar[122]122nameu_char[6]unsigned char[6]6addrPROTO_UNDEF-1PCAP_ETHERS_FILE"/etc/ethers"lib_pcap_namedb_h__cplusplusexternc_linkage/*
 * If a protocol is unknown, PROTO_UNDEF is returned.
 * Also, pcap_nametoport() returns the protocol along with the port number.
 * If there are ambiguous entried in /etc/services (i.e. domain
 * can be either tcp or udp) PROTO_UNDEF is returned.
 *//*
 * As returned by the pcap_next_etherent()
 * XXX this stuff doesn't belong in this interface, but this
 * library already must do name to address translation, so
 * on systems that don't have support for /etc/ethers, we
 * export these hooks since they're already being used by
 * some applications (such as tcpdump) and already being
 * marked as exported in some OSes offering libpcap (such
 * as Debian).
 *//*
 * Copyright (c) 1994, 1996
 *	The Regents of the University of California.  All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *	This product includes software developed by the Computer Systems
 *	Engineering Group at Lawrence Berkeley Laboratory.
 * 4. Neither the name of the University nor of the Laboratory may be used
 *    to endorse or promote products derived from this software without
 *    specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 *//Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX.sdk/usr/include/pcap/Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX.sdk/usr/include/Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX.sdk/usr/Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX.sdk/Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Applications/Xcode.app/Contents/Developer/Platforms/Applications/Xcode.app/Contents/Developer/Applications/Xcode.app/Contents/Applications/Xcode.app/Applications//Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX.sdk/usr/include/pcap-namedb.h<pcap/namedb.h>/*
 * For backwards compatibility.
 *
 * Note to OS vendors: do NOT get rid of this file!  Some applications
 * might expect to be able to include <pcap-namedb.h>.
 *//Users/owura/Repos/codeql_eval/proj_repos/the-tcpdump-group-tcpdump-commit-0f95d441e4b5d7512cc5c326c8668a120e048eda/tcpdump/interface.h"netdissect.h"<pcap.h><stdint.h><stdarg.h>in_cksum_shouldbein_cksumconst cksum_vecconst cksum_vec *cksum_vec *nt_errstrsmb_errstrq922_stringconst u_charconst u_char *create_osi_cksumconst uint8_tconst uint8_t *verify_crc10_cksuminit_checksumdnnum_stringdnname_stringcopy_argvchar **read_infilewarningerrortok2strary_internalconst char **mask2plencksum_veclenptrthiszoneprogram_nametok2strary(a,f,i)tok2strary_internal(a, sizeof(a)/sizeof(a[0]),f,i)TCHECK(var)TCHECK2(var, sizeof(var))TCHECK2(var,l)if (!TTEST2(var, l)) goto truncTTEST(var)TTEST2(var, sizeof(var))TTEST2(var,l)(snapend - (l) <= snapend && (const u_char *)&(var) <= snapend - (l))EDST(ep)((ep)->ether_dhost)ESRC(ep)((ep)->ether_shost)PT_LMP16PT_PGM_ZMTP115PT_PGM14PT_VXLAN13PT_ZMTP112PT_RADIUS11PT_CARP10PT_AODV9PT_TFTP8PT_CNFP7PT_SNMPPT_RTCP5PT_RTP4PT_RPC3PT_WB2PT_VAT1tcpdump_interface_hHAVE_OS_PROTO_HHAVE_STDINT_H!defined(HAVE_SNPRINTF)__ATTRIBUTE___FORMAT_OK!defined(HAVE_VSNPRINTF)HAVE_STRLCATHAVE_STRLCPYHAVE_STRDUPHAVE_STRSEPNTOHLINET6HAVE_BPF_DUMPNETDISSECT_REWORKEDvoid_param_listformatprintfnoreturn/* forward compatibility *//*INET6*//* The printer routines. *//* checksum routines *//* __ATTRIBUTE___FORMAT_OK *//* Bail if "var" was not captured *//* Bail if "l" bytes of "var" were not captured *//* True if "var" was captured *//*
 * True if  "l" bytes of "var" were captured.
 *
 * The "snapend - (l) <= snapend" checks to make sure "l" isn't so large
 * that "snapend - (l)" underflows.
 *
 * The check is for <= rather than < because "l" might be 0.
 *//* seconds offset from gmt to local time *//* used to generate self-identifying messages *//* Link Management Protocol *//* ZMTP/1.0 inside PGM (native or UDP-encapsulated) *//* [UDP-encapsulated] Pragmatic General Multicast *//* Virtual eXtensible Local Area Network *//* ZeroMQ Message Transport Protocol 1.0 *//* RADIUS authentication Protocol *//* Common Address Redundancy Protocol *//* Ad-hoc On-demand Distance Vector Protocol *//* trivial file transfer protocol *//* Cisco NetFlow protocol *//* Simple Network Management Protocol *//* Real-Time Applications control protocol *//* Real-Time Applications protocol *//* Remote Procedure Call *//* distributed White Board *//* Visual Audio Tool *//* !defined(HAVE_VSNPRINTF) *//* !defined(HAVE_SNPRINTF) *//* snprintf et al *//*
 * Copyright (c) 1988-2002
 *	The Regents of the University of California.  All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that: (1) source code distributions
 * retain the above copyright notice and this paragraph in its entirety, (2)
 * distributions including binary code include the above copyright notice and
 * this paragraph in its entirety in the documentation or other materials
 * provided with the distribution, and (3) all advertising materials mentioning
 * features or use of this software display the following acknowledgement:
 * ``This product includes software developed by the University of California,
 * Lawrence Berkeley Laboratory and its contributors.'' Neither the name of
 * the University nor the names of its contributors may be used to endorse
 * or promote products derived from this software without specific prior
 * written permission.
 * THIS SOFTWARE IS PROVIDED ``AS IS'' AND WITHOUT ANY EXPRESS OR IMPLIED
 * WARRANTIES, INCLUDING, WITHOUT LIMITATION, THE IMPLIED WARRANTIES OF
 * MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE.
 *//Users/owura/Repos/codeql_eval/proj_repos/the-tcpdump-group-tcpdump-commit-0f95d441e4b5d7512cc5c326c8668a120e048eda/tcpdump/Users/owura/Repos/codeql_eval/proj_repos/the-tcpdump-group-tcpdump-commit-0f95d441e4b5d7512cc5c326c8668a120e048eda/Users/owura/Repos/codeql_eval/proj_repos/Users/owura/Repos/codeql_eval/Users/owura/Repos/Users/owura/Users/Users/owura/Repos/codeql_eval/proj_repos/the-tcpdump-group-tcpdump-commit-0f95d441e4b5d7512cc5c326c8668a120e048eda/tcpdump/addrtoname.h(unnamed enum)LINKADDR_ETHER0LINKADDR_FRELAYLINKADDR_IEEE1394LINKADDR_ATMipaddr_string(ndo,p)getname(ndo, (const u_char *)(p))BUFSIZE128hnamemem *newhnamememhnamememinit_addrtonamenetdissect_options *intoagetnameipxsap_stringprotoid_stringdnaddr_stringisonsap_stringudpport_stringtcpport_stringetherproto_stringle64addr_stringetheraddr_stringlinkaddr_stringconst unsigned int/* Name to address translation routines. *//*
 * Copyright (c) 1990, 1992, 1993, 1994, 1995, 1996, 1997
 *	The Regents of the University of California.  All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that: (1) source code distributions
 * retain the above copyright notice and this paragraph in its entirety, (2)
 * distributions including binary code include the above copyright notice and
 * this paragraph in its entirety in the documentation or other materials
 * provided with the distribution, and (3) all advertising materials mentioning
 * features or use of this software display the following acknowledgement:
 * ``This product includes software developed by the University of California,
 * Lawrence Berkeley Laboratory and its contributors.'' Neither the name of
 * the University nor the names of its contributors may be used to endorse
 * or promote products derived from this software without specific prior
 * written permission.
 * THIS SOFTWARE IS PROVIDED ``AS IS'' AND WITHOUT ANY EXPRESS OR IMPLIED
 * WARRANTIES, INCLUDING, WITHOUT LIMITATION, THE IMPLIED WARRANTIES OF
 * MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE.
 *//Users/owura/Repos/codeql_eval/proj_repos/the-tcpdump-group-tcpdump-commit-0f95d441e4b5d7512cc5c326c8668a120e048eda/tcpdump/llc.hPID_RFC2684_BPDU0x000ePID_RFC2684_802_6_NOFCS0x000bPID_RFC2684_802_6_FCS0x0005PID_RFC2684_FDDI_NOFCS0x000aPID_RFC2684_FDDI_FCS0x0004PID_RFC2684_802_5_NOFCS0x0009PID_RFC2684_802_5_FCS0x0003PID_RFC2684_802_4_NOFCS0x0008PID_RFC2684_802_4_FCS0x0002PID_RFC2684_ETH_NOFCS0x0007PID_RFC2684_ETH_FCS0x0001PID_CISCO_VLANBRIDGE0x010cPID_CISCO_PVST0x010bPID_CISCO_UDLD0x0111PID_CISCO_DTP0x2004PID_CISCO_VTP0x2003PID_CISCO_CDP0x2000LLCSAP_ISONS0xfeLLCSAP_NETBEUI0xf0LLCSAP_IPX0xe0LLCSAP_SNAP0xaaLLCSAP_PROWAY0x8eLLCSAP_ISO82080x7eLLCSAP_RS5110x4eLLCSAP_8021D0x42LLCSAP_PROWAYNM0x0eLLCSAP_IP0x06LLCSAP_SNA0x04LLCSAP_8021B_G0x03LLCSAP_8021B_I0x02LLCSAP_GLOBAL0xffLLCSAP_NULL0x00LLC_I_NS(is)(((is) >> 1) & 0x7f)LLC_IS_NR(is)(((is) >> 9) & 0x7f)LLC_REJLLC_RNRLLC_RRLLC_S_CMD(is)(((is) >> 2) & 0x03)LLC_FRMR0x87LLC_XID0xafLLC_TEST0xe3LLC_SABME0x6fLLC_DM0x0fLLC_DISC0x43LLC_UA0x63LLC_UILLC_U_CMD(u)((u) & 0xef)LLC_XID_FI0x81LLC_IS_POLL0x0100LLC_U_POLL0x10LLC_S_FMTLLC_IGLLC_GSAPLLC_U_FMT/* BPDUs *//* 802.6, without FCS *//* 802.6, with FCS *//* FDDI, without FCS *//* FDDI, with FCS *//* 802.5, without FCS *//* 802.5, with FCS *//* 802.4, without FCS *//* 802.4, with FCS *//* Ethernet, without FCS *//* Ethernet, with FCS *//*
 * PIDs for use with OUI_RFC2684.
 *//* "VLAN Bridge", according to Wireshark *//* Per VLAN Spanning Tree+ and RPVST+ *//* Unidirectional Link Detection *//* Cisco Dynamic Trunk Protocol *//* Cisco VLAN Trunk Protocol *//* Cisco Discovery Protocol *//*
 * PIDs for use with OUI_CISCO.
 *//* Individual / Group *//*
 * Definitions for information in the LLC header.
 *//*
 * Copyright (c) 1993, 1994, 1997
 *	The Regents of the University of California.  All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that: (1) source code distributions
 * retain the above copyright notice and this paragraph in its entirety, (2)
 * distributions including binary code include the above copyright notice and
 * this paragraph in its entirety in the documentation or other materials
 * provided with the distribution, and (3) all advertising materials mentioning
 * features or use of this software display the following acknowledgement:
 * ``This product includes software developed by the University of California,
 * Lawrence Berkeley Laboratory and its contributors.'' Neither the name of
 * the University nor the names of its contributors may be used to endorse
 * or promote products derived from this software without specific prior
 * written permission.
 * THIS SOFTWARE IS PROVIDED ``AS IS'' AND WITHOUT ANY EXPRESS OR IMPLIED
 * WARRANTIES, INCLUDING, WITHOUT LIMITATION, THE IMPLIED WARRANTIES OF
 * MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE.
 *//Users/owura/Repos/codeql_eval/proj_repos/the-tcpdump-group-tcpdump-commit-0f95d441e4b5d7512cc5c326c8668a120e048eda/tcpdump/extract.hEXTRACT_LE_64BITS(p)((uint64_t)(((uint64_t)(*((const uint8_t *)(p) + 7)) << 56) | ((uint64_t)(*((const uint8_t *)(p) + 6)) << 48) | ((uint64_t)(*((const uint8_t *)(p) + 5)) << 40) | ((uint64_t)(*((const uint8_t *)(p) + 4)) << 32) | ((uint64_t)(*((const uint8_t *)(p) + 3)) << 24) | ((uint64_t)(*((const uint8_t *)(p) + 2)) << 16) | ((uint64_t)(*((const uint8_t *)(p) + 1)) << 8) | ((uint64_t)(*((const uint8_t *)(p) + 0)) << 0)))EXTRACT_LE_24BITS(p)((uint32_t)(((uint32_t)(*((const uint8_t *)(p) + 2)) << 16) | ((uint32_t)(*((const uint8_t *)(p) + 1)) << 8) | ((uint32_t)(*((const uint8_t *)(p) + 0)) << 0)))EXTRACT_LE_32BITS(p)((uint32_t)(((uint32_t)(*((const uint8_t *)(p) + 3)) << 24) | ((uint32_t)(*((const uint8_t *)(p) + 2)) << 16) | ((uint32_t)(*((const uint8_t *)(p) + 1)) << 8) | ((uint32_t)(*((const uint8_t *)(p) + 0)) << 0)))EXTRACT_LE_16BITS(p)((uint16_t)(((uint16_t)(*((const uint8_t *)(p) + 1)) << 8) | ((uint16_t)(*((const uint8_t *)(p) + 0)) << 0)))EXTRACT_LE_8BITS(p)(*(p))EXTRACT_56BITS(p)((uint64_t)(((uint64_t)(*((const uint8_t *)(p) + 0)) << 48) | ((uint64_t)(*((const uint8_t *)(p) + 1)) << 40) | ((uint64_t)(*((const uint8_t *)(p) + 2)) << 32) | ((uint64_t)(*((const uint8_t *)(p) + 3)) << 24) | ((uint64_t)(*((const uint8_t *)(p) + 4)) << 16) | ((uint64_t)(*((const uint8_t *)(p) + 5)) << 8) | ((uint64_t)(*((const uint8_t *)(p) + 6)) << 0)))EXTRACT_48BITS(p)((uint64_t)(((uint64_t)(*((const uint8_t *)(p) + 0)) << 40) | ((uint64_t)(*((const uint8_t *)(p) + 1)) << 32) | ((uint64_t)(*((const uint8_t *)(p) + 2)) << 24) | ((uint64_t)(*((const uint8_t *)(p) + 3)) << 16) | ((uint64_t)(*((const uint8_t *)(p) + 4)) << 8) | ((uint64_t)(*((const uint8_t *)(p) + 5)) << 0)))EXTRACT_40BITS(p)((uint64_t)(((uint64_t)(*((const uint8_t *)(p) + 0)) << 32) | ((uint64_t)(*((const uint8_t *)(p) + 1)) << 24) | ((uint64_t)(*((const uint8_t *)(p) + 2)) << 16) | ((uint64_t)(*((const uint8_t *)(p) + 3)) << 8) | ((uint64_t)(*((const uint8_t *)(p) + 4)) << 0)))EXTRACT_24BITS(p)((uint32_t)(((uint32_t)(*((const uint8_t *)(p) + 0)) << 16) | ((uint32_t)(*((const uint8_t *)(p) + 1)) << 8) | ((uint32_t)(*((const uint8_t *)(p) + 2)) << 0)))EXTRACT_64BITS(p)((uint64_t)(((uint64_t)(*((const uint8_t *)(p) + 0)) << 56) | ((uint64_t)(*((const uint8_t *)(p) + 1)) << 48) | ((uint64_t)(*((const uint8_t *)(p) + 2)) << 40) | ((uint64_t)(*((const uint8_t *)(p) + 3)) << 32) | ((uint64_t)(*((const uint8_t *)(p) + 4)) << 24) | ((uint64_t)(*((const uint8_t *)(p) + 5)) << 16) | ((uint64_t)(*((const uint8_t *)(p) + 6)) << 8) | ((uint64_t)(*((const uint8_t *)(p) + 7)) << 0)))EXTRACT_32BITS(p)((uint32_t)(((uint32_t)(*((const uint8_t *)(p) + 0)) << 24) | ((uint32_t)(*((const uint8_t *)(p) + 1)) << 16) | ((uint32_t)(*((const uint8_t *)(p) + 2)) << 8) | ((uint32_t)(*((const uint8_t *)(p) + 3)) << 0)))EXTRACT_16BITS(p)((uint16_t)(((uint16_t)(*((const uint8_t *)(p) + 0)) << 8) | ((uint16_t)(*((const uint8_t *)(p) + 1)) << 0)))LBL_ALIGNdefined(__GNUC__) && defined(HAVE___ATTRIBUTE__) && \__GNUC__/*
 * Macros to extract possibly-unaligned little-endian integral values.
 * XXX - do loads on little-endian machines that support unaligned loads?
 *//* LBL_ALIGN *//*
 * The processor natively handles unaligned loads, so we can just
 * cast the pointer and fetch through it.
 *//* must special-case unaligned accesses *//*
 * This isn't a GCC-compatible compiler, we don't have __attribute__,
 * or we do but we don't know of any better way with this instruction
 * set to do unaligned loads, so do unaligned loads of big-endian
 * quantities the hard way - fetch the bytes one at a time and
 * assemble them.
 *//* have to do it a byte at a time *//*
 * This is a GCC-compatible compiler and we have __attribute__, which
 * we assume that mean we have __attribute__((packed)), and this is
 * MIPS or Alpha, which has instructions that can help when doing
 * unaligned loads.
 *
 * Declare packed structures containing a uint16_t and a uint32_t,
 * cast the pointer to point to one of those, and fetch through it;
 * the GCC manual doesn't appear to explicitly say that
 * __attribute__((packed)) causes the compiler to generate unaligned-safe
 * code, but it apppears to do so.
 *
 * We do this in case the compiler can generate code using those
 * instructions to do an unaligned load and pass stuff to "ntohs()" or
 * "ntohl()", which might be better than than the code to fetch the
 * bytes one at a time and assemble them.  (That might not be the
 * case on a little-endian platform, such as DEC's MIPS machines and
 * Alpha machines, where "ntohs()" and "ntohl()" might not be done
 * inline.)
 *
 * We do this only for specific architectures because, for example,
 * at least some versions of GCC, when compiling for 64-bit SPARC,
 * generate code that assumes alignment if we do this.
 *
 * XXX - add other architectures and compilers as possible and
 * appropriate.
 *
 * HP's C compiler, indicated by __HP_cc being defined, supports
 * "#pragma unaligned N" in version A.05.50 and later, where "N"
 * specifies a number of bytes at which the typedef on the next
 * line is aligned, e.g.
 *
 *	#pragma unalign 1
 *	typedef uint16_t unaligned_uint16_t;
 *
 * to define unaligned_uint16_t as a 16-bit unaligned data type.
 * This could be presumably used, in sufficiently recent versions of
 * the compiler, with macros similar to those below.  This would be
 * useful only if that compiler could generate better code for PA-RISC
 * or Itanium than would be generated by a bunch of shifts-and-ORs.
 *
 * DEC C, indicated by __DECC being defined, has, at least on Alpha,
 * an __unaligned qualifier that can be applied to pointers to get the
 * compiler to generate code that does unaligned loads and stores when
 * dereferencing the pointer in question.
 *
 * XXX - what if the native C compiler doesn't support
 * __attribute__((packed))?  How can we get it to generate unaligned
 * accesses for *specific* items?
 *//*
 * The processor doesn't natively handle unaligned loads.
 *//*
 * Macros to extract possibly-unaligned big-endian integral values.
 *//*
 * Copyright (c) 1992, 1993, 1994, 1995, 1996
 *	The Regents of the University of California.  All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that: (1) source code distributions
 * retain the above copyright notice and this paragraph in its entirety, (2)
 * distributions including binary code include the above copyright notice and
 * this paragraph in its entirety in the documentation or other materials
 * provided with the distribution, and (3) all advertising materials mentioning
 * features or use of this software display the following acknowledgement:
 * ``This product includes software developed by the University of California,
 * Lawrence Berkeley Laboratory and its contributors.'' Neither the name of
 * the University nor the names of its contributors may be used to endorse
 * or promote products derived from this software without specific prior
 * written permission.
 * THIS SOFTWARE IS PROVIDED ``AS IS'' AND WITHOUT ANY EXPRESS OR IMPLIED
 * WARRANTIES, INCLUDING, WITHOUT LIMITATION, THE IMPLIED WARRANTIES OF
 * MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE.
 *//Users/owura/Repos/codeql_eval/proj_repos/the-tcpdump-group-tcpdump-commit-0f95d441e4b5d7512cc5c326c8668a120e048eda/tcpdump/oui.hconst tokconst tok[]tok[]smi_valuesoui_valuesSMI_WIFI_ALLIANCE14122SMI_GEMTEK_SYSTEMS10529SMI_THE3GPP10415SMI_COLUMBIA_UNIVERSITY11862SMI_COLUBRIS8744SMI_INTERLINK6728SMI_QUINTUM6618SMI_ISSANNI5948SMI_IP_UNPLUGGED5925SMI_THE3GPP25535SMI_CISCO_BBSM5263SMI_UNISPHERE4874SMI_CABLELABS4491SMI_SIEMENS4329SMI_NOMADIX3309SMI_NETSCREEN3224SMI_SHASTA3199SMI_COSINE3085SMI_CISCO_VPN30003076SMI_APTIS2637SMI_JUNIPER2636SMI_REDBACK2352SMI_VERSANET2180SMI_FOUNDRY1991SMI_BAY1584SMI_ASCEND529SMI_3COM429SMI_MICROSOFT311SMI_LIVINGSTON307SMI_CISCO_VPN5000255SMI_ERICSSON193SMI_SHIVA166SMI_MERIT61SMI_SUN_MICROSYSTEMS42SMI_HEWLETT_PACKARDSMI_CISCOSMI_ACCSMI_IETFOUI_DCBX0x001B21OUI_TIA0x0012bbOUI_IEEE_8023_PRIVATE0x00120fOUI_IEEE_8021_PRIVATE0x0080c2OUI_HP0x080009OUI_JUNIPER0x009069OUI_APPLETALK0x080007OUI_CABLE_BPDU0x00E02FOUI_ATM_FORUM0x00A03EOUI_RFC2684OUI_CISCO_900x0000f8OUI_NORTEL0x000081OUI_CISCO0x00000cOUI_ENCAP_ETHER0x000000/* reserved - used by the IETF in L2TP? *//*
 * These are SMI Network Management Private Enterprise Codes for
 * organizations; see
 *
 *	http://www.iana.org/assignments/enterprise-numbers
 *
 * for a list.
 *
 * List taken from Ethereal's epan/sminmpec.h.
 *//* DCBX *//* TIA - Telecommunications Industry Association - ANSI/TIA-1057- 2006 *//* IEEE 802.3 Organisation Specific - Annex G *//* IEEE 802.1 Organisation Specific - Annex F *//* Hewlett-Packard *//* Juniper *//* Appletalk *//* DOCSIS spanning tree BPDU *//* ATM Forum *//* RFC 2427/2684 bridged Ethernet *//* Cisco bridging *//* Nortel SONMP *//* Cisco protocols *//* encapsulated Ethernet *//*
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that: (1) source code
 * distributions retain the above copyright notice and this paragraph
 * in its entirety, and (2) distributions including binary code include
 * the above copyright notice and this paragraph in its entirety in
 * the documentation or other materials provided with the distribution.
 * THIS SOFTWARE IS PROVIDED ``AS IS'' AND
 * WITHOUT ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, WITHOUT
 * LIMITATION, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS
 * FOR A PARTICULAR PURPOSE.
 *
 * Original code by Hannes Gredler (hannes@juniper.net)
 */compiled as c/Users/owura/Repos/codeql_eval/proj_repos/the-tcpdump-group-tcpdump-commit-0f95d441e4b5d7512cc5c326c8668a120e048eda/tcpdump/config.h/Users/owura/Repos/codeql_eval/proj_repos/the-tcpdump-group-tcpdump-commit-0f95d441e4b5d7512cc5c326c8668a120e048eda/tcpdump/tcpdump-stdinc.h/Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX.sdk/usr/include/errno.h/Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX.sdk/usr/include/sys/errno.h/Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX.sdk/usr/include/sys/cdefs.h/Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX.sdk/usr/include/sys/_symbol_aliasing.h/Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX.sdk/usr/include/sys/_posix_availability.h/Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX.sdk/usr/include/sys/_types/_errno_t.h/Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX.sdk/usr/include/ctype.h/Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX.sdk/usr/include/_ctype.h/Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX.sdk/usr/include/runetype.h/Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX.sdk/usr/include/_types.h/Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX.sdk/usr/include/sys/_types.h/Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX.sdk/usr/include/machine/_types.h/Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX.sdk/usr/include/i386/_types.h/Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX.sdk/usr/include/sys/_pthread/_pthread_types.h/Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX.sdk/usr/include/sys/_types/_size_t.h17/Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX.sdk/usr/include/sys/_types/_ct_rune_t.h18/Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX.sdk/usr/include/sys/_types/_rune_t.h19/Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX.sdk/usr/include/sys/_types/_wchar_t.h20/Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX.sdk/usr/include/sys/_types/_wint_t.h21/Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX.sdk/usr/include/unistd.h22/Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX.sdk/usr/include/sys/unistd.h23/Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX.sdk/usr/include/sys/_types/_posix_vdisable.h24/Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX.sdk/usr/include/sys/_types/_seek_set.h25/Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX.sdk/usr/include/sys/_types/_ssize_t.h26/Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX.sdk/usr/include/machine/types.h27/Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX.sdk/usr/include/i386/types.h28/Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX.sdk/usr/include/sys/_types/_int8_t.h29/Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX.sdk/usr/include/sys/_types/_int16_t.h30/Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX.sdk/usr/include/sys/_types/_int32_t.h31/Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX.sdk/usr/include/sys/_types/_int64_t.h32/Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX.sdk/usr/include/sys/_types/_u_int8_t.h33/Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX.sdk/usr/include/sys/_types/_u_int16_t.h34/Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX.sdk/usr/include/sys/_types/_u_int32_t.h35/Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX.sdk/usr/include/sys/_types/_u_int64_t.h36/Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX.sdk/usr/include/sys/_types/_intptr_t.h3738/Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX.sdk/usr/include/sys/_types/_uintptr_t.h39/Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX.sdk/usr/include/_types/_uint64_t.h40/Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX.sdk/usr/include/_types/_uint32_t.h41/Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX.sdk/usr/include/Availability.h/Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX.sdk/usr/include/AvailabilityVersions.h43/Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX.sdk/usr/include/AvailabilityInternal.h44/Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX.sdk/usr/include/sys/_types/_uid_t.h45/Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX.sdk/usr/include/sys/_types/_gid_t.h46/Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX.sdk/usr/include/sys/_types/_off_t.h47/Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX.sdk/usr/include/sys/_types/_pid_t.h48/Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX.sdk/usr/include/sys/_types/_useconds_t.h49/Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX.sdk/usr/include/sys/_types/_null.h50/Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX.sdk/usr/include/_ctermid.h51/Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX.sdk/usr/include/sys/select.h52/Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX.sdk/usr/include/sys/appleapiopts.h53/Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX.sdk/usr/include/sys/_types/_fd_def.h54/Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX.sdk/usr/include/sys/_types/_timespec.h55/Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX.sdk/usr/include/sys/_types/_timeval.h56/Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX.sdk/usr/include/sys/_types/_time_t.h57/Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX.sdk/usr/include/sys/_types/_suseconds_t.h58/Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX.sdk/usr/include/sys/_types/_sigset_t.h59/Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX.sdk/usr/include/sys/_types/_fd_setsize.h60/Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX.sdk/usr/include/sys/_types/_fd_set.h/Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX.sdk/usr/include/sys/_types/_fd_clr.h62/Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX.sdk/usr/include/sys/_types/_fd_isset.h63/Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX.sdk/usr/include/sys/_types/_fd_zero.h64/Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX.sdk/usr/include/sys/_types/_fd_copy.h65/Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX.sdk/usr/include/sys/_select.h66/Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX.sdk/usr/include/sys/_types/_dev_t.h67/Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX.sdk/usr/include/sys/_types/_mode_t.h68/Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX.sdk/usr/include/sys/_types/_uuid_t.h69/Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX.sdk/usr/include/gethostuuid.h70/Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX.sdk/usr/include/netdb.h71/Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX.sdk/usr/include/sys/_types/_socklen_t.h72/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/lib/clang/13.1.6/include/stdint.h73/Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX.sdk/usr/include/stdint.h74/Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX.sdk/usr/include/_types/_uint8_t.h75/Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX.sdk/usr/include/_types/_uint16_t.h76/Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX.sdk/usr/include/_types/_intmax_t.h77/Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX.sdk/usr/include/_types/_uintmax_t.h78/Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX.sdk/usr/include/netinet/in.h79/Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX.sdk/usr/include/sys/_types/_in_addr_t.h80/Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX.sdk/usr/include/sys/_types/_in_port_t.h81/Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX.sdk/usr/include/sys/socket.h82/Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX.sdk/usr/include/sys/types.h83/Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX.sdk/usr/include/machine/endian.h84/Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX.sdk/usr/include/i386/endian.h85/Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX.sdk/usr/include/sys/_endian.h86/Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX.sdk/usr/include/libkern/_OSByteOrder.h87/Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX.sdk/usr/include/libkern/i386/_OSByteOrder.h88/Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX.sdk/usr/include/sys/_types/_u_char.h89/Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX.sdk/usr/include/sys/_types/_u_short.h90/Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX.sdk/usr/include/sys/_types/_u_int.h91/Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX.sdk/usr/include/sys/_types/_caddr_t.h92/Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX.sdk/usr/include/sys/_types/_blkcnt_t.h93/Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX.sdk/usr/include/sys/_types/_blksize_t.h94/Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX.sdk/usr/include/sys/_types/_ino_t.h95/Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX.sdk/usr/include/sys/_types/_ino64_t.h96/Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX.sdk/usr/include/sys/_types/_key_t.h97/Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX.sdk/usr/include/sys/_types/_nlink_t.h98/Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX.sdk/usr/include/sys/_types/_id_t.h99/Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX.sdk/usr/include/sys/_types/_clock_t.h100/Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX.sdk/usr/include/sys/_types/_rsize_t.h101/Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX.sdk/usr/include/sys/_pthread/_pthread_attr_t.h102/Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX.sdk/usr/include/sys/_pthread/_pthread_cond_t.h103/Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX.sdk/usr/include/sys/_pthread/_pthread_condattr_t.h104/Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX.sdk/usr/include/sys/_pthread/_pthread_mutex_t.h105/Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX.sdk/usr/include/sys/_pthread/_pthread_mutexattr_t.h106/Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX.sdk/usr/include/sys/_pthread/_pthread_once_t.h107/Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX.sdk/usr/include/sys/_pthread/_pthread_rwlock_t.h108/Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX.sdk/usr/include/sys/_pthread/_pthread_rwlockattr_t.h109/Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX.sdk/usr/include/sys/_pthread/_pthread_t.h110/Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX.sdk/usr/include/sys/_pthread/_pthread_key_t.h111/Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX.sdk/usr/include/sys/_types/_fsblkcnt_t.h112/Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX.sdk/usr/include/sys/_types/_fsfilcnt_t.h113/Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX.sdk/usr/include/machine/_param.h114/Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX.sdk/usr/include/i386/_param.h115/Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX.sdk/usr/include/net/net_kev.h116/Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX.sdk/usr/include/sys/_types/_sa_family_t.h117/Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX.sdk/usr/include/sys/_types/_iovec_t.h118/Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX.sdk/usr/include/netinet6/in6.h119/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/lib/clang/13.1.6/include/inttypes.h120/Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX.sdk/usr/include/inttypes.h121/Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX.sdk/usr/include/sys/param.h123/Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX.sdk/usr/include/sys/syslimits.h124/Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX.sdk/usr/include/machine/param.h125/Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX.sdk/usr/include/i386/param.h126/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/lib/clang/13.1.6/include/limits.h127/Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX.sdk/usr/include/limits.h/Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX.sdk/usr/include/machine/limits.h129/Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX.sdk/usr/include/i386/limits.h130/Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX.sdk/usr/include/i386/_limits.h131/Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX.sdk/usr/include/sys/signal.h132/Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX.sdk/usr/include/machine/signal.h133/Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX.sdk/usr/include/i386/signal.h134/Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX.sdk/usr/include/machine/_mcontext.h135/Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX.sdk/usr/include/i386/_mcontext.h136/Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX.sdk/usr/include/mach/machine/_structs.h137/Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX.sdk/usr/include/mach/i386/_structs.h138/Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX.sdk/usr/include/sys/_types/_sigaltstack.h139/Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX.sdk/usr/include/sys/_types/_ucontext.h140/Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX.sdk/usr/include/sys/time.h141/Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX.sdk/usr/include/sys/_types/_timeval64.h142/Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX.sdk/usr/include/time.h143/Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX.sdk/usr/include/arpa/inet.h144/Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX.sdk/usr/include/pcap.h145/Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX.sdk/usr/include/pcap/pcap.h146/Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX.sdk/usr/include/pcap/funcattrs.h147/Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX.sdk/usr/include/pcap/compiler-tests.h148/Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX.sdk/usr/include/pcap/pcap-inttypes.h149/Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX.sdk/usr/include/pcap/socket.h150/Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX.sdk/usr/include/pcap/bpf.h151/Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX.sdk/usr/include/pcap/dlt.h152/Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX.sdk/usr/include/stdio.h153/Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX.sdk/usr/include/_stdio.h154/Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX.sdk/usr/include/sys/_types/_va_list.h155/Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX.sdk/usr/include/sys/stdio.h156/Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX.sdk/usr/include/secure/_stdio.h157/Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX.sdk/usr/include/secure/_common.h158159160/Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX.sdk/usr/include/signal.h161/Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX.sdk/usr/include/string.h162/Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX.sdk/usr/include/strings.h163164/Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX.sdk/usr/include/secure/_strings.h165/Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX.sdk/usr/include/secure/_string.h/Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX.sdk/usr/include/stdlib.h167/Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX.sdk/usr/include/sys/wait.h168/Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX.sdk/usr/include/sys/resource.h169/Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX.sdk/usr/include/alloca.h170171/Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX.sdk/usr/include/malloc/_malloc.h172173/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/lib/clang/13.1.6/include/stdarg.h174175/Users/owura/Repos/codeql_eval/proj_repos/the-tcpdump-group-tcpdump-commit-0f95d441e4b5d7512cc5c326c8668a120e048eda/tcpdump/netdissect.h176/Users/owura/Repos/codeql_eval/proj_repos/the-tcpdump-group-tcpdump-commit-0f95d441e4b5d7512cc5c326c8668a120e048eda/tcpdump/ip.h177178179180/Users/owura/Repos/codeql_eval/proj_repos/the-tcpdump-group-tcpdump-commit-0f95d441e4b5d7512cc5c326c8668a120e048eda/tcpdump/setsignal.h181182183/Users/owura/Repos/codeql_eval/proj_repos/the-tcpdump-group-tcpdump-commit-0f95d441e4b5d7512cc5c326c8668a120e048eda/tcpdump/addrtoname.c"oui.h""extract.h""setsignal.h""llc.h""addrtoname.h""interface.h"<stdlib.h><string.h><stdio.h><signal.h><pcap-namedb.h><tcpdump-stdinc.h>"config.h"pregisterstaticnumvoid *..(*)(..)sizeof (*ptr)newhnamemem: calloc"newhnamemem: calloc"char[20]tphnamemem[4096]4096HASHNAMESIZE4095(HASHNAMESIZE-1)init_ipxsaparrayitableipxsap_db[i].vconst tok[214]tok[214]const tok *tok *j__builtin_constant_p65280init_etherarrayconst etherlistconst etherlist *etherlist *elenamemem *epfpconst char *__restrict__/etc/etherschar[12]r"r"char[2]const u_char[6]const etherlist[2]etherlist[2]init_protoidarrayprotoidmem *const protoidlistconst protoidlist *protoidlist *plu_char[5]unsigned char[5]protoideproto_db[i].p(char *)&protoid[3](char *)&etype, 2const eprotoconst eproto[]eproto[]const eproto *eproto *etype__builtin___memcpy_chkconst voidconst void *u_short *unsigned short *__builtin_object_sizeconst u_char[5]const protoidlist[6]protoidlist[6]init_eprotoarrayndodnaddrlocalnetmaskinit_servarrayservent *svchar[11]sizeof("0000000000")bufsv->s_portsizeof(buf)"%d", portporttcp"tcp"char[4]udp"udp"__builtin___snprintf_chk%dchar[3]cpchar[5]sizeof("0000")(__uint16_t)portconst char[17]char[17]0xf'\0'char[6]sizeof("00000")"%u", i%unsap_idxISONSAP_MAX_LENGTHisonsap_string: illegal length"isonsap_string: illegal length"char[31]("isonsap_string: illegal length")xx.xxxx.xxxx.xxxx.xxxx.xxxx.xxxx.xxxx.xxxx.xxxx.xx"xx.xxxx.xxxx.xxxx.xxxx.xxxx.xxxx.xxxx.xxxx.xxxx.xx"char[51]"xx.xxxx.xxxx.xxxx.xxxx.xxxx.xxxx.xxxx.xxxx.xxxx.xx")sizeof("xx.xxxx.xxxx.xxxx.xxxx.xxxx.xxxx.xxxx.xxxx.xxxx.xx")isonsap_string: malloc"isonsap_string: malloc"char[23]'.'char[15]sizeof("00:00:00:00:00")':'nsapnsap_lengthpi<empty>"<empty>"char[8]("<empty>")ETHER_ADDR_LENlinkaddr_string: malloc"linkaddr_string: malloc"char[24]char[128]ouiBUFSIZE - (2 + 5*3)128 - (2 + 5*3)" (oui %s)", tok2str(oui_values, "Unknown", oui) (oui %s)char[10]Unknownlookup_protoidprotoidmem[4096]sizeof(*tp)lookup_protoid: calloc"lookup_protoid: calloc"lookup_nsapknlenensapenamemem[4096]lookup_nsap: malloc"lookup_nsap: malloc"(char *)tp->e_nsap(const char *)nsap, nlen + 1typelookup_nsap: calloc"lookup_nsap: calloc"lookup_bytestringlookup_bytestring: calloc"lookup_bytestring: calloc"char[26]tp->e_bstp->e_nsapbs, nlenlookup_ememlookup_emem: calloc"lookup_emem: calloc"hostent *hp&addrap, sizeof(addr)uint32_t *AF_INETdotpbytensizeof(".xxx.xxx.xxx.xxx")(__uint32_t)addr427819008016711680'0'etherlistprotoidlisteprotoprotoidmemenamememsp_nxtp_namep_protop_ouie_nxte_nsape_namee_addr2e_addr1e_addr0nxt0x0000"Unknown"User"User"User Group"User Group"PrintQueue"PrintQueue"FileServer"FileServer"JobServer"JobServer"0x0006Gateway"Gateway"PrintServer"PrintServer"ArchiveQueue"ArchiveQueue"char[13]ArchiveServer"ArchiveServer"char[14]JobQueue"JobQueue"char[9]Administration"Administration"0x000FNovell TI-RPC"Novell TI-RPC"0x0017Diagnostics"Diagnostics"0x0020NetBIOS"NetBIOS"0x0021NAS SNA Gateway"NAS SNA Gateway"char[16]0x0023NACS AsyncGateway"NACS AsyncGateway"char[18]0x0024RemoteBridge/RoutingService"RemoteBridge/RoutingService"char[28]0x0026BridgeServer"BridgeServer"0x0027TCP/IP Gateway"TCP/IP Gateway"0x0028Point-to-point X.25 BridgeServer"Point-to-point X.25 BridgeServer"char[33]0x00293270 Gateway"3270 Gateway"0x002aCHI Corp"CHI Corp"0x002cPC Chalkboard"PC Chalkboard"0x002dTimeSynchServer"TimeSynchServer"0x002eARCserve5.0/PalindromeBackup"ARCserve5.0/PalindromeBackup"char[29]0x0045DI3270 Gateway"DI3270 Gateway"0x0047AdvertisingPrintServer"AdvertisingPrintServer"0x004aNetBlazerModems"NetBlazerModems"bsap0x004bBtrieveVAP"BtrieveVAP"0x004cNetwareSQL"NetwareSQL"0x004dXtreeNetwork"XtreeNetwork"0x0050BtrieveVAP4.11"BtrieveVAP4.11"0x0052QuickLink"QuickLink"0x0053PrintQueueUser"PrintQueueUser"0x0058Multipoint X.25 Router"Multipoint X.25 Router"0x0060STLB/NLM"STLB/NLM"0x0064ARCserve"ARCserve"0x0066ARCserve3.0"ARCserve3.0"0x0072WAN CopyUtility"WAN CopyUtility"0x007aTES-NetwareVMS"TES-NetwareVMS"0x0092WATCOM Debugger/EmeraldTapeBackupServer"WATCOM Debugger/EmeraldTapeBackupServer"char[40]0x0095DDA OBGYN"DDA OBGYN"0x0098NetwareAccessServer"NetwareAccessServer"0x009aNetware for VMS II/NamedPipeServer"Netware for VMS II/NamedPipeServer"char[35]0x009b0x009ePortableNetwareServer/SunLinkNVT"PortableNetwareServer/SunLinkNVT"0x00a1PowerchuteAPC UPS"PowerchuteAPC UPS"0x00aaLAWserve"LAWserve"0x00acCompaqIDA StatusMonitor"CompaqIDA StatusMonitor"256PIPE STAIL"PIPE STAIL"2580x0102LAN ProtectBindery"LAN ProtectBindery"char[19]2590x0103OracleDataBaseServer"OracleDataBaseServer"char[21]2630x0107Netware386/RSPX RemoteConsole"Netware386/RSPX RemoteConsole"char[30]2710x010fNovellSNA Gateway"NovellSNA Gateway"273TestServer"TestServer"2740x0112HP PrintServer"HP PrintServer"2760x0114CSA MUX"CSA MUX"2770x0115CSA LCA"CSA LCA"2780x0116CSA CM"CSA CM"char[7]2790x0117CSA SMA"CSA SMA"2800x0118CSA DBA"CSA DBA"2810x0119CSA NMA"CSA NMA"2820x011aCSA SSA"CSA SSA"2830x011bCSA STATUS"CSA STATUS"2860x011eCSA APPC"CSA APPC"2940x0126SNA TEST SSA Profile"SNA TEST SSA Profile"2980x012aCSA TRACE"CSA TRACE"2990x012bNetwareSAA"NetwareSAA"3020x012eIKARUS VirusScan"IKARUS VirusScan"3040x0130CommunicationsExecutive"CommunicationsExecutive"0x0133NNS DomainServer/NetwareNamingServicesDomain"NNS DomainServer/NetwareNamingServicesDomain"char[45]3090x0135NetwareNamingServicesProfile"NetwareNamingServicesProfile"0x0137Netware386 PrintQueue/NNS PrintQueue"Netware386 PrintQueue/NNS PrintQueue"char[37]3210x0141LAN SpoolServer"LAN SpoolServer"3380x0152IRMALAN Gateway"IRMALAN Gateway"3400x0154NamedPipeServer"NamedPipeServer"3580x0166NetWareManagement"NetWareManagement"3600x0168Intel PICKIT CommServer/Intel CAS TalkServer"Intel PICKIT CommServer/Intel CAS TalkServer"3710x0173Compaq"Compaq"3720x0174Compaq SNMP Agent"Compaq SNMP Agent"3730x01753840x0180XTreeServer/XTreeTools"XTreeServer/XTreeTools"3940x018ANASI ServicesBroadcastServer"NASI ServicesBroadcastServer"4320x01b0GARP Gateway"GARP Gateway"4330x01b1Binfview"Binfview"4470x01bfIntelLanDeskManager"IntelLanDeskManager"4580x01caAXTEC"AXTEC"4590x01cbShivaNetModem/E"ShivaNetModem/E"4600x01ccShivaLanRover/E"ShivaLanRover/E"4610x01cdShivaLanRover/T"ShivaLanRover/T"4620x01ceShivaUniversal"ShivaUniversal"4720x01d8CastelleFAXPressServer"CastelleFAXPressServer"4740x01daCastelleLANPressPrintServer"CastelleLANPressPrintServer"4760x01dcCastelleFAX/Xerox7033 FaxServer/ExcelLanFax"CastelleFAX/Xerox7033 FaxServer/ExcelLanFax"char[44]4960x01f0LEGATO"LEGATO"5010x01f55630x0233NMS Agent/NetwareManagementAgent"NMS Agent/NetwareManagementAgent"5670x0237NMS IPX Discovery/LANternReadWriteChannel"NMS IPX Discovery/LANternReadWriteChannel"char[42]5680x0238NMS IP Discovery/LANternTrapAlarmChannel"NMS IP Discovery/LANternTrapAlarmChannel"char[41]5700x023aLANtern"LANtern"5720x023cMAVERICK"MAVERICK"5750x023fNovellSMDR"NovellSMDR"5900x024eNetwareConnect"NetwareConnect"5910x024fNASI ServerBroadcast Cisco"NASI ServerBroadcast Cisco"char[27]6180x026aNMS ServiceConsole"NMS ServiceConsole"6190x026bTimeSynchronizationServer Netware 4.x"TimeSynchronizationServer Netware 4.x"char[38]6320x0278DirectoryServer Netware 4.x"DirectoryServer Netware 4.x"6350x027bNetwareManagementAgent"NetwareManagementAgent"6400x0280Novell File and Printer Sharing Service for PC"Novell File and Printer Sharing Service for PC"char[47]7720x0304NovellSAA Gateway"NovellSAA Gateway"7760x0308COM/VERMED"COM/VERMED"7780x030aGalacticommWorldgroupServer"GalacticommWorldgroupServer"7800x030cIntelNetport2/HP JetDirect/HP Quicksilver"IntelNetport2/HP JetDirect/HP Quicksilver"8000x0320AttachmateGateway"AttachmateGateway"8070x0327MicrosoftDiagnostiocs"MicrosoftDiagnostiocs"char[22]8080x0328WATCOM SQL Server"WATCOM SQL Server"8210x0335MultiTechSystems MultisynchCommServer"MultiTechSystems MultisynchCommServer"8350x0343Xylogics RemoteAccessServer/LANModem"Xylogics RemoteAccessServer/LANModem"8530x0355ArcadaBackupExec"ArcadaBackupExec"8560x0358MSLCD1"MSLCD1"8650x0361NETINELO"NETINELO"8940x037ePowerchute UPS Monitoring"Powerchute UPS Monitoring"8950x037fViruSafeNotify"ViruSafeNotify"9020x0386HP Bridge"HP Bridge"9030x0387HP Hub"HP Hub"9160x0394NetWare SAA Gateway"NetWare SAA Gateway"9230x039bLotusNotes"LotusNotes"9510x03b7CertusAntiVirus"CertusAntiVirus"9640x03c4ARCserve4.0"ARCserve4.0"9670x03c7LANspool3.5"LANspool3.5"9830x03d7LexmarkPrinterServer"LexmarkPrinterServer"9840x03d8LexmarkXLE PrinterServer"LexmarkXLE PrinterServer"char[25]9890x03ddBanyanENS NetwareClient"BanyanENS NetwareClient"9900x03deGuptaSequelBaseServer/NetWareSQL"GuptaSequelBaseServer/NetWareSQL"9930x03e1UnivelUnixware"UnivelUnixware"9960x03e410200x03fcIntelNetport"IntelNetport"10210x03fdPrintServerQueue"PrintServerQueue"10340x040AipnServer"ipnServer"10370x040DLVERRMAN"LVERRMAN"10380x040ELVLIC"LVLIC"10440x0414NET Silicon (DPI)/Kyocera"NET Silicon (DPI)/Kyocera"10650x0429SiteLockVirus"SiteLockVirus"10740x0432UFHELPR???"UFHELPR???"10750x0433Synoptics281xAdvancedSNMPAgent"Synoptics281xAdvancedSNMPAgent"10920x0444MicrosoftNT SNA Server"MicrosoftNT SNA Server"10960x0448Oracle"Oracle"11000x044cARCserve5.01"ARCserve5.01"11110x0457CanonGP55"CanonGP55"11140x045aQMS Printers"QMS Printers"11150x045bDellSCSI Array"DellSCSI Array"11690x049111960x04acOnTimeScheduler"OnTimeScheduler"12000x04b0CD-Net"CD-Net"12990x0513EmulexNQA"EmulexNQA"13120x0520SiteLockChecks"SiteLockChecks"13210x052913250x052dCitrixOS2 AppServer"CitrixOS2 AppServer"13330x0535Tektronix"Tektronix"13340x0536Milan"Milan"13730x055dAttachmate SNA gateway"Attachmate SNA gateway"13870x056bIBM8235 ModemServer"IBM8235 ModemServer"13880x056cShivaLanRover/E PLUS"ShivaLanRover/E PLUS"13890x056dShivaLanRover/T PLUS"ShivaLanRover/T PLUS"14080x0580McAfeeNetShield"McAfeeNetShield"14640x05B8NLM to workstation communication (Revelation Software)"NLM to workstation communication (Revelation Software)"char[55]14660x05BACompatibleSystemsRouters"CompatibleSystemsRouters"14700x05BECheyenneHierarchicalStorageManager"CheyenneHierarchicalStorageManager"15420x0606JCWatermarkImaging"JCWatermarkImaging"15480x060cAXISNetworkPrinter"AXISNetworkPrinter"15520x0610AdaptecSCSIManagement"AdaptecSCSIManagement"15690x0621IBM AntiVirus"IBM AntiVirus"16000x0640Windows95 RemoteRegistryService"Windows95 RemoteRegistryService"char[32]16140x064eMicrosoftIIS"MicrosoftIIS"16590x067bMicrosoft Win95/98 File and Print Sharing for NetWare"Microsoft Win95/98 File and Print Sharing for NetWare"char[54]16600x067c19000x076CXerox"Xerox"19470x079bShivaLanRover/E 115"ShivaLanRover/E 115"19480x079cShivaLanRover/T 115"ShivaLanRover/T 115"19720x07B4CubixWorldDesk"CubixWorldDesk"19860x07c2Quarterdeck IWare Connect V2.x NLM"Quarterdeck IWare Connect V2.x NLM"19850x07c1Quarterdeck IWare Connect V3.x NLM"Quarterdeck IWare Connect V3.x NLM"20640x0810ELAN License Server Demo"ELAN License Server Demo"20840x0824ShivaLanRoverAccessSwitch/E"ShivaLanRoverAccessSwitch/E"21540x086aISSC Collector"ISSC Collector"21750x087fISSC DAS AgentAIX"ISSC DAS AgentAIX"21760x0880Intel Netport PRO"Intel Netport PRO"21770x088128570x0b29SiteLock"SiteLock"31130x0c29SiteLockApplications"SiteLockApplications"31160x0c2cLicensingServer"LicensingServer"84490x2101PerformanceTechnologyInstantInternet"PerformanceTechnologyInstantInternet"90880x2380LAI SiteLock"LAI SiteLock"91000x238cMeetingMaker"MeetingMaker"184400x4808SiteLockServer/SiteLockMetering"SiteLockServer/SiteLockMetering"218450x5555SiteLockUser"SiteLockUser"253620x6312Tapeware"Tapeware"284160x6f00RabbitGateway"RabbitGateway"304670x7703MODEM"MODEM"327700x8002NetPortPrinters"NetPortPrinters"327760x8008WordPerfectNetworkVersion"WordPerfectNetworkVersion"342380x85BECisco EIGRP"Cisco EIGRP"349520x8888WordPerfectNetworkVersion/QuickNetworkManagement"WordPerfectNetworkVersion/QuickNetworkManagement"char[49]368640x9000384040x9604CSA-NT_MON"CSA-NT_MON"467600xb6a8OceanIsleReachoutRemoteControl"OceanIsleReachoutRemoteControl"617270xf11fSiteLockMetering"SiteLockMetering"619510xf1ff627230xf503Microsoft SQL Server"Microsoft SQL Server"637490xF905IBM TimeAndPlace"IBM TimeAndPlace"645070xfbfbTopCallIII FaxServer"TopCallIII FaxServer"655350xffffAnyService/Wildcard"AnyService/Wildcard"(char *)0ipxsap_dbconst etherlist[]etherlist[]Broadcast"Broadcast"const protoidlist[]protoidlist[]0x0c0x010x07CiscoMLS"CiscoMLS"0x20CiscoCDP"CiscoCDP"CiscoCGMP"CiscoCGMP"CiscoVTP"CiscoVTP"2240x2b1870xbbExtremeEDP"ExtremeEDP"eproto_dbconst char[]char[]0123456789abcdef"0123456789abcdef"hexf_localnetf_netmaskprotoidtablebytestringtablensaptableenametableipxsaptablednaddrtableeprototableuporttabletporttablehnametablee_bsHAVE_CONFIG_HUSE_ETHER_NTOHOSTHAVE_NETINET_IF_ETHER_HNETINET_ETHER_H_DECLARES_ETHER_NTOHOST!defined(HAVE_DECL_ETHER_NTOHOST) || !HAVE_DECL_ETHER_NTOHOSTHAVE_STRUCT_ETHER_ADDRdefined(INET6) && defined(WIN32)defined(WIN32) && !defined(USE_STATIC_LIBPCAP)/* INET6 *//* Return a zero'ed h6namemem struct and cuts down on calloc() overhead *//* Return a zero'ed hnamemem struct and cuts down on calloc() overhead *//*
		 * Simplest way to suppress names.
		 *//*
 * Initialize the address to name translation machinery.  We map all
 * non-local IP addresses to numeric addresses if ndo->ndo_fflag is true
 * (i.e., to prevent blocking on the nameserver).  localnet is the IP address
 * of the local network.  mask is its subnet mask.
 *//*
		 * Use YP/NIS version of name if available.
		 *
		 * We don't cast it to "const struct ether_addr *"
		 * because some systems don't modify the Ethernet
		 * address but fail to declare the second argument
		 * as a "const" pointer.
		 *//* Don't override existing name *//* Hardwire some ethernet names *//* Suck in entire ethers file *//*
 * Initialize the ethers hash table.  We take two different approaches
 * depending on whether or not the system provides the ethers name
 * service.  If it does, we just wire in a few names at startup,
 * and etheraddr_string() fills in the table on demand.  If it doesn't,
 * then we suck in the entire /etc/ethers file at startup.  The idea
 * is that parsing the local file will be fast, but spinning through
 * all the ethers entries via NIS & next_etherent might be very slow.
 *
 * XXX pcap_next_etherent doesn't belong in the pcap interface, but
 * since the pcap module already does name-to-address translation,
 * it's already does most of the work for the ethernet address-to-name
 * translation, so we just pcap_next_etherent as a convenience.
 *//* Hardwire some SNAP proto ID names *//*
 * SNAP proto IDs with org code 0:0:0 are actually encapsulated Ethernet
 * types.
 *//* in libpcap.a (nametoaddr.c) *//*
		 * We don't cast it to "const struct ether_addr *"
		 * because some systems fail to declare the second
		 * argument as a "const" pointer, even though they
		 * don't modify what it points to.
		 *//* XXX should be endian-insensitive, but do big-endian testing  XXX *//* 5 octets won't be aligned *//* Find the hash node that corresponds the protoid 'pi'. *//* Find the hash node that corresponds the NSAP 'nsap' *//*
 * Find the hash node that corresponds to the bytestring 'bs'
 * with length 'nlen'
 *//* Find the hash node that corresponds the ether address 'ep' *//* Remove domain qualifications *//*
	 * Do not print names if -n was given.
	 *//* static for longjmp() *//*
 * Return a name for the IP6 address pointed to by ap.  This address
 * is assumed to be in network byte order.
 *//*
	 * Print names unless:
	 *	(1) -n was given.
	 *      (2) Address is foreign and -f was given. (If -f was not
	 *	    given, f_netmask and f_localnet are 0 and the test
	 *	    evaluates to true)
	 *//*
 * Return a name for the IP address pointed to by ap.  This address
 * is assumed to be in network byte order.
 *
 * NOTE: ap is *NOT* necessarily part of the packet data (not even if
 * this is being called with the "ipaddr_string()" macro), so you
 * *CANNOT* use the TCHECK{2}/TTEST{2} macros on it.  Furthermore,
 * even in cases where it *is* part of the packet data, the caller
 * would still have to check for a null return value, even if it's
 * just printing the return value with "%s" - not all versions of
 * printf print "(null)" with "%s" and a null pointer, some of them
 * don't check for a null pointer and crash in that case.
 *
 * The callers of this routine should, before handing this routine
 * a pointer to packet data, be sure that the data is present in
 * the packet buffer.  They should probably do those checks anyway,
 * as other data at that layer might not be IP addresses, and it
 * also needs to check whether they're present in the packet buffer.
 *//*
 * A faster replacement for inet_ntoa().
 *//* for bytestringtable *//* used only for nsaptable[] *//* INET6 & WIN32 *//*
 * fake gethostbyaddr for Win2k/XP
 * gethostbyaddr() returns incorrect value when AF_INET6 is passed
 * to 3rd argument.
 *
 * h_name in struct hostent is only valid.
 *//*
 * hash tables for whatever-to-name translations
 *
 * XXX there has to be error checks against strdup(3) failure
 *//* USE_ETHER_NTOHOST *//* NETINET_ETHER_H_DECLARES_ETHER_NTOHOST *//* HAVE_NETINET_IF_ETHER_H *//* for "struct ifnet" in "struct arpcom" on Solaris *//* declarations in <net/if.h> *//* Squelch compiler warnings on some platforms for *//*
 * Copyright (c) 1990, 1991, 1992, 1993, 1994, 1995, 1996, 1997
 *	The Regents of the University of California.  All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that: (1) source code distributions
 * retain the above copyright notice and this paragraph in its entirety, (2)
 * distributions including binary code include the above copyright notice and
 * this paragraph in its entirety in the documentation or other materials
 * provided with the distribution, and (3) all advertising materials mentioning
 * features or use of this software display the following acknowledgement:
 * ``This product includes software developed by the University of California,
 * Lawrence Berkeley Laboratory and its contributors.'' Neither the name of
 * the University nor the names of its contributors may be used to endorse
 * or promote products derived from this software without specific prior
 * written permission.
 * THIS SOFTWARE IS PROVIDED ``AS IS'' AND WITHOUT ANY EXPRESS OR IMPLIED
 * WARRANTIES, INCLUDING, WITHOUT LIMITATION, THE IMPLIED WARRANTIES OF
 * MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE.
 *
 *  Internet, ethernet, port, and protocol string to address
 *  and address to string conversion routines
 */__va_list_tag[1]__gnuc_va_listva_list__GNUC_VA_LISTva_copy(dest,src)__builtin_va_copy(dest, src)__va_copy(d,s)__builtin_va_copy(d,s)va_arg(ap,type)__builtin_va_arg(ap, type)va_end(ap)__builtin_va_end(ap)va_start(ap,param)__builtin_va_start(ap, param)_VA_LIST__STDARG_H__STDC_VERSION__ >= 199901L || __cplusplus >= 201103L || !defined(__STRICT_ANSI__)__STDC_VERSION__201710L/* __STDARG_H *//* GCC always defines __va_copy, but does not define va_copy unless in c99 mode
 * or -ansi is not specified, since it was not part of C90.
 *//*===---- stdarg.h - Variable argument handling ----------------------------===
 *
 * Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.
 * See https://llvm.org/LICENSE.txt for license information.
 * SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
 *
 *===-----------------------------------------------------------------------===
 *//Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/lib/clang/13.1.6/include/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/lib/clang/13.1.6/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/lib/clang/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/lib/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/Applications/Xcode.app/Contents/Developer/Toolchains<machine/types.h>_VA_LIST_T/* _VA_LIST_T *//* __darwin_va_list *//*
 * Copyright (c) 2012 Apple Inc. All rights reserved.
 *
 * @APPLE_OSREFERENCE_LICENSE_HEADER_START@
 *
 * This file contains Original Code and/or Modifications of Original Code
 * as defined in and that are subject to the Apple Public Source License
 * Version 2.0 (the 'License'). You may not use this file except in
 * compliance with the License. The rights granted to you under the License
 * may not be used to create, or enable the creation or redistribution of,
 * unlawful or unlicensed copies of an Apple operating system, or to
 * circumvent, violate, or enable the circumvention or violation of, any
 * terms of an Apple operating system software license agreement.
 *
 * Please obtain a copy of the License at
 * http://www.opensource.apple.com/apsl/ and read it before using this file.
 *
 * The Original Code and all software distributed under the License are
 * distributed on an 'AS IS' basis, WITHOUT WARRANTY OF ANY KIND, EITHER
 * EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES,
 * INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE, QUIET ENJOYMENT OR NON-INFRINGEMENT.
 * Please see the License for the specific language governing rights and
 * limitations under the License.
 *
 * @APPLE_OSREFERENCE_LICENSE_HEADER_END@
 *//Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX.sdk/usr/include/sys/_types/Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX.sdk/usr/include/sys/Users/owura/Repos/codeql_eval/proj_repos/the-tcpdump-group-tcpdump-commit-0f95d441e4b5d7512cc5c326c8668a120e048eda/tcpdump/af.hBSD_AFNUM_INET6_DARWINBSD_AFNUM_INET6_FREEBSDBSD_AFNUM_INET6_BSDBSD_AFNUM_IPXBSD_AFNUM_APPLETALKBSD_AFNUM_ISOBSD_AFNUM_NSBSD_AFNUM_INETAFNUM_L2VPN196AFNUM_VPLSAFNUM_E164NSAPAFNUM_BANYANAFNUM_DECNETAFNUM_ATALKAFNUM_IPXAFNUM_X121AFNUM_F69AFNUM_E164AFNUM_E163AFNUM_802AFNUM_BBN1822AFNUM_HDLCAFNUM_NSAPAFNUM_INET6AFNUM_INETbsd_af_valuesaf_values/* OpenBSD (and probably NetBSD), BSD/OS *//* XEROX NS protocols *//*
 * BSD AF_ values.
 *
 * Unfortunately, the BSDs don't all use the same value for AF_INET6,
 * so, because we want to be able to read captures from all of the BSDs,
 * we check for all of them.
 *//* still to be approved by IANA *//* draft-kompella-ppvpn-l2vpn *//* RFC1700 address family numbers *//*
 * Copyright (c) 1998-2006 The TCPDUMP project
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that: (1) source code
 * distributions retain the above copyright notice and this paragraph
 * in its entirety, and (2) distributions including binary code include
 * the above copyright notice and this paragraph in its entirety in
 * the documentation or other materials provided with the distribution.
 * THIS SOFTWARE IS PROVIDED ``AS IS'' AND
 * WITHOUT ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, WITHOUT
 * LIMITATION, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS
 * FOR A PARTICULAR PURPOSE.
 *
 * Original code by Hannes Gredler (hannes@juniper.net)
 *//Users/owura/Repos/codeql_eval/proj_repos/the-tcpdump-group-tcpdump-commit-0f95d441e4b5d7512cc5c326c8668a120e048eda/tcpdump/af.c"af.h"const tok[9]tok[9]IPv4"IPv4"NS"NS"ISO"ISO"Appletalk"Appletalk"IPX"IPX"IPv6"IPv6"const tok[19]tok[19]Reserved"Reserved"NSAP"NSAP"HDLC"HDLC"BBN 1822"BBN 1822"802"802"E.163"E.163"E.164"E.164"F.69"F.69"X.121"X.121"Novell IPX"Novell IPX"Decnet IV"Decnet IV"Banyan Vines"Banyan Vines"E.164 with NSAP subaddress"E.164 with NSAP subaddress"Layer-2 VPN"Layer-2 VPN"VPLS"VPLS"/Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX.sdk/usr/include/assert.h<sys/cdefs.h>__assert_rtnstatic_assert_Static_assert_ASSERT_H_assert(e)(__builtin_expect(!(e), 0) ? __assert_rtn(__func__, __ASSERT_FILE_NAME, __LINE__, #e) : (void)0)__assert(e,file,line)__assert_rtn ((const char *)-1L, file, line, e)__ASSERT_FILE_NAME__FILE____assertassertNDEBUG__FILE_NAME__defined(__ENVIRONMENT_MAC_OS_X_VERSION_MIN_REQUIRED__) && ((__ENVIRONMENT_MAC_OS_X_VERSION_MIN_REQUIRED__-0) < 1070)__DARWIN_UNIX03defined(__STDC_VERSION__) && __STDC_VERSION__ >= 201112Lcold__ENVIRONMENT_MAC_OS_X_VERSION_MIN_REQUIRED__120000/* _ASSERT_H_ *//* !__cplusplus *//* __STDC_VERSION__ *//* NDEBUG *//* __GNUC__ *//* __DARWIN_UNIX03 *//* !__DARWIN_UNIX03 *//* 8462256: modified __assert_rtn() replaces deprecated __eprintf() *//* __FILE_NAME__ *//*
 * Unlike other ANSI header files, <assert.h> may usefully be included
 * multiple times, with and without NDEBUG defined.
 *//* __cplusplus *//*-
 * Copyright (c) 1992, 1993
 *	The Regents of the University of California.  All rights reserved.
 * (c) UNIX System Laboratories, Inc.
 * All or some portions of this file are derived from material licensed
 * to the University of California by American Telephone and Telegraph
 * Co. or Unix System Laboratories, Inc. and are reproduced herein with
 * the permission of UNIX System Laboratories, Inc.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *	This product includes software developed by the University of
 *	California, Berkeley and its contributors.
 * 4. Neither the name of the University nor the names of its contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 *
 *	@(#)assert.h	8.2 (Berkeley) 1/21/94
 * $FreeBSD: src/include/assert.h,v 1.4 2002/03/23 17:24:53 imp Exp $
 *//Users/owura/Repos/codeql_eval/proj_repos/the-tcpdump-group-tcpdump-commit-0f95d441e4b5d7512cc5c326c8668a120e048eda/tcpdump/checksum.c<assert.h>xymulc0c1checksumindex0x00FF10230x3ffconst uint16_tconst uint16_t[256]unsigned short[256]const uint16_t *init_crc10_tableaccumuint16_t[256]verify_crc10_table10240x4001587CRC10_POLYNOMIALuint16_t *memcmp(verify_crc10_table, crc10_table, sizeof(verify_crc10_table)) == 0__builtin_expect512__func__./checksum.cchar[73]crc10_table0x633/*
         * Ignore the contents of the checksum field.
         *//*
 * Creates the OSI Fletcher checksum. See 8473-1, Appendix C, section C.3.
 * The checksum field of the passed PDU does not need to be reset to zero.
 *//* precompute checksum tables *//*
 * CRC-10 table generated using the following Python snippet:

import sys

crc_table = []
for i in range(256):
	accum = i << 2
	for j in range(8):
		accum <<= 1
		if accum & 0x400:
			accum ^= 0x633
	crc_table.append(accum)

for i in range(len(crc_table)/8):
	for j in range(8):
		sys.stdout.write("0x%04x, " % crc_table[i*8+j])
	sys.stdout.write("\n")

 *//*
 * Copyright (c) 1998-2006 The TCPDUMP project
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that: (1) source code
 * distributions retain the above copyright notice and this paragraph
 * in its entirety, and (2) distributions including binary code include
 * the above copyright notice and this paragraph in its entirety in
 * the documentation or other materials provided with the distribution.
 * THIS SOFTWARE IS PROVIDED ``AS IS'' AND
 * WITHOUT ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, WITHOUT
 * LIMITATION, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS
 * FOR A PARTICULAR PURPOSE.
 *
 * miscellaneous checksumming routines
 *
 * Original code by Hannes Gredler (hannes@juniper.net)
 */pptrchecksum_offsetlength/Users/owura/Repos/codeql_eval/proj_repos/the-tcpdump-group-tcpdump-commit-0f95d441e4b5d7512cc5c326c8668a120e048eda/tcpdump/cpack.hcpack_statec_lenuint8_t *c_nextc_bufcpack_int64(__s,__p)cpack_uint64((__s), (uint64_t*)(__p))cpack_int32(__s,__p)cpack_uint32((__s), (uint32_t*)(__p))cpack_int16(__s,__p)cpack_uint16((__s), (uint16_t*)(__p))cpack_int8(__s,__p)cpack_uint8((__s), (uint8_t*)(__p))_CPACK_Hcpack_advancecpack_state *const size_tcpack_align_and_reservecpack_next_boundarycpack_uint64uint64_t *unsigned long long *cpack_uint32cpack_uint16cpack_uint8cpack_init/* _CPACK_H *//*-
 * Copyright (c) 2003, 2004 David Young.  All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. The name of David Young may not be used to endorse or promote
 *    products derived from this software without specific prior
 *    written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY DAVID YOUNG ``AS IS'' AND ANY
 * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
 * THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A
 * PARTICULAR PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL DAVID
 * YOUNG BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
 * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED
 * TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
 * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
 * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
 * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY
 * OF SUCH DAMAGE.
 */cswordsizealignment/Users/owura/Repos/codeql_eval/proj_repos/the-tcpdump-group-tcpdump-commit-0f95d441e4b5d7512cc5c326c8668a120e048eda/tcpdump/cpack.c"cpack.h"nextsizeof(*u)0, sizeof(*cs)__builtin___memset_chkmisalignment/* Move pointer past the uint8_t. *//* No space left? *//* Unpack an 8-bit unsigned integer. *//* Move pointer past the uint16_t. *//* Unpack a 16-bit unsigned integer. *//* Move pointer past the uint32_t. *//* Unpack a 32-bit unsigned integer. *//* Move pointer past the uint64_t. *//* Unpack a 64-bit unsigned integer. *//* Advance by N bytes without returning them. *//* Too little space for wordsize bytes? *//* Ensure alignment. *//* Advance to the next wordsize boundary. Return NULL if fewer than
 * wordsize bytes remain in the buffer after the boundary.  Otherwise,
 * return a pointer to the boundary.
 */ubuflentoskip/Users/owura/Repos/codeql_eval/proj_repos/the-tcpdump-group-tcpdump-commit-0f95d441e4b5d7512cc5c326c8668a120e048eda/tcpdump/gmpls.hGMPLS_FSC200GMPLS_LSCGMPLS_TSCGMPLS_L2SCGMPLS_PSC4GMPLS_PSC3GMPLS_PSC2GMPLS_PSC1lmp_sd_service_config_cpsa_signal_type_sonet_valueslmp_sd_service_config_cpsa_signal_type_sdh_valueslmp_sd_service_config_cpsa_link_type_valuesdiffserv_te_bc_valuesgmpls_payload_valuesgmpls_encoding_valuesgmpls_switch_cap_tsc_indication_valuesgmpls_switch_cap_valuesgmpls_link_prot_values/Users/owura/Repos/codeql_eval/proj_repos/the-tcpdump-group-tcpdump-commit-0f95d441e4b5d7512cc5c326c8668a120e048eda/tcpdump/gmpls.c"gmpls.h"const tok[4]tok[4]DIFFSERV_BC_MODEL_RDMRussian dolls"Russian dolls"DIFFSERV_BC_MODEL_MAMMaximum allocation"Maximum allocation"254DIFFSERV_BC_MODEL_EXTD_MAMMaximum allocation with E-LSP support"Maximum allocation with E-LSP support"STS-1 SPE"STS-1 SPE"STS-3c SPE"STS-3c SPE"STS-1"STS-1"STM-3"STM-3"STM-12"STM-12"STM-48"STM-48"STM-192"STM-192"STM-768"STM-768"VC-3"VC-3"VC-4"VC-4"STM-0"STM-0"STM-1"STM-1"STM-4"STM-4"STM-16"STM-16"STM-64"STM-64"STM-256"STM-256"const tok[3]tok[3]SDH ITU-T G.707"SDH ITU-T G.707"SONET ANSI T1.105"SONET ANSI T1.105"const tok[60]tok[60]Asynchronous mapping of E4"Asynchronous mapping of E4"Asynchronous mapping of DS3/T3"Asynchronous mapping of DS3/T3"Asynchronous mapping of E3"Asynchronous mapping of E3"Bit synchronous mapping of E3"Bit synchronous mapping of E3"Byte synchronous mapping of E3"Byte synchronous mapping of E3"Asynchronous mapping of DS2/T2"Asynchronous mapping of DS2/T2"Bit synchronous mapping of DS2/T2"Bit synchronous mapping of DS2/T2"char[34]Asynchronous mapping of E1"Asynchronous mapping of E1"Byte synchronous mapping of E1"Byte synchronous mapping of E1"Byte synchronous mapping of 31 * DS0"Byte synchronous mapping of 31 * DS0"Asynchronous mapping of DS1/T1"Asynchronous mapping of DS1/T1"Bit synchronous mapping of DS1/T1"Bit synchronous mapping of DS1/T1"Byte synchronous mapping of DS1/T1"Byte synchronous mapping of DS1/T1"VC-11 in VC-12"VC-11 in VC-12"DS1 SF Asynchronous"DS1 SF Asynchronous"DS1 ESF Asynchronous"DS1 ESF Asynchronous"DS3 M23 Asynchronous"DS3 M23 Asynchronous"DS3 C-Bit Parity Asynchronous"DS3 C-Bit Parity Asynchronous"VT/LOVC"VT/LOVC"STS SPE/HOVC"STS SPE/HOVC"POS - No Scrambling, 16 bit CRC"POS - No Scrambling, 16 bit CRC"POS - No Scrambling, 32 bit CRC"POS - No Scrambling, 32 bit CRC"POS - Scrambling, 16 bit CRC"POS - Scrambling, 16 bit CRC"POS - Scrambling, 32 bit CRC"POS - Scrambling, 32 bit CRC"ATM mapping"ATM mapping"Ethernet PHY"Ethernet PHY"SONET/SDH"SONET/SDH"Reserved (SONET deprecated)"Reserved (SONET deprecated)"Digital Wrapper"Digital Wrapper"Lambda"Lambda"ANSI/ETSI PDH"ANSI/ETSI PDH"Link Access Protocol SDH (X.85 and X.86)"Link Access Protocol SDH (X.85 and X.86)"FDDI"FDDI"DQDB (ETSI ETS 300 216)"DQDB (ETSI ETS 300 216)"FiberChannel-3 (Services)"FiberChannel-3 (Services)"Ethernet V2/DIX (only)"Ethernet V2/DIX (only)"Ethernet 802.3 (only)"Ethernet 802.3 (only)"G.709 ODUj"G.709 ODUj"G.709 OTUk(v)"G.709 OTUk(v)"CBR/CBRa"CBR/CBRa"CBRb"CBRb"BSOT"BSOT"BSNT"BSNT"IP/PPP (GFP)"IP/PPP (GFP)"Ethernet MAC (framed GFP)"Ethernet MAC (framed GFP)"Ethernet PHY (transparent GFP)"Ethernet PHY (transparent GFP)"ESCON"ESCON"FICON"FICON"Fiber Channel"Fiber Channel"const tok[12]tok[12]Packet"Packet"Ethernet V2/DIX"Ethernet V2/DIX"SDH ITU-T G.707/SONET ANSI T1.105"SDH ITU-T G.707/SONET ANSI T1.105"Lambda (photonic)"Lambda (photonic)"Fiber"Fiber"FiberChannel"FiberChannel"Standard SONET/SDH"Standard SONET/SDH"Arbitrary SONET/SDH"Arbitrary SONET/SDH"Packet-Switch Capable-1"Packet-Switch Capable-1"Packet-Switch Capable-2"Packet-Switch Capable-2"Packet-Switch Capable-3"Packet-Switch Capable-3"Packet-Switch Capable-4"Packet-Switch Capable-4"Layer-2 Switch Capable"Layer-2 Switch Capable"Time-Division-Multiplex"Time-Division-Multiplex"Lambda-Switch Capable"Lambda-Switch Capable"Fiber-Switch Capable"Fiber-Switch Capable"Extra Traffic"Extra Traffic"Unprotected"Unprotected"Shared"Shared"0x08Dedicated 1:1"Dedicated 1:1"Dedicated 1+1"Dedicated 1+1"Enhanced"Enhanced"0x400x80/* experimental *//* draft-ietf-tewg-diff-te-proto-07 *//*
 * Signal Type values for SONET links used by LMP Service Discovery (specifically,
 * the Client Port Service Attributes Object). See UNI 1.0 section 9.4.2 for
 * details.
 *//*
 * Signal Type values for SDH links used by LMP Service Discovery (specifically,
 * the Client Port Service Attributes Object). See UNI 1.0 section 9.4.2 for
 * details.
 *//*
 * Link Type values used by LMP Service Discovery (specifically, the Client
 * Port Service Attributes Object). See UNI 1.0 section 9.4.2 for details.
 *//* draft-ietf-ccamp-gmpls-g709-04.txt *//* rfc3471 *//* rfc4205 *//Users/owura/Repos/codeql_eval/proj_repos/the-tcpdump-group-tcpdump-commit-0f95d441e4b5d7512cc5c326c8668a120e048eda/tcpdump/gmt2local.h/Users/owura/Repos/codeql_eval/proj_repos/the-tcpdump-group-tcpdump-commit-0f95d441e4b5d7512cc5c326c8668a120e048eda/tcpdump/gmt2local.c"gmt2local.h"gmt2localdtdirtm *gmtlocsgmttime_t *long *const time_tconst time_t */*
	 * If the year or julian day is different, we span 00:00 GMT
	 * and must add or subtract a day. Check the year first to
	 * avoid problems when the julian day wraps.
	 *//*
 * Returns the difference between gmt and local time in seconds.
 * Use gmtime() and localtime() to keep things simple.
 *//*
 * Copyright (c) 1997
 *	The Regents of the University of California.  All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that: (1) source code distributions
 * retain the above copyright notice and this paragraph in its entirety, (2)
 * distributions including binary code include the above copyright notice and
 * this paragraph in its entirety in the documentation or other materials
 * provided with the distribution, and (3) all advertising materials mentioning
 * features or use of this software display the following acknowledgement:
 * ``This product includes software developed by the University of California,
 * Lawrence Berkeley Laboratory and its contributors.'' Neither the name of
 * the University nor the names of its contributors may be used to endorse
 * or promote products derived from this software without specific prior
 * written permission.
 * THIS SOFTWARE IS PROVIDED ``AS IS'' AND WITHOUT ANY EXPRESS OR IMPLIED
 * WARRANTIES, INCLUDING, WITHOUT LIMITATION, THE IMPLIED WARRANTIES OF
 * MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE.
 */t/Users/owura/Repos/codeql_eval/proj_repos/the-tcpdump-group-tcpdump-commit-0f95d441e4b5d7512cc5c326c8668a120e048eda/tcpdump/in_cksum.cshouldbecomputed_sum0xFFFFwsum 0mlenbyte_swappedunion <unnamed>s_utill_utiluint8_t[2]unsigned char[2]uint16_t[2]unsigned short[2]lcREDUCE{l_util.l = sum; sum = l_util.s[0] + l_util.s[1]; ADDCARRY(sum);}ADDCARRY(x){if ((x) > 65535) (x) -= 65535;}/*
	 * The value that should have gone into the checksum field
	 * is the negative of the value gotten by summing up everything
	 * *but* the checksum field.
	 *
	 * We can compute that by subtracting the value of the checksum
	 * field from the sum of all the data in the packet, and then
	 * computing the negative of that value.
	 *
	 * "sum" is the value of the checksum field, and "computed_sum"
	 * is the negative of the sum of all the data in the packets,
	 * so that's -(-computed_sum - sum), or (sum + computed_sum).
	 *
	 * All the arithmetic in question is one's complement, so the
	 * addition must include an end-around carry; we do this by
	 * doing the arithmetic in 32 bits (with no sign-extension),
	 * and then adding the upper 16 bits of the sum, which contain
	 * the carry, to the lower 16 bits of the sum, and then do it
	 * again in case *that* sum produced a carry.
	 *
	 * As RFC 1071 notes, the checksum can be computed without
	 * byte-swapping the 16-bit words; summing 16-bit words
	 * on a big-endian machine gives a big-endian checksum, which
	 * can be directly stuffed into the big-endian checksum fields
	 * in protocol headers, and summing words on a little-endian
	 * machine gives a little-endian checksum, which must be
	 * byte-swapped before being stuffed into a big-endian checksum
	 * field.
	 *
	 * "computed_sum" is a network-byte-order value, so we must put
	 * it in host byte order before subtracting it from the
	 * host-byte-order value from the header; the adjusted checksum
	 * will be in host byte order, which is what we'll return.
	 *//*
 * Given the host-byte-order value of the checksum field in a packet
 * header, and the network-byte-order computed checksum of the data
 * that the checksum covers (including the checksum itself), compute
 * what the checksum field *should* have been.
 *//* The last mbuf has odd # of bytes. Follow the
		   standard (the odd byte may be shifted left by 8 bits
		   or not as determined by endian-ness of the machine) *//*
		 * Unroll the loop to make overhead from
		 * branches &c small.
		 *//*
		 * Force to even boundary.
		 *//*
			 * The first byte of this chunk is the continuation
			 * of a word spanning between this chunk and the
			 * last chunk.
			 *
			 * s_util.c[0] is already saved when scanning previous
			 * chunk.
			 *//*
 * Checksum routine for Internet Protocol family headers (Portable Version).
 *
 * This routine is very heavily used in the network
 * code and should be modified for each CPU to be as fast as possible.
 *//*
 * Copyright (c) 1988, 1992, 1993
 *	The Regents of the University of California.  All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. Neither the name of the University nor the names of its contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 *
 *	@(#)in_cksum.c	8.1 (Berkeley) 6/10/93
 *//* in_cksum.c
 * 4.4-Lite-2 Internet checksum routine, modified to take a vector of
 * pointers/lengths giving the pieces to be checksummed.  Also using
 * Tahoe/CGI version of ADDCARRY(x) macro instead of from portable version.
 */vecveclen/Users/owura/Repos/codeql_eval/proj_repos/the-tcpdump-group-tcpdump-commit-0f95d441e4b5d7512cc5c326c8668a120e048eda/tcpdump/ipproto.hIPPROTO_MOBILITYIPPROTO_CARPIPPROTO_VRRPIPPROTO_OSPFIPPROTO_EIGRPIPPROTO_MOBILITY_OLDIPPROTO_MOBILEIPPROTO_DCCPIPPROTO_IPIPPROTO_HOPOPTSIPPROTO_ICMPIPPROTO_IGMPIPPROTO_IPV4IPPROTO_TCPIPPROTO_EGPIPPROTO_PIGPIPPROTO_UDPIPPROTO_IPV6IPPROTO_ROUTINGIPPROTO_FRAGMENTIPPROTO_RSVPIPPROTO_GREIPPROTO_ESPIPPROTO_AHIPPROTO_ICMPV6IPPROTO_NONEIPPROTO_DSTOPTSIPPROTO_NDIPPROTO_PIMIPPROTO_IPCOMPIPPROTO_PGMIPPROTO_SCTPipproto_values/* Cisco/GXS IGRP *//* Sun net disk proto (temp.) *//*
 * The current Protocol Numbers list says that the IP protocol number for
 * mobility headers is 135; it cites draft-ietf-mobileip-ipv6-24, but
 * that draft doesn't actually give a number.
 *
 * It appears that 62 used to be used, even though that's assigned to
 * a protocol called CFTP; however, the only reference for CFTP is a
 * Network Message from BBN back in 1982, so, for now, we support 62,
 * aas well as 135, as a protocol number for mobility headers.
 *//* IPv6 destination options *//* IPv6 no next header *//* ICMPv6 *//* SIPP Auth Header *//* SIPP Encap Sec. Payload *//* General Routing Encap. *//* resource reservation *//* IPv6 fragmentation header *//* IPv6 routing header *//* datagram congestion control protocol *//* user datagram protocol *//* exterior gateway protocol *//* tcp *//* group mgmt protocol *//* control message protocol *//* IPv6 hop-by-hop options *//* dummy for IP *//*
 * Copyright (c) 1982, 1986, 1990, 1993
 *	The Regents of the University of California.  All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *	This product includes software developed by the University of
 *	California, Berkeley and its contributors.
 * 4. Neither the name of the University nor the names of its contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 *
 * From:
 *	@(#)in.h	8.3 (Berkeley) 1/3/94
 * $FreeBSD: src/sys/netinet/in.h,v 1.38.2.3 1999/08/29 16:29:34 peter Exp $
 *//Users/owura/Repos/codeql_eval/proj_repos/the-tcpdump-group-tcpdump-commit-0f95d441e4b5d7512cc5c326c8668a120e048eda/tcpdump/ipproto.c"ipproto.h"const tok[29]tok[29]Options"Options"ICMP"ICMP"IGMP"IGMP"IPIP"IPIP"TCP"TCP"EGP"EGP"IGRP"IGRP"UDP"UDP"DCCP"DCCP"Routing"Routing"Fragment"Fragment"RSVP"RSVP"GRE"GRE"ESP"ESP"AH"AH"Mobile IP"Mobile IP"ICMPv6"ICMPv6"Mobile IP (old)"Mobile IP (old)"EIGRP"EIGRP"OSPF"OSPF"PIM"PIM"Compressed IP"Compressed IP"VRRP"VRRP"PGM"PGM"SCTP"SCTP"Mobility"Mobility"CARP"CARP"/Users/owura/Repos/codeql_eval/proj_repos/the-tcpdump-group-tcpdump-commit-0f95d441e4b5d7512cc5c326c8668a120e048eda/tcpdump/l2vpn.hl2vpn_encaps_values/Users/owura/Repos/codeql_eval/proj_repos/the-tcpdump-group-tcpdump-commit-0f95d441e4b5d7512cc5c326c8668a120e048eda/tcpdump/l2vpn.c"l2vpn.h"const tok[27]tok[27]Frame Relay"Frame Relay"ATM AAL5 VCC transport"ATM AAL5 VCC transport"ATM transparent cell transport"ATM transparent cell transport"Ethernet VLAN"Ethernet VLAN"0x05Ethernet"Ethernet"Cisco-HDLC"Cisco-HDLC"PPP"PPP"SONET/SDH Circuit Emulation Service over MPLS"SONET/SDH Circuit Emulation Service over MPLS"char[46]0x09ATM n-to-one VCC cell transport"ATM n-to-one VCC cell transport"0x0aATM n-to-one VPC cell transport"ATM n-to-one VPC cell transport"0x0bIP Layer2 Transport"IP Layer2 Transport"ATM one-to-one VCC Cell Mode"ATM one-to-one VCC Cell Mode"0x0dATM one-to-one VPC Cell Mode"ATM one-to-one VPC Cell Mode"ATM AAL5 PDU VCC transport"ATM AAL5 PDU VCC transport"Frame-Relay Port mode"Frame-Relay Port mode"SONET/SDH Circuit Emulation over Packet"SONET/SDH Circuit Emulation over Packet"0x11Structure-agnostic E1 over Packet"Structure-agnostic E1 over Packet"0x12Structure-agnostic T1 (DS1) over Packet"Structure-agnostic T1 (DS1) over Packet"0x13Structure-agnostic E3 over Packet"Structure-agnostic E3 over Packet"0x14Structure-agnostic T3 (DS3) over Packet"Structure-agnostic T3 (DS3) over Packet"0x15CESoPSN basic mode"CESoPSN basic mode"0x16TDMoIP basic mode"TDMoIP basic mode"0x17CESoPSN TDM with CAS"CESoPSN TDM with CAS"0x18TDMoIP TDM with CAS"TDMoIP TDM with CAS"IP-interworking"IP-interworking"/* draft-ietf-pwe3-iana-allocation-04 *//Users/owura/Repos/codeql_eval/proj_repos/the-tcpdump-group-tcpdump-commit-0f95d441e4b5d7512cc5c326c8668a120e048eda/tcpdump/machdep.h/Users/owura/Repos/codeql_eval/proj_repos/the-tcpdump-group-tcpdump-commit-0f95d441e4b5d7512cc5c326c8668a120e048eda/tcpdump/machdep.c"machdep.h"abort_on_misalignmentunused(0)HAVE___ATTRIBUTE____osf___U___attribute__((unused))/*
 * On platforms where the CPU doesn't support unaligned loads, force
 * unaligned accesses to abort with SIGBUS, rather than being fixed
 * up (slowly) by the OS kernel; on those platforms, misaligned accesses
 * are bugs, and we want tcpdump to crash so that the bugs are reported.
 *
 * The only OS on which this is necessary is DEC OSF/1^W^WDigital
 * UNIX^W^WTru64 UNIX.
 *//* __osf__ *//* HAVE___ATTRIBUTE__ *//*
 * XXX - all we need, on platforms other than DEC OSF/1 (a/k/a Digital UNIX,
 * a/k/a Tru64 UNIX), is "size_t", which is a standard C type; what do we
 * need to do to get it defined?  This is clearly wrong, as we shouldn't
 * have to include UNIX or Windows system header files to get it.
 *//*
 * Copyright (c) 1996, 1997
 *	The Regents of the University of California.  All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that: (1) source code distributions
 * retain the above copyright notice and this paragraph in its entirety, (2)
 * distributions including binary code include the above copyright notice and
 * this paragraph in its entirety in the documentation or other materials
 * provided with the distribution, and (3) all advertising materials mentioning
 * features or use of this software display the following acknowledgement:
 * ``This product includes software developed by the University of California,
 * Lawrence Berkeley Laboratory and its contributors.'' Neither the name of
 * the University nor the names of its contributors may be used to endorse
 * or promote products derived from this software without specific prior
 * written permission.
 * THIS SOFTWARE IS PROVIDED ``AS IS'' AND WITHOUT ANY EXPRESS OR IMPLIED
 * WARRANTIES, INCLUDING, WITHOUT LIMITATION, THE IMPLIED WARRANTIES OF
 * MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE.
 */ebufebufsiz/Users/owura/Repos/codeql_eval/proj_repos/the-tcpdump-group-tcpdump-commit-0f95d441e4b5d7512cc5c326c8668a120e048eda/tcpdump/nlpid.hNLPID_IP6NLPID_X25_ESIS0x8aNLPID_PPP0xcfNLPID_IP0xccNLPID_SPB0xc1NLPID_MFR0xb1NLPID_IDRP0x85NLPID_CONS0x84NLPID_ISIS0x83NLPID_ESIS0x82NLPID_CLNPNLPID_SNAPNLPID_LMINLPID_Q933NLPID_NULLNSnlpid_values/* IEEE 802.1aq/D4.5 *//* FRF.15 *//* iso9577 *//* The original, aka Cisco, aka Gang of Four *//* ANSI T1.617 Annex D or ITU-T Q.933 Annex A *//Users/owura/Repos/codeql_eval/proj_repos/the-tcpdump-group-tcpdump-commit-0f95d441e4b5d7512cc5c326c8668a120e048eda/tcpdump/nlpid.c"nlpid.h"const tok[16]tok[16]NULL"NULL"Q.933"Q.933"LMI"LMI"SNAP"SNAP"CLNP"CLNP"ES-IS"ES-IS"IS-IS"IS-IS"CONS"CONS"IDRP"IDRP"ISIS_SPB"ISIS_SPB"FRF.15"FRF.15"204207X25 ES-IS"X25 ES-IS"/Users/owura/Repos/codeql_eval/proj_repos/the-tcpdump-group-tcpdump-commit-0f95d441e4b5d7512cc5c326c8668a120e048eda/tcpdump/oui.cconst tok[39]tok[39]IETF (reserved)"IETF (reserved)"ACC"ACC"Cisco"Cisco"Hewlett Packard"Hewlett Packard"Sun Microsystems"Sun Microsystems"Merit"Merit"Shiva"Shiva"Ericsson AB"Ericsson AB"Cisco VPN 5000"Cisco VPN 5000"Livingston"Livingston"Microsoft"Microsoft"3Com"3Com"Ascend"Ascend"Bay Networks"Bay Networks"Foundry"Foundry"Versanet"Versanet"Redback"Redback"Juniper Networks"Juniper Networks"Aptis"Aptis"Cisco VPN 3000"Cisco VPN 3000"CoSine Communications"CoSine Communications"Netscreen"Netscreen"Shasta"Shasta"Nomadix"Nomadix"Siemens"Siemens"CableLabs"CableLabs"Unisphere Networks"Unisphere Networks"Cisco BBSM"Cisco BBSM"3rd Generation Partnership Project 2 (3GPP2)"3rd Generation Partnership Project 2 (3GPP2)"ipUnplugged"ipUnplugged"Issanni Communications"Issanni Communications"Quintum"Quintum"Interlink"Interlink"Colubris"Colubris"Columbia University"Columbia University"3GPP"3GPP"Gemtek-Systems"Gemtek-Systems"Wi-Fi Alliance"Wi-Fi Alliance"const tok[15]tok[15]Nortel Networks SONMP"Nortel Networks SONMP"248Cisco bridged"Cisco bridged"32962Ethernet bridged"Ethernet bridged"41022ATM Forum"ATM Forum"57391DOCSIS Spanning Tree"DOCSIS Spanning Tree"52429536969Juniper"Juniper"524297Hewlett-Packard"Hewlett-Packard"IEEE 802.1 Private"IEEE 802.1 Private"4623IEEE 802.3 Private"IEEE 802.3 Private"4795ANSI/TIA"ANSI/TIA"6945DCBX"DCBX"/*
 * SMI Network Management Private Enterprise Codes for organizations.
 *
 * XXX - these also appear in FreeRadius dictionary files, with items such
 * as
 *
 *	VENDOR          Cisco           9
 *
 * List taken from Ethereal's epan/sminmpec.c.
 *//* FIXME complete OUI list using a script *//Users/owura/Repos/codeql_eval/proj_repos/the-tcpdump-group-tcpdump-commit-0f95d441e4b5d7512cc5c326c8668a120e048eda/tcpdump/nfsfh.hmy_fsidstruct <unnamed>my_devtfsid_codechar[65]2 * 322 * 32 + 1Opaque_HandleFsid_devMajorMinorfsid_eq(a,b)((a.fsid_code == b.fsid_code) && dev_eq(a.Fsid_dev, b.Fsid_dev))dev_eq(a,b)((a.Minor == b.Minor) && (a.Major == b.Major))Parse_fhconst unsigned charconst unsigned char *my_fsid *struct <unnamed> */* XXX avoid name conflict with AIX *//*
 * Many file servers now use a large file system ID.  This is
 * our internal representation of that.
 *//* upper case to avoid clashing with macro names *//*
 * Internal representation of dev_t, because different NFS servers
 * that we might be spying upon use different external representations.
 *//*
 * nfsfh.h - NFS file handle definitions (for portable use)
 *
 * Jeffrey C. Mogul
 * Digital Equipment Corporation
 * Western Research Laboratory
 *//*
 * Copyright (c) 1993, 1994 Jeffrey C. Mogul, Digital Equipment Corporation,
 * Western Research Laboratory. All rights reserved.
 * Copyright (c) 2001 Compaq Computer Corporation. All rights reserved.
 *
 *  Permission to use, copy, and modify this software and its
 *  documentation is hereby granted only under the following terms and
 *  conditions.  Both the above copyright notice and this permission
 *  notice must appear in all copies of the software, derivative works
 *  or modified versions, and any portions thereof, and both notices
 *  must appear in supporting documentation.
 *
 *  Redistribution and use in source and binary forms, with or without
 *  modification, are permitted provided that the following conditions
 *  are met:
 *    1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 *    2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in
 *    the documentation and/or other materials provided with the
 *    distribution.
 *
 *  THE SOFTWARE IS PROVIDED "AS IS" AND COMPAQ COMPUTER CORPORATION
 *  DISCLAIMS ALL WARRANTIES WITH REGARD TO THIS SOFTWARE, INCLUDING
 *  ALL IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS.   IN NO
 *  EVENT SHALL COMPAQ COMPUTER CORPORATION BE LIABLE FOR ANY
 *  SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
 *  WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN
 *  AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING
 *  OUT OF OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS
 *  SOFTWARE.
 *//Users/owura/Repos/codeql_eval/proj_repos/the-tcpdump-group-tcpdump-commit-0f95d441e4b5d7512cc5c326c8668a120e048eda/tcpdump/parsenfsfh.c"nfsfh.h"is_UCXseen_nullfhp[i](1)fhptempfhtype FHT_UNKNOWNFHT_AUSPEXFHT_DECOSFFHT_IRIX4FHT_SUNOS4FHT_BSD44FHT_ULTRIXFHT_SUNOS5FHT_HPUX9FHT_VMSUCXFHT_UNKNOWNfhp[12]fhp[13]fhp[14]fhp[15]fhp[7]fhp[6]fhp[5]fhp[4]fhp[3]fhp[2]fhp[1]fhp[0]fhp[8]fhp[9]fhp[10]fhp[11](char *)fsidp0, sizeof(*fsidp)(char *)fh, 14(char *)tempa0, sizeof(tempa)fhp[26]fhp[27]fhp[23]fhp[22]&(fsidp->Opaque_Handle[i*2])"%.2X", fhp[i]Auspex"Auspex"BSD 4.4"BSD 4.4"10485750xFFFFF0xFFFOSF"OSF"IRIX4"IRIX4"FHT_IRIX5fhfsidpinoposnamepfsnamepourselfIRIX5"IRIX5"SUNOS4"SUNOS4"163830x3FFF2621430x3FFFFSUNOS5"SUNOS5"Ultrix"Ultrix"sizeof(*fsidp)sizeof(*fsidp) >= 14sizeof(*fsidp) > 14uint32_t[4]unsigned int[4]tempaVMS"VMS"FHT_AIX32AIX32"AIX32"HPUX9"HPUX9"%.2X257make_uint48(msb,b,c,d,e,lsb)((lsb) + ((e)<<8) + ((d)<<16) + ((c)<<24))make_uint16(msb,lsb)(XFF(lsb) + (XFF(msb)<<8))make_uint24(msb,b,lsb)(XFF(lsb) + (XFF(b)<<8) + (XFF(msb)<<16))make_uint32(msb,b,c,lsb)(XFF(lsb) + (XFF(c)<<8) + (XFF(b)<<16) + (XFF(msb)<<24))XFF(x)(x)FHT_SUNOS3ultrix__alphadefined(IRIX40)defined(IRIX50)defined(IRIX51)defined(SUNOS4)defined(SUNOS5)defined(ultrix)defined(__osf__)defined(__NetBSD__) || defined(__FreeBSD__) || defined(__DragonFly__) \notdefDEBUG/*
 * Is this a VMS UCX file handle?
 *	Check for:
 *	(1) leading code byte	[XXX not yet]
 *	(2) followed by string of printing chars & spaces
 *	(3) followed by string of nulls
 *//* display will show this string instead of (257,257) *//* XXX for now, give "bogus" values to aid debugging *//* Save the actual handle, so it can be display with -u *//* XXX debugging *//* Caller must save (and null-terminate?) this value *//* VMS file ID is: (RVN, FidHi, FidLo) *//* ensure alignment *//* at least 16 bytes, maybe more *//* just use the whole thing *//* No numeric file system ID, so hash on the device-name *//*
	     * XXX - none of the heuristics above return this.
	     * Are there any SunOS 3.x systems around to care about?
	     *//* XXX could ignore 3 high-order bytes *//* XXX still needs to handle SUNOS3 *//* or maybe IRIX5 *//*
			 * XXX Could be SUNOS5/IRIX5 or AIX.  I don't
			 * XXX see any way to disambiguate these, so
			 * XXX I'm going with the more likely guess.
			 * XXX Sorry, Big Blue.
			 *//* This would be MNT_NFS on AIX, which is impossible *//* XXX is this always true of HP-UX? *//* could be SUNOS5/IRIX5, AIX, HP-UX *//*
		 * bytes[2,3] != (0,0); rules out Ultrix, could be
		 * DECOSF, SUNOS5, IRIX5, AIX, HP-UX, or UCX
		 *//* XXX what about AIX? *//* XXX no obvious difference between SUNOS5 and IRIX5 *//* Could be SUNOS5/IRIX5, maybe AIX *//*XXX we probably only need to test of these two bytes *//*
		 * bytes[2,3] == (0,0); rules out OSF, probably not UCX
		 * (unless the exported device name is just one letter!),
		 * could be Ultrix, IRIX5, AIX, or SUNOS5
		 * might be HP-UX (depends on their values for minor devs)
		 *//*
	     * bytes[0,1] != (0,0); rules out Auspex, IRIX4, SUNOS4
	     * could be IRIX5, DECOSF, UCX, Ultrix, SUNOS5
	     * could be AIX, HP-UX
	     *//* by elimination *//* looks like a length, not a file system typecode *//* XXX the test of fhp[5] == 8 could be wrong *//* could be SUNOS4 or IRIX4 *//* seems to be DECOSF, with minor == 0 *//*
		 * bytes[2,3] != (0,0); rules out Auspex, could be
		 * DECOSF, SUNOS4, or IRIX4
		 *//* XXX or could be Ultrix+MASSBUS "hp" disk? *//* bytes[2,3] == (0,0); must be Auspex *//* probably rules out HP-UX, AIX unless they allow major=0 *//* bytes[0,1] == (0,0); rules out Ultrix, IRIX5, SUNOS5 *//*
	 * This is basically a big decision tree
	 *//* File handle generated on this host, no need for guessing *//* true if file handle was generated on this host *//* if non-NULL, return server fs name here (for VMS) *//* if non-NULL, return OS name here *//* on 32-bit systems ignore high-order bits *//* or other 64-bit systems *//* Nasty hack to keep the Ultrix C compiler from emitting bogus warnings *//*
 * This routine attempts to parse a file handle (in network byte order),
 * using heuristics to guess what kind of format it is in.  See the
 * file "fhandle_layouts" for a detailed description of the various
 * patterns we know about.
 *
 * The file handle is parsed into our internal representation of a
 * file-system id, and an internal representation of an inode-number.
 *//*
 * parsenfsfh.c - portable parser for NFS file handles
 *			uses all sorts of heuristics
 *
 * Jeffrey C. Mogul
 * Digital Equipment Corporation
 * Western Research Laboratory
 *//Users/owura/Repos/codeql_eval/proj_repos/the-tcpdump-group-tcpdump-commit-0f95d441e4b5d7512cc5c326c8668a120e048eda/tcpdump/print-802_11.cieee802_11_radio_avs_if_printconst pcap_pkthdrconst pcap_pkthdr *pcap_pkthdr *ieee802_11_radio_if_printprism_if_printcaplenmsgcode(ndo, "%s", tstr)%sconst char[10]2149650433WLANCAP_MAGIC_COOKIE_V12149650434WLANCAP_MAGIC_COOKIE_V2PRISM_HDR_LENieee802_11_avs_radio_printcaphdr_lenp + 4ieee802_11_radio_printcpackerieee80211_radiotap_header *hdrpresentnext_presentpresentflagspresentplast_presentpbitbit0flagspadfcslenstatesizeof(*hdr)&hdr->it_lenIEEE80211_RADIOTAP_EXT2147483648sizeof(hdr->it_present)&state0, sizeof(state)present ^ next_present(present ^ next_present) >> 16((present ^ next_present) >> 16) >> 8(((present ^ next_present) >> 16) >> 8) >> 4((((present ^ next_present) >> 16) >> 8) >> 4) >> 2((((present ^ next_present) >> 16) >> 8) >> 4)(((present ^ next_present) >> 16) >> 8)((((present ^ next_present) >> 16) >> 8)) >> 2((((present ^ next_present) >> 16) >> 8))((present ^ next_present) >> 16)(((present ^ next_present) >> 16)) >> 4((((present ^ next_present) >> 16)) >> 4) >> 2((((present ^ next_present) >> 16)) >> 4)(((present ^ next_present) >> 16))((((present ^ next_present) >> 16))) >> 2((((present ^ next_present) >> 16)))(present ^ next_present)((present ^ next_present)) >> 8(((present ^ next_present)) >> 8) >> 4((((present ^ next_present)) >> 8) >> 4) >> 2((((present ^ next_present)) >> 8) >> 4)(((present ^ next_present)) >> 8)((((present ^ next_present)) >> 8)) >> 2((((present ^ next_present)) >> 8))((present ^ next_present))(((present ^ next_present))) >> 4((((present ^ next_present))) >> 4) >> 2((((present ^ next_present))) >> 4)(((present ^ next_present)))((((present ^ next_present)))) >> 2((((present ^ next_present))))radiotap_state *houtIEEE80211_RADIOTAP_F_DATAPADIEEE80211_RADIOTAP_F_FCSprint_radiotap_fieldu2u3u4rc&u.i8(ndo, "[bit %u] ", bit)IEEE80211_RADIOTAP_FLAGSIEEE80211_RADIOTAP_RATEIEEE80211_RADIOTAP_DB_ANTSIGNALIEEE80211_RADIOTAP_DB_ANTNOISEIEEE80211_RADIOTAP_ANTENNAIEEE80211_RADIOTAP_DBM_ANTSIGNALIEEE80211_RADIOTAP_DBM_ANTNOISEint8_t *signed char *IEEE80211_RADIOTAP_CHANNELIEEE80211_RADIOTAP_FHSSIEEE80211_RADIOTAP_LOCK_QUALITYIEEE80211_RADIOTAP_TX_ATTENUATIONIEEE80211_RADIOTAP_RX_FLAGSIEEE80211_RADIOTAP_DB_TX_ATTENUATIONIEEE80211_RADIOTAP_DBM_TX_POWERIEEE80211_RADIOTAP_TSFTIEEE80211_RADIOTAP_XCHANNELIEEE80211_RADIOTAP_MCSIEEE80211_RADIOTAP_VENDOR_NAMESPACEuint8_t[3]unsigned char[3]vnssubspace[bit %u] (ndo, "fhset %d fhpat %d ", u.u16 & 0xff, (u.u16 >> 8) & 0xff)(ndo, "MCS %u ", u.u8 & 0x7f)(ndo, "%2.1f Mb/s ", .5 * u.u8)(ndo, "%ddB signal ", u.i8)(ndo, "%ddB noise ", u.i8)(ndo, "%ddB signal ", u.u8)(ndo, "%ddB noise ", u.u8)(ndo, "%u sq ", u.u16)(ndo, "%d tx power ", -(int)u.u16)(ndo, "%ddB tx power ", -(int)u.u8)(ndo, "%ddBm tx power ", u.i8)(ndo, "cfp ")(ndo, "short preamble ")(ndo, "wep ")(ndo, "fragmented ")(ndo, "bad-fcs ")(ndo, "antenna %d ", u.u8)(ndo, "%" PRIu64 "us tsft ", u.u64)(ndo, "%" "ll" "u" "us tsft ", u.u64)(ndo, "%.1f Mb/s MCS %u ", htrate, u3.u8)(ndo, "MCS %u ", u3.u8)(ndo, "%s ", bandwidth[u2.u8 & IEEE80211_RADIOTAP_MCS_BANDWIDTH_MASK])(ndo, "%s ", bandwidth[u2.u8 & 0x03])(ndo, "%s GI ", (u2.u8 & IEEE80211_RADIOTAP_MCS_SHORT_GI) ? "short" : "lon")(ndo, "%s GI ", (u2.u8 & 0x04) ? "short" : "lon")(ndo, "%s ", (u2.u8 & IEEE80211_RADIOTAP_MCS_HT_GREENFIELD) ? "greenfield" : "mixed")(ndo, "%s ", (u2.u8 & 0x08) ? "greenfield" : "mixed")(ndo, "%s FEC ", (u2.u8 & IEEE80211_RADIOTAP_MCS_FEC_LDPC) ? "LDPC" : "BCC")(ndo, "%s FEC ", (u2.u8 & 0x10) ? "LDPC" : "BCC")(ndo, "RX-STBC%u ", (u2.u8 & IEEE80211_RADIOTAP_MCS_STBC_MASK) >> IEEE80211_RADIOTAP_MCS_STBC_SHIFT)(ndo, "RX-STBC%u ", (u2.u8 & 0x60) >> 5)2621441 << IEEE80211_RADIOTAP_XCHANNEL(1 << IEEE80211_RADIOTAP_XCHANNEL)fhset %d fhpat %d 0x8fMCS %u %2.1f Mb/s 0.5%ddB signal %ddB noise %u sq %d tx power %ddB tx power %ddBm tx power IEEE80211_RADIOTAP_F_CFPcfp IEEE80211_RADIOTAP_F_SHORTPREshort preamble IEEE80211_RADIOTAP_F_WEPwep IEEE80211_RADIOTAP_F_FRAGfragmented IEEE80211_RADIOTAP_F_BADFCSbad-fcs antenna %d %lluus tsft const char *[4]char *[4]20 MHz"20 MHz"40 MHz"40 MHz"20 MHz (L)"20 MHz (L)"20 MHz (U)"20 MHz (U)"bandwidthhtrateIEEE80211_RADIOTAP_MCS_MCS_INDEX_KNOWNMAX_MCS_INDEXIEEE80211_RADIOTAP_MCS_BANDWIDTH_KNOWNIEEE80211_RADIOTAP_MCS_GUARD_INTERVAL_KNOWN(IEEE80211_RADIOTAP_MCS_BANDWIDTH_KNOWN|IEEE80211_RADIOTAP_MCS_GUARD_INTERVAL_KNOWN)const floatconst float[2]float[2]const float[2][2]float[2][2]const float[77][2][2]float[77][2][2]const float(*)[2][2]float(*)[2][2]const float(*)[2]float(*)[2]IEEE80211_RADIOTAP_MCS_BANDWIDTH_MASKIEEE80211_RADIOTAP_MCS_BANDWIDTH_40const float *float *IEEE80211_RADIOTAP_MCS_SHORT_GI0.0%.1f Mb/s MCS %u %s %s GI shortlonIEEE80211_RADIOTAP_MCS_HT_FORMAT_KNOWNgreenfieldmixedIEEE80211_RADIOTAP_MCS_FEC_TYPE_KNOWN%s FEC LDPCBCCIEEE80211_RADIOTAP_MCS_STBC_KNOWNRX-STBC%u print_chaninfo(ndo, "%u MHz", freq)%u MHz(ndo, " FHSS")2048 FHSS(ndo, " 11a/10Mhz")(ndo, " 11a/5Mhz")(ndo, " 11a")32016384IEEE80211_CHAN_HALF 11a/10Mhz32768IEEE80211_CHAN_QUARTER 11a/5Mhz 11a(ndo, " 11g/10Mhz")(ndo, " 11g/5Mhz")(ndo, " 11g")(ndo, " 11b")1921152 11g/10Mhz 11g/5Mhz 11g 11b(ndo, " Turbo")IEEE80211_CHAN_TURBO Turbo(ndo, " ht/20")(ndo, " ht/40-")(ndo, " ht/40+")65536IEEE80211_CHAN_HT20 ht/20IEEE80211_CHAN_HT40D ht/40-131072IEEE80211_CHAN_HT40U ht/40+(ndo, " ") ieee802_11_if_printieee802_11_printfchdrlenmeshdrlensrcdstextracted_ethertypeIEEE802_11_FC_LEN-44294967292FC_SUBTYPE(fc)(((fc) >> 4) & 0xF)T_DATAconst uint8_t **unsigned char **(ndo, "(LLC %s) ", etherproto_string( htons(extracted_ethertype)))(ndo, "(LLC %s) ", etherproto_string( ((__uint16_t)(__builtin_constant_p(extracted_ethertype) ? ((__uint16_t)((((__uint16_t)(extracted_ethertype) & 0xff00U) >> 8) | (((__uint16_t)(extracted_ethertype) & 0x00ffU) << 8))) : _OSSwapInt16(extracted_ethertype)))))(ndo, "unknown 802.11 frame type (%d)", FC_TYPE(fc))(ndo, "unknown 802.11 frame type (%d)", (((fc) >> 2) & 0x3))T_MGMTconst mgmt_header_tconst mgmt_header_t *mgmt_header_t *T_CTRLfreqorig_caplen(LLC %s) unknown 802.11 frame type (%d)ieee_802_11_hdr_print(ndo, "More Data ")(ndo, "More Fragments ")(ndo, "Pwr Mgmt ")(ndo, "Retry ")(ndo, "Strictly Ordered ")(ndo, "WEP Encrypted ")(ndo, "%dus ", EXTRACT_LE_16BITS( &((const struct mgmt_header_t *)p)->duration))(ndo, "%dus ", ((uint16_t)(((uint16_t)(*((const uint8_t *)(&((const struct mgmt_header_t *)p)->duration) + 1)) << 8) | ((uint16_t)(*((const uint8_t *)(&((const struct mgmt_header_t *)p)->duration) + 0)) << 0))))&((const struct mgmt_header_t *)p)->duration8192More Data More Fragments Pwr Mgmt Retry Strictly Ordered WEP Encrypted CTRL_PS_POLL%dus (ndo, "MeshData (AE %d TTL %u seq %u", ae, mc->ttl, EXTRACT_LE_32BITS(mc->seq))(ndo, "MeshData (AE %d TTL %u seq %u", ae, mc->ttl, ((uint32_t)(((uint32_t)(*((const uint8_t *)(mc->seq) + 3)) << 24) | ((uint32_t)(*((const uint8_t *)(mc->seq) + 2)) << 16) | ((uint32_t)(*((const uint8_t *)(mc->seq) + 1)) << 8) | ((uint32_t)(*((const uint8_t *)(mc->seq) + 0)) << 0))))mc->seq(ndo, " A4:%s", etheraddr_string(ndo, mc->addr4))(ndo, " A5:%s", etheraddr_string(ndo, mc->addr5))(ndo, " A6:%s", etheraddr_string(ndo, mc->addr6))(ndo, ") ")const meshcntl_tconst meshcntl_t *meshcntl_t *mcaeMeshData (AE %d TTL %u seq %uuint8_t[4]unsigned char[4] A4:%suint8_t[6] A5:%s A6:%s) (ndo, "(header) unknown IEEE802.11 frame type (%d)", FC_TYPE(fc))(ndo, "(header) unknown IEEE802.11 frame type (%d)", (((fc) >> 2) & 0x3))(header) unknown IEEE802.11 frame type (%d)extract_mesh_header_length~ 3extract_header_length(ndo, "unknown IEEE802.11 frame type (%d)", FC_TYPE(fc))(ndo, "unknown IEEE802.11 frame type (%d)", (((fc) >> 2) & 0x3))MGMT_HDRLENCTRL_BARCTRL_BAR_HDRLENCTRL_PS_POLL_HDRLENCTRL_RTSCTRL_RTS_HDRLENCTRL_CTSCTRL_CTS_HDRLENCTRL_ACKCTRL_ACK_HDRLENCTRL_CF_ENDCTRL_END_HDRLENCTRL_END_ACKCTRL_END_ACK_HDRLENunknown IEEE802.11 frame type (%d)ctrl_header_print(ndo, " RA:%s TA:%s CTL(%x) SEQ(%u) ", etheraddr_string(ndo, ((const struct ctrl_bar_t *)p)->ra), etheraddr_string(ndo, ((const struct ctrl_bar_t *)p)->ta), EXTRACT_LE_16BITS(&(((const struct ctrl_bar_t *)p)->ctl)), EXTRACT_LE_16BITS(&(((const struct ctrl_bar_t *)p)->seq)))(ndo, " RA:%s TA:%s CTL(%x) SEQ(%u) ", etheraddr_string(ndo, ((const struct ctrl_bar_t *)p)->ra), etheraddr_string(ndo, ((const struct ctrl_bar_t *)p)->ta), ((uint16_t)(((uint16_t)(*((const uint8_t *)(&(((const struct ctrl_bar_t *)p)->ctl)) + 1)) << 8) | ((uint16_t)(*((const uint8_t *)(&(((const struct ctrl_bar_t *)p)->ctl)) + 0)) << 0))), ((uint16_t)(((uint16_t)(*((const uint8_t *)(&(((const struct ctrl_bar_t *)p)->seq)) + 1)) << 8) | ((uint16_t)(*((const uint8_t *)(&(((const struct ctrl_bar_t *)p)->seq)) + 0)) << 0))))&(((const struct ctrl_bar_t *)p)->ctl)&(((const struct ctrl_bar_t *)p)->seq)(ndo, "RA:%s ", etheraddr_string(ndo, ((const struct ctrl_ba_t *)p)->ra))(ndo, "BSSID:%s TA:%s ", etheraddr_string(ndo, ((const struct ctrl_ps_poll_t *)p)->bssid), etheraddr_string(ndo, ((const struct ctrl_ps_poll_t *)p)->ta))(ndo, "RA:%s TA:%s ", etheraddr_string(ndo, ((const struct ctrl_rts_t *)p)->ra), etheraddr_string(ndo, ((const struct ctrl_rts_t *)p)->ta))(ndo, "RA:%s ", etheraddr_string(ndo, ((const struct ctrl_cts_t *)p)->ra))(ndo, "RA:%s ", etheraddr_string(ndo, ((const struct ctrl_ack_t *)p)->ra))(ndo, "RA:%s BSSID:%s ", etheraddr_string(ndo, ((const struct ctrl_end_t *)p)->ra), etheraddr_string(ndo, ((const struct ctrl_end_t *)p)->bssid))(ndo, "RA:%s BSSID:%s ", etheraddr_string(ndo, ((const struct ctrl_end_ack_t *)p)->ra), etheraddr_string(ndo, ((const struct ctrl_end_ack_t *)p)->bssid))(ndo, "(H) Unknown Ctrl Subtype") RA:%s TA:%s CTL(%x) SEQ(%u) const ctrl_bar_tconst ctrl_bar_t *ctrl_bar_t *srcpdstpCTRL_BARA:%s const ctrl_ba_tconst ctrl_ba_t *ctrl_ba_t *BSSID:%s TA:%s const ctrl_ps_poll_tconst ctrl_ps_poll_t *ctrl_ps_poll_t *RA:%s TA:%s const ctrl_rts_tconst ctrl_rts_t *ctrl_rts_t *const ctrl_cts_tconst ctrl_cts_t *ctrl_cts_t *const ctrl_ack_tconst ctrl_ack_t *ctrl_ack_t *RA:%s BSSID:%s const ctrl_end_tconst ctrl_end_t *ctrl_end_t *const ctrl_end_ack_tconst ctrl_end_ack_t *ctrl_end_ack_t *(H) Unknown Ctrl Subtypemgmt_header_print(ndo, "BSSID:%s DA:%s SA:%s ", etheraddr_string(ndo, (hp)->bssid), etheraddr_string(ndo, (hp)->da), etheraddr_string(ndo, (hp)->sa))BSSID:%s DA:%s SA:%s data_header_printsubtype(ndo, "CF ")(ndo, "Ack/Poll")(ndo, "Ack")(ndo, "Poll")(ndo, "+QoS")CF Ack/PollAckPoll+QoS(ndo, "DA:%s SA:%s BSSID:%s ", etheraddr_string(ndo, ADDR1), etheraddr_string(ndo, ADDR2), etheraddr_string(ndo, ADDR3))(ndo, "DA:%s SA:%s BSSID:%s ", etheraddr_string(ndo, (p + 4)), etheraddr_string(ndo, (p + 10)), etheraddr_string(ndo, (p + 16)))(ndo, "DA:%s BSSID:%s SA:%s ", etheraddr_string(ndo, ADDR1), etheraddr_string(ndo, ADDR2), etheraddr_string(ndo, ADDR3))(ndo, "DA:%s BSSID:%s SA:%s ", etheraddr_string(ndo, (p + 4)), etheraddr_string(ndo, (p + 10)), etheraddr_string(ndo, (p + 16)))(ndo, "BSSID:%s SA:%s DA:%s ", etheraddr_string(ndo, ADDR1), etheraddr_string(ndo, ADDR2), etheraddr_string(ndo, ADDR3))(ndo, "BSSID:%s SA:%s DA:%s ", etheraddr_string(ndo, (p + 4)), etheraddr_string(ndo, (p + 10)), etheraddr_string(ndo, (p + 16)))(ndo, "RA:%s TA:%s DA:%s SA:%s ", etheraddr_string(ndo, ADDR1), etheraddr_string(ndo, ADDR2), etheraddr_string(ndo, ADDR3), etheraddr_string(ndo, ADDR4))(ndo, "RA:%s TA:%s DA:%s SA:%s ", etheraddr_string(ndo, (p + 4)), etheraddr_string(ndo, (p + 10)), etheraddr_string(ndo, (p + 16)), etheraddr_string(ndo, (p + 24)))DA:%s SA:%s BSSID:%s DA:%s BSSID:%s SA:%s BSSID:%s SA:%s DA:%s RA:%s TA:%s DA:%s SA:%s ctrl_body_print(ndo, "%s", tok2str(ctrl_str, "Unknown Ctrl Subtype", FC_SUBTYPE(fc)))(ndo, "%s", tok2str(ctrl_str, "Unknown Ctrl Subtype", (((fc) >> 4) & 0xF)))const tok[10]tok[10]Unknown Ctrl Subtype*p(2+2+ 6+6+ 2+2)CTRL_BA_HDRLEN(2+2+6)(ndo, " RA:%s ", etheraddr_string(ndo, ((const struct ctrl_ba_t *)p)->ra))(2+2+ 6+6)(ndo, " AID(%x)", EXTRACT_LE_16BITS(&(((const struct ctrl_ps_poll_t *)p)->aid)))(ndo, " AID(%x)", ((uint16_t)(((uint16_t)(*((const uint8_t *)(&(((const struct ctrl_ps_poll_t *)p)->aid)) + 1)) << 8) | ((uint16_t)(*((const uint8_t *)(&(((const struct ctrl_ps_poll_t *)p)->aid)) + 0)) << 0))))&(((const struct ctrl_ps_poll_t *)p)->aid)(ndo, " TA:%s ", etheraddr_string(ndo, ((const struct ctrl_rts_t *)p)->ta))(ndo, " RA:%s ", etheraddr_string(ndo, ((const struct ctrl_cts_t *)p)->ra))(ndo, " RA:%s ", etheraddr_string(ndo, ((const struct ctrl_ack_t *)p)->ra))(ndo, " RA:%s ", etheraddr_string(ndo, ((const struct ctrl_end_t *)p)->ra))(ndo, " RA:%s ", etheraddr_string(ndo, ((const struct ctrl_end_ack_t *)p)->ra))CTRL_CONTROL_WRAPPER RA:%s  AID(%x) TA:%s mgmt_body_print(ndo, "%s", tok2str(st_str, "Unhandled Management subtype(%x)", FC_SUBTYPE(fc)))(ndo, "%s", tok2str(st_str, "Unhandled Management subtype(%x)", (((fc) >> 4) & 0xF)))const tok[13]tok[13]Unhandled Management subtype(%x)(ndo, "Authentication (Shared-Key)-3 ")ST_ASSOC_REQUESTST_ASSOC_RESPONSEST_REASSOC_REQUESTST_REASSOC_RESPONSEST_PROBE_REQUESTST_PROBE_RESPONSEST_BEACONST_ATIMST_DISASSOCST_AUTHAuthentication (Shared-Key)-3 ST_DEAUTHST_ACTIONhandle_action(ndo, ": ")(ndo, " (%s): ", etheraddr_string(ndo, pmh->sa)):  (%s): (ndo, "Spectrum Management Act#%d", p[1])(ndo, "QoS Act#%d", p[1])(ndo, "DLS Act#%d", p[1])(ndo, "BA ")p[1](ndo, "ADDBA Request")(ndo, "ADDBA Response")(ndo, "DELBA")(ndo, "Act#%d", (p[1]))(ndo, "HT ")(ndo, "TxChWidth")(ndo, "MIMOPwrSave")(ndo, "MeshAction ")(ndo, "MeshLink")(ndo, "HWMP")(ndo, "Gate Announcement")(ndo, "Congestion Control")(ndo, "MCCA Setup Request")(ndo, "MCCA Setup Reply")(ndo, "MCCA Advertisement Request")(ndo, "MCCA Advertisement")(ndo, "MCCA Teardown")(ndo, "TBTT Adjustment Request")(ndo, "TBTT Adjustment Response")(ndo, "MultiohopAction ")(ndo, "Proxy Update")(ndo, "Proxy Update Confirmation")(ndo, "SelfprotectAction ")(ndo, "Peering Open")(ndo, "Peering Confirm")(ndo, "Peering Close")(ndo, "Group Key Inform")(ndo, "Group Key Acknowledge")(ndo, "Vendor Act#%d", p[1])(ndo, "Reserved(%d) Act#%d", p[0], p[1])Spectrum Management Act#%dQoS Act#%dDLS Act#%dBA ADDBA RequestADDBA ResponseDELBAAct#%dpmhHT TxChWidthMIMOPwrSaveMeshAction MeshLinkHWMPGate AnnouncementCongestion ControlMCCA Setup RequestMCCA Setup ReplyMCCA Advertisement RequestMCCA AdvertisementMCCA TeardownTBTT Adjustment RequestTBTT Adjustment ResponseMultiohopAction Proxy UpdateProxy Update ConfirmationSelfprotectAction Peering OpenPeering ConfirmPeering CloseGroup Key InformGroup Key AcknowledgeVendor Act#%dReserved(%d) Act#%dhandle_deauthpbodyreason&pbody0, sizeof(pbody)mgmt_body_t *648IEEE802_11_REASON_LENconst char *[46]char *[46]368NUM_REASONS(ndo, ": %s", reason)(ndo, " (%s): %s", etheraddr_string(ndo, pmh->sa), reason): %s (%s): %shandle_authoffsetretp + offset(ndo, " (%s)-%x [Challenge Text] %s", (pbody.auth_alg < NUM_AUTH_ALGS) ? auth_alg_text[pbody.auth_alg] : "Reserved", pbody.auth_trans_seq_num, ((pbody.auth_trans_seq_num % 2) ? ((pbody.status_code < NUM_STATUSES) ? status_text[pbody.status_code] : "n/a") : ""))(ndo, " (%s)-%x [Challenge Text] %s", (pbody.auth_alg < (sizeof auth_alg_text / sizeof auth_alg_text[0])) ? auth_alg_text[pbody.auth_alg] : "Reserved", pbody.auth_trans_seq_num, ((pbody.auth_trans_seq_num % 2) ? ((pbody.status_code < (sizeof status_text / sizeof status_text[0])) ? status_text[pbody.status_code] : "n/a") : "")) (%s)-%x [Challenge Text] %sconst char *[3]char *[3]const char *[51]char *[51]408n/achar[1](ndo, " (%s)-%x: %s", (pbody.auth_alg < NUM_AUTH_ALGS) ? auth_alg_text[pbody.auth_alg] : "Reserved", pbody.auth_trans_seq_num, (pbody.auth_trans_seq_num % 2) ? ((pbody.status_code < NUM_STATUSES) ? status_text[pbody.status_code] : "n/a") : "")(ndo, " (%s)-%x: %s", (pbody.auth_alg < (sizeof auth_alg_text / sizeof auth_alg_text[0])) ? auth_alg_text[pbody.auth_alg] : "Reserved", pbody.auth_trans_seq_num, (pbody.auth_trans_seq_num % 2) ? ((pbody.status_code < (sizeof status_text / sizeof status_text[0])) ? status_text[pbody.status_code] : "n/a") : "") (%s)-%x: %shandle_disassoc(ndo, ": %s", (pbody.reason_code < NUM_REASONS) ? reason_text[pbody.reason_code] : "Reserved")(ndo, ": %s", (pbody.reason_code < (sizeof reason_text / sizeof reason_text[0])) ? reason_text[pbody.reason_code] : "Reserved")handle_atimhandle_probe_responseIEEE802_11_TSTAMP_LEN + IEEE802_11_BCNINT_LEN + IEEE802_11_CAPINFO_LEN8 + 2 + 2IEEE802_11_TSTAMP_LENIEEE802_11_BCNINT_LENIEEE802_11_CAPINFO_LEN&pbody.timestampp, IEEE802_11_TSTAMP_LENp, 8uint8_t[8]unsigned char[8]uint8_t(*)[8]unsigned char(*)[8]p+offset(ndo, " (")(ndo, ")") (u_char[33]unsigned char[33])seppbody.rates.rate[z](pbody.rates.rate[z] & 0x80 ? "*" : "")(ndo, "%s%2.1f%s", sep, (.5 * ((pbody.rates.rate[z]) & 0x7f)), (pbody.rates.rate[z] & 0x80 ? "*" : ""))(ndo, " Mbit]")z [%s%2.1f%suint8_t[16]unsigned char[16]* Mbit](ndo, " CH: %u", pbody.ds.channel) CH: %u(ndo, "%s", CAPABILITY_PRIVACY(pbody.capability_info) ? ", PRIVACY" : "")(ndo, "%s", ((pbody.capability_info) & 0x0010) ? ", PRIVACY" : "")pbody.capability_info, PRIVACYhandle_probe_requesthandle_reassoc_responsehandle_reassoc_requestIEEE802_11_CAPINFO_LEN + IEEE802_11_LISTENINT_LEN + IEEE802_11_AP_LEN2 + 2 + 6IEEE802_11_LISTENINT_LENIEEE802_11_AP_LEN&pbody.app+offset, IEEE802_11_AP_LENp+offset, 6u_char(*)[6]unsigned char(*)[6](ndo, " AP : %s", etheraddr_string(ndo, pbody.ap )) AP : %shandle_assoc_responseIEEE802_11_CAPINFO_LEN + IEEE802_11_STATUS_LEN + IEEE802_11_AID_LEN2 + 2 + 2IEEE802_11_STATUS_LENIEEE802_11_AID_LEN(ndo, " AID(%x) :%s: %s", ((uint16_t)(pbody.aid << 2 )) >> 2 , CAPABILITY_PRIVACY(pbody.capability_info) ? " PRIVACY " : "", (pbody.status_code < NUM_STATUSES ? status_text[pbody.status_code] : "n/a"))(ndo, " AID(%x) :%s: %s", ((uint16_t)(pbody.aid << 2 )) >> 2 , ((pbody.capability_info) & 0x0010) ? " PRIVACY " : "", (pbody.status_code < (sizeof status_text / sizeof status_text[0]) ? status_text[pbody.status_code] : "n/a")) AID(%x) :%s: %s PRIVACY handle_assoc_requestIEEE802_11_CAPINFO_LEN + IEEE802_11_LISTENINT_LEN2 + 2handle_beacon(ndo, " %s", CAPABILITY_ESS(pbody.capability_info) ? "ESS" : "IBSS")(ndo, " %s", ((pbody.capability_info) & 0x0001) ? "ESS" : "IBSS") %sESSIBSSparse_elementselementlenssidchallengeratesdscftim*(p + offset)*(p + offset + 2)&ssidp + offset, 2ssid.length&ssid.ssidp + offset, ssid.length&challengechallenge.length&challenge.textp + offset, challenge.length&ratesrates.length&rates.ratep + offset, rates.length&ds&cf&cf.countp + offset, 6&tim&tim.countp + offset, 3tim.bitmapp + (tim.length - 3), (tim.length - 3)E_SSIDssid_t *sizeof(ssid.ssid)sizeof(ssid.ssid) - 1u_char(*)[33]unsigned char(*)[33]E_CHALLENGEchallenge_t *uint8_t[254]unsigned char[254]sizeof(challenge.text)253sizeof(challenge.text) - 1uint8_t(*)[254]unsigned char(*)[254]E_RATESrates_t *sizeof rates.rateuint8_t(*)[16]unsigned char(*)[16]E_DSds_t *E_CFcf_t *E_TIMtim_t *uint8_t[251]unsigned char[251]251(int)sizeof tim.bitmapwep_printivIEEE802_11_IV_LEN + IEEE802_11_KID_LEN3 + 1(ndo, "Data IV:%3x Pad %x KeyID %x", IV_IV(iv), IV_PAD(iv), IV_KEYID(iv))(ndo, "Data IV:%3x Pad %x KeyID %x", ((iv) & 0xFFFFFF), (((iv) >> 24) & 0x3F), (((iv) >> 30) & 0x03))Data IV:%3x Pad %x KeyID %x16777215radiotap_stateieee80211_radiotap_typeIEEE80211_RADIOTAP_NAMESPACEieee80211_radiotap_headermeshcntl_tctrl_bar_tctrl_ba_tctrl_end_ack_tctrl_end_tctrl_ps_poll_tctrl_ack_tctrl_cts_tctrl_rts_tmgmt_body_ttim_tcf_tds_tfh_tchallenge_trates_tssid_tmgmt_header_tu64u32u16i16u8i8rateit_presentit_lenit_padit_versionaddr6addr5addr4seqttlfcsctltaradurdurationbssidaidtim_presentfh_presentcf_presentds_presentrates_presentssid_presentcapability_infochallenge_presentauth_trans_seq_numauth_algreason_codestatus_codelisten_intervalbeacon_intervaltimestampbitmapbitmap_controlperiodcountelement_iddur_remaingmax_durationchannelhop_indexhop_patternhop_setdwell_timetextseq_ctrlsadaconst char *[]char *[]Unspecified reason"Unspecified reason"Previous authentication no longer valid"Previous authentication no longer valid"Deauthenticated because sending station is leaving (or has left) IBSS or ESS"Deauthenticated because sending station is leaving (or has left) "
	  "IBSS or ESS"char[77]Disassociated due to inactivity"Disassociated due to inactivity"Disassociated because AP is unable to handle all currently  associated stations"Disassociated because AP is unable to handle all currently "
	  " associated stations"char[80]Class 2 frame received from nonauthenticated station"Class 2 frame received from nonauthenticated station"char[53]Class 3 frame received from nonassociated station"Class 3 frame received from nonassociated station"char[50]Disassociated because sending station is leaving (or has left) BSS"Disassociated because sending station is leaving "
	  "(or has left) BSS"char[67]Station requesting (re)association is not authenticated with responding station"Station requesting (re)association is not authenticated with "
	  "responding station"Disassociated because the information in the Power Capability element is unacceptable"Disassociated because the information in the Power Capability "
	  "element is unacceptable"char[86]Disassociated because the information in the SupportedChannels element is unacceptable"Disassociated because the information in the SupportedChannels "
	  "element is unacceptable"char[87]Invalid Information Element"Invalid Information Element"Michael MIC failure"Michael MIC failure"4-Way Handshake timeout"4-Way Handshake timeout"Group key update timeout"Group key update timeout"Information element in 4-Way Handshake different from (Re)AssociationRequest/Probe Response/Beacon"Information element in 4-Way Handshake different from (Re)Association"
	  "Request/Probe Response/Beacon"char[99]Group Cipher is not valid"Group Cipher is not valid"AKMP is not valid"AKMP is not valid"Unsupported RSN IE version"Unsupported RSN IE version"Invalid RSN IE Capabilities"Invalid RSN IE Capabilities"IEEE 802.1X Authentication failed"IEEE 802.1X Authentication failed"Cipher suite is rejected per security policy"Cipher suite is rejected per security policy"TS deleted because QoS AP lacks sufficient bandwidth for this QoS STA due to a change in BSS service characteristics or operational mode (e.g. an HT BSS change from 40 MHz channel to 20 MHz channel)"TS deleted because QoS AP lacks sufficient bandwidth for this "
	  "QoS STA due to a change in BSS service characteristics or "
	  "operational mode (e.g. an HT BSS change from 40 MHz channel "
	  "to 20 MHz channel)"char[199]Disassociated for unspecified, QoS-related reason"Disassociated for unspecified, QoS-related reason"Disassociated because QoS AP lacks sufficient bandwidth for this QoS STA"Disassociated because QoS AP lacks sufficient bandwidth for this "
	  "QoS STA"Disassociated because of excessive number of frames that need to be acknowledged, but are not acknowledged for AP transmissions and/or poor channel conditions"Disassociated because of excessive number of frames that need to be "
          "acknowledged, but are not acknowledged for AP transmissions "
	  "and/or poor channel conditions"char[159]Disassociated because STA is transmitting outside the limits of its TXOPs"Disassociated because STA is transmitting outside the limits "
	  "of its TXOPs"char[74]Requested from peer STA as the STA is leaving the BSS (or resetting)"Requested from peer STA as the STA is leaving the BSS "
	  "(or resetting)"char[69]Requested from peer STA as it does not want to use the mechanism"Requested from peer STA as it does not want to use the "
	  "mechanism"Requested from peer STA as the STA received frames using the mechanism for which a set up is required"Requested from peer STA as the STA received frames using the "
	  "mechanism for which a set up is required"char[102]Requested from peer STA due to time out"Requested from peer STA due to time out"Peer STA does not support the requested cipher suite"Peer STA does not support the requested cipher suite"Association denied due to requesting STA not supporting HT features"Association denied due to requesting STA not supporting HT "
	  "features"char[68]reason_textSuccessful"Successful"Unspecified failure"Unspecified failure"Cannot Support all requested capabilities in the Capability Information field"Cannot Support all requested capabilities in the Capability "
	  "Information field"char[78]Reassociation denied due to inability to confirm that association exists"Reassociation denied due to inability to confirm that association "
	  "exists"Association denied due to reason outside the scope of the standard"Association denied due to reason outside the scope of the "
	  "standard"Responding station does not support the specified authentication algorithm "Responding station does not support the specified authentication "
	  "algorithm "char[76]Received an Authentication frame with authentication transaction sequence number out of expected sequence"Received an Authentication frame with authentication transaction "
	  "sequence number out of expected sequence"char[106]Authentication rejected because of challenge failure"Authentication rejected because of challenge failure"Authentication rejected due to timeout waiting for next frame in sequence"Authentication rejected due to timeout waiting for next frame in "
	  "sequence"Association denied because AP is unable to handle additionalassociated stations"Association denied because AP is unable to handle additional"
	  "associated stations"Association denied due to requesting station not supporting all of the data rates in BSSBasicRateSet parameter"Association denied due to requesting station not supporting all of "
	  "the data rates in BSSBasicRateSet parameter"char[111]Association denied due to requesting station not supporting short preamble operation"Association denied due to requesting station not supporting "
	  "short preamble operation"char[85]Association denied due to requesting station not supporting PBCC encoding"Association denied due to requesting station not supporting "
	  "PBCC encoding"Association denied due to requesting station not supporting channel agility"Association denied due to requesting station not supporting "
	  "channel agility"Association request rejected because Spectrum Management capability is required"Association request rejected because Spectrum Management "
	  "capability is required"Association request rejected because the information in the Power Capability element is unacceptable"Association request rejected because the information in the "
	  "Power Capability element is unacceptable"char[101]Association request rejected because the information in the Supported Channels element is unacceptable"Association request rejected because the information in the "
	  "Supported Channels element is unacceptable"char[103]Association denied due to requesting station not supporting short slot operation"Association denied due to requesting station not supporting "
	  "short slot operation"char[81]Association denied due to requesting station not supporting DSSS-OFDM operation"Association denied due to requesting station not supporting "
	  "DSSS-OFDM operation"Association denied because the requested STA does not support HT features"Association denied because the requested STA does not support HT "
	  "features"Association denied because the requested STA does not support the PCO transition time required by the AP"Association denied because the requested STA does not support "
	  "the PCO transition time required by the AP"char[105]Unspecified, QoS-related failure"Unspecified, QoS-related failure"Association denied due to QAP having insufficient bandwidth to handle another QSTA"Association denied due to QAP having insufficient bandwidth "
	  "to handle another QSTA"char[83]Association denied due to excessive frame loss rates and/or poor conditions on current operating channel"Association denied due to excessive frame loss rates and/or "
	  "poor conditions on current operating channel"Association (with QBSS) denied due to requesting station not supporting the QoS facility"Association (with QBSS) denied due to requesting station not "
	  "supporting the QoS facility"char[89]Association denied due to requesting station not supporting Block Ack"Association denied due to requesting station not supporting "
	  "Block Ack"char[70]The request has been declined"The request has been declined"The request has not been successful as one or more parameters have invalid values"The request has not been successful as one or more parameters "
	  "have invalid values"char[82]The TS has not been created because the request cannot be honored. Try again with the suggested changes to the TSPEC"The TS has not been created because the request cannot be honored. "
	  "Try again with the suggested changes to the TSPEC"char[117]Pairwise Cipher is not valid"Pairwise Cipher is not valid"The TS has not been created. However, the HC may be capable of creating a TS, in response to a request, after the time indicated in the TS Delay element"The TS has not been created. However, the HC may be capable of "
	  "creating a TS, in response to a request, after the time indicated "
	  "in the TS Delay element"char[153]Direct Link is not allowed in the BSS by policy"Direct Link is not allowed in the BSS by policy"char[48]Destination STA is not present within this QBSS."Destination STA is not present within this QBSS."The Destination STA is not a QSTA."The Destination STA is not a QSTA."status_textOpen System"Open System"Shared Key"Shared Key"EAP"EAP"auth_alg_textieee80211_float_htrates[|802.11]"[|802.11]"tstrControl Wrapper"Control Wrapper"BAR"BAR"BA"BA"Power Save-Poll"Power Save-Poll"Request-To-Send"Request-To-Send"Clear-To-Send"Clear-To-Send"Acknowledgment"Acknowledgment"CF-End"CF-End"CF-End+CF-Ack"CF-End+CF-Ack"ctrl_strAssoc Request"Assoc Request"Assoc Response"Assoc Response"ReAssoc Request"ReAssoc Request"ReAssoc Response"ReAssoc Response"Probe Request"Probe Request"Probe Response"Probe Response"Beacon"Beacon"ATIM"ATIM"Disassociation"Disassociation"Authentication"Authentication"DeAuthentication"DeAuthentication"Action"Action"st_str0x802110020x80211001WLANCAP_MAGIC_COOKIE_BASE0x80211000BITBITNO_2BITNO_4BITNO_8BITNO_16BITNO_32IS_EXTENDED(__p)(EXTRACT_LE_32BITS(__p) & BIT(IEEE80211_RADIOTAP_EXT)) != 0BIT(n)(1U << n)BITNO_2(x)(((x) & 2) ? 1 : 0)BITNO_4(x)(((x) >> 2) ? 2 + BITNO_2((x) >> 2) : BITNO_2((x)))BITNO_8(x)(((x) >> 4) ? 4 + BITNO_4((x) >> 4) : BITNO_4((x)))BITNO_16(x)(((x) >> 8) ? 8 + BITNO_8((x) >> 8) : BITNO_8((x)))BITNO_32(x)(((x) >> 16) ? 16 + BITNO_16((x) >> 16) : BITNO_16((x)))IS_CHAN_ANYG(flags)(IS_CHAN_PUREG(flags) || IS_CHAN_G(flags))IS_CHAN_G(flags)((flags & IEEE80211_CHAN_G) == IEEE80211_CHAN_G)IS_CHAN_PUREG(flags)((flags & IEEE80211_CHAN_PUREG) == IEEE80211_CHAN_PUREG)IS_CHAN_B(flags)((flags & IEEE80211_CHAN_B) == IEEE80211_CHAN_B)IS_CHAN_A(flags)((flags & IEEE80211_CHAN_A) == IEEE80211_CHAN_A)IS_CHAN_FHSS(flags)((flags & IEEE80211_CHAN_FHSS) == IEEE80211_CHAN_FHSS)IEEE80211_CHAN_G(IEEE80211_CHAN_2GHZ | IEEE80211_CHAN_DYN)IEEE80211_CHAN_PUREG(IEEE80211_CHAN_2GHZ | IEEE80211_CHAN_OFDM)IEEE80211_CHAN_B(IEEE80211_CHAN_2GHZ | IEEE80211_CHAN_CCK)IEEE80211_CHAN_A(IEEE80211_CHAN_5GHZ | IEEE80211_CHAN_OFDM)IEEE80211_CHAN_FHSS(IEEE80211_CHAN_2GHZ | IEEE80211_CHAN_GFSK)roundup2(x,y)(((x)+((y)-1))&(~((y)-1)))ADDR4ADDR3ADDR2ADDR1(p + 24)(p + 16)(p + 10)(p + 4)PRINT_SELFPROT_ACTION(v)( (v) == 1 ? ND_PRINT((ndo, "Peering Open")) : (v) == 2 ? ND_PRINT((ndo, "Peering Confirm")) : (v) == 3 ? ND_PRINT((ndo, "Peering Close")) : (v) == 4 ? ND_PRINT((ndo, "Group Key Inform")) : (v) == 5 ? ND_PRINT((ndo, "Group Key Acknowledge")) : ND_PRINT((ndo, "Act#%d", (v))) )PRINT_MULTIHOP_ACTION(v)( (v) == 0 ? ND_PRINT((ndo, "Proxy Update")) : (v) == 1 ? ND_PRINT((ndo, "Proxy Update Confirmation")) : ND_PRINT((ndo, "Act#%d", (v))) )PRINT_MESH_ACTION(v)( (v) == 0 ? ND_PRINT((ndo, "MeshLink")) : (v) == 1 ? ND_PRINT((ndo, "HWMP")) : (v) == 2 ? ND_PRINT((ndo, "Gate Announcement")) : (v) == 3 ? ND_PRINT((ndo, "Congestion Control")) : (v) == 4 ? ND_PRINT((ndo, "MCCA Setup Request")) : (v) == 5 ? ND_PRINT((ndo, "MCCA Setup Reply")) : (v) == 6 ? ND_PRINT((ndo, "MCCA Advertisement Request")) : (v) == 7 ? ND_PRINT((ndo, "MCCA Advertisement")) : (v) == 8 ? ND_PRINT((ndo, "MCCA Teardown")) : (v) == 9 ? ND_PRINT((ndo, "TBTT Adjustment Request")) : (v) == 10 ? ND_PRINT((ndo, "TBTT Adjustment Response")) : ND_PRINT((ndo, "Act#%d", (v))) )PRINT_MESHPATH_ACTION(v)( (v) == 0 ? ND_PRINT((ndo, "Request")) : (v) == 1 ? ND_PRINT((ndo, "Report")) : (v) == 2 ? ND_PRINT((ndo, "Error")) : (v) == 3 ? ND_PRINT((ndo, "RootAnnouncement")) : ND_PRINT((ndo, "Act#%d", (v))) )PRINT_MESHPEERING_ACTION(v)( (v) == 0 ? ND_PRINT((ndo, "Open")) : (v) == 1 ? ND_PRINT((ndo, "Confirm")) : (v) == 2 ? ND_PRINT((ndo, "Close")) : ND_PRINT((ndo, "Act#%d", (v))) )PRINT_MESHLINK_ACTION(v)( (v) == 0 ? ND_PRINT((ndo, "Request")) : (v) == 1 ? ND_PRINT((ndo, "Report")) : ND_PRINT((ndo, "Act#%d", (v))) )PRINT_BA_ACTION(v)( (v) == 0 ? ND_PRINT((ndo, "ADDBA Request")) : (v) == 1 ? ND_PRINT((ndo, "ADDBA Response")) : (v) == 2 ? ND_PRINT((ndo, "DELBA")) : ND_PRINT((ndo, "Act#%d", (v))) )PRINT_HT_ACTION(v)( (v) == 0 ? ND_PRINT((ndo, "TxChWidth")) : (v) == 1 ? ND_PRINT((ndo, "MIMOPwrSave")) : ND_PRINT((ndo, "Act#%d", (v))) )(sizeof reason_text / sizeof reason_text[0])NUM_STATUSES(sizeof status_text / sizeof status_text[0])NUM_AUTH_ALGS(sizeof auth_alg_text / sizeof auth_alg_text[0])PRINT_DS_CHANNEL(p)if (p.ds_present) ND_PRINT((ndo, " CH: %u", p.ds.channel)); ND_PRINT((ndo, "%s", CAPABILITY_PRIVACY(p.capability_info) ? ", PRIVACY" : ""));PRINT_RATES(p)if (p.rates_present) { int z; const char *sep = " ["; for (z = 0; z < p.rates.length ; z++) { PRINT_RATE(sep, p.rates.rate[z], (p.rates.rate[z] & 0x80 ? "*" : "")); sep = " "; } if (p.rates.length != 0) ND_PRINT((ndo, " Mbit]")); }PRINT_RATE(_sep,_r,_suf)ND_PRINT((ndo, "%s%2.1f%s", _sep, (.5 * ((_r) & 0x7f)), _suf))PRINT_SSID(p)if (p.ssid_present) { ND_PRINT((ndo, " (")); fn_print(ndo, p.ssid.ssid, NULL); ND_PRINT((ndo, ")")); }IEEE80211_RADIOTAP_MCS_STBC_SHIFTIEEE80211_RADIOTAP_MCS_STBC_3IEEE80211_RADIOTAP_MCS_STBC_2IEEE80211_RADIOTAP_MCS_STBC_1IEEE80211_RADIOTAP_MCS_STBC_MASK0x60IEEE80211_RADIOTAP_MCS_FEC_LDPCIEEE80211_RADIOTAP_MCS_HT_GREENFIELDIEEE80211_RADIOTAP_MCS_BANDWIDTH_20UIEEE80211_RADIOTAP_MCS_BANDWIDTH_20LIEEE80211_RADIOTAP_MCS_BANDWIDTH_20IEEE80211_RADIOTAP_F_RX_PLCP_CRCIEEE80211_RADIOTAP_F_RX_BADFCSIEEE80211_CHAN_TG(IEEE80211_CHAN_2GHZ | IEEE80211_CHAN_DYN | IEEE80211_CHAN_TURBO)IEEE80211_CHAN_TA(IEEE80211_CHAN_5GHZ | IEEE80211_CHAN_OFDM | IEEE80211_CHAN_TURBO)0x400000x200000x100000x080000x04000IEEE80211_CHAN_STURBO0x02000IEEE80211_CHAN_GSM0x01000IEEE80211_CHAN_GFSK0x00800IEEE80211_CHAN_DYN0x00400IEEE80211_CHAN_PASSIVE0x00200IEEE80211_CHAN_5GHZ0x00100IEEE80211_CHAN_2GHZ0x00080IEEE80211_CHAN_OFDM0x00040IEEE80211_CHAN_CCK0x000200x00010IV_KEYID(iv)(((iv) >> 30) & 0x03)IV_PAD(iv)(((iv) >> 24) & 0x3F)IV_IV(iv)((iv) & 0xFFFFFF)(IEEE802_11_FC_LEN+IEEE802_11_DUR_LEN+ IEEE802_11_RA_LEN+IEEE802_11_TA_LEN+ IEEE802_11_CTL_LEN+IEEE802_11_SEQ_LEN)(IEEE802_11_FC_LEN+IEEE802_11_DUR_LEN+IEEE802_11_RA_LEN)(IEEE802_11_FC_LEN+IEEE802_11_DUR_LEN+ IEEE802_11_RA_LEN+IEEE802_11_BSSID_LEN)(IEEE802_11_FC_LEN+IEEE802_11_AID_LEN+ IEEE802_11_BSSID_LEN+IEEE802_11_TA_LEN)(IEEE802_11_FC_LEN+IEEE802_11_DUR_LEN+ IEEE802_11_RA_LEN+IEEE802_11_TA_LEN)E_IBSSE_FHCAPABILITY_PRIVACY(cap)((cap) & 0x0010)CAPABILITY_CFP_REQ(cap)((cap) & 0x0008)CAPABILITY_CFP(cap)((cap) & 0x0004)CAPABILITY_IBSS(cap)((cap) & 0x0002)CAPABILITY_ESS(cap)((cap) & 0x0001)(IEEE802_11_FC_LEN+IEEE802_11_DUR_LEN+ IEEE802_11_DA_LEN+IEEE802_11_SA_LEN+ IEEE802_11_BSSID_LEN+IEEE802_11_SEQ_LEN)FC_ORDER(fc)((fc) & 0x8000)FC_WEP(fc)((fc) & 0x4000)FC_MORE_DATA(fc)((fc) & 0x2000)FC_POWER_MGMT(fc)((fc) & 0x1000)FC_RETRY(fc)((fc) & 0x0800)FC_MORE_FLAG(fc)((fc) & 0x0400)FC_FROM_DS(fc)((fc) & 0x0200)FC_TO_DS(fc)((fc) & 0x0100)FC_TYPE(fc)(((fc) >> 2) & 0x3)FC_VERSION(fc)((fc) & 0x3)DATA_FRAME_IS_QOS(x)((x) & 0x08)DATA_FRAME_IS_NULL(x)((x) & 0x04)DATA_FRAME_IS_CF_POLL(x)((x) & 0x02)DATA_FRAME_IS_CF_ACK(x)((x) & 0x01)DATA_QOS_CF_ACK_POLL_NODATA0xFDATA_QOS_CF_POLL_NODATA0xEDATA_QOS_NODATA0xCDATA_QOS_DATA_CF_ACK_POLL0xBDATA_QOS_DATA_CF_POLL0xADATA_QOS_DATA_CF_ACK0x9DATA_QOS_DATA0x8DATA_NODATA_CF_ACK_POLL0x7DATA_NODATA_CF_POLL0x6DATA_NODATA_CF_ACK0x5DATA_NODATA0x4DATA_DATA_CF_ACK_POLL0x3DATA_DATA_CF_POLL0x2DATA_DATA_CF_ACK0x1DATA_DATA0x00xDT_RESVIEEE802_11_FCS_LENIEEE802_11_KID_LENIEEE802_11_IV_LENIEEE802_11_CTL_LENIEEE802_11_SEQ_LENIEEE802_11_TA_LENIEEE802_11_RA_LENIEEE802_11_BSSID_LENIEEE802_11_SA_LENIEEE802_11_DA_LENIEEE802_11_DUR_LENroundup2/*
 * For DLT_IEEE802_11_RADIO_AVS; like DLT_IEEE802_11, but with an
 * extra header, containing information such as radio information,
 * which we currently ignore.
 *//*
 * For DLT_IEEE802_11_RADIO; like DLT_IEEE802_11, but with an extra
 * header, containing information such as radio information.
 *//*
 * For DLT_PRISM_HEADER; like DLT_IEEE802_11, but with an extra header,
 * containing information such as radio information, which we
 * currently ignore.
 *
 * If, however, the packet begins with WLANCAP_MAGIC_COOKIE_V1 or
 * WLANCAP_MAGIC_COOKIE_V2, it's really DLT_IEEE802_11_RADIO_AVS
 * (currently, on Linux, there's no ARPHRD_ type for
 * DLT_IEEE802_11_RADIO_AVS, as there is a ARPHRD_IEEE80211_PRISM
 * for DLT_PRISM_HEADER, so ARPHRD_IEEE80211_PRISM is used for
 * the AVS header, and the first 4 bytes of the header are used to
 * indicate whether it's a Prism header or an AVS header).
 *//*
		 * Yow!  The capture header length is claimed not
		 * to be large enough to include even the version
		 * cookie or capture header length!
		 *//* FCS at end of packet *//* Atheros padding *//* extract the least significant bit that is set *//* clear the least significant bit that is set *//* Clear state. *//* Assume no FCS at end of frame *//* Assume no Atheros padding between 802.11 header and body *//* Assume no flags *//* are there more bitmap extensions than bytes in header? *//* more bitmaps *//* includes the 1st bitmap *//* align against header start *//*
				 * We at least have the MCS index.
				 * Print it.
				 *//*
				 * We have the rate.
				 * Print it.
				 *//*
				 * The MCS value is out of range.
				 *//*
					 * We don't know both the bandwidth
					 * and the guard interval, so we can
					 * only report the MCS index.
					 *//*
					 * And we know both the bandwidth and
					 * the guard interval, so we can look
					 * up the rate.
					 *//*
				 * And it's in-range.
				 *//*
			 * We know the MCS index.
			 *//* Do nothing for now *//*
			 * XXX - we don't know the channel width
			 * or guard interval length, so we can't
			 * convert this to a data rate.
			 *
			 * If you want us to show a data rate,
			 * use the MCS field, not the Rate field;
			 * the MCS field includes not only the
			 * MCS index, it also includes bandwidth
			 * and guard interval information.
			 *
			 * XXX - can we get the channel width
			 * from XChannel and the guard interval
			 * information from Flags, at least on
			 * FreeBSD?
			 *//*
		 * XXX On FreeBSD rate & 0x80 means we have an MCS. On
		 * Linux and AirPcap it does not.  (What about
		 * Mac OS X, NetBSD, OpenBSD, and DragonFly BSD?)
		 *
		 * This is an issue either for proprietary extensions
		 * to 11a or 11g, which do exist, or for 11n
		 * implementations that stuff a rate value into
		 * this field, which also appear to exist.
		 *
		 * We currently handle that by assuming that
		 * if the 0x80 bit is set *and* the remaining
		 * bits have a value between 0 and 15 it's
		 * an MCS value, otherwise it's a rate.  If
		 * there are cases where systems that use
		 * "0x80 + MCS index" for MCS indices > 15,
		 * or stuff a rate value here between 64 and
		 * 71.5 Mb/s in here, we'll need a preference
		 * setting.  Such rates do exist, e.g. 11n
		 * MCS 7 at 20 MHz with a long guard interval.
		 *//*
		 * If CHANNEL and XCHANNEL are both present, skip
		 * CHANNEL.
		 *//* Preserve the state present flags *//* this bit indicates a field whose
		 * size we do not know, so we cannot
		 * proceed.  Just print the bit number.
		 *//* Skip up to length *//* Save state rate *//*
 * This is the top level routine of the printer.  'p' points
 * to the 802.11 header of the packet, 'h->ts' is the timestamp,
 * 'h->len' is the length of the packet off the wire, and 'h->caplen'
 * is the number of bytes actually captured.
 *//*
			 * Some kinds of LLC packet we cannot
			 * handle intelligently
			 *//* There may be a problem w/ AP not having this bit set *//* no-data frame *//*
	 * Go past the 802.11 header.
	 *//* Amount of FCS in actual packet data, if any *//* Remove FCS, if present *//* if y is powers of two *//*
 * Print the 802.11 MAC header if eflag is set, and set "*srcp" and "*dstp"
 * to point to the source and destination MAC addresses in any case if
 * "srcp" and "dstp" aren't null.
 *//*
 *  Data Frame - Address field contents
 *
 *  To Ds  | From DS | Addr 1 | Addr 2 | Addr 3 | Addr 4
 *    0    |  0      |  DA    | SA     | BSSID  | n/a
 *    0    |  1      |  DA    | BSSID  | SA     | n/a
 *    1    |  0      |  BSSID | SA     | DA     | n/a
 *    1    |  1      |  RA    | TA     | DA     | SA
 *//*
 * Print Header funcs
 *//* XXX - requires special handling *//*********************************************************************************
 * Handles printing all the control frame types
 *********************************************************************************//*********************************************************************************
 * Print Body funcs
 *********************************************************************************//* the frame body for ATIM is null. *//* Same as a Association Reponse *//*********************************************************************************
 * Print Handle functions for the management frame types
 *********************************************************************************//* No problems found. *//*
			 * Present and not truncated.
			 *
			 * If we haven't already seen a TIM IE,
			 * copy this one, otherwise ignore this one,
			 * so we later report the first one we saw.
			 *//*
			 * Present and not truncated.
			 *
			 * If we haven't already seen a CF IE,
			 * copy this one, otherwise ignore this one,
			 * so we later report the first one we saw.
			 *//*
			 * Present and not truncated.
			 *
			 * If we haven't already seen a DS IE,
			 * copy this one, otherwise ignore this one,
			 * so we later report the first one we saw.
			 *//*
			 * Present and not truncated.
			 *
			 * If we haven't already seen a rates IE,
			 * copy this one if it's not zero-length,
			 * otherwise ignore this one, so we later
			 * report the first one we saw.
			 *
			 * We ignore zero-length rates IEs as some
			 * devices seem to put a zero-length rates
			 * IE, followed by an SSID IE, followed by
			 * a non-zero-length rates IE into frames,
			 * even though IEEE Std 802.11-2007 doesn't
			 * seem to indicate that a zero-length rates
			 * IE is valid.
			 *//*
			 * Present and not truncated.
			 *
			 * If we haven't already seen a challenge IE,
			 * copy this one, otherwise ignore this one,
			 * so we later report the first one we saw.
			 *//*
			 * Present and not truncated.
			 *
			 * If we haven't already seen an SSID IE,
			 * copy this one, otherwise ignore this one,
			 * so we later report the first one we saw.
			 *//* Make sure we have the entire element. *//* Make sure we at least have the element ID and length. *//*
	 * We haven't seen any elements yet.
	 *//* 46 *//* 45 *//* 44 *//* 43 *//* 42 *//* 41 *//* 40 *//* 39 *//* 38 *//* 37 *//* 36 *//* 35 *//* 34 *//* 33 *//* 32 *//* 31 *//* 30 *//* 29 *//* 28 *//* 27 *//* 26 *//* 25 *//* 24 *//* 23 *//* 22 *//* 21 *//* 20 *//* 18 *//* 17 *//* 16 *//* 15 *//* 14 *//* 13 *//* 12 *//* 11 *//* 10 *//* 9 *//* 8 *//* 7 *//* 6 *//* 5 *//* 4 *//* 3 *//* 2 *//* 1 *//* 0 *//* 50 *//* 49 *//* 48 *//* 47 *//* 19 *//*  9 *//*  8 *//*  7 *//*  6 *//*  5 *//*  4 *//*  3 *//*  2 *//*  1 *//*  0 *//* SGI *//* 40 Mhz *//* 20 Mhz *//* MCS 76  *//* MCS 75  *//* MCS 74  *//* MCS 73  *//* MCS 72  *//* MCS 71  *//* MCS 70  *//* MCS 69  *//* MCS 68  *//* MCS 67  *//* MCS 66  *//* MCS 65  *//* MCS 64  *//* MCS 63  *//* MCS 62  *//* MCS 61  *//* MCS 60  *//* MCS 59  *//* MCS 58  *//* MCS 57  *//* MCS 56  *//* MCS 55  *//* MCS 54  *//* MCS 53  *//* MCS 52  *//* MCS 51  *//* MCS 50  *//* MCS 49  *//* MCS 48  *//* MCS 47  *//* MCS 46  *//* MCS 45  *//* MCS 44  *//* MCS 43  *//* MCS 42  *//* MCS 41  *//* MCS 40  *//* MCS 39  *//* MCS 38  *//* MCS 37  *//* MCS 36  *//* MCS 35  *//* MCS 34  *//* MCS 33  *//* not valid *//* MCS 32  *//* MCS 31  *//* MCS 30  *//* MCS 29  *//* MCS 28  *//* MCS 27  *//* MCS 26  *//* MCS 25  *//* MCS 24  *//* MCS 23  *//* MCS 22  *//* MCS 21  *//* MCS 20  *//* MCS 19  *//* MCS 18  *//* MCS 17  *//* MCS 16  *//* MCS 15  *//* MCS 14  *//* MCS 13  *//* MCS 12  *//* MCS 11  *//* MCS 10  *//* MCS  9  *//* MCS  8  *//* MCS  7  *//* MCS  6  *//* MCS  5  *//* MCS  4  *//* MCS  3  *//* MCS  2  *//* MCS  1  *//* MCS  0  *//*
 * Indices are:
 *
 *	the MCS index (0-76);
 *
 *	0 for 20 MHz, 1 for 40 MHz;
 *
 *	0 for a long guard interval, 1 for a short guard interval.
 *//*  This is used to save state when parsing/processing parameters *//* Radiotap state *//* short guard interval *//* For IEEE80211_RADIOTAP_MCS flags *//* MCS index field *//* For IEEE80211_RADIOTAP_MCS known *//* frame failed PLCP CRC check *//* frame failed crc check *//* For IEEE80211_RADIOTAP_RX_FLAGS *//* does not pass FCS check *//* frame has padding between
						 * 802.11 header and payload
						 * (to 32-bit boundary)
						 *//* frame includes FCS *//* sent/received
						 * with fragmentation
						 *//* sent/received
						 * with WEP encryption
						 *//* sent/received
						 * with short
						 * preamble
						 *//* sent/received
						 * during CFP
						 *//* For IEEE80211_RADIOTAP_FLAGS *//* Useful combinations of channel characteristics, borrowed from Ethereal *//* HT 40 channel w/ ext below *//* HT 40 channel w/ ext above *//* HT 20 channel *//* Quarter rate channel *//* Half rate channel *//* 11a static turbo channel only *//* 900 MHz spectrum channel *//* GFSK channel (FHSS PHY) *//* Dynamic CCK-OFDM channel *//* Only passive scan allowed *//* 5 GHz spectrum channel *//* 2 GHz spectrum channel. *//* OFDM channel *//* CCK channel *//* Turbo channel *//* channel attributes *//* NB: gap for netbsd definitions *//* Name                                 Data type       Units
 * ----                                 ---------       -----
 *
 * IEEE80211_RADIOTAP_TSFT              uint64_t       microseconds
 *
 *      Value in microseconds of the MAC's 64-bit 802.11 Time
 *      Synchronization Function timer when the first bit of the
 *      MPDU arrived at the MAC. For received frames, only.
 *
 * IEEE80211_RADIOTAP_CHANNEL           2 x uint16_t   MHz, bitmap
 *
 *      Tx/Rx frequency in MHz, followed by flags (see below).
 *	Note that IEEE80211_RADIOTAP_XCHANNEL must be used to
 *	represent an HT channel as there is not enough room in
 *	the flags word.
 *
 * IEEE80211_RADIOTAP_FHSS              uint16_t       see below
 *
 *      For frequency-hopping radios, the hop set (first byte)
 *      and pattern (second byte).
 *
 * IEEE80211_RADIOTAP_RATE              uint8_t        500kb/s or index
 *
 *      Tx/Rx data rate.  If bit 0x80 is set then it represents an
 *	an MCS index and not an IEEE rate.
 *
 * IEEE80211_RADIOTAP_DBM_ANTSIGNAL     int8_t          decibels from
 *                                                      one milliwatt (dBm)
 *
 *      RF signal power at the antenna, decibel difference from
 *      one milliwatt.
 *
 * IEEE80211_RADIOTAP_DBM_ANTNOISE      int8_t          decibels from
 *                                                      one milliwatt (dBm)
 *
 *      RF noise power at the antenna, decibel difference from one
 *      milliwatt.
 *
 * IEEE80211_RADIOTAP_DB_ANTSIGNAL      uint8_t        decibel (dB)
 *
 *      RF signal power at the antenna, decibel difference from an
 *      arbitrary, fixed reference.
 *
 * IEEE80211_RADIOTAP_DB_ANTNOISE       uint8_t        decibel (dB)
 *
 *      RF noise power at the antenna, decibel difference from an
 *      arbitrary, fixed reference point.
 *
 * IEEE80211_RADIOTAP_LOCK_QUALITY      uint16_t       unitless
 *
 *      Quality of Barker code lock. Unitless. Monotonically
 *      nondecreasing with "better" lock strength. Called "Signal
 *      Quality" in datasheets.  (Is there a standard way to measure
 *      this?)
 *
 * IEEE80211_RADIOTAP_TX_ATTENUATION    uint16_t       unitless
 *
 *      Transmit power expressed as unitless distance from max
 *      power set at factory calibration.  0 is max power.
 *      Monotonically nondecreasing with lower power levels.
 *
 * IEEE80211_RADIOTAP_DB_TX_ATTENUATION uint16_t       decibels (dB)
 *
 *      Transmit power expressed as decibel distance from max power
 *      set at factory calibration.  0 is max power.  Monotonically
 *      nondecreasing with lower power levels.
 *
 * IEEE80211_RADIOTAP_DBM_TX_POWER      int8_t          decibels from
 *                                                      one milliwatt (dBm)
 *
 *      Transmit power expressed as dBm (decibels from a 1 milliwatt
 *      reference). This is the absolute power level measured at
 *      the antenna port.
 *
 * IEEE80211_RADIOTAP_FLAGS             uint8_t        bitmap
 *
 *      Properties of transmitted and received frames. See flags
 *      defined below.
 *
 * IEEE80211_RADIOTAP_ANTENNA           uint8_t        antenna index
 *
 *      Unitless indication of the Rx/Tx antenna for this packet.
 *      The first antenna is antenna 0.
 *
 * IEEE80211_RADIOTAP_RX_FLAGS          uint16_t       bitmap
 *
 *     Properties of received frames. See flags defined below.
 *
 * IEEE80211_RADIOTAP_XCHANNEL          uint32_t	bitmap
 *					uint16_t	MHz
 *					uint8_t		channel number
 *					uint8_t		.5 dBm
 *
 *	Extended channel specification: flags (see below) followed by
 *	frequency in MHz, the corresponding IEEE channel number, and
 *	finally the maximum regulatory transmit power cap in .5 dBm
 *	units.  This property supersedes IEEE80211_RADIOTAP_CHANNEL
 *	and only one of the two should be present.
 *
 * IEEE80211_RADIOTAP_MCS		uint8_t		known
 *					uint8_t		flags
 *					uint8_t		mcs
 *
 *	Bitset indicating which fields have known values, followed
 *	by bitset of flag values, followed by the MCS rate index as
 *	in IEEE 802.11n.
 *
 * IEEE80211_RADIOTAP_VENDOR_NAMESPACE
 *					uint8_t  OUI[3]
 *                                   uint8_t  subspace
 *                                   uint16_t length
 *
 *     The Vendor Namespace Field contains three sub-fields. The first
 *     sub-field is 3 bytes long. It contains the vendor's IEEE 802
 *     Organizationally Unique Identifier (OUI). The fourth byte is a
 *     vendor-specific "namespace selector."
 *
 *//* A bitmap telling which
					 * fields are present. Set bit 31
					 * (0x80000000) to extend the
					 * bitmap by another 32 bits.
					 * Additional extensions are made
					 * by setting bit 31.
					 *//* length of the whole
					 * header in bytes, including
					 * it_version, it_pad,
					 * it_len, and data fields.
					 *//* Version 0. Only increases
					 * for drastic changes,
					 * introduction of compatible
					 * new fields does not count.
					 *//*
 * The radio capture header precedes the 802.11 header.
 *
 * Note well: all radiotap fields are little-endian.
 *//* A generic radio capture format is desirable. It must be
 * rigidly defined (e.g., units for fields should be given),
 * and easily extensible.
 *
 * The following is an extensible radio capture format. It is
 * based on a bitmap indicating which fields are present.
 *
 * I am trying to describe precisely what the application programmer
 * should expect in the following, and for that reason I tell the
 * units and origin of each measurement (where it applies), or else I
 * use sufficiently weaselly language ("is a monotonically nondecreasing
 * function of...") that I cannot set false expectations for lawyerly
 * readers.
 *//* NetBSD: ieee802_11_radio.h,v 1.2 2006/02/26 03:04:03 dyoung Exp  *//* $FreeBSD: src/sys/net80211/ieee80211_radiotap.h,v 1.5 2005/01/22 20:12:05 sam Exp $ *//* reserved 		16 *//* reserved 		19 *//* reserved 		18 *//* reserved 		17 *//* reserved 		15 *//* reserved 		14 *//* reserved 		13 *//* reserved 		12 *//* reserved 		11 *//* reserved 		10 *//* reserved 		9 *//* reserved 		8 *//* reserved 		7 *//* 1-253 + 1 for null *//* 32 + 1 for null *//*
 * Bits in the frame control field.
 *//*
 * The subtype field of a data frame is, in effect, composed of 4 flag
 * bits - CF-Ack, CF-Poll, Null (means the frame doesn't actually have
 * any data), and QoS.
 *//* RESERVED 			0xF  *//* RESERVED 			0xE  *//* RESERVED 			0x7  *//* RESERVED 			0x6  *//* reserved *//* data *//* control *//* management *//* Length of previous AP in reassocation frame *//* Lengths of beacon components. *//* Frame check sequence length. *//* Lengths of 802.11 header components. *//*
 * Copyright (c) 2001
 *	Fortress Technologies, Inc.  All rights reserved.
 *      Charlie Lenahan (clenahan@fortresstech.com)
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that: (1) source code distributions
 * retain the above copyright notice and this paragraph in its entirety, (2)
 * distributions including binary code include the above copyright notice and
 * this paragraph in its entirety in the documentation or other materials
 * provided with the distribution, and (3) all advertising materials mentioning
 * features or use of this software display the following acknowledgement:
 * ``This product includes software developed by the University of California,
 * Lawrence Berkeley Laboratory and its contributors.'' Neither the name of
 * the University nor the names of its contributors may be used to endorse
 * or promote products derived from this software without specific prior
 * written permission.
 * THIS SOFTWARE IS PROVIDED ``AS IS'' AND WITHOUT ANY EXPRESS OR IMPLIED
 * WARRANTIES, INCLUDING, WITHOUT LIMITATION, THE IMPLIED WARRANTIES OF
 * MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE.
 *//Users/owura/Repos/codeql_eval/proj_repos/the-tcpdump-group-tcpdump-commit-0f95d441e4b5d7512cc5c326c8668a120e048eda/tcpdump/print-802_15_4.cieee802_15_4_if_print(ndo, "[|802.15.4] %x", caplen)[|802.15.4] %xp + 2(ndo,"IEEE 802.15.4 %s packet ", ftypes[fc & 0x7])IEEE 802.15.4 %s packet const char *[8]char *[8](ndo,"seq %02x ", seq)seq %02x (ndo,"malformed! ")malformed! (ndo,"none ")(ndo,"reserved destination addressing mode")(ndo,"%04x:%04x ", panid, EXTRACT_LE_16BITS(p))(ndo,"%04x:%04x ", panid, ((uint16_t)(((uint16_t)(*((const uint8_t *)(p) + 1)) << 8) | ((uint16_t)(*((const uint8_t *)(p) + 0)) << 0))))(ndo,"%04x:%s ", panid, le64addr_string(p))(ndo,"< ")(ndo,"reserved source addressing mode")panidnone reserved destination addressing mode%04x:%04x %04x:%s < reserved source addressing mode1 << 6(1 << 6)Data"Data"ACK"ACK"Command"Command"ftypes/* intra-PAN with none dest addr *//*
 * Copyright (c) 2009
 * 	Siemens AG, All rights reserved.
 * 	Dmitry Eremin-Solenikov (dbaryshkov@gmail.com)
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that: (1) source code distributions
 * retain the above copyright notice and this paragraph in its entirety, (2)
 * distributions including binary code include the above copyright notice and
 * this paragraph in its entirety in the documentation or other materials
 * provided with the distribution, and (3) all advertising materials mentioning
 * features or use of this software display the following acknowledgement:
 * ``This product includes software developed by the University of California,
 * Lawrence Berkeley Laboratory and its contributors.'' Neither the name of
 * the University nor the names of its contributors may be used to endorse
 * or promote products derived from this software without specific prior
 * written permission.
 * THIS SOFTWARE IS PROVIDED ``AS IS'' AND WITHOUT ANY EXPRESS OR IMPLIED
 * WARRANTIES, INCLUDING, WITHOUT LIMITATION, THE IMPLIED WARRANTIES OF
 * MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE.
 *//Users/owura/Repos/codeql_eval/proj_repos/the-tcpdump-group-tcpdump-commit-0f95d441e4b5d7512cc5c326c8668a120e048eda/tcpdump/ah.hnewahahah_seqah_spiah_reserveah_lenah_nxt_NETINET6_AH_H_/*_NETINET6_AH_H_*//* Authentication data *//* variable size, 32bit bound*//* Sequence number field *//* Security parameter index *//* Reserved for future use *//* Length of data + 1, in 32bit *//* Next Header *//* Length of data, in 32bit *//*
 * RFC1826/2402 authentication header.
 *//*
 * Copyright (C) 1995, 1996, 1997, and 1998 WIDE Project.
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. Neither the name of the project nor the names of its contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE PROJECT AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE PROJECT OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 *//*	$KAME: ah.h,v 1.12 2000/07/20 17:41:01 itojun Exp $	*//*	$NetBSD: ah.h,v 1.12 2000/07/23 05:23:04 itojun Exp $	*//Users/owura/Repos/codeql_eval/proj_repos/the-tcpdump-group-tcpdump-commit-0f95d441e4b5d7512cc5c326c8668a120e048eda/tcpdump/print-ah.c"ah.h"ah_printconst ahconst ah *ah *sumlenspi*ahsizeof(*ah)&ah->ah_spiconst uint32_tconst uint32_t *(ndo, "AH(spi=0x%08x", spi)AH(spi=0x%08x(ndo, ",sumlen=%d", sumlen),sumlen=%d(ndo, ",seq=0x%x", EXTRACT_32BITS(ah + 1))(ndo, ",seq=0x%x", ((uint32_t)(((uint32_t)(*((const uint8_t *)(ah + 1) + 0)) << 24) | ((uint32_t)(*((const uint8_t *)(ah + 1) + 1)) << 16) | ((uint32_t)(*((const uint8_t *)(ah + 1) + 2)) << 8) | ((uint32_t)(*((const uint8_t *)(ah + 1) + 3)) << 0)))),seq=0x%xah + 1(ndo, "[truncated]")sizeof(struct ah)[truncated](ndo, "): ")): trunc(ndo, "[|AH]")[|AH]/* 'ep' points to the end of available data. *//*
 * Copyright (c) 1988, 1989, 1990, 1991, 1992, 1993, 1994
 *	The Regents of the University of California.  All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that: (1) source code distributions
 * retain the above copyright notice and this paragraph in its entirety, (2)
 * distributions including binary code include the above copyright notice and
 * this paragraph in its entirety in the documentation or other materials
 * provided with the distribution, and (3) all advertising materials mentioning
 * features or use of this software display the following acknowledgement:
 * ``This product includes software developed by the University of California,
 * Lawrence Berkeley Laboratory and its contributors.'' Neither the name of
 * the University nor the names of its contributors may be used to endorse
 * or promote products derived from this software without specific prior
 * written permission.
 * THIS SOFTWARE IS PROVIDED ``AS IS'' AND WITHOUT ANY EXPRESS OR IMPLIED
 * WARRANTIES, INCLUDING, WITHOUT LIMITATION, THE IMPLIED WARRANTIES OF
 * MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE.
 *//*	$NetBSD: print-ah.c,v 1.4 1996/05/20 00:41:16 fvdl Exp $	*/bp/Users/owura/Repos/codeql_eval/proj_repos/the-tcpdump-group-tcpdump-commit-0f95d441e4b5d7512cc5c326c8668a120e048eda/tcpdump/print-ahcp.cahcp_printconst u_intversion(ndo, "AHCP")AHCP*cpAHCP_MAGIC_NUMBER(ndo, " Version 1")AHCP1_HEADER_FIX_LEN - 224 - 2(ndo, "\n\tHopcount %u", *cp)(ndo, ", Original Hopcount %u", *cp)(ndo, ", Nonce 0x%08x", EXTRACT_32BITS(cp))(ndo, ", Nonce 0x%08x", ((uint32_t)(((uint32_t)(*((const uint8_t *)(cp) + 0)) << 24) | ((uint32_t)(*((const uint8_t *)(cp) + 1)) << 16) | ((uint32_t)(*((const uint8_t *)(cp) + 2)) << 8) | ((uint32_t)(*((const uint8_t *)(cp) + 3)) << 0))))(ndo, ", Source Id %s", linkaddr_string(ndo, cp, 0, 8))(ndo, ", Destination Id %s", linkaddr_string(ndo, cp, 0, 8))(ndo, " Version %u (unknown)", version)AHCP_VERSION_1 Version 1AHCP1_HEADER_FIX_LEN
	Hopcount %u, Original Hopcount %u, Nonce 0x%08x, Source Id %s, Destination Id %s Version %u (unknown)corrupt(ndo, " %s", cstr)ep - cpconst char[9]ahcp1_body_printmbzbody_lenAHCP1_BODY_MIN_LEN(ndo, "\n\t%s", tok2str(ahcp1_msg_str, "Unknown-%u", type))(ndo, ", MBZ %u", mbz)(ndo, ", Length %u", body_len)
	%sconst tok[7]tok[7]Unknown-%u, MBZ %u, Length %uahcp1_options_printoption_nooption_len(ndo, "\n\t %s", tok2str(ahcp1_opt_str, "Unknown-%u", option_no))(ndo, " (Length %u)", option_len)
	 %sAHCP1_OPT_PADAHCP1_OPT_MANDATORYAHCP1_OPT_MAX..(*const)(..)..(*const[14])(..)..(*[14])(..)..(*const *)(..)..(**)(..) (Length %u)ahcp_ipv4_prefixes_print": "(ndo, "%s%s/%u", sep, ipaddr_string(ndo, cp), *(cp + 4))(ndo, "%s%s/%u", sep, getname(ndo, (const u_char *)(cp)), *(cp + 4))%s%s/%u, ", "(ndo, ": %s", cstr)ahcp_ipv6_prefixes_print(ndo, "%s(compiled w/o IPv6)/%u", sep, *(cp + 16))%s(compiled w/o IPv6)/%uahcp_ipv4_addresses_print(ndo, "%s%s", sep, ipaddr_string(ndo, cp))(ndo, "%s%s", sep, getname(ndo, (const u_char *)(cp)))%s%sahcp_ipv6_addresses_print(ndo, "%s(compiled w/o IPv6)", sep)%s(compiled w/o IPv6)ahcp_seconds_print(ndo, ": %us", EXTRACT_32BITS(cp))(ndo, ": %us", ((uint32_t)(((uint32_t)(*((const uint8_t *)(cp) + 0)) << 24) | ((uint32_t)(*((const uint8_t *)(cp) + 1)) << 16) | ((uint32_t)(*((const uint8_t *)(cp) + 2)) << 8) | ((uint32_t)(*((const uint8_t *)(cp) + 3)) << 0)))): %usahcp_time_printtm(ndo, ": gmtime() error")(ndo, ": strftime() error")(ndo, ": %s UTC", buf): gmtime() errorchar *__restrict__const tmconst tm *const tm *__restrict__%Y-%m-%d %H:%M:%S"%Y-%m-%d %H:%M:%S": strftime() error: %s UTCdata_decodersPad"Pad"Mandatory"Mandatory"AHCP1_OPT_ORIGIN_TIMEOrigin Time"Origin Time"AHCP1_OPT_EXPIRESExpires"Expires"AHCP1_OPT_MY_IPV6_ADDRESSMy-IPv6-Address"My-IPv6-Address"AHCP1_OPT_MY_IPV4_ADDRESSMy-IPv4-Address"My-IPv4-Address"AHCP1_OPT_IPV6_PREFIXIPv6 Prefix"IPv6 Prefix"AHCP1_OPT_IPV4_PREFIXIPv4 Prefix"IPv4 Prefix"AHCP1_OPT_IPV6_ADDRESSIPv6 Address"IPv6 Address"AHCP1_OPT_IPV4_ADDRESSIPv4 Address"IPv4 Address"AHCP1_OPT_IPV6_PREFIX_DELEGATIONIPv6 Prefix Delegation"IPv6 Prefix Delegation"AHCP1_OPT_IPV4_PREFIX_DELEGATIONIPv4 Prefix Delegation"IPv4 Prefix Delegation"AHCP1_OPT_NAME_SERVERName Server"Name Server"AHCP1_OPT_NTP_SERVERNTP Server"NTP Server"ahcp1_opt_strAHCP1_MSG_DISCOVERDiscover"Discover"AHCP1_MSG_OFFEROffer"Offer"AHCP1_MSG_REQUESTRequest"Request"AHCP1_MSG_ACK"Ack"AHCP1_MSG_NACKNack"Nack"AHCP1_MSG_RELEASERelease"Release"ahcp1_msg_str(corrupt)"(corrupt)"cstr [|ahcp]" [|ahcp]"/* Body *//* Destination Id *//* Source Id *//* Nonce *//* Original Hopcount *//* Hopcount *//* Version *//* Magic *//* not ep (ignore extra data) *//* Options *//* Length *//* MBZ *//* Type *//* truncated and already marked up *//* Value *//* Option no *//* [AHCP1_OPT_NTP_SERVER]             = *//* [AHCP1_OPT_NAME_SERVER]            = *//* [AHCP1_OPT_IPV4_PREFIX_DELEGATION] = *//* [AHCP1_OPT_IPV6_PREFIX_DELEGATION] = *//* [AHCP1_OPT_IPV4_ADDRESS]           = *//* [AHCP1_OPT_IPV6_ADDRESS]           = *//* [AHCP1_OPT_IPV4_PREFIX]            = *//* [AHCP1_OPT_IPV6_PREFIX]            = *//* [AHCP1_OPT_MY_IPV4_ADDRESS]        = *//* [AHCP1_OPT_MY_IPV6_ADDRESS]        = *//* [AHCP1_OPT_EXPIRES]                = *//* [AHCP1_OPT_ORIGIN_TIME]            = *//* [AHCP1_OPT_MANDATORY]              = *//* [AHCP1_OPT_PAD]                    = *//* Data decoders signal truncated data with -1. *//*
 * This module implements decoding of AHCP (Ad Hoc Configuration Protocol) based
 * on draft-chroboczek-ahcp-00 and source code of ahcpd-0.53.
 *
 *
 * Copyright (c) 2013 The TCPDUMP project
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
 * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
 * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS
 * FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE
 * COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT,
 * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,
 * BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
 * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
 * CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN
 * ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
 * POSSIBILITY OF SUCH DAMAGE.
 *//Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/lib/clang/13.1.6/include/__stddef_max_align_t.hmax_align_t__CLANG_MAX_ALIGN_T_DEFINEDdefined(_MSC_VER)defined(__APPLE__)__APPLE__// Define 'max_align_t' to match the GCC definition./*===---- __stddef_max_align_t.h - Definition of max_align_t for modules ---===
 *
 * Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.
 * See https://llvm.org/LICENSE.txt for license information.
 * SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
 *
 *===-----------------------------------------------------------------------===
 *//Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/lib/clang/13.1.6/include/stddef.h"__stddef_max_align_t.h"ptrdiff_t__need_STDDEF_H_miscoffsetof(t,d)__builtin_offsetof(t, d)__need_NULL((void*)0)__need_wchar_t__need_size_t__need_ptrdiff_t_PTRDIFF_T__STDDEF_H!defined(__STDDEF_H) || defined(__need_ptrdiff_t) ||                       \!defined(__need_ptrdiff_t) && !defined(__need_size_t) &&                   \!__has_feature(modules)defined(__need_ptrdiff_t)!defined(_PTRDIFF_T) || __has_feature(modules)defined(__need_size_t)!defined(_SIZE_T) || __has_feature(modules)defined(__need_STDDEF_H_misc)(defined(__STDC_WANT_LIB_EXT1__) && __STDC_WANT_LIB_EXT1__ >= 1 && \defined(__need_wchar_t)!defined(_WCHAR_T) || __has_feature(modules)defined(_MSC_EXTENSIONS)defined(__need_NULL)!defined(__MINGW32__) && !defined(_MSC_VER)defined(_MSC_EXTENSIONS) && defined(_NATIVE_NULLPTR_SUPPORTED)__STDC_VERSION__ >= 201112L || __cplusplus >= 201103Ldefined(__need_wint_t)!defined(_WINT_T) || __has_feature(modules)__PTRDIFF_TYPE__long int/* __need_wint_t *//* Always define wint_t when modules are available. *//* Some C libraries expect to see a wint_t here. Others (notably MinGW) will use
__WINT_TYPE__ directly; accommodate both by requiring __need_wint_t *//* defined(__need_STDDEF_H_misc) *//* defined(__need_NULL) *//* defined(__need_wchar_t) *//* Always define wchar_t when modules are available. *//* Always define rsize_t when modules are available. *//* ISO9899:2011 7.20 (C11 Annex K): Define rsize_t if __STDC_WANT_LIB_EXT1__ is
 * enabled. *//*defined(__need_size_t) *//* Always define size_t when modules are available. *//* defined(__need_ptrdiff_t) *//* Always define ptrdiff_t when modules are available. *//* __need_wint_t is intentionally not defined here. *//* Always define miscellaneous pieces when modules are available. *//*===---- stddef.h - Basic type definitions --------------------------------===
 *
 * Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.
 * See https://llvm.org/LICENSE.txt for license information.
 * SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
 *
 *===-----------------------------------------------------------------------===
 *//Users/owura/Repos/codeql_eval/proj_repos/the-tcpdump-group-tcpdump-commit-0f95d441e4b5d7512cc5c326c8668a120e048eda/tcpdump/print-aodv.c<stddef.h>aodv_printconst aodvconst aodv *aodv *(ndo, " [|aodv]") [|aodv](u_int)(ndo->ndo_snapend - dat)const aodv_rrep_acksizeof(ap->rrep_ack)(ndo, " aodv") aodv(ndo, " rrep-ack %u", length)(ndo, " %u %u", ap->rreq.rreq_type, length)AODV_RREQAODV_RREPAODV_RERRAODV_RREP_ACK rrep-ack %uAODV_V6_DRAFT_01_RREQAODV_V6_DRAFT_01_RREPAODV_V6_DRAFT_01_RERRAODV_V6_DRAFT_01_RREP_ACK %u %uaodv_v6_draft_01_rerr(ndo, " rerr %u", length) rerr %uaodv_v6_draft_01_rrep(ndo, " rrep %u", length) rrep %uaodv_v6_draft_01_rreq(ndo, " rreq %u", length) rreq %uaodv_v6_rerraodv_v6_rrepaodv_v6_rreq(ndo, " v6 rreq %u", length) v6 rreq %uaodv_rerrconst rerr_unreachconst rerr_unreach *rerr_unreach *dpstruct aodv_rerr(ndo, " [|rerr]")aodv_rerr *offsetof(struct aodv_rerr, r) [|rerr]rerr_unreach[1]sizeof(ap->rerr.r.dest[0])(ndo, " rerr %s [items %u] [%u]:", ap->rerr.rerr_flags & RERR_NODELETE ? "[D]" : "", ap->rerr.rerr_dc, length)(ndo, " rerr %s [items %u] [%u]:", ap->rerr.rerr_flags & 0x80 ? "[D]" : "", ap->rerr.rerr_dc, length) rerr %s [items %u] [%u]:[D](ndo, " {%s}(%ld)", ipaddr_string(ndo, &dp->u_da), (unsigned long)EXTRACT_32BITS(&dp->u_ds))(ndo, " {%s}(%ld)", getname(ndo, (const u_char *)(&dp->u_da)), (unsigned long)((uint32_t)(((uint32_t)(*((const uint8_t *)(&dp->u_ds) + 0)) << 24) | ((uint32_t)(*((const uint8_t *)(&dp->u_ds) + 1)) << 16) | ((uint32_t)(*((const uint8_t *)(&dp->u_ds) + 2)) << 8) | ((uint32_t)(*((const uint8_t *)(&dp->u_ds) + 3)) << 0))))&dp->u_da&dp->u_ds {%s}(%ld)(ndo, "[|rerr]")[|rerr]aodv_rrep(ndo, " [|rrep]")const aodv_rrepsizeof(ap->rrep) [|rrep](ndo, " rrep %u %s%sprefix %u hops %u\n" "\tdst %s dseq %lu src %s %lu ms", length, ap->rrep.rrep_type & RREP_REPAIR ? "[R]" : "", ap->rrep.rrep_type & RREP_ACK ? "[A] " : " ", ap->rrep.rrep_ps & RREP_PREFIX_MASK, ap->rrep.rrep_hops, ipaddr_string(ndo, &ap->rrep.rrep_da), (unsigned long)EXTRACT_32BITS(&ap->rrep.rrep_ds), ipaddr_string(ndo, &ap->rrep.rrep_oa), (unsigned long)EXTRACT_32BITS(&ap->rrep.rrep_life))(ndo, " rrep %u %s%sprefix %u hops %u\n" "\tdst %s dseq %lu src %s %lu ms", length, ap->rrep.rrep_type & 0x80 ? "[R]" : "", ap->rrep.rrep_type & 0x40 ? "[A] " : " ", ap->rrep.rrep_ps & 0x1F, ap->rrep.rrep_hops, getname(ndo, (const u_char *)(&ap->rrep.rrep_da)), (unsigned long)((uint32_t)(((uint32_t)(*((const uint8_t *)(&ap->rrep.rrep_ds) + 0)) << 24) | ((uint32_t)(*((const uint8_t *)(&ap->rrep.rrep_ds) + 1)) << 16) | ((uint32_t)(*((const uint8_t *)(&ap->rrep.rrep_ds) + 2)) << 8) | ((uint32_t)(*((const uint8_t *)(&ap->rrep.rrep_ds) + 3)) << 0))), getname(ndo, (const u_char *)(&ap->rrep.rrep_oa)), (unsigned long)((uint32_t)(((uint32_t)(*((const uint8_t *)(&ap->rrep.rrep_life) + 0)) << 24) | ((uint32_t)(*((const uint8_t *)(&ap->rrep.rrep_life) + 1)) << 16) | ((uint32_t)(*((const uint8_t *)(&ap->rrep.rrep_life) + 2)) << 8) | ((uint32_t)(*((const uint8_t *)(&ap->rrep.rrep_life) + 3)) << 0)))) rrep %u %s%sprefix %u hops %u
	dst %s dseq %lu src %s %lu mschar[62][R][A] &ap->rrep.rrep_da&ap->rrep.rrep_dsdatis_ip6&ap->rrep.rrep_oa&ap->rrep.rrep_lifesizeof(struct aodv_ext)const aodv_extconst aodv_ext *aodv_ext *const aodv_rrep *aodv_rrep *aodv_rreq(ndo, " [|rreq]")const aodv_rreqsizeof(ap->rreq) [|rreq](ndo, " rreq %u %s%s%s%s%shops %u id 0x%08lx\n" "\tdst %s seq %lu src %s seq %lu", length, ap->rreq.rreq_type & RREQ_JOIN ? "[J]" : "", ap->rreq.rreq_type & RREQ_REPAIR ? "[R]" : "", ap->rreq.rreq_type & RREQ_GRAT ? "[G]" : "", ap->rreq.rreq_type & RREQ_DEST ? "[D]" : "", ap->rreq.rreq_type & RREQ_UNKNOWN ? "[U] " : " ", ap->rreq.rreq_hops, (unsigned long)EXTRACT_32BITS(&ap->rreq.rreq_id), ipaddr_string(ndo, &ap->rreq.rreq_da), (unsigned long)EXTRACT_32BITS(&ap->rreq.rreq_ds), ipaddr_string(ndo, &ap->rreq.rreq_oa), (unsigned long)EXTRACT_32BITS(&ap->rreq.rreq_os))(ndo, " rreq %u %s%s%s%s%shops %u id 0x%08lx\n" "\tdst %s seq %lu src %s seq %lu", length, ap->rreq.rreq_type & 0x80 ? "[J]" : "", ap->rreq.rreq_type & 0x40 ? "[R]" : "", ap->rreq.rreq_type & 0x20 ? "[G]" : "", ap->rreq.rreq_type & 0x10 ? "[D]" : "", ap->rreq.rreq_type & 0x08 ? "[U] " : " ", ap->rreq.rreq_hops, (unsigned long)((uint32_t)(((uint32_t)(*((const uint8_t *)(&ap->rreq.rreq_id) + 0)) << 24) | ((uint32_t)(*((const uint8_t *)(&ap->rreq.rreq_id) + 1)) << 16) | ((uint32_t)(*((const uint8_t *)(&ap->rreq.rreq_id) + 2)) << 8) | ((uint32_t)(*((const uint8_t *)(&ap->rreq.rreq_id) + 3)) << 0))), getname(ndo, (const u_char *)(&ap->rreq.rreq_da)), (unsigned long)((uint32_t)(((uint32_t)(*((const uint8_t *)(&ap->rreq.rreq_ds) + 0)) << 24) | ((uint32_t)(*((const uint8_t *)(&ap->rreq.rreq_ds) + 1)) << 16) | ((uint32_t)(*((const uint8_t *)(&ap->rreq.rreq_ds) + 2)) << 8) | ((uint32_t)(*((const uint8_t *)(&ap->rreq.rreq_ds) + 3)) << 0))), getname(ndo, (const u_char *)(&ap->rreq.rreq_oa)), (unsigned long)((uint32_t)(((uint32_t)(*((const uint8_t *)(&ap->rreq.rreq_os) + 0)) << 24) | ((uint32_t)(*((const uint8_t *)(&ap->rreq.rreq_os) + 1)) << 16) | ((uint32_t)(*((const uint8_t *)(&ap->rreq.rreq_os) + 2)) << 8) | ((uint32_t)(*((const uint8_t *)(&ap->rreq.rreq_os) + 3)) << 0)))) rreq %u %s%s%s%s%shops %u id 0x%08lx
	dst %s seq %lu src %s seq %lu[J][G][U] &ap->rreq.rreq_id&ap->rreq.rreq_da&ap->rreq.rreq_ds&ap->rreq.rreq_oa&ap->rreq.rreq_osconst aodv_rreq *aodv_rreq *aodv_extensionconst aodv_helloconst aodv_hello *aodv_hello *(ndo, " [|hello]")(u_int)(ndo->ndo_snapend - (u_char *)ep)(ndo, "\n\text HELLO %ld ms", (unsigned long)EXTRACT_32BITS(&ah->interval))(ndo, "\n\text HELLO %ld ms", (unsigned long)((uint32_t)(((uint32_t)(*((const uint8_t *)(&ah->interval) + 0)) << 24) | ((uint32_t)(*((const uint8_t *)(&ah->interval) + 1)) << 16) | ((uint32_t)(*((const uint8_t *)(&ah->interval) + 2)) << 8) | ((uint32_t)(*((const uint8_t *)(&ah->interval) + 3)) << 0))))&ah->interval(ndo, "\n\text %u %u", ep->type, ep->length)AODV_EXT_HELLO [|hello]sizeof(struct aodv_hello)
	ext HELLO %ld msconst uint8_t[4]const uint8_t(*)[4]unsigned char(*)[4]
	ext %u %uaodv_helloaodv_extaodvaodv_rrep_ackrerr_unreachintervalehrrep_ackrerrrreprreqra_zero0ra_typererr_dcrerr_zero0rerr_flagsrerr_typedestu_dsu_darrep_liferrep_oarrep_dsrrep_darrep_hopsrrep_psrrep_flagsrrep_typerreq_osrreq_oarreq_dsrreq_darreq_idrreq_hopsrreq_zero0rreq_flagsrreq_typeRERR_FLAGS_MASKRERR_NODELETERREP_PREFIX_MASK0x1FRREP_FLAGS_MASK0xC0RREP_ACKRREP_REPAIRRREQ_FLAGS_MASK0xF8RREQ_UNKNOWNRREQ_DESTRREQ_GRATRREQ_REPAIRRREQ_JOIN/* expect my next hello in
						 * (n) ms
						 * NOTE: this is not aligned *//* extension header *//* extension length *//* extension type *//* IPV6 route response acknowledgment *//* IPv6 error report *//* IPv6 route response *//* IPv6 route request *//* route response acknowledgement *//* error report *//* route response *//* route request *//* mask for rerr_flags *//* don't delete the link *//* destination count *//* reserved, set to zero *//* various flags *//* AODV message type (3 or 18) *//* sequence number *//* IPv6 address *//* IPv4 address *//* mask for prefix size *//* mask for rrep_flags *//* acknowledgement required *//* repair (reserved for multicast *//* lifetime of this route *//* originator IPv6 address *//* destination IPv6 address *//* destination sequence number *//* number of hops from o to d *//* prefix size *//* AODV message type (17) *//* AODV message type (2) *//* originator IPv4 address *//* destination IPv4 address *//* mask for rreq_flags *//* unknown destination sequence num *//* destination only *//* gratuitous RREP *//* join (reserved for multicast *//* originator sequence number *//* request ID *//* number of hops from originator *//* AODV message type (16) *//* AODV message type (1) *//* must come after interface.h *//* for offsetof *//*
 * Copyright (c) 2003 Bruce M. Simpson <bms@spc.org>
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *        This product includes software developed by Bruce M. Simpson.
 * 4. Neither the name of Bruce M. Simpson nor the names of co-
 *    contributors may be used to endorse or promote products derived
 *    from this software without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY Bruce M. Simpson AND CONTRIBUTORS
 * ``AS IS'' AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED
 * TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
 * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL Bruce M. Simpson OR CONTRIBUTORS
 * BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
 * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
 * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
 * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
 * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
 * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
 * POSSIBILITY OF SUCH DAMAGE.
 *//Users/owura/Repos/codeql_eval/proj_repos/the-tcpdump-group-tcpdump-commit-0f95d441e4b5d7512cc5c326c8668a120e048eda/tcpdump/ether.hether_headerether_typeether_shostether_dhostETHER_HDRLENETHERMTU1500/*
 * Length of a DEC/Intel/Xerox or 802.3 Ethernet header; note that some
 * compilers may pad "struct ether_header" to a multiple of 4 bytes,
 * for example, so "sizeof (struct ether_header)" may not give the right
 * answer.
 *//*
 * Structure of a DEC/Intel/Xerox or 802.3 Ethernet header.
 *//*
 * The number of bytes in an ethernet (MAC) address.
 *//*
 * Copyright (c) 1982, 1986, 1993
 *	The Regents of the University of California.  All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *	This product includes software developed by the University of
 *	California, Berkeley and its contributors.
 * 4. Neither the name of the University nor the names of its contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 *
 *	@(#)if_ether.h	8.3 (Berkeley) 5/2/95
 *//Users/owura/Repos/codeql_eval/proj_repos/the-tcpdump-group-tcpdump-commit-0f95d441e4b5d7512cc5c326c8668a120e048eda/tcpdump/print-aoe.c"ether.h"aoe_printver(ndo, "AoE length %u", len)AoE length %u2400xF0(ndo, ", Ver %u", ver), Ver %uAOE_V1(ndo, "%s", cstr)const char[11]const char[8]aoev1_printcommandcmd_decoderAOEV1_COMMON_HDR_LEN0x0F(ndo, ", Flags: [%s]", bittok2str(aoev1_flag_str, "none", flags)), Flags: [%s]const tok[5]tok[5]none(ndo, "\n\tError: %s", tok2str(aoev1_errcode_str, "Invalid (%u)", *cp))AOEV1_FLAG_E
	Error: %sInvalid (%u)(ndo, "\n\tMajor: 0x%04x", EXTRACT_16BITS(cp))(ndo, "\n\tMajor: 0x%04x", ((uint16_t)(((uint16_t)(*((const uint8_t *)(cp) + 0)) << 8) | ((uint16_t)(*((const uint8_t *)(cp) + 1)) << 0))))
	Major: 0x%04x(ndo, ", Minor: 0x%02x", *cp), Minor: 0x%02x(ndo, ", Command: %s", tok2str(cmdcode_str, "Unknown (0x%02x)", command)), Command: %sUnknown (0x%02x)(ndo, ", Tag: 0x%08x", EXTRACT_32BITS(cp))(ndo, ", Tag: 0x%08x", ((uint32_t)(((uint32_t)(*((const uint8_t *)(cp) + 0)) << 24) | ((uint32_t)(*((const uint8_t *)(cp) + 1)) << 16) | ((uint32_t)(*((const uint8_t *)(cp) + 2)) << 8) | ((uint32_t)(*((const uint8_t *)(cp) + 3)) << 0)))), Tag: 0x%08xAOEV1_CMD_ISSUE_ATA_COMMANDAOEV1_CMD_QUERY_CONFIG_INFORMATIONAOEV1_CMD_MAC_MASK_LISTAOEV1_CMD_RESERVE_RELEASEaoev1_reserve_printnmacsAOEV1_RESERVE_ARG_LEN(ndo, "\n\tRCmd: %s", tok2str(aoev1_rcmd_str, "Unknown (0x%02x)", *cp))
	RCmd: %s(ndo, ", NMacs: %u", nmacs), NMacs: %u(ndo, "\n\tEthernet Address %u: %s", i, etheraddr_string(ndo, cp))
	Ethernet Address %u: %saoev1_mac_printdircountAOEV1_MAC_ARG_LEN(ndo, "\n\tMCmd: %s", tok2str(aoev1_mcmd_str, "Unknown (0x%02x)", *cp))
	MCmd: %s(ndo, ", MError: %s", tok2str(aoev1_merror_str, "Unknown (0x%02x)", *cp)), MError: %s(ndo, ", Dir Count: %u", dircount), Dir Count: %u(ndo, "\n\t DCmd: %s", tok2str(aoev1_dcmd_str, "Unknown (0x%02x)", *cp))(ndo, ", Ethernet Address: %s", etheraddr_string(ndo, cp))
	 DCmd: %s, Ethernet Address: %saoev1_query_printcslenAOEV1_QUERY_ARG_LEN(ndo, "\n\tBuffer Count: %u", EXTRACT_16BITS(cp))(ndo, "\n\tBuffer Count: %u", ((uint16_t)(((uint16_t)(*((const uint8_t *)(cp) + 0)) << 8) | ((uint16_t)(*((const uint8_t *)(cp) + 1)) << 0))))
	Buffer Count: %u(ndo, ", Firmware Version: %u", EXTRACT_16BITS(cp))(ndo, ", Firmware Version: %u", ((uint16_t)(((uint16_t)(*((const uint8_t *)(cp) + 0)) << 8) | ((uint16_t)(*((const uint8_t *)(cp) + 1)) << 0)))), Firmware Version: %u(ndo, ", Sector Count: %u", *cp), Sector Count: %u(ndo, ", AoE: %u, CCmd: %s", (*cp & 0xF0) >> 4, tok2str(aoev1_ccmd_str, "Unknown (0x02x)", *cp & 0x0F)), AoE: %u, CCmd: %sconst tok[6]tok[6]Unknown (0x02x)AOEV1_MAX_CONFSTR_LEN(ndo, "\n\tConfig String (length %u): ", cslen)
	Config String (length %u): aoev1_issue_printAOEV1_ISSUE_ARG_LEN(ndo, "\n\tAFlags: [%s]", bittok2str(aoev1_aflag_str, "none", *cp))
	AFlags: [%s](ndo, ", Err/Feature: %u", *cp), Err/Feature: %u(ndo, ", Cmd/Status: %u", *cp), Cmd/Status: %u(ndo, "\n\tlba0: %u", *cp)
	lba0: %u(ndo, ", lba1: %u", *cp), lba1: %u(ndo, ", lba2: %u", *cp), lba2: %u(ndo, ", lba3: %u", *cp), lba3: %u(ndo, ", lba4: %u", *cp), lba4: %u(ndo, ", lba5: %u", *cp), lba5: %u(ndo, "\n\tData: %u bytes", len - AOEV1_ISSUE_ARG_LEN)(ndo, "\n\tData: %u bytes", len - 12U)
	Data: %u bytesRead reserve list"Read reserve list"Set reserve list"Set reserve list"Force set reserve list"Force set reserve list"aoev1_rcmd_strNo Directive"No Directive"Add mac address to mask list"Add mac address to mask list"Delete mac address from mask list"Delete mac address from mask list"aoev1_dcmd_strUnspecified Error"Unspecified Error"Bad DCmd directive"Bad DCmd directive"Mask list full"Mask list full"aoev1_merror_strRead Mac Mask List"Read Mac Mask List"Edit Mac Mask List"Edit Mac Mask List"aoev1_mcmd_strread config string"read config string"test config string"test config string"test config string prefix"test config string prefix"set config string"set config string"force set config string"force set config string"aoev1_ccmd_strMBZ-0x08"MBZ-0x08"AOEV1_AFLAG_EExt48"Ext48"MBZ-0x06"MBZ-0x06"AOEV1_AFLAG_DDevice"Device"MBZ-0x04"MBZ-0x04"MBZ-0x03"MBZ-0x03"AOEV1_AFLAG_AAsync"Async"AOEV1_AFLAG_WWrite"Write"aoev1_aflag_strUnrecognized command code"Unrecognized command code"Bad argument parameter"Bad argument parameter"Device unavailable"Device unavailable"Config string present"Config string present"Unsupported version"Unsupported version"Target is reserved"Target is reserved"aoev1_errcode_strAOEV1_FLAG_RResponse"Response"Error"Error"MBZ-0x02"MBZ-0x02"MBZ-0x01"MBZ-0x01"aoev1_flag_strIssue ATA Command"Issue ATA Command"Query Config Information"Query Config Information"MAC Mask List"MAC Mask List"Reserve/Release"Reserve/Release"cmdcode_str (corrupt)" (corrupt)" [|aoe]" [|aoe]"1024U2U4U8U12U10UATA_SECTOR_SIZE/* Don't advance cp yet: low order 4 bits are version-specific. *//* Ver/Flags *//* Arg *//* Tag *//* Command *//* Minor *//* Major *//* Error *//* Flags *//* cp points to the Ver/Flags octet *//* addresses *//* NMacs (correlated with the length) *//* RCmd *//* Ethernet Address *//* DCmd *//* Reserved *//* directives *//* Dir Count *//* MError *//* MCmd *//* Config String *//* Config String Length *//* AoE/CCmd *//* Sector Count *//* Firmware Version *//* Buffer Count *//* Data *//* lba5 *//* lba4 *//* lba3 *//* lba2 *//* lba1 *//* lba0 *//* Cmd/Status *//* Sector Count (not correlated with the length) *//* Err/Feature *//* AFlags *//* up to but w/o Ethernet address 0 *//* up to but w/o Directive 0        *//* up to but w/o Config String      *//* up to but w/o Data               *//* up to but w/o Arg                *//*
 * This module implements decoding of the ATA over Ethernet (AoE) protocol
 * according to the following specification:
 * http://support.coraid.com/documents/AoEr11.txt
 *
 * Copyright (c) 2014 The TCPDUMP project
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
 * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
 * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS
 * FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE
 * COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT,
 * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,
 * BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
 * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
 * CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN
 * ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
 * POSSIBILITY OF SUCH DAMAGE.
 *//Users/owura/Repos/codeql_eval/proj_repos/the-tcpdump-group-tcpdump-commit-0f95d441e4b5d7512cc5c326c8668a120e048eda/tcpdump/ethertype.hethertype_valuesETHERTYPE_GEONET0x8947ETHERTYPE_GEONET_OLD0x0707ETHERTYPE_CALM_FAST0x1111ETHERTYPE_ISO0xfefeETHERTYPE_IEEE1905_10x893aETHERTYPE_CFM0x8902ETHERTYPE_CFM_OLD0xabcdETHERTYPE_VMAN0x9100ETHERTYPE_LOOPBACKETHERTYPE_AOE0x88a2ETHERTYPE_RRCP0x8899ETHERTYPE_EAPOL0x888eETHERTYPE_LLDP0x88ccETHERTYPE_JUMBO0x8870ETHERTYPE_MS_NLB_HB0x886fETHERTYPE_PPPOES20x3c13ETHERTYPE_PPPOED20x3c12ETHERTYPE_PPPOES0x8864ETHERTYPE_PPPOED0x8863ETHERTYPE_MPLS_MULTI0x8848ETHERTYPE_MPLS0x8847ETHERTYPE_SLOW0x8809ETHERTYPE_MPCP0x8808ETHERTYPE_PPP0x880bETHERTYPE_IPV60x86ddETHERTYPE_IPX0x8137ETHERTYPE_8021QinQ0x88a8ETHERTYPE_8021Q92000x9200ETHERTYPE_8021Q9100ETHERTYPE_8021Q0x8100ETHERTYPE_TIPC0x88caETHERTYPE_AARP0x80f3ETHERTYPE_ATALK0x809bETHERTYPE_VPROD0x805cETHERTYPE_VEXP0x805bETHERTYPE_DECDTS0x803eETHERTYPE_DECDNS0x803cETHERTYPE_LANBRIDGE0x8038ETHERTYPE_TEB0x6558ETHERTYPE_SCA0x6007ETHERTYPE_LAT0x6004ETHERTYPE_DN0x6003ETHERTYPE_MOPRC0x6002ETHERTYPE_MOPDL0x6001ETHERTYPE_TRAIL0x1000ETHERTYPE_SPRITE0x0500ETHERTYPE_NS0x0600ETHERTYPE_REVARP0x8035ETHERTYPE_ARP0x0806ETHERTYPE_IP0x0800ETHERTYPE_PUP0x0200ETHERTYPE_GRE_ISO0x00FEETHERTYPE_LEN/* ETSI GeoNetworking (Official IEEE registration from Jan 2013) *//* ETSI GeoNetworking (before Jan 2013) *//* ISO CALM FAST *//* nonstandard - used in Cisco HDLC encapsulation *//* IEEE 1905.1 *//* 802.1ag *//* 802.1ag depreciated *//* Extreme VMAN Protocol *//* MS Network Load Balancing Heartbeat *//* see:
        http://en.wikipedia.org/wiki/IEEE_802.1Q
    and http://en.wikipedia.org/wiki/QinQ
*//* reverse Addr. resolution protocol *//* Addr. resolution protocol *//* IP protocol *//* PUP protocol *//* not really an ethertype only used in GRE *//*
 * Ethernet types.
 *
 * We wrap the declarations with #ifdef, so that if a file includes
 * <netinet/if_ether.h>, which may declare some of these, we don't
 * get a bunch of complaints from the C compiler about redefinitions
 * of these values.
 *
 * We declare all of them here so that no file has to include
 * <netinet/if_ether.h> if all it needs are ETHERTYPE_ values.
 *//*
 * Copyright (c) 1993, 1994, 1996
 *	The Regents of the University of California.  All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that: (1) source code distributions
 * retain the above copyright notice and this paragraph in its entirety, (2)
 * distributions including binary code include the above copyright notice and
 * this paragraph in its entirety in the documentation or other materials
 * provided with the distribution, and (3) all advertising materials mentioning
 * features or use of this software display the following acknowledgement:
 * ``This product includes software developed by the University of California,
 * Lawrence Berkeley Laboratory and its contributors.'' Neither the name of
 * the University nor the names of its contributors may be used to endorse
 * or promote products derived from this software without specific prior
 * written permission.
 * THIS SOFTWARE IS PROVIDED ``AS IS'' AND WITHOUT ANY EXPRESS OR IMPLIED
 * WARRANTIES, INCLUDING, WITHOUT LIMITATION, THE IMPLIED WARRANTIES OF
 * MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE.
 *//Users/owura/Repos/codeql_eval/proj_repos/the-tcpdump-group-tcpdump-commit-0f95d441e4b5d7512cc5c326c8668a120e048eda/tcpdump/print-ap1394.c"ethertype.h"ap1394_if_printfirewire_header *(ndo, "[|ap1394]")FIREWIRE_HDRLEN[|ap1394]&fp->firewire_typeap1394_hdr_printconst firewire_headerconst firewire_header *firewire_type(ndo, "%s > %s", linkaddr_string(ndo, fp->firewire_dhost, LINKADDR_IEEE1394, FIREWIRE_EUI64_LEN), linkaddr_string(ndo, fp->firewire_shost, LINKADDR_IEEE1394, FIREWIRE_EUI64_LEN))(ndo, "%s > %s", linkaddr_string(ndo, fp->firewire_dhost, LINKADDR_IEEE1394, 8), linkaddr_string(ndo, fp->firewire_shost, LINKADDR_IEEE1394, 8))%s > %su_char[8]FIREWIRE_EUI64_LENconst u_shortconst u_short *(ndo, ", ethertype %s (0x%04x)", tok2str(ethertype_values,"Unknown", firewire_type), firewire_type)(ndo, ", %s", tok2str(ethertype_values,"Unknown Ethertype (0x%04x)", firewire_type)), ethertype %s (0x%04x), %sUnknown Ethertype (0x%04x)(ndo, ", length %u: ", length), length %u: firewire_headerfirewire_shostfirewire_dhost/* ether_type not known, print raw packet *//*
 * This is the top level routine of the printer.  'p' points
 * to the ether header of the packet, 'h->ts' is the timestamp,
 * 'h->len' is the length of the packet off the wire, and 'h->caplen'
 * is the number of bytes actually captured.
 *//*
 * Length of that header; note that some compilers may pad
 * "struct firewire_header" to a multiple of 4 bytes, for example, so
 * "sizeof (struct firewire_header)" may not give the right answer.
 *//*
 * Structure of a header for Apple's IP-over-IEEE 1384 BPF header.
 *//*
 * Copyright (c) 1988, 1989, 1990, 1991, 1992, 1993, 1994, 1995, 1996, 1997, 2000
 *	The Regents of the University of California.  All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that: (1) source code distributions
 * retain the above copyright notice and this paragraph in its entirety, (2)
 * distributions including binary code include the above copyright notice and
 * this paragraph in its entirety in the documentation or other materials
 * provided with the distribution, and (3) all advertising materials mentioning
 * features or use of this software display the following acknowledgement:
 * ``This product includes software developed by the University of California,
 * Lawrence Berkeley Laboratory and its contributors.'' Neither the name of
 * the University nor the names of its contributors may be used to endorse
 * or promote products derived from this software without specific prior
 * written permission.
 * THIS SOFTWARE IS PROVIDED ``AS IS'' AND WITHOUT ANY EXPRESS OR IMPLIED
 * WARRANTIES, INCLUDING, WITHOUT LIMITATION, THE IMPLIED WARRANTIES OF
 * MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE.
 *//Users/owura/Repos/codeql_eval/proj_repos/the-tcpdump-group-tcpdump-commit-0f95d441e4b5d7512cc5c326c8668a120e048eda/tcpdump/print-arcnet.carcnet_encap_print(ndo, "et1 ")ARCTYPE_IP_OLD212ARCTYPE_IPARCTYPE_INET6241ARCTYPE_ARP_OLD213ARCTYPE_ARP214ARCTYPE_REVARP221ARCTYPE_ATALKet1 250ARCTYPE_IPXarcnet_linux_if_printconst arc_linux_headerconst arc_linux_header *arc_linux_header *archdrlenarc_type(ndo, "[|arcnet]")ARC_LINUX_HDRLEN[|arcnet]ARC_LINUX_HDRNEWLENARCTYPE_DIAGNOSEarcnet_if_printconst arc_headerconst arc_header *arc_header *phdsflagseqidARC_HDRLEN(ndo, "[|phds]")(ndo, "[|phds extended]")&ap->arc_seqid2&ap->arc_seqidARC_HDRNEWLEN[|phds]ARC_HDRNEWLEN_EXC[|phds extended]arcnet_printarctypename(ndo, "%02x %02x %d: ", ap->arc_shost, ap->arc_dhost, length)%02x %02x %d: const tok[11]tok[11]%02x"%02x"(ndo, "%02x %02x %s %d: ", ap->arc_shost, ap->arc_dhost, arctypename, length)%02x %02x %s %d: (ndo, "%02x %02x %s seqid %04x %d: ", ap->arc_shost, ap->arc_dhost, arctypename, seqid, length)%02x %02x %s seqid %04x %d: (ndo, "%02x %02x %s seqid %04x " "(first of %d fragments) %d: ", ap->arc_shost, ap->arc_dhost, arctypename, seqid, (flag + 3) / 2, length)(ndo, "%02x %02x %s seqid %04x " "(fragment %d) %d: ", ap->arc_shost, ap->arc_dhost, arctypename, seqid, flag/2 + 1, length)%02x %02x %s seqid %04x (first of %d fragments) %d: %02x %02x %s seqid %04x (fragment %d) %d: char[43]arc_linux_headerarc_headerarc_seqidarc_flagarc_offsetarc_dhostarc_shostarc_seqid2arc_flag2arc_type2oldip"oldip"oldarp"oldarp"ip"ip"arp"arp"rarp"rarp"atalk"atalk"247ARCTYPE_BANIANbanyan"banyan"ipx"ipx"ipv6"ipv6"diag"diag"arctypemap0xc4/*
 * Local Variables:
 * c-style: bsd
 * End:
 *//* XXX was this ever used? *//*
 * Prints the packet encapsulated in an ARCnet data field,
 * given the ARCnet system code.
 *
 * Returns non-zero if it can do so, zero if the system code is unknown.
 *//*
	 * Go past the ARCNET header.
	 *//*
 * This is the top level routine of the printer.  'p' points
 * to the ARCNET header of the packet, 'h->ts' is the timestamp,
 * 'h->len' is the length of the packet off the wire, and 'h->caplen'
 * is the number of bytes actually captured.  It is quite similar
 * to the non-Linux style printer except that Linux doesn't ever
 * supply packets that look like exception frames, it always supplies
 * reassembled packets rather than raw frames, and headers have an
 * extra "offset" field between the src/dest and packet type.
 *//*
		 * This is a middle fragment.
		 *//*
 * This is the top level routine of the printer.  'p' points
 * to the ARCNET header of the packet, 'h->ts' is the timestamp,
 * 'h->len' is the length of the packet off the wire, and 'h->caplen'
 * is the number of bytes actually captured.
 *//*
	 * only present for newstyle encoding with LL fragmentation.
	 * Don't use sizeof(anything), use ARC_LINUX_HDR{,NEW}LEN
	 * instead.
	 *//*
 * Structure of a 2.5MB/s Arcnet header on Linux.  Linux has
 * an extra "offset" field when given to interface code, and
 * never presents packets that look like exception frames.
 *//* as per ANSI/ATA 878.1 *//* IPng *//* Novell IPX *//* Banyan Vines *//* reverse addr resolution protocol *//* address resolution protocol *//* RFC 1201 *//* RFC 1051 *//* real seqid value *//* real flag value *//* same as arc_type *//*
	 * only present in exception packets (arc_flag == 0xff)
	 *//*
	 * only present for newstyle encoding with LL fragmentation.
	 * Don't use sizeof(anything), use ARC_HDR{,NEW}LEN instead.
	 *//*
 * Structure of a 2.5MB/s Arcnet header on the BSDs,
 * as given to interface code.
 *//*
 * from: NetBSD: if_arc.h,v 1.13 1999/11/19 20:41:19 thorpej Exp
 *//*
 * Copyright (c) 1988, 1989, 1990, 1991, 1992, 1993, 1994, 1995, 1996, 1997
 *	The Regents of the University of California.  All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that: (1) source code distributions
 * retain the above copyright notice and this paragraph in its entirety, (2)
 * distributions including binary code include the above copyright notice and
 * this paragraph in its entirety in the documentation or other materials
 * provided with the distribution, and (3) all advertising materials mentioning
 * features or use of this software display the following acknowledgement:
 * ``This product includes software developed by the University of California,
 * Lawrence Berkeley Laboratory and its contributors.'' Neither the name of
 * the University nor the names of its contributors may be used to endorse
 * or promote products derived from this software without specific prior
 * written permission.
 * THIS SOFTWARE IS PROVIDED ``AS IS'' AND WITHOUT ANY EXPRESS OR IMPLIED
 * WARRANTIES, INCLUDING, WITHOUT LIMITATION, THE IMPLIED WARRANTIES OF
 * MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE.
 *
 * From: NetBSD: print-arcnet.c,v 1.2 2000/04/24 13:02:28 itojun Exp
 */arctype/Users/owura/Repos/codeql_eval/proj_repos/the-tcpdump-group-tcpdump-commit-0f95d441e4b5d7512cc5c326c8668a120e048eda/tcpdump/print-arp.carp_printconst arp_pkthdrconst arp_pkthdr *arp_pkthdr *prohrdoplinkaddr*apsizeof(*ap)&(ap)->ar_hrd&(ap)->ar_pro&(ap)->ar_opARPHRD_ATM2225ARPHRD_FRELAY*ar_tpa(ap)*(((const u_char *)((ap)+1))+2*(ap)->ar_hln+(ap)->ar_pln)PROTO_LEN(ap)((ap)->ar_pln)(const u_char *)apconst char[7](ndo, "ARP, ")ARP, (ndo, "%s (len %u), %s (len %u)", tok2str(arphrd_values, "Unknown Hardware (%u)", hrd), HRD_LEN(ap), tok2str(ethertype_values, "Unknown Protocol (0x%04x)", pro), PROTO_LEN(ap))(ndo, "%s (len %u), %s (len %u)", tok2str(arphrd_values, "Unknown Hardware (%u)", hrd), ((ap)->ar_hln), tok2str(ethertype_values, "Unknown Protocol (0x%04x)", pro), ((ap)->ar_pln))%s (len %u), %s (len %u)const tok[8]tok[8]Unknown Hardware (%u)Unknown Protocol (0x%04x)(ndo, "%s%s ", ndo->ndo_vflag ? ", " : "", tok2str(arpop_values, "Unknown (%u)", op))%s%s Unknown (%u)(ndo, "who-has %s", ipaddr_string(ndo, TPA(ap)))(ndo, "who-has %s", getname(ndo, (const u_char *)(((((const u_char *)((ap)+1))+2*(ap)->ar_hln+(ap)->ar_pln)))))TPA(ap)((((const u_char *)((ap)+1))+2*(ap)->ar_hln+(ap)->ar_pln))(ndo, " (%s)", linkaddr_string(ndo, THA(ap), linkaddr, HRD_LEN(ap)))(ndo, " (%s)", linkaddr_string(ndo, ((((const u_char *)((ap)+1))+ (ap)->ar_hln+(ap)->ar_pln)), linkaddr, ((ap)->ar_hln)))(ndo, " tell %s", ipaddr_string(ndo, SPA(ap)))(ndo, " tell %s", getname(ndo, (const u_char *)(((((const u_char *)((ap)+1))+ (ap)->ar_hln)))))SPA(ap)((((const u_char *)((ap)+1))+ (ap)->ar_hln))(ndo, "%s is-at %s", ipaddr_string(ndo, SPA(ap)), linkaddr_string(ndo, SHA(ap), linkaddr, HRD_LEN(ap)))(ndo, "%s is-at %s", getname(ndo, (const u_char *)(((((const u_char *)((ap)+1))+ (ap)->ar_hln)))), linkaddr_string(ndo, ((((const u_char *)((ap)+1))+0)), linkaddr, ((ap)->ar_hln)))(ndo, "who-is %s tell %s", linkaddr_string(ndo, THA(ap), linkaddr, HRD_LEN(ap)), linkaddr_string(ndo, SHA(ap), linkaddr, HRD_LEN(ap)))(ndo, "who-is %s tell %s", linkaddr_string(ndo, ((((const u_char *)((ap)+1))+ (ap)->ar_hln+(ap)->ar_pln)), linkaddr, ((ap)->ar_hln)), linkaddr_string(ndo, ((((const u_char *)((ap)+1))+0)), linkaddr, ((ap)->ar_hln)))(ndo, "%s at %s", linkaddr_string(ndo, THA(ap), linkaddr, HRD_LEN(ap)), ipaddr_string(ndo, TPA(ap)))(ndo, "%s at %s", linkaddr_string(ndo, ((((const u_char *)((ap)+1))+ (ap)->ar_hln+(ap)->ar_pln)), linkaddr, ((ap)->ar_hln)), getname(ndo, (const u_char *)(((((const u_char *)((ap)+1))+2*(ap)->ar_hln+(ap)->ar_pln)))))(ndo,"%s at %s", linkaddr_string(ndo, THA(ap), linkaddr, HRD_LEN(ap)), ipaddr_string(ndo, TPA(ap)))(ndo,"%s at %s", linkaddr_string(ndo, ((((const u_char *)((ap)+1))+ (ap)->ar_hln+(ap)->ar_pln)), linkaddr, ((ap)->ar_hln)), getname(ndo, (const u_char *)(((((const u_char *)((ap)+1))+2*(ap)->ar_hln+(ap)->ar_pln)))))ARPOP_REQUESTwho-has %s (%s) tell %sARPOP_REPLY%s is-at %sARPOP_REVREQUESTwho-is %s tell %sARPOP_REVREPLY%s at %sARPOP_INVREQUESTARPOP_INVREPLY(ndo, ", length %u", length), length %uatmarp_printconst atmarp_pkthdrconst atmarp_pkthdr *atmarp_pkthdr *&(ap)->aar_hrd&(ap)->aar_pro&(ap)->aar_op*aar_tpa(ap)*(((((((const u_char *)((ap)+1)) + ((ap)->aar_shtl & 0x3F)) + ((ap)->aar_sstl & 0x3F)) + ((ap)->aar_spln)) + ((ap)->aar_thtl & 0x3F)) + ((ap)->aar_tstl & 0x3F))ATMTPROTO_LEN(ap)((ap)->aar_tpln)(ndo, "%s, %s (len %u/%u)", tok2str(arphrd_values, "Unknown Hardware (%u)", hrd), tok2str(ethertype_values, "Unknown Protocol (0x%04x)", pro), ATMSPROTO_LEN(ap), ATMTPROTO_LEN(ap))(ndo, "%s, %s (len %u/%u)", tok2str(arphrd_values, "Unknown Hardware (%u)", hrd), tok2str(ethertype_values, "Unknown Protocol (0x%04x)", pro), ((ap)->aar_spln), ((ap)->aar_tpln))%s, %s (len %u/%u)(ndo, "who-has %s", ipaddr_string(ndo, ATMTPA(ap)))(ndo, "who-has %s", getname(ndo, (const u_char *)(((((((((const u_char *)((ap)+1)) + ((ap)->aar_shtl & 0x3F)) + ((ap)->aar_sstl & 0x3F)) + ((ap)->aar_spln)) + ((ap)->aar_thtl & 0x3F)) + ((ap)->aar_tstl & 0x3F))))))ATMTPA(ap)((((((((const u_char *)((ap)+1)) + ((ap)->aar_shtl & 0x3F)) + ((ap)->aar_sstl & 0x3F)) + ((ap)->aar_spln)) + ((ap)->aar_thtl & 0x3F)) + ((ap)->aar_tstl & 0x3F)))(ndo, "tell %s", ipaddr_string(ndo, ATMSPA(ap)))(ndo, "tell %s", getname(ndo, (const u_char *)((((((const u_char *)((ap)+1)) + ((ap)->aar_shtl & 0x3F)) + ((ap)->aar_sstl & 0x3F))))))ATMSPA(ap)(((((const u_char *)((ap)+1)) + ((ap)->aar_shtl & 0x3F)) + ((ap)->aar_sstl & 0x3F)))(ndo, "%s is-at ", ipaddr_string(ndo, ATMSPA(ap)))(ndo, "%s is-at ", getname(ndo, (const u_char *)((((((const u_char *)((ap)+1)) + ((ap)->aar_shtl & 0x3F)) + ((ap)->aar_sstl & 0x3F))))))(ndo, "who-is ")(ndo, " tell ")(ndo, "at %s", ipaddr_string(ndo, ATMSPA(ap)))(ndo, "at %s", getname(ndo, (const u_char *)((((((const u_char *)((ap)+1)) + ((ap)->aar_shtl & 0x3F)) + ((ap)->aar_sstl & 0x3F))))))(ndo, "for %s", ipaddr_string(ndo, ATMSPA(ap)))(ndo, "for %s", getname(ndo, (const u_char *)((((((const u_char *)((ap)+1)) + ((ap)->aar_shtl & 0x3F)) + ((ap)->aar_sstl & 0x3F))))))tell %s%s is-at who-is  tell at %sARPOP_NAKfor %satmarp_addr_print(ndo, "<No address>")(ndo, "%s", linkaddr_string(ndo, ha, LINKADDR_ATM, ha_len))(ndo, ",%s", linkaddr_string(ndo, srca, LINKADDR_ATM, srca_len))<No address>,%satmarp_pkthdrarp_pkthdraar_tplnaar_tstlaar_thtlaar_splnaar_opaar_sstlaar_shtlaar_proaar_hrdar_opar_plnar_hlnar_proar_hrdezeroARPHRD_ETHERARPHRD_IEEE802TokenRing"TokenRing"ARPHRD_ARCNETArcNet"ArcNet"FrameRelay"FrameRelay"ARPHRD_STRIPStrip"Strip"ARPHRD_IEEE1394IEEE 1394"IEEE 1394"ATM"ATM"arphrd_valuesReply"Reply"Reverse Request"Reverse Request"Reverse Reply"Reverse Reply"Inverse Request"Inverse Request"Inverse Reply"Inverse Reply"NACK Reply"NACK Reply"arpop_values[|ARP]"[|ARP]"(aar_tpa(ap))ATMTSA(ap)(aar_tsa(ap))ATMTHA(ap)(aar_tha(ap))(aar_spa(ap))ATMSSA(ap)(aar_ssa(ap))ATMSHA(ap)(aar_sha(ap))aar_tpa(ap)(aar_tsa(ap) + ATMTSLN(ap))aar_tsa(ap)(aar_tha(ap) + ATMTHRD_LEN(ap))aar_tha(ap)(aar_spa(ap) + ATMSPROTO_LEN(ap))aar_spa(ap)(aar_ssa(ap) + ATMSSLN(ap))aar_ssa(ap)(aar_sha(ap) + ATMSHRD_LEN(ap))aar_sha(ap)((const u_char *)((ap)+1))ATMTSLN(ap)((ap)->aar_tstl & ATMARP_LEN_MASK)ATMTHRD_LEN(ap)((ap)->aar_thtl & ATMARP_LEN_MASK)ATMPRO(ap)EXTRACT_16BITS(&(ap)->aar_pro)ATMOP(ap)EXTRACT_16BITS(&(ap)->aar_op)ATMSPROTO_LEN(ap)((ap)->aar_spln)ATMSSLN(ap)((ap)->aar_sstl & ATMARP_LEN_MASK)ATMSHRD_LEN(ap)((ap)->aar_shtl & ATMARP_LEN_MASK)ATMHRD(ap)EXTRACT_16BITS(&(ap)->aar_hrd)ATMARP_LEN_MASK0x3FATMARP_IS_E164(ar_tpa(ap))THA(ap)(ar_tha(ap))(ar_spa(ap))SHA(ap)(ar_sha(ap))PRO(ap)EXTRACT_16BITS(&(ap)->ar_pro)OP(ap)EXTRACT_16BITS(&(ap)->ar_op)HRD_LEN(ap)((ap)->ar_hln)HRD(ap)EXTRACT_16BITS(&(ap)->ar_hrd)ARP_HDRLENar_tpa(ap)(((const u_char *)((ap)+1))+2*(ap)->ar_hln+(ap)->ar_pln)ar_tha(ap)(((const u_char *)((ap)+1))+ (ap)->ar_hln+(ap)->ar_pln)ar_spa(ap)(((const u_char *)((ap)+1))+ (ap)->ar_hln)ar_sha(ap)(((const u_char *)((ap)+1))+0)COMMENT_ONLY/* print operation *//* don't know know about the address formats *//* print hardware type/len and proto type/len *//* if its ATM then call the ATM ARP printer
           for Frame-relay ARP most of the fields
           are similar to Ethernet so overload the Ethernet Printer
           and set the linkaddr type for linkaddr_string(ndo, ) accordingly *//* target protocol address *//* target ATM subaddress *//* target ATM number *//* sender protocol address *//* source ATM subaddress *//* source ATM number *//*
 * The remaining fields are variable in size,
 * according to the sizes above.
 *//* length of target protocol address *//* length of target ATM subaddress *//* length of target ATM number *//* length of source protocol address *//* same as regular ARP *//* length of {sub}address in type/length *//* bit in type/length for E.164 format *//* length of source ATM subaddress *//* length of source ATM number *//* format of protocol address *//* format of hardware address *//*
 * ATM Address Resolution Protocol.
 *
 * See RFC 2225 for protocol description.  ATMARP packets are similar
 * to ARP packets, except that there are no length fields for the
 * protocol address - instead, there are type/length fields for
 * the ATM number and subaddress - and the hardware addresses consist
 * of an ATM number and an ATM subaddress.
 *//* target hardware address *//* sender hardware address *//* NAK - only valif for ATM ARP *//* response identifying peer *//* request to identify peer *//* response giving protocol address *//* request protocol address given hardware *//* response to previous request *//* request to resolve address *//* one of: *//* length of protocol address *//* length of hardware address *//* IEEE 1394 (FireWire) hardware format *//* Ricochet Starmode Radio hardware format *//* ATM (RFC 2225) *//* frame relay hardware format *//* arcnet hardware format *//* token-ring hardware format *//* ethernet hardware format *//*
 * Address Resolution Protocol.
 *
 * See RFC 826 for protocol description.  ARP packets are variable
 * in size; the arphdr structure defines the fixed-length portion.
 * Protocol type values are the same as those for 10 Mb/s Ethernet.
 * It is followed by the variable-sized fields ar_sha, arp_spa,
 * arp_tha and arp_tpa in that order, according to the lengths
 * specified.  Field names used correspond to RFC 826.
 *//*
 * Copyright (c) 1988, 1989, 1990, 1991, 1992, 1993, 1994, 1995, 1996, 1997
 *	The Regents of the University of California.  All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that: (1) source code distributions
 * retain the above copyright notice and this paragraph in its entirety, (2)
 * distributions including binary code include the above copyright notice and
 * this paragraph in its entirety in the documentation or other materials
 * provided with the distribution, and (3) all advertising materials mentioning
 * features or use of this software display the following acknowledgement:
 * ``This product includes software developed by the University of California,
 * Lawrence Berkeley Laboratory and its contributors.'' Neither the name of
 * the University nor the names of its contributors may be used to endorse
 * or promote products derived from this software without specific prior
 * written permission.
 * THIS SOFTWARE IS PROVIDED ``AS IS'' AND WITHOUT ANY EXPRESS OR IMPLIED
 * WARRANTIES, INCLUDING, WITHOUT LIMITATION, THE IMPLIED WARRANTIES OF
 * MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE.
 */haha_lensrcasrca_len/Users/owura/Repos/codeql_eval/proj_repos/the-tcpdump-group-tcpdump-commit-0f95d441e4b5d7512cc5c326c8668a120e048eda/tcpdump/print-ascii.chex_printhex_print_with_offsetnshortssizeof(u_short)(ndo,"%s0x%04x: ", ident, oset)(ndo," %02x%02x", s, *cp++)%s0x%04x: HEXDUMP_BYTES_PER_LINE %02x%02x(ndo," %02x", *cp) %02xhex_and_ascii_printhex_and_ascii_print_with_offsets1s2HEXDUMP_SHORTS_PER_LINEHEXDUMP_HEXSTUFF_PER_SHORThexstuffhspchar[301]300ASCII_LINELENGTH301asciistuffaspsizeof(hexstuff) - (hsp - hexstuff)" %02x%02x", s1, s2(ndo, "%s0x%04x: %-*s  %s", ident, oset, HEXDUMP_HEXSTUFF_PER_LINE, hexstuff, asciistuff)(ndo, "%s0x%04x: %-*s  %s", ident, oset, (5 * (16 / 2)), hexstuff, asciistuff)%s0x%04x: %-*s  %s" %02x", s1ascii_print(ndo, "\n")
(ndo, ".")(ndo, "%c", s)'\r''\n'.'\t'' '%cHEXDUMP_HEXSTUFF_PER_LINE(HEXDUMP_HEXSTUFF_PER_SHORT * HEXDUMP_SHORTS_PER_LINE)(HEXDUMP_BYTES_PER_LINE / 2)MAIN/* MAIN *//*
 * just for completeness
 *//*
 * telnet_print() wants this.  It is essentially default_print_unaligned()
 *//*
			 * Don't print CRs at the end of the line; they
			 * don't belong at the ends of lines on UN*X,
			 * and the standard I/O library will give us one
			 * on Windows so we don't need to print one
			 * ourselves.
			 *
			 * In the middle of a line, just print a '.'.
			 *//* 4 hex digits and a space *//*-
 * Copyright (c) 1997, 1998 The NetBSD Foundation, Inc.
 * All rights reserved.
 *
 * This code is derived from software contributed to The NetBSD Foundation
 * by Alan Barrett and Simon J. Gerraty.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *        This product includes software developed by the NetBSD
 *        Foundation, Inc. and its contributors.
 * 4. Neither the name of The NetBSD Foundation nor the names of its
 *    contributors may be used to endorse or promote products derived
 *    from this software without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE NETBSD FOUNDATION, INC. AND CONTRIBUTORS
 * ``AS IS'' AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED
 * TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
 * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL THE FOUNDATION OR CONTRIBUTORS
 * BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
 * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
 * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
 * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
 * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
 * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
 * POSSIBILITY OF SUCH DAMAGE.
 *//*	$NetBSD: print-ascii.c,v 1.1 1999/09/30 14:49:12 sjg Exp $ 	*/identoset/Users/owura/Repos/codeql_eval/proj_repos/the-tcpdump-group-tcpdump-commit-0f95d441e4b5d7512cc5c326c8668a120e048eda/tcpdump/appletalk.hzipHeaderatNBPtupleatNBPatEchoatATPatShortDDPatDDPLAPnetcountenumeratorsktnodenetidcontrolechoDataechoFunctionuserDatatransIDsrcSktdstSktsrcNodedstNodesrcNetdstNetatalk_port(p)(((unsigned)((p) - 16512) < 128) || ((unsigned)((p) - 200) < 128) || ((unsigned)((p) - 768) < 128))GetZoneListGetMyZonezipSktddpZIPzipBringupzipTakedownzipReplyzipQueryzipHeaderSizertmpTupleSizertmpSizertmpSktnbpSktnbpTupleSizenbpHeaderSizenbpTupleMaxnbpNISnbpLkUpReply0x30nbpLkUpnbpBrRqechoReplyechoRequestechoSizeechoSktatpMaxData578atpMaxNumatpControlMaskatpFlagMaskatpSTSatpEOMatpXOatpRelCodeatpRspCodeatpReqCodeddpKLAP0x4bddpEIGRPddpARPddpIPddpECHOddpATPddpNBPddpRTMPrequestddpRTMPddpWKSddpSSizeddpSizeddpHopShiftddpLengthMask0x3FFddpMaxData586ddpMaxWKS0x7FlapKLAP'K'lapDDPlapShortDDP/*
 * UDP port range used for ddp-in-udp encapsulation is 16512-16639
 * for client sockets (128-255) and 200-327 for server sockets
 * (0-127).  We also try to recognize the pre-April 88 server
 * socket range of 768-895.
 *//* Zone Information Protocol *//* minimum size *//* number of RTMP socket *//* Routing Table Maint. Protocol *//* NIS *//* Name Binding Protocol *//* echo request *//* size of echo header *//* the echoer socket *//* AppleTalk Echo Protocol *//* AppleTalk Transaction Protocol *//* Kinetics KLAP type *//* EIGRP over Appletalk *//* ARP type *//* IP type *//* ECHO type *//* ATP type *//* NBP type *//* RTMP request type *//* RTMP type *//* boundary of DDP well known sockets *//* size of DDP header (avoid struct padding) *//* Datagram Delivery Protocol *//* DDP type *//* short DDP type *//*
 * Copyright (c) 1988, 1989, 1990, 1993, 1994, 1995, 1996
 *	The Regents of the University of California.  All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that: (1) source code distributions
 * retain the above copyright notice and this paragraph in its entirety, (2)
 * distributions including binary code include the above copyright notice and
 * this paragraph in its entirety in the documentation or other materials
 * provided with the distribution, and (3) all advertising materials mentioning
 * features or use of this software display the following acknowledgement:
 * ``This product includes software developed by the University of California,
 * Lawrence Berkeley Laboratory and its contributors.'' Neither the name of
 * the University nor the names of its contributors may be used to endorse
 * or promote products derived from this software without specific prior
 * written permission.
 * THIS SOFTWARE IS PROVIDED ``AS IS'' AND WITHOUT ANY EXPRESS OR IMPLIED
 * WARRANTIES, INCLUDING, WITHOUT LIMITATION, THE IMPLIED WARRANTIES OF
 * MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE.
 *
 * AppleTalk protocol formats (courtesy Bill Croft of Stanford/SUMEX).
 *//Users/owura/Repos/codeql_eval/proj_repos/the-tcpdump-group-tcpdump-commit-0f95d441e4b5d7512cc5c326c8668a120e048eda/tcpdump/print-atalk.c"appletalk.h"ddpskt_string"%d", skt"%d"ataddr_stringtp2char[257]256+1nambuffirst/etc/atalk.names"/etc/atalk.names"char[256]linei1i2sizeof(line)'#'%d.%d %256s"%d.%d %256s"%d %256s"%d %256s"sizeof(nambuf)"%s.%d", tp2->name, athost%s.%d"%d.%d", atnet, athost"%d", atnet%d.%dconst atNBPtupleconst atNBPtuple *atNBPtuple *nbp_name_print(ndo, "\"")"(ndo, ":")(ndo, "@"):@nbp_tuple_printtpn(ndo, "(%d)", tp->enumerator)(%d)(ndo, " %d", tp->skt) %d&tp->net(ndo, " [addr=%s]", ataddr_string(ndo, EXTRACT_16BITS(&tp->net), tp->node))(ndo, " [addr=%s]", ataddr_string(ndo, ((uint16_t)(((uint16_t)(*((const uint8_t *)(&tp->net) + 0)) << 8) | ((uint16_t)(*((const uint8_t *)(&tp->net) + 1)) << 0))), tp->node)) [addr=%s]atnetathostsnetsnodeprint_cstring(ndo, "[len=%u]", length)[len=%u](ndo, "%c", *cp++)nbp_printconst atNBPconst atNBP *atNBP *(ndo, " truncated-nbp %u", length) truncated-nbp %u(ndo, " truncated-nbp %u", length + nbpHeaderSize)(ndo, " truncated-nbp %u", length + 2)(ndo, i == nbpLkUp? " nbp-lkup %d:":" nbp-brRq %d:", np->id)(ndo, i == 0x20? " nbp-lkup %d:":" nbp-brRq %d:", np->id)(ndo, " [ntup=%d]", np->control & 0xf)(ndo, " [enum=%d]", tp->enumerator)(ndo, " [addr=%s.%d]", ataddr_string(ndo, EXTRACT_16BITS(&tp->net), tp->node), tp->skt)(ndo, " [addr=%s.%d]", ataddr_string(ndo, ((uint16_t)(((uint16_t)(*((const uint8_t *)(&tp->net) + 0)) << 8) | ((uint16_t)(*((const uint8_t *)(&tp->net) + 1)) << 0))), tp->node), tp->skt)(ndo, " nbp-reply %d:", np->id)(ndo, " nbp-0x%x  %d (%u)", np->control, np->id, length) nbp-lkup %d: nbp-brRq %d: [ntup=%d] [enum=%d] [addr=%s.%d] nbp-reply %d: nbp-0x%x  %d (%u)atp_bitmap_print(ndo, "%c%d", c, i)(ndo, ">")(ndo, "<0-%d>", i - 1)(ndo, "<0>")'<'%c%d','><0-%d><0>atp_printconst atATPconst atATP *atATP *data(ndo, " [|atp %u]", length) [|atp %u](ndo, " atp-req%s %d", ap->control & atpXO? " " : "*", EXTRACT_16BITS(&ap->transID))(ndo, " atp-req%s %d", ap->control & 0x20? " " : "*", ((uint16_t)(((uint16_t)(*((const uint8_t *)(&ap->transID) + 0)) << 8) | ((uint16_t)(*((const uint8_t *)(&ap->transID) + 1)) << 0))))&ap->transID(ndo, " [len=%u]", length)(ndo, " [EOM]")(ndo, " [STS]")(ndo, " [EOM,STS]")(ndo, " atp-resp%s%d:%d (%u)", ap->control & atpEOM? "*" : " ", EXTRACT_16BITS(&ap->transID), ap->bitmap, length)(ndo, " atp-resp%s%d:%d (%u)", ap->control & 0x10? "*" : " ", ((uint16_t)(((uint16_t)(*((const uint8_t *)(&ap->transID) + 0)) << 8) | ((uint16_t)(*((const uint8_t *)(&ap->transID) + 1)) << 0))), ap->bitmap, length)(ndo, " [XO]")(ndo, " [XO,STS]")(ndo, " atp-rel  %d", EXTRACT_16BITS(&ap->transID))(ndo, " atp-rel  %d", ((uint16_t)(((uint16_t)(*((const uint8_t *)(&ap->transID) + 0)) << 8) | ((uint16_t)(*((const uint8_t *)(&ap->transID) + 1)) << 0))))(ndo, "%cXO", c)(ndo, "%cEOM", c)(ndo, "%cSTS", c)(ndo, "]")(ndo, " atp-0x%x  %d (%u)", ap->control, EXTRACT_16BITS(&ap->transID), length)(ndo, " atp-0x%x  %d (%u)", ap->control, ((uint16_t)(((uint16_t)(*((const uint8_t *)(&ap->transID) + 0)) << 8) | ((uint16_t)(*((const uint8_t *)(&ap->transID) + 1)) << 0))), length)0xc0 atp-req%s %d [len=%u](atpEOM|atpSTS) [EOM] [STS] [EOM,STS] atp-resp%s%d:%d (%u)npbm(atpXO|atpSTS) [XO] [XO,STS] atp-rel  %d(atpXO|atpEOM|atpSTS)'['%cXO%cEOM%cSTS] atp-0x%x  %d (%u)&ap->userDataconst int32_tconst int32_t *(ndo, " 0x%x", data) 0x%xddp_print(ndo, " at-%s %d", tok2str(type2str, NULL, t), length)(ndo, " at-%s %d", tok2str(type2str, ((void *)0), t), length) at-%s %daarp_printconst aarpconst aarp *aarp *(ndo, "aarp ")aarp &ap->htype&ap->ptype&ap->op(ndo, "who-has %s tell %s", AT(pdaddr), AT(psaddr))(ndo, "who-has %s tell %s", ataddr_string(ndo, (ap->pdaddr[1]<<8)|ap->pdaddr[2],ap->pdaddr[3]), ataddr_string(ndo, (ap->psaddr[1]<<8)|ap->psaddr[2],ap->psaddr[3]))pdaddrpsaddr(ndo, "reply %s is-at %s", AT(psaddr), etheraddr_string(ndo, ap->hsaddr))(ndo, "reply %s is-at %s", ataddr_string(ndo, (ap->psaddr[1]<<8)|ap->psaddr[2],ap->psaddr[3]), etheraddr_string(ndo, ap->hsaddr))(ndo, "probe %s tell %s", AT(pdaddr), AT(psaddr))(ndo, "probe %s tell %s", ataddr_string(ndo, (ap->pdaddr[1]<<8)|ap->pdaddr[2],ap->pdaddr[3]), ataddr_string(ndo, (ap->psaddr[1]<<8)|ap->psaddr[2],ap->psaddr[3]))32923who-has %s tell %sreply %s is-at %sprobe %s tell %s(ndo, "len %u op %u htype %u ptype %#x halen %u palen %u", length, EXTRACT_16BITS(&ap->op), EXTRACT_16BITS(&ap->htype), EXTRACT_16BITS(&ap->ptype), ap->halen, ap->palen)(ndo, "len %u op %u htype %u ptype %#x halen %u palen %u", length, ((uint16_t)(((uint16_t)(*((const uint8_t *)(&ap->op) + 0)) << 8) | ((uint16_t)(*((const uint8_t *)(&ap->op) + 1)) << 0))), ((uint16_t)(((uint16_t)(*((const uint8_t *)(&ap->htype) + 0)) << 8) | ((uint16_t)(*((const uint8_t *)(&ap->htype) + 1)) << 0))), ((uint16_t)(((uint16_t)(*((const uint8_t *)(&ap->ptype) + 0)) << 8) | ((uint16_t)(*((const uint8_t *)(&ap->ptype) + 1)) << 0))), ap->halen, ap->palen)len %u op %u htype %u ptype %#x halen %u palen %uatalk_printconst atDDPconst atDDP *atDDP *(ndo, "AT ")AT (ndo, " [|ddp %u]", length) [|ddp %u]&dp->srcNet(ndo, "%s.%s", ataddr_string(ndo, snet, dp->srcNode), ddpskt_string(ndo, dp->srcSkt))%s.%s(ndo, " > %s.%s: ", ataddr_string(ndo, EXTRACT_16BITS(&dp->dstNet), dp->dstNode), ddpskt_string(ndo, dp->dstSkt))(ndo, " > %s.%s: ", ataddr_string(ndo, ((uint16_t)(((uint16_t)(*((const uint8_t *)(&dp->dstNet) + 0)) << 8) | ((uint16_t)(*((const uint8_t *)(&dp->dstNet) + 1)) << 0))), dp->dstNode), ddpskt_string(ndo, dp->dstSkt)) > %s.%s: &dp->dstNetllap_printconst LAPconst LAP *LAP *lpconst atShortDDPconst atShortDDP *atShortDDP *sdp(ndo, " [|llap %u]", length)sizeof(*lp) [|llap %u](ndo, " [|sddp %u]", length)(ndo, "%s.%s", ataddr_string(ndo, 0, lp->src), ddpskt_string(ndo, sdp->srcSkt))(ndo, " > %s.%s:", ataddr_string(ndo, 0, lp->dst), ddpskt_string(ndo, sdp->dstSkt))(ndo, " > %s.%s:", ataddr_string(ndo, EXTRACT_16BITS(&dp->dstNet), dp->dstNode), ddpskt_string(ndo, dp->dstSkt))(ndo, " > %s.%s:", ataddr_string(ndo, ((uint16_t)(((uint16_t)(*((const uint8_t *)(&dp->dstNet) + 0)) << 8) | ((uint16_t)(*((const uint8_t *)(&dp->dstNet) + 1)) << 0))), dp->dstNode), ddpskt_string(ndo, dp->dstSkt))(ndo, "%d > %d at-lap#%d %u", lp->src, lp->dst, lp->type, length) [|sddp %u] > %s.%s:%d > %d at-lap#%d %ultalk_if_printaarphdaddrhsaddrpalenhalenptypehtypertmp"rtmp"nis"nis"echo"echo"zip"zip"skt2strrtmpReq"rtmpReq"IP"IP"ARP"ARP"KLAP"KLAP"type2str[|atalk]"[|atalk]"AT(member)ataddr_string(ndo, (ap->member[1]<<8)|ap->member[2],ap->member[3])/* zone info protocol *//* AppleTalk echo protocol *//* name info socket *//* routing table maintenance *//* didn't have the node name -- see if we've got the net name *//* got a net name *//* got a hostname. *//*
	 * if this is the first call, see if there's an AppleTalk
	 * number to name map file.
	 *//* Zone *//* Object *//* if the address doesn't match the src address, it's an anomaly *//* if the socket doesn't match the src socket, print it *//* if the enumerator isn't 1, print it *//* Spec says string can be at most 32 bytes long *//* print a counted string *//* print each of the tuples in the reply *//*
		 * look for anomalies: the spec says there can only
		 * be one tuple, the address must match the source
		 * address and the enumerator should be zero.
		 *//* ep points to end of available data *//* must be room for at least one tuple *//*
	 * The '& 0xff' below is needed for compilers that want to sign
	 * extend a u_char, which is the case with the Ultrix compiler.
	 * (gcc is smart enough to eliminate it, at least on the Sparc).
	 *//* there shouldn't be any control flags *//* length should be zero *//* Just bail if we don't have the whole chunk. *//*
 * Print AppleTalk Datagram Delivery Protocol packets.
 *//* probe (oy!) *//* response *//* request *//* XXX should probably pass in the snap header and do checks like arp_print() *//*
 * Print EtherTalk/TokenTalk packets (or FDDITalk, or whatever it's called
 * when it runs over FDDI; yes, I've seen FDDI captures with AppleTalk
 * packets in them).
 *//*
 * Print AppleTalk LLAP packets.
 *//*
 * Print LLAP packets received on a physical LocalTalk interface.
 *//*
 * Copyright (c) 1988, 1989, 1990, 1991, 1992, 1993, 1994, 1995, 1996, 1997
 *	The Regents of the University of California.  All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that: (1) source code distributions
 * retain the above copyright notice and this paragraph in its entirety, (2)
 * distributions including binary code include the above copyright notice and
 * this paragraph in its entirety in the documentation or other materials
 * provided with the distribution, and (3) all advertising materials mentioning
 * features or use of this software display the following acknowledgement:
 * ``This product includes software developed by the University of California,
 * Lawrence Berkeley Laboratory and its contributors.'' Neither the name of
 * the University nor the names of its contributors may be used to endorse
 * or promote products derived from this software without specific prior
 * written permission.
 * THIS SOFTWARE IS PROVIDED ``AS IS'' AND WITHOUT ANY EXPRESS OR IMPLIED
 * WARRANTIES, INCLUDING, WITHOUT LIMITATION, THE IMPLIED WARRANTIES OF
 * MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE.
 *
 * Format and print AppleTalk packets.
 *//Users/owura/Repos/codeql_eval/proj_repos/the-tcpdump-group-tcpdump-commit-0f95d441e4b5d7512cc5c326c8668a120e048eda/tcpdump/atm.hATM_HDR_LEN_NOHECATM_OAM_HECATM_OAM_NOHECATM_LLCATM_LANEATM_UNKNOWN/*
 * some OAM cell captures (most notably Juniper's)
 * do not deliver a heading HEC byte
 *//* LLC encapsulation *//* LANE *//* Unknown *//*
 * Traffic types for ATM.
 *//*
 * Copyright (c) 2002 Guy Harris.
 *                All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that: (1) source code
 * distributions retain the above copyright notice and this paragraph
 * in its entirety, and (2) distributions including binary code include
 * the above copyright notice and this paragraph in its entirety in
 * the documentation or other materials provided with the distribution.
 * The name of Guy Harris may not be used to endorse or promote products
 * derived from this software without specific prior written permission.
 * THIS SOFTWARE IS PROVIDED ``AS IS'' AND WITHOUT ANY EXPRESS OR IMPLIED
 * WARRANTIES, INCLUDING, WITHOUT LIMITATION, THE IMPLIED WARRANTIES OF
 * MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE.
 *//Users/owura/Repos/codeql_eval/proj_repos/the-tcpdump-group-tcpdump-commit-0f95d441e4b5d7512cc5c326c8668a120e048eda/tcpdump/atmuni31.hFIELD_BEGIN_POSLEN_POSTYPE_POSIE_BEGIN_POSMSG_LEN_POSMSG_TYPE_POSCALL_REF_POSPROTO_POSQ2931CALLED_PARTY0x70CALLING_PARTY0x6cB_LOWER0x5fB_BEARER0x5eB_HIGHER0x5dQOS_PARA0x5cCONNECT_ID0x5aTRAFF_DESCRIP0x59AAL_PARA0x58ENDPT_REF0x54CAUSEDROP_PARTY_ACKDROP_PARTYADD_PARTY_REJADD_PARTY_ACKADD_PARTYSTATUS_ENQ0x75STATUS0x7dRESTART_ACKRESTART0x46RELEASE_DONERELEASE0x4dSETUPCONNECT_ACKCONNECTCALL_PROCEEDVCI_ILMICVCI_METACVCI_OAMF4ECVCI_OAMF4SCVCI_BCCVCI_PPC/* format of signalling messages *//* offset of first information element *//* offset of mesage length *//* offset of message type *//* offset of call reference value *//* offset of protocol discriminator *//* Q.2931 signalling general messages format *//* called party nmber *//* calling party number *//* broadband lower information *//* broadband bearer capability *//* broadband higher layer information *//* quality of service parameters *//* connection identifier *//* atm traffic descriptors *//* ATM adaptation layer parameters *//* endpoint reference *//* cause *//* Information Element Parameters in the signalling messages *//* drop party ack *//* drop party *//* add party rej *//* add party ack *//* add party *//* status ack *//* status *//* restart ack *//* restart *//* release_done *//* release *//* setup *//* connect_ack *//* connect *//* call proceeding *//* Q.2931 signalling messages *//* ILMI msg *//* Meta signal msg *//* End-to-end OAM F4 flow cell *//* Segment OAM F4 flow cell *//* Broadcast signal msg *//* Point-to-point signal msg *//* ATM traffic types based on VPI=0 and (the following VCI *//* Based on UNI3.1 standard by ATM Forum *//*
 * Copyright (c) 1997 Yen Yen Lim and North Dakota State University
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *      This product includes software developed by Yen Yen Lim and
        North Dakota State University
 * 4. The name of the author may not be used to endorse or promote products
 *    derived from this software without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
 * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
 * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT,
 * INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
 * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
 * SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
 * STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN
 * ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
 * POSSIBILITY OF SUCH DAMAGE.
 *//Users/owura/Repos/codeql_eval/proj_repos/the-tcpdump-group-tcpdump-commit-0f95d441e4b5d7512cc5c326c8668a120e048eda/tcpdump/print-atm.c"atmuni31.h""atm.h"oam_printcell_headervpivcicksumcksum_shouldbeidxcell_typefunc_typepayloadclpoam_ptrp+hec(ndo, "%s, vpi %u, vci %u, payload [ %s ], clp %u, length %u", tok2str(oam_f_values, "OAM F5", vci), vpi, vci, tok2str(atm_pty_values, "Unknown", payload), clp, length)%s, vpi %u, vci %u, payload [ %s ], clp %u, length %uOAM F5(ndo, "\n\tcell-type %s (%u)", tok2str(oam_celltype_values, "unknown", cell_type), cell_type)
	cell-type %s (%u)unknown(ndo, ", func-type unknown (%u)", func_type)(ndo, ", func-type %s (%u)", tok2str(oam_functype_values[cell_type],"none",func_type), func_type)const tok *[16]tok *[16]const tok **tok **, func-type unknown (%u), func-type %s (%u)(ndo, "\n\tLoopback-Indicator %s, Correlation-Tag 0x%08x", tok2str(oam_fm_loopback_indicator_values, "Unknown", oam_ptr.oam_fm_loopback->loopback_indicator & OAM_FM_LOOPBACK_INDICATOR_MASK), EXTRACT_32BITS(&oam_ptr.oam_fm_loopback->correlation_tag))(ndo, "\n\tLoopback-Indicator %s, Correlation-Tag 0x%08x", tok2str(oam_fm_loopback_indicator_values, "Unknown", oam_ptr.oam_fm_loopback->loopback_indicator & 0x1), ((uint32_t)(((uint32_t)(*((const uint8_t *)(&oam_ptr.oam_fm_loopback->correlation_tag) + 0)) << 24) | ((uint32_t)(*((const uint8_t *)(&oam_ptr.oam_fm_loopback->correlation_tag) + 1)) << 16) | ((uint32_t)(*((const uint8_t *)(&oam_ptr.oam_fm_loopback->correlation_tag) + 2)) << 8) | ((uint32_t)(*((const uint8_t *)(&oam_ptr.oam_fm_loopback->correlation_tag) + 3)) << 0))))&oam_ptr.oam_fm_loopback->correlation_tag(ndo, "\n\tLocation-ID ")(ndo, "%04x ", EXTRACT_16BITS(&oam_ptr.oam_fm_loopback->loopback_id[idx]))(ndo, "%04x ", ((uint16_t)(((uint16_t)(*((const uint8_t *)(&oam_ptr.oam_fm_loopback->loopback_id[idx]) + 0)) << 8) | ((uint16_t)(*((const uint8_t *)(&oam_ptr.oam_fm_loopback->loopback_id[idx]) + 1)) << 0))))&oam_ptr.oam_fm_loopback->loopback_id[idx](ndo, "\n\tSource-ID   ")(ndo, "%04x ", EXTRACT_16BITS(&oam_ptr.oam_fm_loopback->source_id[idx]))(ndo, "%04x ", ((uint16_t)(((uint16_t)(*((const uint8_t *)(&oam_ptr.oam_fm_loopback->source_id[idx]) + 0)) << 8) | ((uint16_t)(*((const uint8_t *)(&oam_ptr.oam_fm_loopback->source_id[idx]) + 1)) << 0))))&oam_ptr.oam_fm_loopback->source_id[idx](ndo, "\n\tFailure-type 0x%02x", oam_ptr.oam_fm_ais_rdi->failure_type)(ndo, "%04x ", EXTRACT_16BITS(&oam_ptr.oam_fm_ais_rdi->failure_location[idx]))(ndo, "%04x ", ((uint16_t)(((uint16_t)(*((const uint8_t *)(&oam_ptr.oam_fm_ais_rdi->failure_location[idx]) + 0)) << 8) | ((uint16_t)(*((const uint8_t *)(&oam_ptr.oam_fm_ais_rdi->failure_location[idx]) + 1)) << 0))))&oam_ptr.oam_fm_ais_rdi->failure_location[idx]OAM_CELLTYPE_FMOAM_FM_FUNCTYPE_LOOPBACK(OAM_CELLTYPE_FM << 4 | OAM_FM_FUNCTYPE_LOOPBACK)const oam_fm_loopback_tconst oam_fm_loopback_t *oam_fm_loopback_t *OAM_CELLTYPE_FUNCTYPE_LEN
	Loopback-Indicator %s, Correlation-Tag 0x%08x
	Location-ID uint8_t[12]unsigned char[12]const uint8_t[12]sizeof(oam_ptr.oam_fm_loopback->loopback_id)%04x 
	Source-ID   sizeof(oam_ptr.oam_fm_loopback->source_id)OAM_FM_FUNCTYPE_AIS(OAM_CELLTYPE_FM << 4 | OAM_FM_FUNCTYPE_AIS)OAM_FM_FUNCTYPE_RDI(OAM_CELLTYPE_FM << 4 | OAM_FM_FUNCTYPE_RDI)const oam_fm_ais_rdi_tconst oam_fm_ais_rdi_t *oam_fm_ais_rdi_t *
	Failure-type 0x%02xconst uint8_t[16]sizeof(oam_ptr.oam_fm_ais_rdi->failure_location)OAM_FM_FUNCTYPE_CONTCHECK(OAM_CELLTYPE_FM << 4 | OAM_FM_FUNCTYPE_CONTCHECK)p + OAM_CELLTYPE_FUNCTYPE_LEN + OAM_FUNCTION_SPECIFIC_LENp + 1 + 45hecOAM_CRC10_MASKOAM_PAYLOAD_LEN(ndo, "\n\tcksum 0x%03x (%scorrect)", cksum, cksum_shouldbe == 0 ? "" : "in")
	cksum 0x%03x (%scorrect)inatm_print(ndo, "VPI:%u VCI:%u ", vpi, vci)VPI:%u VCI:%u (ndo, "broadcast sig: ")(ndo, "meta: ")(ndo, "ilmi: ")broadcast sig: meta: ilmi: sig_printcall_ref(ndo, "Q.2931")(ndo, " %s", tstr)(ndo, ":%s ", tok2str(msgtype2str, "msgtype#%d", p[MSG_TYPE_POS]))(ndo, ":%s ", tok2str(msgtype2str, "msgtype#%d", p[5]))&p[CALL_REF_POS]&p[2](ndo, "CALL_REF:0x%06x", call_ref)(ndo, "SSCOP, proto %d ", p[PROTO_POS])(ndo, "SSCOP, proto %d ", p[0])Q.2931:%s msgtype#%dCALL_REF:0x%06xSSCOP, proto %d atm_if_printllchdr(ndo, "CNLPID ")CNLPID (ndo, "%08x%08x %08x%08x ", EXTRACT_32BITS(p), EXTRACT_32BITS(p+4), EXTRACT_32BITS(p+8), EXTRACT_32BITS(p+12))(ndo, "%08x%08x %08x%08x ", ((uint32_t)(((uint32_t)(*((const uint8_t *)(p) + 0)) << 24) | ((uint32_t)(*((const uint8_t *)(p) + 1)) << 16) | ((uint32_t)(*((const uint8_t *)(p) + 2)) << 8) | ((uint32_t)(*((const uint8_t *)(p) + 3)) << 0))), ((uint32_t)(((uint32_t)(*((const uint8_t *)(p+4) + 0)) << 24) | ((uint32_t)(*((const uint8_t *)(p+4) + 1)) << 16) | ((uint32_t)(*((const uint8_t *)(p+4) + 2)) << 8) | ((uint32_t)(*((const uint8_t *)(p+4) + 3)) << 0))), ((uint32_t)(((uint32_t)(*((const uint8_t *)(p+8) + 0)) << 24) | ((uint32_t)(*((const uint8_t *)(p+8) + 1)) << 16) | ((uint32_t)(*((const uint8_t *)(p+8) + 2)) << 8) | ((uint32_t)(*((const uint8_t *)(p+8) + 3)) << 0))), ((uint32_t)(((uint32_t)(*((const uint8_t *)(p+12) + 0)) << 24) | ((uint32_t)(*((const uint8_t *)(p+12) + 1)) << 16) | ((uint32_t)(*((const uint8_t *)(p+12) + 2)) << 8) | ((uint32_t)(*((const uint8_t *)(p+12) + 3)) << 0))))p+4p+8p+1211141120435201118464011184643LLC_UI_HDR(LLCSAP_SNAP)16646144650241671116816711171LLC_UI_HDR(LLCSAP_ISONS)3932161536394752394755LLC_UI_HDR(LLCSAP_IP)%08x%08x %08x%08x traftypeatm_llc_print(ndo, "(LLC %s) ", etherproto_string(htons(extracted_ethertype)))(ndo, "(LLC %s) ", etherproto_string(((__uint16_t)(__builtin_constant_p(extracted_ethertype) ? ((__uint16_t)((((__uint16_t)(extracted_ethertype) & 0xff00U) >> 8) | (((__uint16_t)(extracted_ethertype) & 0x00ffU) << 8))) : _OSSwapInt16(extracted_ethertype)))))oam_fm_ais_rdi_toam_fm_loopback_toam_fm_ais_rdioam_fm_loopbackuint8_t[28]unsigned char[28]failure_locationfailure_typesource_idloopback_idcorrelation_tagloopback_indicatorCall_proceeding"Call_proceeding"Connect"Connect"Connect_ack"Connect_ack"Setup"Setup"Release_complete"Release_complete"Restart"Restart"Restart_ack"Restart_ack"Status"Status"Status_enquiry"Status_enquiry"Add_party"Add_party"Add_party_ack"Add_party_ack"Add_party_reject"Add_party_reject"Drop_party"Drop_party"Drop_party_ack"Drop_party_ack"msgtype2stroam_functype_valuesoam_fm_loopback_indicator_valuesPerformance Monitoring"Performance Monitoring"Continuity Check"Continuity Check"oam_ad_functype_valuesForward Monitoring"Forward Monitoring"Backward Reporting"Backward Reporting"Monitoring and Reporting"Monitoring and Reporting"oam_pm_functype_valuesAIS"AIS"RDI"RDI"Loopback"Loopback"oam_fm_functype_valuesFault Management"Fault Management"OAM_CELLTYPE_PMPerformance Management"Performance Management"OAM_CELLTYPE_ADactivate/deactivate"activate/deactivate"OAM_CELLTYPE_SMSystem Management"System Management"oam_celltype_valuesuser data, uncongested, SDU 0"user data, uncongested, SDU 0"user data, uncongested, SDU 1"user data, uncongested, SDU 1"user data, congested, SDU 0"user data, congested, SDU 0"user data, congested, SDU 1"user data, congested, SDU 1"VCC OAM F5 flow segment"VCC OAM F5 flow segment"VCC OAM F5 flow end-to-end"VCC OAM F5 flow end-to-end"Traffic Control and resource Mgmt"Traffic Control and resource Mgmt"atm_pty_valuesOAM F4 (segment)"OAM F4 (segment)"OAM F4 (end)"OAM F4 (end)"oam_f_values[|atm]"[|atm]"LLC_UI_HDR(sap)((sap)<<16 | (sap<<8) | 0x03)OAM_FM_LOOPBACK_INDICATOR_MASKOAM_FUNCTION_SPECIFIC_LEN/* crc10 checksum verification *//* FIXME *//*
		 * Assumes traffic is LLC if unknown.
		 *//* fall through *//*
 * Print an ATM PDU (such as an AAL5 PDU).
 *//* SCCOP with some unknown protocol atop it *//*
		 * The call reference comes before the message type,
		 * so if we know we have the message type, which we
		 * do from the caplen test above, we also know we have
		 * the call reference.
		 *//*
		 * protocol:Q.2931 for User to Network Interface
		 * (UNI 3.1) signalling
		 *//*
 * ATM signalling.
 *//*
		 * XXX - assume 802.6 MAC header from Fore driver.
		 *
		 * Unfortunately, the above list doesn't check for
		 * all known SAPs, doesn't check for headers where
		 * the source and destination SAP aren't the same,
		 * and doesn't check for non-UI frames.  It also
		 * runs the risk of an 802.6 MAC header that happens
		 * to begin with one of those values being
		 * incorrectly treated as an 802.2 header.
		 *
		 * So is that Fore driver still around?  And, if so,
		 * is it still putting 802.6 MAC headers on ATM
		 * packets?  If so, could it be changed to use a
		 * new DLT_IEEE802_6 value if we added it?
		 *//*
	 * Extract the presumed LLC header into a variable, for quick
	 * testing.
	 * Then check for a header that's neither a header for a SNAP
	 * packet nor an RFC 2684 routed NLPID-formatted PDU nor
	 * an 802.2-but-no-SNAP IP packet.
	 *//* Cisco Style NLPID ? *//*
 * This is the top level routine of the printer.  'p' points
 * to the LLC/SNAP header of the packet, 'h->ts' is the timestamp,
 * 'h->len' is the length of the packet off the wire, and 'h->caplen'
 * is the number of bytes actually captured.
 *//*
 * Given a SAP value, generate the LLC header value for a UI packet
 * with that SAP as the source and destination SAP.
 *//*
 * Print an RFC 1483 LLC-encapsulated ATM frame.
 *//* this excludes crc10 and cell-type/function-type *//*
 * Copyright (c) 1994, 1995, 1996, 1997
 *	The Regents of the University of California.  All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that: (1) source code distributions
 * retain the above copyright notice and this paragraph in its entirety, (2)
 * distributions including binary code include the above copyright notice and
 * this paragraph in its entirety in the documentation or other materials
 * provided with the distribution, and (3) all advertising materials mentioning
 * features or use of this software display the following acknowledgement:
 * ``This product includes software developed by the University of California,
 * Lawrence Berkeley Laboratory and its contributors.'' Neither the name of
 * the University nor the names of its contributors may be used to endorse
 * or promote products derived from this software without specific prior
 * written permission.
 * THIS SOFTWARE IS PROVIDED ``AS IS'' AND WITHOUT ANY EXPRESS OR IMPLIED
 * WARRANTIES, INCLUDING, WITHOUT LIMITATION, THE IMPLIED WARRANTIES OF
 * MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE.
 *//Users/owura/Repos/codeql_eval/proj_repos/the-tcpdump-group-tcpdump-commit-0f95d441e4b5d7512cc5c326c8668a120e048eda/tcpdump/print-beep.cbeep_print(ndo, " BEEP MSG")(ndo, " BEEP RPY")(ndo, " BEEP ERR")(ndo, " BEEP ANS")(ndo, " BEEP NUL")(ndo, " BEEP SEQ")(ndo, " BEEP END")(ndo, " BEEP (payload or undecoded)")MSG"MSG" BEEP MSGRPY "RPY " BEEP RPYERR "ERR " BEEP ERRANS "ANS " BEEP ANSNUL "NUL " BEEP NULSEQ "SEQ " BEEP SEQEND"END" BEEP END BEEP (payload or undecoded)l_strnstart/* A REQuest *//* Check for a string but not go beyond length
 * Return TRUE on match, FALSE otherwise
 *
 * Looks at the first few chars up to tl1 ...
 *//*
 * Copyright (C) 2000, Richard Sharpe
 *
 * This software may be distributed either under the terms of the
 * BSD-style licence that accompanies tcpdump or under the GNU GPL
 * version 2 or later.
 *
 * print-beep.c
 *
 */tstr1tl1str2l2/Users/owura/Repos/codeql_eval/proj_repos/the-tcpdump-group-tcpdump-commit-0f95d441e4b5d7512cc5c326c8668a120e048eda/tcpdump/udp.hudphdruh_sumuh_ulenuh_dportuh_sportVXLAN_PORT4789OTV_PORT8472LWAPP_CONTROL_PORT12223LWAPP_DATA_PORT12222SFLOW_PORT6343WB_PORT4567BFD_ECHO_PORT3785BFD_CONTROL_PORT3784MPLS_LSP_PING_PORT3503VAT_PORT3456ZEPHYR_CLT_PORT2104ZEPHYR_SRV_PORT2103VQP_PORT1589LWRES_PORT921LMP_PORT701HSRP_PORTRADIUS_COA_PORT3799RADIUS_NEW_ACCOUNTING_PORT1813RADIUS_ACCOUNTING_PORT1646RADIUS_NEW_PORT1812RADIUS_PORT1645CISCO_AUTORP_PORTNETBIOS_DGRAM_PORTNETBIOS_NS_PORTRX_PORT_HIGH7009RX_PORT_LOW7000ISAKMP_PORT_USER28500ISAKMP_PORT_USER17500ISAKMP_PORT_NATT4500SIP_PORT5060L2TP_PORT1701KERBEROS_SEC_PORT750OLSR_PORT698AODV_PORT654LDP_PORT646RIP_PORT520TIMED_PORT525SYSLOG_PORT514ISAKMP_PORT500SNMPTRAP_PORTNTP_PORTSNMP_PORTSUNRPC_PORTKERBEROS_PORTTFTP_PORTBOOTPC_PORTBOOTPS_PORT/* draft-chroboczek-ahcp-00 *//*XXX*//* draft-mahalingam-dutt-dcops-vxlan-04 *//* draft-hasmit-otv-04 *//* draft-ohara-capwap-lwapp-04.txt *//* http://www.sflow.org/developers/specifications.php *//* draft-katz-ward-bfd-v4v6-1hop-00.txt *//* draft-ietf-mpls-lsp-ping-02.txt *//* rfc4204 *//*XXX - nonstandard*//* rfc3948 *//* rfc3626 *//* rfc3164 *//* RFC951 *//* udp checksum *//* udp length *//* destination port *//* source port *//*
 * Udp protocol header.
 * Per RFC 768, September, 1981.
 *//*
 * Copyright (c) 1982, 1986, 1993
 *	The Regents of the University of California.  All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *	This product includes software developed by the University of
 *	California, Berkeley and its contributors.
 * 4. Neither the name of the University nor the names of its contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 *
 *	@(#)udp.h	8.1 (Berkeley) 6/10/93
 *//Users/owura/Repos/codeql_eval/proj_repos/the-tcpdump-group-tcpdump-commit-0f95d441e4b5d7512cc5c326c8668a120e048eda/tcpdump/print-bfd.c"udp.h"bfd_printconst bfd_header_tconst bfd_header_t *bfd_header_t *bfd_headerconst bfd_auth_header_tconst bfd_auth_header_t *bfd_auth_header_t *bfd_auth_header*bfd_headersizeof(*bfd_header)bfd_header->version_diag(ndo, "BFDv%u, %s, Flags: [%s], length: %u", version, tok2str(bfd_port_values, "unknown (%u)", port), bittok2str(bfd_v0_flag_values, "none", bfd_header->flags), len)(ndo, "BFDv%u, length: %u\n\t%s, Flags: [%s], Diagnostic: %s (0x%02x)", version, len, tok2str(bfd_port_values, "unknown (%u)", port), bittok2str(bfd_v0_flag_values, "none", bfd_header->flags), tok2str(bfd_diag_values,"unknown",BFD_EXTRACT_DIAG(bfd_header->version_diag)), BFD_EXTRACT_DIAG(bfd_header->version_diag))(ndo, "BFDv%u, length: %u\n\t%s, Flags: [%s], Diagnostic: %s (0x%02x)", version, len, tok2str(bfd_port_values, "unknown (%u)", port), bittok2str(bfd_v0_flag_values, "none", bfd_header->flags), tok2str(bfd_diag_values,"unknown",((bfd_header->version_diag)&0x1f)), ((bfd_header->version_diag)&0x1f))(ndo, "\n\tDetection Timer Multiplier: %u (%u ms Detection time), BFD Length: %u", bfd_header->detect_time_multiplier, bfd_header->detect_time_multiplier * EXTRACT_32BITS(bfd_header->desired_min_tx_interval)/1000, bfd_header->length)(ndo, "\n\tDetection Timer Multiplier: %u (%u ms Detection time), BFD Length: %u", bfd_header->detect_time_multiplier, bfd_header->detect_time_multiplier * ((uint32_t)(((uint32_t)(*((const uint8_t *)(bfd_header->desired_min_tx_interval) + 0)) << 24) | ((uint32_t)(*((const uint8_t *)(bfd_header->desired_min_tx_interval) + 1)) << 16) | ((uint32_t)(*((const uint8_t *)(bfd_header->desired_min_tx_interval) + 2)) << 8) | ((uint32_t)(*((const uint8_t *)(bfd_header->desired_min_tx_interval) + 3)) << 0)))/1000, bfd_header->length)bfd_header->desired_min_tx_interval(ndo, "\n\tMy Discriminator: 0x%08x", EXTRACT_32BITS(bfd_header->my_discriminator))(ndo, "\n\tMy Discriminator: 0x%08x", ((uint32_t)(((uint32_t)(*((const uint8_t *)(bfd_header->my_discriminator) + 0)) << 24) | ((uint32_t)(*((const uint8_t *)(bfd_header->my_discriminator) + 1)) << 16) | ((uint32_t)(*((const uint8_t *)(bfd_header->my_discriminator) + 2)) << 8) | ((uint32_t)(*((const uint8_t *)(bfd_header->my_discriminator) + 3)) << 0))))bfd_header->my_discriminator(ndo, ", Your Discriminator: 0x%08x", EXTRACT_32BITS(bfd_header->your_discriminator))(ndo, ", Your Discriminator: 0x%08x", ((uint32_t)(((uint32_t)(*((const uint8_t *)(bfd_header->your_discriminator) + 0)) << 24) | ((uint32_t)(*((const uint8_t *)(bfd_header->your_discriminator) + 1)) << 16) | ((uint32_t)(*((const uint8_t *)(bfd_header->your_discriminator) + 2)) << 8) | ((uint32_t)(*((const uint8_t *)(bfd_header->your_discriminator) + 3)) << 0))))bfd_header->your_discriminator(ndo, "\n\t  Desired min Tx Interval:    %4u ms", EXTRACT_32BITS(bfd_header->desired_min_tx_interval)/1000)(ndo, "\n\t  Desired min Tx Interval:    %4u ms", ((uint32_t)(((uint32_t)(*((const uint8_t *)(bfd_header->desired_min_tx_interval) + 0)) << 24) | ((uint32_t)(*((const uint8_t *)(bfd_header->desired_min_tx_interval) + 1)) << 16) | ((uint32_t)(*((const uint8_t *)(bfd_header->desired_min_tx_interval) + 2)) << 8) | ((uint32_t)(*((const uint8_t *)(bfd_header->desired_min_tx_interval) + 3)) << 0)))/1000)(ndo, "\n\t  Required min Rx Interval:   %4u ms", EXTRACT_32BITS(bfd_header->required_min_rx_interval)/1000)(ndo, "\n\t  Required min Rx Interval:   %4u ms", ((uint32_t)(((uint32_t)(*((const uint8_t *)(bfd_header->required_min_rx_interval) + 0)) << 24) | ((uint32_t)(*((const uint8_t *)(bfd_header->required_min_rx_interval) + 1)) << 16) | ((uint32_t)(*((const uint8_t *)(bfd_header->required_min_rx_interval) + 2)) << 8) | ((uint32_t)(*((const uint8_t *)(bfd_header->required_min_rx_interval) + 3)) << 0)))/1000)bfd_header->required_min_rx_interval(ndo, "\n\t  Required min Echo Interval: %4u ms", EXTRACT_32BITS(bfd_header->required_min_echo_interval)/1000)(ndo, "\n\t  Required min Echo Interval: %4u ms", ((uint32_t)(((uint32_t)(*((const uint8_t *)(bfd_header->required_min_echo_interval) + 0)) << 24) | ((uint32_t)(*((const uint8_t *)(bfd_header->required_min_echo_interval) + 1)) << 16) | ((uint32_t)(*((const uint8_t *)(bfd_header->required_min_echo_interval) + 2)) << 8) | ((uint32_t)(*((const uint8_t *)(bfd_header->required_min_echo_interval) + 3)) << 0)))/1000)bfd_header->required_min_echo_interval(ndo, "BFDv%u, %s, State %s, Flags: [%s], length: %u", version, tok2str(bfd_port_values, "unknown (%u)", port), tok2str(bfd_v1_state_values, "unknown (%u)", (bfd_header->flags & 0xc0) >> 6), bittok2str(bfd_v1_flag_values, "none", bfd_header->flags & 0x3f), len)(ndo, "BFDv%u, length: %u\n\t%s, State %s, Flags: [%s], Diagnostic: %s (0x%02x)", version, len, tok2str(bfd_port_values, "unknown (%u)", port), tok2str(bfd_v1_state_values, "unknown (%u)", (bfd_header->flags & 0xc0) >> 6), bittok2str(bfd_v1_flag_values, "none", bfd_header->flags & 0x3f), tok2str(bfd_diag_values,"unknown",BFD_EXTRACT_DIAG(bfd_header->version_diag)), BFD_EXTRACT_DIAG(bfd_header->version_diag))(ndo, "BFDv%u, length: %u\n\t%s, State %s, Flags: [%s], Diagnostic: %s (0x%02x)", version, len, tok2str(bfd_port_values, "unknown (%u)", port), tok2str(bfd_v1_state_values, "unknown (%u)", (bfd_header->flags & 0xc0) >> 6), bittok2str(bfd_v1_flag_values, "none", bfd_header->flags & 0x3f), tok2str(bfd_diag_values,"unknown",((bfd_header->version_diag)&0x1f)), ((bfd_header->version_diag)&0x1f))*bfd_auth_headersizeof(const struct bfd_auth_header_t)(ndo, "\n\t%s (%u) Authentication, length %u present", tok2str(bfd_v1_authentication_values,"Unknown",bfd_auth_header->auth_type), bfd_auth_header->auth_type, bfd_auth_header->auth_len)(ndo, "BFD, %s, length: %u", tok2str(bfd_port_values, "unknown (%u)", port), len)968704(BFD_CONTROL_PORT << 8)BFDv%u, %s, Flags: [%s], length: %uchar[36]unknown (%u)BFDv%u, length: %u
	%s, Flags: [%s], Diagnostic: %s (0x%02x)char[61]
	Detection Timer Multiplier: %u (%u ms Detection time), BFD Length: %uchar[72]1000
	My Discriminator: 0x%08x, Your Discriminator: 0x%08x
	  Desired min Tx Interval:    %4u mschar[39]
	  Required min Rx Interval:   %4u ms
	  Required min Echo Interval: %4u ms968705(BFD_CONTROL_PORT << 8 | 1)BFDv%u, %s, State %s, Flags: [%s], length: %uBFDv%u, length: %u
	%s, State %s, Flags: [%s], Diagnostic: %s (0x%02x)char[71]BFD_FLAG_AUTHsizeof (const struct bfd_header_t)
	%s (%u) Authentication, length %u present968960(BFD_ECHO_PORT << 8)968961(BFD_ECHO_PORT << 8 | 1)BFD, %s, length: %u
	"\n\t"(ndo, "[|BFD]")[|BFD]bfd_auth_header_tbfd_header_tauth_dataauth_lenauth_typerequired_min_echo_intervalrequired_min_rx_intervaldesired_min_tx_intervalyour_discriminatormy_discriminatordetect_time_multiplierversion_diagAdminDown"AdminDown"Down"Down"Init"Init"Up"Up"bfd_v1_state_values"Poll"Final"Final"Control Plane Independent"Control Plane Independent"Authentication Present"Authentication Present"Demand"Demand"bfd_v1_flag_valuesI Hear You"I Hear You"bfd_v0_flag_valuesNo Diagnostic"No Diagnostic"Control Detection Time Expired"Control Detection Time Expired"Echo Function Failed"Echo Function Failed"Neighbor Signaled Session Down"Neighbor Signaled Session Down"Forwarding Plane Reset"Forwarding Plane Reset"Path Down"Path Down"Concatenated Path Down"Concatenated Path Down"Administratively Down"Administratively Down"Reverse Concatenated Path Down"Reverse Concatenated Path Down"bfd_diag_valuesControl"Control"Echo"Echo"bfd_port_valuesSimple Password"Simple Password"Keyed MD5"Keyed MD5"Meticulous Keyed MD5"Meticulous Keyed MD5"Keyed SHA1"Keyed SHA1"Meticulous Keyed SHA1"Meticulous Keyed SHA1"bfd_v1_authentication_valuesBFD_EXTRACT_DIAG(x)((x)&0x1f)BFD_EXTRACT_VERSION(x)(((x)&0xe0)>>5)/*
 * Local Variables:
 * c-style: whitesmith
 * c-basic-offset: 8
 * End:
 *//* BFDv1 *//* not yet supported - fall through *//* BFDv0 *//* Echo is BFD v1 only *//*
 *    An optional Authentication Header may be present
 *
 *     0                   1                   2                   3
 *     0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
 *    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
 *    |   Auth Type   |   Auth Len    |    Authentication Data...     |
 *    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
 *//*
 *  Control packet, BFDv1, draft-ietf-bfd-base-02.txt
 *
 *     0                   1                   2                   3
 *     0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
 *    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
 *    |Vers |  Diag   |Sta|P|F|C|A|D|R|  Detect Mult  |    Length     |
 *    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
 *    |                       My Discriminator                        |
 *    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
 *    |                      Your Discriminator                       |
 *    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
 *    |                    Desired Min TX Interval                    |
 *    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
 *    |                   Required Min RX Interval                    |
 *    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
 *    |                 Required Min Echo RX Interval                 |
 *    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
 *//*
 * Control packet, BFDv0, draft-katz-ward-bfd-01.txt
 *
 *     0                   1                   2                   3
 *     0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
 *    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
 *    |Vers |  Diag   |H|D|P|F| Rsvd  |  Detect Mult  |    Length     |
 *    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
 *    |                       My Discriminator                        |
 *    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
 *    |                      Your Discriminator                       |
 *    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
 *    |                    Desired Min TX Interval                    |
 *    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
 *    |                   Required Min RX Interval                    |
 *    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
 *    |                 Required Min Echo RX Interval                 |
 *    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
 *//Users/owura/Repos/codeql_eval/proj_repos/the-tcpdump-group-tcpdump-commit-0f95d441e4b5d7512cc5c326c8668a120e048eda/tcpdump/print-bgp.cbgp_printstartconst u_char[]unsigned char[]markerconst u_char[16]bgphlenTOKBUFSIZEtokbuf(ndo, ": BGP"): BGPp[0]sizeof(marker)BGP_SIZE&bgpp, BGP_SIZEp, 19(ndo, " [|BGP]")bgp.bgp_len(ndo, "\n[|BGP Bogus header length %u < %u]", hlen, BGP_SIZE)(ndo, "\n[|BGP Bogus header length %u < %u]", hlen, 19)(ndo, "\n[|BGP %s]", tok2strbuf(bgp_msg_values, "Unknown Message Type", bgp.bgp_type, tokbuf, sizeof(tokbuf)))bgp * [|BGP]
[|BGP Bogus header length %u < %u]
[|BGP %s]Unknown Message Typebgp_header_printdat[0]dat, BGP_SIZEdat, 19(ndo, "\n\t%s Message (%u), length: %u", tok2strbuf(bgp_msg_values, "Unknown", bgp.bgp_type, tokbuf, sizeof(tokbuf)), bgp.bgp_type, length)
	%s Message (%u), length: %u*dat(ndo, "\n\t  no Message %u decoder", bgp.bgp_type)BGP_OPENBGP_UPDATEBGP_NOTIFICATIONBGP_KEEPALIVEBGP_ROUTE_REFRESH
	  no Message %u decoder
	  "\n\t  "(ndo, "[|BGP]")[|BGP]bgp_route_refresh_printconst bgp_route_refreshconst bgp_route_refresh *bgp_route_refresh *bgp_route_refresh_headertokbuf2pptr[0]BGP_ROUTE_REFRESH_SIZE(ndo, "\n\t  AFI %s (%u), SAFI %s (%u)", tok2strbuf(af_values,"Unknown", EXTRACT_16BITS(&bgp_route_refresh_header->afi), tokbuf, sizeof(tokbuf)), EXTRACT_16BITS(&bgp_route_refresh_header->afi), tok2strbuf(bgp_safi_values,"Unknown", bgp_route_refresh_header->safi, tokbuf2, sizeof(tokbuf2)), bgp_route_refresh_header->safi)(ndo, "\n\t  AFI %s (%u), SAFI %s (%u)", tok2strbuf(af_values,"Unknown", ((uint16_t)(((uint16_t)(*((const uint8_t *)(&bgp_route_refresh_header->afi) + 0)) << 8) | ((uint16_t)(*((const uint8_t *)(&bgp_route_refresh_header->afi) + 1)) << 0))), tokbuf, sizeof(tokbuf)), ((uint16_t)(((uint16_t)(*((const uint8_t *)(&bgp_route_refresh_header->afi) + 0)) << 8) | ((uint16_t)(*((const uint8_t *)(&bgp_route_refresh_header->afi) + 1)) << 0))), tok2strbuf(bgp_safi_values,"Unknown", bgp_route_refresh_header->safi, tokbuf2, sizeof(tokbuf2)), bgp_route_refresh_header->safi)
	  AFI %s (%u), SAFI %s (%u)const uint8_t[2]const uint8_t(*)[2]unsigned char(*)[2]&bgp_route_refresh_header->aficonst tok[14]tok[14]*pptrbgp_notification_printbgpntptrBGP_NOTIFICATION_SIZE&bgpndat, BGP_NOTIFICATION_SIZEdat, 21bgp_notification *(ndo, ", %s (%u)", tok2strbuf(bgp_notify_major_values, "Unknown Error", bgpn.bgpn_major, tokbuf, sizeof(tokbuf)), bgpn.bgpn_major), %s (%u)Unknown Error(ndo, ", subcode %s (%u)", tok2strbuf(bgp_notify_minor_msg_values, "Unknown", bgpn.bgpn_minor, tokbuf, sizeof(tokbuf)), bgpn.bgpn_minor)(ndo, ", subcode %s (%u)", tok2strbuf(bgp_notify_minor_open_values, "Unknown", bgpn.bgpn_minor, tokbuf, sizeof(tokbuf)), bgpn.bgpn_minor)(ndo, ", subcode %s (%u)", tok2strbuf(bgp_notify_minor_update_values, "Unknown", bgpn.bgpn_minor, tokbuf, sizeof(tokbuf)), bgpn.bgpn_minor)(ndo, " subcode %s (%u)", tok2strbuf(bgp_notify_minor_cap_values, "Unknown", bgpn.bgpn_minor, tokbuf, sizeof(tokbuf)), bgpn.bgpn_minor)(ndo, ", subcode %s (%u)", tok2strbuf(bgp_notify_minor_cease_values, "Unknown", bgpn.bgpn_minor, tokbuf, sizeof(tokbuf)), bgpn.bgpn_minor)*tptr(ndo, ", AFI %s (%u), SAFI %s (%u), Max Prefixes: %u", tok2strbuf(af_values, "Unknown", EXTRACT_16BITS(tptr), tokbuf, sizeof(tokbuf)), EXTRACT_16BITS(tptr), tok2strbuf(bgp_safi_values, "Unknown", *(tptr+2), tokbuf2, sizeof(tokbuf)), *(tptr+2), EXTRACT_32BITS(tptr+3))(ndo, ", AFI %s (%u), SAFI %s (%u), Max Prefixes: %u", tok2strbuf(af_values, "Unknown", ((uint16_t)(((uint16_t)(*((const uint8_t *)(tptr) + 0)) << 8) | ((uint16_t)(*((const uint8_t *)(tptr) + 1)) << 0))), tokbuf, sizeof(tokbuf)), ((uint16_t)(((uint16_t)(*((const uint8_t *)(tptr) + 0)) << 8) | ((uint16_t)(*((const uint8_t *)(tptr) + 1)) << 0))), tok2strbuf(bgp_safi_values, "Unknown", *(tptr+2), tokbuf2, sizeof(tokbuf)), *(tptr+2), ((uint32_t)(((uint32_t)(*((const uint8_t *)(tptr+3) + 0)) << 24) | ((uint32_t)(*((const uint8_t *)(tptr+3) + 1)) << 16) | ((uint32_t)(*((const uint8_t *)(tptr+3) + 2)) << 8) | ((uint32_t)(*((const uint8_t *)(tptr+3) + 3)) << 0))))tptr+3BGP_NOTIFY_MAJOR_MSG, subcode %s (%u)BGP_NOTIFY_MAJOR_OPENBGP_NOTIFY_MAJOR_UPDATEBGP_NOTIFY_MAJOR_CAP subcode %s (%u)BGP_NOTIFY_MAJOR_CEASEBGP_NOTIFY_MINOR_CEASE_MAXPRFX, AFI %s (%u), SAFI %s (%u), Max Prefixes: %ubgp_update_printwithdrawn_routes_lenchar[356]MAXHOSTNAMELEN356wpfx(ndo, "\n\t  Withdrawn routes:")(ndo, "\n\t    (illegal prefix length)")(ndo, "\n\t    %s", buf)
	  Withdrawn routes:
	    (illegal prefix length)-2-3
	    %s(ndo, "\n\t  End-of-Rib Marker (empty NLRI)")
	  End-of-Rib Marker (empty NLRI)aflagsalenlen(ndo, "\n\t  %s (%u), length: %u", tok2strbuf(bgp_attr_values, "Unknown Attribute", atype, tokbuf, sizeof(tokbuf)), atype, alen)(ndo, ", Flags [%s%s%s%s", aflags & 0x80 ? "O" : "", aflags & 0x40 ? "T" : "", aflags & 0x20 ? "P" : "", aflags & 0x10 ? "E" : "")(ndo, "+%x", aflags & 0xf)(ndo, "]: ")atypealen
	  %s (%u), length: %uconst tok[22]tok[22]Unknown Attribute, Flags [%s%s%s%sOTPE+%x]: (ndo, "\n\t  Updated routes:")
	  Updated routes:bgp_open_printbgpobgpoptoptBGP_OPEN_SIZE&bgpodat, BGP_OPEN_SIZEdat, 29bgp_open *(ndo, "\n\t  Version %d, ", bgpo.bgpo_version)
	  Version %d, (ndo, "my AS %s, ", as_printf(ndo, astostr, sizeof(astostr), ntohs(bgpo.bgpo_myas)))(ndo, "my AS %s, ", as_printf(ndo, astostr, sizeof(astostr), ((__uint16_t)(__builtin_constant_p(bgpo.bgpo_myas) ? ((__uint16_t)((((__uint16_t)(bgpo.bgpo_myas) & 0xff00U) >> 8) | (((__uint16_t)(bgpo.bgpo_myas) & 0x00ffU) << 8))) : _OSSwapInt16(bgpo.bgpo_myas)))))my AS %s, bgpo.bgpo_myas(ndo, "Holdtime %us, ", ntohs(bgpo.bgpo_holdtime))(ndo, "Holdtime %us, ", ((__uint16_t)(__builtin_constant_p(bgpo.bgpo_holdtime) ? ((__uint16_t)((((__uint16_t)(bgpo.bgpo_holdtime) & 0xff00U) >> 8) | (((__uint16_t)(bgpo.bgpo_holdtime) & 0x00ffU) << 8))) : _OSSwapInt16(bgpo.bgpo_holdtime))))Holdtime %us, bgpo.bgpo_holdtime(ndo, "ID %s", getname(ndo, (u_char *)&bgpo.bgpo_id))ID %s(ndo, "\n\t  Optional parameters, length: %u", bgpo.bgpo_optlen)
	  Optional parameters, length: %uconst bgp_openconst bgp_open *opt[i]BGP_OPT_SIZE&bgpopt&opt[i], BGP_OPT_SIZE&opt[i], 2(ndo, "\n\t     Option %d, length: %u", bgpopt.bgpopt_type, bgpopt.bgpopt_len)(ndo, "\n\t    Option %s (%u), length: %u", tok2strbuf(bgp_opt_values,"Unknown", bgpopt.bgpopt_type, tokbuf, sizeof(tokbuf)), bgpopt.bgpopt_type, bgpopt.bgpopt_len)(ndo, "\n\t      no decoder for option %u", bgpopt.bgpopt_type)bgp_opt *
	     Option %d, length: %u
	    Option %s (%u), length: %uBGP_OPT_CAPBGP_OPT_AUTH
	      no decoder for option %ubgp_capabilities_printcap_typecap_lentcap_lencap_offsetBGP_CAP_HEADER_SIZE(ndo, "\n\t      %s (%u), length: %u", tok2strbuf(bgp_capcode_values, "Unknown", cap_type, tokbuf, sizeof(tokbuf)), cap_type, cap_len)opt[i+2](ndo, "\n\t\tAFI %s (%u), SAFI %s (%u)", tok2strbuf(af_values, "Unknown", EXTRACT_16BITS(opt+i+2), tokbuf, sizeof(tokbuf)), EXTRACT_16BITS(opt+i+2), tok2strbuf(bgp_safi_values, "Unknown", opt[i+5], tokbuf, sizeof(tokbuf)), opt[i+5])(ndo, "\n\t\tAFI %s (%u), SAFI %s (%u)", tok2strbuf(af_values, "Unknown", ((uint16_t)(((uint16_t)(*((const uint8_t *)(opt+i+2) + 0)) << 8) | ((uint16_t)(*((const uint8_t *)(opt+i+2) + 1)) << 0))), tokbuf, sizeof(tokbuf)), ((uint16_t)(((uint16_t)(*((const uint8_t *)(opt+i+2) + 0)) << 8) | ((uint16_t)(*((const uint8_t *)(opt+i+2) + 1)) << 0))), tok2strbuf(bgp_safi_values, "Unknown", opt[i+5], tokbuf, sizeof(tokbuf)), opt[i+5])opt+i+2(ndo, "\n\t\tRestart Flags: [%s], Restart Time %us", ((opt[i+2])&0x80) ? "R" : "none", EXTRACT_16BITS(opt+i+2)&0xfff)(ndo, "\n\t\tRestart Flags: [%s], Restart Time %us", ((opt[i+2])&0x80) ? "R" : "none", ((uint16_t)(((uint16_t)(*((const uint8_t *)(opt+i+2) + 0)) << 8) | ((uint16_t)(*((const uint8_t *)(opt+i+2) + 1)) << 0)))&0xfff)(ndo, "\n\t\t  AFI %s (%u), SAFI %s (%u), Forwarding state preserved: %s", tok2strbuf(af_values,"Unknown", EXTRACT_16BITS(opt+i+cap_offset), tokbuf, sizeof(tokbuf)), EXTRACT_16BITS(opt+i+cap_offset), tok2strbuf(bgp_safi_values,"Unknown", opt[i+cap_offset+2], tokbuf2, sizeof(tokbuf2)), opt[i+cap_offset+2], ((opt[i+cap_offset+3])&0x80) ? "yes" : "no" )(ndo, "\n\t\t  AFI %s (%u), SAFI %s (%u), Forwarding state preserved: %s", tok2strbuf(af_values,"Unknown", ((uint16_t)(((uint16_t)(*((const uint8_t *)(opt+i+cap_offset) + 0)) << 8) | ((uint16_t)(*((const uint8_t *)(opt+i+cap_offset) + 1)) << 0))), tokbuf, sizeof(tokbuf)), ((uint16_t)(((uint16_t)(*((const uint8_t *)(opt+i+cap_offset) + 0)) << 8) | ((uint16_t)(*((const uint8_t *)(opt+i+cap_offset) + 1)) << 0))), tok2strbuf(bgp_safi_values,"Unknown", opt[i+cap_offset+2], tokbuf2, sizeof(tokbuf2)), opt[i+cap_offset+2], ((opt[i+cap_offset+3])&0x80) ? "yes" : "no" )opt+i+cap_offset(ndo, "\n\t\t 4 Byte AS %s", as_printf(ndo, astostr, sizeof(astostr), EXTRACT_32BITS(opt + i + 2)))(ndo, "\n\t\t 4 Byte AS %s", as_printf(ndo, astostr, sizeof(astostr), ((uint32_t)(((uint32_t)(*((const uint8_t *)(opt + i + 2) + 0)) << 24) | ((uint32_t)(*((const uint8_t *)(opt + i + 2) + 1)) << 16) | ((uint32_t)(*((const uint8_t *)(opt + i + 2) + 2)) << 8) | ((uint32_t)(*((const uint8_t *)(opt + i + 2) + 3)) << 0)))))opt + i + 2(ndo, "\n\t\tno decoder for Capability %u", cap_type)caps_len
	      %s (%u), length: %uBGP_CAPCODE_MP
		AFI %s (%u), SAFI %s (%u)BGP_CAPCODE_RESTART
		Restart Flags: [%s], Restart Time %usR
		  AFI %s (%u), SAFI %s (%u), Forwarding state preserved: %schar[63]yesnoBGP_CAPCODE_RRBGP_CAPCODE_RR_CISCOBGP_CAPCODE_AS_NEW
		 4 Byte AS %s
		no decoder for Capability %u
		"\n\t\t"bgp_attr_printafsafisnpanhlenbwadvancetlenas_size(ndo, "invalid len")sizeof(*tptr)(ndo, "%s", tok2strbuf(bgp_origin_values, "Unknown Origin Typecode", tptr[0], tokbuf, sizeof(tokbuf)))(ndo, "empty")tptr[0]sizeof(tptr[0])(ndo, "%s", tok2strbuf(bgp_as_path_segment_open_values, "?", tptr[0], tokbuf, sizeof(tokbuf)))tptr[2 + i](ndo, "%s ", as_printf(ndo, astostr, sizeof(astostr), as_size == 2 ? EXTRACT_16BITS(&tptr[2 + i]) : EXTRACT_32BITS(&tptr[2 + i])))(ndo, "%s ", as_printf(ndo, astostr, sizeof(astostr), as_size == 2 ? ((uint16_t)(((uint16_t)(*((const uint8_t *)(&tptr[2 + i]) + 0)) << 8) | ((uint16_t)(*((const uint8_t *)(&tptr[2 + i]) + 1)) << 0))) : ((uint32_t)(((uint32_t)(*((const uint8_t *)(&tptr[2 + i]) + 0)) << 24) | ((uint32_t)(*((const uint8_t *)(&tptr[2 + i]) + 1)) << 16) | ((uint32_t)(*((const uint8_t *)(&tptr[2 + i]) + 2)) << 8) | ((uint32_t)(*((const uint8_t *)(&tptr[2 + i]) + 3)) << 0)))))&tptr[2 + i](ndo, "%s", tok2strbuf(bgp_as_path_segment_close_values, "?", tptr[0], tokbuf, sizeof(tokbuf)))tptr[1]sizeof(tptr[1])(ndo, "%s", getname(ndo, tptr))(ndo, "%u", EXTRACT_32BITS(tptr))(ndo, "%u", ((uint32_t)(((uint32_t)(*((const uint8_t *)(tptr) + 0)) << 24) | ((uint32_t)(*((const uint8_t *)(tptr) + 1)) << 16) | ((uint32_t)(*((const uint8_t *)(tptr) + 2)) << 8) | ((uint32_t)(*((const uint8_t *)(tptr) + 3)) << 0))))(ndo, " AS #%s, origin %s", as_printf(ndo, astostr, sizeof(astostr), EXTRACT_16BITS(tptr)), getname(ndo, tptr + 2))(ndo, " AS #%s, origin %s", as_printf(ndo, astostr, sizeof(astostr), ((uint16_t)(((uint16_t)(*((const uint8_t *)(tptr) + 0)) << 8) | ((uint16_t)(*((const uint8_t *)(tptr) + 1)) << 0)))), getname(ndo, tptr + 2))(ndo, " AS #%s, origin %s", as_printf(ndo, astostr, sizeof(astostr), EXTRACT_32BITS(tptr)), getname(ndo, tptr + 4))(ndo, " AS #%s, origin %s", as_printf(ndo, astostr, sizeof(astostr), ((uint32_t)(((uint32_t)(*((const uint8_t *)(tptr) + 0)) << 24) | ((uint32_t)(*((const uint8_t *)(tptr) + 1)) << 16) | ((uint32_t)(*((const uint8_t *)(tptr) + 2)) << 8) | ((uint32_t)(*((const uint8_t *)(tptr) + 3)) << 0)))), getname(ndo, tptr + 4))(ndo, " NO_EXPORT")(ndo, " NO_ADVERTISE")(ndo, " NO_EXPORT_SUBCONFED")(ndo, "%u:%u%s", (comm >> 16) & 0xffff, comm & 0xffff, (tlen>4) ? ", " : "")(ndo, "%s",getname(ndo, tptr))(ndo, "%s%s", getname(ndo, tptr), (tlen>4) ? ", " : "")(ndo, "\n\t    AFI: %s (%u), %sSAFI: %s (%u)", tok2strbuf(af_values, "Unknown AFI", af, tokbuf, sizeof(tokbuf)), af, (safi>128) ? "vendor specific " : "", tok2strbuf(bgp_safi_values, "Unknown SAFI", safi, tokbuf, sizeof(tokbuf)), safi)(ndo, "\n\t    no AFI %u / SAFI %u decoder", af, safi)(ndo, "\n\t    nexthop: ")(ndo, ", " )sizeof(struct in_addr)sizeof(struct in_addr)+BGP_VPN_RD_LENsizeof(struct in_addr)+8(ndo, "RD: %s, %s", bgp_vpn_rd_print(ndo, tptr), getname(ndo, tptr+BGP_VPN_RD_LEN))(ndo, "RD: %s, %s", bgp_vpn_rd_print(ndo, tptr), getname(ndo, tptr+8))(ndo, "%s", isonsap_string(tptr, tlen))(ndo, "RD: %s, %s", bgp_vpn_rd_print(ndo, tptr), isonsap_string(tptr+BGP_VPN_RD_LEN,tlen-BGP_VPN_RD_LEN))(ndo, "RD: %s, %s", bgp_vpn_rd_print(ndo, tptr), isonsap_string(tptr+8,tlen-8))tptr+BGP_VPN_RD_LENtptr+8(ndo, " = %s", getname(ndo, tptr+BGP_VPN_RD_LEN+4))(ndo, " = %s", getname(ndo, tptr+8+4))(ndo, "no AFI %u/SAFI %u decoder", af, safi)(ndo, ", nh-length: %u", nhlen)(ndo, "\n\t    %u SNPA", snpa)(ndo, "\n\t      %d bytes", tptr[0])(ndo, ", no SNPA")(ndo, "\n\t      %s", buf)(ndo, "\n\t    (illegal length)")BGP_MP_NLRI_MINSIZE(ndo, "\n\t      End-of-Rib Marker (empty NLRI)")*(tptr-3)(ndo, "no AFI %u / SAFI %u decoder", af, safi)(ndo, "\n\t    %s (0x%04x), Flags [%s]", tok2strbuf(bgp_extd_comm_subtype_values, "unknown extd community typecode", extd_comm, tokbuf, sizeof(tokbuf)), extd_comm, bittok2str(bgp_extd_comm_flag_values, "none", extd_comm))*(tptr+2)(ndo, ": %u:%u (= %s)", EXTRACT_16BITS(tptr+2), EXTRACT_32BITS(tptr+4), getname(ndo, tptr+4))(ndo, ": %u:%u (= %s)", ((uint16_t)(((uint16_t)(*((const uint8_t *)(tptr+2) + 0)) << 8) | ((uint16_t)(*((const uint8_t *)(tptr+2) + 1)) << 0))), ((uint32_t)(((uint32_t)(*((const uint8_t *)(tptr+4) + 0)) << 24) | ((uint32_t)(*((const uint8_t *)(tptr+4) + 1)) << 16) | ((uint32_t)(*((const uint8_t *)(tptr+4) + 2)) << 8) | ((uint32_t)(*((const uint8_t *)(tptr+4) + 3)) << 0))), getname(ndo, tptr+4))tptr+2tptr+4(ndo, ": %s:%u", getname(ndo, tptr+2), EXTRACT_16BITS(tptr+6))(ndo, ": %s:%u", getname(ndo, tptr+2), ((uint16_t)(((uint16_t)(*((const uint8_t *)(tptr+6) + 0)) << 8) | ((uint16_t)(*((const uint8_t *)(tptr+6) + 1)) << 0))))tptr+6(ndo, ": %s:%u", as_printf(ndo, astostr, sizeof(astostr), EXTRACT_32BITS(tptr+2)), EXTRACT_16BITS(tptr+6))(ndo, ": %s:%u", as_printf(ndo, astostr, sizeof(astostr), ((uint32_t)(((uint32_t)(*((const uint8_t *)(tptr+2) + 0)) << 24) | ((uint32_t)(*((const uint8_t *)(tptr+2) + 1)) << 16) | ((uint32_t)(*((const uint8_t *)(tptr+2) + 2)) << 8) | ((uint32_t)(*((const uint8_t *)(tptr+2) + 3)) << 0)))), ((uint16_t)(((uint16_t)(*((const uint8_t *)(tptr+6) + 0)) << 8) | ((uint16_t)(*((const uint8_t *)(tptr+6) + 1)) << 0))))(ndo, ": bandwidth: %.3f Mbps", bw.f*8/1000000)(ndo, "%s", getname(ndo, tptr+2))(ndo, ": area:%s, router-type:%s, metric-type:%s%s", getname(ndo, tptr+2), tok2strbuf(bgp_extd_comm_ospf_rtype_values, "unknown (0x%02x)", *(tptr+6), tokbuf, sizeof(tokbuf)), (*(tptr+7) & BGP_OSPF_RTYPE_METRIC_TYPE) ? "E2" : "", ((*(tptr+6) == BGP_OSPF_RTYPE_EXT) || (*(tptr+6) == BGP_OSPF_RTYPE_NSSA)) ? "E1" : "")(ndo, ": area:%s, router-type:%s, metric-type:%s%s", getname(ndo, tptr+2), tok2strbuf(bgp_extd_comm_ospf_rtype_values, "unknown (0x%02x)", *(tptr+6), tokbuf, sizeof(tokbuf)), (*(tptr+7) & 0x1) ? "E2" : "", ((*(tptr+6) == 5) || (*(tptr+6) == 7)) ? "E1" : "")(ndo, ": %s Control Flags [0x%02x]:MTU %u", tok2strbuf(l2vpn_encaps_values, "unknown encaps", *(tptr+2), tokbuf, sizeof(tokbuf)), *(tptr+3), EXTRACT_16BITS(tptr+4))(ndo, ": %s Control Flags [0x%02x]:MTU %u", tok2strbuf(l2vpn_encaps_values, "unknown encaps", *(tptr+2), tokbuf, sizeof(tokbuf)), *(tptr+3), ((uint16_t)(((uint16_t)(*((const uint8_t *)(tptr+4) + 0)) << 8) | ((uint16_t)(*((const uint8_t *)(tptr+4) + 1)) << 0))))(ndo, ": AS %u", EXTRACT_16BITS(tptr+2))(ndo, ": AS %u", ((uint16_t)(((uint16_t)(*((const uint8_t *)(tptr+2) + 0)) << 8) | ((uint16_t)(*((const uint8_t *)(tptr+2) + 1)) << 0))))(ndo, "\n\t    Tunnel-type %s (%u), Flags [%s], MPLS Label %u", tok2str(bgp_pmsi_tunnel_values, "Unknown", tunnel_type), tunnel_type, bittok2str(bgp_pmsi_flag_values, "none", flags), EXTRACT_24BITS(tptr+2)>>4)(ndo, "\n\t    Tunnel-type %s (%u), Flags [%s], MPLS Label %u", tok2str(bgp_pmsi_tunnel_values, "Unknown", tunnel_type), tunnel_type, bittok2str(bgp_pmsi_flag_values, "none", flags), ((uint32_t)(((uint32_t)(*((const uint8_t *)(tptr+2) + 0)) << 16) | ((uint32_t)(*((const uint8_t *)(tptr+2) + 1)) << 8) | ((uint32_t)(*((const uint8_t *)(tptr+2) + 2)) << 0)))>>4)(ndo, "\n\t      Sender %s, P-Group %s", ipaddr_string(ndo, tptr), ipaddr_string(ndo, tptr+4))(ndo, "\n\t      Sender %s, P-Group %s", getname(ndo, (const u_char *)(tptr)), getname(ndo, (const u_char *)(tptr+4)))(ndo, "\n\t      Root-Node %s, P-Group %s", ipaddr_string(ndo, tptr), ipaddr_string(ndo, tptr+4))(ndo, "\n\t      Root-Node %s, P-Group %s", getname(ndo, (const u_char *)(tptr)), getname(ndo, (const u_char *)(tptr+4)))(ndo, "\n\t      Tunnel-Endpoint %s", ipaddr_string(ndo, tptr))(ndo, "\n\t      Tunnel-Endpoint %s", getname(ndo, (const u_char *)(tptr)))(ndo, "\n\t      Root-Node %s, LSP-ID 0x%08x", ipaddr_string(ndo, tptr), EXTRACT_32BITS(tptr+4))(ndo, "\n\t      Root-Node %s, LSP-ID 0x%08x", getname(ndo, (const u_char *)(tptr)), ((uint32_t)(((uint32_t)(*((const uint8_t *)(tptr+4) + 0)) << 24) | ((uint32_t)(*((const uint8_t *)(tptr+4) + 1)) << 16) | ((uint32_t)(*((const uint8_t *)(tptr+4) + 2)) << 8) | ((uint32_t)(*((const uint8_t *)(tptr+4) + 3)) << 0))))(ndo, "\n\t      Extended-Tunnel-ID %s, P2MP-ID 0x%08x", ipaddr_string(ndo, tptr), EXTRACT_32BITS(tptr+4))(ndo, "\n\t      Extended-Tunnel-ID %s, P2MP-ID 0x%08x", getname(ndo, (const u_char *)(tptr)), ((uint32_t)(((uint32_t)(*((const uint8_t *)(tptr+4) + 0)) << 24) | ((uint32_t)(*((const uint8_t *)(tptr+4) + 1)) << 16) | ((uint32_t)(*((const uint8_t *)(tptr+4) + 2)) << 8) | ((uint32_t)(*((const uint8_t *)(tptr+4) + 3)) << 0))))(ndo, "\n\t    Origin AS: %s", as_printf(ndo, astostr, sizeof(astostr), EXTRACT_32BITS(tptr)))(ndo, "\n\t    Origin AS: %s", as_printf(ndo, astostr, sizeof(astostr), ((uint32_t)(((uint32_t)(*((const uint8_t *)(tptr) + 0)) << 24) | ((uint32_t)(*((const uint8_t *)(tptr) + 1)) << 16) | ((uint32_t)(*((const uint8_t *)(tptr) + 2)) << 8) | ((uint32_t)(*((const uint8_t *)(tptr) + 3)) << 0)))))(ndo, "\n\t      %s (%u), length: %u", tok2strbuf(bgp_attr_values, "Unknown Attribute", atype, tokbuf, sizeof(tokbuf)), atype, alen)(ndo, "\n\t    no Attribute %u decoder", atype)BGPTYPE_ORIGINinvalid lenUnknown Origin TypecodeBGPTYPE_AS4_PATHBGPTYPE_AS_PATHempty?BGPTYPE_NEXT_HOPBGPTYPE_MULTI_EXIT_DISCBGPTYPE_LOCAL_PREFBGPTYPE_ATOMIC_AGGREGATEBGPTYPE_AGGREGATOR AS #%s, origin %sBGPTYPE_AGGREGATOR4BGPTYPE_COMMUNITIEScomm4294967041BGP_COMMUNITY_NO_EXPORT NO_EXPORT4294967042BGP_COMMUNITY_NO_ADVERT NO_ADVERTISE4294967043BGP_COMMUNITY_NO_EXPORT_SUBCONFED NO_EXPORT_SUBCONFED%u:%u%sBGPTYPE_ORIGINATOR_IDBGPTYPE_CLUSTER_LISTBGPTYPE_MP_REACH_NLRI
	    AFI: %s (%u), %sSAFI: %s (%u)Unknown AFIvendor specific Unknown SAFISAFNUM_UNICAST(AFNUM_INET<<8 | SAFNUM_UNICAST)SAFNUM_MULTICAST(AFNUM_INET<<8 | SAFNUM_MULTICAST)SAFNUM_UNIMULTICAST(AFNUM_INET<<8 | SAFNUM_UNIMULTICAST)SAFNUM_LABUNICAST260(AFNUM_INET<<8 | SAFNUM_LABUNICAST)SAFNUM_RT_ROUTING_INFO388(AFNUM_INET<<8 | SAFNUM_RT_ROUTING_INFO)SAFNUM_VPNUNICAST(AFNUM_INET<<8 | SAFNUM_VPNUNICAST)SAFNUM_VPNMULTICAST385(AFNUM_INET<<8 | SAFNUM_VPNMULTICAST)SAFNUM_VPNUNIMULTICAST386(AFNUM_INET<<8 | SAFNUM_VPNUNIMULTICAST)SAFNUM_MULTICAST_VPN261(AFNUM_INET<<8 | SAFNUM_MULTICAST_VPN)SAFNUM_MDT322(AFNUM_INET<<8 | SAFNUM_MDT)768769(AFNUM_NSAP<<8 | SAFNUM_UNICAST)770(AFNUM_NSAP<<8 | SAFNUM_MULTICAST)771(AFNUM_NSAP<<8 | SAFNUM_UNIMULTICAST)896(AFNUM_NSAP<<8 | SAFNUM_VPNUNICAST)897(AFNUM_NSAP<<8 | SAFNUM_VPNMULTICAST)898(AFNUM_NSAP<<8 | SAFNUM_VPNUNIMULTICAST)5017650304(AFNUM_L2VPN<<8 | SAFNUM_VPNUNICAST)50305(AFNUM_L2VPN<<8 | SAFNUM_VPNMULTICAST)50306(AFNUM_L2VPN<<8 | SAFNUM_VPNUNIMULTICAST)6400SAFNUM_VPLS6465(AFNUM_VPLS<<8 | SAFNUM_VPLS)
	    no AFI %u / SAFI %u decoder
	    "\n\t    "nnh
	    nexthop: (int)sizeof(struct in_addr)BGP_VPN_RD_LEN(int)(sizeof(struct in_addr)+BGP_VPN_RD_LEN)RD: %s, %s(sizeof(struct in_addr)+BGP_VPN_RD_LEN)(sizeof(struct in_addr))11911838730x47000601 = %sno AFI %u/SAFI %u decoder, nh-length: %u
	    %u SNPA
	      %d bytes, no SNPA
	      %s517(AFNUM_INET6<<8 | SAFNUM_MULTICAST_VPN)
	    (illegal length)doneBGPTYPE_MP_UNREACH_NLRI
	      End-of-Rib Marker (empty NLRI)no AFI %u / SAFI %u decoderBGPTYPE_EXTD_COMMUNITIESextd_comm
	    %s (0x%04x), Flags [%s]unknown extd community typecodeBGP_EXT_COM_RT_0BGP_EXT_COM_RO_0BGP_EXT_COM_L2VPN_RT_0: %u:%u (= %s)BGP_EXT_COM_RT_1BGP_EXT_COM_RO_161706BGP_EXT_COM_L2VPN_RT_1267BGP_EXT_COM_VRF_RT_IMP: %s:%uBGP_EXT_COM_RT_2515BGP_EXT_COM_RO_216388BGP_EXT_COM_LINKBAND: bandwidth: %.3f Mbps8.010000001000000.0BGP_EXT_COM_VPN_ORIGINBGP_EXT_COM_VPN_ORIGIN2BGP_EXT_COM_VPN_ORIGIN332773BGP_EXT_COM_VPN_ORIGIN4BGP_EXT_COM_OSPF_RID32769BGP_EXT_COM_OSPF_RID2774BGP_EXT_COM_OSPF_RTYPEBGP_EXT_COM_OSPF_RTYPE2: area:%s, router-type:%s, metric-type:%s%sunknown (0x%02x)E2E132778BGP_EXT_COM_L2INFO: %s Control Flags [0x%02x]:MTU %uunknown encapsBGP_EXT_COM_SOURCE_AS: AS %u
	      "\n\t      "BGPTYPE_PMSI_TUNNELtunnel_type
	    Tunnel-type %s (%u), Flags [%s], MPLS Label %uconst tok[2]tok[2]BGP_PMSI_TUNNEL_PIM_SMBGP_PMSI_TUNNEL_PIM_BIDIR
	      Sender %s, P-Group %sBGP_PMSI_TUNNEL_PIM_SSM
	      Root-Node %s, P-Group %sBGP_PMSI_TUNNEL_INGRESS
	      Tunnel-Endpoint %sBGP_PMSI_TUNNEL_LDP_P2MPBGP_PMSI_TUNNEL_LDP_MP2MP
	      Root-Node %s, LSP-ID 0x%08xBGP_PMSI_TUNNEL_RSVP_P2MP
	      Extended-Tunnel-ID %s, P2MP-ID 0x%08xBGPTYPE_ATTR_SET
	    Origin AS: %s
	    no Attribute %u decoderbgp_attr_get_as_sizedecode_labeled_vpn_clnp_prefixuint8_t[19]unsigned char[19]plensizeof(pptr[0])24+64(24+64)0, sizeof(addr)uint8_t(*)[19]unsigned char(*)[19]pptr[12](plen + 7) / 8bgpa_type&pptr[12], (plen + 7) / 80xff00"RD: %s, %s/%d, label:%u %s", bgp_vpn_rd_print(ndo, pptr+4), isonsap_string(addr,(plen + 7) / 8), plen, EXTRACT_24BITS(pptr+1)>>4, ((pptr[3]&1)==0) ? "(BOGUS: Bottom of Stack NOT set!)" : "(bottom)""RD: %s, %s/%d, label:%u %s", bgp_vpn_rd_print(ndo, pptr+4), isonsap_string(addr,(plen + 7) / 8), plen, ((uint32_t)(((uint32_t)(*((const uint8_t *)(pptr+1) + 0)) << 16) | ((uint32_t)(*((const uint8_t *)(pptr+1) + 1)) << 8) | ((uint32_t)(*((const uint8_t *)(pptr+1) + 2)) << 0)))>>4, ((pptr[3]&1)==0) ? "(BOGUS: Bottom of Stack NOT set!)" : "(bottom)"RD: %s, %s/%d, label:%u %spptr+1(BOGUS: Bottom of Stack NOT set!)(bottom)decode_clnp_prefixpptr[4]&pptr[4], (plen + 7) / 8"%s/%d", isonsap_string(addr,(plen + 7) / 8), plen%s/%ddecode_labeled_vpn_l2strlentlv_typetlv_lenttlv_len"RD: %s, BGPNH: %s", bgp_vpn_rd_print(ndo, pptr), getname(ndo, pptr+8)"RD: %s, CE-ID: %u, Label-Block Offset: %u, Label Base %u", bgp_vpn_rd_print(ndo, pptr), EXTRACT_16BITS(pptr+8), EXTRACT_16BITS(pptr+10), EXTRACT_24BITS(pptr+12)>>4"RD: %s, CE-ID: %u, Label-Block Offset: %u, Label Base %u", bgp_vpn_rd_print(ndo, pptr), ((uint16_t)(((uint16_t)(*((const uint8_t *)(pptr+8) + 0)) << 8) | ((uint16_t)(*((const uint8_t *)(pptr+8) + 1)) << 0))), ((uint16_t)(((uint16_t)(*((const uint8_t *)(pptr+10) + 0)) << 8) | ((uint16_t)(*((const uint8_t *)(pptr+10) + 1)) << 0))), ((uint32_t)(((uint32_t)(*((const uint8_t *)(pptr+12) + 0)) << 16) | ((uint32_t)(*((const uint8_t *)(pptr+12) + 1)) << 8) | ((uint32_t)(*((const uint8_t *)(pptr+12) + 2)) << 0)))>>4pptr+8pptr+10pptr+12"\n\t\tcircuit status vector (%u) length: %u: 0x", tlv_type, tlv_len"%02x",*pptr++"\n\t\tunknown TLV #%u, length: %u", tlv_type, tlv_lenRD: %s, BGPNH: %sRD: %s, CE-ID: %u, Label-Block Offset: %u, Label Base %uchar[57]
		circuit status vector (%u) length: %u: 0x
		unknown TLV #%u, length: %udecode_multicast_vpnroute_typeroute_lengthaddr_lengthsg_length"Route-Type: %s (%u), length: %u", tok2str(bgp_multicast_vpn_route_type_values, "Unknown", route_type), route_type, route_lengthRoute-Type: %s (%u), length: %ubuf + offsetbuflen - offset", RD: %s, Originator %s", bgp_vpn_rd_print(ndo, pptr), bgp_vpn_ip_print(ndo, pptr + BGP_VPN_RD_LEN, (route_length - BGP_VPN_RD_LEN) << 3)", RD: %s, Originator %s", bgp_vpn_rd_print(ndo, pptr), bgp_vpn_ip_print(ndo, pptr + 8, (route_length - 8) << 3)BGP_VPN_RD_LEN + 48 + 4", RD: %s, Source-AS %s", bgp_vpn_rd_print(ndo, pptr), as_printf(ndo, astostr, sizeof(astostr), EXTRACT_32BITS(pptr + BGP_VPN_RD_LEN))", RD: %s, Source-AS %s", bgp_vpn_rd_print(ndo, pptr), as_printf(ndo, astostr, sizeof(astostr), ((uint32_t)(((uint32_t)(*((const uint8_t *)(pptr + 8) + 0)) << 24) | ((uint32_t)(*((const uint8_t *)(pptr + 8) + 1)) << 16) | ((uint32_t)(*((const uint8_t *)(pptr + 8) + 2)) << 8) | ((uint32_t)(*((const uint8_t *)(pptr + 8) + 3)) << 0))))pptr + BGP_VPN_RD_LENpptr + 8", RD: %s", bgp_vpn_rd_print(ndo, pptr)", Originator %s", bgp_vpn_ip_print(ndo, pptr, addr_length << 3)BGP_MULTICAST_VPN_ROUTE_TYPE_INTRA_AS_I_PMSI, RD: %s, Originator %sBGP_MULTICAST_VPN_ROUTE_TYPE_INTER_AS_I_PMSI, RD: %s, Source-AS %sBGP_MULTICAST_VPN_ROUTE_TYPE_S_PMSI, RD: %s, Originator %sBGP_MULTICAST_VPN_ROUTE_TYPE_SOURCE_ACTIVEBGP_MULTICAST_VPN_ROUTE_TYPE_SHARED_TREE_JOINBGP_MULTICAST_VPN_ROUTE_TYPE_SOURCE_TREE_JOINBGP_MULTICAST_VPN_ROUTE_TYPE_INTRA_AS_SEG_LEAFdecode_mdt_vpn_nlrirdvpn_ipMDT_VPN_NLRI_LEN"RD: %s, VPN IP Address: %s, MC Group Address: %s", bgp_vpn_rd_print(ndo, rd), ipaddr_string(ndo, vpn_ip), ipaddr_string(ndo, pptr)"RD: %s, VPN IP Address: %s, MC Group Address: %s", bgp_vpn_rd_print(ndo, rd), getname(ndo, (const u_char *)(vpn_ip)), getname(ndo, (const u_char *)(pptr))RD: %s, VPN IP Address: %s, MC Group Address: %sdecode_labeled_vpn_prefix4in_addr *"RD: %s, %s/%d, label:%u %s", bgp_vpn_rd_print(ndo, pptr+4), getname(ndo, (u_char *)&addr), plen, EXTRACT_24BITS(pptr+1)>>4, ((pptr[3]&1)==0) ? "(BOGUS: Bottom of Stack NOT set!)" : "(bottom)""RD: %s, %s/%d, label:%u %s", bgp_vpn_rd_print(ndo, pptr+4), getname(ndo, (u_char *)&addr), plen, ((uint32_t)(((uint32_t)(*((const uint8_t *)(pptr+1) + 0)) << 16) | ((uint32_t)(*((const uint8_t *)(pptr+1) + 1)) << 8) | ((uint32_t)(*((const uint8_t *)(pptr+1) + 2)) << 0)))>>4, ((pptr[3]&1)==0) ? "(BOGUS: Bottom of Stack NOT set!)" : "(bottom)"decode_rt_routing_inforoute_target&route_target0, sizeof(route_target)pptr[1]&pptr[1], (plen + 7) / 8"origin AS: %s, route target %s", as_printf(ndo, astostr, sizeof(astostr), EXTRACT_32BITS(pptr+1)), bgp_vpn_rd_print(ndo, (u_char *)&route_target)"origin AS: %s, route target %s", as_printf(ndo, astostr, sizeof(astostr), ((uint32_t)(((uint32_t)(*((const uint8_t *)(pptr+1) + 0)) << 24) | ((uint32_t)(*((const uint8_t *)(pptr+1) + 1)) << 16) | ((uint32_t)(*((const uint8_t *)(pptr+1) + 2)) << 8) | ((uint32_t)(*((const uint8_t *)(pptr+1) + 3)) << 0)))), bgp_vpn_rd_print(ndo, (u_char *)&route_target)origin AS: %s, route target %sbgp_vpn_rd_printsizeof("xxxxxxxxxx:xxxxx (xxx.xxx.xxx.xxx:xxxxx)")possizeof(rd) - (pos - rd)"%u:%u (= %u.%u.%u.%u)", EXTRACT_16BITS(pptr+2), EXTRACT_32BITS(pptr+4), *(pptr+4), *(pptr+5), *(pptr+6), *(pptr+7)"%u:%u (= %u.%u.%u.%u)", ((uint16_t)(((uint16_t)(*((const uint8_t *)(pptr+2) + 0)) << 8) | ((uint16_t)(*((const uint8_t *)(pptr+2) + 1)) << 0))), ((uint32_t)(((uint32_t)(*((const uint8_t *)(pptr+4) + 0)) << 24) | ((uint32_t)(*((const uint8_t *)(pptr+4) + 1)) << 16) | ((uint32_t)(*((const uint8_t *)(pptr+4) + 2)) << 8) | ((uint32_t)(*((const uint8_t *)(pptr+4) + 3)) << 0))), *(pptr+4), *(pptr+5), *(pptr+6), *(pptr+7)pptr+2pptr+4"%u.%u.%u.%u:%u", *(pptr+2), *(pptr+3), *(pptr+4), *(pptr+5), EXTRACT_16BITS(pptr+6)"%u.%u.%u.%u:%u", *(pptr+2), *(pptr+3), *(pptr+4), *(pptr+5), ((uint16_t)(((uint16_t)(*((const uint8_t *)(pptr+6) + 0)) << 8) | ((uint16_t)(*((const uint8_t *)(pptr+6) + 1)) << 0)))pptr+6"%s:%u (%u.%u.%u.%u:%u)", as_printf(ndo, astostr, sizeof(astostr), EXTRACT_32BITS(pptr+2)), EXTRACT_16BITS(pptr+6), *(pptr+2), *(pptr+3), *(pptr+4), *(pptr+5), EXTRACT_16BITS(pptr+6)"%s:%u (%u.%u.%u.%u:%u)", as_printf(ndo, astostr, sizeof(astostr), ((uint32_t)(((uint32_t)(*((const uint8_t *)(pptr+2) + 0)) << 24) | ((uint32_t)(*((const uint8_t *)(pptr+2) + 1)) << 16) | ((uint32_t)(*((const uint8_t *)(pptr+2) + 2)) << 8) | ((uint32_t)(*((const uint8_t *)(pptr+2) + 3)) << 0)))), ((uint16_t)(((uint16_t)(*((const uint8_t *)(pptr+6) + 0)) << 8) | ((uint16_t)(*((const uint8_t *)(pptr+6) + 1)) << 0))), *(pptr+2), *(pptr+3), *(pptr+4), *(pptr+5), ((uint16_t)(((uint16_t)(*((const uint8_t *)(pptr+6) + 0)) << 8) | ((uint16_t)(*((const uint8_t *)(pptr+6) + 1)) << 0)))"unknown RD format"%u:%u (= %u.%u.%u.%u)%u.%u.%u.%u:%u%s:%u (%u.%u.%u.%u:%u)unknown RD formatbgp_vpn_sg_printtotal_length(addr_length >> 3)", Source %s", bgp_vpn_ip_print(ndo, pptr, addr_length), Source %s", Group %s", bgp_vpn_ip_print(ndo, pptr, addr_length), Group %sbgp_vpn_ip_printsizeof("1234:5678:89ab:cdef:1234:5678:89ab:cdef")sizeof(addr)"%s", ipaddr_string(ndo, pptr)"%s", getname(ndo, (const u_char *)(pptr))"bogus address length %u", addr_lengthsizeof(struct in_addr) << 3(sizeof(struct in_addr) << 3)bogus address length %udecode_labeled_prefix4plenbytes&pptr[4], plenbytes"%s/%d, label:%u %s", getname(ndo, (u_char *)&addr), plen, EXTRACT_24BITS(pptr+1)>>4, ((pptr[3]&1)==0) ? "(BOGUS: Bottom of Stack NOT set!)" : "(bottom)""%s/%d, label:%u %s", getname(ndo, (u_char *)&addr), plen, ((uint32_t)(((uint32_t)(*((const uint8_t *)(pptr+1) + 0)) << 16) | ((uint32_t)(*((const uint8_t *)(pptr+1) + 1)) << 8) | ((uint32_t)(*((const uint8_t *)(pptr+1) + 2)) << 0)))>>4, ((pptr[3]&1)==0) ? "(BOGUS: Bottom of Stack NOT set!)" : "(bottom)"%s/%d, label:%u %sbadtlvdecode_prefix4&pptr[1], plenbytesitemlen"%s/%d", getname(ndo, (u_char *)&addr), plenas_printfstrsize"%u", asnum"%u.%u", asnum >> 16, asnum & 0xFFFF%u.%ubgp_route_refreshbgp_notificationbgp_optbgp_openfresafibgp_markerbgpn_minorbgpn_majorbgpn_typebgpn_lenbgpn_markerbgpopt_lenbgpopt_typebgpo_optlenbgpo_idbgpo_holdtimebgpo_myasbgpo_versionbgpo_typebgpo_lenbgpo_markerbgp_typebgp_lenIntra-AS I-PMSI"Intra-AS I-PMSI"Inter-AS I-PMSI"Inter-AS I-PMSI"S-PMSI"S-PMSI"Intra-AS Segment-Leaf"Intra-AS Segment-Leaf"Source-Active"Source-Active"Shared Tree Join"Shared Tree Join"Source Tree Join"Source Tree Join"bgp_multicast_vpn_route_type_valuesastostrBGP_OSPF_RTYPE_RTRRouter"Router"BGP_OSPF_RTYPE_NETNetwork"Network"BGP_OSPF_RTYPE_SUMSummary"Summary"BGP_OSPF_RTYPE_EXTExternal"External"BGP_OSPF_RTYPE_NSSANSSA External"NSSA External"BGP_OSPF_RTYPE_SHAMMPLS-VPN Sham"MPLS-VPN Sham"bgp_extd_comm_ospf_rtype_valuestarget"target"origin"origin"link-BW"link-BW"ospf-domain"ospf-domain"ospf-route-type"ospf-route-type"ospf-router-id"ospf-router-id"layer2-info"layer2-info"34816BGP_EXT_COM_EIGRP_GENeigrp-general-route (flag, tag)"eigrp-general-route (flag, tag)"34817BGP_EXT_COM_EIGRP_METRIC_AS_DELAYeigrp-route-metric (AS, delay)"eigrp-route-metric (AS, delay)"34818BGP_EXT_COM_EIGRP_METRIC_REL_NH_BWeigrp-route-metric (reliability, nexthop, bandwidth)"eigrp-route-metric (reliability, nexthop, bandwidth)"34819BGP_EXT_COM_EIGRP_METRIC_LOAD_MTUeigrp-route-metric (load, MTU)"eigrp-route-metric (load, MTU)"34820BGP_EXT_COM_EIGRP_EXT_REMAS_REMIDeigrp-external-route (remote-AS, remote-ID)"eigrp-external-route (remote-AS, remote-ID)"34821BGP_EXT_COM_EIGRP_EXT_REMPROTO_REMMETRICeigrp-external-route (remote-proto, remote-metric)"eigrp-external-route (remote-proto, remote-metric)"source-AS"source-AS"vrf-route-import"vrf-route-import"l2vpn-id"l2vpn-id"bgp_extd_comm_subtype_values0x8000vendor-specific"vendor-specific"0x4000non-transitive"non-transitive"bgp_extd_comm_flag_valuesSAFNUM_RESUnicast"Unicast"Multicast"Multicast"Unicast+Multicast"Unicast+Multicast"labeled Unicast"labeled Unicast"SAFNUM_TUNNELTunnel"Tunnel"MDT"MDT"labeled VPN Unicast"labeled VPN Unicast"labeled VPN Multicast"labeled VPN Multicast"labeled VPN Unicast+Multicast"labeled VPN Unicast+Multicast"Route Target Routing Information"Route Target Routing Information"Multicast VPN"Multicast VPN"bgp_safi_valuesLeaf Information required"Leaf Information required"bgp_pmsi_flag_valuesRSVP-TE P2MP LSP"RSVP-TE P2MP LSP"LDP P2MP LSP"LDP P2MP LSP"PIM-SSM Tree"PIM-SSM Tree"PIM-SM Tree"PIM-SM Tree"PIM-Bidir Tree"PIM-Bidir Tree"Ingress Replication"Ingress Replication"LDP MP2MP LSP"LDP MP2MP LSP"bgp_pmsi_tunnel_valuesIGP"IGP"Incomplete"Incomplete"bgp_origin_valuesInvalid Action Value"Invalid Action Value"Invalid Capability Length"Invalid Capability Length"Malformed Capability Value"Malformed Capability Value"Unsupported Capability Code"Unsupported Capability Code"bgp_notify_minor_cap_valuesMalformed Attribute List"Malformed Attribute List"Unrecognized Well-known Attribute"Unrecognized Well-known Attribute"Missing Well-known Attribute"Missing Well-known Attribute"Attribute Flags Error"Attribute Flags Error"Attribute Length Error"Attribute Length Error"Invalid ORIGIN Attribute"Invalid ORIGIN Attribute"AS Routing Loop"AS Routing Loop"Invalid NEXT_HOP Attribute"Invalid NEXT_HOP Attribute"Optional Attribute Error"Optional Attribute Error"Invalid Network Field"Invalid Network Field"Malformed AS_PATH"Malformed AS_PATH"bgp_notify_minor_update_valuesUnsupported Version Number"Unsupported Version Number"Bad Peer AS"Bad Peer AS"Bad BGP Identifier"Bad BGP Identifier"Unsupported Optional Parameter"Unsupported Optional Parameter"Authentication Failure"Authentication Failure"Unacceptable Hold Time"Unacceptable Hold Time"Capability Message Error"Capability Message Error"bgp_notify_minor_open_valuesConnection Not Synchronized"Connection Not Synchronized"Bad Message Length"Bad Message Length"Bad Message Type"Bad Message Type"bgp_notify_minor_msg_valuesMaximum Number of Prefixes Reached"Maximum Number of Prefixes Reached"Administratively Shutdown"Administratively Shutdown"Peer Unconfigured"Peer Unconfigured"Administratively Reset"Administratively Reset"Connection Rejected"Connection Rejected"Other Configuration Change"Other Configuration Change"Connection Collision Resolution"Connection Collision Resolution"bgp_notify_minor_cease_valuesMessage Header Error"Message Header Error"OPEN Message Error"OPEN Message Error"UPDATE Message Error"UPDATE Message Error"BGP_NOTIFY_MAJOR_HOLDTIMEHold Timer Expired"Hold Timer Expired"BGP_NOTIFY_MAJOR_FSMFinite State Machine Error"Finite State Machine Error"Cease"Cease"bgp_notify_major_valuesMultiprotocol Extensions"Multiprotocol Extensions"Route Refresh"Route Refresh"BGP_CAPCODE_ORFCooperative Route Filtering"Cooperative Route Filtering"Graceful Restart"Graceful Restart"32-Bit AS Number"32-Bit AS Number"BGP_CAPCODE_DYN_CAPDynamic Capability"Dynamic Capability"Route Refresh (Cisco)"Route Refresh (Cisco)"bgp_capcode_valuesAuthentication Information"Authentication Information"Capabilities Advertisement"Capabilities Advertisement"bgp_opt_valuesBGP_AS_SEQUENCE""BGP_AS_SET}"}"BGP_CONFED_AS_SEQUENCE")"BGP_CONFED_AS_SET})"})"bgp_as_path_segment_close_values{ "{ "( "( "({ "({ "bgp_as_path_segment_open_valuesOrigin"Origin"AS Path"AS Path"AS4 Path"AS4 Path"Next Hop"Next Hop"Multi Exit Discriminator"Multi Exit Discriminator"Local Preference"Local Preference"Atomic Aggregate"Atomic Aggregate"Aggregator"Aggregator"Aggregator4"Aggregator4"Community"Community"Originator ID"Originator ID"Cluster List"Cluster List"BGPTYPE_DPADPA"DPA"BGPTYPE_ADVERTISERSAdvertisers"Advertisers"BGPTYPE_RCID_PATHRCID Path / Cluster ID"RCID Path / Cluster ID"Multi-Protocol Reach NLRI"Multi-Protocol Reach NLRI"Multi-Protocol Unreach NLRI"Multi-Protocol Unreach NLRI"Extended Community"Extended Community"PMSI Tunnel"PMSI Tunnel"Attribute Set"Attribute Set"Reserved for development"Reserved for development"bgp_attr_valuesOpen"Open"Update"Update"Notification"Notification"Keepalive"Keepalive"bgp_msg_valuesUPDATE_BUF_BUFLEN(buf,buflen,strlen)if (strlen<0) buflen=0; else if ((u_int)strlen>buflen) buflen=0; else { buflen-=strlen; buf+=strlen; }ITEMCHECK(minlen)if (itemlen < minlen) goto badtlv;BGP_OSPF_RTYPE_METRIC_TYPE0x88050x88040x88030x88020x88010x88000xF10a0x800a0x80010x03060x80050x02050x01050x40040x02030x02020xffffff030xffffff020xffffff01BGP_AS_SEG_TYPE_MAXBGP_AS_SEG_TYPE_MINbgp_attr_len(flags,p)(((flags) & 0x10) ? EXTRACT_16BITS(p) : *(p))bgp_attr_lenlen(flags,p)(((flags) & 0x10) ? 2 : 1)/*
 * Local Variables:
 * c-style: whitesmith
 * c-basic-offset: 4
 * End:
 *//* found BGP header *//* lets be less chatty *//* we have no decoder for the BGP message *//* this stinks but the compiler pads the structure
			   * weird *//* some little sanity checking *//* draft-ietf-idr-cease-subcode-02 mentions optionally 7 bytes
             * for the maxprefix subtype, which may contain AFI, SAFI and MAXPREFIXES
             *//* bytes left, but not enough *//*
		 * XXX - what if they're using the "Advertisement of
		 * Multiple Paths in BGP" feature:
		 *
		 * https://datatracker.ietf.org/doc/draft-ietf-idr-add-paths/
		 *
		 * http://tools.ietf.org/html/draft-ietf-idr-add-paths-06
		 *//* do something more useful!*//* No withdrawn routes, no path attributes, no NLRI *//*
		 * Without keeping state from the original NLRI message,
		 * it's not possible to tell if this a v4 or v6 route,
		 * so only try to decode it if we're not v6 enabled.
	         *//* Unfeasible routes *//* now let's decode the options we know*//* ugly! *//*
                     * Extract the 4 byte AS number encoded.
                     *//* omit zero length attributes*//* we have no decoder for the attribute *//* FIXME check for recursion *//* 128 is meanwhile wellknown *//*nothing*//* rfc1888 mapped IPv6 address ? *//* rfc986 mapped IPv4 address ? *//*
                 * Depending on the AS encoded is of 2 bytes or of 4 bytes,
                 * the length of this PA can be either 6 bytes or 8 bytes.
                 *//*
                 * BGP updates exchanged between New speakers that support 4
                 * byte AS, ASs are always encoded in 4 bytes. There is no
                 * definitive way to find this, just by the packet's
                 * contents. So, check for packet's TLV's sanity assuming
                 * 2 bytes first, and it does not pass, assume that ASs are
                 * encoded in 4 bytes format and move on.
                 *//*
         * Process AS4 byte path and AS2 byte path attributes here.
         *//* copy buffer for bandwidth values *//*
     * We can come here, either we did not have enough data, or if we
     * try to decode 4 byte ASs in 2 byte format. Either way, return 4,
     * so that calller can try to decode each AS as of 4 bytes. If indeed
     * there was not enough data, it will crib and end the parse anyways.
     *//*
     * If we correctly reached end of the AS path attribute data content,
     * then most likely ASs were indeed encoded as 2 bytes.
     *//*
         * If we do not find a valid segment type, our guess might be wrong.
         *//*
     * Let us assume that ASs are of 2 bytes in size, and check if the AS-Path
     * TLV is good. If not, ask the caller to try with AS encoded as 4 bytes
     * each.
     *//*
     * If the path attribute is the optional AS4 path type, then we already
     * know, that ASs must be encoded in 4 byte format.
     *//*
 * bgp_attr_get_as_size
 *
 * Try to find the size of the ASs encoded in an as-path. It is not obvious, as
 * both Old speakers that do not support 4 byte AS, and the new speakers that do
 * support, exchange AS-Path with the same path-attribute type value 0x02.
 *//* the label may get offsetted by 4 bits so lets shift it right *//* adjust prefixlen - labellength - RD len*//* get prefix length *//* adjust prefixlen - labellength *//* prefix length and label = 4 bytes *//* complain bitterly ? *//* the tlv-length is expressed in bits so lets shift it right *//* how many bytes do we need to read ? *//* ok now the variable part - lets read out TLVs*//* the label is offsetted by 4 bits so lets shift it right *//* RD, ID, LBLKOFF, LBLBASE *//* assume old format *//* need something like getname(ndo, ) here *//* assume AD-only with RD, BGPNH *//* Old and new L2VPN NLRI share AFI/SAFI
         *   -> Assume a 12 Byte-length NLRI is auto-discovery-only
         *      and > 17 as old format. Complain for the middle case
         *//*
 * As I remember, some versions of systems have an snprintf() that
 * returns -1 if the buffer would have overflowed.  If the return
 * value is negative, set buflen to 0, to indicate that we've filled
 * the buffer up.
 *
 * If the return value is greater than buflen, that means that
 * the buffer would have overflowed; again, set buflen to 0 in
 * that case.
 *//*
             * no per route-type printing yet.
             *//* MDT Group Address *//* RD *//* if the NLRI is not predefined length, quit.*//*
 * +-------------------------------+
 * |                               |
 * |  RD:IPv4-address (12 octets)  |
 * |                               |
 * +-------------------------------+
 * |  MDT Group-address (4 octets) |
 * +-------------------------------+
 *//* adjust prefix length *//* default route target *//* 4-byte-AS:number fmt*//* IP-address:AS fmt*//* 2-byte-AS:number fmt*//* ok lets load the RD format *//* allocate space for the largest possible string *//* RDs and RTs share the same semantics
 * we use bgp_vpn_rd_print for
 * printing route targets inside a NLRI *//* Group address *//* Group address length, encoded in bits *//* Source address *//* Source address length, encoded in bits *//*
 * bgp_vpn_sg_print
 *
 * print an multicast s,g entry into a buffer.
 * the s,g entry is encoded like this.
 *
 * +-----------------------------------+
 * | Multicast Source Length (1 octet) |
 * +-----------------------------------+
 * |   Multicast Source (Variable)     |
 * +-----------------------------------+
 * |  Multicast Group Length (1 octet) |
 * +-----------------------------------+
 * |  Multicast Group   (Variable)     |
 * +-----------------------------------+
 *
 * return the number of bytes read from the wire.
 *//* 128 *//* worst case string is s fully formatted v6 address *//*
 * bgp_vpn_ip_print
 *
 * print an ipv4 or ipv6 address into a buffer dependend on address length.
 *//* this is one of the weirdnesses of rfc3107
           the label length (actually the label + COS bits)
           is added to the prefix length;
           we also do only read out just one label -
           there is no real application for advertisement of
           stacked labels in a a single BGP message
        *//*
 * as_printf
 *
 * Convert an AS number into a string and return string pointer.
 *
 * Depending on bflag is set or not, AS number is converted into ASDOT notation
 * or plain number notation.
 *
 *//* LSB of RTYPE Options Field *//* OSPF-MPLS-VPN Sham link *//* OSPF NSSA External*//* OSPF External LSA, note that ASBR doesn't apply to MPLS-VPN *//* OSPF Summary LSA *//* OSPF Network LSA *//* OSPF Router LSA *//* OSPF codes for  BGP_EXT_COM_OSPF_RTYPE draft-rosen-vpns-ospf-bgp-mpls  *//* http://www.cisco.com/en/US/tech/tk436/tk428/technologies_tech_note09186a00801eb09a.shtml  *//* L2VPN Identifier,Format IP address:AN(2bytes) *//* L2VPN Identifier,Format AS(2bytes):AN(4bytes) *//* RFC-ietf-l3vpn-2547bis-mcast-bgp-08.txt *//* duplicate - keep for backwards compatability *//* OSPF Router ID,Format RouterID(4B):Unused(2B) *//* OSPF Route Type,Format Area(4B):RouteType(1B):Options(1B) *//* OSPF Domain ID / VPN of Origin  - draft-rosen-vpns-ospf-bgp-mpls *//* rfc2547 bgp-mpls-vpns *//* Link Bandwidth,Format AS(2B):Bandwidth(4B) *//* Route Origin,Format AN(4bytes):local(2bytes) *//* Route Origin,Format IP address:AN(2bytes) *//* Route Origin,Format AS(2bytes):AN(4bytes) *//* Route Target,Format AN(4bytes):local(2bytes) *//* Route Target,Format IP address:AN(2bytes) *//* Route Target,Format AS(2bytes):AN(4bytes) *//* Extended community type - draft-ietf-idr-bgp-ext-communities-05 *//* well-known community *//* draft-marques-ppvpn-rt-constrain-01.txt *//* Section 4.3.4 of draft-rosen-rfc2547bis-03.txt  *//* draft-nalawade-idr-mdt-safi-03 *//* XXX *//* draft-ietf-l3vpn-2547bis-mcast-bgp-02.txt *//* labeled BGP RFC3107 *//* Subsequent address family identifier, RFC2283 section 7 *//* draft-ietf-idr-cease-subcode-02 *//* draft-ietf-idr-restart-05  *//* draft-ietf-idr-rfc3065bis-01  *//* draft-ietf-idr-rfc3065bis-01 *//* End of RIB Marker detection *//* draft-marques-ppvpn-ibgp *//* RFC4893 *//* draft-ietf-idr-bgp-ext-communities *//* RFC2283 *//* RFC1863 *//* draft-ietf-idr-bgp-dpa *//* RFC1998 *//* RFC1997 *//* EXTRACT_16BITS(&bgp_route_refresh->afi) (sigh)      *//* afi should be int16 - so we have to access it using *//* when doing misaligned sequences of int8 and int16   *//* the compiler messes this structure up               *//* unaligned *//* some compilers may pad to 4 bytes *//* variable length *//* options should follow *//*
 * Copyright (C) 1999 WIDE Project.
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. Neither the name of the project nor the names of its contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE PROJECT AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE PROJECT OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 *
 * Extensively modified by Hannes Gredler (hannes@juniper.net) for more
 * complete BGP support.
 */asnum/Users/owura/Repos/codeql_eval/proj_repos/the-tcpdump-group-tcpdump-commit-0f95d441e4b5d7512cc5c326c8668a120e048eda/tcpdump/print-bootp.cclient_fqdn_flags8+1CLIENT_FQDN_FLAGS_S'S'CLIENT_FQDN_FLAGS_O'O'CLIENT_FQDN_FLAGS_E'E'CLIENT_FQDN_FLAGS_N'N'cmu_printconst cmu_vendconst cmu_vend *cmu_vend *cmu(ndo, " vend-cmu") vend-cmucmu->v_flagssizeof(cmu->v_flags)(ndo, " F:0x%x", cmu->v_flags)VF_SMASK(VF_SMASK)4294967294~(VF_SMASK) F:0x%xv_dgate"DG"cmu->v_dgatesizeof(cmu->v_dgate)const in_addrconst in_addr *(ndo, " %s:%s", "DG", ipaddr_string(ndo, &cmu->v_dgate.s_addr))(ndo, " %s:%s", "DG", getname(ndo, (const u_char *)(&cmu->v_dgate.s_addr)))&cmu->v_dgate.s_addr %s:%sDGconst in_addr_tconst in_addr_t *v_smaskcmu->v_flags & VF_SMASK ? "SM" : "SM*"cmu->v_flags & 1 ? "SM" : "SM*"cmu->v_smasksizeof(cmu->v_smask)(ndo, " %s:%s", cmu->v_flags & 1 ? "SM" : "SM*", ipaddr_string(ndo, &cmu->v_smask.s_addr))(ndo, " %s:%s", cmu->v_flags & 1 ? "SM" : "SM*", getname(ndo, (const u_char *)(&cmu->v_smask.s_addr)))&cmu->v_smask.s_addrSMSM*v_dns1"NS1"cmu->v_dns1sizeof(cmu->v_dns1)(ndo, " %s:%s", "NS1", ipaddr_string(ndo, &cmu->v_dns1.s_addr))(ndo, " %s:%s", "NS1", getname(ndo, (const u_char *)(&cmu->v_dns1.s_addr)))&cmu->v_dns1.s_addrNS1v_dns2"NS2"cmu->v_dns2sizeof(cmu->v_dns2)(ndo, " %s:%s", "NS2", ipaddr_string(ndo, &cmu->v_dns2.s_addr))(ndo, " %s:%s", "NS2", getname(ndo, (const u_char *)(&cmu->v_dns2.s_addr)))&cmu->v_dns2.s_addrNS2v_ins1"IEN1"cmu->v_ins1sizeof(cmu->v_ins1)(ndo, " %s:%s", "IEN1", ipaddr_string(ndo, &cmu->v_ins1.s_addr))(ndo, " %s:%s", "IEN1", getname(ndo, (const u_char *)(&cmu->v_ins1.s_addr)))&cmu->v_ins1.s_addrIEN1v_ins2"IEN2"cmu->v_ins2sizeof(cmu->v_ins2)(ndo, " %s:%s", "IEN2", ipaddr_string(ndo, &cmu->v_ins2.s_addr))(ndo, " %s:%s", "IEN2", getname(ndo, (const u_char *)(&cmu->v_ins2.s_addr)))&cmu->v_ins2.s_addrIEN2v_ts1"TS1"cmu->v_ts1sizeof(cmu->v_ts1)(ndo, " %s:%s", "TS1", ipaddr_string(ndo, &cmu->v_ts1.s_addr))(ndo, " %s:%s", "TS1", getname(ndo, (const u_char *)(&cmu->v_ts1.s_addr)))&cmu->v_ts1.s_addrTS1v_ts2"TS2"cmu->v_ts2sizeof(cmu->v_ts2)(ndo, " %s:%s", "TS2", ipaddr_string(ndo, &cmu->v_ts2.s_addr))(ndo, " %s:%s", "TS2", getname(ndo, (const u_char *)(&cmu->v_ts2.s_addr)))&cmu->v_ts2.s_addrTS2rfc1048_printtagulusucsuboptsuboptlen(ndo, "\n\t  Vendor-rfc1048 Extensions")
	  Vendor-rfc1048 Extensions(ndo, "\n\t    Magic Cookie 0x%08x", EXTRACT_32BITS(bp))(ndo, "\n\t    Magic Cookie 0x%08x", ((uint32_t)(((uint32_t)(*((const uint8_t *)(bp) + 0)) << 24) | ((uint32_t)(*((const uint8_t *)(bp) + 1)) << 16) | ((uint32_t)(*((const uint8_t *)(bp) + 2)) << 8) | ((uint32_t)(*((const uint8_t *)(bp) + 3)) << 0))))
	    Magic Cookie 0x%08xsizeof(int32_t)*bp*(bp + 1)bp + 1(ndo, "\n\t    %s Option %u, length %u%s", cp, tag, len, len > 0 ? ": " : "")(ndo, ", occurs %u", ntag)(ndo, "[|rfc1048 %u]", len)(ndo, "%s", tok2str(dhcp_msg_values, "Unknown (%u)", uc))(ndo, "\n\t      ")(ndo, ", ")(ndo, "%s", cp + 1)(ndo, "+")(ndo, ",")(ndo, "%s", ipaddr_string(ndo, &ul))(ndo, "%s", getname(ndo, (const u_char *)(&ul)))&ul(ndo, "%d", ul)(ndo, "%u", ul)(char *)&ul(const char *)bp, sizeof(ul)(ndo, "(%s:", ipaddr_string(ndo, &ul))(ndo, "(%s:", getname(ndo, (const u_char *)(&ul)))(ndo, "%s)", ipaddr_string(ndo, &ul))(ndo, "%s)", getname(ndo, (const u_char *)(&ul)))(ndo, "%u", us)(ndo, "N")(ndo, "Y")(ndo, "%u?", *bp)(ndo, c == 'x' ? ":" : ".")(ndo, "%02x", *bp)(ndo, "%u", *bp)(ndo, "ERROR: option %u len %u < 1 bytes", TAG_NETBIOS_NODE, len)(ndo, "ERROR: option %u len %u < 1 bytes", ((uint8_t) 46), len)(ndo, "%s", tok2str(nbo2str, NULL, tag))(ndo, "%s", tok2str(nbo2str, ((void *)0), tag))(ndo, "ERROR: option %u len %u < 1 bytes", TAG_OPT_OVERLOAD, len)(ndo, "ERROR: option %u len %u < 1 bytes", ((uint8_t) 52), len)(ndo, "%s", tok2str(oo2str, NULL, tag))(ndo, "%s", tok2str(oo2str, ((void *)0), tag))(ndo, "ERROR: option %u len %u < 3 bytes", TAG_CLIENT_FQDN, len)(ndo, "ERROR: option %u len %u < 3 bytes", ((uint8_t) 81), len)(ndo, "[%s] ", client_fqdn_flags(*bp))(ndo, "%u/%u ", *bp, *(bp+1))(ndo, "ERROR: option %u len %u < 1 bytes", TAG_CLIENT_ID, len)(ndo, "ERROR: option %u len %u < 1 bytes", ((uint8_t) 61), len)(ndo, "%s ", tok2str(arp2str, "hardware-type %u,", type))(ndo, "\n\t      %s SubOption %u, length %u: length goes past end of option", tok2str(agent_suboption_values, "Unknown", subopt), subopt, suboptlen)(ndo, "\n\t      %s SubOption %u, length %u: ", tok2str(agent_suboption_values, "Unknown", subopt), subopt, suboptlen)(ndo, "ERROR: option %u len %u < 5 bytes", TAG_CLASSLESS_STATIC_RT, len)(ndo, "ERROR: option %u len %u < 5 bytes", ((uint8_t) 121), len)(ndo, "[ERROR: Mask width (%d) > 32]", mask_width)(ndo, "[ERROR: Remaining length (%u) < %u bytes]", len, significant_octets + 4)(ndo, "(")(ndo, "default")(ndo, "%d", *bp++)(ndo, ".0")(ndo, "/%d", mask_width)(ndo, ":%s)", ipaddr_string(ndo, &ul))(ndo, ":%s)", getname(ndo, (const u_char *)(&ul)))(ndo, "[unknown special tag %u, size %u]", tag, len)(ndo, "\n\t  trailing data length %u", len)TAG_PADTAG_ENDTAG_EXTENDED_OPTIONconst tok[1]tok[1]?xT%u"?xT%u"const tok[108]tok[108]?T%u"?T%u"
	    %s Option %u, length %u%sntag, occurs %u[|rfc1048 %u]TAG_DHCP_MESSAGETAG_PARM_REQUEST?Option %u"?Option %u"TAG_EXTENDED_REQUEST+'?''b''s''l''a''i''L'sizeof(ul),'p'2*sizeof(ul)(%s:%s)sizeof(us)'B'NY%u?'x''$'TAG_NETBIOS_NODEERROR: option %u len %u < 1 bytesTAG_OPT_OVERLOADTAG_CLIENT_FQDNERROR: option %u len %u < 3 bytes[%s] %u/%u TAG_CLIENT_IDhardware-type %u,TAG_AGENT_CIRCUIT
	      %s SubOption %u, length %u: length goes past end of option
	      %s SubOption %u, length %u: AGENT_SUBOPTION_CIRCUIT_IDAGENT_SUBOPTION_REMOTE_IDAGENT_SUBOPTION_SUBSCRIBER_IDTAG_CLASSLESS_STATIC_RT249TAG_CLASSLESS_STA_RT_MSmask_widthsignificant_octetsERROR: option %u len %u < 5 bytes[ERROR: Mask width (%d) > 32][ERROR: Remaining length (%u) < %u bytes](default.0/%d:%s)[unknown special tag %u, size %u]
	  trailing data length %u(ndo, "|[rfc1048]")|[rfc1048]bootp_printconst bootpconst bootp *bootp *const u_char[4]vm_cmuCMUVM_CMUvm_rfc1048bp->bp_opsizeof(bp->bp_op)(ndo, "BOOTP/DHCP, %s", tok2str(bootp_op_values, "unknown (0x%02x)", bp->bp_op))BOOTP/DHCP, %sbp->bp_chaddr[0](ndo, " from %s", etheraddr_string(ndo, bp->bp_chaddr))BOOTPREQUEST from %sbp->bp_secssizeof(bp->bp_secs)(ndo, ", htype %d", bp->bp_htype), htype %d(ndo, ", hlen %d", bp->bp_hlen), hlen %d(ndo, ", hops %d", bp->bp_hops), hops %d&bp->bp_xid(ndo, ", xid 0x%x", EXTRACT_32BITS(&bp->bp_xid))(ndo, ", xid 0x%x", ((uint32_t)(((uint32_t)(*((const uint8_t *)(&bp->bp_xid) + 0)) << 24) | ((uint32_t)(*((const uint8_t *)(&bp->bp_xid) + 1)) << 16) | ((uint32_t)(*((const uint8_t *)(&bp->bp_xid) + 2)) << 8) | ((uint32_t)(*((const uint8_t *)(&bp->bp_xid) + 3)) << 0)))), xid 0x%x&bp->bp_secs(ndo, ", secs %d", EXTRACT_16BITS(&bp->bp_secs))(ndo, ", secs %d", ((uint16_t)(((uint16_t)(*((const uint8_t *)(&bp->bp_secs) + 0)) << 8) | ((uint16_t)(*((const uint8_t *)(&bp->bp_secs) + 1)) << 0)))), secs %d(ndo, ", Flags [%s]", bittok2str(bootp_flag_values, "none", EXTRACT_16BITS(&bp->bp_flags)))(ndo, ", Flags [%s]", bittok2str(bootp_flag_values, "none", ((uint16_t)(((uint16_t)(*((const uint8_t *)(&bp->bp_flags) + 0)) << 8) | ((uint16_t)(*((const uint8_t *)(&bp->bp_flags) + 1)) << 0))))), Flags [%s]&bp->bp_flags(ndo, " (0x%04x)", EXTRACT_16BITS(&bp->bp_flags))(ndo, " (0x%04x)", ((uint16_t)(((uint16_t)(*((const uint8_t *)(&bp->bp_flags) + 0)) << 8) | ((uint16_t)(*((const uint8_t *)(&bp->bp_flags) + 1)) << 0)))) (0x%04x)bp->bp_ciaddrsizeof(bp->bp_ciaddr)&bp->bp_ciaddr.s_addr(ndo, "\n\t  Client-IP %s", ipaddr_string(ndo, &bp->bp_ciaddr))(ndo, "\n\t  Client-IP %s", getname(ndo, (const u_char *)(&bp->bp_ciaddr)))&bp->bp_ciaddr
	  Client-IP %sbp->bp_yiaddrsizeof(bp->bp_yiaddr)&bp->bp_yiaddr.s_addr(ndo, "\n\t  Your-IP %s", ipaddr_string(ndo, &bp->bp_yiaddr))(ndo, "\n\t  Your-IP %s", getname(ndo, (const u_char *)(&bp->bp_yiaddr)))&bp->bp_yiaddr
	  Your-IP %sbp->bp_siaddrsizeof(bp->bp_siaddr)&bp->bp_siaddr.s_addr(ndo, "\n\t  Server-IP %s", ipaddr_string(ndo, &bp->bp_siaddr))(ndo, "\n\t  Server-IP %s", getname(ndo, (const u_char *)(&bp->bp_siaddr)))&bp->bp_siaddr
	  Server-IP %sbp->bp_giaddrsizeof(bp->bp_giaddr)&bp->bp_giaddr.s_addr(ndo, "\n\t  Gateway-IP %s", ipaddr_string(ndo, &bp->bp_giaddr))(ndo, "\n\t  Gateway-IP %s", getname(ndo, (const u_char *)(&bp->bp_giaddr)))&bp->bp_giaddr
	  Gateway-IP %s(ndo, "\n\t  Client-Ethernet-Address %s", etheraddr_string(ndo, bp->bp_chaddr))
	  Client-Ethernet-Address %sbp->bp_sname[0]uint8_t[64]unsigned char[64](ndo, "\n\t  sname \"")(ndo, "%s", tstr + 1)
	  sname "bp->bp_file[0]uint8_t[128]unsigned char[128](ndo, "\n\t  file \"")
	  file "bp->bp_vend[0]sizeof(bp->bp_vend[0])&bp->bp_vend(ndo, "\n\t  Vendor-#0x%x", ul)sizeof(uint32_t)const uint8_t[64]const uint8_t(*)[64]unsigned char(*)[64]
	  Vendor-#0x%xcmu_vendpackedbootpuint8_t[24]unsigned char[24]v_unusedv_flagsv_magicbp_vendbp_filebp_snamebp_chaddrbp_giaddrbp_siaddrbp_yiaddrbp_ciaddrbp_flagsbp_secsbp_xidbp_hopsbp_hlenbp_htypebp_opCircuit-ID"Circuit-ID"Remote-ID"Remote-ID"Subscriber-ID"Subscriber-ID"agent_suboption_valuesDHCPDISCOVERDHCPOFFERDHCPREQUESTDHCPDECLINEDecline"Decline"DHCPACKDHCPNAKNACK"NACK"DHCPRELEASEDHCPINFORMInform"Inform"dhcp_msg_valuesether"ether"ieee802"ieee802"arcnet"arcnet"frelay"frelay"strip"strip"ieee1394"ieee1394"arp2strb-node"b-node"p-node"p-node"m-node"m-node"h-node"h-node"nbo2strfile"file"sname"sname"file+sname"file+sname"oo2strxtag2str PAD" PAD"TAG_SUBNET_MASKiSubnet-Mask"iSubnet-Mask"TAG_TIME_OFFSETLTime-Zone"LTime-Zone"TAG_GATEWAYiDefault-Gateway"iDefault-Gateway"TAG_TIME_SERVERiTime-Server"iTime-Server"TAG_NAME_SERVERiIEN-Name-Server"iIEN-Name-Server"TAG_DOMAIN_SERVERiDomain-Name-Server"iDomain-Name-Server"TAG_LOG_SERVERiLOG"iLOG"TAG_COOKIE_SERVERiCS"iCS"TAG_LPR_SERVERiLPR-Server"iLPR-Server"TAG_IMPRESS_SERVERiIM"iIM"TAG_RLP_SERVERiRL"iRL"TAG_HOSTNAMEaHostname"aHostname"TAG_BOOTSIZEsBS"sBS" END" END"TAG_DUMPPATHaDP"aDP"TAG_DOMAINNAMEaDomain-Name"aDomain-Name"TAG_SWAP_SERVERiSS"iSS"TAG_ROOTPATHaRP"aRP"TAG_EXTPATHaEP"aEP"TAG_IP_FORWARDBIPF"BIPF"TAG_NL_SRCRTBSRT"BSRT"TAG_PFILTERSpPF"pPF"TAG_REASS_SIZEsRSZ"sRSZ"TAG_DEF_TTLbTTL"bTTL"TAG_MTU_TIMEOUTlMTU-Timeout"lMTU-Timeout"TAG_MTU_TABLEsMTU-Table"sMTU-Table"TAG_INT_MTUsMTU"sMTU"TAG_LOCAL_SUBNETSBLSN"BLSN"TAG_BROAD_ADDRiBR"iBR"TAG_DO_MASK_DISCBMD"BMD"TAG_SUPPLY_MASKBMS"BMS"TAG_DO_RDISCBRouter-Discovery"BRouter-Discovery"TAG_RTR_SOL_ADDRiRSA"iRSA"TAG_STATIC_ROUTEpStatic-Route"pStatic-Route"TAG_USE_TRAILERSBUT"BUT"TAG_ARP_TIMEOUTlAT"lAT"TAG_ETH_ENCAPBIE"BIE"TAG_TCP_TTLbTT"bTT"TAG_TCP_KEEPALIVElKI"lKI"TAG_KEEPALIVE_GOBKG"BKG"TAG_NIS_DOMAINaYD"aYD"TAG_NIS_SERVERSiYS"iYS"TAG_NTP_SERVERSiNTP"iNTP"TAG_VENDOR_OPTSbVendor-Option"bVendor-Option"TAG_NETBIOS_NSiNetbios-Name-Server"iNetbios-Name-Server"TAG_NETBIOS_DDSiWDD"iWDD"$Netbios-Node"$Netbios-Node"TAG_NETBIOS_SCOPEaNetbios-Scope"aNetbios-Scope"TAG_XWIN_FSiXFS"iXFS"TAG_XWIN_DMiXDM"iXDM"TAG_NIS_P_DOMAINsN+D"sN+D"TAG_NIS_P_SERVERSiN+S"iN+S"TAG_MOBILE_HOMEiMH"iMH"TAG_SMPT_SERVERiSMTP"iSMTP"TAG_POP3_SERVERiPOP3"iPOP3"TAG_NNTP_SERVERiNNTP"iNNTP"TAG_WWW_SERVERiWWW"iWWW"TAG_FINGER_SERVERiFG"iFG"TAG_IRC_SERVERiIRC"iIRC"TAG_STREETTALK_SRVRiSTS"iSTS"TAG_STREETTALK_STDAiSTDA"iSTDA"TAG_REQUESTED_IPiRequested-IP"iRequested-IP"TAG_IP_LEASElLease-Time"lLease-Time"$OO"$OO"TAG_TFTP_SERVERaTFTP"aTFTP"TAG_BOOTFILENAMEaBF"aBF" DHCP-Message" DHCP-Message"TAG_SERVER_IDiServer-ID"iServer-ID"bParameter-Request"bParameter-Request"TAG_MESSAGEaMSG"aMSG"TAG_MAX_MSG_SIZEsMSZ"sMSZ"TAG_RENEWAL_TIMElRN"lRN"TAG_REBIND_TIMElRB"lRB"TAG_VENDOR_CLASSaVendor-Class"aVendor-Class"$Client-ID"$Client-ID"TAG_OPEN_GROUP_UAPaUAP"aUAP"TAG_DISABLE_AUTOCONFBNOAUTO"BNOAUTO"TAG_SLP_DAbSLP-DA"bSLP-DA"TAG_SLP_SCOPEbSLP-SCOPE"bSLP-SCOPE"TAG_NS_SEARCHsNSSEARCH"sNSSEARCH"TAG_IP4_SUBNET_SELECTiSUBNET"iSUBNET"$Classless-Static-Route"$Classless-Static-Route"$Classless-Static-Route-Microsoft"$Classless-Static-Route-Microsoft"TAG_USER_CLASSaCLASS"aCLASS"TAG_SLP_NAMING_AUTHaSLP-NA"aSLP-NA"$FQDN"$FQDN"$Agent-Information"$Agent-Information"TAG_AGENT_REMOTEbARMT"bARMT"TAG_AGENT_MASKbAMSK"bAMSK"TAG_TZ_STRINGaTZSTR"aTZSTR"TAG_FQDN_OPTIONbFQDNS"bFQDNS"TAG_AUTHbAUTH"bAUTH"TAG_VINES_SERVERSiVINES"iVINES"TAG_SERVER_RANKsRANK"sRANK"TAG_CLIENT_ARCHsARCH"sARCH"TAG_CLIENT_NDIbNDI"bNDI"TAG_CLIENT_GUIDbGUID"bGUID"TAG_LDAP_URLaLDAP"aLDAP"TAG_6OVER4i6o4"i6o4"TAG_PRINTER_NAMEaPRTR"aPRTR"TAG_MDHCP_SERVERbMDHCP"bMDHCP"TAG_IPX_COMPATbIPX"bIPX"TAG_NETINFO_PARENTiNI"iNI"TAG_NETINFO_PARENT_TAGaNITAG"aNITAG"TAG_URLaURL"aURL"TAG_FAILOVERbFAIL"bFAIL"tag2strBOOTPREPLYbootp_op_valuesbootp_flag_values [|bootp]" [|bootp]"PRINTCMUADDRPRINTCMUADDR(m,s){ ND_TCHECK(cmu->m); if (cmu->m.s_addr != 0) ND_PRINT((ndo, " %s:%s", s, ipaddr_string(ndo, &cmu->m.s_addr))); }((uint8_t) 127)((uint8_t) 126)((uint8_t) 115)((uint8_t) 114)((uint8_t) 113)((uint8_t) 112)((uint8_t) 110)((uint8_t) 101)((uint8_t) 100)((uint8_t) 96)((uint8_t) 95)((uint8_t) 97)((uint8_t) 94)((uint8_t) 93)((uint8_t) 92)((uint8_t) 91)((uint8_t) 90)((uint8_t) 89)((uint8_t) 88)((uint8_t) 84)((uint8_t) 83)((uint8_t) 82)((uint8_t) 81)((uint8_t) 80)((uint8_t) 77)((uint8_t) 249)((uint8_t) 121)((uint8_t) 118)((uint8_t) 117)((uint8_t) 79)((uint8_t) 78)((uint8_t) 116)((uint8_t) 98)TAG_NDS_IPINFO((uint8_t) 63)TAG_NDS_IPDOMAIN((uint8_t) 62)TAG_NDS_CONTEXT((uint8_t) 87)TAG_NDS_TREE_NAME((uint8_t) 86)TAG_NDS_SERVERS((uint8_t) 85)((uint8_t) 61)((uint8_t) 60)((uint8_t) 59)((uint8_t) 58)((uint8_t) 57)((uint8_t) 56)((uint8_t) 55)((uint8_t) 54)((uint8_t) 53)((uint8_t) 67)((uint8_t) 66)((uint8_t) 52)((uint8_t) 51)((uint8_t) 50)((uint8_t) 76)((uint8_t) 75)((uint8_t) 74)((uint8_t) 73)((uint8_t) 72)((uint8_t) 71)((uint8_t) 70)((uint8_t) 69)((uint8_t) 68)((uint8_t) 65)((uint8_t) 64)((uint8_t) 49)((uint8_t) 48)((uint8_t) 47)((uint8_t) 46)((uint8_t) 45)((uint8_t) 44)((uint8_t) 43)((uint8_t) 42)((uint8_t) 41)((uint8_t) 40)((uint8_t) 39)((uint8_t) 38)((uint8_t) 37)((uint8_t) 36)((uint8_t) 35)((uint8_t) 34)((uint8_t) 33)((uint8_t) 32)((uint8_t) 31)((uint8_t) 30)((uint8_t) 29)((uint8_t) 28)((uint8_t) 27)((uint8_t) 26)((uint8_t) 25)((uint8_t) 24)((uint8_t) 23)((uint8_t) 22)((uint8_t) 21)((uint8_t) 20)((uint8_t) 19)((uint8_t) 18)((uint8_t) 17)((uint8_t) 16)((uint8_t) 15)((uint8_t) 14)((uint8_t) 255)((uint8_t) 13)((uint8_t) 12)((uint8_t) 11)((uint8_t) 10)((uint8_t) 9)((uint8_t) 8)((uint8_t) 7)((uint8_t) 6)((uint8_t) 5)((uint8_t) 4)((uint8_t) 3)((uint8_t) 2)((uint8_t) 1)((uint8_t) 0)VM_RFC1048{ 99, 130, 83, 99 }"CMU"/* Only print if there are unknown bits *//* Data left over? *//* significant octets + router(4) *//* mask_width <= 32 *//* this option should be at least 5 bytes long *//* this option should be at least 1 byte long *//* this option should be at least 3 bytes long *//* Guys we can't handle with one of the usual cases *//* Bytes *//* boolean *//* shorts *//* IP address pairs *//* ip addresses/32-bit words *//* ascii strings *//* Base default formats for unknown tags on data size *//* Print data *//* Get the length; check for truncation *//* XXX we don't know yet if the IANA will
			 * preclude overlap of 1-byte and 2-byte spaces.
			 * If not, we need to offset tag after this step.
			 *//* Loop while we there is a tag left in the buffer *//* Step over magic cookie *//* RFC 3993 *//* RFC 3046 *//* ARP Hardware types, for Client-ID option *//* NETBIOS over TCP/IP node type options *//* DHCP "options overload" types *//* 2-byte extended tags *//* XXX 'b' *//* http://www.iana.org/assignments/bootp-dhcp-extensions/index.htm *//* RFC 3442 *//* RFC 3011 *//* XXX 's' *//* RFC 2937 *//*"b" is a little wrong *//* RFC 2610 *//* RFC 2563 *//* RFC 2485 *//* RFC2132 tags *//* RFC1497 tags *//* 512 byte blocks *//* ascii hostname *//* resource location (RFC887) *//* impress servers (Imagen) *//* lpr server (RFC1179) *//* cookie servers (RFC865) *//* MIT log servers *//* domain name (RFC1035) *//* IEN name servers (IEN116) *//* time servers (RFC868) *//* default gateway *//* seconds from UTC *//* subnet mask (RFC950) *//* RFC1048 tags *//*
 * The first character specifies the format to print:
 *     i - ip address (32 bits)
 *     p - ip address pairs (32 bits + 32 bits)
 *     l - long (32 bits)
 *     L - unsigned long (32 bits)
 *     s - short (16 bits)
 *     b - period-seperated decimal bytes (variable length)
 *     x - colon-seperated hex bytes (variable length)
 *     a - ascii string (variable length)
 *     B - on/off (8 bits)
 *     $ - special (explicit code to handle)
 *//* Decode the vendor buffer *//* check first char only *//* Client's Ethernet address *//* Gateway's ip address *//* Server's ip address *//* 'your' ip address (bootp client) *//* Client's ip address *//* Only print interesting fields *//* The usual length for 10Mb Ethernet address is 6 bytes *//* The usual hardware address type is 1 (10Mb Ethernet) *//*
 * Print bootp requests
 *//* end of original bootp.h *//* RFC 4702 DHCP Client FQDN Option *//* Subnet mask field contains valid data *//* v_flags values *//* currently unused *//* Time servers *//* IEN-116 name servers *//* Domain name servers *//* Default gateway *//* Subnet mask *//* flags/opcodes, etc. *//* magic number *//*
 * "vendor" data permitted for CMU bootp clients.
 *//* DHCP Message types (values for TAG_DHCP_MESSAGE option) *//* ftp://ftp.isi.edu/.../assignments/bootp-dhcp-extensions *//* RFC 2242 *//* RFC 2241 *//* DHCP options *//* RFC2132 *//*
 * RFC1048 tag values used to specify what information is being supplied in
 * the vendor field of the packet.
 *//*
 * Vendor magic cookie (v_magic) for RFC1048
 *//*
 * Vendor magic cookie (v_magic) for CMU
 *//* vendor-specific area *//* boot file name *//* server host name *//* client hardware address *//* gateway IP address *//* server IP address *//* 'your' IP address *//* client IP address *//* flags - see bootp_flag_values[]
					   in print-bootp.c *//* seconds since boot began *//* transaction ID *//* gateway hops *//* hardware addr length *//* hardware addr type *//* packet opcode type *//*
 * Bootstrap Protocol (BOOTP).  RFC951 and RFC1048.
 *
 * This file specifies the "implementation-independent" BOOTP protocol
 * information which is common to both client and server.
 *
 * Copyright 1988 by Carnegie Mellon.
 *
 * Permission to use, copy, modify, and distribute this program for any
 * purpose and without fee is hereby granted, provided that this copyright
 * and permission notice appear on all copies and supporting documentation,
 * the name of Carnegie Mellon not be used in advertising or publicity
 * pertaining to distribution of the program without specific prior
 * permission, and notice be given in supporting documentation that copying
 * and distribution is by permission of Carnegie Mellon and Stanford
 * University.  Carnegie Mellon makes no representations about the
 * suitability of this software for any purpose.  It is provided "as is"
 * without express or implied warranty.
 *//*
 * Copyright (c) 1990, 1991, 1993, 1994, 1995, 1996, 1997
 *	The Regents of the University of California.  All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that: (1) source code distributions
 * retain the above copyright notice and this paragraph in its entirety, (2)
 * distributions including binary code include the above copyright notice and
 * this paragraph in its entirety in the documentation or other materials
 * provided with the distribution, and (3) all advertising materials mentioning
 * features or use of this software display the following acknowledgement:
 * ``This product includes software developed by the University of California,
 * Lawrence Berkeley Laboratory and its contributors.'' Neither the name of
 * the University nor the names of its contributors may be used to endorse
 * or promote products derived from this software without specific prior
 * written permission.
 * THIS SOFTWARE IS PROVIDED ``AS IS'' AND WITHOUT ANY EXPRESS OR IMPLIED
 * WARRANTIES, INCLUDING, WITHOUT LIMITATION, THE IMPLIED WARRANTIES OF
 * MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE.
 *
 * Format and print bootp packets.
 *//Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX.sdk/usr/include/pcap/bluetooth.h<pcap/pcap-inttypes.h>pcap_bluetooth_linux_monitor_header_pcap_bluetooth_linux_monitor_headerpcap_bluetooth_h4_header_pcap_bluetooth_h4_headeropcodeadapter_iddirectionlib_pcap_bluetooth_h/*
 * Header prepended libpcap to each bluetooth linux monitor frame,
 * fields are in network byte order
 *//* if first bit is set direction is incoming *//*
 * Header prepended libpcap to each bluetooth h4 frame,
 * fields are in network byte order
 *//*
 * Copyright (c) 2006 Paolo Abeni (Italy)
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 *
 * 1. Redistributions of source code must retain the above copyright
 * notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 * notice, this list of conditions and the following disclaimer in the
 * documentation and/or other materials provided with the distribution.
 * 3. The name of the author may not be used to endorse or promote
 * products derived from this software without specific prior written
 * permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
 * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
 * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
 * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
 * OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
 * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
 * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
 * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
 * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 *
 * bluetooth data struct
 * By Paolo Abeni <paolo.abeni@email.it>
 *//Users/owura/Repos/codeql_eval/proj_repos/the-tcpdump-group-tcpdump-commit-0f95d441e4b5d7512cc5c326c8668a120e048eda/tcpdump/print-bt.c<pcap/bluetooth.h>bt_if_printconst pcap_bluetooth_h4_headerconst pcap_bluetooth_h4_header *_pcap_bluetooth_h4_header *(ndo, "[|bt]")BT_HDRLEN[|bt](BT_HDRLEN)(ndo, "hci length %d, direction %s, ", length, (EXTRACT_32BITS(&hdr->direction)&0x1)?"in":"out")(ndo, "hci length %d, direction %s, ", length, (((uint32_t)(((uint32_t)(*((const uint8_t *)(&hdr->direction) + 0)) << 24) | ((uint32_t)(*((const uint8_t *)(&hdr->direction) + 1)) << 16) | ((uint32_t)(*((const uint8_t *)(&hdr->direction) + 2)) << 8) | ((uint32_t)(*((const uint8_t *)(&hdr->direction) + 3)) << 0)))&0x1)?"in":"out")&hdr->directionhci length %d, direction %s, sizeof(pcap_bluetooth_h4_header)defined(DLT_BLUETOOTH_HCI_H4_WITH_PHDR) && defined(HAVE_PCAP_BLUETOOTH_H)/*
 * This is the top level routine of the printer.  'p' points
 * to the bluetooth header of the packet, 'h->ts' is the timestamp,
 * 'h->len' is the length of the packet off the wire, and 'h->caplen'
 * is the number of bytes actually captured.
 *//*
 * Copyright (c) 2007
 *	paolo.abeni@email.it  All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that: (1) source code distributions
 * retain the above copyright notice and this paragraph in its entirety, (2)
 * distributions including binary code include the above copyright notice and
 * this paragraph in its entirety in the documentation or other materials
 * provided with the distribution, and (3) all advertising materials mentioning
 * features or use of this software display the following acknowledgement:
 * ``This product includes software developed by Paolo Abeni.''
 * The name of author may not be used to endorse or promote products derived
 * from this software without specific prior written permission.
 * THIS SOFTWARE IS PROVIDED ``AS IS'' AND WITHOUT ANY EXPRESS OR IMPLIED
 * WARRANTIES, INCLUDING, WITHOUT LIMITATION, THE IMPLIED WARRANTIES OF
 * MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE.
 *//Users/owura/Repos/codeql_eval/proj_repos/the-tcpdump-group-tcpdump-commit-0f95d441e4b5d7512cc5c326c8668a120e048eda/tcpdump/print-calm-fast.ccalm_fast_printsrcNwrefdstNwref(ndo, "CALM FAST src:%s; ", etheraddr_string(ndo, eth+6))CALM FAST src:%s; (ndo, "SrcNwref:%d; ", srcNwref)SrcNwref:%d; (ndo, "DstNwref:%d; ", dstNwref)DstNwref:%d; /*
 * This is the top level routine of the printer.  'bp' points
 * to the calm header of the packet.
 *//*
   ISO 29281:2009
   Intelligent Transport Systems . Communications access for land mobiles (CALM)
   CALM non-IP networking
*//*
 * Copyright (c) 2013 The TCPDUMP project
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that: (1) source code
 * distributions retain the above copyright notice and this paragraph
 * in its entirety, and (2) distributions including binary code include
 * the above copyright notice and this paragraph in its entirety in
 * the documentation or other materials provided with the distribution.
 * THIS SOFTWARE IS PROVIDED ``AS IS'' AND
 * WITHOUT ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, WITHOUT
 * LIMITATION, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS
 * FOR A PARTICULAR PURPOSE.
 *
 * Original code by Ola Martin Lykkja (ola.lykkja@q-free.com)
 */eth/Users/owura/Repos/codeql_eval/proj_repos/the-tcpdump-group-tcpdump-commit-0f95d441e4b5d7512cc5c326c8668a120e048eda/tcpdump/print-carp.ccarp_printtype_sbp[0]sizeof(bp[0])advertise"advertise""unknown"(ndo, "CARPv%d-%s %d: ", version, type_s, len)CARPv%d-%s %d: (ndo, "[ttl=%d!] ", ttl)[ttl=%d!] bp[2]sizeof(bp[2])bp[5]sizeof(bp[5])(ndo, "vhid=%d advbase=%d advskew=%d authlen=%d ", bp[1], bp[5], bp[2], bp[3])vhid=%d advbase=%d advskew=%d authlen=%d (ndo, " (bad carp cksum %x!)", EXTRACT_16BITS(&bp[6]))(ndo, " (bad carp cksum %x!)", ((uint16_t)(((uint16_t)(*((const uint8_t *)(&bp[6]) + 0)) << 8) | ((uint16_t)(*((const uint8_t *)(&bp[6]) + 1)) << 0))))&bp[6]cksum_vec[1] (bad carp cksum %x!)(ndo, "counter=%" PRIu64, EXTRACT_64BITS(&bp[8]))(ndo, "counter=%" "ll" "u", ((uint64_t)(((uint64_t)(*((const uint8_t *)(&bp[8]) + 0)) << 56) | ((uint64_t)(*((const uint8_t *)(&bp[8]) + 1)) << 48) | ((uint64_t)(*((const uint8_t *)(&bp[8]) + 2)) << 40) | ((uint64_t)(*((const uint8_t *)(&bp[8]) + 3)) << 32) | ((uint64_t)(*((const uint8_t *)(&bp[8]) + 4)) << 24) | ((uint64_t)(*((const uint8_t *)(&bp[8]) + 5)) << 16) | ((uint64_t)(*((const uint8_t *)(&bp[8]) + 6)) << 8) | ((uint64_t)(*((const uint8_t *)(&bp[8]) + 7)) << 0))))counter=%llu&bp[8](ndo, "[|carp]")[|carp]/* for checksum structure and functions *//*
 * Copyright (c) 2000 William C. Fenner.
 *                All rights reserved.
 *
 * Kevin Steves <ks@hp.se> July 2000
 * Modified to:
 * - print version, type string and packet length
 * - print IP address count if > 1 (-v)
 * - verify checksum (-v)
 * - print authentication string (-v)
 *
 * Copyright (c) 2011 Advanced Computing Technologies
 * George V. Neille-Neil
 *
 * Modified to:
 * - work correctly with CARP
 * - compile into the latest tcpdump
 * - print out the counter
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that: (1) source code
 * distributions retain the above copyright notice and this paragraph
 * in its entirety, and (2) distributions including binary code include
 * the above copyright notice and this paragraph in its entirety in
 * the documentation or other materials provided with the distribution.
 * The name of William C. Fenner may not be used to endorse or
 * promote products derived from this software without specific prior
 * written permission.  THIS SOFTWARE IS PROVIDED ``AS IS'' AND
 * WITHOUT ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, WITHOUT
 * LIMITATION, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS
 * FOR A PARTICULAR PURPOSE.
 *
 *//*	$OpenBSD: print-carp.c,v 1.6 2009/10/27 23:59:55 deraadt Exp $	*//Users/owura/Repos/codeql_eval/proj_repos/the-tcpdump-group-tcpdump-commit-0f95d441e4b5d7512cc5c326c8668a120e048eda/tcpdump/print-cdp.ccdp_get_numbercdp_print_prefixes(ndo, " IPv4 Prefixes (%d):", l / 5) IPv4 Prefixes (%d):(ndo, " %u.%u.%u.%u/%u", p[0], p[1], p[2], p[3], p[4]) %u.%u.%u.%u/%ucdp_print_addrptalendpp[pl]&p[pl](ndo, "IPv4 (%u) %s", num, ipaddr_string(ndo, p))(ndo, "IPv4 (%u) %s", num, getname(ndo, (const u_char *)(p)))(ndo, "pt=0x%02x, pl=%d, pb=", *(p - 2), pl)(ndo, " %02x", *p++)(ndo, ", al=%d, a=", al)PT_NLPIDIPv4 (%u) %spt=0x%02x, pl=%d, pb=, al=%d, a=cdp_printCDP_HEADER_LEN(ndo, "CDPv%u, ttl: %us", *(tptr + CDP_HEADER_VERSION_OFFSET), *(tptr + CDP_HEADER_TTL_OFFSET))(ndo, "CDPv%u, ttl: %us", *(tptr + 0), *(tptr + 1))CDPv%u, ttl: %us(ndo, ", checksum: 0x%04x (unverified), length %u", EXTRACT_16BITS(tptr+CDP_HEADER_CHECKSUM_OFFSET), length)(ndo, ", checksum: 0x%04x (unverified), length %u", ((uint16_t)(((uint16_t)(*((const uint8_t *)(tptr+2) + 0)) << 8) | ((uint16_t)(*((const uint8_t *)(tptr+2) + 1)) << 0))), length)tptr+CDP_HEADER_CHECKSUM_OFFSET, checksum: 0x%04x (unverified), length %uCDP_TLV_HEADER_LENtptr+CDP_TLV_TYPE_OFFSETtptr+0tptr+CDP_TLV_LEN_OFFSET(ndo, "\n\t%s (0x%02x), TLV length: %u byte%s (too short)", tok2str(cdp_tlv_values,"unknown field type", type), type, len, PLURAL_SUFFIX(len))(ndo, "\n\t%s (0x%02x), TLV length: %u byte%s (too short)", tok2str(cdp_tlv_values,"unknown field type", type), type, len, (((len) != 1) ? "s" : ""))(ndo, ", %s TLV length %u too short", tok2str(cdp_tlv_values,"unknown field type", type), len)(ndo, "\n\t%s (0x%02x), value length: %u byte%s: ", tok2str(cdp_tlv_values,"unknown field type", type), type, len, PLURAL_SUFFIX(len))(ndo, "\n\t%s (0x%02x), value length: %u byte%s: ", tok2str(cdp_tlv_values,"unknown field type", type), type, len, (((len) != 1) ? "s" : ""))(ndo, ", Device-ID ")(ndo, "'")(ndo, "(0x%08x): %s", EXTRACT_32BITS(tptr), bittok2str(cdp_capability_values, "none", EXTRACT_32BITS(tptr)))(ndo, "(0x%08x): %s", ((uint32_t)(((uint32_t)(*((const uint8_t *)(tptr) + 0)) << 24) | ((uint32_t)(*((const uint8_t *)(tptr) + 1)) << 16) | ((uint32_t)(*((const uint8_t *)(tptr) + 2)) << 8) | ((uint32_t)(*((const uint8_t *)(tptr) + 3)) << 0))), bittok2str(cdp_capability_values, "none", ((uint32_t)(((uint32_t)(*((const uint8_t *)(tptr) + 0)) << 24) | ((uint32_t)(*((const uint8_t *)(tptr) + 1)) << 16) | ((uint32_t)(*((const uint8_t *)(tptr) + 2)) << 8) | ((uint32_t)(*((const uint8_t *)(tptr) + 3)) << 0)))))(ndo, "\n\t  ")(ndo, "%c", j)(ndo, "\t  ")(ndo, "%d", EXTRACT_16BITS(tptr))(ndo, "%d", ((uint16_t)(((uint16_t)(*((const uint8_t *)(tptr) + 0)) << 8) | ((uint16_t)(*((const uint8_t *)(tptr) + 1)) << 0))))(ndo, "%s", *(tptr) ? "full": "half")(ndo, "app %d, vlan %d", *(tptr), EXTRACT_16BITS(tptr + 1))(ndo, "app %d, vlan %d", *(tptr), ((uint16_t)(((uint16_t)(*((const uint8_t *)(tptr + 1) + 0)) << 8) | ((uint16_t)(*((const uint8_t *)(tptr + 1) + 1)) << 0))))tptr + 1(ndo, "%1.2fW", cdp_get_number(tptr, len) / 1000.0)(ndo, "%u bytes", EXTRACT_32BITS(tptr))(ndo, "%u bytes", ((uint32_t)(((uint32_t)(*((const uint8_t *)(tptr) + 0)) << 24) | ((uint32_t)(*((const uint8_t *)(tptr) + 1)) << 16) | ((uint32_t)(*((const uint8_t *)(tptr) + 2)) << 8) | ((uint32_t)(*((const uint8_t *)(tptr) + 3)) << 0))))(ndo, "0x%02x", *(tptr))(ndo, "/")
	%s (0x%02x), TLV length: %u byte%s (too short)unknown field type, %s TLV length %u too short
	%s (0x%02x), value length: %u byte%s: , Device-ID '(0x%08x): %s	  fullhalfapp %d, vlan %d%1.2fW1000.0%u bytes0x%02x(ndo, ", length %u", caplen)Transparent Bridge"Transparent Bridge"Source Route Bridge"Source Route Bridge"L2 Switch"L2 Switch"L3 capable"L3 capable"IGMP snooping"IGMP snooping"L1 capable"L1 capable"cdp_capability_valuesDevice-ID"Device-ID"Address"Address"Port-ID"Port-ID"Capability"Capability"Version String"Version String"Platform"Platform"Prefixes"Prefixes"Protocol-Hello option"Protocol-Hello option"VTP Management Domain"VTP Management Domain"Native VLAN ID"Native VLAN ID"Duplex"Duplex"ATA-186 VoIP VLAN request"ATA-186 VoIP VLAN request"ATA-186 VoIP VLAN assignment"ATA-186 VoIP VLAN assignment"power consumption"power consumption"MTU"MTU"AVVID trust bitmap"AVVID trust bitmap"AVVID untrusted ports CoS"AVVID untrusted ports CoS"System Name"System Name"System Object ID (not decoded)"System Object ID (not decoded)"Management Addresses"Management Addresses"Physical Location"Physical Location"cdp_tlv_values[|cdp]"[|cdp]"PT_IEEE_802_2CDP_TLV_LEN_OFFSETCDP_TLV_TYPE_OFFSETCDP_HEADER_CHECKSUM_OFFSETCDP_HEADER_TTL_OFFSETCDP_HEADER_VERSION_OFFSET/* read in a <n>-byte number, MSB first
 * (of course this can handle max sizeof(long))
 *//*
			 * Generic case: just print raw data
			 *//*
			 * IPv6: protocol type = IEEE 802.2 header,
			 * protocol length = 8 (size of LLC+SNAP header),
			 * protocol = LLC+SNAP header with the IPv6
			 * Ethertype, address length = 16
			 *//*
			 * IPv4: protocol type = NLPID, protocol length = 1
			 * (1-byte NLPID), protocol = 0xcc (NLPID for IPv4),
			 * address length = 4
			 *//* address length *//* length of "protocol" field *//* type of "protocol" field *//* IEEE 802.2 LLC header *//* OSI NLPID *//*
 * Protocol type values.
 *
 * PT_NLPID means that the protocol type field contains an OSI NLPID.
 *
 * PT_IEEE_802_2 means that the protocol type field contains an IEEE 802.2
 * LLC header that specifies that the payload is for that protocol.
 *//* Physical Location - not documented *//* System Object ID - not documented *//* System Name - not documented *//* AVVID untrusted port CoS - not documented *//* AVVID trust bitmap - not documented *//* MTU - not documented *//* ATA-186 VoIP VLAN assignment - incomplete doc. *//* ATA-186 VoIP VLAN request - incomplete doc. *//* http://www.cisco.com/c/en/us/td/docs/voice_ip_comm/cata/186/2_12_m/english/release/notes/186rn21m.html
		     * plus more details from other sources
		     *//* Duplex - CDPv2 *//* Native VLAN ID - CDPv2 *//* VTP Mgmt Domain  - CDPv2 *//* Protocol Hello Option - not documented *//* Prefixes *//* Platform *//* lets rework the version string to get a nice identation *//* Capabilities *//* Port-ID *//* Address *//* Device-ID *//* plural *//* in non-verbose mode just print Device-ID *//* object length includes the 4 bytes header length *//* read out Type and Length *//* temporary pointer *//*
 * Copyright (c) 1992, 1993, 1994, 1995, 1996, 1997
 *	The Regents of the University of California.  All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that: (1) source code distributions
 * retain the above copyright notice and this paragraph in its entirety, (2)
 * distributions including binary code include the above copyright notice and
 * this paragraph in its entirety in the documentation or other materials
 * provided with the distribution, and (3) all advertising materials mentioning
 * features or use of this software display the following acknowledgement:
 * ``This product includes software developed by the University of California,
 * Lawrence Berkeley Laboratory and its contributors.'' Neither the name of
 * the University nor the names of its contributors may be used to endorse
 * or promote products derived from this software without specific prior
 * written permission.
 * THIS SOFTWARE IS PROVIDED ``AS IS'' AND WITHOUT ANY EXPRESS OR IMPLIED
 * WARRANTIES, INCLUDING, WITHOUT LIMITATION, THE IMPLIED WARRANTIES OF
 * MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE.
 *
 * Code by Gert Doering, SpaceNet GmbH, gert@space.net
 *
 * Reference documentation:
 *    http://www.cisco.com/univercd/cc/td/doc/product/lan/trsrb/frames.htm
 *//Users/owura/Repos/codeql_eval/proj_repos/the-tcpdump-group-tcpdump-commit-0f95d441e4b5d7512cc5c326c8668a120e048eda/tcpdump/print-cfm.ccfm_printconst cfm_common_header_tconst cfm_common_header_t *cfm_common_header_t *cfm_common_headerconst cfm_tlv_header_tconst cfm_tlv_header_t *cfm_tlv_header_t *cfm_tlv_headertlv_ptrma_namema_nameformatma_namelengthhexdumpcfm_tlv_lencfm_tlv_typeccm_intervalmsg_ptr*cfm_common_headersizeof(*cfm_common_header)cfm_common_header->mdlevel_version(ndo, "CFMv%u not supported, length %u", CFM_EXTRACT_VERSION(cfm_common_header->mdlevel_version), length)(ndo, "CFMv%u not supported, length %u", (((cfm_common_header->mdlevel_version)&0x1f)), length)CFM_VERSIONCFMv%u not supported, length %u(ndo, "CFMv%u %s, MD Level %u, length %u", CFM_EXTRACT_VERSION(cfm_common_header->mdlevel_version), tok2str(cfm_opcode_values, "unknown (%u)", cfm_common_header->opcode), CFM_EXTRACT_MD_LEVEL(cfm_common_header->mdlevel_version), length)(ndo, "CFMv%u %s, MD Level %u, length %u", (((cfm_common_header->mdlevel_version)&0x1f)), tok2str(cfm_opcode_values, "unknown (%u)", cfm_common_header->opcode), (((cfm_common_header->mdlevel_version)&0xe0)>>5), length)CFMv%u %s, MD Level %u, length %u(ndo, "\n\tFirst TLV offset %u", cfm_common_header->first_tlv_offset)
	First TLV offset %usizeof(const struct cfm_common_header_t)sizeof(struct cfm_common_header_t)cfm_common_header->flags(ndo, ", Flags [CCM Interval %u%s]", ccm_interval, cfm_common_header->flags & CFM_CCM_RDI_FLAG ? ", RDI" : "")(ndo, ", Flags [CCM Interval %u%s]", ccm_interval, cfm_common_header->flags & 0x80 ? ", RDI" : "")(ndo, "\n\t  CCM Interval %.3fs" ", min CCM Lifetime %.3fs, max CCM Lifetime %.3fs", ccm_interval_base[ccm_interval], ccm_interval_base[ccm_interval] * CCM_INTERVAL_MIN_MULTIPLIER, ccm_interval_base[ccm_interval] * CCM_INTERVAL_MAX_MULTIPLIER)(ndo, "\n\t  CCM Interval %.3fs" ", min CCM Lifetime %.3fs, max CCM Lifetime %.3fs", ccm_interval_base[ccm_interval], ccm_interval_base[ccm_interval] * 3.25, ccm_interval_base[ccm_interval] * 3.5)(ndo, "\n\t  Sequence Number 0x%08x, MA-End-Point-ID 0x%04x", EXTRACT_32BITS(msg_ptr.cfm_ccm->sequence), EXTRACT_16BITS(msg_ptr.cfm_ccm->ma_epi))(ndo, "\n\t  Sequence Number 0x%08x, MA-End-Point-ID 0x%04x", ((uint32_t)(((uint32_t)(*((const uint8_t *)(msg_ptr.cfm_ccm->sequence) + 0)) << 24) | ((uint32_t)(*((const uint8_t *)(msg_ptr.cfm_ccm->sequence) + 1)) << 16) | ((uint32_t)(*((const uint8_t *)(msg_ptr.cfm_ccm->sequence) + 2)) << 8) | ((uint32_t)(*((const uint8_t *)(msg_ptr.cfm_ccm->sequence) + 3)) << 0))), ((uint16_t)(((uint16_t)(*((const uint8_t *)(msg_ptr.cfm_ccm->ma_epi) + 0)) << 8) | ((uint16_t)(*((const uint8_t *)(msg_ptr.cfm_ccm->ma_epi) + 1)) << 0))))msg_ptr.cfm_ccm->sequencemsg_ptr.cfm_ccm->ma_epi(ndo, "\n\t  MD Name Format %s (%u), MD Name length %u", tok2str(cfm_md_nameformat_values, "Unknown", msg_ptr.cfm_ccm->md_nameformat), msg_ptr.cfm_ccm->md_nameformat, msg_ptr.cfm_ccm->md_namelength)(ndo, "\n\t  MD Name: ")(ndo, "\n\t  MAC %s", etheraddr_string(ndo, msg_ptr.cfm_ccm->md_name))(ndo, "\n\t  MA Name-Format %s (%u), MA name length %u", tok2str(cfm_ma_nameformat_values, "Unknown", *ma_nameformat), *ma_nameformat, *ma_namelength)(ndo, "\n\t  MA Name: ")(ndo, ", Flags [%s]", bittok2str(cfm_ltm_flag_values, "none", cfm_common_header->flags))(ndo, "\n\t  Transaction-ID 0x%08x, Egress-ID %s, ttl %u", EXTRACT_32BITS(msg_ptr.cfm_ltm->transaction_id), cfm_egress_id_string(ndo, msg_ptr.cfm_ltm->egress_id), msg_ptr.cfm_ltm->ttl)(ndo, "\n\t  Transaction-ID 0x%08x, Egress-ID %s, ttl %u", ((uint32_t)(((uint32_t)(*((const uint8_t *)(msg_ptr.cfm_ltm->transaction_id) + 0)) << 24) | ((uint32_t)(*((const uint8_t *)(msg_ptr.cfm_ltm->transaction_id) + 1)) << 16) | ((uint32_t)(*((const uint8_t *)(msg_ptr.cfm_ltm->transaction_id) + 2)) << 8) | ((uint32_t)(*((const uint8_t *)(msg_ptr.cfm_ltm->transaction_id) + 3)) << 0))), cfm_egress_id_string(ndo, msg_ptr.cfm_ltm->egress_id), msg_ptr.cfm_ltm->ttl)msg_ptr.cfm_ltm->transaction_id(ndo, "\n\t  Original-MAC %s, Target-MAC %s", etheraddr_string(ndo, msg_ptr.cfm_ltm->original_mac), etheraddr_string(ndo, msg_ptr.cfm_ltm->target_mac))(ndo, ", Flags [%s]", bittok2str(cfm_ltr_flag_values, "none", cfm_common_header->flags))(ndo, "\n\t  Transaction-ID 0x%08x, Last-Egress-ID %s", EXTRACT_32BITS(msg_ptr.cfm_ltr->transaction_id), cfm_egress_id_string(ndo, msg_ptr.cfm_ltr->last_egress_id))(ndo, "\n\t  Transaction-ID 0x%08x, Last-Egress-ID %s", ((uint32_t)(((uint32_t)(*((const uint8_t *)(msg_ptr.cfm_ltr->transaction_id) + 0)) << 24) | ((uint32_t)(*((const uint8_t *)(msg_ptr.cfm_ltr->transaction_id) + 1)) << 16) | ((uint32_t)(*((const uint8_t *)(msg_ptr.cfm_ltr->transaction_id) + 2)) << 8) | ((uint32_t)(*((const uint8_t *)(msg_ptr.cfm_ltr->transaction_id) + 3)) << 0))), cfm_egress_id_string(ndo, msg_ptr.cfm_ltr->last_egress_id))msg_ptr.cfm_ltr->transaction_id(ndo, "\n\t  Next-Egress-ID %s, ttl %u", cfm_egress_id_string(ndo, msg_ptr.cfm_ltr->next_egress_id), msg_ptr.cfm_ltr->ttl)(ndo, "\n\t  Replay-Action %s (%u)", tok2str(cfm_ltr_replay_action_values, "Unknown", msg_ptr.cfm_ltr->replay_action), msg_ptr.cfm_ltr->replay_action)CFM_OPCODE_CCMconst cfm_ccm_tconst cfm_ccm_t *cfm_ccm_t *, Flags [CCM Interval %u%s], RDI
	  CCM Interval %.3fs, min CCM Lifetime %.3fs, max CCM Lifetime %.3fsconst float[8]float[8]3.253.5
	  Sequence Number 0x%08x, MA-End-Point-ID 0x%04x
	  MD Name Format %s (%u), MD Name length %uCFM_CCM_MD_FORMAT_NONE
	  MD Name: CFM_CCM_MD_FORMAT_DNSCFM_CCM_MD_FORMAT_CHARuint8_t[46]unsigned char[46]CFM_CCM_MD_FORMAT_MAC
	  MAC %sCFM_CCM_MA_FORMAT_8021
	  MA Name-Format %s (%u), MA name length %u
	  MA Name: CFM_CCM_MA_FORMAT_CHARCFM_CCM_MA_FORMAT_VIDCFM_CCM_MA_FORMAT_INTCFM_CCM_MA_FORMAT_VPNCFM_OPCODE_LTMconst cfm_ltm_tconst cfm_ltm_t *cfm_ltm_t *
	  Transaction-ID 0x%08x, Egress-ID %s, ttl %u
	  Original-MAC %s, Target-MAC %sCFM_OPCODE_LTRconst cfm_ltr_tconst cfm_ltr_t *cfm_ltr_t *
	  Transaction-ID 0x%08x, Last-Egress-ID %s
	  Next-Egress-ID %s, ttl %u
	  Replay-Action %s (%u)CFM_OPCODE_LBRCFM_OPCODE_LBMsizeof(struct cfm_tlv_header_t)&cfm_tlv_header->length(ndo, "\n\t%s TLV (0x%02x), length %u", tok2str(cfm_tlv_values, "Unknown", cfm_tlv_type), cfm_tlv_type, cfm_tlv_len)(ndo, ", Status: %s (%u)", tok2str(cfm_tlv_port_status_values, "Unknown", *tptr), *tptr)(ndo, ", Status: %s (%u)", tok2str(cfm_tlv_interface_status_values, "Unknown", *tptr), *tptr)(ndo, ", Vendor: %s (%u), Sub-Type %u", tok2str(oui_values,"Unknown", EXTRACT_24BITS(tptr)), EXTRACT_24BITS(tptr), *(tptr + 3))(ndo, ", Vendor: %s (%u), Sub-Type %u", tok2str(oui_values,"Unknown", ((uint32_t)(((uint32_t)(*((const uint8_t *)(tptr) + 0)) << 16) | ((uint32_t)(*((const uint8_t *)(tptr) + 1)) << 8) | ((uint32_t)(*((const uint8_t *)(tptr) + 2)) << 0)))), ((uint32_t)(((uint32_t)(*((const uint8_t *)(tptr) + 0)) << 16) | ((uint32_t)(*((const uint8_t *)(tptr) + 1)) << 8) | ((uint32_t)(*((const uint8_t *)(tptr) + 2)) << 0))), *(tptr + 3))(ndo, "\n\t  Chassis-ID Type %s (%u), Chassis-ID length %u", tok2str(cfm_tlv_senderid_chassisid_values, "Unknown", chassis_id_type), chassis_id_type, chassis_id_length)(ndo, "\n\t  MAC %s", etheraddr_string(ndo, tptr + 1))CFM_TLV_END
	%s TLV (0x%02x), length %uFALSECFM_TLV_PORT_STATUS, Status: %s (%u)CFM_TLV_INTERFACE_STATUSCFM_TLV_PRIVATE, Vendor: %s (%u), Sub-Type %uTRUECFM_TLV_SENDER_IDchassis_id_typechassis_id_lengthmgmt_addr_length
	  Chassis-ID Type %s (%u), Chassis-ID length %uCFM_CHASSIS_ID_MAC_ADDRESSCFM_CHASSIS_ID_NETWORK_ADDRESSCFM_CHASSIS_ID_INTERFACE_NAMECFM_CHASSIS_ID_INTERFACE_ALIASCFM_CHASSIS_ID_LOCALCFM_CHASSIS_ID_CHASSIS_COMPONENTCFM_CHASSIS_ID_PORT_COMPONENTCFM_TLV_DATACFM_TLV_REPLY_INGRESSCFM_TLV_REPLY_EGRESS(ndo, "\n\t\t packet exceeded snapshot")
		 packet exceeded snapshotcfm_egress_id_stringegress_id_buffersizeof(egress_id_buffer)"MAC 0x%4x-%s", EXTRACT_16BITS(tptr), etheraddr_string(ndo, tptr+2)"MAC 0x%4x-%s", ((uint16_t)(((uint16_t)(*((const uint8_t *)(tptr) + 0)) << 8) | ((uint16_t)(*((const uint8_t *)(tptr) + 1)) << 0))), etheraddr_string(ndo, tptr+2)MAC 0x%4x-%scfm_mgmt_addr_printmgmt_addr_type(ndo, "\n\t  Management Address Type %s (%u)", tok2str(af_values, "Unknown", mgmt_addr_type), mgmt_addr_type)
	  Management Address Type %s (%u)(ndo, ", %s", ipaddr_string(ndo, tptr + 1))(ndo, ", %s", getname(ndo, (const u_char *)(tptr + 1)))cfm_tlv_header_tcfm_ltr_tcfm_ltm_tcfm_lbm_tcfm_ccm_tcfm_common_header_tcfm_ltrcfm_ltmconst cfm_lbm_tconst cfm_lbm_t *cfm_lbm_t *cfm_lbmcfm_ccmreservedreplay_actionnext_egress_idlast_egress_idtransaction_idtarget_macoriginal_macegress_idreserved_itumd_namemd_namelengthmd_nameformatma_episequencefirst_tlv_offsetmdlevel_versionChassis component"Chassis component"Interface alias"Interface alias"Port component"Port component"MAC address"MAC address"Network address"Network address"Interface name"Interface name"Locally assigned"Locally assigned"cfm_tlv_senderid_chassisid_valuesTesting"Testing"Dormant"Dormant"not present"not present"lower Layer down"lower Layer down"cfm_tlv_interface_status_valuesBlocked"Blocked"cfm_tlv_port_status_valuesEnd"End"Sender ID"Sender ID"Port status"Port status"Interface status"Interface status"Reply Ingress"Reply Ingress"Reply Egress"Reply Egress"Organization Specific"Organization Specific"cfm_tlv_valuesExact Match"Exact Match"Filtering DB"Filtering DB"MIP CCM DB"MIP CCM DB"cfm_ltr_replay_action_valuesUseFDB Only"UseFDB Only"FwdYes"FwdYes"Terminal MEP"Terminal MEP"cfm_ltr_flag_valuesUse Forwarding-DB only"Use Forwarding-DB only"cfm_ltm_flag_valuesIEEE 802.1"IEEE 802.1"Primary VID"Primary VID"Character string"Character string"16Bit Integer"16Bit Integer"RFC2685 VPN-ID"RFC2685 VPN-ID"cfm_ma_nameformat_valuesCFM_CCM_MD_FORMAT_8021No MD Name present"No MD Name present"DNS string"DNS string"MAC + 16Bit Integer"MAC + 16Bit Integer"cfm_md_nameformat_values0.0033330000000000000250.0033330.0033330000010.010000000000000000210.010.0099999997760.10000000000000000560.10.10000000151.010.060.0600600.0ccm_interval_baseContinouity Check Message"Continouity Check Message"Loopback Reply"Loopback Reply"Loopback Message"Loopback Message"Linktrace Reply"Linktrace Reply"Linktrace Message"Linktrace Message"cfm_opcode_valuesCFM_EXTRACT_CCM_INTERVAL(x)(((x)&0x07))CFM_CCM_RDI_FLAGCCM_INTERVAL_MAX_MULTIPLIERCCM_INTERVAL_MIN_MULTIPLIERCFM_EXTRACT_MD_LEVEL(x)CFM_EXTRACT_VERSION(x)(((x)&0x1f))/* do we want to see an additional hexdump ? *//*
             * FIXME those are the defined TLVs that lack a decoder
             * you are welcome to contribute code ;-)
             *//*
             * Check if there is a Management Address.
             *//*
             * Check if there is a Chassis-ID.
             *//* we are done - bail out *//* did we capture enough for fully decoding the object ? *//* sanity check for not walking off and infinite loop check. *//* did we capture enough for fully decoding the object header ? *//* Enough to read the tlv type ? *//*
     * Sanity check for not walking off.
     *//*
         * No message decoder yet.
         * Hexdump everything up until the start of the TLVs
         *//* FIXME add printers for those MA formats - hexdump for now *//*
         * Resolve the MA fields.
         *//* FIXME add printers for those MD formats - hexdump for now *//*
         * Resolve the MD fields.
         *//*
         * Resolve the CCM interval field.
         *//*
     * In non-verbose mode just print the opcode and md-level.
     *//*
     * Sanity checking of the header.
     *//*
 * The egress-ID string is a 16-Bit string plus a MAC address.
 *//*
     * Resolve the passed in Address.
     *//*
     * Altough AFIs are tpically 2 octects wide,
     * 802.1ab specifies that this field width
     * is only once octet
     *//* FIXME define TLV formats *//*
 * TLVs
 *//*
 * Timer Bases for the CCM Interval field.
 * Expressed in units of seconds.
 *//* md name and short ma name *//*
 * Message Formats.
 *//*
 * Copyright (c) 1998-2006 The TCPDUMP project
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that: (1) source code
 * distributions retain the above copyright notice and this paragraph
 * in its entirety, and (2) distributions including binary code include
 * the above copyright notice and this paragraph in its entirety in
 * the documentation or other materials provided with the distribution.
 * THIS SOFTWARE IS PROVIDED ``AS IS'' AND
 * WITHOUT ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, WITHOUT
 * LIMITATION, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS
 * FOR A PARTICULAR PURPOSE.
 *
 * Support for the IEEE Connectivity Fault Management Protocols as per 802.1ag.
 *
 * Original code by Hannes Gredler (hannes@juniper.net)
 *//Users/owura/Repos/codeql_eval/proj_repos/the-tcpdump-group-tcpdump-commit-0f95d441e4b5d7512cc5c326c8668a120e048eda/tcpdump/chdlc.hCHDLC_TYPE_CDPCHDLC_TYPE_SLARPCHDLC_BCASTCHDLC_UNICASTCHDLC_HDRLEN/*
 * Copyright (c) 1990, 1991, 1993, 1994, 1995, 1996, 1997
 *	The Regents of the University of California.  All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that: (1) source code distributions
 * retain the above copyright notice and this paragraph in its entirety, (2)
 * distributions including binary code include the above copyright notice and
 * this paragraph in its entirety in the documentation or other materials
 * provided with the distribution, and (3) all advertising materials mentioning
 * features or use of this software display the following acknowledgement:
 * ``This product includes software developed by the University of California,
 * Lawrence Berkeley Laboratory and its contributors.'' Neither the name of
 * the University nor the names of its contributors may be used to endorse
 * or promote products derived from this software without specific prior
 * written permission.
 * THIS SOFTWARE IS PROVIDED ``AS IS'' AND WITHOUT ANY EXPRESS OR IMPLIED
 * WARRANTIES, INCLUDING, WITHOUT LIMITATION, THE IMPLIED WARRANTIES OF
 * MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE.
 *//Users/owura/Repos/codeql_eval/proj_repos/the-tcpdump-group-tcpdump-commit-0f95d441e4b5d7512cc5c326c8668a120e048eda/tcpdump/print-chdlc.c"chdlc.h"chdlc_slarp_printconst cisco_slarpconst cisco_slarp *cisco_slarp *slarpsecminhrsdays(ndo, "SLARP (length: %u), ",length)SLARP (length: %u), SLARP_MIN_LEN*slarp&slarp->code(ndo, "request")(ndo, "reply %s/%s", ipaddr_string(ndo, &slarp->un.addr.addr), ipaddr_string(ndo, &slarp->un.addr.mask))(ndo, "reply %s/%s", getname(ndo, (const u_char *)(&slarp->un.addr.addr)), getname(ndo, (const u_char *)(&slarp->un.addr.mask)))&slarp->un.addr.addr&slarp->un.addr.mask(ndo, "keepalive: mineseen=0x%08x, yourseen=0x%08x, reliability=0x%04x", EXTRACT_32BITS(&slarp->un.keep.myseq), EXTRACT_32BITS(&slarp->un.keep.yourseq), EXTRACT_16BITS(&slarp->un.keep.rel))(ndo, "keepalive: mineseen=0x%08x, yourseen=0x%08x, reliability=0x%04x", ((uint32_t)(((uint32_t)(*((const uint8_t *)(&slarp->un.keep.myseq) + 0)) << 24) | ((uint32_t)(*((const uint8_t *)(&slarp->un.keep.myseq) + 1)) << 16) | ((uint32_t)(*((const uint8_t *)(&slarp->un.keep.myseq) + 2)) << 8) | ((uint32_t)(*((const uint8_t *)(&slarp->un.keep.myseq) + 3)) << 0))), ((uint32_t)(((uint32_t)(*((const uint8_t *)(&slarp->un.keep.yourseq) + 0)) << 24) | ((uint32_t)(*((const uint8_t *)(&slarp->un.keep.yourseq) + 1)) << 16) | ((uint32_t)(*((const uint8_t *)(&slarp->un.keep.yourseq) + 2)) << 8) | ((uint32_t)(*((const uint8_t *)(&slarp->un.keep.yourseq) + 3)) << 0))), ((uint16_t)(((uint16_t)(*((const uint8_t *)(&slarp->un.keep.rel) + 0)) << 8) | ((uint16_t)(*((const uint8_t *)(&slarp->un.keep.rel) + 1)) << 0))))&slarp->un.keep.myseq&slarp->un.keep.yourseq&slarp->un.keep.rel(ndo, ", link uptime=%ud%uh%um%us",days,hrs,min,sec)(ndo, "0x%02x unknown", EXTRACT_32BITS(&slarp->code))(ndo, "0x%02x unknown", ((uint32_t)(((uint32_t)(*((const uint8_t *)(&slarp->code) + 0)) << 24) | ((uint32_t)(*((const uint8_t *)(&slarp->code) + 1)) << 16) | ((uint32_t)(*((const uint8_t *)(&slarp->code) + 2)) << 8) | ((uint32_t)(*((const uint8_t *)(&slarp->code) + 3)) << 0))))SLARP_REQUESTrequestSLARP_REPLYreply %s/%sSLARP_KEEPALIVEkeepalive: mineseen=0x%08x, yourseen=0x%08x, reliability=0x%04xchar[64]SLARP_MAX_LEN, link uptime=%ud%uh%um%us0x%02x unknown(ndo, ", (trailing junk: %d bytes)", length - SLARP_MAX_LEN)(ndo, ", (trailing junk: %d bytes)", length - 18), (trailing junk: %d bytes)(ndo, "[|slarp]")[|slarp]chdlc_printproto(ndo, "%s, ethertype %s (0x%04x), length %u: ", tok2str(chdlc_cast_values, "0x%02x", p[0]), tok2str(ethertype_values, "Unknown", proto), proto, length)%s, ethertype %s (0x%04x), length %u: (ndo, "unknown CHDLC protocol (0x%04x)", proto)3452532821348873488865278unknown CHDLC protocol (0x%04x)(CHDLC_HDRLEN)chdlc_if_print(ndo, "[|chdlc]")[|chdlc]cisco_slarpuncodekeeprelyourseqmysequnicast"unicast"bcast"bcast"chdlc_cast_values/* uptime-stamp is optional *//*
		 * At least according to William "Chops" Westfield's
		 * message in
		 *
		 *	http://www.nethelp.no/net/cisco-hdlc.txt
		 *
		 * the address and mask aren't used in requests -
		 * they're just zero.
		 *//*
 * The fixed-length portion of a SLARP packet.
 *//* is the fudge byte set ? lets verify by spotting ISO headers *//* Standard CHDLC printer *//Users/owura/Repos/codeql_eval/proj_repos/the-tcpdump-group-tcpdump-commit-0f95d441e4b5d7512cc5c326c8668a120e048eda/tcpdump/print-cip.ccip_if_print(ndo, "[|cip]")const unsigned char[6]sizeof(rfcllc)RFC1483LLC_LEN[|cip]cip_print(ndo, "%d: ", length)%d: const unsigned char[]rfcllc/*
		 * LLC header is absent; treat it as just IP.
		 *//*
		 * LLC header is present.  Try to print it & higher layers.
		 *//*
 * This is the top level routine of the printer.  'p' points
 * to the LLC/SNAP or raw header of the packet, 'h->ts' is the timestamp,
 * 'h->len' is the length of the packet off the wire, and 'h->caplen'
 * is the number of bytes actually captured.
 *//*
	 * There is no MAC-layer header, so just print the length.
	 *//* OUI: EtherType *//* Ctrl: Unnumbered Information Command PDU *//* SSAP: non-ISO *//* DSAP: non-ISO *//*
 * Marko Kiiskila carnil@cs.tut.fi
 *
 * Tampere University of Technology - Telecommunications Laboratory
 *
 * Permission to use, copy, modify and distribute this
 * software and its documentation is hereby granted,
 * provided that both the copyright notice and this
 * permission notice appear in all copies of the software,
 * derivative works or modified versions, and any portions
 * thereof, that both notices appear in supporting
 * documentation, and that the use of this software is
 * acknowledged in any publications resulting from using
 * the software.
 *
 * TUT ALLOWS FREE USE OF THIS SOFTWARE IN ITS "AS IS"
 * CONDITION AND DISCLAIMS ANY LIABILITY OF ANY KIND FOR
 * ANY DAMAGES WHATSOEVER RESULTING FROM THE USE OF THIS
 * SOFTWARE.
 *
 *//Users/owura/Repos/codeql_eval/proj_repos/the-tcpdump-group-tcpdump-commit-0f95d441e4b5d7512cc5c326c8668a120e048eda/tcpdump/tcp.htcphdrtcp_seqth_urpth_sumth_winth_flagsth_offx2th_ackth_seqth_dportth_sportFTP_PORTRTSP_PORT_ALT8554RTSP_PORT554HTTP_PORT_ALT8080HTTP_PORTSMB_PORT445RPKI_RTR_PORT323MSDP_PORT639NFS_PORT2049BEEP_PORT10288PPTP_PORT1723OPENFLOW_PORT_IANA6653OPENFLOW_PORT_OLD6633NETBIOS_SSN_PORTBGP_PORTSMTP_PORTTELNET_PORTTCPOPT_TSTAMP_HDR(TCPOPT_NOP<<24|TCPOPT_NOP<<16|TCPOPT_TIMESTAMP<<8|TCPOLEN_TIMESTAMP)TCPOPT_EXPERIMENT2TCPOPT_MPTCPTCPOLEN_UTOTCPOPT_UTOTCPOPT_AUTHTCP_SIGLENTCPOLEN_SIGNATURETCPOPT_SIGNATURETCPOPT_CCECHOTCPOPT_CCNEWTCPOPT_CCTCPOLEN_TSTAMP_APPA(TCPOLEN_TIMESTAMP+2)TCPOLEN_TIMESTAMPTCPOPT_TIMESTAMPTCPOPT_ECHOREPLYTCPOPT_ECHOTCPOPT_SACKTCPOPT_SACKOKTCPOPT_WSCALETCPOLEN_MAXSEGTCPOPT_MAXSEGTCPOPT_NOPTCPOPT_EOLTH_CWRTH_ECNECHOTH_URGTH_ACKTH_PUSHTH_RSTTH_SYNTH_FINTH_OFF(th)(((th)->th_offx2 & 0xf0) >> 4)/* experimental headers (rfc4727) *//* MPTCP options *//* tcp user timeout (rfc5482) *//* Enhanced AUTH option *//* length of an option 19 digest *//* Keyed MD5 (rfc2385) *//* T/TCP CC options (rfc1644) *//* appendix A *//* timestamp (rfc1323) *//* echo (rfc1072) *//* selective ack (rfc2018) *//* selective ack ok (rfc2018) *//* window scale factor (rfc1323) *//* ECN Cwnd Reduced *//* ECN Echo *//* TCP flags *//* urgent pointer *//* checksum *//* window *//* data offset, rsvd *//* acknowledgement number *//*
 * TCP header.
 * Per RFC 793, September, 1981.
 *//*
 * Copyright (c) 1982, 1986, 1993
 *	The Regents of the University of California.  All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *	This product includes software developed by the University of
 *	California, Berkeley and its contributors.
 * 4. Neither the name of the University nor the names of its contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 *
 *	@(#)tcp.h	8.1 (Berkeley) 6/10/93
 *//Users/owura/Repos/codeql_eval/proj_repos/the-tcpdump-group-tcpdump-commit-0f95d441e4b5d7512cc5c326c8668a120e048eda/tcpdump/print-cnfp.c"tcp.h"cnfp_printconst nfhdrconst nfhdr *nfhdr *nhconst nfrecconst nfrec *nfrec *nrprotoent *pentnrecs&nh->ver_cnt42949017600xffff0000(ndo, "NetFlow v%x, %u.%03u uptime, %u.%09u, ", ver, EXTRACT_32BITS(&nh->msys_uptime)/1000, EXTRACT_32BITS(&nh->msys_uptime)%1000, EXTRACT_32BITS(&nh->utc_sec), EXTRACT_32BITS(&nh->utc_nsec))(ndo, "NetFlow v%x, %u.%03u uptime, %u.%09u, ", ver, ((uint32_t)(((uint32_t)(*((const uint8_t *)(&nh->msys_uptime) + 0)) << 24) | ((uint32_t)(*((const uint8_t *)(&nh->msys_uptime) + 1)) << 16) | ((uint32_t)(*((const uint8_t *)(&nh->msys_uptime) + 2)) << 8) | ((uint32_t)(*((const uint8_t *)(&nh->msys_uptime) + 3)) << 0)))/1000, ((uint32_t)(((uint32_t)(*((const uint8_t *)(&nh->msys_uptime) + 0)) << 24) | ((uint32_t)(*((const uint8_t *)(&nh->msys_uptime) + 1)) << 16) | ((uint32_t)(*((const uint8_t *)(&nh->msys_uptime) + 2)) << 8) | ((uint32_t)(*((const uint8_t *)(&nh->msys_uptime) + 3)) << 0)))%1000, ((uint32_t)(((uint32_t)(*((const uint8_t *)(&nh->utc_sec) + 0)) << 24) | ((uint32_t)(*((const uint8_t *)(&nh->utc_sec) + 1)) << 16) | ((uint32_t)(*((const uint8_t *)(&nh->utc_sec) + 2)) << 8) | ((uint32_t)(*((const uint8_t *)(&nh->utc_sec) + 3)) << 0))), ((uint32_t)(((uint32_t)(*((const uint8_t *)(&nh->utc_nsec) + 0)) << 24) | ((uint32_t)(*((const uint8_t *)(&nh->utc_nsec) + 1)) << 16) | ((uint32_t)(*((const uint8_t *)(&nh->utc_nsec) + 2)) << 8) | ((uint32_t)(*((const uint8_t *)(&nh->utc_nsec) + 3)) << 0))))NetFlow v%x, %u.%03u uptime, %u.%09u, &nh->msys_uptime&nh->utc_sec&nh->utc_nsec(ndo, "#%u, ", EXTRACT_32BITS(&nh->sequence))(ndo, "#%u, ", ((uint32_t)(((uint32_t)(*((const uint8_t *)(&nh->sequence) + 0)) << 24) | ((uint32_t)(*((const uint8_t *)(&nh->sequence) + 1)) << 16) | ((uint32_t)(*((const uint8_t *)(&nh->sequence) + 2)) << 8) | ((uint32_t)(*((const uint8_t *)(&nh->sequence) + 3)) << 0))))&nh->sequence#%u, (ndo, "%2u recs", nrecs)%2u recs(ndo, "\n  started %u.%03u, last %u.%03u", EXTRACT_32BITS(&nr->start_time)/1000, EXTRACT_32BITS(&nr->start_time)%1000, EXTRACT_32BITS(&nr->last_time)/1000, EXTRACT_32BITS(&nr->last_time)%1000)(ndo, "\n  started %u.%03u, last %u.%03u", ((uint32_t)(((uint32_t)(*((const uint8_t *)(&nr->start_time) + 0)) << 24) | ((uint32_t)(*((const uint8_t *)(&nr->start_time) + 1)) << 16) | ((uint32_t)(*((const uint8_t *)(&nr->start_time) + 2)) << 8) | ((uint32_t)(*((const uint8_t *)(&nr->start_time) + 3)) << 0)))/1000, ((uint32_t)(((uint32_t)(*((const uint8_t *)(&nr->start_time) + 0)) << 24) | ((uint32_t)(*((const uint8_t *)(&nr->start_time) + 1)) << 16) | ((uint32_t)(*((const uint8_t *)(&nr->start_time) + 2)) << 8) | ((uint32_t)(*((const uint8_t *)(&nr->start_time) + 3)) << 0)))%1000, ((uint32_t)(((uint32_t)(*((const uint8_t *)(&nr->last_time) + 0)) << 24) | ((uint32_t)(*((const uint8_t *)(&nr->last_time) + 1)) << 16) | ((uint32_t)(*((const uint8_t *)(&nr->last_time) + 2)) << 8) | ((uint32_t)(*((const uint8_t *)(&nr->last_time) + 3)) << 0)))/1000, ((uint32_t)(((uint32_t)(*((const uint8_t *)(&nr->last_time) + 0)) << 24) | ((uint32_t)(*((const uint8_t *)(&nr->last_time) + 1)) << 16) | ((uint32_t)(*((const uint8_t *)(&nr->last_time) + 2)) << 8) | ((uint32_t)(*((const uint8_t *)(&nr->last_time) + 3)) << 0)))%1000)&nr->start_time&nr->last_time"/%u", (EXTRACT_32BITS(&nr->masks) >> 24) & 0xff"/%u", (((uint32_t)(((uint32_t)(*((const uint8_t *)(&nr->masks) + 0)) << 24) | ((uint32_t)(*((const uint8_t *)(&nr->masks) + 1)) << 16) | ((uint32_t)(*((const uint8_t *)(&nr->masks) + 2)) << 8) | ((uint32_t)(*((const uint8_t *)(&nr->masks) + 3)) << 0))) >> 24) & 0xff&nr->masksasbufsizeof(asbuf)":%u", (EXTRACT_32BITS(&nr->asses) >> 16) & 0xffff":%u", (((uint32_t)(((uint32_t)(*((const uint8_t *)(&nr->asses) + 0)) << 24) | ((uint32_t)(*((const uint8_t *)(&nr->asses) + 1)) << 16) | ((uint32_t)(*((const uint8_t *)(&nr->asses) + 2)) << 8) | ((uint32_t)(*((const uint8_t *)(&nr->asses) + 3)) << 0))) >> 16) & 0xffff&nr->asses(ndo, "\n    %s%s%s:%u ", intoa(nr->src_ina.s_addr), buf, asbuf, EXTRACT_32BITS(&nr->ports) >> 16)(ndo, "\n    %s%s%s:%u ", intoa(nr->src_ina.s_addr), buf, asbuf, ((uint32_t)(((uint32_t)(*((const uint8_t *)(&nr->ports) + 0)) << 24) | ((uint32_t)(*((const uint8_t *)(&nr->ports) + 1)) << 16) | ((uint32_t)(*((const uint8_t *)(&nr->ports) + 2)) << 8) | ((uint32_t)(*((const uint8_t *)(&nr->ports) + 3)) << 0))) >> 16)&nr->ports"/%d", (EXTRACT_32BITS(&nr->masks) >> 16) & 0xff"/%d", (((uint32_t)(((uint32_t)(*((const uint8_t *)(&nr->masks) + 0)) << 24) | ((uint32_t)(*((const uint8_t *)(&nr->masks) + 1)) << 16) | ((uint32_t)(*((const uint8_t *)(&nr->masks) + 2)) << 8) | ((uint32_t)(*((const uint8_t *)(&nr->masks) + 3)) << 0))) >> 16) & 0xff":%u", EXTRACT_32BITS(&nr->asses) & 0xffff":%u", ((uint32_t)(((uint32_t)(*((const uint8_t *)(&nr->asses) + 0)) << 24) | ((uint32_t)(*((const uint8_t *)(&nr->asses) + 1)) << 16) | ((uint32_t)(*((const uint8_t *)(&nr->asses) + 2)) << 8) | ((uint32_t)(*((const uint8_t *)(&nr->asses) + 3)) << 0))) & 0xffff(ndo, "> %s%s%s:%u ", intoa(nr->dst_ina.s_addr), buf, asbuf, EXTRACT_32BITS(&nr->ports) & 0xffff)(ndo, "> %s%s%s:%u ", intoa(nr->dst_ina.s_addr), buf, asbuf, ((uint32_t)(((uint32_t)(*((const uint8_t *)(&nr->ports) + 0)) << 24) | ((uint32_t)(*((const uint8_t *)(&nr->ports) + 1)) << 16) | ((uint32_t)(*((const uint8_t *)(&nr->ports) + 2)) << 8) | ((uint32_t)(*((const uint8_t *)(&nr->ports) + 3)) << 0))) & 0xffff)(ndo, ">> %s\n    ", intoa(nr->nhop_ina.s_addr))&nr->proto_tos(ndo, "%u ", (EXTRACT_32BITS(&nr->proto_tos) >> 8) & 0xff)(ndo, "%u ", (((uint32_t)(((uint32_t)(*((const uint8_t *)(&nr->proto_tos) + 0)) << 24) | ((uint32_t)(*((const uint8_t *)(&nr->proto_tos) + 1)) << 16) | ((uint32_t)(*((const uint8_t *)(&nr->proto_tos) + 2)) << 8) | ((uint32_t)(*((const uint8_t *)(&nr->proto_tos) + 3)) << 0))) >> 8) & 0xff)(ndo, "%s ", pent->p_name)(ndo, "%s%s%s%s%s%s%s", flags & TH_FIN ? "F" : "", flags & TH_SYN ? "S" : "", flags & TH_RST ? "R" : "", flags & TH_PUSH ? "P" : "", flags & TH_ACK ? "A" : "", flags & TH_URG ? "U" : "", flags ? " " : "")(ndo, "%s%s%s%s%s%s%s", flags & 0x01 ? "F" : "", flags & 0x02 ? "S" : "", flags & 0x04 ? "R" : "", flags & 0x08 ? "P" : "", flags & 0x10 ? "A" : "", flags & 0x20 ? "U" : "", flags ? " " : "")"(%u<>%u encaps)", (EXTRACT_32BITS(&nr->masks) >> 8) & 0xff, (EXTRACT_32BITS(&nr->masks)) & 0xff"(%u<>%u encaps)", (((uint32_t)(((uint32_t)(*((const uint8_t *)(&nr->masks) + 0)) << 24) | ((uint32_t)(*((const uint8_t *)(&nr->masks) + 1)) << 16) | ((uint32_t)(*((const uint8_t *)(&nr->masks) + 2)) << 8) | ((uint32_t)(*((const uint8_t *)(&nr->masks) + 3)) << 0))) >> 8) & 0xff, (((uint32_t)(((uint32_t)(*((const uint8_t *)(&nr->masks) + 0)) << 24) | ((uint32_t)(*((const uint8_t *)(&nr->masks) + 1)) << 16) | ((uint32_t)(*((const uint8_t *)(&nr->masks) + 2)) << 8) | ((uint32_t)(*((const uint8_t *)(&nr->masks) + 3)) << 0)))) & 0xff(ndo, "tos %u, %u (%u octets) %s", EXTRACT_32BITS(&nr->proto_tos) & 0xff, EXTRACT_32BITS(&nr->packets), EXTRACT_32BITS(&nr->octets), buf)(ndo, "tos %u, %u (%u octets) %s", ((uint32_t)(((uint32_t)(*((const uint8_t *)(&nr->proto_tos) + 0)) << 24) | ((uint32_t)(*((const uint8_t *)(&nr->proto_tos) + 1)) << 16) | ((uint32_t)(*((const uint8_t *)(&nr->proto_tos) + 2)) << 8) | ((uint32_t)(*((const uint8_t *)(&nr->proto_tos) + 3)) << 0))) & 0xff, ((uint32_t)(((uint32_t)(*((const uint8_t *)(&nr->packets) + 0)) << 24) | ((uint32_t)(*((const uint8_t *)(&nr->packets) + 1)) << 16) | ((uint32_t)(*((const uint8_t *)(&nr->packets) + 2)) << 8) | ((uint32_t)(*((const uint8_t *)(&nr->packets) + 3)) << 0))), ((uint32_t)(((uint32_t)(*((const uint8_t *)(&nr->octets) + 0)) << 24) | ((uint32_t)(*((const uint8_t *)(&nr->octets) + 1)) << 16) | ((uint32_t)(*((const uint8_t *)(&nr->octets) + 2)) << 8) | ((uint32_t)(*((const uint8_t *)(&nr->octets) + 3)) << 0))), buf)&nr->packets&nr->octets
  started %u.%03u, last %u.%03u/%u:%u
    %s%s%s:%u > %s%s%s:%u >> %s
    %u %s%s%s%s%s%s%sFSAU(%u<>%u encaps)tos %u, %u (%u octets) %snfrecnfhdrpeer_nexthopmasksassesproto_tosportslast_timestart_timeoctetspacketsifacesnhop_inadst_inasrc_inautc_nsecutc_secmsys_uptimever_cnt/* tcp flags for tcp only *//*
	 * This is seconds since the UN*X epoch, and is followed by
	 * nanoseconds.  XXX - format it, rather than just dumping the
	 * raw seconds-since-the-Epoch.
	 *//* v6: IP address of the nexthop within the peer (FIB)*//* src,dst addr prefix; v6: encaps *//* v1: flags; v5: src,dst AS *//* proto, tos, pad, flags(v5) *//* src,dst ports *//* sys_uptime value *//* src,dst ifaces *//* v5 only *//* v5 flow sequence number *//* version [15], and # of records *//*
 * Copyright (c) 1998 Michael Shalayeff
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *	This product includes software developed by Michael Shalayeff.
 * 4. The name of the author may not be used to endorse or promote products
 *    derived from this software without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
 * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
 * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
 * IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
 * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
 * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
 * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
 * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
 * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 *//*	$OpenBSD: print-cnfp.c,v 1.2 1998/06/25 20:26:59 mickey Exp $	*//Users/owura/Repos/codeql_eval/proj_repos/the-tcpdump-group-tcpdump-commit-0f95d441e4b5d7512cc5c326c8668a120e048eda/tcpdump/print-dccp.c"ip.h"dccp_print_optionoptlen*optionsizeof(*option)*(option+1)sizeof(*(option+1))(ndo, "CCID option %u optlen too short", *option)(ndo, "%s optlen too short", tok2str(dccp_option_values, "Option %u", *option))CCID option %u optlen too short%s optlen too shortconst tok[17]tok[17]Option %u(ndo, "CCID option %u optlen goes past header length", *option)(ndo, "%s optlen goes past header length", tok2str(dccp_option_values, "Option %u", *option))CCID option %u optlen goes past header length%s optlen goes past header length(ndo, "CCID option %d", *option)(ndo, " %u", EXTRACT_16BITS(option + 2))(ndo, " %u", ((uint16_t)(((uint16_t)(*((const uint8_t *)(option + 2) + 0)) << 8) | ((uint16_t)(*((const uint8_t *)(option + 2) + 1)) << 0))))option + 2(ndo, " %u", EXTRACT_32BITS(option + 2))(ndo, " %u", ((uint32_t)(((uint32_t)(*((const uint8_t *)(option + 2) + 0)) << 24) | ((uint32_t)(*((const uint8_t *)(option + 2) + 1)) << 16) | ((uint32_t)(*((const uint8_t *)(option + 2) + 2)) << 8) | ((uint32_t)(*((const uint8_t *)(option + 2) + 3)) << 0))))(ndo, "%s", tok2str(dccp_option_values, "Option %u", *option))(ndo, " optlen too short")(ndo, " %s", dccp_feature_nums[*(option + 2)])(ndo, " %d", *(option + 3 + i))(ndo, " 0x")(ndo, "%02x", *(option + 2 + i))(ndo, " %d", *(option + 2 + i))(ndo, " optlen != 4")(ndo, " optlen != 4 or 6")CCID option %d %u optlen too shortconst char *[10]char *[10] 0xoption optlen != 4 optlen != 4 or 6dccp_printconst dccp_hdrconst dccp_hdr *dccp_hdr *dhconst ipconst ip *ip *sportdportfixed_hdrlen(ndo, "[Invalid packet|dccp]")[Invalid packet|dccp](ndo, "truncated-dccp - %u bytes missing!", len - (u_int)sizeof(struct dccp_hdr))sizeof(struct dccp_hdr)truncated-dccp - %u bytes missing!(ndo, "truncated-dccp - %u bytes missing!", len - fixed_hdrlen)*dh&dh->dccph_sport&dh->dccph_dport(ndo, "%s.%d > %s.%d: ", ipaddr_string(ndo, &ip->ip_src), sport, ipaddr_string(ndo, &ip->ip_dst), dport)(ndo, "%s.%d > %s.%d: ", getname(ndo, (const u_char *)(&ip->ip_src)), sport, getname(ndo, (const u_char *)(&ip->ip_dst)), dport)%s.%d > %s.%d: &ip->ip_src&ip->ip_dst(ndo, " %d", len - hlen)(ndo, "dccp [bad hdr length %u - too long, > %u]", hlen, len)dccp [bad hdr length %u - too long, > %u](ndo, "CCVal %d, CsCov %d, ", DCCPH_CCVAL(dh), DCCPH_CSCOV(dh))(ndo, "CCVal %d, CsCov %d, ", (((dh)->dccph_ccval_cscov >> 4) & 0xF), (((dh)->dccph_ccval_cscov) & 0xF))CCVal %d, CsCov %d, &dh->dccph_checksum(ndo, "cksum 0x%04x ", dccp_sum)(ndo, "(incorrect -> 0x%04x), ",in_cksum_shouldbe(dccp_sum, sum))(ndo, "(correct), ")dccp_sumcksum 0x%04x (incorrect -> 0x%04x), (correct), (ndo, "truncated-dccp request - %u bytes missing!", len - fixed_hdrlen)*dhrsizeof(*dhr)(ndo, "request (service=%d) ", EXTRACT_32BITS(&dhr->dccph_req_service))(ndo, "request (service=%d) ", ((uint32_t)(((uint32_t)(*((const uint8_t *)(&dhr->dccph_req_service) + 0)) << 24) | ((uint32_t)(*((const uint8_t *)(&dhr->dccph_req_service) + 1)) << 16) | ((uint32_t)(*((const uint8_t *)(&dhr->dccph_req_service) + 2)) << 8) | ((uint32_t)(*((const uint8_t *)(&dhr->dccph_req_service) + 3)) << 0))))&dhr->dccph_req_service(ndo, "truncated-dccp response - %u bytes missing!", len - fixed_hdrlen)(ndo, "response (service=%d) ", EXTRACT_32BITS(&dhr->dccph_resp_service))(ndo, "response (service=%d) ", ((uint32_t)(((uint32_t)(*((const uint8_t *)(&dhr->dccph_resp_service) + 0)) << 24) | ((uint32_t)(*((const uint8_t *)(&dhr->dccph_resp_service) + 1)) << 16) | ((uint32_t)(*((const uint8_t *)(&dhr->dccph_resp_service) + 2)) << 8) | ((uint32_t)(*((const uint8_t *)(&dhr->dccph_resp_service) + 3)) << 0))))&dhr->dccph_resp_service(ndo, "data ")(ndo, "truncated-dccp ack - %u bytes missing!", len - fixed_hdrlen)(ndo, "ack ")(ndo, "truncated-dccp dataack - %u bytes missing!", len - fixed_hdrlen)(ndo, "dataack ")(ndo, "truncated-dccp closereq - %u bytes missing!", len - fixed_hdrlen)(ndo, "closereq ")(ndo, "truncated-dccp close - %u bytes missing!", len - fixed_hdrlen)(ndo, "close ")(ndo, "truncated-dccp reset - %u bytes missing!", len - fixed_hdrlen)(ndo, "reset (code=%s) ", dccp_reset_code(dhr->dccph_reset_code))(ndo, "truncated-dccp sync - %u bytes missing!", len - fixed_hdrlen)(ndo, "sync ")(ndo, "truncated-dccp syncack - %u bytes missing!", len - fixed_hdrlen)(ndo, "syncack ")(ndo, "invalid ")DCCP_PKT_REQUESTdccp_hdr_request *dhrtruncated-dccp request - %u bytes missing!data2request (service=%d) DCCP_PKT_RESPONSEdccp_hdr_response *truncated-dccp response - %u bytes missing!response (service=%d) DCCP_PKT_DATAdata DCCP_PKT_ACKtruncated-dccp ack - %u bytes missing!ack DCCP_PKT_DATAACKtruncated-dccp dataack - %u bytes missing!dataack DCCP_PKT_CLOSEREQtruncated-dccp closereq - %u bytes missing!closereq DCCP_PKT_CLOSEtruncated-dccp close - %u bytes missing!close DCCP_PKT_RESETdccp_hdr_reset *truncated-dccp reset - %u bytes missing!reset (code=%s) DCCP_PKT_SYNCtruncated-dccp sync - %u bytes missing!sync DCCP_PKT_SYNCACKtruncated-dccp syncack - %u bytes missing!syncack invalid (ndo, "seq %" PRIu64, dccp_seqno(bp))(ndo, "seq %" "ll" "u", dccp_seqno(bp))seq %llu(ndo, " <") <dccp_print_ack_noackpackno*ackpackp + 2ackp + 1(ndo, "(ack=%" PRIu64 ") ", ackno)(ndo, "(ack=%" "ll" "u" ") ", ackno)(ack=%llu) dccp_basic_hdr_lensizeof(struct dccp_hdr_ext)dccp_seqnoseqnodhx->dccph_seqdh->dccph_seqconst dccp_hdr_extconst dccp_hdr_ext *dccp_hdr_ext *dhxdccp_reset_code__DCCP_RESET_CODE_LASTinvalid"invalid"const char *[12]char *[12]dccp_cksumdccp_csum_coveragecovdccp_reset_codesDCCP_RESET_CODE_UNSPECIFIEDDCCP_RESET_CODE_CLOSEDDCCP_RESET_CODE_ABORTEDDCCP_RESET_CODE_NO_CONNECTIONDCCP_RESET_CODE_PACKET_ERRORDCCP_RESET_CODE_OPTION_ERRORDCCP_RESET_CODE_MANDATORY_ERRORDCCP_RESET_CODE_CONNECTION_REFUSEDDCCP_RESET_CODE_BAD_SERVICE_CODEDCCP_RESET_CODE_TOO_BUSYDCCP_RESET_CODE_BAD_INIT_COOKIEDCCP_RESET_CODE_AGGRESSION_PENALTYdccp_pkt_typeDCCP_PKT_INVALIDdccp_hdr_resetdccp_hdr_responsedccp_hdr_requestdccp_hdr_extdccp_hdrdccph_reset_datadccph_reset_codedccph_reset_ackdccph_resp_servicedccph_resp_ackdccph_req_servicedccph_seqdccph_xtrdccph_checksumdccph_ccval_cscovdccph_doffdccph_dportdccph_sportnop"nop"mandatory"mandatory"slowreceiver"slowreceiver"change_l"change_l"confirm_l"confirm_l"change_r"change_r"confirm_r"confirm_r"initcookie"initcookie"ndp_count"ndp_count"ack_vector0"ack_vector0"ack_vector1"ack_vector1"data_dropped"data_dropped""timestamp"timestamp_echo"timestamp_echo"elapsed_time"elapsed_time"data_checksum"data_checksum"dccp_option_values"reserved"ccid"ccid"allow_short_seqno"allow_short_seqno"sequence_window"sequence_window"ecn_incapable"ecn_incapable"ack_ratio"ack_ratio"send_ack_vector"send_ack_vector"send_ndp_count"send_ndp_count"minimum checksum coverage"minimum checksum coverage"check data checksum"check data checksum"dccp_feature_numsunspecified"unspecified"closed"closed"aborted"aborted"no_connection"no_connection"packet_error"packet_error"option_error"option_error"mandatory_error"mandatory_error"connection_refused"connection_refused"bad_service_code"bad_service_code"too_busy"too_busy"bad_init_cookie"bad_init_cookie"aggression_penalty"aggression_penalty"[|dccp]"[|dccp]"DCCPH_TYPE(dh)(((dh)->dccph_xtr >> 1) & 0xF)DCCPH_X(dh)((dh)->dccph_xtr & 1)DCCPH_CSCOV(dh)(((dh)->dccph_ccval_cscov) & 0xF)DCCPH_CCVAL(dh)(((dh)->dccph_ccval_cscov >> 4) & 0xF)/* process options *//* checksum calculation *//* other variables in generic header *//* get the length of the generic header *//* make sure we have enough data to look at the X bit *//**
 * dccp_print - show dccp packet
 * @bp - beginning of dccp packet
 * @data2 - beginning of enclosing
 * @len - lenght of ip packet
 *//* always 8 bytes *//**
 * struct dccp_hdr_reset - Unconditionally shut down a connection
 *
 * @dccph_resp_ack - 48 bit ack number
 * @dccph_reset_service - Echoes the Service Code on a received DCCP-Request
 *//**
 * struct dccp_hdr_response - Conection initiation response header
 *
 * @dccph_resp_ack - 48 bit ack number, contains GSR
 * @dccph_resp_service - Echoes the Service Code on a received DCCP-Request
 *//**
 * struct dccp_hdr_request - Conection initiation request header
 *
 * @dccph_req_service - Service to which the client app wants to connect
 *//**
 * struct dccp_hdr_ext - generic part of DCCP packet header, with a 48-bit
 * sequence number
 *
 * @dccph_sport - Relevant port on the endpoint that sent this packet
 * @dccph_dport - Relevant port on the other endpoint
 * @dccph_doff - Data Offset from the start of the DCCP header, in 32-bit words
 * @dccph_ccval - Used by the HC-Sender CCID
 * @dccph_cscov - Parts of the packet that are covered by the Checksum field
 * @dccph_checksum - Internet checksum, depends on dccph_cscov
 * @dccph_x - 0 = 24 bit sequence number, 1 = 48
 * @dccph_type - packet type, see DCCP_PKT_ prefixed macros
 * @dccph_seq - 48-bit sequence number
 *//**
 * struct dccp_hdr - generic part of DCCP packet header, with a 24-bit
 * sequence number
 *
 * @dccph_sport - Relevant port on the endpoint that sent this packet
 * @dccph_dport - Relevant port on the other endpoint
 * @dccph_doff - Data Offset from the start of the DCCP header, in 32-bit words
 * @dccph_ccval - Used by the HC-Sender CCID
 * @dccph_cscov - Parts of the packet that are covered by the Checksum field
 * @dccph_checksum - Internet checksum, depends on dccph_cscov
 * @dccph_x - 0 = 24 bit sequence number, 1 = 48
 * @dccph_type - packet type, see DCCP_PKT_ prefixed macros
 * @dccph_seq - 24-bit sequence number
 *//*
 * Copyright (C) Arnaldo Carvalho de Melo 2004
 * Copyright (C) Ian McDonald 2005
 * Copyright (C) Yoshifumi Nishida 2005
 *
 * This software may be distributed either under the terms of the
 * BSD-style license that accompanies tcpdump or the GNU GPL version 2
 *//Users/owura/Repos/codeql_eval/proj_repos/the-tcpdump-group-tcpdump-commit-0f95d441e4b5d7512cc5c326c8668a120e048eda/tcpdump/print-decnet.csizarea64512AREAMASKAREASHIFTNODEMASK00.0000"00.0000""00.0000")sizeof("00.0000")dnnum_string: malloc"dnnum_string: malloc""%d.%d", area, nodeprint_reason(ndo, "%s ", tok2str(reason2str, "reason-%d", reason))const tok[23]tok[23]reason-%dprint_nspconst nsphdrconst nsphdr *nsphdr *nsphpsizeof(struct nsphdr)*nsphpsizeof(*nsphp)nsphp->nh_flagsnsphp->nh_dstnsphp->nh_src(ndo, "data %d>%d ", src, dst)shp->sh_seq[0]sizeof(shp->sh_seq[0])(ndo, "nak %d ", ack & SGQ_MASK)(ndo, "nak %d ", ack & 07777)(ndo, "ack %d ", ack & SGQ_MASK)(ndo, "ack %d ", ack & 07777)shp->sh_seq[1]sizeof(shp->sh_seq[1])(ndo, "onak %d ", ack & SGQ_MASK)(ndo, "onak %d ", ack & 07777)(ndo, "oack %d ", ack & SGQ_MASK)(ndo, "oack %d ", ack & 07777)shp->sh_seq[2]sizeof(shp->sh_seq[2])(ndo, "seg %d ", ack & SGQ_MASK)(ndo, "seg %d ", ack & 07777)(ndo, "intr ")(ndo, "nakdat %d ", ack & SGQ_MASK)(ndo, "nakdat %d ", ack & 07777)(ndo, "ackdat %d ", ack & SGQ_MASK)(ndo, "ackdat %d ", ack & 07777)(ndo, "link-service %d>%d ", src, dst)*lsmpsizeof(*lsmp)lsmp->ls_lsflagslsmp->ls_fcval(ndo, "dat seg count %d ", fcval)(ndo, "donotsend-data ")(ndo, "send-data ")(ndo, "reserved-fcmod? %x", lsflags)(ndo, "intr req count %d ", fcval)(ndo, "reserved-fcval-int? %x", lsflags)(ndo, "reserved-subtype? %x %d > %d", flags, src, dst)(ndo, "data-ack %d>%d ", src, dst)*ampsizeof(*amp)amp->ak_acknum[0]amp->ak_acknum[1](ndo, "ils-ack %d>%d ", src, dst)sizeof(amp->ak_acknum[1])(ndo, "conn-ack %d", dst)(ndo, "reserved-acktype? %x %d > %d", flags, src, dst)(ndo, "conn-initiate ")(ndo, "retrans-conn-initiate ")(ndo, "%d>%d ", src, dst)*cimpsizeof(*cimp)cimp->ci_servicescimp->ci_infocimp->ci_segsize(ndo, "seg ")(ndo, "msg ")(ndo, "crypt ")(ndo, "ver 3.2 ")(ndo, "ver 3.1 ")(ndo, "ver 4.0 ")(ndo, "ver 4.1 ")(ndo, "segsize %d ", segsize)(ndo, "conn-confirm %d>%d ", src, dst)*ccmpsizeof(*ccmp)ccmp->cc_servicesccmp->cc_infoccmp->cc_segsizeccmp->cc_optlen(ndo, "optlen %d ", optlen)(ndo, "disconn-initiate %d>%d ", src, dst)*dimpsizeof(*dimp)dimp->di_reasondimp->di_optlen(ndo, "disconn-confirm %d>%d ", src, dst)*dcmpsizeof(*dcmp)dcmp->dc_reason(ndo, "reserved-ctltype? %x %d > %d", flags, src, dst)(ndo, "reserved-type? %x %d > %d", flags, src, dst)NSP_TYPEMASKMFT_DATANSP_SUBMASKMFS_BOMMFS_MOMMFS_EOMdata %d>%d seghdr *shpackdata_offsizeof(struct minseghdr)word[3]unsigned char[3][2]word *SGQ_ACKSGQ_NAKnak %d ack %d sizeof(short)40960SGQ_OACK45056SGQ_ONAKonak %d oack %d seg %d MFS_ILSMFS_INTintr nsppnsplennakdat %d ackdat %d link-service %d>%d lsmsg *lsmpsizeof(struct seghdr)lsflagsfcvalsizeof(struct lsmsg)sizeof(struct seghdr) + sizeof(struct lsmsg)LSI_MASKLSI_DATAdat seg count %d LSM_MASKLSM_NOCHANGELSM_DONOTSENDdonotsend-data LSM_SENDsend-data reserved-fcmod? %xLSI_INTRintr req count %d reserved-fcval-int? %xreserved-subtype? %x %d > %dMFT_ACKMFS_DACKdata-ack %d>%d ackmsg *ampsizeof(struct ackmsg)word[2]unsigned char[2][2]MFS_IACKils-ack %d>%d MFS_CACKconn-ack %dreserved-acktype? %x %d > %dMFT_CTLMFS_CIMFS_RCIconn-initiate retrans-conn-initiate %d>%d cimsg *cimpservicesinfosegsizesizeof(struct cimsg)COS_MASKCOS_NONECOS_SEGMENTseg COS_MESSAGEmsg COS_CRYPTSERcrypt COI_MASKCOI_32ver 3.2 COI_31ver 3.1 COI_40ver 4.0 COI_41ver 4.1 segsize %d MFS_CCconn-confirm %d>%d ccmsg *ccmpsizeof(struct ccmsg)optlen %d MFS_DIdisconn-initiate %d>%d dimsg *dimpsizeof(struct dimsg)MFS_DCdisconn-confirm %d>%d dcmsg *dcmpreserved-ctltype? %x %d > %dreserved-type? %x %d > %dprint_elistprint_i_infontypeII_TYPEMASK(ndo, "reserved-ntype? ")(ndo, "l2rout ")(ndo, "l1rout ")(ndo, "endnode ")reserved-ntype? II_L2ROUTl2rout II_L1ROUTl1rout II_ENDNODEendnode (ndo, "verif ")II_VERIFverif (ndo, "nomcast ")II_NOMCASTnomcast (ndo, "blo ")II_BLOCKblo print_l2_routes*rp3 * sizeof(short)rp(ndo, "{areas %d-%d cost %d hops %d} ", area, area + count, RI_COST(info), RI_HOPS(info))(ndo, "{areas %d-%d cost %d hops %d} ", area, area + count, ((info)&0777), (((info)>>10)&037))(3 * sizeof(short)){areas %d-%d cost %d hops %d} 511print_l1_routes(ndo, "{ids %d-%d cost %d hops %d} ", id, id + count, RI_COST(info), RI_HOPS(info))(ndo, "{ids %d-%d cost %d hops %d} ", id, id + count, ((info)&0777), (((info)>>10)&037)){ids %d-%d cost %d hops %d} print_t_infoTI_L2ROUTTI_L1ROUTTI_ENDNODETI_VERIFTI_BLOCKprint_decnet_ctlmsgconst routehdrconst routehdr *routehdr *rhp->rh_short.sh_flagsmflagscontrolmsg *cmpblksizeecouecohellootherverssrcearteapriorityrhpx(ndo, "init ")cmp->cm_initsizeof(cmp->cm_init)cmp->cm_init.in_srccmp->cm_init.in_infocmp->cm_init.in_blksizecmp->cm_init.in_verscmp->cm_init.in_ecocmp->cm_init.in_uecocmp->cm_init.in_hello(ndo, "src %sblksize %d vers %d eco %d ueco %d hello %d", dnaddr_string(ndo, src), blksize, vers, eco, ueco, hello)(ndo, "verification ")cmp->cm_versizeof(cmp->cm_ver)cmp->cm_ver.ve_srccmp->cm_ver.ve_fcnval(ndo, "src %s fcnval %o", dnaddr_string(ndo, src), other)(ndo, "test ")cmp->cm_testsizeof(cmp->cm_test)cmp->cm_test.te_srccmp->cm_test.te_data(ndo, "src %s data %o", dnaddr_string(ndo, src), other)(ndo, "lev-1-routing ")cmp->cm_l1rousizeof(cmp->cm_l1rou)cmp->cm_l1rou.r1_src(ndo, "src %s ", dnaddr_string(ndo, src))(ndo, "lev-2-routing ")cmp->cm_l2routsizeof(cmp->cm_l2rout)cmp->cm_l2rout.r2_src(ndo, "router-hello ")cmp->cm_rhellosizeof(cmp->cm_rhello)cmp->cm_rhello.rh_verscmp->cm_rhello.rh_ecocmp->cm_rhello.rh_ueco(char *)&srcea(char *)&(cmp->cm_rhello.rh_src), sizeof(srcea)srcea.dne_remote.dne_nodeaddrcmp->cm_rhello.rh_infocmp->cm_rhello.rh_blksizecmp->cm_rhello.rh_prioritycmp->cm_rhello.rh_hello(ndo, "vers %d eco %d ueco %d src %s blksize %d pri %d hello %d", vers, eco, ueco, dnaddr_string(ndo, src), blksize, priority, hello)(ndo, "endnode-hello ")cmp->cm_ehellosizeof(cmp->cm_ehello)cmp->cm_ehello.eh_verscmp->cm_ehello.eh_ecocmp->cm_ehello.eh_ueco(char *)&(cmp->cm_ehello.eh_src), sizeof(srcea)cmp->cm_ehello.eh_infocmp->cm_ehello.eh_blksize(char *)&rtea(char *)&(cmp->cm_ehello.eh_router), sizeof(rtea)rtea.dne_remote.dne_nodeaddrcmp->cm_ehello.eh_hellocmp->cm_ehello.eh_data(ndo, "vers %d eco %d ueco %d src %s blksize %d rtr %s hello %d data %o", vers, eco, ueco, dnaddr_string(ndo, src), blksize, dnaddr_string(ndo, dst), hello, other)(ndo, "unknown control message")(u_char *)rhpmin(length, caplen)((length)>(caplen)?(caplen):(length))RMF_CTLMASKRMF_INITinit sizeof(struct initmsg)initmsg *src %sblksize %d vers %d eco %d ueco %d hello %delprhpRMF_VERverification sizeof(struct verifmsg)verifmsg *src %s fcnval %oRMF_TESTtest sizeof(struct testmsg)testmsg *src %s data %oRMF_L1ROUTlev-1-routing sizeof(struct l1rout)l1rout *src %s RMF_L2ROUTlev-2-routing sizeof(struct l2rout)l2rout *RMF_RHELLOrouter-hello sizeof(struct rhellomsg)rhellomsg *etheraddr *etheraddress *vers %d eco %d ueco %d src %s blksize %d pri %d hello %dRMF_EHELLOendnode-hello sizeof(struct ehellomsg)ehellomsg *vers %d eco %d ueco %d src %s blksize %d rtr %s hello %d data %ounknown control messagedecnet_printhopspktlensizeof(struct shorthdr)sizeof(rhp->rh_short.sh_flags)const byteunsigned char[1]const byte *unsigned char(*)[1](ndo, "[pad:%d] ", padlen)ap[sizeof(short)]padlenRMF_PADRMF_PADMASK[pad:%d] (ndo, "future-version-decnet")RMF_FVERfuture-version-decnetRMF_CTLMSGrhp->rh_longsizeof(rhp->rh_long)rhp->rh_long.lg_dst.dne_remote.dne_nodeaddrrhp->rh_long.lg_src.dne_remote.dne_nodeaddrrhp->rh_long.lg_visitsrhp->rh_shortsizeof(rhp->rh_short)rhp->rh_short.sh_dstrhp->rh_short.sh_srcrhp->rh_short.sh_visits(ndo, "unknown message flags under mask")(u_char *)apRMF_MASKRMF_LONGsizeof(struct longhdr)const longhdrconst longhdr *longhdr *sizeof(short) + sizeof(struct longhdr)RMF_SHORTconst shorthdrconst shorthdr *shorthdr *VIS_MASKsizeof(short) + sizeof(struct shorthdr)unknown message flags under mask(ndo, "%s > %s %d ", dnaddr_string(ndo, src), dnaddr_string(ndo, dst), pktlen)%s > %s %d (ndo, "RQR ")(ndo, "RTS ")(ndo, "IE ")(ndo, "%d hops ", hops)RMF_RQRRQR RMF_RTSRTS RMF_IEIE %d hops dnet_htoadn_naddr *dcmsgdimsgcnmsgccmsgcimsgciackmsgminackmsgackmsglsmsgminseghdrseghdrnsphdrcontrolmsgehellomsgrhellomsgl2routl1routtestmsgverifmsginitmsginitmsgIIIroutehdrlonghdrshorthdrdn_naddretheraddretheraddresslongwordworduint8_t[1]rtentrymbufdc_reasondc_srcdc_dstdc_flagsdi_optlendi_reasondi_srcdi_dstdi_flagscn_segsizecn_infocn_servicescn_srccn_dstcn_flagscc_optlencc_segsizecc_infocc_servicescc_srccc_dstcc_flagsci_segsizeci_infoci_servicesci_srcci_dstci_flagsck_dstck_flagsmk_acknummk_srcmk_dstmk_flagsak_acknumak_srcak_dstak_flagsls_fcvalls_lsflagsms_seqms_srcms_dstms_flagssh_seqsh_srcsh_dstsh_flagsnh_srcnh_dstnh_flagscm_ehellocm_rhellocm_l2routcm_l1roucm_testcm_vercm_initeh_dataeh_mpdeh_helloeh_routerbyte[8]unsigned char[8][1]eh_seedeh_areaeh_blksizeeh_infoeh_srceh_uecoeh_ecoeh_verseh_flagsrh_mpdrh_hellorh_arearh_priorityrh_blksizerh_inforh_srcrh_uecorh_ecorh_versrh_flagsr2_rsvdr2_srcr2_flagsr1_rsvdr1_srcr1_flagste_datate_srcte_flagsve_fcnvalve_srcve_flagsin_rsvdin_helloin_uecoin_ecoin_versin_blksizein_infoin_srcin_flagsinIII_rsvdinIII_uecoinIII_ecoinIII_versinIII_blksizeinIII_infoinIII_srcinIII_flagsrh_longrh_shortlg_ptlg_servicelg_visitslg_nextl2lg_srclg_ssarealg_sarealg_dstlg_dsarealg_darealg_flagssh_visitsuint8_t[20]unsigned char[20]DN_MAXADDLa_addra_lendne_remotedne_addrdne_nodeaddrdne_hiordUC_OBJREJECTobject rejected connect"object rejected connect"UC_RESOURCESinsufficient resources"insufficient resources"UC_NOSUCHNODEunrecognized node name"unrecognized node name"DI_SHUTnode is shutting down"node is shutting down"UC_NOSUCHOBJunrecognized object"unrecognized object"UC_INVOBJFORMATinvalid object name format"invalid object name format"UC_OBJTOOBUSYobject too busy"object too busy"DI_PROTOCOLprotocol error discovered"protocol error discovered"DI_TPAthird party abort"third party abort"UC_USERABORTuser abort"user abort"UC_INVNODEFORMATinvalid node name format"invalid node name format"UC_LOCALSHUTlocal node shutting down"local node shutting down"DI_LOCALRESRCinsufficient local resources"insufficient local resources"DI_REMUSERRESRCinsufficient remote user resources"insufficient remote user resources"UC_ACCESSREJECTinvalid access control information"invalid access control information"DI_BADACCNTbad ACCOUNT information"bad ACCOUNT information"UC_NORESPONSEno response from object"no response from object"UC_UNREACHABLEnode unreachable"node unreachable"DC_NOLINKno link terminate"no link terminate"DC_COMPLETEdisconnect complete"disconnect complete"DI_BADIMAGEbad image data in connect"bad image data in connect"DI_SERVMISMATCHcryptographic service mismatch"cryptographic service mismatch"reason2str[|decnet]"[|decnet]"UC_NETWORKABORTUC_REMOTESHUTUC_USERDISCONNECTDI_UNREACHABLEDI_TIMEDOUTDI_CONNECTABORTDI_BADACCESSDI_ABORTDI_REMRESRCDI_INVDESTDI_NOUSERDI_NOERRORDC_NORESOURCESMNU_UICPROXYMNU_INVKPROXYMNU_USRDATAMNU_ACCESSMNU_20040MNU_10000MNU_MASKCOS_DEFAULT02001004014LSI_INTM037703SGQ_EOM0100000SGQ_DELAY010000SGQ_OTHER020000SGQ_MASK0777701300000120000011000001400100060MFS_NOPNSP_SUBSHFT0160RI_HOPS(x)(((x)>>10)&037)RI_COST(x)((x)&0777)TESTLENTESTDATA02520201P3_UECOP3_ECOP3_VERSVE_UECOVE_ECOVE_VERS015013011070501707701770200017770176000HIORD0x000400aaHAVE_NETDNET_DNETDB_HWIN32PRINT_NSPDATAHAVE_NETDNET_DNETDB_H_DNET_HTOAHAVE_DNET_HTOA/* punt *//* ackdat field *//* acknum field *//* ackoth field *//* Not enough examples available for me to debug this *//* seems to be bogus from here on *//* The last short is a checksum *//*seed*//* is it a control message? *//* pad bytes of some sort in front of message *//* Forwards *//* reason code *//* source link address *//* destination link address *//* message flags *//* disconnect confirm message *//* optional data length *//* disconnect initiate message *//* maximum segment size *//* information *//* requested services *//* generic connect message *//* connect confirm message *//* destination link address (0) *//* connect initiate message *//* connect acknowledgement message *//* minimum acknowledgement message *//* acknowledgement numbers *//* acknowledgement message *//* flow control value *//* link service flags *//* link service message (after hdr) *//* minimum data segment header *//* sequence numbers *//* data segment header *//* general nsp header *//*
 * NSP message formats.
 *//* node unreachable *//* no response from object *//* invalid access control information *//* local node shutting down *//* invalid node name format *//* user abort *//* network abort *//* object too busy *//* invalid object name format *//* unrecognized object *//* remote node shutting down *//* unrecognized node name *//* insufficient resources (local or remote) *//* user disconnect *//* object rejected connect *//* cryptographic service mismatch *//* bad image data in connect *//* local timers expired due to ... *//* remote node or user crashed *//* connect request cancelled *//* bad ACCOUNT information *//* bad access control information *//* insufficient remote user resources *//* insufficient local resources *//* protocol error discovered *//* third party abort *//* insufficient remote resources *//* invalid end user destination *//* destination end user does not exist *//* node is shutting down *//* disconnect complete reason code *//* no link terminate reason code *//* no resource reason code *//* use uic-based proxy *//* invoke proxy field present *//* user data field present *//* access control present *//* session V2.0 *//* session V1.0 *//* mask for session control version *//* version 4.1 *//* version 4.0 *//* version 3.1 *//* version 3.2 *//* mask for version field *//* default value for field *//* cryptographic services requested *//* message flow control *//* segment flow control *//* no flow control *//* mask for flow control field *//* funny marker for int. message *//* interrupt request count *//* data segment or message count *//* mask for interpretation field *//* send data *//* do not send data *//* no change *//* mask for modifier field *//* pseudo flag for end-of-message *//* ack delay flag *//* other channel qualifier *//* mask to isolate seq # *//* other channel negative ack *//* other channel ack *//* negative ack *//* ack *//* retransmitted connect initiate *//* disconnect confirm *//* disconnect initiate *//* connect confirm *//* connect initiate *//* no operation *//* connect acknowledgement *//* I/LS acknowledgement *//* data acknowledgement *//* interrupt message *//* end of message (data) *//* middle of message (data) *//* beginning of message (data) *//* data or I/LS indicator *//* control message *//* data message *//* shift to move subtype code *//* mask to isolate subtype code *//* mask to isolate type code *//*
 * NSP protocol fields and values.
 *//* Macros for decoding routing-info fields *//* endnode hello message *//* router hello message *//* level 2 routing message *//* level 1 routing message *//* hello and test message *//* verification message *//* initialization message *//* test data image field *//* (reserved) *//* hello timer *//* designated router *//* verification seed *//* area (reserved) *//* maximum data link block size *//* routing layer information *//* source id *//* user ECO number *//* ECO number *//* version number *//* route flags *//* router's priority *//* reserved field *//* source node address *//* function value image field *//* reserved image field *//* phase III initialization message *//*
 * Define control message formats.
 *//* length of transmitted test data *//* test data bytes *//* mask for node type *//* blocking requested *//* no multicast traffic accepted *//* verification required *//* endnode *//* level 1 router *//* level 2 router *//* user ECO number (0) *//* ECO number (3) *//* phase III version number (1) *//* version number (2) *//* control message indicator *//* mask for message type *//*
 * 2. Control packet formats.
 *//* visit field mask *//* pad field mask *//* pad field *//* future version flag *//* RMR_RQR *//* intra-ethernet packet *//* returning to sender *//* request return to sender *//* long message format *//* short message format *//*
 * Define the values of various fields in the protocol messages.
 *
 * 1. Data packet formats.
 *//* long route header *//* short route header *//* protocol type (reserved) *//* service class (reserved) *//* visit count *//* next level 2 router (reserved) *//* source subarea (reserved) *//* source area (reserved) *//* destination id *//* destination subarea (reserved) *//* destination area (reserved) *//* destination node address *//*
 * Define long and short header formats.
 *//* address as bytes *//* length of address *//* max size of DECnet address *//* mask for node address field *//* bit-offset for area field *//* mask for area field *//* high 32-bits of address (swapped) *//* Ethernet address *//* DECnet node address *//* DECnet HIORD prefix *//* full ethernet address *//*
 * Definitions for DECNET Phase IV protocol headers
 *//* 4 bytes field *//* 2 byte field *//* WIN32 *//* single byte field *//*
 * the keyword 'byte' generates conflicts in Windows
 *//*
 * Copyright (c) 1992, 1993, 1994, 1995, 1996, 1997
 *	The Regents of the University of California.  All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that: (1) source code distributions
 * retain the above copyright notice and this paragraph in its entirety, (2)
 * distributions including binary code include the above copyright notice and
 * this paragraph in its entirety in the documentation or other materials
 * provided with the distribution, and (3) all advertising materials mentioning
 * features or use of this software display the following acknowledgement:
 * ``This product includes software developed by the University of California,
 * Lawrence Berkeley Laboratory and its contributors.'' Neither the name of
 * the University nor the names of its contributors may be used to endorse
 * or promote products derived from this software without specific prior
 * written permission.
 * THIS SOFTWARE IS PROVIDED ``AS IS'' AND WITHOUT ANY EXPRESS OR IMPLIED
 * WARRANTIES, INCLUDING, WITHOUT LIMITATION, THE IMPLIED WARRANTIES OF
 * MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE.
 *//Users/owura/Repos/codeql_eval/proj_repos/the-tcpdump-group-tcpdump-commit-0f95d441e4b5d7512cc5c326c8668a120e048eda/tcpdump/nameser.h<sys/types.h>rrecHEADERr_datar_sizer_ttlr_typer_classr_zonearcountnscountancountqdcountflags2flags1PUTLONG(l,cp){ register uint32_t t_l = (uint32_t)(l); register u_char *t_cp = (u_char *)(cp); *t_cp++ = t_l >> 24; *t_cp++ = t_l >> 16; *t_cp++ = t_l >> 8; *t_cp = t_l; (cp) += 4; }PUTSHORT(s,cp){ register uint16_t t_s = (uint16_t)(s); register u_char *t_cp = (u_char *)(cp); *t_cp++ = t_s >> 8; *t_cp = t_s; (cp) += 2; }GETLONG(l,cp){ register u_char *t_cp = (u_char *)(cp); (l) = (((uint32_t)t_cp[0]) << 24) | (((uint32_t)t_cp[1]) << 16) | (((uint32_t)t_cp[2]) << 8) | (((uint32_t)t_cp[3])); (cp) += 4; }GETSHORT(s,cp){ register u_char *t_cp = (u_char *)(cp); (s) = ((uint16_t)t_cp[0] << 8) | (uint16_t)t_cp[1]; (cp) += 2; }EDNS0_ELT_BITLABELEDNS0_MASKINDIR_MASKDNS_RCODE(np)((np)->flags2 & 0xF)DNS_CD(np)((np)->flags2 & 0x10)DNS_AD(np)((np)->flags2 & 0x20)DNS_RA(np)((np)->flags2 & 0x80)DNS_RD(np)((np)->flags1 & 0x01)DNS_TC(np)((np)->flags1 & 0x02)DNS_AA(np)((np)->flags1 & 0x04)DNS_OPCODE(np)((((np)->flags1) >> 3) & 0xF)DNS_QR(np)((np)->flags1 & 0x80)CONV_BADBUFLENCONV_BADCKSUMCONV_BADFMTCONV_OVERFLOWCONV_SUCCESSC_CACHE_FLUSHC_QUC_ANYC_HSC_CHAOSC_INT_ANYT_MAILAT_MAILBT_AXFR252T_IXFRT_TSIGT_TKEYT_UNSPECAT_UNSPECT_GIDT_UIDT_UINFOT_SPFT_DNSKEYT_NSECT_RRSIGT_IPSECKEYT_SSHFPT_DST_APLT_OPTT_SINKT_DNAMET_A6T_CERTT_KXT_NAPTRT_ATMAT_SRVT_NIMLOCT_EIDT_NXTT_LOCT_AAAAT_GPOST_PXT_KEYT_SIGT_NSAP_PTRT_NSAPT_RTT_ISDNT_X25T_AFSDBT_RPT_TXTT_MXT_MINFOT_HINFOT_PTRT_WKST_NULLT_MRT_MGT_MBT_SOAT_CNAMET_MFT_MDT_NST_ANOCHANGEREFUSEDNOTIMPNXDOMAINSERVFAILFORMERRNOERRORZONEREFZONEINIT0xeUPDATEMA0xdUPDATEM0xcUPDATEDA0xbUPDATED0xaUPDATEAIQUERYQUERYMULTICASTDNS_PORT5353NAMESERVER_PORTRRFIXEDSZQFIXEDSZMAXLABELMAXCDNAMEMAXDNAMEPACKETSZ_NAMESER_H_/* !_NAMESER_H_ *//*
 * Warning: PUTLONG --no-longer-- destroys its first argument.  if you
 * were depending on this "feature", you will lose.
 *//*
 * Inline versions of get/put short/long.  Pointer is advanced.
 * We also assume that a "uint16_t" holds 2 "chars"
 * and that a "uint32_t" holds 4 "chars".
 *
 * These macros demonstrate the property of C whereby it can be
 * portable or it can be elegant but never both.
 *//* pointer to data *//* size of data area *//* time to live *//* type number *//* class number *//* zone number *//*
 * Structure for passing resource records around.
 *//* 01.... *//* 11.... *//*
 * Defines for handling compressed domain names, EDNS0 labels, etc.
 *//* response code *//* checking disabled by resolver *//* authentic data from named *//* recursion available *//* recursion desired *//* truncated message *//* authoritative answer *//* purpose of message *//* response flag *//*
 * Macros for subfields of flag fields.
 *//* number of resource entries *//* number of authority entries *//* number of answer entries *//* number of question entries *//* second byte of flags *//* first byte of flags *//* query identification number *//*
 * Structure for query header.
 *//*
 * Status return codes for T_UNSPEC conversion routines
 *//* mDNS cache flush flag in replies *//* mDNS QU flag in queries *//* wildcard match *//* Query class values which do not appear in resource records *//* for Hesiod name server (MIT) (XXX) *//* for chaos net (MIT) *//* the arpa internet *//*
 * Values for class field
 *//* transfer mail agent records *//* transfer mailbox records *//* transfer zone of authority *//* incremental transfer [RFC1995] *//* Transaction Signature [RFC2845] *//* Transaction Key [RFC2930] *//* Query type values which do not appear in resource records *//* "unspecified ascii". Ugly MIT hack *//* Unspecified format (binary data) *//* group ID *//* user ID *//* user (finger) information *//* sender policy framework *//* non standard *//* new security key *//* provable insecure information *//* new security signature *//* IPsec keying material *//* SSH Fingerprint *//* Delegation Signer *//* lists of address prefixes *//* EDNS0 option (meta-RR) *//* unknown *//* non-terminal redirection *//* IP6 address *//* Certificates in the DNS *//* Key Exchanger *//* Naming Authority PoinTeR *//* ATM Address *//* Server selection *//* Nimrod locator *//* Endpoint identifier *//* Next Valid Name in Zone *//* Location Information *//* IP6 Address *//* geographical position (withdrawn) *//* X.400 mail mapping *//* security key *//* security signature *//* reverse lookup for NSAP *//* NSAP address *//* router *//* ISDN calling address *//* X_25 calling address *//* AFS cell database *//* responsible person *//* text strings *//* mail routing information *//* mailbox information *//* host information *//* domain name pointer *//* well known service *//* null resource record *//* mail rename name *//* mail group member *//* mailbox domain name *//* start of authority zone *//* connonical name *//* mail forwarder *//* mail destination *//* authoritative server *//* host address *//*
 * Type values for resources and queries
 *//* update failed to change db *//* query refused *//* not implemented *//* non existent domain *//* server failure *//* format error *//* no error *//*
 * Currently defined response codes
 *//*
 * Undefine various #defines from various System V-flavored OSes (Solaris,
 * SINIX, HP-UX) so the compiler doesn't whine that we redefine them.
 *//* incremental zone referesh *//* initial zone transfer *//* modify all named resource record *//* modify a specific resource record *//* delete all named resource record *//* delete a specific resource record *//* add resource record *//* non standard - supports ALLOW_UPDATES stuff from Mike Schwartz *//* 0x3 reserved *//* nameserver status query *//* inverse query *//* standard query *//*
 * Currently defined opcodes
 *//*
 * Port for multicast DNS; see
 *
 *	http://files.multicastdns.org/draft-cheshire-dnsext-multicastdns.txt
 *
 * for the current mDNS spec.
 *//*
 * Internet nameserver port number
 *//* number of bytes of fixed size data in resource record *//* Number of bytes of fixed size data in query structure *//* maximum length of domain label *//* maximum compressed domain name *//* maximum domain name *//* maximum packet size *//*
 * Define constants based on rfc883
 *//*
 * Copyright (c) 1983, 1989, 1993
 *	The Regents of the University of California.  All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *	This product includes software developed by the University of
 *	California, Berkeley and its contributors.
 * 4. Neither the name of the University nor the names of its contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 *
 *      @(#)nameser.h	8.2 (Berkeley) 2/16/94
 * -
 * Portions Copyright (c) 1993 by Digital Equipment Corporation.
 *
 * Permission to use, copy, modify, and distribute this software for any
 * purpose with or without fee is hereby granted, provided that the above
 * copyright notice and this permission notice appear in all copies, and that
 * the name of Digital Equipment Corporation not be used in advertising or
 * publicity pertaining to distribution of the document or software without
 * specific, written prior permission.
 *
 * THE SOFTWARE IS PROVIDED "AS IS" AND DIGITAL EQUIPMENT CORP. DISCLAIMS ALL
 * WARRANTIES WITH REGARD TO THIS SOFTWARE, INCLUDING ALL IMPLIED WARRANTIES
 * OF MERCHANTABILITY AND FITNESS.   IN NO EVENT SHALL DIGITAL EQUIPMENT
 * CORPORATION BE LIABLE FOR ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL
 * DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR
 * PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS
 * ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS
 * SOFTWARE.
 * -
 * --Copyright--
 *//Users/owura/Repos/codeql_eval/proj_repos/the-tcpdump-group-tcpdump-commit-0f95d441e4b5d7512cc5c326c8668a120e048eda/tcpdump/print-domain.c"nameser.h"ns_printconst HEADERconst HEADER *b2*npsizeof(*np)&np->qdcount&np->ancount&np->nscount&np->arcount(ndo, "%d%s%s%s%s%s%s", EXTRACT_16BITS(&np->id), ns_ops[DNS_OPCODE(np)], ns_resp[DNS_RCODE(np)], DNS_AA(np)? "*" : "", DNS_RA(np)? "" : "-", DNS_TC(np)? "|" : "", DNS_AD(np)? "$" : "")(ndo, "%d%s%s%s%s%s%s", ((uint16_t)(((uint16_t)(*((const uint8_t *)(&np->id) + 0)) << 8) | ((uint16_t)(*((const uint8_t *)(&np->id) + 1)) << 0))), ns_ops[((((np)->flags1) >> 3) & 0xF)], ns_resp[((np)->flags2 & 0xF)], ((np)->flags1 & 0x04)? "*" : "", ((np)->flags2 & 0x80)? "" : "-", ((np)->flags1 & 0x02)? "|" : "", ((np)->flags2 & 0x20)? "$" : "")&np->id(ndo, " [%dq]", qdcount)(ndo, " q:")(ndo, " %d/%d/%d", ancount, nscount, arcount)(ndo, " ns:")(ndo, " ar:")(ndo, "%d%s%s%s", EXTRACT_16BITS(&np->id), ns_ops[DNS_OPCODE(np)], DNS_RD(np) ? "+" : "", DNS_CD(np) ? "%" : "")(ndo, "%d%s%s%s", ((uint16_t)(((uint16_t)(*((const uint8_t *)(&np->id) + 0)) << 8) | ((uint16_t)(*((const uint8_t *)(&np->id) + 1)) << 0))), ns_ops[((((np)->flags1) >> 3) & 0xF)], ((np)->flags1 & 0x01) ? "+" : "", ((np)->flags2 & 0x10) ? "%" : "")((u_short *)np)+1(ndo, " [b2&3=0x%x]", b2)(ndo, " [%da]", ancount)(ndo, " [%dn]", nscount)(ndo, " [%dau]", arcount)%d%s%s%s%s%s%sconst char *[16]char *[16]-|$ [%dq] q: %d/%d/%d ns: ar:%d%s%s%sis_mdns%17430x6cf [b2&3=0x%x] [%da] [%dn] [%dau](ndo, " (%d)", length) (%d)(ndo, "[|domain]")[|domain]ns_rprintclassopt_flagstyp4294934527~C_CACHE_FLUSH(ndo, " %s", tok2str(ns_class2str, "(Class %d)", class))(Class %d)(ndo, " (Cache flush)") (Cache flush)(ndo, " [")(ndo, " %s", tok2str(ns_type2str, "Type%d", typ))const tok[62]tok[62]Type%d(NULL)(ndo, " %s", intoa(htonl(EXTRACT_32BITS(cp))))(ndo, " %s", intoa((__builtin_constant_p(((uint32_t)(((uint32_t)(*((const uint8_t *)(cp) + 0)) << 24) | ((uint32_t)(*((const uint8_t *)(cp) + 1)) << 16) | ((uint32_t)(*((const uint8_t *)(cp) + 2)) << 8) | ((uint32_t)(*((const uint8_t *)(cp) + 3)) << 0)))) ? ((__uint32_t)((((__uint32_t)(((uint32_t)(((uint32_t)(*((const uint8_t *)(cp) + 0)) << 24) | ((uint32_t)(*((const uint8_t *)(cp) + 1)) << 16) | ((uint32_t)(*((const uint8_t *)(cp) + 2)) << 8) | ((uint32_t)(*((const uint8_t *)(cp) + 3)) << 0)))) & 0xff000000U) >> 24) | (((__uint32_t)(((uint32_t)(((uint32_t)(*((const uint8_t *)(cp) + 0)) << 24) | ((uint32_t)(*((const uint8_t *)(cp) + 1)) << 16) | ((uint32_t)(*((const uint8_t *)(cp) + 2)) << 8) | ((uint32_t)(*((const uint8_t *)(cp) + 3)) << 0)))) & 0x00ff0000U) >> 8) | (((__uint32_t)(((uint32_t)(((uint32_t)(*((const uint8_t *)(cp) + 0)) << 24) | ((uint32_t)(*((const uint8_t *)(cp) + 1)) << 16) | ((uint32_t)(*((const uint8_t *)(cp) + 2)) << 8) | ((uint32_t)(*((const uint8_t *)(cp) + 3)) << 0)))) & 0x0000ff00U) << 8) | (((__uint32_t)(((uint32_t)(((uint32_t)(*((const uint8_t *)(cp) + 0)) << 24) | ((uint32_t)(*((const uint8_t *)(cp) + 1)) << 16) | ((uint32_t)(*((const uint8_t *)(cp) + 2)) << 8) | ((uint32_t)(*((const uint8_t *)(cp) + 3)) << 0)))) & 0x000000ffU) << 24))) : _OSSwapInt32(((uint32_t)(((uint32_t)(*((const uint8_t *)(cp) + 0)) << 24) | ((uint32_t)(*((const uint8_t *)(cp) + 1)) << 16) | ((uint32_t)(*((const uint8_t *)(cp) + 2)) << 8) | ((uint32_t)(*((const uint8_t *)(cp) + 3)) << 0)))))))EXTRACT_32BITS(cp)((uint32_t)(((uint32_t)(*((const uint8_t *)(cp) + 0)) << 24) | ((uint32_t)(*((const uint8_t *)(cp) + 1)) << 16) | ((uint32_t)(*((const uint8_t *)(cp) + 2)) << 8) | ((uint32_t)(*((const uint8_t *)(cp) + 3)) << 0)))5 * 4(ndo, " %u", EXTRACT_32BITS(cp))(ndo, " %u", ((uint32_t)(((uint32_t)(*((const uint8_t *)(cp) + 0)) << 24) | ((uint32_t)(*((const uint8_t *)(cp) + 1)) << 16) | ((uint32_t)(*((const uint8_t *)(cp) + 2)) << 8) | ((uint32_t)(*((const uint8_t *)(cp) + 3)) << 0))))(ndo, " %d", EXTRACT_16BITS(cp))(ndo, " %d", ((uint16_t)(((uint16_t)(*((const uint8_t *)(cp) + 0)) << 8) | ((uint16_t)(*((const uint8_t *)(cp) + 1)) << 0))))(ndo, " \"")(ndo, ":%d %d %d", EXTRACT_16BITS(cp + 4), EXTRACT_16BITS(cp), EXTRACT_16BITS(cp + 2))(ndo, ":%d %d %d", ((uint16_t)(((uint16_t)(*((const uint8_t *)(cp + 4) + 0)) << 8) | ((uint16_t)(*((const uint8_t *)(cp + 4) + 1)) << 0))), ((uint16_t)(((uint16_t)(*((const uint8_t *)(cp) + 0)) << 8) | ((uint16_t)(*((const uint8_t *)(cp) + 1)) << 0))), ((uint16_t)(((uint16_t)(*((const uint8_t *)(cp + 2) + 0)) << 8) | ((uint16_t)(*((const uint8_t *)(cp + 2) + 1)) << 0))))cp + 4cp + 2(ndo, " UDPsize=%u", class)(ndo, " OK")(ndo, " fudge=%u", EXTRACT_16BITS(cp))(ndo, " fudge=%u", ((uint16_t)(((uint16_t)(*((const uint8_t *)(cp) + 0)) << 8) | ((uint16_t)(*((const uint8_t *)(cp) + 1)) << 0))))(ndo, " maclen=%u", EXTRACT_16BITS(cp))(ndo, " maclen=%u", ((uint16_t)(((uint16_t)(*((const uint8_t *)(cp) + 0)) << 8) | ((uint16_t)(*((const uint8_t *)(cp) + 1)) << 0))))(ndo, " origid=%u", EXTRACT_16BITS(cp))(ndo, " origid=%u", ((uint16_t)(((uint16_t)(*((const uint8_t *)(cp) + 0)) << 8) | ((uint16_t)(*((const uint8_t *)(cp) + 1)) << 0))))(ndo, " error=%u", EXTRACT_16BITS(cp))(ndo, " error=%u", ((uint16_t)(((uint16_t)(*((const uint8_t *)(cp) + 0)) << 8) | ((uint16_t)(*((const uint8_t *)(cp) + 1)) << 0))))(ndo, " otherlen=%u", EXTRACT_16BITS(cp))(ndo, " otherlen=%u", ((uint16_t)(((uint16_t)(*((const uint8_t *)(cp) + 0)) << 8) | ((uint16_t)(*((const uint8_t *)(cp) + 1)) << 0)))) ":%d %d %d UDPsize=%u OK fudge=%u maclen=%u origid=%u error=%u otherlen=%uns_qprint(ndo, " %s", tok2str(ns_type2str, "Type%d", i))~C_QU(ndo, i & C_QU ? " (QU)" : " (QM)")(ndo, i & 0x8000 ? " (QU)" : " (QM)") (QU) (QM)(ndo, "? ")? ns_cprintns_nprintcompresschars_processedeltdata_size4294967295(u_int)-1(ndo, "<LOOP>")(ndo, "<ELT %d>", elt)0x3fff<LOOP>4294967103~INDIR_MASK<ELT %d>labellen(-1)*(cp + 1)bitlenblabel_printslenbbitplimtc(ndo, "\\[x")\[x*bitpsizeof(*bitp)(ndo, "%02x", *bitp)(ndo, "%02x", tc & (0xff << (8 - b)))(ndo, "%1x", ((tc >> 4) & 0x0f) & (0x0f << (4 - b)))%1x(ndo, "/%d]", bitlen)/%d](ndo, ".../%d]", bitlen).../%d]ns_nskipbytelen-193IN"IN"CHAOS"CHAOS"HS"HS"ANY"ANY"ns_class2str"A"MD"MD"MF"MF"CNAME"CNAME"SOA"SOA"MB"MB"MG"MG"MR"MR"WKS"WKS"PTR"PTR"HINFO"HINFO"MINFO"MINFO"MX"MX"TXT"TXT"RP"RP"AFSDB"AFSDB"X25"X25"ISDN"ISDN"RT"RT"NSAP_PTR"NSAP_PTR"SIG"SIG"KEY"KEY"PX"PX"GPOS"GPOS"AAAA"AAAA"LOC"LOC"NXT"NXT"EID"EID"NIMLOC"NIMLOC"SRV"SRV"ATMA"ATMA"NAPTR"NAPTR"KX"KX"CERT"CERT"A6"A6"DNAME"DNAME"SINK"SINK"OPT"OPT"APL"APL"DS"DS"SSHFP"SSHFP"IPSECKEY"IPSECKEY"RRSIG"RRSIG"NSEC"NSEC"DNSKEY"DNSKEY"SPF"SPF"UINFO"UINFO"UID"UID"GID"GID"UNSPEC"UNSPEC"UNSPECA"UNSPECA"TKEY"TKEY"TSIG"TSIG"IXFR"IXFR"AXFR"AXFR"MAILB"MAILB"MAILA"MAILA"ns_type2str FormErr" FormErr" ServFail" ServFail" NXDomain" NXDomain" NotImp" NotImp" Refused" Refused" YXDomain" YXDomain" YXRRSet" YXRRSet" NXRRSet" NXRRSet" NotAuth" NotAuth" NotZone" NotZone" Resp11" Resp11" Resp12" Resp12" Resp13" Resp13" Resp14" Resp14" NoChange" NoChange"ns_resp inv_q" inv_q" stat" stat" op3" op3" notify" notify" update" update" op6" op6" op7" op7" op8" op8" updateA" updateA" updateD" updateD" updateDA" updateDA" updateM" updateM" updateMA" updateMA" zoneInit" zoneInit" zoneRef" zoneRef"ns_ops/* Print remaining sections on -vv *//* any weirdness? *//* this is a request *//* Print NS and AR sections on -vv *//* skip QTYPE and QCLASS *//* Print QUESTION section on -vv *//* this is a response *//* get the byte-order right *//* XXX This isn't always right *//* One long string *//* ignore ttl *//* print ttl *//* ignore rest of ttl field *//* get opt flags *//* print the class (if it's not IN and the type isn't OPT) *//* print the type/qtype *//* print a reply *//* print the qclass (if it's not IN) *//* print the qtype *//* print a query *//* Not used *//* RFC 1035 *//* RFC 1995 *//* RFC 2845 *//* RFC 2930 *//* RFC-schlitt-spf-classic-02.txt *//* RFC 4034 *//* RFC 4025 *//* RFC 4255 *//* RFC 3123 *//* RFC 2671 *//* RFC 2672 *//* RFC 2874 *//* RFC 2538 *//* RFC 2230 *//* RFC 2168, RFC 2915 *//* RFC 2782 *//* Nimrod *//* RFC 2535 *//* RFC 1876 *//* RFC 1886 *//* RFC 1712 *//* RFC 2163 *//* RFC 1706 *//* RFC 1183 *//* http://www.iana.org/assignments/dns-parameters *//* print a <character-string> *//* unknown ELT *//*
				 * If we've looked at every character in
				 * the message, this pointer will make
				 * us look at some character again,
				 * which means we're looping.
				 *//* print the bit string as a hex string *//* print a <domain-name> *//* skip over a domain name *//Users/owura/Repos/codeql_eval/proj_repos/the-tcpdump-group-tcpdump-commit-0f95d441e4b5d7512cc5c326c8668a120e048eda/tcpdump/print-dtp.cdtp_printDTP_HEADER_LEN(ndo, "DTPv%u, length %u", (*tptr), length)DTPv%u, length %u(ndo, "\n\t%s (0x%04x) TLV, length %u", tok2str(dtp_tlv_values, "Unknown", type), type, len)(ndo, ", %s", tptr+4)(ndo, ", 0x%x", *(tptr+4))(ndo, ", %s", etheraddr_string(ndo, tptr+4))
	%s (0x%04x) TLV, length %uDTP_DOMAIN_TLVDTP_STATUS_TLVDTP_DTP_TYPE_TLV, 0x%xDTP_NEIGHBOR_TLV(ndo, "[|dtp]")[|dtp]Domain TLV"Domain TLV"Status TLV"Status TLV"DTP type TLV"DTP type TLV"Neighbor TLV"Neighbor TLV"dtp_tlv_values/* infinite loop check *//*
     * In non-verbose mode, just print version.
     *//*
 * Copyright (c) 1998-2007 The TCPDUMP project
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that: (1) source code
 * distributions retain the above copyright notice and this paragraph
 * in its entirety, and (2) distributions including binary code include
 * the above copyright notice and this paragraph in its entirety in
 * the documentation or other materials provided with the distribution.
 * THIS SOFTWARE IS PROVIDED ``AS IS'' AND
 * WITHOUT ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, WITHOUT
 * LIMITATION, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS
 * FOR A PARTICULAR PURPOSE.
 *
 * Dynamic Trunk Protocol (DTP)
 *
 * Original code by Carles Kishimoto <carles.kishimoto@gmail.com>
 *//Users/owura/Repos/codeql_eval/proj_repos/the-tcpdump-group-tcpdump-commit-0f95d441e4b5d7512cc5c326c8668a120e048eda/tcpdump/print-dvmrp.cprint_graft_ack(ndo, " src %s grp %s", ipaddr_string(ndo, bp), ipaddr_string(ndo, bp + 4))(ndo, " src %s grp %s", getname(ndo, (const u_char *)(bp)), getname(ndo, (const u_char *)(bp + 4))) src %s grp %sbp + 4print_graftprint_prune(ndo, " timer ") timer print_neighbors2laddrmetricthreshncount(ndo, " (v %d.%d):", (int)target_level & 0xff, (int)(target_level >> 8) & 0xff) (v %d.%d):(ndo, " [%s -> ", ipaddr_string(ndo, laddr))(ndo, " [%s -> ", getname(ndo, (const u_char *)(laddr)))(ndo, "%s (%d/%d", ipaddr_string(ndo, bp), metric, thresh)(ndo, "%s (%d/%d", getname(ndo, (const u_char *)(bp)), metric, thresh)(ndo, "/tunnel")(ndo, "/srcrt")(ndo, "/querier")(ndo, "/disabled")(ndo, "/down")(ndo, ")]")(ndo, " [|]") [%s -> %s (%d/%dDVMRP_NF_TUNNEL/tunnelDVMRP_NF_SRCRT/srcrtDVMRP_NF_QUERIER/querierDVMRP_NF_DISABLED/disabledDVMRP_NF_DOWN/down)] [|]print_neighbors(ndo, " [%s ->", ipaddr_string(ndo, laddr))(ndo, " [%s ->", getname(ndo, (const u_char *)(laddr)))(ndo, " %s, (%d/%d)]", ipaddr_string(ndo, bp), metric, thresh)(ndo, " %s, (%d/%d)]", getname(ndo, (const u_char *)(bp)), metric, thresh) [%s -> %s, (%d/%d)]print_probegenid(ndo, " [|}") [|}(ndo, ndo->ndo_vflag > 1 ? "\n\t" : " ")(ndo, "genid %u", genid)genid %u(ndo, "\n\tneighbor %s", ipaddr_string(ndo, bp))(ndo, "\n\tneighbor %s", getname(ndo, (const u_char *)(bp)))
	neighbor %sprint_reportwidth(ndo, "\n\tMask %s", intoa(htonl(mask)))(ndo, "\n\tMask %s", intoa((__builtin_constant_p(mask) ? ((__uint32_t)((((__uint32_t)(mask) & 0xff000000U) >> 24) | (((__uint32_t)(mask) & 0x00ff0000U) >> 8) | (((__uint32_t)(mask) & 0x0000ff00U) << 8) | (((__uint32_t)(mask) & 0x000000ffU) << 24))) : _OSSwapInt32(mask))))(ndo, "\n\t  [Truncated Report]")sizeof(*bp)(ndo, "\n\t  %s metric %d", intoa(htonl(origin)), metric)(ndo, "\n\t  %s metric %d", intoa((__builtin_constant_p(origin) ? ((__uint32_t)((((__uint32_t)(origin) & 0xff000000U) >> 24) | (((__uint32_t)(origin) & 0x00ff0000U) >> 8) | (((__uint32_t)(origin) & 0x0000ff00U) << 8) | (((__uint32_t)(origin) & 0x000000ffU) << 24))) : _OSSwapInt32(origin))), metric)(uint32_t)0xff(uint32_t)0xff << 24
	Mask %s
	  [Truncated Report]0x7f
	  %s metric %ddvmrp_printbp[1]sizeof(bp[1])(ndo, " Probe")(ndo, " Report")(ndo, " Ask-neighbors(old)")(ndo, " Neighbors(old)")(ndo, " Ask-neighbors2")(ndo, " Neighbors2")(ndo, " Prune")(ndo, " Graft")(ndo, " Graft-ACK")(ndo, " [type %d]", type)DVMRP_PROBE ProbeDVMRP_REPORT ReportDVMRP_ASK_NEIGHBORS Ask-neighbors(old)DVMRP_NEIGHBORS Neighbors(old)DVMRP_ASK_NEIGHBORS2 Ask-neighbors2DVMRP_NEIGHBORS2 Neighbors2DVMRP_PRUNE PruneDVMRP_GRAFT GraftDVMRP_GRAFT_ACK Graft-ACK [type %d](ndo, "[|dvmrp]")[|dvmrp]target_level/* { (ctags) *//*
		 * extract version and capabilities from IGMP group
		 * address field
		 *//* Skip IGMP header *//* I am the subnet's querier *//* administratively disabled *//* kernel state of interface *//* tunnel uses IP source routing *//* neighbors reached via tunnel *//*
 * 'flags' byte values in DVMRP_NEIGHBORS2 reply.
 *//* graft acknowledgement *//* graft message *//* prune message *//* as above, want new format reply *//* response to such a request *//* of this router's neighbors *//* sent by mapper, asking for a list *//* for reporting some or all routes *//* for finding neighbors *//*
 * DVMRP message types and flag values shamelessly stolen from
 * mrouted/dvmrp.h.
 *//*
 * Copyright (c) 1995, 1996
 *	The Regents of the University of California.  All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that: (1) source code distributions
 * retain the above copyright notice and this paragraph in its entirety, (2)
 * distributions including binary code include the above copyright notice and
 * this paragraph in its entirety in the documentation or other materials
 * provided with the distribution, and (3) all advertising materials mentioning
 * features or use of this software display the following acknowledgement:
 * ``This product includes software developed by the University of California,
 * Lawrence Berkeley Laboratory and its contributors.'' Neither the name of
 * the University nor the names of its contributors may be used to endorse
 * or promote products derived from this software without specific prior
 * written permission.
 * THIS SOFTWARE IS PROVIDED ``AS IS'' AND WITHOUT ANY EXPRESS OR IMPLIED
 * WARRANTIES, INCLUDING, WITHOUT LIMITATION, THE IMPLIED WARRANTIES OF
 * MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE.
 *//Users/owura/Repos/codeql_eval/proj_repos/the-tcpdump-group-tcpdump-commit-0f95d441e4b5d7512cc5c326c8668a120e048eda/tcpdump/print-eap.ceap_printconst eap_frame_tconst eap_frame_t *eap_frame_t *eap*eapsizeof(*eap)(ndo, "%s (%u) v%u, len %u", tok2str(eap_frame_type_values, "unknown", eap->type), eap->type, eap->version, EXTRACT_16BITS(eap->length))(ndo, "%s (%u) v%u, len %u", tok2str(eap_frame_type_values, "unknown", eap->type), eap->type, eap->version, ((uint16_t)(((uint16_t)(*((const uint8_t *)(eap->length) + 0)) << 8) | ((uint16_t)(*((const uint8_t *)(eap->length) + 1)) << 0))))eap->length%s (%u) v%u, len %usizeof(const struct eap_frame_t)(ndo, ", %s (%u), id %u, len %u", tok2str(eap_code_values, "unknown", type), type, *(tptr+1), len)(ndo, "\n\t\t Type %s (%u)", tok2str(eap_type_values, "unknown", *(tptr+4)), *(tptr + 4))(ndo, ", Identity: ")(ndo, ", Notification: ")(ndo, " %s (%u),", tok2str(eap_type_values, "unknown", *(tptr+count)), *(tptr + count))(ndo, " TTLSv%u", EAP_TTLS_VERSION(*(tptr + 5)))(ndo, " TTLSv%u", ((*(tptr + 5))&0x07))*(tptr + 5)(ndo, " flags [%s] 0x%02x,", bittok2str(eap_tls_flags_values, "none", *(tptr+5)), *(tptr + 5))*(tptr+5)(ndo, " len %u", EXTRACT_32BITS(tptr + 6))(ndo, " len %u", ((uint32_t)(((uint32_t)(*((const uint8_t *)(tptr + 6) + 0)) << 24) | ((uint32_t)(*((const uint8_t *)(tptr + 6) + 1)) << 16) | ((uint32_t)(*((const uint8_t *)(tptr + 6) + 2)) << 8) | ((uint32_t)(*((const uint8_t *)(tptr + 6) + 3)) << 0))))tptr + 6(ndo, " FASTv%u", EAP_TTLS_VERSION(*(tptr + 5)))(ndo, " FASTv%u", ((*(tptr + 5))&0x07))(ndo, " subtype [%s] 0x%02x,", tok2str(eap_aka_subtype_values, "unknown", *(tptr+5)), *(tptr + 5))EAP_FRAME_TYPE_PACKET, %s (%u), id %u, len %u
		 Type %s (%u)EAP_TYPE_IDENTITY, Identity: EAP_TYPE_NOTIFICATION, Notification: EAP_TYPE_NAK %s (%u),EAP_TYPE_TTLS TTLSv%uEAP_TYPE_TLS flags [%s] 0x%02x, len %uEAP_TYPE_FAST FASTv%uEAP_TYPE_AKAEAP_TYPE_SIM subtype [%s] 0x%02x,EAP_TYPE_MD5_CHALLENGEEAP_TYPE_OTPEAP_TYPE_GTCEAP_TYPE_EXPANDED_TYPESEAP_TYPE_EXPERIMENTALEAP_FRAME_TYPE_LOGOFFEAP_FRAME_TYPE_ENCAP_ASF_ALERT(ndo, "\n\t[|EAP]")
	[|EAP]eap_packet_teap_frame_tEAP_AKA_CHALLENGEChallenge"Challenge"EAP_AKA_AUTH_REJECTAuth reject"Auth reject"EAP_AKA_SYNC_FAILURESync failure"Sync failure"EAP_AKA_IDENTITYIdentity"Identity"EAP_SIM_STARTStart"Start"EAP_SIM_CHALLENGEEAP_AKA_NOTIFICATIONEAP_AKA_REAUTHReauth"Reauth"EAP_AKA_CLIENT_ERRORClient error"Client error"eap_aka_subtype_valuesEAP_TLS_FLAGS_LEN_INCLUDEDL bit"L bit"EAP_TLS_FLAGS_MORE_FRAGMENTSMore fragments bit"More fragments bit"EAP_TLS_FLAGS_STARTStart bit"Start bit"eap_tls_flags_valuesEAP_TYPE_NO_PROPOSEDNo proposed"No proposed"Nak"Nak"MD5-challenge"MD5-challenge"OTP"OTP"GTC"GTC"TLS"TLS"SIM"SIM"TTLS"TTLS"AKA"AKA"FAST"FAST"Expanded types"Expanded types"Experimental"Experimental"eap_type_valuesEAP_REQUESTEAP_RESPONSEEAP_SUCCESSSuccess"Success"EAP_FAILUREFailure"Failure"eap_code_valuesEAP packet"EAP packet"EAP_FRAME_TYPE_STARTEAPOL start"EAPOL start"EAPOL logoff"EAPOL logoff"EAP_FRAME_TYPE_KEYEAPOL key"EAPOL key"Encapsulated ASF alert"Encapsulated ASF alert"eap_frame_type_valuesEAP_TTLS_VERSION(x)((x)&0x07)(1 << 5)(1 << 7)EAP_TLS_EXTRACT_BIT_L(x)(((x)&0x80)>>7)/*
 * Local Variables:
 * c-basic-offset: 4
 * End:
 *//* FIXME - TLV attributes follow *//*
                 * one or more octets indicating
                 * the desired authentication
                 * type one octet per type
                 *//* For EAP_REQUEST and EAP_RESPONSE only *//* in non-verbose mode just lets print the basic info *//*
 * Print EAP requests / responses
 *//* EAP-AKA and EAP-SIM - RFC 4187 *//* RFC 2716 - EAP TLS bits *//* RFC 4851 *//* RFC 4187 *//* draft-funk-eap-ttls-v0-01.txt *//* RFC 4186 *//* RFC 2716 *//* RFC 3748 *//*
 * Copyright (c) 2004 - Michael Richardson <mcr@xelerance.com>
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that: (1) source code distributions
 * retain the above copyright notice and this paragraph in its entirety, (2)
 * distributions including binary code include the above copyright notice and
 * this paragraph in its entirety in the documentation or other materials
 * provided with the distribution, and (3) all advertising materials mentioning
 * features or use of this software display the following acknowledgement:
 * ``This product includes software developed by the University of California,
 * Lawrence Berkeley Laboratory and its contributors.'' Neither the name of
 * the University nor the names of its contributors may be used to endorse
 * or promote products derived from this software without specific prior
 * written permission.
 * THIS SOFTWARE IS PROVIDED ``AS IS'' AND WITHOUT ANY EXPRESS OR IMPLIED
 * WARRANTIES, INCLUDING, WITHOUT LIMITATION, THE IMPLIED WARRANTIES OF
 * MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE.
 *
 * Format and print EAP packets.
 *
 *//Users/owura/Repos/codeql_eval/proj_repos/the-tcpdump-group-tcpdump-commit-0f95d441e4b5d7512cc5c326c8668a120e048eda/tcpdump/print-egp.cegp_printconst egp_packetconst egp_packet *egp_packet *egpstatus*egp(ndo, "[|egp]")[|egp](ndo, "EGPv%u, AS %u, seq %u, length %u", egp->egp_version, EXTRACT_16BITS(&egp->egp_as), EXTRACT_16BITS(&egp->egp_sequence), length)(ndo, "EGPv%u, AS %u, seq %u, length %u", egp->egp_version, ((uint16_t)(((uint16_t)(*((const uint8_t *)(&egp->egp_as) + 0)) << 8) | ((uint16_t)(*((const uint8_t *)(&egp->egp_as) + 1)) << 0))), ((uint16_t)(((uint16_t)(*((const uint8_t *)(&egp->egp_sequence) + 0)) << 8) | ((uint16_t)(*((const uint8_t *)(&egp->egp_sequence) + 1)) << 0))), length)&egp->egp_as&egp->egp_sequence(ndo, "EGPv%u, length %u", egp->egp_version, length)EGPv%u, AS %u, seq %u, length %uEGPv%u, length %u(ndo, "[version %d]", egp->egp_version)EGP_VERSION[version %d](ndo, " acquire")(ndo, " %s", egp_acquire_codes[code])(ndo, " %s", egp_acquire_status[status])(ndo, " [status %d]", status)(ndo, " hello:%d poll:%d", EXTRACT_16BITS(&egp->egp_hello), EXTRACT_16BITS(&egp->egp_poll))(ndo, " hello:%d poll:%d", ((uint16_t)(((uint16_t)(*((const uint8_t *)(&egp->egp_handg.egpu_hello) + 0)) << 8) | ((uint16_t)(*((const uint8_t *)(&egp->egp_handg.egpu_hello) + 1)) << 0))), ((uint16_t)(((uint16_t)(*((const uint8_t *)(&egp->egp_pands.egpu_poll) + 0)) << 8) | ((uint16_t)(*((const uint8_t *)(&egp->egp_pands.egpu_poll) + 1)) << 0))))&egp->egp_hello&egp->egp_handg.egpu_hello&egp->egp_poll&egp->egp_pands.egpu_poll(ndo, "[status %d]", status)(ndo, "[code %d]", code)(ndo, " %s", egp_reach_codes[code])(ndo, " state:%s", egp_status_updown[status])(ndo, "[reach code %d]", code)(ndo, " poll")(ndo, " net:%s", ipaddr_string(ndo, &egp->egp_sourcenet))(ndo, " net:%s", getname(ndo, (const u_char *)(&egp->egp_pands.egpu_sourcenet)))&egp->egp_sourcenet&egp->egp_pands.egpu_sourcenet(ndo, " update")(ndo, " unsolicited")(ndo, " %s int %d ext %d", ipaddr_string(ndo, &egp->egp_sourcenet), egp->egp_intgw, egp->egp_extgw)(ndo, " %s int %d ext %d", getname(ndo, (const u_char *)(&egp->egp_pands.egpu_sourcenet)), egp->egp_handg.egpu_gws[0], egp->egp_handg.egpu_gws[1])(ndo, " error")&egp->egp_reason&egp->egp_handg.egpu_reason(ndo, " %s", egp_reasons[EXTRACT_16BITS(&egp->egp_reason)])(ndo, " %s", egp_reasons[((uint16_t)(((uint16_t)(*((const uint8_t *)(&egp->egp_handg.egpu_reason) + 0)) << 8) | ((uint16_t)(*((const uint8_t *)(&egp->egp_handg.egpu_reason) + 1)) << 0)))])(ndo, " [reason %d]", EXTRACT_16BITS(&egp->egp_reason))(ndo, " [reason %d]", ((uint16_t)(((uint16_t)(*((const uint8_t *)(&egp->egp_handg.egpu_reason) + 0)) << 8) | ((uint16_t)(*((const uint8_t *)(&egp->egp_handg.egpu_reason) + 1)) << 0))))(ndo, "[type %d]", type)EGPT_ACQUIRE acquireEGPC_REQUESTEGPC_CONFIRMconst char *[5]char *[5]EGPS_UNSPECEGPS_ACTIVEEGPS_PASSIVE [status %d] hello:%d poll:%dEGPC_REFUSEEGPC_CEASEEGPC_CEASEACKEGPS_NORESEGPS_ADMINEGPS_GODOWNEGPS_PARAMEGPS_PROTO[status %d][code %d]EGPT_REACHEGPC_HELLOEGPC_HEARDUconst char *[2]char *[2]EGPS_DOWN state:%s[reach code %d]EGPT_POLL poll net:%sEGPT_UPDATEEGPS_UNSOL-129~EGPS_UNSOL unsolicited %s int %d ext %dEGPT_ERROR errorEGPR_UVERSIONconst char *[7]char *[7] [reason %d][type %d]egpnrprintnetlengatewaysdistancesnetworkst_gatewayscommaIN_CLASSA_NET3221225472IN_CLASSB_NET37580963844294967040IN_CLASSC_NETcp[0]4 - netlen(ndo, " %s %s ", gateways < (int)egp->egp_intgw ? "int" : "ext", ipaddr_string(ndo, &addr))(ndo, " %s %s ", gateways < (int)egp->egp_handg.egpu_gws[0] ? "int" : "ext", getname(ndo, (const u_char *)(&addr)))(ndo, "%sd%d:", comma, (int)*cp++)(ndo, " %s", ipaddr_string(ndo, &addr))(ndo, " %s", getname(ndo, (const u_char *)(&addr))) %s %s intext%sd%d:(ndo, "[|]")[|]egp_packetegp_pandsegp_handgegp_sequenceegp_asegp_checksumegp_statusegp_codeegp_typeegp_versionegpu_sourcenetegpu_pollegpu_reasonegpu_gwsegpu_hellobad_EGP_header_format"bad_EGP_header_format"bad_EGP_data_field_format"bad_EGP_data_field_format"reachability_info_unavailable"reachability_info_unavailable"excessive_polling_rate"excessive_polling_rate"no_response"no_response"unsupported_version"unsupported_version"egp_reasonsindeterminate"indeterminate"up"up"down"down"egp_status_updown"hello"i-h-u"i-h-u"egp_reach_codesactive_mode"active_mode"passive_mode"passive_mode"insufficient_resources"insufficient_resources"administratively_prohibited"administratively_prohibited"going_down"going_down"parameter_violation"parameter_violation"protocol_violation"protocol_violation"egp_acquire_status"request"confirm"confirm"refuse"refuse"cease"cease"cease_ack"cease_ack"egp_acquire_codesegp_sourcenetegp_pands.egpu_sourcenetegp_pollegp_pands.egpu_pollegp_reasonegp_handg.egpu_reasonegp_extgwegp_handg.egpu_gws[1]egp_intgwegp_handg.egpu_gws[0]egp_helloegp_handg.egpu_helloEGPR_NORESPEGPR_XSPOLLEGPR_NOREACHEGPR_BADDATAEGPR_BADHEADEGPR_UNSPECEGPS_UPEGPS_INDET/* Pickup network number *//* Pickup host part of gateway address *//*
 * Copyright (c) 1991, 1992, 1993, 1994, 1995, 1996
 *	The Regents of the University of California.  All rights reserved.
 *
 * Redistribution and use in source and binary forms are permitted
 * provided that the above copyright notice and this paragraph are
 * duplicated in all such forms and that any documentation,
 * advertising materials, and other materials related to such
 * distribution and use acknowledge that the software was developed
 * by the University of California, Lawrence Berkeley Laboratory,
 * Berkeley, CA.  The name of the University may not be used to
 * endorse or promote products derived from this software without
 * specific prior written permission.
 * THIS SOFTWARE IS PROVIDED ``AS IS'' AND WITHOUT ANY EXPRESS OR
 * IMPLIED WARRANTIES, INCLUDING, WITHOUT LIMITATION, THE IMPLIED
 * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE.
 *
 * Initial contribution from Jeff Honig (jch@MITCHELL.CIT.CORNELL.EDU).
 *//Users/owura/Repos/codeql_eval/proj_repos/the-tcpdump-group-tcpdump-commit-0f95d441e4b5d7512cc5c326c8668a120e048eda/tcpdump/print-eigrp.ceigrp_printconst eigrp_common_headerconst eigrp_common_header *eigrp_common_header *eigrp_com_headerconst eigrp_tlv_headerconst eigrp_tlv_header *eigrp_tlv_header *eigrp_tlv_headertlv_tptreigrp_tlv_leneigrp_tlv_typetlv_tlenbyte_lengthbit_lengthprefix*eigrp_com_headersizeof(*eigrp_com_header)(ndo, "EIGRP version %u packet not supported",eigrp_com_header->version)EIGRP_VERSIONEIGRP version %u packet not supported(ndo, "EIGRP %s, length: %u", tok2str(eigrp_opcode_values, "unknown (%u)",eigrp_com_header->opcode), len)EIGRP %s, length: %usizeof(struct eigrp_common_header)(ndo, "\n\tEIGRP v%u, opcode: %s (%u), chksum: 0x%04x, Flags: [%s]\n\tseq: 0x%08x, ack: 0x%08x, AS: %u, length: %u", eigrp_com_header->version, tok2str(eigrp_opcode_values, "unknown, type: %u",eigrp_com_header->opcode), eigrp_com_header->opcode, EXTRACT_16BITS(&eigrp_com_header->checksum), tok2str(eigrp_common_header_flag_values, "none", EXTRACT_32BITS(&eigrp_com_header->flags)), EXTRACT_32BITS(&eigrp_com_header->seq), EXTRACT_32BITS(&eigrp_com_header->ack), EXTRACT_32BITS(&eigrp_com_header->asn), tlen)(ndo, "\n\tEIGRP v%u, opcode: %s (%u), chksum: 0x%04x, Flags: [%s]\n\tseq: 0x%08x, ack: 0x%08x, AS: %u, length: %u", eigrp_com_header->version, tok2str(eigrp_opcode_values, "unknown, type: %u",eigrp_com_header->opcode), eigrp_com_header->opcode, ((uint16_t)(((uint16_t)(*((const uint8_t *)(&eigrp_com_header->checksum) + 0)) << 8) | ((uint16_t)(*((const uint8_t *)(&eigrp_com_header->checksum) + 1)) << 0))), tok2str(eigrp_common_header_flag_values, "none", ((uint32_t)(((uint32_t)(*((const uint8_t *)(&eigrp_com_header->flags) + 0)) << 24) | ((uint32_t)(*((const uint8_t *)(&eigrp_com_header->flags) + 1)) << 16) | ((uint32_t)(*((const uint8_t *)(&eigrp_com_header->flags) + 2)) << 8) | ((uint32_t)(*((const uint8_t *)(&eigrp_com_header->flags) + 3)) << 0)))), ((uint32_t)(((uint32_t)(*((const uint8_t *)(&eigrp_com_header->seq) + 0)) << 24) | ((uint32_t)(*((const uint8_t *)(&eigrp_com_header->seq) + 1)) << 16) | ((uint32_t)(*((const uint8_t *)(&eigrp_com_header->seq) + 2)) << 8) | ((uint32_t)(*((const uint8_t *)(&eigrp_com_header->seq) + 3)) << 0))), ((uint32_t)(((uint32_t)(*((const uint8_t *)(&eigrp_com_header->ack) + 0)) << 24) | ((uint32_t)(*((const uint8_t *)(&eigrp_com_header->ack) + 1)) << 16) | ((uint32_t)(*((const uint8_t *)(&eigrp_com_header->ack) + 2)) << 8) | ((uint32_t)(*((const uint8_t *)(&eigrp_com_header->ack) + 3)) << 0))), ((uint32_t)(((uint32_t)(*((const uint8_t *)(&eigrp_com_header->asn) + 0)) << 24) | ((uint32_t)(*((const uint8_t *)(&eigrp_com_header->asn) + 1)) << 16) | ((uint32_t)(*((const uint8_t *)(&eigrp_com_header->asn) + 2)) << 8) | ((uint32_t)(*((const uint8_t *)(&eigrp_com_header->asn) + 3)) << 0))), tlen)
	EIGRP v%u, opcode: %s (%u), chksum: 0x%04x, Flags: [%s]
	seq: 0x%08x, ack: 0x%08x, AS: %u, length: %uchar[104]unknown, type: %u&eigrp_com_header->checksum&eigrp_com_header->flags&eigrp_com_header->seq&eigrp_com_header->ack&eigrp_com_header->asnsizeof(const struct eigrp_common_header)sizeof(struct eigrp_tlv_header)&eigrp_tlv_header->length&eigrp_tlv_header->type(ndo, "\n\t  %s TLV (0x%04x), length: %u", tok2str(eigrp_tlv_values, "Unknown", eigrp_tlv_type), eigrp_tlv_type, eigrp_tlv_len)(ndo, "\n\t    holdtime: %us, k1 %u, k2 %u, k3 %u, k4 %u, k5 %u", EXTRACT_16BITS(tlv_ptr.eigrp_tlv_general_parm->holdtime), tlv_ptr.eigrp_tlv_general_parm->k1, tlv_ptr.eigrp_tlv_general_parm->k2, tlv_ptr.eigrp_tlv_general_parm->k3, tlv_ptr.eigrp_tlv_general_parm->k4, tlv_ptr.eigrp_tlv_general_parm->k5)(ndo, "\n\t    holdtime: %us, k1 %u, k2 %u, k3 %u, k4 %u, k5 %u", ((uint16_t)(((uint16_t)(*((const uint8_t *)(tlv_ptr.eigrp_tlv_general_parm->holdtime) + 0)) << 8) | ((uint16_t)(*((const uint8_t *)(tlv_ptr.eigrp_tlv_general_parm->holdtime) + 1)) << 0))), tlv_ptr.eigrp_tlv_general_parm->k1, tlv_ptr.eigrp_tlv_general_parm->k2, tlv_ptr.eigrp_tlv_general_parm->k3, tlv_ptr.eigrp_tlv_general_parm->k4, tlv_ptr.eigrp_tlv_general_parm->k5)tlv_ptr.eigrp_tlv_general_parm->holdtime(ndo, "\n\t    IOS version: %u.%u, EIGRP version %u.%u", tlv_ptr.eigrp_tlv_sw_version->ios_major, tlv_ptr.eigrp_tlv_sw_version->ios_minor, tlv_ptr.eigrp_tlv_sw_version->eigrp_major, tlv_ptr.eigrp_tlv_sw_version->eigrp_minor)(ndo, "\n\t    illegal prefix length %u",bit_length)0, 4&tlv_ptr.eigrp_tlv_ip_int->destination,byte_length(ndo, "\n\t    IPv4 prefix: %15s/%u, nexthop: ", ipaddr_string(ndo, prefix), bit_length)(ndo, "\n\t    IPv4 prefix: %15s/%u, nexthop: ", getname(ndo, (const u_char *)(prefix)), bit_length)&tlv_ptr.eigrp_tlv_ip_int->nexthop(ndo, "self")(ndo, "%s",ipaddr_string(ndo, &tlv_ptr.eigrp_tlv_ip_int->nexthop))(ndo, "%s",getname(ndo, (const u_char *)(&tlv_ptr.eigrp_tlv_ip_int->nexthop)))(ndo, "\n\t      delay %u ms, bandwidth %u Kbps, mtu %u, hop %u, reliability %u, load %u", (EXTRACT_32BITS(&tlv_ptr.eigrp_tlv_ip_int->delay)/100), EXTRACT_32BITS(&tlv_ptr.eigrp_tlv_ip_int->bandwidth), EXTRACT_24BITS(&tlv_ptr.eigrp_tlv_ip_int->mtu), tlv_ptr.eigrp_tlv_ip_int->hopcount, tlv_ptr.eigrp_tlv_ip_int->reliability, tlv_ptr.eigrp_tlv_ip_int->load)(ndo, "\n\t      delay %u ms, bandwidth %u Kbps, mtu %u, hop %u, reliability %u, load %u", (((uint32_t)(((uint32_t)(*((const uint8_t *)(&tlv_ptr.eigrp_tlv_ip_int->delay) + 0)) << 24) | ((uint32_t)(*((const uint8_t *)(&tlv_ptr.eigrp_tlv_ip_int->delay) + 1)) << 16) | ((uint32_t)(*((const uint8_t *)(&tlv_ptr.eigrp_tlv_ip_int->delay) + 2)) << 8) | ((uint32_t)(*((const uint8_t *)(&tlv_ptr.eigrp_tlv_ip_int->delay) + 3)) << 0)))/100), ((uint32_t)(((uint32_t)(*((const uint8_t *)(&tlv_ptr.eigrp_tlv_ip_int->bandwidth) + 0)) << 24) | ((uint32_t)(*((const uint8_t *)(&tlv_ptr.eigrp_tlv_ip_int->bandwidth) + 1)) << 16) | ((uint32_t)(*((const uint8_t *)(&tlv_ptr.eigrp_tlv_ip_int->bandwidth) + 2)) << 8) | ((uint32_t)(*((const uint8_t *)(&tlv_ptr.eigrp_tlv_ip_int->bandwidth) + 3)) << 0))), ((uint32_t)(((uint32_t)(*((const uint8_t *)(&tlv_ptr.eigrp_tlv_ip_int->mtu) + 0)) << 16) | ((uint32_t)(*((const uint8_t *)(&tlv_ptr.eigrp_tlv_ip_int->mtu) + 1)) << 8) | ((uint32_t)(*((const uint8_t *)(&tlv_ptr.eigrp_tlv_ip_int->mtu) + 2)) << 0))), tlv_ptr.eigrp_tlv_ip_int->hopcount, tlv_ptr.eigrp_tlv_ip_int->reliability, tlv_ptr.eigrp_tlv_ip_int->load)&tlv_ptr.eigrp_tlv_ip_int->delay&tlv_ptr.eigrp_tlv_ip_int->bandwidth&tlv_ptr.eigrp_tlv_ip_int->mtu&tlv_ptr.eigrp_tlv_ip_ext->destination,byte_length&tlv_ptr.eigrp_tlv_ip_ext->nexthop(ndo, "%s",ipaddr_string(ndo, &tlv_ptr.eigrp_tlv_ip_ext->nexthop))(ndo, "%s",getname(ndo, (const u_char *)(&tlv_ptr.eigrp_tlv_ip_ext->nexthop)))(ndo, "\n\t      origin-router %s, origin-as %u, origin-proto %s, flags [0x%02x], tag 0x%08x, metric %u", ipaddr_string(ndo, tlv_ptr.eigrp_tlv_ip_ext->origin_router), EXTRACT_32BITS(tlv_ptr.eigrp_tlv_ip_ext->origin_as), tok2str(eigrp_ext_proto_id_values,"unknown",tlv_ptr.eigrp_tlv_ip_ext->proto_id), tlv_ptr.eigrp_tlv_ip_ext->flags, EXTRACT_32BITS(tlv_ptr.eigrp_tlv_ip_ext->tag), EXTRACT_32BITS(tlv_ptr.eigrp_tlv_ip_ext->metric))(ndo, "\n\t      origin-router %s, origin-as %u, origin-proto %s, flags [0x%02x], tag 0x%08x, metric %u", getname(ndo, (const u_char *)(tlv_ptr.eigrp_tlv_ip_ext->origin_router)), ((uint32_t)(((uint32_t)(*((const uint8_t *)(tlv_ptr.eigrp_tlv_ip_ext->origin_as) + 0)) << 24) | ((uint32_t)(*((const uint8_t *)(tlv_ptr.eigrp_tlv_ip_ext->origin_as) + 1)) << 16) | ((uint32_t)(*((const uint8_t *)(tlv_ptr.eigrp_tlv_ip_ext->origin_as) + 2)) << 8) | ((uint32_t)(*((const uint8_t *)(tlv_ptr.eigrp_tlv_ip_ext->origin_as) + 3)) << 0))), tok2str(eigrp_ext_proto_id_values,"unknown",tlv_ptr.eigrp_tlv_ip_ext->proto_id), tlv_ptr.eigrp_tlv_ip_ext->flags, ((uint32_t)(((uint32_t)(*((const uint8_t *)(tlv_ptr.eigrp_tlv_ip_ext->tag) + 0)) << 24) | ((uint32_t)(*((const uint8_t *)(tlv_ptr.eigrp_tlv_ip_ext->tag) + 1)) << 16) | ((uint32_t)(*((const uint8_t *)(tlv_ptr.eigrp_tlv_ip_ext->tag) + 2)) << 8) | ((uint32_t)(*((const uint8_t *)(tlv_ptr.eigrp_tlv_ip_ext->tag) + 3)) << 0))), ((uint32_t)(((uint32_t)(*((const uint8_t *)(tlv_ptr.eigrp_tlv_ip_ext->metric) + 0)) << 24) | ((uint32_t)(*((const uint8_t *)(tlv_ptr.eigrp_tlv_ip_ext->metric) + 1)) << 16) | ((uint32_t)(*((const uint8_t *)(tlv_ptr.eigrp_tlv_ip_ext->metric) + 2)) << 8) | ((uint32_t)(*((const uint8_t *)(tlv_ptr.eigrp_tlv_ip_ext->metric) + 3)) << 0))))tlv_ptr.eigrp_tlv_ip_ext->origin_routertlv_ptr.eigrp_tlv_ip_ext->origin_astlv_ptr.eigrp_tlv_ip_ext->tagtlv_ptr.eigrp_tlv_ip_ext->metric(ndo, "\n\t      delay %u ms, bandwidth %u Kbps, mtu %u, hop %u, reliability %u, load %u", (EXTRACT_32BITS(&tlv_ptr.eigrp_tlv_ip_ext->delay)/100), EXTRACT_32BITS(&tlv_ptr.eigrp_tlv_ip_ext->bandwidth), EXTRACT_24BITS(&tlv_ptr.eigrp_tlv_ip_ext->mtu), tlv_ptr.eigrp_tlv_ip_ext->hopcount, tlv_ptr.eigrp_tlv_ip_ext->reliability, tlv_ptr.eigrp_tlv_ip_ext->load)(ndo, "\n\t      delay %u ms, bandwidth %u Kbps, mtu %u, hop %u, reliability %u, load %u", (((uint32_t)(((uint32_t)(*((const uint8_t *)(&tlv_ptr.eigrp_tlv_ip_ext->delay) + 0)) << 24) | ((uint32_t)(*((const uint8_t *)(&tlv_ptr.eigrp_tlv_ip_ext->delay) + 1)) << 16) | ((uint32_t)(*((const uint8_t *)(&tlv_ptr.eigrp_tlv_ip_ext->delay) + 2)) << 8) | ((uint32_t)(*((const uint8_t *)(&tlv_ptr.eigrp_tlv_ip_ext->delay) + 3)) << 0)))/100), ((uint32_t)(((uint32_t)(*((const uint8_t *)(&tlv_ptr.eigrp_tlv_ip_ext->bandwidth) + 0)) << 24) | ((uint32_t)(*((const uint8_t *)(&tlv_ptr.eigrp_tlv_ip_ext->bandwidth) + 1)) << 16) | ((uint32_t)(*((const uint8_t *)(&tlv_ptr.eigrp_tlv_ip_ext->bandwidth) + 2)) << 8) | ((uint32_t)(*((const uint8_t *)(&tlv_ptr.eigrp_tlv_ip_ext->bandwidth) + 3)) << 0))), ((uint32_t)(((uint32_t)(*((const uint8_t *)(&tlv_ptr.eigrp_tlv_ip_ext->mtu) + 0)) << 16) | ((uint32_t)(*((const uint8_t *)(&tlv_ptr.eigrp_tlv_ip_ext->mtu) + 1)) << 8) | ((uint32_t)(*((const uint8_t *)(&tlv_ptr.eigrp_tlv_ip_ext->mtu) + 2)) << 0))), tlv_ptr.eigrp_tlv_ip_ext->hopcount, tlv_ptr.eigrp_tlv_ip_ext->reliability, tlv_ptr.eigrp_tlv_ip_ext->load)&tlv_ptr.eigrp_tlv_ip_ext->delay&tlv_ptr.eigrp_tlv_ip_ext->bandwidth&tlv_ptr.eigrp_tlv_ip_ext->mtu(ndo, "\n\t    Cable-range: %u-%u, Router-ID %u", EXTRACT_16BITS(&tlv_ptr.eigrp_tlv_at_cable_setup->cable_start), EXTRACT_16BITS(&tlv_ptr.eigrp_tlv_at_cable_setup->cable_end), EXTRACT_32BITS(&tlv_ptr.eigrp_tlv_at_cable_setup->router_id))(ndo, "\n\t    Cable-range: %u-%u, Router-ID %u", ((uint16_t)(((uint16_t)(*((const uint8_t *)(&tlv_ptr.eigrp_tlv_at_cable_setup->cable_start) + 0)) << 8) | ((uint16_t)(*((const uint8_t *)(&tlv_ptr.eigrp_tlv_at_cable_setup->cable_start) + 1)) << 0))), ((uint16_t)(((uint16_t)(*((const uint8_t *)(&tlv_ptr.eigrp_tlv_at_cable_setup->cable_end) + 0)) << 8) | ((uint16_t)(*((const uint8_t *)(&tlv_ptr.eigrp_tlv_at_cable_setup->cable_end) + 1)) << 0))), ((uint32_t)(((uint32_t)(*((const uint8_t *)(&tlv_ptr.eigrp_tlv_at_cable_setup->router_id) + 0)) << 24) | ((uint32_t)(*((const uint8_t *)(&tlv_ptr.eigrp_tlv_at_cable_setup->router_id) + 1)) << 16) | ((uint32_t)(*((const uint8_t *)(&tlv_ptr.eigrp_tlv_at_cable_setup->router_id) + 2)) << 8) | ((uint32_t)(*((const uint8_t *)(&tlv_ptr.eigrp_tlv_at_cable_setup->router_id) + 3)) << 0))))&tlv_ptr.eigrp_tlv_at_cable_setup->cable_start&tlv_ptr.eigrp_tlv_at_cable_setup->cable_end&tlv_ptr.eigrp_tlv_at_cable_setup->router_id(ndo, "\n\t     Cable-Range: %u-%u, nexthop: ", EXTRACT_16BITS(&tlv_ptr.eigrp_tlv_at_int->cable_start), EXTRACT_16BITS(&tlv_ptr.eigrp_tlv_at_int->cable_end))(ndo, "\n\t     Cable-Range: %u-%u, nexthop: ", ((uint16_t)(((uint16_t)(*((const uint8_t *)(&tlv_ptr.eigrp_tlv_at_int->cable_start) + 0)) << 8) | ((uint16_t)(*((const uint8_t *)(&tlv_ptr.eigrp_tlv_at_int->cable_start) + 1)) << 0))), ((uint16_t)(((uint16_t)(*((const uint8_t *)(&tlv_ptr.eigrp_tlv_at_int->cable_end) + 0)) << 8) | ((uint16_t)(*((const uint8_t *)(&tlv_ptr.eigrp_tlv_at_int->cable_end) + 1)) << 0))))&tlv_ptr.eigrp_tlv_at_int->cable_start&tlv_ptr.eigrp_tlv_at_int->cable_end&tlv_ptr.eigrp_tlv_at_int->nexthop(ndo, "%u.%u", EXTRACT_16BITS(&tlv_ptr.eigrp_tlv_at_int->nexthop), EXTRACT_16BITS(&tlv_ptr.eigrp_tlv_at_int->nexthop[2]))(ndo, "%u.%u", ((uint16_t)(((uint16_t)(*((const uint8_t *)(&tlv_ptr.eigrp_tlv_at_int->nexthop) + 0)) << 8) | ((uint16_t)(*((const uint8_t *)(&tlv_ptr.eigrp_tlv_at_int->nexthop) + 1)) << 0))), ((uint16_t)(((uint16_t)(*((const uint8_t *)(&tlv_ptr.eigrp_tlv_at_int->nexthop[2]) + 0)) << 8) | ((uint16_t)(*((const uint8_t *)(&tlv_ptr.eigrp_tlv_at_int->nexthop[2]) + 1)) << 0))))&tlv_ptr.eigrp_tlv_at_int->nexthop[2](ndo, "\n\t      delay %u ms, bandwidth %u Kbps, mtu %u, hop %u, reliability %u, load %u", (EXTRACT_32BITS(&tlv_ptr.eigrp_tlv_at_int->delay)/100), EXTRACT_32BITS(&tlv_ptr.eigrp_tlv_at_int->bandwidth), EXTRACT_24BITS(&tlv_ptr.eigrp_tlv_at_int->mtu), tlv_ptr.eigrp_tlv_at_int->hopcount, tlv_ptr.eigrp_tlv_at_int->reliability, tlv_ptr.eigrp_tlv_at_int->load)(ndo, "\n\t      delay %u ms, bandwidth %u Kbps, mtu %u, hop %u, reliability %u, load %u", (((uint32_t)(((uint32_t)(*((const uint8_t *)(&tlv_ptr.eigrp_tlv_at_int->delay) + 0)) << 24) | ((uint32_t)(*((const uint8_t *)(&tlv_ptr.eigrp_tlv_at_int->delay) + 1)) << 16) | ((uint32_t)(*((const uint8_t *)(&tlv_ptr.eigrp_tlv_at_int->delay) + 2)) << 8) | ((uint32_t)(*((const uint8_t *)(&tlv_ptr.eigrp_tlv_at_int->delay) + 3)) << 0)))/100), ((uint32_t)(((uint32_t)(*((const uint8_t *)(&tlv_ptr.eigrp_tlv_at_int->bandwidth) + 0)) << 24) | ((uint32_t)(*((const uint8_t *)(&tlv_ptr.eigrp_tlv_at_int->bandwidth) + 1)) << 16) | ((uint32_t)(*((const uint8_t *)(&tlv_ptr.eigrp_tlv_at_int->bandwidth) + 2)) << 8) | ((uint32_t)(*((const uint8_t *)(&tlv_ptr.eigrp_tlv_at_int->bandwidth) + 3)) << 0))), ((uint32_t)(((uint32_t)(*((const uint8_t *)(&tlv_ptr.eigrp_tlv_at_int->mtu) + 0)) << 16) | ((uint32_t)(*((const uint8_t *)(&tlv_ptr.eigrp_tlv_at_int->mtu) + 1)) << 8) | ((uint32_t)(*((const uint8_t *)(&tlv_ptr.eigrp_tlv_at_int->mtu) + 2)) << 0))), tlv_ptr.eigrp_tlv_at_int->hopcount, tlv_ptr.eigrp_tlv_at_int->reliability, tlv_ptr.eigrp_tlv_at_int->load)&tlv_ptr.eigrp_tlv_at_int->delay&tlv_ptr.eigrp_tlv_at_int->bandwidth&tlv_ptr.eigrp_tlv_at_int->mtu(ndo, "\n\t     Cable-Range: %u-%u, nexthop: ", EXTRACT_16BITS(&tlv_ptr.eigrp_tlv_at_ext->cable_start), EXTRACT_16BITS(&tlv_ptr.eigrp_tlv_at_ext->cable_end))(ndo, "\n\t     Cable-Range: %u-%u, nexthop: ", ((uint16_t)(((uint16_t)(*((const uint8_t *)(&tlv_ptr.eigrp_tlv_at_ext->cable_start) + 0)) << 8) | ((uint16_t)(*((const uint8_t *)(&tlv_ptr.eigrp_tlv_at_ext->cable_start) + 1)) << 0))), ((uint16_t)(((uint16_t)(*((const uint8_t *)(&tlv_ptr.eigrp_tlv_at_ext->cable_end) + 0)) << 8) | ((uint16_t)(*((const uint8_t *)(&tlv_ptr.eigrp_tlv_at_ext->cable_end) + 1)) << 0))))&tlv_ptr.eigrp_tlv_at_ext->cable_start&tlv_ptr.eigrp_tlv_at_ext->cable_end&tlv_ptr.eigrp_tlv_at_ext->nexthop(ndo, "%u.%u", EXTRACT_16BITS(&tlv_ptr.eigrp_tlv_at_ext->nexthop), EXTRACT_16BITS(&tlv_ptr.eigrp_tlv_at_ext->nexthop[2]))(ndo, "%u.%u", ((uint16_t)(((uint16_t)(*((const uint8_t *)(&tlv_ptr.eigrp_tlv_at_ext->nexthop) + 0)) << 8) | ((uint16_t)(*((const uint8_t *)(&tlv_ptr.eigrp_tlv_at_ext->nexthop) + 1)) << 0))), ((uint16_t)(((uint16_t)(*((const uint8_t *)(&tlv_ptr.eigrp_tlv_at_ext->nexthop[2]) + 0)) << 8) | ((uint16_t)(*((const uint8_t *)(&tlv_ptr.eigrp_tlv_at_ext->nexthop[2]) + 1)) << 0))))&tlv_ptr.eigrp_tlv_at_ext->nexthop[2](ndo, "\n\t      origin-router %u, origin-as %u, origin-proto %s, flags [0x%02x], tag 0x%08x, metric %u", EXTRACT_32BITS(tlv_ptr.eigrp_tlv_at_ext->origin_router), EXTRACT_32BITS(tlv_ptr.eigrp_tlv_at_ext->origin_as), tok2str(eigrp_ext_proto_id_values,"unknown",tlv_ptr.eigrp_tlv_at_ext->proto_id), tlv_ptr.eigrp_tlv_at_ext->flags, EXTRACT_32BITS(tlv_ptr.eigrp_tlv_at_ext->tag), EXTRACT_16BITS(tlv_ptr.eigrp_tlv_at_ext->metric))(ndo, "\n\t      origin-router %u, origin-as %u, origin-proto %s, flags [0x%02x], tag 0x%08x, metric %u", ((uint32_t)(((uint32_t)(*((const uint8_t *)(tlv_ptr.eigrp_tlv_at_ext->origin_router) + 0)) << 24) | ((uint32_t)(*((const uint8_t *)(tlv_ptr.eigrp_tlv_at_ext->origin_router) + 1)) << 16) | ((uint32_t)(*((const uint8_t *)(tlv_ptr.eigrp_tlv_at_ext->origin_router) + 2)) << 8) | ((uint32_t)(*((const uint8_t *)(tlv_ptr.eigrp_tlv_at_ext->origin_router) + 3)) << 0))), ((uint32_t)(((uint32_t)(*((const uint8_t *)(tlv_ptr.eigrp_tlv_at_ext->origin_as) + 0)) << 24) | ((uint32_t)(*((const uint8_t *)(tlv_ptr.eigrp_tlv_at_ext->origin_as) + 1)) << 16) | ((uint32_t)(*((const uint8_t *)(tlv_ptr.eigrp_tlv_at_ext->origin_as) + 2)) << 8) | ((uint32_t)(*((const uint8_t *)(tlv_ptr.eigrp_tlv_at_ext->origin_as) + 3)) << 0))), tok2str(eigrp_ext_proto_id_values,"unknown",tlv_ptr.eigrp_tlv_at_ext->proto_id), tlv_ptr.eigrp_tlv_at_ext->flags, ((uint32_t)(((uint32_t)(*((const uint8_t *)(tlv_ptr.eigrp_tlv_at_ext->tag) + 0)) << 24) | ((uint32_t)(*((const uint8_t *)(tlv_ptr.eigrp_tlv_at_ext->tag) + 1)) << 16) | ((uint32_t)(*((const uint8_t *)(tlv_ptr.eigrp_tlv_at_ext->tag) + 2)) << 8) | ((uint32_t)(*((const uint8_t *)(tlv_ptr.eigrp_tlv_at_ext->tag) + 3)) << 0))), ((uint16_t)(((uint16_t)(*((const uint8_t *)(tlv_ptr.eigrp_tlv_at_ext->metric) + 0)) << 8) | ((uint16_t)(*((const uint8_t *)(tlv_ptr.eigrp_tlv_at_ext->metric) + 1)) << 0))))tlv_ptr.eigrp_tlv_at_ext->origin_routertlv_ptr.eigrp_tlv_at_ext->origin_astlv_ptr.eigrp_tlv_at_ext->tagtlv_ptr.eigrp_tlv_at_ext->metric(ndo, "\n\t      delay %u ms, bandwidth %u Kbps, mtu %u, hop %u, reliability %u, load %u", (EXTRACT_32BITS(&tlv_ptr.eigrp_tlv_at_ext->delay)/100), EXTRACT_32BITS(&tlv_ptr.eigrp_tlv_at_ext->bandwidth), EXTRACT_24BITS(&tlv_ptr.eigrp_tlv_at_ext->mtu), tlv_ptr.eigrp_tlv_at_ext->hopcount, tlv_ptr.eigrp_tlv_at_ext->reliability, tlv_ptr.eigrp_tlv_at_ext->load)(ndo, "\n\t      delay %u ms, bandwidth %u Kbps, mtu %u, hop %u, reliability %u, load %u", (((uint32_t)(((uint32_t)(*((const uint8_t *)(&tlv_ptr.eigrp_tlv_at_ext->delay) + 0)) << 24) | ((uint32_t)(*((const uint8_t *)(&tlv_ptr.eigrp_tlv_at_ext->delay) + 1)) << 16) | ((uint32_t)(*((const uint8_t *)(&tlv_ptr.eigrp_tlv_at_ext->delay) + 2)) << 8) | ((uint32_t)(*((const uint8_t *)(&tlv_ptr.eigrp_tlv_at_ext->delay) + 3)) << 0)))/100), ((uint32_t)(((uint32_t)(*((const uint8_t *)(&tlv_ptr.eigrp_tlv_at_ext->bandwidth) + 0)) << 24) | ((uint32_t)(*((const uint8_t *)(&tlv_ptr.eigrp_tlv_at_ext->bandwidth) + 1)) << 16) | ((uint32_t)(*((const uint8_t *)(&tlv_ptr.eigrp_tlv_at_ext->bandwidth) + 2)) << 8) | ((uint32_t)(*((const uint8_t *)(&tlv_ptr.eigrp_tlv_at_ext->bandwidth) + 3)) << 0))), ((uint32_t)(((uint32_t)(*((const uint8_t *)(&tlv_ptr.eigrp_tlv_at_ext->mtu) + 0)) << 16) | ((uint32_t)(*((const uint8_t *)(&tlv_ptr.eigrp_tlv_at_ext->mtu) + 1)) << 8) | ((uint32_t)(*((const uint8_t *)(&tlv_ptr.eigrp_tlv_at_ext->mtu) + 2)) << 0))), tlv_ptr.eigrp_tlv_at_ext->hopcount, tlv_ptr.eigrp_tlv_at_ext->reliability, tlv_ptr.eigrp_tlv_at_ext->load)&tlv_ptr.eigrp_tlv_at_ext->delay&tlv_ptr.eigrp_tlv_at_ext->bandwidth&tlv_ptr.eigrp_tlv_at_ext->mtu
	  %s TLV (0x%04x), length: %uEIGRP_TLV_GENERAL_PARMconst eigrp_tlv_general_parm_tconst eigrp_tlv_general_parm_t *eigrp_tlv_general_parm_t *
	    holdtime: %us, k1 %u, k2 %u, k3 %u, k4 %u, k5 %uEIGRP_TLV_SW_VERSIONconst eigrp_tlv_sw_version_tconst eigrp_tlv_sw_version_t *eigrp_tlv_sw_version_t *
	    IOS version: %u.%u, EIGRP version %u.%uEIGRP_TLV_IP_INTconst eigrp_tlv_ip_int_tconst eigrp_tlv_ip_int_t *eigrp_tlv_ip_int_t *
	    illegal prefix length %u
	    IPv4 prefix: %15s/%u, nexthop: self
	      delay %u ms, bandwidth %u Kbps, mtu %u, hop %u, reliability %u, load %uconst uint8_t[3]const uint8_t(*)[3]unsigned char(*)[3]EIGRP_TLV_IP_EXTconst eigrp_tlv_ip_ext_tconst eigrp_tlv_ip_ext_t *eigrp_tlv_ip_ext_t *
	      origin-router %s, origin-as %u, origin-proto %s, flags [0x%02x], tag 0x%08x, metric %uchar[95]516EIGRP_TLV_AT_CABLE_SETUPconst eigrp_tlv_at_cable_setup_tconst eigrp_tlv_at_cable_setup_t *eigrp_tlv_at_cable_setup_t *
	    Cable-range: %u-%u, Router-ID %uEIGRP_TLV_AT_INTconst eigrp_tlv_at_int_tconst eigrp_tlv_at_int_t *eigrp_tlv_at_int_t *
	     Cable-Range: %u-%u, nexthop: EIGRP_TLV_AT_EXTconst eigrp_tlv_at_ext_tconst eigrp_tlv_at_ext_t *eigrp_tlv_at_ext_t *
	      origin-router %u, origin-as %u, origin-proto %s, flags [0x%02x], tag 0x%08x, metric %uEIGRP_TLV_AUTHEIGRP_TLV_SEQEIGRP_TLV_MCAST_SEQEIGRP_TLV_IPX_INTEIGRP_TLV_IPX_EXTeigrp_tlv_at_ext_teigrp_tlv_at_int_teigrp_tlv_at_cable_setup_teigrp_tlv_ip_ext_teigrp_tlv_ip_int_teigrp_tlv_sw_version_teigrp_tlv_general_parm_teigrp_common_headereigrp_tlv_at_exteigrp_tlv_at_inteigrp_tlv_at_cable_setupeigrp_tlv_ip_exteigrp_tlv_ip_inteigrp_tlv_sw_versioneigrp_tlv_general_parmcable_endcable_startreserved2loadreliabilityhopcountmtudelayproto_idorigin_asorigin_routernexthoprouter_iddestinationeigrp_minoreigrp_majorios_minorios_majorholdtimek5k4k3k2k1asnStatic"Static"RIP"RIP"Hello"Hello"BGP"BGP"Connected"Connected"eigrp_ext_proto_id_valuesGeneral Parameters"General Parameters"Sequence"Sequence"Software Version"Software Version"Next Multicast Sequence"Next Multicast Sequence"IP Internal routes"IP Internal routes"IP External routes"IP External routes"AppleTalk Internal routes"AppleTalk Internal routes"AppleTalk External routes"AppleTalk External routes"AppleTalk Cable setup"AppleTalk Cable setup"IPX Internal routes"IPX Internal routes"IPX External routes"IPX External routes"eigrp_tlv_valuesConditionally Received"Conditionally Received"eigrp_common_header_flag_valuesEIGRP_OPCODE_UPDATEEIGRP_OPCODE_QUERYQuery"Query"EIGRP_OPCODE_REPLYEIGRP_OPCODE_HELLOEIGRP_OPCODE_IPXSAPIPX SAP"IPX SAP"EIGRP_OPCODE_PROBEProbe"Probe"eigrp_opcode_values0x03030x03020x0204/* do we want to see an additionally hexdump ? *//* variable length encoding *//* FIXME print other header info *//* ok they seem to want to know everything - lets fully decode it *//* in non-verbose mode just lets print the basic Message Type*//* variable length [1-4] bytes encoding *//*
 * packet format documented at
 * http://www.rhyshaden.com/eigrp.htm
 *//*
 * Copyright (c) 1998-2004  Hannes Gredler <hannes@tcpdump.org>
 *      The TCPDUMP project
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that: (1) source code
 * distributions retain the above copyright notice and this paragraph
 * in its entirety, and (2) distributions including binary code include
 * the above copyright notice and this paragraph in its entirety in
 * the documentation or other materials provided with the distribution.
 * THIS SOFTWARE IS PROVIDED ``AS IS'' AND
 * WITHOUT ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, WITHOUT
 * LIMITATION, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS
 * FOR A PARTICULAR PURPOSE.
 *//Users/owura/Repos/codeql_eval/proj_repos/the-tcpdump-group-tcpdump-commit-0f95d441e4b5d7512cc5c326c8668a120e048eda/tcpdump/print-enc.cenc_if_printconst enchdrconst enchdr *enchdr *(ndo, "[|enc]")ENC_HDRLEN[|enc](ndo, "(unprotected): ")(unprotected): M_AUTH"authentic"(ndo, "%s%s", "authentic", (flags) == (0x0800) ? "): " : ",")authentic-2049M_CONF0x0400"confidential"(ndo, "%s%s", "confidential", (flags) == (0x0400) ? "): " : ",")confidential-1025(ndo, "SPI 0x%08x: ", EXTRACT_32BITS(&hdr->spi))(ndo, "SPI 0x%08x: ", ((uint32_t)(((uint32_t)(*((const uint8_t *)(&hdr->spi) + 0)) << 24) | ((uint32_t)(*((const uint8_t *)(&hdr->spi) + 1)) << 16) | ((uint32_t)(*((const uint8_t *)(&hdr->spi) + 2)) << 8) | ((uint32_t)(*((const uint8_t *)(&hdr->spi) + 3)) << 0))))SPI 0x%08x: &hdr->spiAF_INET6(ENC_HDRLEN)enchdrENC_PRINT_TYPE(wh,xf,nam)if ((wh) & (xf)) { ND_PRINT((ndo, "%s%s", nam, (wh) == (xf) ? "): " : ",")); (wh) &= ~(xf); }/* ENC_PRINT_TYPE(flags, M_TUNNEL, "tunnel"); *//* packet was authenticated (AH) *//* packet was encrypted (ESP-transport) *//* From $OpenBSD: mbuf.h,v 1.56 2002/01/25 15:50:23 art Exp $	*//*
 * The authors of this code are John Ioannidis (ji@tla.org),
 * Angelos D. Keromytis (kermit@csd.uch.gr) and
 * Niels Provos (provos@physnet.uni-hamburg.de).
 *
 * This code was written by John Ioannidis for BSD/OS in Athens, Greece,
 * in November 1995.
 *
 * Ported to OpenBSD and NetBSD, with additional transforms, in December 1996,
 * by Angelos D. Keromytis.
 *
 * Additional transforms and features in 1997 and 1998 by Angelos D. Keromytis
 * and Niels Provos.
 *
 * Copyright (C) 1995, 1996, 1997, 1998 by John Ioannidis, Angelos D. Keromytis
 * and Niels Provos.
 * Copyright (c) 2001, Angelos D. Keromytis.
 *
 * Permission to use, copy, and modify this software with or without fee
 * is hereby granted, provided that this entire notice is included in
 * all copies of any software which is or includes a copy or
 * modification of this software.
 * You may use this code under the GNU public license if you so wish. Please
 * contribute changes back to the authors under this freer than GPL license
 * so that we may further the use of strong encryption without limitations to
 * all.
 *
 * THIS SOFTWARE IS BEING PROVIDED "AS IS", WITHOUT ANY EXPRESS OR
 * IMPLIED WARRANTY. IN PARTICULAR, NONE OF THE AUTHORS MAKES ANY
 * REPRESENTATION OR WARRANTY OF ANY KIND CONCERNING THE
 * MERCHANTABILITY OF THIS SOFTWARE OR ITS FITNESS FOR ANY PARTICULAR
 * PURPOSE.
 *//* From $OpenBSD: if_enc.h,v 1.8 2001/06/25 05:14:00 angelos Exp $ *//*
 * Copyright (c) 1990, 1991, 1993, 1994, 1995, 1996
 *	The Regents of the University of California.  All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that: (1) source code distributions
 * retain the above copyright notice and this paragraph in its entirety, (2)
 * distributions including binary code include the above copyright notice and
 * this paragraph in its entirety in the documentation or other materials
 * provided with the distribution, and (3) all advertising materials mentioning
 * features or use of this software display the following acknowledgement:
 * ``This product includes software developed by the University of California,
 * Lawrence Berkeley Laboratory and its contributors.'' Neither the name of
 * the University nor the names of its contributors may be used to endorse
 * or promote products derived from this software without specific prior
 * written permission.
 * THIS SOFTWARE IS PROVIDED ``AS IS'' AND WITHOUT ANY EXPRESS OR IMPLIED
 * WARRANTIES, INCLUDING, WITHOUT LIMITATION, THE IMPLIED WARRANTIES OF
 * MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE.
 *//*	$OpenBSD: print-enc.c,v 1.7 2002/02/19 19:39:40 millert Exp $	*//Users/owura/Repos/codeql_eval/proj_repos/the-tcpdump-group-tcpdump-commit-0f95d441e4b5d7512cc5c326c8668a120e048eda/tcpdump/print-esp.cesp_printconst intconst newespconst newesp *newesp *esp(ndo, "[|ESP]")[|ESP](ndo, "ESP(spi=0x%08x", EXTRACT_32BITS(&esp->esp_spi))(ndo, "ESP(spi=0x%08x", ((uint32_t)(((uint32_t)(*((const uint8_t *)(&esp->esp_spi) + 0)) << 24) | ((uint32_t)(*((const uint8_t *)(&esp->esp_spi) + 1)) << 16) | ((uint32_t)(*((const uint8_t *)(&esp->esp_spi) + 2)) << 8) | ((uint32_t)(*((const uint8_t *)(&esp->esp_spi) + 3)) << 0))))ESP(spi=0x%08x&esp->esp_spi(ndo, ",seq=0x%x)", EXTRACT_32BITS(&esp->esp_seq))(ndo, ",seq=0x%x)", ((uint32_t)(((uint32_t)(*((const uint8_t *)(&esp->esp_seq) + 0)) << 24) | ((uint32_t)(*((const uint8_t *)(&esp->esp_seq) + 1)) << 16) | ((uint32_t)(*((const uint8_t *)(&esp->esp_seq) + 2)) << 8) | ((uint32_t)(*((const uint8_t *)(&esp->esp_seq) + 3)) << 0)))),seq=0x%x)&esp->esp_seqfailnewespesp_seqesp_spiHAVE_LIBCRYPTOHAVE_OPENSSL_EVP_H/* sanity check for pad length *//* FCS included at end of frame (NetBSD 1.6 or later) *//* if we can't get nexthdr, we do not need to decrypt it *//* if not found fail *//* if we didn't find the specific one, then look for
	 * an unspecified one.
	 *//* see if we can find the SA, and if so, decode it *//* nexthdr & padding are in the last fragment *//* we do not attempt to decrypt jumbograms *//* initiailize SAs *//* keep secret out of a register *//* pick out the first line or first thing until a comma *//* skip any blank spaces *//* remove newline from the line *//* open file and read it *//* sa1.spi = 0; *//* memset(&sa1.daddr, 0, sizeof(sa1.daddr)); *//* sa1.daddr.version = 0; *//* if there is only one token, then it is an algo:key token *//*
 *
 * special form: file /name
 * causes us to go read from this file instead.
 *
 *//* if any fields are missing *//* it's an IKEv2 secret, store it instead *//*
 * for the moment, ignore the auth algorith, just hard code the authenticator
 * length. Need to research how openssl looks up HMAC stuff.
 *//* decode some hex! *//*
 * decode the form:    SPINUM@IP <tab> ALGONAME:0xsecret
 *//*
 * returns size of binary, 0 on failure.
 *//* copy the "sa" *//*
	 * remove authenticator, and see if we still have something to
	 * work with
	 *//* initiator arg is any non-zero value *//*
 * this will adjust ndo_packetp and ndo_snapend to new buffer!
 *//* is that big enough for all secrets? *//* for IKEv2 *//* if == 0, then IKEv2 *//*variable size, 32bit bound*//* next header *//*8bit*//* pad size *//* padding *//*variable size*//* (IV and) Payload data *//* Sequence number *//* ESP *//*
 * RFC1827/2406 Encapsulated Security Payload.
 *//* Any code in this file that depends on HAVE_LIBCRYPTO depends on
 * HAVE_OPENSSL_EVP_H too. Undefining the former when the latter isn't defined
 * is the simplest way of handling the dependency.
 */bp2nhdr/Users/owura/Repos/codeql_eval/proj_repos/the-tcpdump-group-tcpdump-commit-0f95d441e4b5d7512cc5c326c8668a120e048eda/tcpdump/print-ether.cethertype_print(ndo, "(NOV-ETHII) ")2054245793301133079(NOV-ETHII) 34915349161537815379349583496934827348243482535074439813502035018349271799351434369349782458024583245782457735130netanalyzer_transparent_if_print(ndo, "[|netanalyzer-transparent]")[|netanalyzer-transparent]12 + ETHER_HDRLEN(12 + ETHER_HDRLEN)netanalyzer_if_print(ndo, "[|netanalyzer]")[|netanalyzer]4 + ETHER_HDRLEN(4 + ETHER_HDRLEN)ether_if_print(ETHER_HDRLEN)ether_printether_header *orig_lengthextracted_ether_type(ndo, "[|ether]")[|ether]&ep->ether_typerecurse(ndo, "[|vlan]")(ndo, "vlan %u, p %u%s, ", tag & 0xfff, tag >> 13, (tag & 0x1000) ? ", CFI" : "")(ndo, "ethertype %s, ", tok2str(ethertype_values,"0x%04x", ether_type))33024371203737634984[|vlan]vlan %u, p %u%s, , CFIprint_encap_headerencap_header_argethertype %s, const tok[51]tok[51]0x%04x34928ether_hdr_printconst ether_headerconst ether_header *(ndo, "%s > %s", etheraddr_string(ndo, ESRC(ep)), etheraddr_string(ndo, EDST(ep)))(ndo, "%s > %s", etheraddr_string(ndo, ((ep)->ether_shost)), etheraddr_string(ndo, ((ep)->ether_dhost)))(ndo, ", 802.3")(ndo, ", ethertype %s (0x%04x)", tok2str(ethertype_values,"Unknown", ether_type), ether_type)(ndo, ", %s", tok2str(ethertype_values,"Unknown Ethertype (0x%04x)", ether_type)), 802.3MPLS unicast"MPLS unicast"MPLS multicast"MPLS multicast"802.1Q"802.1Q"802.1Q-9100"802.1Q-9100"802.1Q-QinQ"802.1Q-QinQ"802.1Q-9200"802.1Q-9200"VMAN"VMAN"PUP"PUP"Reverse ARP"Reverse ARP"1280Sprite"Sprite"Trail"Trail"MOP DL"MOP DL"MOP RC"MOP RC"DN"DN"LAT"LAT"SCA"SCA"25944TEB"TEB"32824Lanbridge"Lanbridge"32828DEC DNS"DEC DNS"32830DEC DTS"DEC DTS"32859VEXP"VEXP"32860VPROD"VPROD"Appletalk ARP"Appletalk ARP"MPCP"MPCP"Slow Protocols"Slow Protocols"PPPoE D"PPPoE D"PPPoE S"PPPoE S"EAPOL"EAPOL"RRCP"RRCP"MS NLB heartbeat"MS NLB heartbeat"Jumbo"Jumbo"OSI"OSI"GRE-OSI"GRE-OSI"CFM (old)"CFM (old)"CFM"CFM"IEEE1905.1"IEEE1905.1"LLDP"LLDP"TIPC"TIPC"GeoNet (old)"GeoNet (old)"GeoNet"GeoNet"CALM FAST"CALM FAST"AoE"AoE"/* default_print for now *//*
 * Prints the packet payload, given an Ethernet type code for the payload's
 * protocol.
 *
 * Returns non-zero if it can do so, zero if the ethertype is unknown.
 *//* Skip the pseudo-header, preamble, and SOF. *//*
	 * Fail if we don't have enough data for the Hilscher pseudo-header,
	 * preamble, and SOF.
	 *//*
 * This is the top level routine of the printer.  'p' points
 * to the ether header of the packet, 'h->ts' is the timestamp,
 * 'h->len' is the length of the packet off the wire, and 'h->caplen'
 * is the number of bytes actually captured.
 *
 * This is for DLT_NETANALYZER_TRANSPARENT, which has a 4-byte
 * pseudo-header, a 7-byte Ethernet preamble, and a 1-byte Ethernet SOF
 * before the Ethernet header.
 *//* Skip the pseudo-header. *//*
	 * Fail if we don't have enough data for the Hilscher pseudo-header.
	 *//*
 * This is the top level routine of the printer.  'p' points
 * to the ether header of the packet, 'h->ts' is the timestamp,
 * 'h->len' is the length of the packet off the wire, and 'h->caplen'
 * is the number of bytes actually captured.
 *
 * This is for DLT_NETANALYZER, which has a 4-byte pseudo-header
 * before the Ethernet header.
 *//* Try to print the LLC-layer header & higher layers *//*
		 * Alteon jumbo frames.
		 * See
		 *
		 *	http://tools.ietf.org/html/draft-ietf-isis-ext-eth-01
		 *
		 * which indicates that, following the type field,
		 * there's an LLC header and payload.
		 *//*
		 * Print VLAN information, and then go back and process
		 * the enclosed type field.
		 *//*
	 * Is it (gag) an 802.3 encapsulation?
	 *//*
 * Print an Ethernet frame.
 * This might be encapsulated within another frame; we might be passed
 * a pointer to a function that can print header information for that
 * frame's protocol, and an argument to pass to that function.
 *//Users/owura/Repos/codeql_eval/proj_repos/the-tcpdump-group-tcpdump-commit-0f95d441e4b5d7512cc5c326c8668a120e048eda/tcpdump/print-fddi.cfddi_if_printFDDI_HDRLEN(FDDI_HDRLEN)fddi_printconst fddi_headerconst fddi_header *fddi_header *fddipehdr(ndo, "[|fddi]")[|fddi]&ehdrFDDIFC_CLFFFDDIFC_LLC_ASYNCFDDIFC_SMTfddi_smt_print(ndo, "<SMT printer not yet implemented>")<SMT printer not yet implemented>fddi_hdr_printsrcnamedstname(ndo, "%02x %s %s %d: ", fddip->fddi_fc, srcname, dstname, length)(ndo, "%s %s %d: ", srcname, dstname, length)%02x %s %s %d: %s %s %d: extract_fddi_addrsfdst(const char *)fddip->fddi_dhost, 6fsrc(const char *)fddip->fddi_shost, 6const u_char[256]unsigned char[256]print_fddi_fc(ndo, "void ")(ndo, "nrt ")(ndo, "rt ")(ndo, "info ")(ndo, "nsa ")(ndo, "beacon ")(ndo, "claim ")(ndo, "mac%1x ", fc & FDDIFC_ZZZZ)(ndo, "mac%1x ", fc & 0x0F)(ndo, "smt%1x ", fc & FDDIFC_ZZZZ)(ndo, "smt%1x ", fc & 0x0F)(ndo, "async%1x ", fc & FDDIFC_ZZZZ)(ndo, "async%1x ", fc & 0x0F)(ndo, "sync%1x ", fc & FDDIFC_ZZZZ)(ndo, "sync%1x ", fc & 0x0F)(ndo, "imp_async%1x ", fc & FDDIFC_ZZZZ)(ndo, "imp_async%1x ", fc & 0x0F)(ndo, "imp_sync%1x ", fc & FDDIFC_ZZZZ)(ndo, "imp_sync%1x ", fc & 0x0F)(ndo, "%02x ", fc)FDDIFC_VOIDvoid FDDIFC_NRTnrt FDDIFC_RTrt FDDIFC_SMT_INFOinfo FDDIFC_SMT_NSAnsa 194FDDIFC_MAC_BEACONbeacon 195FDDIFC_MAC_CLAIMclaim FDDIFC_MACmac%1x smt%1x async%1x 208FDDIFC_LLC_SYNCsync%1x FDDIFC_IMP_ASYNCimp_async%1x FDDIFC_IMP_SYNCimp_sync%1x %02x fddi_headerfddi_shostfddi_dhostfddi_fcfddi_bit_swapfddi_bitswapFDDIFC_ZZZZ0xd00x500xc30xc20x4F0x41FDDIFC_ZFDDIFC_FFDDIFC_LFDDIFC_Cdefined(ultrix) || defined(__alpha) || defined(__bsdi) || defined(__NetBSD__) || defined(__linux__)/*
 * This is the top level routine of the printer.  'p' points
 * to the FDDI header of the packet, 'h->ts' is the timestamp,
 * 'h->len' is the length of the packet off the wire, and 'h->caplen'
 * is the number of bytes actually captured.
 *//* Some kinds of FDDI packet we cannot handle intelligently *//* Frame Control field determines interpretation of packet *//* Skip over FDDI MAC header *//*
	 * Get the FDDI addresses into a canonical form
	 *//*
 * Print the FDDI MAC header
 *//*
		 * bit-swap the fddi addresses (isn't the IEEE standards
		 * process wonderful!) then convert them to names.
		 *//* Extract src, dst addresses *//* MAC Claim frame *//* MAC Beacon frame *//* SMT Next station adrs *//* SMT Info *//* Restricted token *//* Nonrestricted token *//* Void frame *//*
 * Print FDDI frame-control bits
 *//*
 * FDDI support for tcpdump, by Jeffrey Mogul [DECWRL], June 1992
 *
 * Based in part on code by Van Jacobson, which bears this note:
 *
 * NOTE:  This is a very preliminary hack for FDDI support.
 * There are all sorts of wired in constants & nothing (yet)
 * to print SMT packets as anything other than hex dumps.
 * Most of the necessary changes are waiting on my redoing
 * the "header" that a kernel fddi driver supplies to bpf:  I
 * want it to look like one byte of 'direction' (0 or 1
 * depending on whether the packet was inbound or outbound),
 * two bytes of system/driver dependent data (anything an
 * implementor thinks would be useful to filter on and/or
 * save per-packet, then the real 21-byte FDDI header.
 * Steve McCanne & I have also talked about adding the
 * 'direction' byte to all bpf headers (e.g., in the two
 * bytes of padding on an ethernet header).  It's not clear
 * we could do this in a backwards compatible way & we hate
 * the idea of an incompatible bpf change.  Discussions are
 * proceeding.
 *
 * Also, to really support FDDI (and better support 802.2
 * over ethernet) we really need to re-think the rather simple
 * minded assumptions about fixed length & fixed format link
 * level headers made in gencode.c.  One day...
 *
 *  - vj
 *//*
 * Some FDDI interfaces use bit-swapped addresses.
 *//* Control bits *//* Class/Length/Format bits *//* MAC frame *//* SMT frame *//* Implementor Synch. *//* Implementor Async. *//* Sync. LLC frame *//* Async. LLC frame *//*
 * FDDI Frame Control values. (48-bit addressing only).
 *//* Frame format bits *//* Address length bit *//* Class bit *//*
 * FDDI Frame Control bits
 *//* Useful values for fddi_fc (frame control) field *//*
 * Length of an FDDI header; note that some compilers may pad
 * "struct fddi_header" to a multiple of 4 bytes, for example, so
 * "sizeof (struct fddi_header)" may not give the right
 * answer.
 *//* frame control *//*
 * Based on Ultrix if_fddi.h
 *//*
 * Copyright (c) 1991, 1992, 1993, 1994, 1995, 1996, 1997
 *	The Regents of the University of California.  All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that: (1) source code distributions
 * retain the above copyright notice and this paragraph in its entirety, (2)
 * distributions including binary code include the above copyright notice and
 * this paragraph in its entirety in the documentation or other materials
 * provided with the distribution, and (3) all advertising materials mentioning
 * features or use of this software display the following acknowledgement:
 * ``This product includes software developed by the University of California,
 * Lawrence Berkeley Laboratory and its contributors.'' Neither the name of
 * the University nor the names of its contributors may be used to endorse
 * or promote products derived from this software without specific prior
 * written permission.
 * THIS SOFTWARE IS PROVIDED ``AS IS'' AND WITHOUT ANY EXPRESS OR IMPLIED
 * WARRANTIES, INCLUDING, WITHOUT LIMITATION, THE IMPLIED WARRANTIES OF
 * MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE.
 *//Users/owura/Repos/codeql_eval/proj_repos/the-tcpdump-group-tcpdump-commit-0f95d441e4b5d7512cc5c326c8668a120e048eda/tcpdump/print-forces.cforces_printconst forceshconst forcesh *forcesh *fhdrflg_rawconst tom_hconst tom_h *tom_h *tops*fhdrsizeof(*fhdr)(ndo, "Invalid ForCES message type %d\n", fhdr->fm_tom)Invalid ForCES message type %d
&(fhdr)->fm_len(ndo, "\n\tUnknown ForCES message type=0x%x", fhdr->fm_tom)TOM_RSVD
	Unknown ForCES message type=0x%x(ndo, "\n\tForCES %s ", tops->s)
	ForCES %s (ndo, "Illegal ForCES pkt len - min %u, total recvd %d, advertised %d ", ForCES_HDRL, len, ForCES_BLN(fhdr))(ndo, "Illegal ForCES pkt len - min %u, total recvd %d, advertised %d ", 24, len, ((uint32_t)(((uint16_t)(((uint16_t)(*((const uint8_t *)(&(fhdr)->fm_len) + 0)) << 8) | ((uint16_t)(*((const uint8_t *)(&(fhdr)->fm_len) + 1)) << 0))) << 2)))Illegal ForCES pkt len - min %u, total recvd %d, advertised %d *(pptr + 20)pptr + 20(ndo, "\n\tForCES Version %d len %uB flags 0x%08x ", ForCES_V(fhdr), mlen, flg_raw)(ndo, "\n\tForCES Version %d len %uB flags 0x%08x ", ((fhdr)->fm_vrsvd >> 4), mlen, flg_raw)(ndo, "\n\tSrcID 0x%x(%s) DstID 0x%x(%s) Correlator 0x%" PRIx64, ForCES_SID(fhdr), ForCES_node(ForCES_SID(fhdr)), ForCES_DID(fhdr), ForCES_node(ForCES_DID(fhdr)), EXTRACT_64BITS(fhdr->fm_cor))(ndo, "\n\tSrcID 0x%x(%s) DstID 0x%x(%s) Correlator 0x%" "ll" "x", ((uint32_t)(((uint32_t)(*((const uint8_t *)(&(fhdr)->fm_sid) + 0)) << 24) | ((uint32_t)(*((const uint8_t *)(&(fhdr)->fm_sid) + 1)) << 16) | ((uint32_t)(*((const uint8_t *)(&(fhdr)->fm_sid) + 2)) << 8) | ((uint32_t)(*((const uint8_t *)(&(fhdr)->fm_sid) + 3)) << 0))), ForCES_node(((uint32_t)(((uint32_t)(*((const uint8_t *)(&(fhdr)->fm_sid) + 0)) << 24) | ((uint32_t)(*((const uint8_t *)(&(fhdr)->fm_sid) + 1)) << 16) | ((uint32_t)(*((const uint8_t *)(&(fhdr)->fm_sid) + 2)) << 8) | ((uint32_t)(*((const uint8_t *)(&(fhdr)->fm_sid) + 3)) << 0)))), ((uint32_t)(((uint32_t)(*((const uint8_t *)(&(fhdr)->fm_did) + 0)) << 24) | ((uint32_t)(*((const uint8_t *)(&(fhdr)->fm_did) + 1)) << 16) | ((uint32_t)(*((const uint8_t *)(&(fhdr)->fm_did) + 2)) << 8) | ((uint32_t)(*((const uint8_t *)(&(fhdr)->fm_did) + 3)) << 0))), ForCES_node(((uint32_t)(((uint32_t)(*((const uint8_t *)(&(fhdr)->fm_did) + 0)) << 24) | ((uint32_t)(*((const uint8_t *)(&(fhdr)->fm_did) + 1)) << 16) | ((uint32_t)(*((const uint8_t *)(&(fhdr)->fm_did) + 2)) << 8) | ((uint32_t)(*((const uint8_t *)(&(fhdr)->fm_did) + 3)) << 0)))), ((uint64_t)(((uint64_t)(*((const uint8_t *)(fhdr->fm_cor) + 0)) << 56) | ((uint64_t)(*((const uint8_t *)(fhdr->fm_cor) + 1)) << 48) | ((uint64_t)(*((const uint8_t *)(fhdr->fm_cor) + 2)) << 40) | ((uint64_t)(*((const uint8_t *)(fhdr->fm_cor) + 3)) << 32) | ((uint64_t)(*((const uint8_t *)(fhdr->fm_cor) + 4)) << 24) | ((uint64_t)(*((const uint8_t *)(fhdr->fm_cor) + 5)) << 16) | ((uint64_t)(*((const uint8_t *)(fhdr->fm_cor) + 6)) << 8) | ((uint64_t)(*((const uint8_t *)(fhdr->fm_cor) + 7)) << 0))))&(fhdr)->fm_sid&(fhdr)->fm_didfhdr->fm_cor
	ForCES Version %d len %uB flags 0x%08x 
	SrcID 0x%x(%s) DstID 0x%x(%s) Correlator 0x%llx(ndo, "\n\tForCES flags:\n\t  %s(0x%x), prio=%d, %s(0x%x),\n\t  %s(0x%x), %s(0x%x)\n", tok2str(ForCES_ACKs, "ACKUnknown", ForCES_ACK(fhdr)), ForCES_ACK(fhdr), ForCES_PRI(fhdr), tok2str(ForCES_EMs, "EMUnknown", ForCES_EM(fhdr)), ForCES_EM(fhdr), tok2str(ForCES_ATs, "ATUnknown", ForCES_AT(fhdr)), ForCES_AT(fhdr), tok2str(ForCES_TPs, "TPUnknown", ForCES_TP(fhdr)), ForCES_TP(fhdr))(ndo, "\n\tForCES flags:\n\t  %s(0x%x), prio=%d, %s(0x%x),\n\t  %s(0x%x), %s(0x%x)\n", tok2str(ForCES_ACKs, "ACKUnknown", ((((uint32_t)(((uint32_t)(*((const uint8_t *)(&(fhdr)->fm_flags) + 0)) << 24) | ((uint32_t)(*((const uint8_t *)(&(fhdr)->fm_flags) + 1)) << 16) | ((uint32_t)(*((const uint8_t *)(&(fhdr)->fm_flags) + 2)) << 8) | ((uint32_t)(*((const uint8_t *)(&(fhdr)->fm_flags) + 3)) << 0)))&0xC0000000) >> 30)), ((((uint32_t)(((uint32_t)(*((const uint8_t *)(&(fhdr)->fm_flags) + 0)) << 24) | ((uint32_t)(*((const uint8_t *)(&(fhdr)->fm_flags) + 1)) << 16) | ((uint32_t)(*((const uint8_t *)(&(fhdr)->fm_flags) + 2)) << 8) | ((uint32_t)(*((const uint8_t *)(&(fhdr)->fm_flags) + 3)) << 0)))&0xC0000000) >> 30), ((((uint32_t)(((uint32_t)(*((const uint8_t *)(&(fhdr)->fm_flags) + 0)) << 24) | ((uint32_t)(*((const uint8_t *)(&(fhdr)->fm_flags) + 1)) << 16) | ((uint32_t)(*((const uint8_t *)(&(fhdr)->fm_flags) + 2)) << 8) | ((uint32_t)(*((const uint8_t *)(&(fhdr)->fm_flags) + 3)) << 0)))&0x38000000) >> 27), tok2str(ForCES_EMs, "EMUnknown", ((((uint32_t)(((uint32_t)(*((const uint8_t *)(&(fhdr)->fm_flags) + 0)) << 24) | ((uint32_t)(*((const uint8_t *)(&(fhdr)->fm_flags) + 1)) << 16) | ((uint32_t)(*((const uint8_t *)(&(fhdr)->fm_flags) + 2)) << 8) | ((uint32_t)(*((const uint8_t *)(&(fhdr)->fm_flags) + 3)) << 0)))&0x00C00000) >> 22)), ((((uint32_t)(((uint32_t)(*((const uint8_t *)(&(fhdr)->fm_flags) + 0)) << 24) | ((uint32_t)(*((const uint8_t *)(&(fhdr)->fm_flags) + 1)) << 16) | ((uint32_t)(*((const uint8_t *)(&(fhdr)->fm_flags) + 2)) << 8) | ((uint32_t)(*((const uint8_t *)(&(fhdr)->fm_flags) + 3)) << 0)))&0x00C00000) >> 22), tok2str(ForCES_ATs, "ATUnknown", ((((uint32_t)(((uint32_t)(*((const uint8_t *)(&(fhdr)->fm_flags) + 0)) << 24) | ((uint32_t)(*((const uint8_t *)(&(fhdr)->fm_flags) + 1)) << 16) | ((uint32_t)(*((const uint8_t *)(&(fhdr)->fm_flags) + 2)) << 8) | ((uint32_t)(*((const uint8_t *)(&(fhdr)->fm_flags) + 3)) << 0)))&0x00200000) >> 21)), ((((uint32_t)(((uint32_t)(*((const uint8_t *)(&(fhdr)->fm_flags) + 0)) << 24) | ((uint32_t)(*((const uint8_t *)(&(fhdr)->fm_flags) + 1)) << 16) | ((uint32_t)(*((const uint8_t *)(&(fhdr)->fm_flags) + 2)) << 8) | ((uint32_t)(*((const uint8_t *)(&(fhdr)->fm_flags) + 3)) << 0)))&0x00200000) >> 21), tok2str(ForCES_TPs, "TPUnknown", ((((uint32_t)(((uint32_t)(*((const uint8_t *)(&(fhdr)->fm_flags) + 0)) << 24) | ((uint32_t)(*((const uint8_t *)(&(fhdr)->fm_flags) + 1)) << 16) | ((uint32_t)(*((const uint8_t *)(&(fhdr)->fm_flags) + 2)) << 8) | ((uint32_t)(*((const uint8_t *)(&(fhdr)->fm_flags) + 3)) << 0)))&0x00180000) >> 19)), ((((uint32_t)(((uint32_t)(*((const uint8_t *)(&(fhdr)->fm_flags) + 0)) << 24) | ((uint32_t)(*((const uint8_t *)(&(fhdr)->fm_flags) + 1)) << 16) | ((uint32_t)(*((const uint8_t *)(&(fhdr)->fm_flags) + 2)) << 8) | ((uint32_t)(*((const uint8_t *)(&(fhdr)->fm_flags) + 3)) << 0)))&0x00180000) >> 19))&(fhdr)->fm_flags(ndo, "\t  Extra flags: rsv(b5-7) 0x%x rsv(b13-31) 0x%x\n", ForCES_RS1(fhdr), ForCES_RS2(fhdr))(ndo, "\t  Extra flags: rsv(b5-7) 0x%x rsv(b13-31) 0x%x\n", ((((uint32_t)(((uint32_t)(*((const uint8_t *)(&(fhdr)->fm_flags) + 0)) << 24) | ((uint32_t)(*((const uint8_t *)(&(fhdr)->fm_flags) + 1)) << 16) | ((uint32_t)(*((const uint8_t *)(&(fhdr)->fm_flags) + 2)) << 8) | ((uint32_t)(*((const uint8_t *)(&(fhdr)->fm_flags) + 3)) << 0)))&0x07000000) >> 24), ((((uint32_t)(((uint32_t)(*((const uint8_t *)(&(fhdr)->fm_flags) + 0)) << 24) | ((uint32_t)(*((const uint8_t *)(&(fhdr)->fm_flags) + 1)) << 16) | ((uint32_t)(*((const uint8_t *)(&(fhdr)->fm_flags) + 2)) << 8) | ((uint32_t)(*((const uint8_t *)(&(fhdr)->fm_flags) + 3)) << 0)))&0x0007FFFF) >> 0))
	ForCES flags:
	  %s(0x%x), prio=%d, %s(0x%x),
	  %s(0x%x), %s(0x%x)
ACKUnknown939524096EMUnknown12582912ATUnknown2097152TPUnknown1572864	  Extra flags: rsv(b5-7) 0x%x rsv(b13-31) 0x%x
117440512524287(ndo, "\n\t]")
	["\n\t["
	](ndo, "\n\t  Raw ForCES message\n\t [")(ndo, "\n\t ]")
	  Raw ForCES message
	 [
	 "\n\t "
	 ]forces_type_printconst forces_tlvconst forces_tlv *forces_tlv *tltlvrleninvtlvttlvForCES_HDRL(ndo, "<0x%x>Illegal Top level TLV!\n", tops->flags)(ndo, "\tTop level TLV Data missing!\n")TLV_HLNZERO_TTLV<0x%x>Illegal Top level TLV!
ZERO_MORE_TTLVONE_MORE_TTLV	Top level TLV Data missing!
*tltlvsizeof(*tltlv)&tltlv->type(ndo, "\n\tInvalid ForCES Top TLV type=0x%x", EXTRACT_16BITS(&tltlv->type))(ndo, "\n\tInvalid ForCES Top TLV type=0x%x", ((uint16_t)(((uint16_t)(*((const uint8_t *)(&tltlv->type) + 0)) << 8) | ((uint16_t)(*((const uint8_t *)(&tltlv->type) + 1)) << 0))))(ndo, "\t%s, length %d (data length %d Bytes)", tok2str(ForCES_TLV, NULL, EXTRACT_16BITS(&tltlv->type)), EXTRACT_16BITS(&tltlv->length), EXTRACT_16BITS(&tltlv->length) - TLV_HDRL)(ndo, "\t%s, length %d (data length %d Bytes)", tok2str(ForCES_TLV, ((void *)0), ((uint16_t)(((uint16_t)(*((const uint8_t *)(&tltlv->type) + 0)) << 8) | ((uint16_t)(*((const uint8_t *)(&tltlv->type) + 1)) << 0)))), ((uint16_t)(((uint16_t)(*((const uint8_t *)(&tltlv->length) + 0)) << 8) | ((uint16_t)(*((const uint8_t *)(&tltlv->length) + 1)) << 0))), ((uint16_t)(((uint16_t)(*((const uint8_t *)(&tltlv->length) + 0)) << 8) | ((uint16_t)(*((const uint8_t *)(&tltlv->length) + 1)) << 0))) - 4)&tltlv->lengthTLV_HDRLEXTRACT_16BITS(&(tltlv)->length)((uint16_t)(((uint16_t)(*((const uint8_t *)(&(tltlv)->length) + 0)) << 8) | ((uint16_t)(*((const uint8_t *)(&(tltlv)->length) + 1)) << 0)))&(tltlv)->length
	Invalid ForCES Top TLV type=0x%x	%s, length %d (data length %d Bytes)(ndo, "\tMess TopTLV header: min %u, total %d advertised %d ", TLV_HDRL, rlen, EXTRACT_16BITS(&tltlv->length))(ndo, "\tMess TopTLV header: min %u, total %d advertised %d ", 4, rlen, ((uint16_t)(((uint16_t)(*((const uint8_t *)(&tltlv->length) + 0)) << 8) | ((uint16_t)(*((const uint8_t *)(&tltlv->length) + 1)) << 0))))	Mess TopTLV header: min %u, total %d advertised %d lfbselect_printconst forces_lfbshconst forces_lfbsh *forces_lfbsh *lfbsotlvibdlen(ndo, "\n\t\ttruncated lfb selector: %d bytes missing! ", OP_MIN - dlen)(ndo, "\n\t\ttruncated lfb selector: %d bytes missing! ", 12 - dlen)OP_MIN
		truncated lfb selector: %d bytes missing! OP_OFF*lfbssizeof(*lfbs)(ndo, "\n%s%s(Classid %x) instance %x\n", ib, tok2str(ForCES_LFBs, NULL, EXTRACT_32BITS(&lfbs->class)), EXTRACT_32BITS(&lfbs->class), EXTRACT_32BITS(&lfbs->instance))(ndo, "\n%s%s(Classid %x) instance %x\n", ib, tok2str(ForCES_LFBs, ((void *)0), ((uint32_t)(((uint32_t)(*((const uint8_t *)(&lfbs->class) + 0)) << 24) | ((uint32_t)(*((const uint8_t *)(&lfbs->class) + 1)) << 16) | ((uint32_t)(*((const uint8_t *)(&lfbs->class) + 2)) << 8) | ((uint32_t)(*((const uint8_t *)(&lfbs->class) + 3)) << 0)))), ((uint32_t)(((uint32_t)(*((const uint8_t *)(&lfbs->class) + 0)) << 24) | ((uint32_t)(*((const uint8_t *)(&lfbs->class) + 1)) << 16) | ((uint32_t)(*((const uint8_t *)(&lfbs->class) + 2)) << 8) | ((uint32_t)(*((const uint8_t *)(&lfbs->class) + 3)) << 0))), ((uint32_t)(((uint32_t)(*((const uint8_t *)(&lfbs->instance) + 0)) << 24) | ((uint32_t)(*((const uint8_t *)(&lfbs->instance) + 1)) << 16) | ((uint32_t)(*((const uint8_t *)(&lfbs->instance) + 2)) << 8) | ((uint32_t)(*((const uint8_t *)(&lfbs->instance) + 3)) << 0))))&lfbs->class&lfbs->instance
%s%s(Classid %x) instance %x
*otlvsizeof(*otlv)&otlv->type(ndo, "\t\tINValid oper-TLV type 0x%x length %d for this ForCES message\n", EXTRACT_16BITS(&otlv->type), EXTRACT_16BITS(&otlv->length))(ndo, "\t\tINValid oper-TLV type 0x%x length %d for this ForCES message\n", ((uint16_t)(((uint16_t)(*((const uint8_t *)(&otlv->type) + 0)) << 8) | ((uint16_t)(*((const uint8_t *)(&otlv->type) + 1)) << 0))), ((uint16_t)(((uint16_t)(*((const uint8_t *)(&otlv->length) + 0)) << 8) | ((uint16_t)(*((const uint8_t *)(&otlv->length) + 1)) << 0))))&otlv->lengthEXTRACT_16BITS(&(otlv)->length)((uint16_t)(((uint16_t)(*((const uint8_t *)(&(otlv)->length) + 0)) << 8) | ((uint16_t)(*((const uint8_t *)(&(otlv)->length) + 1)) << 0)))&(otlv)->length		INValid oper-TLV type 0x%x length %d for this ForCES message
op_mskindent(ndo, "\n\t\tMessy oper TLV header, type (0x%x)\n\t\texcess of %d Bytes ", EXTRACT_16BITS(&otlv->type), rlen - EXTRACT_16BITS(&otlv->length))(ndo, "\n\t\tMessy oper TLV header, type (0x%x)\n\t\texcess of %d Bytes ", ((uint16_t)(((uint16_t)(*((const uint8_t *)(&otlv->type) + 0)) << 8) | ((uint16_t)(*((const uint8_t *)(&otlv->type) + 1)) << 0))), rlen - ((uint16_t)(((uint16_t)(*((const uint8_t *)(&otlv->length) + 0)) << 8) | ((uint16_t)(*((const uint8_t *)(&otlv->length) + 1)) << 0))))
		Messy oper TLV header, type (0x%x)
		excess of %d Bytes char[60]redirect_printtlv(ndo, "\n\t\ttruncated Redirect TLV: %d bytes missing! ", RD_MIN - dlen)(ndo, "\n\t\ttruncated Redirect TLV: %d bytes missing! ", 8 - dlen)RD_MIN
		truncated Redirect TLV: %d bytes missing! *tlvsizeof(*tlv)(ndo, "Bad Redirect data\n")&tlv->type&tlv->length(ndo, "Unknown REDIRECT TLV 0x%x len %d\n", EXTRACT_16BITS(&tlv->type), EXTRACT_16BITS(&tlv->length))(ndo, "Unknown REDIRECT TLV 0x%x len %d\n", ((uint16_t)(((uint16_t)(*((const uint8_t *)(&tlv->type) + 0)) << 8) | ((uint16_t)(*((const uint8_t *)(&tlv->type) + 1)) << 0))), ((uint16_t)(((uint16_t)(*((const uint8_t *)(&tlv->length) + 0)) << 8) | ((uint16_t)(*((const uint8_t *)(&tlv->length) + 1)) << 0))))EXTRACT_16BITS(&(tlv)->length)((uint16_t)(((uint16_t)(*((const uint8_t *)(&(tlv)->length) + 0)) << 8) | ((uint16_t)(*((const uint8_t *)(&(tlv)->length) + 1)) << 0)))&(tlv)->lengthBad Redirect data
F_TLV_METDF_TLV_REDDUnknown REDIRECT TLV 0x%x len %d
(ndo, "\n\t\tMessy Redirect TLV header, type (0x%x)\n\t\texcess of %d Bytes ", EXTRACT_16BITS(&tlv->type), rlen - EXTRACT_16BITS(&tlv->length))(ndo, "\n\t\tMessy Redirect TLV header, type (0x%x)\n\t\texcess of %d Bytes ", ((uint16_t)(((uint16_t)(*((const uint8_t *)(&tlv->type) + 0)) << 8) | ((uint16_t)(*((const uint8_t *)(&tlv->type) + 1)) << 0))), rlen - ((uint16_t)(((uint16_t)(*((const uint8_t *)(&tlv->length) + 0)) << 8) | ((uint16_t)(*((const uint8_t *)(&tlv->length) + 1)) << 0))))
		Messy Redirect TLV header, type (0x%x)
		excess of %d Bytes print_reddata(ndo, "\n%s Redirect Data length %d \n", ib, rlen)
%s Redirect Data length %d 
(ndo, "\t\t[")(ndo, "\n\t\t]")		[
		]print_metatlvconst forces_ilvconst forces_ilv *forces_ilv *ilvinvilv(ndo, "\n%s METADATA length %d \n", ib, rlen)
%s METADATA length %d 
*ilvsizeof(*ilv)EXTRACT_32BITS(&(ilv)->length)((uint32_t)(((uint32_t)(*((const uint8_t *)(&(ilv)->length) + 0)) << 24) | ((uint32_t)(*((const uint8_t *)(&(ilv)->length) + 1)) << 16) | ((uint32_t)(*((const uint8_t *)(&(ilv)->length) + 2)) << 8) | ((uint32_t)(*((const uint8_t *)(&(ilv)->length) + 3)) << 0)))&(ilv)->lengthprint_metailv&ilv->lengthILV_HDRL(ndo, "%sMetaID 0x%x length %d\n", ib, EXTRACT_32BITS(&ilv->type), EXTRACT_32BITS(&ilv->length))(ndo, "%sMetaID 0x%x length %d\n", ib, ((uint32_t)(((uint32_t)(*((const uint8_t *)(&ilv->type) + 0)) << 24) | ((uint32_t)(*((const uint8_t *)(&ilv->type) + 1)) << 16) | ((uint32_t)(*((const uint8_t *)(&ilv->type) + 2)) << 8) | ((uint32_t)(*((const uint8_t *)(&ilv->type) + 3)) << 0))), ((uint32_t)(((uint32_t)(*((const uint8_t *)(&ilv->length) + 0)) << 24) | ((uint32_t)(*((const uint8_t *)(&ilv->length) + 1)) << 16) | ((uint32_t)(*((const uint8_t *)(&ilv->length) + 2)) << 8) | ((uint32_t)(*((const uint8_t *)(&ilv->length) + 3)) << 0))))%sMetaID 0x%x length %d
&ilv->type(ndo, " ]\n")"\t\t[" ]
asrtlv_printrescode(ndo, "illegal ASRresult-TLV: %d bytes!\n", dlen)ASRDLNillegal ASRresult-TLV: %d bytes!
(ndo, "illegal ASRresult result code: %d!\n", rescode)ASRMCDillegal ASRresult result code: %d!
(ndo, "\n%s", ib)(ndo, "Success ")(ndo, "FE ID invalid ")(ndo, "permission denied ")(ndo, "Unknown ")(ndo, "(%x)\n%s", rescode, ib)
%sSuccess FE ID invalid permission denied Unknown (%x)
%sasttlv_print(ndo, "illegal ASTresult-TLV: %d bytes!\n", dlen)ASTDLNillegal ASTresult-TLV: %d bytes!
(ndo, "illegal ASTresult result code: %d!\n", rescode)ASTMCDillegal ASTresult result code: %d!
(ndo, "Teardown reason:\n%s", ib)(ndo, "Normal Teardown")(ndo, "Loss of Heartbeats")(ndo, "Out of bandwidth")(ndo, "Out of Memory")(ndo, "Application Crash")(ndo, "Unknown Teardown reason")Teardown reason:
%sNormal TeardownLoss of HeartbeatsOut of bandwidthOut of MemoryApplication CrashUnknown Teardown reasonotlv_printtllconst optlv_hconst optlv_h *optlv_h *ops(ndo, "%sOper TLV %s(0x%x) length %d\n", ib, ops->s, type, EXTRACT_16BITS(&otlv->length))(ndo, "%sOper TLV %s(0x%x) length %d\n", ib, ops->s, type, ((uint16_t)(((uint16_t)(*((const uint8_t *)(&otlv->length) + 0)) << 8) | ((uint16_t)(*((const uint8_t *)(&otlv->length) + 1)) << 0))))%sOper TLV %s(0x%x) length %d
(ndo, "%s: Illegal - MUST be empty\n", ops->s)%s: Illegal - MUST be empty
(ndo, "\t\tOper TLV %s(0x%x) length %d\n", ops->s, type, EXTRACT_16BITS(&otlv->length))(ndo, "\t\tOper TLV %s(0x%x) length %d\n", ops->s, type, ((uint16_t)(((uint16_t)(*((const uint8_t *)(&otlv->length) + 0)) << 8) | ((uint16_t)(*((const uint8_t *)(&otlv->length) + 1)) << 0))))(ndo, "\t\tTruncated data size %d minimum required %d\n", tll, OP_MIN_SIZ)(ndo, "\t\tTruncated data size %d minimum required %d\n", tll, 8)OP_MIN_SIZ		Oper TLV %s(0x%x) length %d
		Truncated data size %d minimum required %d
invoptlv_print(ndo, "%sData[", &ib[1])(ndo, "%s]\n", ib)%sData[%s]
recpdoptlv_printpdtlv*pdtlvsizeof(*pdtlv)&pdtlv->type&pdtlv->length(ndo, "%s%s, length %d (data encapsulated %d Bytes)", ib, tok2str(ForCES_TLV, NULL, type), EXTRACT_16BITS(&pdtlv->length), EXTRACT_16BITS(&pdtlv->length) - TLV_HDRL)(ndo, "%s%s, length %d (data encapsulated %d Bytes)", ib, tok2str(ForCES_TLV, ((void *)0), type), ((uint16_t)(((uint16_t)(*((const uint8_t *)(&pdtlv->length) + 0)) << 8) | ((uint16_t)(*((const uint8_t *)(&pdtlv->length) + 1)) << 0))), ((uint16_t)(((uint16_t)(*((const uint8_t *)(&pdtlv->length) + 0)) << 8) | ((uint16_t)(*((const uint8_t *)(&pdtlv->length) + 1)) << 0))) - 4)EXTRACT_16BITS(&(pdtlv)->length)((uint16_t)(((uint16_t)(*((const uint8_t *)(&(pdtlv)->length) + 0)) << 8) | ((uint16_t)(*((const uint8_t *)(&(pdtlv)->length) + 1)) << 0)))&(pdtlv)->length%s%s, length %d (data encapsulated %d Bytes)(ndo, "\n\t\tMessy PATHDATA TLV header, type (0x%x)\n\t\texcess of %d Bytes ", EXTRACT_16BITS(&pdtlv->type), len - EXTRACT_16BITS(&pdtlv->length))(ndo, "\n\t\tMessy PATHDATA TLV header, type (0x%x)\n\t\texcess of %d Bytes ", ((uint16_t)(((uint16_t)(*((const uint8_t *)(&pdtlv->type) + 0)) << 8) | ((uint16_t)(*((const uint8_t *)(&pdtlv->type) + 1)) << 0))), len - ((uint16_t)(((uint16_t)(*((const uint8_t *)(&pdtlv->length) + 0)) << 8) | ((uint16_t)(*((const uint8_t *)(&pdtlv->length) + 1)) << 0))))
		Messy PATHDATA TLV header, type (0x%x)
		excess of %d Bytes genoptlv_print(ndo, "genoptlvprint - %s TLV type 0x%x len %d\n", tok2str(ForCES_TLV, NULL, type), type, EXTRACT_16BITS(&pdtlv->length))(ndo, "genoptlvprint - %s TLV type 0x%x len %d\n", tok2str(ForCES_TLV, ((void *)0), type), type, ((uint16_t)(((uint16_t)(*((const uint8_t *)(&pdtlv->length) + 0)) << 8) | ((uint16_t)(*((const uint8_t *)(&pdtlv->length) + 1)) << 0))))genoptlvprint - %s TLV type 0x%x len %d
(ndo, "%s TLV type 0x%x len %d\n", tok2str(ForCES_TLV_err, NULL, invtlv), type, EXTRACT_16BITS(&pdtlv->length))(ndo, "%s TLV type 0x%x len %d\n", tok2str(ForCES_TLV_err, ((void *)0), invtlv), type, ((uint16_t)(((uint16_t)(*((const uint8_t *)(&pdtlv->length) + 0)) << 8) | ((uint16_t)(*((const uint8_t *)(&pdtlv->length) + 1)) << 0))))(ndo, "%s%s, length %d (data length %d Bytes)", ib, tok2str(ForCES_TLV, NULL, type), EXTRACT_16BITS(&pdtlv->length), tll)(ndo, "%s%s, length %d (data length %d Bytes)", ib, tok2str(ForCES_TLV, ((void *)0), type), ((uint16_t)(((uint16_t)(*((const uint8_t *)(&pdtlv->length) + 0)) << 8) | ((uint16_t)(*((const uint8_t *)(&pdtlv->length) + 1)) << 0))), tll)(ndo, "\t\t\tInvalid ForCES TLV type=%x", type)%s TLV type 0x%x len %d
%s%s, length %d (data length %d Bytes)			Invalid ForCES TLV type=%xpdata_printconst pathdata_hconst pathdata_h *pathdata_h *pdhminsizemore_pdidcnt*pdhsizeof(*pdh)sizeof(struct pathdata_h)(ndo, "\n%sPathdata: Flags 0x%x ID count %d\n", ib, EXTRACT_16BITS(&pdh->pflags), EXTRACT_16BITS(&pdh->pIDcnt))(ndo, "\n%sPathdata: Flags 0x%x ID count %d\n", ib, ((uint16_t)(((uint16_t)(*((const uint8_t *)(&pdh->pflags) + 0)) << 8) | ((uint16_t)(*((const uint8_t *)(&pdh->pflags) + 1)) << 0))), ((uint16_t)(((uint16_t)(*((const uint8_t *)(&pdh->pIDcnt) + 0)) << 8) | ((uint16_t)(*((const uint8_t *)(&pdh->pIDcnt) + 1)) << 0))))&pdh->pflags&pdh->pIDcnt
%sPathdata: Flags 0x%x ID count %d
F_SELKEYB_KEYINF_SELTABRANGEB_TRNGF_TABAPPENDB_APPND(ndo, "\t\t\ttruncated IDs expected %uB got %uB\n", minsize, len)(ndo, "]\n")			truncated IDs expected %uB got %uB
			ID Data["\t\t\tID Data["]
(ndo, "\t\t\tIllegal to have both Table ranges and keys\n")			Illegal to have both Table ranges and keys
consumedpdatacnt_print(ndo, "%sTABLE APPEND\n", ib)%sTABLE APPEND
(ndo, "%sID#%02u: %d\n", ib, i + 1, id)%sID#%02u: %d
(ndo, "pathlength %d with key/range too short %d\n", len, PTH_DESC_SIZE)(ndo, "pathlength %d with key/range too short %d\n", len, 12)(ndo, "%sTable range: [%d,%d]\n", ib, starti, endi)&keytlv->length(ndo, "key content length %u < %u\n", tll, TLV_HDRL)(ndo, "key content length %u < %u\n", tll, 4)(ndo, "key content too short\n")startiendiPTH_DESC_SIZEpathlength %d with key/range too short %d
sizeof(struct forces_tlv)%sTable range: [%d,%d]
keytlvIDcntkey content length %u < %u
key content too short
(ndo, "%s Outstanding bytes %d for TLV type 0x%x TLV len %d\n", tok2str(ForCES_TLV_err, NULL, invtlv), len, type, EXTRACT_16BITS(&pdtlv->length))(ndo, "%s Outstanding bytes %d for TLV type 0x%x TLV len %d\n", tok2str(ForCES_TLV_err, ((void *)0), invtlv), len, type, ((uint16_t)(((uint16_t)(*((const uint8_t *)(&pdtlv->length) + 0)) << 8) | ((uint16_t)(*((const uint8_t *)(&pdtlv->length) + 1)) << 0))))EXTRACT_16BITS(&pdtlv->length)((uint16_t)(((uint16_t)(*((const uint8_t *)(&pdtlv->length) + 0)) << 8) | ((uint16_t)(*((const uint8_t *)(&pdtlv->length) + 1)) << 0)))(ndo, "Invalid padded pathdata TLV type 0x%x len %d missing %d pad bytes\n", type, EXTRACT_16BITS(&pdtlv->length), aln - len)(ndo, "Invalid padded pathdata TLV type 0x%x len %d missing %d pad bytes\n", type, ((uint16_t)(((uint16_t)(*((const uint8_t *)(&pdtlv->length) + 0)) << 8) | ((uint16_t)(*((const uint8_t *)(&pdtlv->length) + 1)) << 0))), aln - len)(ndo, "%s  %s (Length %d DataLen %d pad %d Bytes)\n", ib, ops->s, EXTRACT_16BITS(&pdtlv->length), tll, pad)(ndo, "%s  %s (Length %d DataLen %d pad %d Bytes)\n", ib, ops->s, ((uint16_t)(((uint16_t)(*((const uint8_t *)(&pdtlv->length) + 0)) << 8) | ((uint16_t)(*((const uint8_t *)(&pdtlv->length) + 1)) << 0))), tll, pad)(ndo, "%s  %s (Length %d DataLen %d Bytes)\n", ib, ops->s, EXTRACT_16BITS(&pdtlv->length), tll)(ndo, "%s  %s (Length %d DataLen %d Bytes)\n", ib, ops->s, ((uint16_t)(((uint16_t)(*((const uint8_t *)(&pdtlv->length) + 0)) << 8) | ((uint16_t)(*((const uint8_t *)(&pdtlv->length) + 1)) << 0))), tll)(ndo, "Invalid path data content type 0x%x len %d\n", type, EXTRACT_16BITS(&pdtlv->length))(ndo, "Invalid path data content type 0x%x len %d\n", type, ((uint16_t)(((uint16_t)(*((const uint8_t *)(&pdtlv->length) + 0)) << 8) | ((uint16_t)(*((const uint8_t *)(&pdtlv->length) + 1)) << 0))))aln%s Outstanding bytes %d for TLV type 0x%x TLV len %d
Invalid padded pathdata TLV type 0x%x len %d missing %d pad bytes
const pdata_opsconst pdata_ops *pdata_ops *272F_TLV_PDAT%s  %s (Length %d DataLen %d pad %d Bytes)
%s  %s (Length %d DataLen %d Bytes)
Invalid path data content type 0x%x len %d
pd_errBad Data val
	  ["Bad Data val\n\t  ["pkeyitlv_printtdpkdtlv*tdpsizeof(*tdp)(ndo, "%sKeyinfo: Key 0x%x\n", ib, id)%sKeyinfo: Key 0x%x
*kdtlvsizeof(*kdtlv)&kdtlv->type(ndo, "%s TLV type 0x%x len %d\n", tok2str(ForCES_TLV_err, NULL, invtlv), type, EXTRACT_16BITS(&kdtlv->length))(ndo, "%s TLV type 0x%x len %d\n", tok2str(ForCES_TLV_err, ((void *)0), invtlv), type, ((uint16_t)(((uint16_t)(*((const uint8_t *)(&kdtlv->length) + 0)) << 8) | ((uint16_t)(*((const uint8_t *)(&kdtlv->length) + 1)) << 0))))&kdtlv->lengthsdatatlv_print(ndo, "Error: expecting SPARSEDATA!\n")275F_TLV_SPADError: expecting SPARSEDATA!
sdatailv_print(ndo, "Error: BAD SPARSEDATA-TLV!\n")Error: BAD SPARSEDATA-TLV!
(ndo, "%s[", &ib[1])(ndo, "\n%s]\n", &ib[1])(ndo, "\n%s ILV: type %x length %d\n", &ib[1], EXTRACT_32BITS(&ilv->type), ilvl)(ndo, "\n%s ILV: type %x length %d\n", &ib[1], ((uint32_t)(((uint32_t)(*((const uint8_t *)(&ilv->type) + 0)) << 24) | ((uint32_t)(*((const uint8_t *)(&ilv->type) + 1)) << 16) | ((uint32_t)(*((const uint8_t *)(&ilv->type) + 2)) << 8) | ((uint32_t)(*((const uint8_t *)(&ilv->type) + 3)) << 0))), ilvl)%s[
%s]
ilvl
%s ILV: type %x length %d
fdatatlv_print(ndo, "Error: expecting FULLDATA!\n")F_TLV_FULDError: expecting FULLDATA!
prestlv_printres_val *(ndo, "illegal RESULT-TLV: %d bytes!\n", dlen)RESLENillegal RESULT-TLV: %d bytes!
*rsizeof(*r)(ndo, "illegal reserved result code: 0x%x!\n", r->result)0xFEillegal reserved result code: 0x%x!
(ndo, "%s  Result: %s (code 0x%x)\n", ib, tok2str(ForCES_errs, NULL, r->result), r->result)(ndo, "%s  Result: %s (code 0x%x)\n", ib, tok2str(ForCES_errs, ((void *)0), r->result), r->result)%s  Result: %s (code 0x%x)
const tok[26]tok[26]get_forces_pdPD_MAX_INDpdoconst pdata_ops[11]pdata_ops[11]PD_RSV_IPD_RSV_I + 1TOM_RSV_Ichk_op_type(ndo, "Based on flags expected KEYINFO TLV!\n")(ndo, "Illegal DATA encoding for type 0x%x programmed %x got %x \n", type, omsk, msk)F_TLV_KEYIBased on flags expected KEYINFO TLV!
Illegal DATA encoding for type 0x%x programmed %x got %x 
char[59]pd_validF_TLV_RESTget_forces_tomTOM_MAX_INDthconst tom_h[11]tom_h[11]ilv_validINVALID_RLENINVALID_STLNINVALID_LTLNEXTRACT_32BITS(&ilv->length)((uint32_t)(((uint32_t)(*((const uint8_t *)(&ilv->length) + 0)) << 24) | ((uint32_t)(*((const uint8_t *)(&ilv->length) + 1)) << 16) | ((uint32_t)(*((const uint8_t *)(&ilv->length) + 2)) << 8) | ((uint32_t)(*((const uint8_t *)(&ilv->length) + 3)) << 0)))INVALID_ALENtlv_validEXTRACT_16BITS(&tlv->length)((uint16_t)(((uint16_t)(*((const uint8_t *)(&tlv->length) + 0)) << 8) | ((uint16_t)(*((const uint8_t *)(&tlv->length) + 1)) << 0)))pdmskomsktomttlv_valid0x1100x116op_validopbindent_prIND_SIZE(IND_SIZE - 1)IND_PREFIND_CHRIND_SUFget_forces_optlv_hF_OP_MAXF_OP_RSVconst optlv_h[15]optlv_h[15]ForCES_node10737418230x3FFFFFFFFE"FE"10737418240x4000000021474836470x7FFFFFFFCE"CE"0xC000000042949672790xFFFFFFEFAllMulticast"AllMulticast"42949672930xFFFFFFFDAllCEsBroadcast"AllCEsBroadcast"0xFFFFFFFEAllFEsBroadcast"AllFEsBroadcast"0xFFFFFFFFAllBroadcast"AllBroadcast"ForCESreserved"ForCESreserved"tom_validE_SUCCESSE_INVALID_HEADERE_LENGTH_MISMATCHE_VERSION_MISMATCHE_INVALID_DESTINATION_PIDE_LFB_UNKNOWNE_LFB_NOT_FOUNDE_LFB_INSTANCE_ID_NOT_FOUNDE_INVALID_PATHE_COMPONENT_DOES_NOT_EXISTE_EXISTSE_NOT_FOUNDE_READ_ONLYE_INVALID_ARRAY_CREATIONE_VALUE_OUT_OF_RANGEE_CONTENTS_TOO_LONGE_INVALID_PARAMETERSE_INVALID_MESSAGE_TYPEE_INVALID_FLAGSE_INVALID_TLVE_EVENT_ERRORE_NOT_SUPPORTEDE_MEMORY_ERRORE_INTERNAL_ERRORE_UNSPECIFIED_ERROR0XFFres_valPD_SEL_IPD_FDT_IPD_SDT_IPD_RES_IPD_PDT_I_PD_RSV_MAXpdata_opsforces_lfbshforces_tlvforces_ilvpathdata_hoptlv_hB_OP_SETF_OP_SETF_OP_SET - 1(F_OP_SET - 1)1 << (F_OP_SET - 1)B_OP_SETPROPF_OP_SETPROPF_OP_SETPROP - 1(F_OP_SETPROP - 1)1 << (F_OP_SETPROP - 1)B_OP_SETRESPF_OP_SETRESPF_OP_SETRESP - 1(F_OP_SETRESP - 1)1 << (F_OP_SETRESP - 1)B_OP_SETPRESPF_OP_SETPRESPF_OP_SETPRESP - 1(F_OP_SETPRESP - 1)1 << (F_OP_SETPRESP - 1)B_OP_DELF_OP_DELF_OP_DEL - 1(F_OP_DEL - 1)1 << (F_OP_DEL - 1)B_OP_DELRESPF_OP_DELRESPF_OP_DELRESP - 1(F_OP_DELRESP - 1)1 << (F_OP_DELRESP - 1)B_OP_GETF_OP_GETF_OP_GET - 1(F_OP_GET - 1)1 << (F_OP_GET - 1)B_OP_GETPROPF_OP_GETPROPF_OP_GETPROP - 1(F_OP_GETPROP - 1)1 << (F_OP_GETPROP - 1)B_OP_GETRESPF_OP_GETRESPF_OP_GETRESP - 1(F_OP_GETRESP - 1)1 << (F_OP_GETRESP - 1)B_OP_GETPRESPF_OP_GETPRESPF_OP_GETPRESP - 1(F_OP_GETPRESP - 1)1 << (F_OP_GETPRESP - 1)B_OP_REPORTF_OP_REPORTF_OP_REPORT - 1(F_OP_REPORT - 1)1 << (F_OP_REPORT - 1)B_OP_COMMITF_OP_COMMITF_OP_COMMIT - 1(F_OP_COMMIT - 1)1 << (F_OP_COMMIT - 1)B_OP_RCOMMITF_OP_RCOMMITF_OP_RCOMMIT - 1(F_OP_RCOMMIT - 1)1 << (F_OP_RCOMMIT - 1)B_OP_RTRCOMPF_OP_RTRCOMPF_OP_RTRCOMP - 1(F_OP_RTRCOMP - 1)1 << (F_OP_RTRCOMP - 1)_F_OP_MAXforceshTOM_ASS_ITOM_AST_ITOM_CFG_ITOM_QRY_ITOM_EVN_ITOM_RED_ITOM_HBT_ITOM_ASR_ITOM_CNR_ITOM_QRR_I_TOM_RSV_MAXtom_hresv2resv1resultprintvinstancepIDcntpflagsfm_flagsfm_corfm_didfm_sidfm_lenfm_tomfm_vrsvdSUCCESS"SUCCESS"INVALID HEADER"INVALID HEADER"LENGTH MISMATCH"LENGTH MISMATCH"VERSION MISMATCH"VERSION MISMATCH"INVALID DESTINATION PID"INVALID DESTINATION PID"LFB UNKNOWN"LFB UNKNOWN"LFB NOT FOUND"LFB NOT FOUND"LFB INSTANCE ID NOT FOUND"LFB INSTANCE ID NOT FOUND"INVALID PATH"INVALID PATH"COMPONENT DOES NOT EXIST"COMPONENT DOES NOT EXIST"EXISTS ALREADY"EXISTS ALREADY"NOT FOUND"NOT FOUND"READ ONLY"READ ONLY"INVALID ARRAY CREATION"INVALID ARRAY CREATION"VALUE OUT OF RANGE"VALUE OUT OF RANGE"CONTENTS TOO LONG"CONTENTS TOO LONG"INVALID PARAMETERS"INVALID PARAMETERS"INVALID MESSAGE TYPE"INVALID MESSAGE TYPE"INVALID FLAGS"INVALID FLAGS"INVALID TLV"INVALID TLV"EVENT ERROR"EVENT ERROR"NOT SUPPORTED"NOT SUPPORTED"MEMORY ERROR"MEMORY ERROR"INTERNAL ERROR"INTERNAL ERROR"UNSPECIFIED ERROR"UNSPECIFIED ERROR"ForCES_errsInvalid message"Invalid message"KEYINFO TLV"KEYINFO TLV"B_FULLDFULLDATA TLV"FULLDATA TLV"B_SPARDSPARSEDATA TLV"SPARSEDATA TLV"B_RESTVRESULT TLV"RESULT TLV"Inner PATH-DATA TLV"Inner PATH-DATA TLV"ForCES_pdataTOM_ASSNSETUPTWO_TLVASSNS_OPSAssociation Setup"Association Setup"TOM_ASSNTEARDTTLV_T1Association TearDown"Association TearDown"TOM_CONFIG244TTLV_T2206710259CFG_OPSConfig"Config"TOM_QUERYCFG_QYTOM_EVENTNOTCFG_EVNEvent Notification"Event Notification"TOM_PKTREDIRPacket Redirect"Packet Redirect"TOM_HEARTBTHeartBeat"HeartBeat"TOM_ASSNSETREPAssociation Response"Association Response"TOM_CONFIGREP4140CFG_ROPSConfig Response"Config Response"nlprefTOM_QUERYREPCFG_QYRQuery Response"Query Response"ForCES_msgInvalid total length"Invalid total length"xLV too short"xLV too short"xLV too long"xLV too long"data padding missing"data padding missing"ForCES_TLV_errF_TLV_RSVDInvalid TLV"Invalid TLV"F_TLV_REDRREDIRECT TLV"REDIRECT TLV"F_TLV_ASRSASResult TLV"ASResult TLV"F_TLV_ASRTASTreason TLV"ASTreason TLV"F_TLV_LFBSLFBselect TLV"LFBselect TLV"PATH-DATA TLV"PATH-DATA TLV"METADATA TLV"METADATA TLV"REDIRECTDATA TLV"REDIRECTDATA TLV"ForCES_TLVind_bufInvalid OPTLV"Invalid OPTLV" Set" Set" SetProp" SetProp" SetResp" SetResp" SetPropResp" SetPropResp" Del" Del" DelResp" DelResp" Get" Get" GetProp" GetProp" GetResp" GetResp" GetPropResp" GetPropResp"" Report" Commit" Commit" RCommit" RCommit" RTRCOMP" RTRCOMP"OPTLV_msgF_LFB_RSVDF_LFB_FEOFEObj LFB"FEObj LFB"F_LFB_FEPOFEProtoObj LFB"FEProtoObj LFB"ForCES_LFBsStartofTransaction"StartofTransaction"MiddleofTransaction"MiddleofTransaction"EndofTransaction"EndofTransaction"abort"abort"ForCES_TPsStandalone"Standalone"2PCtransaction"2PCtransaction"ForCES_ATsEMReserved"EMReserved"execute-all-or-none"execute-all-or-none"execute-until-failure"execute-until-failure"continue-execute-on-failure"continue-execute-on-failure"ForCES_EMsNoACK"NoACK"SuccessACK"SuccessACK"FailureACK"FailureACK"AlwaysACK"AlwaysACK"ForCES_ACKs[|forces]"[|forces]"(_TOM_RSV_MAX - 1)(B_OP_REPORT)(B_OP_GETRESP|B_OP_GETPRESP)(B_OP_GET|B_OP_GETPROP)(B_OP_SETRESP|B_OP_SETPRESP|B_OP_DELRESP|B_OP_RCOMMIT)(B_OP_SET|B_OP_SETPROP|B_OP_DEL|B_OP_COMMIT|B_OP_RTRCOMP)GO_NXT_ILV(ilv,rlen)((rlen) -= F_ALN_LEN(EXTRACT_32BITS(&(ilv)->length)), (struct forces_ilv *)(((char*)(ilv)) + F_ALN_LEN(EXTRACT_32BITS(&(ilv)->length))))ILV_DATA(ilvp)((void*)(((char*)(ilvp)) + ILV_SET_LEN(0)))ILV_RDAT_LEN(ilv)((int)(EXTRACT_32BITS(&(ilv)->length)) - ILV_SET_LEN(0))ILV_ALN_LEN(len)F_ALN_LEN(ILV_SET_LEN(len))ILV_SET_LEN(len)(F_ALN_LEN(ILV_HDRL) + (len))GO_NXT_TLV(tlv,rlen)((rlen) -= F_ALN_LEN(EXTRACT_16BITS(&(tlv)->length)), (struct forces_tlv*)(((char*)(tlv)) + F_ALN_LEN(EXTRACT_16BITS(&(tlv)->length))))TLV_DATA(tlvp)((void*)(((char*)(tlvp)) + TLV_SET_LEN(0)))TLV_RDAT_LEN(tlv)((int)(EXTRACT_16BITS(&(tlv)->length) - TLV_SET_LEN(0))TLV_ALN_LEN(len)F_ALN_LEN(TLV_SET_LEN(len))TLV_SET_LEN(len)(F_ALN_LEN(TLV_HDRL) + (len))GET_TOP_TLV(fhdr)((struct forces_tlv *)((fhdr) + sizeof (struct forcesh)))F_ALN_LEN(len)( ((len)+ForCES_ALNL-1) & ~(ForCES_ALNL-1) )F_TLV_VNSTF_TLV_TRNG0x01130x01100x00110x0010(_F_OP_MAX - 1)ForCES_HLN_VALID(fhl,tlen)((tlen) >= ForCES_HDRL && (fhl) >= ForCES_HDRL && (fhl) == (tlen))ForCES_RS2(forcesh)((EXTRACT_32BITS(&(forcesh)->fm_flags)&0x0007FFFF) >> 0)ForCES_TP(forcesh)((EXTRACT_32BITS(&(forcesh)->fm_flags)&0x00180000) >> 19)ForCES_AT(forcesh)((EXTRACT_32BITS(&(forcesh)->fm_flags)&0x00200000) >> 21)ForCES_EM(forcesh)((EXTRACT_32BITS(&(forcesh)->fm_flags)&0x00C00000) >> 22)ForCES_RS1(forcesh)((EXTRACT_32BITS(&(forcesh)->fm_flags)&0x07000000) >> 24)ForCES_PRI(forcesh)((EXTRACT_32BITS(&(forcesh)->fm_flags)&0x38000000) >> 27)ForCES_ACK(forcesh)((EXTRACT_32BITS(&(forcesh)->fm_flags)&0xC0000000) >> 30)ForCES_DID(forcesh)EXTRACT_32BITS(&(forcesh)->fm_did)ForCES_SID(forcesh)EXTRACT_32BITS(&(forcesh)->fm_sid)ForCES_BLN(forcesh)((uint32_t)(EXTRACT_16BITS(&(forcesh)->fm_len) << 2))ForCES_V(forcesh)((forcesh)->fm_vrsvd >> 4)(ONE_MORE_TTLV|MAX_TLV)(ONE_MORE_TTLV|ONE_TLV)MAX_TLVONE_TLVZERO_TLVForCES_ALNLForCES_VERS/*
	 * XXX - if ttlv != 0, does that mean that the packet was too
	 * short, and didn't have *enough* TLVs in it?
	 *//*
		 * At this point, tlv_valid() has ensured that the TLV
		 * length is large enough but not too large (it doesn't
		 * go past the end of the packet).
		 *//*XXX: 15 top level tlvs will probably be fine
	   You are nuts if you send more ;-> *//*
	 * forces_print() has already checked that mlen >= ForCES_HDRL
	 * by calling ForCES_HLN_VALID().
	 *//*
		 * At this point, tlv_valid() has ensured that the TLV
		 * length is large enough but not too large (it doesn't
		 * go past the end of the containing TLV).
		 *//*
	 * At this point, we know that dlen > OP_MIN; OP_OFF < OP_MIN, so
	 * we also know that it's > OP_OFF.
	 *//* id, instance, oper tlv header .. *//*
	 * forces_type_print() has ensured that len (the TLV length)
	 * >= TLV_HDRL.
	 *//*
		 * At this point, ilv_valid() has ensured that the ILV
		 * length is large enough but not too large (it doesn't
		 * go past the end of the containing TLV).
		 *//*
	 * redirect_print() has ensured that len (what remains in the
	 * TLV) >= TLV_HDRL.
	 *//*
	 * print_metatlv() has ensured that len (what remains in the
	 * ILV) >= ILV_HDRL.
	 *//* XXX: check header length *//* at least 32 bits must exist *//*
 * XXX - not used.
 *//* id, instance, oper tlv *//* rest of ops must at least have 12B {pathinfo} *//* instead of "if (tll)" - for readability .. *//* empty TLVs like COMMIT and TRCOMMIT are empty, we stop here .. *//*
	 * lfbselect_print() has ensured that EXTRACT_16BITS(&otlv->length)
	 * >= TLV_HDRL.
	 *//* XXX: Argh, recurse some more *//* Table SET append operation *//* Table GET Range operation *//* skip key content *//* skip header *//* skip keyid *//*
	 * At this point, tlv_valid() has ensured that the TLV
	 * length is large enough but not too large (it doesn't
	 * go past the end of the containing TLV).
	 *//*
	 * pdatacnt_print() has ensured that len (the TLV length)
	 * >= TLV_HDRL.
	 *//*
	 * pdatacnt_print() or pkeyitlv_print() has ensured that len
	 * (the TLV length) >= TLV_HDRL.
	 *//* 0x18-0xFE are reserved .. *//* PD_PDT_I *//* PD_RES_I *//* PD_SDT_I *//* PD_FDT_I *//* PD_SEL_I *//* PD_RSV_I *//* TOM_QRR_I *//* TOM_CNR_I *//* TOM_ASR_I *//* TOM_HBT_I *//* TOM_RED_I *//* TOM_EVN_I *//* TOM_QRY_I *//* TOM_CFG_I *//* TOM_AST_I *//* TOM_ASS_I *//* TOM_RSV_I *//* XXX: *//* I guess we should allow vendor operations? *//* F_OP_RTRCOMP *//* F_OP_RCOMMIT *//* F_OP_COMMIT *//* F_OP_REPORT *//* F_OP_GETPRESP *//* F_OP_GETRESP *//* F_OP_GETPROP *//* F_OP_GET *//* F_OP_DELRESP *//* F_OP_DEL *//* F_OP_SETPRESP *//* F_OP_SETRESP *//* F_OP_SETPROP *//* F_OP_SET *//* F_OP_RSV *//* flags *//* correlator *//* Destination ID *//* Source ID *//* total length * 4 bytes *//* type of message *//* version and reserved *//*
 * Structure of forces header, naked of TLVs.
 *//*
 * tom_h Flags: resv1(8b):maxtlvs(4b):resv2(2b):mintlv(2b)
*//*
 * Per draft-ietf-forces-protocol-22
*//*
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that: (1) source code
 * distributions retain the above copyright notice and this paragraph
 * in its entirety, and (2) distributions including binary code include
 * the above copyright notice and this paragraph in its entirety in
 * the documentation or other materials provided with the distribution.
 * THIS SOFTWARE IS PROVIDED ``AS IS'' AND
 * WITHOUT ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, WITHOUT
 * LIMITATION, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS
 * FOR A PARTICULAR PURPOSE.
 *
 * Copyright (c) 2009 Mojatatu Networks, Inc
 *
 *//Users/owura/Repos/codeql_eval/proj_repos/the-tcpdump-group-tcpdump-commit-0f95d441e4b5d7512cc5c326c8668a120e048eda/tcpdump/print-fr.cfr_q933_print_ie_codeset5const ie_tlv_header_tconst ie_tlv_header_t *ie_tlv_header_t *dlci(ndo, "%s (%u)", tok2str(fr_lmi_report_type_ie_values,"unknown",p[2]), p[2])(ndo, "TX Seq: %3d, RX Seq: %3d", p[2], p[3])(ndo, "Invalid DLCI IE")(ndo, "DLCI %u: status %s%s", dlci, p[ie_p->ie_len + 1] & 0x8 ? "New, " : "", p[ie_p->ie_len + 1] & 0x2 ? "Active" : "Inactive")FR_LMI_ANSI_REPORT_TYPE_IEFR_LMI_CCITT_REPORT_TYPE_IE%s (%u)FR_LMI_ANSI_LINK_VERIFY_IEFR_LMI_CCITT_LINK_VERIFY_IEFR_LMI_ANSI_LINK_VERIFY_IE_91TX Seq: %3d, RX Seq: %3dFR_LMI_ANSI_PVC_STATUS_IEFR_LMI_CCITT_PVC_STATUS_IEInvalid DLCI IE0x780x7EDLCI %u: status %s%sNew, ActiveInactiveq933_printptempie_polenis_ansicodesetie_is_known(ndo, "[|q.933]")[|q.933]MSG_ANSI_LOCKING_SHIFT(ndo, "%s", ndo->ndo_eflag ? "" : "Q.933, ")Q.933, (ndo, "%s, codeset %u", is_ansi ? "ANSI" : "CCITT", codeset)%s, codeset %uANSICCITT(ndo, ", Call Ref: 0x%02x", p[0]), Call Ref: 0x%02x(ndo, ", %s (0x%02x), length %u", tok2str(fr_q933_msg_values, "unknown message", p[1]), p[1], length)(ndo, ", %s", tok2str(fr_q933_msg_values, "unknown message 0x%02x", p[1])), %s (0x%02x), length %uunknown messageunknown message 0x%02x(ndo, "\n[|q.933]")(ndo, ", length %u", olen)(ndo, "\n\t%s IE (0x%02x), length %u: ", tok2str(fr_q933_ie_codesets[codeset], "unknown", ie_p->ie_type), ie_p->ie_type, ie_p->ie_len)sizeof(struct ie_tlv_header_t)
[|q.933]
	%s IE (0x%02x), length %u: const codeset_pr_func_tconst codeset_pr_func_t[16]..(*[16])(..)const codeset_pr_func_t *frf15_printsequence_numMFR_BEC_MASK0x1e(ndo, "FRF.15, seq 0x%03x, Flags [%s],%s Fragmentation, length %u", sequence_num, bittok2str(frf_flag_values,"none",flags), p[0]&FR_FRF15_FRAGTYPE ? "Interface" : "End-to-End", length)(ndo, "FRF.15, seq 0x%03x, Flags [%s],%s Fragmentation, length %u", sequence_num, bittok2str(frf_flag_values,"none",flags), p[0]&0x01 ? "Interface" : "End-to-End", length)FRF.15, seq 0x%03x, Flags [%s],%s Fragmentation, length %uInterfaceEnd-to-Endmfr_printhdr_lenie_typeie_len(ndo, "FRF.16 Control, Flags [%s], %s, length %u", bittok2str(frf_flag_values,"none",(p[0] & MFR_BEC_MASK)), tok2str(mfr_ctrl_msg_values,"Unknown Message (0x%02x)",p[2]), length)(ndo, "FRF.16 Control, Flags [%s], %s, length %u", bittok2str(frf_flag_values,"none",(p[0] & (0x80 | 0x40 | 0x20))), tok2str(mfr_ctrl_msg_values,"Unknown Message (0x%02x)",p[2]), length)(ndo, "\n\tIE %s (%u), length %u: ", tok2str(mfr_ctrl_ie_values,"Unknown",ie_type), ie_type, ie_len)(ndo, "0x%08x", EXTRACT_32BITS(tptr))(ndo, "0x%08x", ((uint32_t)(((uint32_t)(*((const uint8_t *)(tptr) + 0)) << 24) | ((uint32_t)(*((const uint8_t *)(tptr) + 1)) << 16) | ((uint32_t)(*((const uint8_t *)(tptr) + 2)) << 8) | ((uint32_t)(*((const uint8_t *)(tptr) + 3)) << 0))))MFR_CTRL_FRAMEFRF.16 Control, Flags [%s], %s, length %uUnknown Message (0x%02x)
	IE %s (%u), length %u: MFR_CTRL_IE_MAGIC_NUM0x%08xMFR_CTRL_IE_BUNDLE_IDMFR_CTRL_IE_LINK_IDMFR_ID_STRING_MAXLENMFR_CTRL_IE_TIMESTAMPsizeof(struct timeval)const timevalconst timeval *timeval *MFR_CTRL_IE_VENDOR_EXTMFR_CTRL_IE_CAUSE(ndo, "FRF.16 Frag, seq %u, Flags [%s], ", sequence_num, bittok2str(frf_flag_values,"none",(p[0] & MFR_BEC_MASK)))(ndo, "FRF.16 Frag, seq %u, Flags [%s], ", sequence_num, bittok2str(frf_flag_values,"none",(p[0] & (0x80 | 0x40 | 0x20))))MFR_FRAG_FRAMEMFR_B_BITFRF.16 Frag, seq %u, Flags [%s], (ndo, "FRF.16 Frag, seq %u, Flags [%s]", sequence_num, bittok2str(frf_flag_values,"none",(p[0] & MFR_BEC_MASK)))(ndo, "FRF.16 Frag, seq %u, Flags [%s]", sequence_num, bittok2str(frf_flag_values,"none",(p[0] & (0x80 | 0x40 | 0x20))))FRF.16 Frag, seq %u, Flags [%s](ndo, "[|mfr]")[|mfr]mfr_if_printfr_printaddr_lennlpid(ndo, "Q.922, invalid address")u_int *Q.922, invalid addressaddr_len+1+1p+addr_len(ndo, "UI %02x! ", p[addr_len])UI %02x! (ndo, "Pad! ")(ndo, "No pad! ")Pad! No pad! p - hdr_lenlength + hdr_len(ndo, "[|fr]")[|fr]fr_if_printfr_hdr_print(ndo, "Q.922, DLCI %u, length %u: ", dlci, length)(ndo, "Q.922, hdr-len %u, DLCI %u, Flags [%s], NLPID %s (0x%02x), length %u: ", addr_len, dlci, bittok2str(fr_header_flag_values, "none", EXTRACT_32BITS(flags)), tok2str(nlpid_values,"unknown", nlpid), nlpid, length)(ndo, "Q.922, hdr-len %u, DLCI %u, Flags [%s], NLPID %s (0x%02x), length %u: ", addr_len, dlci, bittok2str(fr_header_flag_values, "none", ((uint32_t)(((uint32_t)(*((const uint8_t *)(flags) + 0)) << 24) | ((uint32_t)(*((const uint8_t *)(flags) + 1)) << 16) | ((uint32_t)(*((const uint8_t *)(flags) + 2)) << 8) | ((uint32_t)(*((const uint8_t *)(flags) + 3)) << 0)))), tok2str(nlpid_values,"unknown", nlpid), nlpid, length)(ndo, "Q.922, hdr-len %u, DLCI %u, Flags [%s], cisco-ethertype %s (0x%04x), length %u: ", addr_len, dlci, bittok2str(fr_header_flag_values, "none", EXTRACT_32BITS(flags)), tok2str(ethertype_values, "unknown", nlpid), nlpid, length)(ndo, "Q.922, hdr-len %u, DLCI %u, Flags [%s], cisco-ethertype %s (0x%04x), length %u: ", addr_len, dlci, bittok2str(fr_header_flag_values, "none", ((uint32_t)(((uint32_t)(*((const uint8_t *)(flags) + 0)) << 24) | ((uint32_t)(*((const uint8_t *)(flags) + 1)) << 16) | ((uint32_t)(*((const uint8_t *)(flags) + 2)) << 8) | ((uint32_t)(*((const uint8_t *)(flags) + 3)) << 0)))), tok2str(ethertype_values, "unknown", nlpid), nlpid, length)Q.922, DLCI %u, length %u: Q.922, hdr-len %u, DLCI %u, Flags [%s], NLPID %s (0x%02x), length %u: Q.922, hdr-len %u, DLCI %u, Flags [%s], cisco-ethertype %s (0x%04x), length %u: fr_hdrlensizeof("DLCI xxxxxxxxxx")buffer0, sizeof(buffer)sizeof(buffer)"DLCI %u", dlciDLCI %uparse_q922_addrFR_EA_BIT0xFCcodeset_pr_func_tie_tlv_header_tconst codeset_pr_func_t[]..(*[])(..)fr_q933_print_ie_codesetconst tok *[]tok *[]fr_q933_ie_codesetsFR_LMI_REPORT_TYPE_IE_FULL_STATUSFull Status"Full Status"FR_LMI_REPORT_TYPE_IE_LINK_VERIFYLink verify"Link verify"FR_LMI_REPORT_TYPE_IE_ASYNC_PVCAsync PVC Status"Async PVC Status"fr_lmi_report_type_ie_valuesANSI Report Type"ANSI Report Type"ANSI Link Verify"ANSI Link Verify"ANSI PVC Status"ANSI PVC Status"CCITT Report Type"CCITT Report Type"CCITT Link Verify"CCITT Link Verify"CCITT PVC Status"CCITT PVC Status"fr_q933_ie_values_codeset5MSG_TYPE_ESC_TO_NATIONALESC to National"ESC to National"MSG_TYPE_ALERTAlert"Alert"MSG_TYPE_CALL_PROCEEDINGCall proceeding"Call proceeding"MSG_TYPE_CONNECTMSG_TYPE_CONNECT_ACKConnect ACK"Connect ACK"MSG_TYPE_PROGRESSProgress"Progress"MSG_TYPE_SETUPMSG_TYPE_DISCONNECTDisconnect"Disconnect"MSG_TYPE_RELEASEMSG_TYPE_RELEASE_COMPLETERelease Complete"Release Complete"MSG_TYPE_RESTARTMSG_TYPE_RESTART_ACKRestart ACK"Restart ACK"MSG_TYPE_STATUSStatus Reply"Status Reply"MSG_TYPE_STATUS_ENQStatus Enquiry"Status Enquiry"fr_q933_msg_valuesBundle ID"Bundle ID"Link ID"Link ID"Magic Number"Magic Number"Timestamp"Timestamp"Vendor Extension"Vendor Extension"Cause"Cause"mfr_ctrl_ie_valuesMFR_CTRL_MSG_ADD_LINKAdd Link"Add Link"MFR_CTRL_MSG_ADD_LINK_ACKAdd Link ACK"Add Link ACK"MFR_CTRL_MSG_ADD_LINK_REJAdd Link Reject"Add Link Reject"MFR_CTRL_MSG_HELLOMFR_CTRL_MSG_HELLO_ACKHello ACK"Hello ACK"MFR_CTRL_MSG_REMOVE_LINKRemove Link"Remove Link"MFR_CTRL_MSG_REMOVE_LINK_ACKRemove Link ACK"Remove Link ACK"mfr_ctrl_msg_valuesBegin"Begin"MFR_E_BITMFR_C_BITfrf_flag_values33554432FR_CR_BITC!"C!"FR_DE_BITDE"DE"FR_BECN_BITBECN"BECN"524288FR_FECN_BITFECN"FECN"FR_SDLC_BITsdlcore"sdlcore"fr_header_flag_values0x570x530x510x190x950x7D0x4E0x5A0x4D0x45FR_FRF15_FRAGTYPE(MFR_B_BIT | MFR_E_BIT )(MFR_B_BIT | MFR_E_BIT | MFR_C_BIT)0x000000020x000800000x000400000x000200000x02000000/* now parse the DLCI information element. *//* do we want to see a hexdump of the IE ? *//* sanity check *//* lets do the full IE parsing only in verbose mode
                 * however some IEs (DLCI Status, Link Verify)
                 * are also interestting in non-verbose mode *//* not bark if there is just a trailer *//* Loop through the rest of IE *//* preserve the original length for non verbose mode *//* printing out header part *//* extract the codeset *//* shortest: Q.933a LINK VERIFY *//* array of 16 codepages - currently we only support codepage 1,5 *//* details? *//* Status *//* Call Clear *//* Call Establish *//*
 * L2 (Octet 2)- Message Types definition 1 byte long.
 *//* L2 (Octet 1)- Call Reference Usually is 0x0 *//* Q.933 packet format
                      Format of Other Protocols
                          using Q.933 NLPID
                  +-------------------------------+
                  |        Q.922 Address          |
                  +---------------+---------------+
                  |Control  0x03  | NLPID   0x08  |
                  +---------------+---------------+
                  |          L2 Protocol ID       |
                  | octet 1       |  octet 2      |
                  +-------------------------------+
                  |          L3 Protocol ID       |
                  | octet 2       |  octet 2      |
                  +-------------------------------+
                  |         Protocol Data         |
                  +-------------------------------+
                  | FCS                           |
                  +-------------------------------+
 *//*
 * Q.933 decoding portion for framerelay specific.
 *//* TODO:
 * depending on all permutations of the B, E and C bit
 * dig as deep as we can - e.g. on the first (B) fragment
 * there is enough payload to print the IP header
 * on non (B) fragments it depends if the fragmentation
 * model is end-to-end or interface based wether we want to print
 * another Q.922 header
 *//* an NLPID of 0xb1 indicates a 2-byte
 * FRF.15 header
 *
 *      7    6    5    4    3    2    1    0
 *    +----+----+----+----+----+----+----+----+
 *    ~              Q.922 header             ~
 *    +----+----+----+----+----+----+----+----+
 *    |             NLPID (8 bits)            | NLPID=0xb1
 *    +----+----+----+----+----+----+----+----+
 *    | B  | E  | C  |seq. (high 4 bits) | R  |
 *    +----+----+----+----+----+----+----+----+
 *    |        sequence  (low 8 bits)         |
 *    +----+----+----+----+----+----+----+----+
 *//* must be a middle or the last fragment *//* whole packet or first fragment ? *//*
 * FRF.16 Fragmentation Frame
 *
 *      7    6    5    4    3    2    1    0
 *    +----+----+----+----+----+----+----+----+
 *    | B  | E  | C=0|seq. (high 4 bits) | EA  |
 *    +----+----+----+----+----+----+----+----+
 *    |        sequence  (low 8 bits)         |
 *    +----+----+----+----+----+----+----+----+
 *    |        DLCI (6 bits)        | CR | EA  |
 *    +----+----+----+----+----+----+----+----+
 *    |   DLCI (4 bits)   |FECN|BECN| DE | EA |
 *    +----+----+----+----+----+----+----+----+
 *//*
                 * FIXME those are the defined IEs that lack a decoder
                 * you are welcome to contribute code ;-)
                 *//* fall through and hexdump if no unix timestamp *//* don't print null termination *//* same message format *//* tlv len includes header *//* minimum frame header length *//*
 * FRF.16 Link Integrity Control Frame
 *
 *      7    6    5    4    3    2    1    0
 *    +----+----+----+----+----+----+----+----+
 *    | B  | E  | C=1| 0    0    0    0  | EA |
 *    +----+----+----+----+----+----+----+----+
 *    | 0    0    0    0    0    0    0    0  |
 *    +----+----+----+----+----+----+----+----+
 *    |              message type             |
 *    +----+----+----+----+----+----+----+----+
 *//* OSI printers need the NLPID field *//* pad byte should be used with 3-byte Q.922 *//* ether_type not known, probably it wasn't one *//* lets figure out if we have cisco style encapsulation: *//* must be an ethertype *//* if its smaller than 256 then its a NLPID *//* NLPID *//* UI *//* pad *//* pad exist *//* Frame Relay packet structure, with flags and CRC removed

                  +---------------------------+
                  |       Q.922 Address*      |
                  +--                       --+
                  |                           |
                  +---------------------------+
                  | Control (UI = 0x03)       |
                  +---------------------------+
                  | Optional Pad      (0x00)  |
                  +---------------------------+
                  | NLPID                     |
                  +---------------------------+
                  |             .             |
                  |             .             |
                  |             .             |
                  |           Data            |
                  |             .             |
                  |             .             |
                  +---------------------------+

           * Q.922 addresses, as presently defined, are two octets and
             contain a 10-bit DLCI.  In some networks Q.922 addresses
             may optionally be increased to three or four octets.
*//* more than 4 bytes of Q.922 address? *//* 4-byte Q.922 address *//* 3- or 4-byte Q.922 address *//* 2-byte Q.922 address *//* clear the rest of the flags *//* populate the first flag fields *//* Finds out Q.922 address length, DLCI and flags. Returns 0 on success
 * save the flags dep. on address length
 *//* FRF.15 / FRF.16 *//*
 * the frame relay header has a variable length
 *
 * the EA bit determines if there is another byte
 * in the header
 *
 * minimum header length is 2 bytes
 * maximum header length is 4 bytes
 *
 *      7    6    5    4    3    2    1    0
 *    +----+----+----+----+----+----+----+----+
 *    |        DLCI (6 bits)        | CR | EA |
 *    +----+----+----+----+----+----+----+----+
 *    |   DLCI (4 bits)   |FECN|BECN| DE | EA |
 *    +----+----+----+----+----+----+----+----+
 *    |           DLCI (7 bits)          | EA |
 *    +----+----+----+----+----+----+----+----+
 *    |        DLCI (6 bits)        |SDLC| EA |
 *    +----+----+----+----+----+----+----+----+
 *//Users/owura/Repos/codeql_eval/proj_repos/the-tcpdump-group-tcpdump-commit-0f95d441e4b5d7512cc5c326c8668a120e048eda/tcpdump/print-ftp.cftp_printftp"ftp"@(#) $Header$"@(#) $Header$"rcsidlint/*
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that: (1) source code
 * distributions retain the above copyright notice and this paragraph
 * in its entirety, and (2) distributions including binary code include
 * the above copyright notice and this paragraph in its entirety in
 * the documentation or other materials provided with the distribution.
 * THIS SOFTWARE IS PROVIDED ``AS IS'' AND
 * WITHOUT ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, WITHOUT
 * LIMITATION, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS
 * FOR A PARTICULAR PURPOSE.
 *//Users/owura/Repos/codeql_eval/proj_repos/the-tcpdump-group-tcpdump-commit-0f95d441e4b5d7512cc5c326c8668a120e048eda/tcpdump/print-geonet.cgeonet_print(ndo, "GeoNet src:%s; ", etheraddr_string(ndo, eth+6))GeoNet src:%s; bp+4(ndo, "v:%d ", version)(ndo, "NH:%d-%s ", next_hdr, next_hdr_txt)(ndo, "HT:%d-%d-%s ", hdr_type, hdr_subtype, hdr_type_txt)(ndo, "HopLim:%d ", hop_limit)(ndo, "Payload:%d ", payload_length)(ndo, "Malformed (small) ")next_hdrhdr_typehdr_subtypepayload_lengthhop_limitnext_hdr_txthdr_type_txthdr_sizeAny"Any"BTP-A"BTP-A"BTP-B"BTP-B"GeoUnicast"GeoUnicast"GeoAnycastCircle"GeoAnycastCircle"GeoAnycastRect"GeoAnycastRect"GeoAnycastElipse"GeoAnycastElipse"GeoBroadcastCircle"GeoBroadcastCircle"GeoBroadcastRect"GeoBroadcastRect"GeoBroadcastElipse"GeoBroadcastElipse"TopoScopeBcast-SH"TopoScopeBcast-SH"TopoScopeBcast-MH"TopoScopeBcast-MH"LocService-Request"LocService-Request"LocService-Reply"LocService-Reply"v:%d NH:%d-%s HT:%d-%d-%s HopLim:%d Payload:%d 68 - 36Malformed (small) print_long_pos_vectorlat(ndo, "GN_ADDR:%s ", linkaddr_string (ndo, bp, 0, GEONET_ADDR_LEN))(ndo, "GN_ADDR:%s ", linkaddr_string (ndo, bp, 0, 8))GN_ADDR:%s bp+12(ndo, "lat:%d ", lat)lat:%d bp+16(ndo, "lon:%d", lon)lon:%dprint_btpbp+0bp+2(ndo, "; BTP Dst:%u Src:%u", dest, src); BTP Dst:%u Src:%uprint_btp_bodymsg_typemsg_type_str"unknown (%u)"(ndo, "; ItsPduHeader v:%d t:%d-%s", version, msg_type, msg_type_str); ItsPduHeader v:%d t:%d-%sCAM"CAM"DENM"DENM"TPEGM"TPEGM"TSPDM"TSPDM"VPM"VPM"SRM"SRM"SLAM"SLAM"ecoCAM"ecoCAM"ITM"ITM"SA"SA"msg_type_valuesGEONET_ADDR_LEN/* Print user data part *//* IPv6 *//* BTP A/B *//* Any *//* Skip Extended headers *//* LocService-Reply *//* LocService-Request *//* TopoScopeBcast-MH *//* TopoScopeBcast-SH *//* GeoBroadcastElipse *//* GeoBroadcastRect *//* GeoBroadcastCircle *//* GeoAnycastElipse *//* GeoAnycastRect *//* GeoAnycastCircle *//* GeoUnicast *//* Beacon *//* Process Extended Headers *//* Skip Common Header *//* Process Common Header *//*
 * This is the top level routine of the printer.  'p' points
 * to the geonet header of the packet.
 *//* Assuming ItsDpuHeader *//*
   ETSI TS 102 636-5-1 V1.1.1 (2011-02)
   Intelligent Transport Systems (ITS); Vehicular Communications; GeoNetworking;
   Part 5: Transport Protocols; Sub-part 1: Basic Transport Protocol

   ETSI TS 102 636-4-1 V1.1.1 (2011-06)
   Intelligent Transport Systems (ITS); Vehicular communications; GeoNetworking;
   Part 4: Geographical addressing and forwarding for point-to-point and point-to-multipoint communications;
   Sub-part 1: Media-Independent Functionality
*//Users/owura/Repos/codeql_eval/proj_repos/the-tcpdump-group-tcpdump-commit-0f95d441e4b5d7512cc5c326c8668a120e048eda/tcpdump/print-gre.cgre_sre_asn_print(ndo, ", badoffset=%u", sreoff), badoffset=%u(ndo, ", badlength=%u", srelen), badlength=%u(ndo, ", badoff/len=%u/%u", sreoff, srelen), badoff/len=%u/%u(ndo, " %s%x", ((bp - up) == sreoff) ? "*" : "", EXTRACT_16BITS(bp))(ndo, " %s%x", ((bp - up) == sreoff) ? "*" : "", ((uint16_t)(((uint16_t)(*((const uint8_t *)(bp) + 0)) << 8) | ((uint16_t)(*((const uint8_t *)(bp) + 1)) << 0)))) %s%xgre_sre_ip_printa&abp, sizeof(a)(ndo, " %s%s", ((bp - up) == sreoff) ? "*" : "", inet_ntoa(a)) %s%sgre_sre_print(ndo, ", (rtaf=ip")(ndo, ", (rtaf=asn")(ndo, ", (rtaf=0x%x) ", af)GRESRE_IP, (rtaf=ip65534GRESRE_ASN, (rtaf=asn, (rtaf=0x%x) gre_print_1prot(ndo, ", Flags [%s]", bittok2str(gre_flag_values,"none",flags))(ndo, ", call %d", k & 0xffff)GRE_KP, call %d(ndo, ", seq %u", EXTRACT_32BITS(bp))(ndo, ", seq %u", ((uint32_t)(((uint32_t)(*((const uint8_t *)(bp) + 0)) << 24) | ((uint32_t)(*((const uint8_t *)(bp) + 1)) << 16) | ((uint32_t)(*((const uint8_t *)(bp) + 2)) << 8) | ((uint32_t)(*((const uint8_t *)(bp) + 3)) << 0))))GRE_SP, seq %u(ndo, ", ack %u", EXTRACT_32BITS(bp))(ndo, ", ack %u", ((uint32_t)(((uint32_t)(*((const uint8_t *)(bp) + 0)) << 24) | ((uint32_t)(*((const uint8_t *)(bp) + 1)) << 16) | ((uint32_t)(*((const uint8_t *)(bp) + 2)) << 8) | ((uint32_t)(*((const uint8_t *)(bp) + 3)) << 0))))GRE_AP, ack %usreoffsrelen(ndo, ", no-payload"), no-payload(ndo, ", proto %s (0x%04x)", tok2str(ethertype_values,"unknown",prot), prot), proto %s (0x%04x)(ndo, ", length %u",length)(ndo, "\n\t")(ndo, "gre-proto-0x%x", prot)gre-proto-0x%xgre_print_0(ndo, ", sum 0x%x", EXTRACT_16BITS(bp))(ndo, ", sum 0x%x", ((uint16_t)(((uint16_t)(*((const uint8_t *)(bp) + 0)) << 8) | ((uint16_t)(*((const uint8_t *)(bp) + 1)) << 0))))(ndo, ", off 0x%x", EXTRACT_16BITS(bp))(ndo, ", off 0x%x", ((uint16_t)(((uint16_t)(*((const uint8_t *)(bp) + 0)) << 8) | ((uint16_t)(*((const uint8_t *)(bp) + 1)) << 0))))GRE_CPGRE_RP, sum 0x%x, off 0x%x(ndo, ", key=0x%x", EXTRACT_32BITS(bp))(ndo, ", key=0x%x", ((uint32_t)(((uint32_t)(*((const uint8_t *)(bp) + 0)) << 24) | ((uint32_t)(*((const uint8_t *)(bp) + 1)) << 16) | ((uint32_t)(*((const uint8_t *)(bp) + 2)) << 8) | ((uint32_t)(*((const uint8_t *)(bp) + 3)) << 0)))), key=0x%xgre_printGRE_VERS_MASK(ndo, "GREv%u",vers)GREv%u(ndo, " ERROR: unknown-version") ERROR: unknown-versionchecksum present"checksum present"routing present"routing present"key present"key present"sequence# present"sequence# present"GRE_sPsource routing present"source routing present"1792GRE_RECRSrecursion count"recursion count"ack present"ack present"gre_flag_values[|gre]"[|gre]"0xfffe0x00800x0700/* if verbose go multiline *//* put in a colon as protocol demarc *//* ASN *//* IP *//* source route entry types *//* protocol version *//* acknowledgment# present *//* recursion count *//* source routing *//* sequence# present *//* key present *//* routing present *//* checksum present *//*
 * tcpdump filter for GRE - Generic Routing Encapsulation
 * RFC1701 (GRE), RFC1702 (GRE IPv4), and RFC2637 (Enhanced GRE)
 *//*
 * Copyright (c) 2002 Jason L. Wright (jason@thought.net)
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *	This product includes software developed by Jason L. Wright
 * 4. The name of the author may not be used to endorse or promote products
 *    derived from this software without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
 * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
 * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT,
 * INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
 * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
 * SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
 * STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN
 * ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
 * POSSIBILITY OF SUCH DAMAGE.
 *//*	$OpenBSD: print-gre.c,v 1.6 2002/10/30 03:04:04 fgsch Exp $	*//Users/owura/Repos/codeql_eval/proj_repos/the-tcpdump-group-tcpdump-commit-0f95d441e4b5d7512cc5c326c8668a120e048eda/tcpdump/print-hsrp.chsrp_printhsrp *hp->hsrp_versionsizeof(hp->hsrp_version)(ndo, "HSRPv%d", hp->hsrp_version)HSRPv%dhp->hsrp_op_codesizeof(hp->hsrp_op_code)(ndo, "-")(ndo, "%s ", tok2strary(op_code_str, "unknown (%d)", hp->hsrp_op_code))(ndo, "%s ", tok2strary_internal(op_code_str, sizeof(op_code_str)/sizeof(op_code_str[0]),"unknown (%d)",hp->hsrp_op_code))op_code_str"unknown (%d)"unknown (%d)(ndo, "%d: ", len)hp->hsrp_statesizeof(hp->hsrp_state)(ndo, "state=%s ", tok2str(states, "Unknown (%d)", hp->hsrp_state))state=%s Unknown (%d)hp->hsrp_groupsizeof(hp->hsrp_group)(ndo, "group=%d ", hp->hsrp_group)group=%d hp->hsrp_reservedsizeof(hp->hsrp_reserved)(ndo, "[reserved=%d!] ", hp->hsrp_reserved)[reserved=%d!] hp->hsrp_virtaddrsizeof(hp->hsrp_virtaddr)(ndo, "addr=%s", ipaddr_string(ndo, &hp->hsrp_virtaddr))(ndo, "addr=%s", getname(ndo, (const u_char *)(&hp->hsrp_virtaddr)))addr=%s&hp->hsrp_virtaddr(ndo, " hellotime=")(ndo, " holdtime=")(ndo, " priority=%d", hp->hsrp_priority)(ndo, " auth=\"") hellotime= holdtime= priority=%d auth="HSRP_AUTH_SIZEsizeof(hp->hsrp_authdata)(ndo, "[|hsrp]")[|hsrp]hsrphsrp_virtaddrhsrp_authdatahsrp_reservedhsrp_grouphsrp_priorityhsrp_holdtimehsrp_hellotimehsrp_statehsrp_op_codehsrp_versioninitial"initial"learn"learn"listen"listen"speak"speak"standby"standby"active"active"statescoup"coup"resign"resign"/* HSRP protocol header. *//*
 * RFC 2281:
 *
 *  0                   1                   2                   3
 *  0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
 * +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
 * |   Version     |   Op Code     |     State     |   Hellotime   |
 * +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
 * |   Holdtime    |   Priority    |     Group     |   Reserved    |
 * +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
 * |                      Authentication  Data                     |
 * +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
 * |                      Authentication  Data                     |
 * +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
 * |                      Virtual IP Address                       |
 * +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
 *//* HSRP states and associated names. *//* HSRP op code types. *//* Cisco Hot Standby Router Protocol (HSRP). *//*
 * Copyright (C) 2001 Julian Cowley
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. Neither the name of the project nor the names of its contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE PROJECT AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE PROJECT OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 *//Users/owura/Repos/codeql_eval/proj_repos/the-tcpdump-group-tcpdump-commit-0f95d441e4b5d7512cc5c326c8668a120e048eda/tcpdump/print-http.chttp_printhttp"http"const char *[39]char *[39]RESP_CODE_SECOND_TOKENGET"GET"PUT"PUT"COPY"COPY"HEAD"HEAD"LOCK"LOCK"MOVE"MOVE"POLL"POLL"POST"POST"BCOPY"BCOPY"BMOVE"BMOVE"MKCOL"MKCOL"TRACE"TRACE"LABEL"LABEL"MERGE"MERGE"DELETE"DELETE"SEARCH"SEARCH"UNLOCK"UNLOCK"REPORT"REPORT"UPDATE"UPDATE"NOTIFY"NOTIFY"BDELETE"BDELETE""CONNECT"OPTIONS"OPTIONS"CHECKIN"CHECKIN"PROPFIND"PROPFIND"CHECKOUT"CHECKOUT"CCM_POST"CCM_POST"SUBSCRIBE"SUBSCRIBE"PROPPATCH"PROPPATCH"BPROPFIND"BPROPFIND"BPROPPATCH"BPROPPATCH"UNCHECKOUT"UNCHECKOUT"MKACTIVITY"MKACTIVITY"MKWORKSPACE"MKWORKSPACE"UNSUBSCRIBE"UNSUBSCRIBE"RPC_CONNECT"RPC_CONNECT"VERSION-CONTROL"VERSION-CONTROL"BASELINE-CONTROL"BASELINE-CONTROL"httpcmds/*
 * Includes WebDAV requests.
 *//Users/owura/Repos/codeql_eval/proj_repos/the-tcpdump-group-tcpdump-commit-0f95d441e4b5d7512cc5c326c8668a120e048eda/tcpdump/mpls.hMPLS_TTL(x)(((x) & TTL_MASK) >> TTL_SHIFT)MPLS_STACK(x)(((x) & STACK_MASK) >> STACK_SHIFT)MPLS_EXP(x)(((x) & EXP_MASK) >> EXP_SHIFT)MPLS_LABEL(x)(((x) & LABEL_MASK) >> LABEL_SHIFT)TTL_SHIFTTTL_MASK0x000000ffSTACK_SHIFTSTACK_MASK0x00000100EXP_SHIFTEXP_MASK0x00000e00LABEL_SHIFTLABEL_MASK0xfffff000/*
 * Copyright (C) 2001 WIDE Project.  All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. Neither the name of the project nor the names of its contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE PROJECT AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE PROJECT OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 *//Users/owura/Repos/codeql_eval/proj_repos/the-tcpdump-group-tcpdump-commit-0f95d441e4b5d7512cc5c326c8668a120e048eda/tcpdump/print-icmp.c"mpls.h"icmp_printconst icmpconst icmp *icmp *const icmp_ext_tconst icmp_ext_t *icmp_ext_t *ext_dpfmtoipconst udphdrconst udphdr *udphdr *ouhobj_tptrraw_labelsnapend_saveconst icmp_mpls_ext_object_header_tconst icmp_mpls_ext_object_header_t *icmp_mpls_ext_object_header_t *icmp_mpls_ext_object_headerobj_tlenobj_class_numobj_ctypedp->icmp_codesizeof(dp->icmp_code)dp->icmp_seqdp->icmp_hun.ih_idseq.icd_seqsizeof(dp->icmp_hun.ih_idseq.icd_seq)"echo %s, id %u, seq %u", dp->icmp_type == ICMP_ECHO ? "request" : "reply", EXTRACT_16BITS(&dp->icmp_id), EXTRACT_16BITS(&dp->icmp_seq)"echo %s, id %u, seq %u", dp->icmp_type == 8 ? "request" : "reply", ((uint16_t)(((uint16_t)(*((const uint8_t *)(&dp->icmp_hun.ih_idseq.icd_id) + 0)) << 8) | ((uint16_t)(*((const uint8_t *)(&dp->icmp_hun.ih_idseq.icd_id) + 1)) << 0))), ((uint16_t)(((uint16_t)(*((const uint8_t *)(&dp->icmp_hun.ih_idseq.icd_seq) + 0)) << 8) | ((uint16_t)(*((const uint8_t *)(&dp->icmp_hun.ih_idseq.icd_seq) + 1)) << 0)))&dp->icmp_id&dp->icmp_hun.ih_idseq.icd_id&dp->icmp_seq&dp->icmp_hun.ih_idseq.icd_seqdp->icmp_ip.ip_dstdp->icmp_dun.id_ip.idi_ip.ip_dstsizeof(dp->icmp_dun.id_ip.idi_ip.ip_dst)dp->icmp_ip.ip_pdp->icmp_dun.id_ip.idi_ip.ip_psizeof(dp->icmp_dun.id_ip.idi_ip.ip_p)"%s protocol %d unreachable", ipaddr_string(ndo, &dp->icmp_ip.ip_dst), dp->icmp_ip.ip_p"%s protocol %d unreachable", getname(ndo, (const u_char *)(&dp->icmp_dun.id_ip.idi_ip.ip_dst)), dp->icmp_dun.id_ip.idi_ip.ip_p&dp->icmp_ip.ip_dst&dp->icmp_dun.id_ip.idi_ip.ip_dstouh->uh_dportsizeof(ouh->uh_dport)&ouh->uh_dport"%s tcp port %s unreachable", ipaddr_string(ndo, &oip->ip_dst), tcpport_string(dport)"%s tcp port %s unreachable", getname(ndo, (const u_char *)(&oip->ip_dst)), tcpport_string(dport)&oip->ip_dst"%s udp port %s unreachable", ipaddr_string(ndo, &oip->ip_dst), udpport_string(dport)"%s udp port %s unreachable", getname(ndo, (const u_char *)(&oip->ip_dst)), udpport_string(dport)"%s protocol %d port %d unreachable", ipaddr_string(ndo, &oip->ip_dst), oip->ip_p, dport"%s protocol %d port %d unreachable", getname(ndo, (const u_char *)(&oip->ip_dst)), oip->ip_p, dport&mp->nexthopmtu"%s unreachable - need to frag (mtu %d)", ipaddr_string(ndo, &dp->icmp_ip.ip_dst), mtu"%s unreachable - need to frag (mtu %d)", getname(ndo, (const u_char *)(&dp->icmp_dun.id_ip.idi_ip.ip_dst)), mtu"%s unreachable - need to frag", ipaddr_string(ndo, &dp->icmp_ip.ip_dst)"%s unreachable - need to frag", getname(ndo, (const u_char *)(&dp->icmp_dun.id_ip.idi_ip.ip_dst))fmt, ipaddr_string(ndo, &dp->icmp_ip.ip_dst)fmt, getname(ndo, (const u_char *)(&dp->icmp_dun.id_ip.idi_ip.ip_dst))fmt, ipaddr_string(ndo, &dp->icmp_ip.ip_dst), ipaddr_string(ndo, &dp->icmp_gwaddr)fmt, getname(ndo, (const u_char *)(&dp->icmp_dun.id_ip.idi_ip.ip_dst)), getname(ndo, (const u_char *)(&dp->icmp_hun.ih_gwaddr))&dp->icmp_gwaddr&dp->icmp_hun.ih_gwaddr"router advertisement"*ihpsizeof(*ihp)" lifetime ", sizeof(buf) - (cp - buf)&ihp->ird_lifetimesizeof(buf) - (cp - buf)"%u", lifetime"%u:%02u", lifetime / 60, lifetime % 60"%u:%02u:%02u", lifetime / 3600, (lifetime % 3600) / 60, lifetime % 60" %d:", num" [size %d]", size*idpsizeof(*idp)" {%s %u}", ipaddr_string(ndo, &idp->ird_addr), EXTRACT_32BITS(&idp->ird_pref)" {%s %u}", getname(ndo, (const u_char *)(&idp->ird_addr)), ((uint32_t)(((uint32_t)(*((const uint8_t *)(&idp->ird_pref) + 0)) << 24) | ((uint32_t)(*((const uint8_t *)(&idp->ird_pref) + 1)) << 16) | ((uint32_t)(*((const uint8_t *)(&idp->ird_pref) + 2)) << 8) | ((uint32_t)(*((const uint8_t *)(&idp->ird_pref) + 3)) << 0)))&idp->ird_addr&idp->ird_pref"time exceeded-#%d", dp->icmp_code"parameter problem - code %d", dp->icmp_codedp->icmp_pptrdp->icmp_hun.ih_pptrsizeof(dp->icmp_hun.ih_pptr)"parameter problem - octet %d", dp->icmp_pptr"parameter problem - octet %d", dp->icmp_hun.ih_pptrdp->icmp_maskdp->icmp_dun.id_masksizeof(dp->icmp_dun.id_mask)"address mask is 0x%08x", EXTRACT_32BITS(&dp->icmp_mask)"address mask is 0x%08x", ((uint32_t)(((uint32_t)(*((const uint8_t *)(&dp->icmp_dun.id_mask) + 0)) << 24) | ((uint32_t)(*((const uint8_t *)(&dp->icmp_dun.id_mask) + 1)) << 16) | ((uint32_t)(*((const uint8_t *)(&dp->icmp_dun.id_mask) + 2)) << 8) | ((uint32_t)(*((const uint8_t *)(&dp->icmp_dun.id_mask) + 3)) << 0)))&dp->icmp_mask&dp->icmp_dun.id_mask"time stamp query id %u seq %u", EXTRACT_16BITS(&dp->icmp_id), EXTRACT_16BITS(&dp->icmp_seq)"time stamp query id %u seq %u", ((uint16_t)(((uint16_t)(*((const uint8_t *)(&dp->icmp_hun.ih_idseq.icd_id) + 0)) << 8) | ((uint16_t)(*((const uint8_t *)(&dp->icmp_hun.ih_idseq.icd_id) + 1)) << 0))), ((uint16_t)(((uint16_t)(*((const uint8_t *)(&dp->icmp_hun.ih_idseq.icd_seq) + 0)) << 8) | ((uint16_t)(*((const uint8_t *)(&dp->icmp_hun.ih_idseq.icd_seq) + 1)) << 0)))dp->icmp_ttimedp->icmp_dun.id_ts.its_ttimesizeof(dp->icmp_dun.id_ts.its_ttime)"time stamp reply id %u seq %u: org %s", EXTRACT_16BITS(&dp->icmp_id), EXTRACT_16BITS(&dp->icmp_seq), icmp_tstamp_print(EXTRACT_32BITS(&dp->icmp_otime))"time stamp reply id %u seq %u: org %s", ((uint16_t)(((uint16_t)(*((const uint8_t *)(&dp->icmp_hun.ih_idseq.icd_id) + 0)) << 8) | ((uint16_t)(*((const uint8_t *)(&dp->icmp_hun.ih_idseq.icd_id) + 1)) << 0))), ((uint16_t)(((uint16_t)(*((const uint8_t *)(&dp->icmp_hun.ih_idseq.icd_seq) + 0)) << 8) | ((uint16_t)(*((const uint8_t *)(&dp->icmp_hun.ih_idseq.icd_seq) + 1)) << 0))), icmp_tstamp_print(((uint32_t)(((uint32_t)(*((const uint8_t *)(&dp->icmp_dun.id_ts.its_otime) + 0)) << 24) | ((uint32_t)(*((const uint8_t *)(&dp->icmp_dun.id_ts.its_otime) + 1)) << 16) | ((uint32_t)(*((const uint8_t *)(&dp->icmp_dun.id_ts.its_otime) + 2)) << 8) | ((uint32_t)(*((const uint8_t *)(&dp->icmp_dun.id_ts.its_otime) + 3)) << 0))))&dp->icmp_otime&dp->icmp_dun.id_ts.its_otimebuf+strlen(buf)sizeof(buf)-strlen(buf)", recv %s", icmp_tstamp_print(EXTRACT_32BITS(&dp->icmp_rtime))", recv %s", icmp_tstamp_print(((uint32_t)(((uint32_t)(*((const uint8_t *)(&dp->icmp_dun.id_ts.its_rtime) + 0)) << 24) | ((uint32_t)(*((const uint8_t *)(&dp->icmp_dun.id_ts.its_rtime) + 1)) << 16) | ((uint32_t)(*((const uint8_t *)(&dp->icmp_dun.id_ts.its_rtime) + 2)) << 8) | ((uint32_t)(*((const uint8_t *)(&dp->icmp_dun.id_ts.its_rtime) + 3)) << 0))))&dp->icmp_rtime&dp->icmp_dun.id_ts.its_rtime", xmit %s", icmp_tstamp_print(EXTRACT_32BITS(&dp->icmp_ttime))", xmit %s", icmp_tstamp_print(((uint32_t)(((uint32_t)(*((const uint8_t *)(&dp->icmp_dun.id_ts.its_ttime) + 0)) << 24) | ((uint32_t)(*((const uint8_t *)(&dp->icmp_dun.id_ts.its_ttime) + 1)) << 16) | ((uint32_t)(*((const uint8_t *)(&dp->icmp_dun.id_ts.its_ttime) + 2)) << 8) | ((uint32_t)(*((const uint8_t *)(&dp->icmp_dun.id_ts.its_ttime) + 3)) << 0))))&dp->icmp_ttime&dp->icmp_dun.id_ts.its_ttimeICMP_ECHOICMP_ECHOREPLYecho %s, id %u, seq %ureplyICMP_UNREACHICMP_UNREACH_PROTOCOL%s protocol %d unreachableICMP_UNREACH_PORT%s tcp port %s unreachable%s udp port %s unreachable%s protocol %d port %d unreachableICMP_UNREACH_NEEDFRAGconst mtu_discoveryconst mtu_discovery *mtu_discovery *mp%s unreachable - need to frag (mtu %d)fragmented%s unreachable - need to frag#%d %%s unreachable"#%d %%s unreachable"ICMP_REDIRECTredirect-#%d %%s to net %%s"redirect-#%d %%s to net %%s"ICMP_ROUTERADVERTconst ih_rdiscoveryconst ih_rdiscovery *ih_rdiscovery *ihpconst id_rdiscoveryconst id_rdiscovery *id_rdiscovery *idplifetimerouter advertisement__builtin___strncpy_chk lifetime 360060 * 60%u:%02u%u:%02u:%02u %d: [size %d]const uint8_t[1]const uint8_t(*)[1] {%s %u}ICMP_TIMXCEEDICMP_TIMXCEED_INTRANStime exceeded in-transit"time exceeded in-transit"ICMP_TIMXCEED_REASSip reassembly time exceeded"ip reassembly time exceeded"time exceeded-#%dICMP_PARAMPROBparameter problem - code %dparameter problem - octet %dICMP_MASKREPLYaddress mask is 0x%08xICMP_TSTAMPtime stamp query id %u seq %uICMP_TSTAMPREPLYtime stamp reply id %u seq %u: org %s, recv %s, xmit %stype-#%d"type-#%d"(ndo, "ICMP %s, length %u", str, plen)ICMP %s, length %u&dp->icmp_cksum(ndo, " (wrong icmp cksum %x (->%x)!)", icmp_sum, in_cksum_shouldbe(icmp_sum, sum))icmp_sum (wrong icmp cksum %x (->%x)!)dp->icmp_type&ip->ip_len*ext_dpsizeof(*ext_dp)(ndo, "\n\tMPLS extension v%u", ICMP_MPLS_EXT_EXTRACT_VERSION(*(ext_dp->icmp_ext_version_res)))(ndo, "\n\tMPLS extension v%u", (((*(ext_dp->icmp_ext_version_res))&0xf0)>>4))*(ext_dp->icmp_ext_version_res)(ndo, " packet not supported")(ndo, ", checksum 0x%04x (%scorrect), length %u", EXTRACT_16BITS(ext_dp->icmp_ext_checksum), in_cksum(vec, 1) ? "in" : "", hlen)(ndo, ", checksum 0x%04x (%scorrect), length %u", ((uint16_t)(((uint16_t)(*((const uint8_t *)(ext_dp->icmp_ext_checksum) + 0)) << 8) | ((uint16_t)(*((const uint8_t *)(ext_dp->icmp_ext_checksum) + 1)) << 0))), in_cksum(vec, 1) ? "in" : "", hlen)ext_dp->icmp_ext_checksum*icmp_mpls_ext_object_headersizeof(*icmp_mpls_ext_object_header)icmp_mpls_ext_object_header->length(ndo, "\n\t  %s Object (%u), Class-Type: %u, length %u", tok2str(icmp_mpls_ext_obj_values,"unknown",obj_class_num), obj_class_num, obj_ctype, obj_tlen)*obj_tptr(ndo, "\n\t    label %u, exp %u", MPLS_LABEL(raw_label), MPLS_EXP(raw_label))(ndo, "\n\t    label %u, exp %u", (((raw_label) & 0xfffff000) >> 12), (((raw_label) & 0x00000e00) >> 9))(ndo, ", [S]")(ndo, ", ttl %u", MPLS_TTL(raw_label))(ndo, ", ttl %u", (((raw_label) & 0x000000ff) >> 0))ICMP_EXTD_MINLEN
	MPLS extension v%uICMP_MPLS_EXT_VERSION packet not supported, checksum 0x%04x (%scorrect), length %usizeof(struct icmp_mpls_ext_object_header_t)
	  %s Object (%u), Class-Type: %u, length %u
	    label %u, exp %u42949632003584, [S], ttl %u(ndo, "[|icmp]")[|icmp]icmp_tstamp_printmsec"%02u:%02u:%02u.%03u",hrs,min,sec,msec%02u:%02u:%02u.%03uicmp_mpls_ext_object_header_ticmp_ext_tid_rdiscoveryih_rdiscoverymtu_discoveryicmpid_ipid_tsih_idseqctypeclass_numicmp_ext_dataicmp_ext_checksumicmp_ext_version_resicmp_ext_legacy_headericmp_reserved2icmp_lengthicmp_reservedicmp_checksumicmp_codeicmp_typeird_prefird_addrird_lifetimeird_addrsizird_addrnumnexthopmtuicmp_dunicmp_hunicmp_cksumid_dataid_maskidi_ipits_ttimeits_rtimeits_otimeih_voidih_gwaddrih_pptricd_seqicd_idMPLS Stack Entry"MPLS Stack Entry"Extended Payload"Extended Payload"icmp_mpls_ext_obj_valuesICMP_REDIRECT_NETredirect %s to net %s"redirect %s to net %s"ICMP_REDIRECT_HOSTredirect %s to host %s"redirect %s to host %s"ICMP_REDIRECT_TOSNETredirect-tos %s to net %s"redirect-tos %s to net %s"ICMP_REDIRECT_TOSHOSTredirect-tos %s to host %s"redirect-tos %s to host %s"ICMP_UNREACH_NETnet %s unreachable"net %s unreachable"ICMP_UNREACH_HOSThost %s unreachable"host %s unreachable"ICMP_UNREACH_SRCFAIL%s unreachable - source route failed"%s unreachable - source route failed"ICMP_UNREACH_NET_UNKNOWNnet %s unreachable - unknown"net %s unreachable - unknown"ICMP_UNREACH_HOST_UNKNOWNhost %s unreachable - unknown"host %s unreachable - unknown"ICMP_UNREACH_ISOLATED%s unreachable - source host isolated"%s unreachable - source host isolated"ICMP_UNREACH_NET_PROHIBnet %s unreachable - admin prohibited"net %s unreachable - admin prohibited"ICMP_UNREACH_HOST_PROHIBhost %s unreachable - admin prohibited"host %s unreachable - admin prohibited"ICMP_UNREACH_TOSNETnet %s unreachable - tos prohibited"net %s unreachable - tos prohibited"ICMP_UNREACH_TOSHOSThost %s unreachable - tos prohibited"host %s unreachable - tos prohibited"ICMP_UNREACH_FILTER_PROHIBhost %s unreachable - admin prohibited filter"host %s unreachable - admin prohibited filter"ICMP_UNREACH_HOST_PRECEDENCEhost %s unreachable - host precedence violation"host %s unreachable - host precedence violation"ICMP_UNREACH_PRECEDENCE_CUTOFFhost %s unreachable - precedence cutoff"host %s unreachable - precedence cutoff"unreach2strecho reply"echo reply"ICMP_SOURCEQUENCHsource quench"source quench"echo request"echo request"ICMP_ROUTERSOLICITrouter solicitation"router solicitation"time stamp request"time stamp request"time stamp reply"time stamp reply"ICMP_IREQinformation request"information request"ICMP_IREQREPLYinformation reply"information reply"ICMP_MASKREQaddress mask request"address mask request"icmp2strICMP_MPLS_EXT_TYPE(type)((type) == ICMP_UNREACH || (type) == ICMP_TIMXCEED || (type) == ICMP_PARAMPROB)ICMP_INFOTYPE(type)((type) == ICMP_ECHOREPLY || (type) == ICMP_ECHO || (type) == ICMP_ROUTERADVERT || (type) == ICMP_ROUTERSOLICIT || (type) == ICMP_TSTAMP || (type) == ICMP_TSTAMPREPLY || (type) == ICMP_IREQ || (type) == ICMP_IREQREPLY || (type) == ICMP_MASKREQ || (type) == ICMP_MASKREPLY)ICMP_MAXTYPEICMP_PARAMPROB_OPTABSENTICMP_ADVLEN(p)(8 + (IP_HL(&(p)->icmp_ip) << 2) + 8)ICMP_ADVLENMIN(8 + sizeof (struct ip) + 8)ICMP_MASKLENICMP_TSLEN(8 + 3 * sizeof (uint32_t))(156 - sizeof (struct ip))ICMP_MINLENICMP_MPLS_EXT_EXTRACT_VERSION(x)(((x)&0xf0)>>4)icmp_dataicmp_dun.id_dataicmp_maskicmp_dun.id_maskicmp_ipicmp_dun.id_ip.idi_ipicmp_ttimeicmp_dun.id_ts.its_ttimeicmp_rtimeicmp_dun.id_ts.its_rtimeicmp_otimeicmp_dun.id_ts.its_otimeicmp_voidicmp_hun.ih_voidicmp_seqicmp_hun.ih_idseq.icd_seqicmp_idicmp_hun.ih_idseq.icd_idicmp_gwaddricmp_hun.ih_gwaddricmp_pptricmp_hun.ih_pptr/*
                *  FIXME those are the defined objects that lack a decoder
                *  you are welcome to contribute code ;-)
                *//* infinite loop protection *//* length field includes tlv header *//* subtract common header size *//*
             * Sanity checking of the header.
             *//*
             * Check first if the mpls extension header shows a non-zero length.
             * If the length field is not set then silently verify the checksum
             * to check if an extension header is present. This is expedient,
             * however not all implementations set the length field proper.
             *//*
         * Attempt to decode the MPLS extensions only for some ICMP types.
         *//*
         * print the remnants of the IP packet.
         * save the snaplength as this may get overidden in the IP printer.
         *//* don't attempt checksumming if this is a frag *//* print the milliseconds since midnight UTC *//* prototypes *//* extension header starts 128 bytes after ICMP header *//*
 * draft-bonica-internet-icmp-08
 *
 * The Destination Unreachable, Time Exceeded
 * and Parameter Problem messages are slighly changed as per
 * the above draft. A new Length field gets added to give
 * the caller an idea about the length of the piggypacked
 * IP packet before the MPLS extension header starts.
 *
 * The Length field represents length of the padded "original datagram"
 * field  measured in 32-bit words.
 *
 * 0                   1                   2                   3
 * 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
 * +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
 * |     Type      |     Code      |          Checksum             |
 * +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
 * |     unused    |    Length     |          unused               |
 * +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
 * |      Internet Header + leading octets of original datagram    |
 * |                                                               |
 * |                           //                                  |
 * |                                                               |
 * +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
 *//* rfc1256 *//* rfc1191 *//* Formats for the ICMP_REDIRECT codes *//* Formats for most of the ICMP_UNREACH codes *//* Most of the icmp types *//* precedence cutoff *//* host precedence violation *//* admin prohibited filter *//* rfc1716 *//* tos prohibited host *//* tos prohibited net *//* admin prohibited host *//* admin prohibited net *//* source host isolated *//* destination host unknown *//* destination net unknown *//* rfc1700 *//* address mask reply *//* address mask request *//* information reply *//* information request *//* timestamp reply *//* timestamp request *//* req. opt. absent *//* ip header bad *//* ttl==0 in reass *//* ttl==0 in transit *//* time exceeded, code: *//* router solicitation *//* router advertisement *//* echo service *//* for tos and host *//* for tos and net *//* for host *//* for network *//* shorter route, codes: *//* packet lost, slow down *//* bad tos for host *//* bad tos for net *//* ditto *//* prohibited access *//* src host isolated *//* unknown host *//* unknown net *//* src route failed *//* IP_DF caused drop *//* bad port *//* bad protocol *//* bad host *//* bad net *//* dest unreachable, codes: *//* echo reply *//*
 * Definition of type and code field values.
 *//* N.B.: must separately check that ip_hl >= 5 *//* min *//* address mask *//* timestamp *//* draft-bonica-internet-icmp-08 *//* abs minimum *//*
 * Lower bounds on packet lengths for various types.
 * For the error advice packets must first insure that the
 * packet is large enought to contain the returned ip header.
 * Only then can we do the check to see if 64 bits of packet
 * data have been returned, since we need to check the returned
 * ip header length.
 *//* options and then 64 bits of data *//* ICMP_REDIRECT *//* ICMP_PARAMPROB *//* ones complement cksum of struct *//* type sub code *//* type of message, see below *//*
 * Structure of an icmp header.
 *//*
 * Interface Control Message Protocol Definitions.
 * Per RFC 792, September 1981.
 *//*
 * Copyright (c) 1988, 1989, 1990, 1991, 1993, 1994, 1995, 1996
 *	The Regents of the University of California.  All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that: (1) source code distributions
 * retain the above copyright notice and this paragraph in its entirety, (2)
 * distributions including binary code include the above copyright notice and
 * this paragraph in its entirety in the documentation or other materials
 * provided with the distribution, and (3) all advertising materials mentioning
 * features or use of this software display the following acknowledgement:
 * ``This product includes software developed by the University of California,
 * Lawrence Berkeley Laboratory and its contributors.'' Neither the name of
 * the University nor the names of its contributors may be used to endorse
 * or promote products derived from this software without specific prior
 * written permission.
 * THIS SOFTWARE IS PROVIDED ``AS IS'' AND WITHOUT ANY EXPRESS OR IMPLIED
 * WARRANTIES, INCLUDING, WITHOUT LIMITATION, THE IMPLIED WARRANTIES OF
 * MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE.
 */tstamp/Users/owura/Repos/codeql_eval/proj_repos/the-tcpdump-group-tcpdump-commit-0f95d441e4b5d7512cc5c326c8668a120e048eda/tcpdump/print-igmp.cigmp_print(ndo, "igmp")igmp(ndo, "igmp query")(ndo, " v2")(ndo, " [max resp time %d]", bp[1])(ndo, " v1")bp[4]&bp[4](ndo, " [gaddr %s]", ipaddr_string(ndo, &bp[4]))(ndo, " [gaddr %s]", getname(ndo, (const u_char *)(&bp[4])))(ndo, " [len %d]", len)(ndo, "igmp v1 report %s", ipaddr_string(ndo, &bp[4]))(ndo, "igmp v1 report %s", getname(ndo, (const u_char *)(&bp[4])))(ndo, "igmp v2 report %s", ipaddr_string(ndo, &bp[4]))(ndo, "igmp v2 report %s", getname(ndo, (const u_char *)(&bp[4])))(ndo, "igmp v3 report")(ndo, "igmp leave %s", ipaddr_string(ndo, &bp[4]))(ndo, "igmp leave %s", getname(ndo, (const u_char *)(&bp[4])))(ndo, "igmp dvmrp")(ndo, "igmp pimv1")(ndo, "igmp-%d", bp[0])igmp query v2 [max resp time %d] v1 [gaddr %s] [len %d]igmp v1 report %sigmp v2 report %s0x22igmp v3 reportigmp leave %sigmp dvmrpigmp pimv10x1figmp-%d(ndo, " bad igmp cksum %x!", EXTRACT_16BITS(&bp[2]))(ndo, " bad igmp cksum %x!", ((uint16_t)(((uint16_t)(*((const uint8_t *)(&bp[2]) + 0)) << 8) | ((uint16_t)(*((const uint8_t *)(&bp[2]) + 1)) << 0))))&bp[2] bad igmp cksum %x!print_igmpv3_querymrcmrtnsrcs(ndo, " v3") v3(ndo, " [invalid len %d]", len) [invalid len %d](ndo, " [max resp time ")(ndo, "%.1fs", mrt * 0.1) [max resp time %.1fs(ndo, " [gaddr %s", ipaddr_string(ndo, &bp[4]))(ndo, " [gaddr %s", getname(ndo, (const u_char *)(&bp[4]))) [gaddr %sbp[10]&bp[10](ndo, " [invalid number of sources]")(ndo, " {")bp[12+(i<<2)](ndo, " %s", ipaddr_string(ndo, &bp[12+(i<<2)]))(ndo, " %s", getname(ndo, (const u_char *)(&bp[12+(i<<2)])))&bp[12+(i<<2)](ndo, " }")(ndo, ", %d source(s)", nsrcs) [invalid number of sources] { }, %d source(s)print_igmpv3_reportgroupngroupsbp[6](ndo, ", %d group record(s)", ngroups), %d group record(s)(ndo, " [invalid number of groups]")bp[group+4](ndo, " [gaddr %s", ipaddr_string(ndo, &bp[group+4]))(ndo, " [gaddr %s", getname(ndo, (const u_char *)(&bp[group+4])))&bp[group+4](ndo, " %s", tok2str(igmpv3report2str, " [v3-report-#%d]", bp[group]))&bp[group+2](ndo, " [invalid number of sources %d]", nsrcs)bp[group+8+(j<<2)](ndo, " %s", ipaddr_string(ndo, &bp[group+8+(j<<2)]))(ndo, " %s", getname(ndo, (const u_char *)(&bp[group+8+(j<<2)])))&bp[group+8+(j<<2)] [invalid number of groups] [v3-report-#%d] [invalid number of sources %d]print_mrespconst tr_queryconst tr_query *tr_query *tr*trsizeof(*tr)sizeof (struct tr_query)8 + sizeof (struct tr_query)(ndo, "mresp %lu: %s to %s reply-to %s", (u_long)TR_GETQID(EXTRACT_32BITS(&tr->tr_rttlqid)), ipaddr_string(ndo, &tr->tr_src), ipaddr_string(ndo, &tr->tr_dst), ipaddr_string(ndo, &tr->tr_raddr))(ndo, "mresp %lu: %s to %s reply-to %s", (u_long)((((uint32_t)(((uint32_t)(*((const uint8_t *)(&tr->tr_rttlqid) + 0)) << 24) | ((uint32_t)(*((const uint8_t *)(&tr->tr_rttlqid) + 1)) << 16) | ((uint32_t)(*((const uint8_t *)(&tr->tr_rttlqid) + 2)) << 8) | ((uint32_t)(*((const uint8_t *)(&tr->tr_rttlqid) + 3)) << 0)))) & 0x00ffffff), getname(ndo, (const u_char *)(&tr->tr_src)), getname(ndo, (const u_char *)(&tr->tr_dst)), getname(ndo, (const u_char *)(&tr->tr_raddr)))mresp %lu: %s to %s reply-to %s&tr->tr_rttlqidEXTRACT_32BITS(&tr->tr_rttlqid)((uint32_t)(((uint32_t)(*((const uint8_t *)(&tr->tr_rttlqid) + 0)) << 24) | ((uint32_t)(*((const uint8_t *)(&tr->tr_rttlqid) + 1)) << 16) | ((uint32_t)(*((const uint8_t *)(&tr->tr_rttlqid) + 2)) << 8) | ((uint32_t)(*((const uint8_t *)(&tr->tr_rttlqid) + 3)) << 0)))&tr->tr_src&tr->tr_dst&tr->tr_raddrEXTRACT_32BITS(&tr->tr_raddr)((uint32_t)(((uint32_t)(*((const uint8_t *)(&tr->tr_raddr) + 0)) << 24) | ((uint32_t)(*((const uint8_t *)(&tr->tr_raddr) + 1)) << 16) | ((uint32_t)(*((const uint8_t *)(&tr->tr_raddr) + 2)) << 8) | ((uint32_t)(*((const uint8_t *)(&tr->tr_raddr) + 3)) << 0)))(ndo, " with-ttl %d", TR_GETTTL(EXTRACT_32BITS(&tr->tr_rttlqid)))(ndo, " with-ttl %d", (int)(((((uint32_t)(((uint32_t)(*((const uint8_t *)(&tr->tr_rttlqid) + 0)) << 24) | ((uint32_t)(*((const uint8_t *)(&tr->tr_rttlqid) + 1)) << 16) | ((uint32_t)(*((const uint8_t *)(&tr->tr_rttlqid) + 2)) << 8) | ((uint32_t)(*((const uint8_t *)(&tr->tr_rttlqid) + 3)) << 0)))) >> 24) & 0xff))4026531840 with-ttl %dprint_mtrace(ndo, "mtrace %u: %s to %s reply-to %s", TR_GETQID(EXTRACT_32BITS(&tr->tr_rttlqid)), ipaddr_string(ndo, &tr->tr_src), ipaddr_string(ndo, &tr->tr_dst), ipaddr_string(ndo, &tr->tr_raddr))(ndo, "mtrace %u: %s to %s reply-to %s", ((((uint32_t)(((uint32_t)(*((const uint8_t *)(&tr->tr_rttlqid) + 0)) << 24) | ((uint32_t)(*((const uint8_t *)(&tr->tr_rttlqid) + 1)) << 16) | ((uint32_t)(*((const uint8_t *)(&tr->tr_rttlqid) + 2)) << 8) | ((uint32_t)(*((const uint8_t *)(&tr->tr_rttlqid) + 3)) << 0)))) & 0x00ffffff), getname(ndo, (const u_char *)(&tr->tr_src)), getname(ndo, (const u_char *)(&tr->tr_dst)), getname(ndo, (const u_char *)(&tr->tr_raddr)))mtrace %u: %s to %s reply-to %str_resptr_querytr_rflagstr_smasktr_fttltr_rprototr_pktcnttr_vifouttr_vifintr_rmtaddrtr_outaddrtr_inaddrtr_qarrtr_rttlqidtr_raddrtr_dsttr_srcis_in"is_in"is_ex"is_ex"to_in"to_in"to_ex"to_ex"allow"allow"block"block"igmpv3report2str[|igmp]"[|igmp]"TR_PROTO_CBTTR_PROTO_PIMTR_PROTO_MOSPFTR_PROTO_DVMRPTR_OLD_ROUTERTR_NO_SPACETR_NO_FWDTR_NO_RTETR_SCOPEDTR_OPRUNEDTR_PRUNEDTR_WRONG_IFTR_NO_ERRTR_RESPTR_QUERYTR_GETQID(x)((x) & 0x00ffffff)TR_GETTTL(x)(int)(((x) >> 24) & 0xff)IN_CLASSD/* Check the IGMP checksum *//* Minimum len is 12, and should be a multiple of 4 *//* Next group record *//* Print the sources *//* Check the number of sources and print them *//* Print the group records *//* Minimum len is 16, and should be a multiple of 4 *//* igmpv3 report types *//* fields for tr_rproto (routing protocol) *//* fields for tr_rflags (forwarding error codes) *//* defs within mtrace *//* forwarding error codes *//* subnet mask for src addr *//* ttl required to forward on outvif *//* routing proto deployed on router *//* total incoming packets for src-grp *//* output packet count on interface *//* input packet count on interface *//* parent address in source tree *//* outgoing interface address *//* incoming interface address *//* query arrival time *//*
 * Traceroute response format.  A traceroute response has a tr_query at the
 * beginning, followed by one tr_resp for each hop taken.
 *//* response ttl and qid *//* traceroute response address *//* traceroute destination *//* traceroute source *//*
 * The packet format for a traceroute request.
 *//* (following from ipmulti/mrouted/prune.h) *//*
 * Copyright (c) 1988, 1989, 1990, 1991, 1993, 1994, 1995, 1996
 *  The Regents of the University of California.  All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that: (1) source code distributions
 * retain the above copyright notice and this paragraph in its entirety, (2)
 * distributions including binary code include the above copyright notice and
 * this paragraph in its entirety in the documentation or other materials
 * provided with the distribution, and (3) all advertising materials mentioning
 * features or use of this software display the following acknowledgement:
 * ``This product includes software developed by the University of California,
 * Lawrence Berkeley Laboratory and its contributors.'' Neither the name of
 * the University nor the names of its contributors may be used to endorse
 * or promote products derived from this software without specific prior
 * written permission.
 * THIS SOFTWARE IS PROVIDED ``AS IS'' AND WITHOUT ANY EXPRESS OR IMPLIED
 * WARRANTIES, INCLUDING, WITHOUT LIMITATION, THE IMPLIED WARRANTIES OF
 * MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE.
 *//Users/owura/Repos/codeql_eval/proj_repos/the-tcpdump-group-tcpdump-commit-0f95d441e4b5d7512cc5c326c8668a120e048eda/tcpdump/print-igrp.cigrp_printigrphdr *nintnsys(ndo, "igrp:")igrp:*hdr&hdr->ig_ni&hdr->ig_ns&hdr->ig_nx(ndo, " %s V%d edit=%d AS=%d (%d/%d/%d)", tok2str(op2str, "op-#%d", IGRP_OP(hdr->ig_vop)), IGRP_V(hdr->ig_vop), hdr->ig_ed, EXTRACT_16BITS(&hdr->ig_as), nint, nsys, next)(ndo, " %s V%d edit=%d AS=%d (%d/%d/%d)", tok2str(op2str, "op-#%d", ((hdr->ig_vop) & 0x0f)), (((hdr->ig_vop) & 0xf0) >> 4), hdr->ig_ed, ((uint16_t)(((uint16_t)(*((const uint8_t *)(&hdr->ig_as) + 0)) << 8) | ((uint16_t)(*((const uint8_t *)(&hdr->ig_as) + 1)) << 0))), nint, nsys, next) %s V%d edit=%d AS=%d (%d/%d/%d)op-#%dhdr->ig_vop&hdr->ig_asIGRP_RTE_SIZE(ndo, " [extra bytes %d]", length)igrprte * [extra bytes %d](ndo, " [|igrp]") [|igrp]igrp_entry_print(ndo, " *.%d.%d.%d", igr->igr_net[0], igr->igr_net[1], igr->igr_net[2])(ndo, " X%d.%d.%d.0", igr->igr_net[0], igr->igr_net[1], igr->igr_net[2])(ndo, " %d.%d.%d.0", igr->igr_net[0], igr->igr_net[1], igr->igr_net[2]) *.%d.%d.%d X%d.%d.%d.0 %d.%d.%d.0igr->igr_dlyigr->igr_bw0xffffffigr->igr_mtu(ndo, " d=%d b=%d r=%d l=%d M=%d mtu=%d in %d hops", 10 * delay, bandwidth == 0 ? 0 : 10000000 / bandwidth, igr->igr_rel, igr->igr_ld, metric, mtu, igr->igr_hct) d=%d b=%d r=%d l=%d M=%d mtu=%d in %d hops10000000igrprteigrphdrigr_hctigr_ldigr_religr_mtuigris_interioris_exteriorigr_bwigr_dlyigr_netig_sumig_nxig_nsig_niig_asig_edig_vopIGRP_UPDATEupdate"update"IGRP_REQUESTop2strIGRP_OP(x)((x) & 0x0f)IGRP_V(x)(((x) & 0xf0) >> 4)/* Header *//* don't believe sizeof ! *//* hop count *//* percent of channel occupied *//* percent packets successfully tx/rx *//* MTU in octets *//* bandwidth in units of 1 kb/s *//* delay in tens of microseconds *//* 3 significant octets of IP address *//* IGRP routing entry *//* checksum of IGRP header & data *//* number of networks ouside AS *//* number of networks in AS *//* number of subnet in local net *//* autonomous system number *//* edition number *//* protocol version number / opcode *//* IGRP Header *//* Cisco IGRP definitions *//*
 * Copyright (c) 1996, 1997
 *	The Regents of the University of California.  All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that: (1) source code distributions
 * retain the above copyright notice and this paragraph in its entirety, (2)
 * distributions including binary code include the above copyright notice and
 * this paragraph in its entirety in the documentation or other materials
 * provided with the distribution, and (3) all advertising materials mentioning
 * features or use of this software display the following acknowledgement:
 * ``This product includes software developed by the University of California,
 * Lawrence Berkeley Laboratory and its contributors.'' Neither the name of
 * the University nor the names of its contributors may be used to endorse
 * or promote products derived from this software without specific prior
 * written permission.
 * THIS SOFTWARE IS PROVIDED ``AS IS'' AND WITHOUT ANY EXPRESS OR IMPLIED
 * WARRANTIES, INCLUDING, WITHOUT LIMITATION, THE IMPLIED WARRANTIES OF
 * MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE.
 *
 * Initial contribution from Francis Dupont (francis.dupont@inria.fr)
 *//Users/owura/Repos/codeql_eval/proj_repos/the-tcpdump-group-tcpdump-commit-0f95d441e4b5d7512cc5c326c8668a120e048eda/tcpdump/print-ip.cipN_print(ndo, "truncated-ip %d", length)truncated-ip %d&hdrbp, 4(ndo, "unknown ip %d", IP_V(&hdr))(ndo, "unknown ip %d", (((&hdr)->ip_vhl & 0xf0) >> 4))unknown ip %dip_printipdip_print_demux_state *ipdsipendip_sumipds->ip(ndo, "IP%u ", IP_V(ipds->ip))(ndo, "IP%u ", (((ipds->ip)->ip_vhl & 0xf0) >> 4))(ndo, ", wrong link-layer encapsulation")(ndo, "IP ")IP%u , wrong link-layer encapsulationIP const char[6](ndo, "truncated-ip %u", length)sizeof (struct ip)truncated-ip %u(ndo, "bad-hlen %u", hlen)bad-hlen %u&ipds->ip->ip_len(ndo, "truncated-ip - %u bytes missing! ", ipds->len - length)truncated-ip - %u bytes missing! (ndo, "bad-len %u", ipds->len)bad-len %u&ipds->ip->ip_off(ndo, "(tos 0x%x", (int)ipds->ip->ip_tos)(ndo, ",ECT(1)")(ndo, ",ECT(0)")(ndo, ",CE")(ndo, ", ttl %u", ipds->ip->ip_ttl)(ndo, ", id %u, offset %u, flags [%s], proto %s (%u)", EXTRACT_16BITS(&ipds->ip->ip_id), (ipds->off & 0x1fff) * 8, bittok2str(ip_frag_values, "none", ipds->off&0xe000), tok2str(ipproto_values,"unknown",ipds->ip->ip_p), ipds->ip->ip_p)(ndo, ", id %u, offset %u, flags [%s], proto %s (%u)", ((uint16_t)(((uint16_t)(*((const uint8_t *)(&ipds->ip->ip_id) + 0)) << 8) | ((uint16_t)(*((const uint8_t *)(&ipds->ip->ip_id) + 1)) << 0))), (ipds->off & 0x1fff) * 8, bittok2str(ip_frag_values, "none", ipds->off&0xe000), tok2str(ipproto_values,"unknown",ipds->ip->ip_p), ipds->ip->ip_p)&ipds->ip->ip_id(ndo, ", length %u", EXTRACT_16BITS(&ipds->ip->ip_len))(ndo, ", length %u", ((uint16_t)(((uint16_t)(*((const uint8_t *)(&ipds->ip->ip_len) + 0)) << 8) | ((uint16_t)(*((const uint8_t *)(&ipds->ip->ip_len) + 1)) << 0))))(ndo, ", options (")&ipds->ip->ip_sum(ndo, ", bad cksum %x (->%x)!", ip_sum, in_cksum_shouldbe(ip_sum, sum))(ndo, ")\n    ")(tos 0x%x,ECT(1),ECT(0),CE, id %u, offset %u, flags [%s], proto %s (%u)819157344sizeof(struct ip), options (, bad cksum %x (->%x)!)
    (ndo, "%s > %s: ", ipaddr_string(ndo, &ipds->ip->ip_src), ipaddr_string(ndo, &ipds->ip->ip_dst))(ndo, "%s > %s: ", getname(ndo, (const u_char *)(&ipds->ip->ip_src)), getname(ndo, (const u_char *)(&ipds->ip->ip_dst)))&ipds->ip->ip_src&ipds->ip->ip_dst(ndo, "%s > %s:", ipaddr_string(ndo, &ipds->ip->ip_src), ipaddr_string(ndo, &ipds->ip->ip_dst))(ndo, "%s > %s:", getname(ndo, (const u_char *)(&ipds->ip->ip_src)), getname(ndo, (const u_char *)(&ipds->ip->ip_dst)))(ndo, " %s", proto->p_name)(ndo, " ip-proto-%d", ipds->ip->ip_p)0x1fff%s > %s: %s > %s: ip-proto-%dip_print_innerip_print_demuxagain(ndo, " nd %d", ipds->len)(ndo, " (ipip-proto-4)")(ndo, "carp %s > %s: ", ipaddr_string(ndo, &ipds->ip->ip_src), ipaddr_string(ndo, &ipds->ip->ip_dst))(ndo, "carp %s > %s: ", getname(ndo, (const u_char *)(&ipds->ip->ip_src)), getname(ndo, (const u_char *)(&ipds->ip->ip_dst)))(ndo, "vrrp %s > %s: ", ipaddr_string(ndo, &ipds->ip->ip_src), ipaddr_string(ndo, &ipds->ip->ip_dst))(ndo, "vrrp %s > %s: ", getname(ndo, (const u_char *)(&ipds->ip->ip_src)), getname(ndo, (const u_char *)(&ipds->ip->ip_dst)))(ndo, " ip-proto-%d", ipds->nh)(ndo, " %d", ipds->len)enhIP_MFIP_OFFMASK(IP_MF|IP_OFFMASK) nd %d (ipip-proto-4)carp %s > %s: vrrp %s > %s: ip_optprint(ndo, "%s", sep)sizeof(*cp)(ndo, "%s", tok2str(ip_option_values,"unknown %u",option_code))cp[1]sizeof(cp[1])(ndo, " [bad length %u]", option_len)cp[3]sizeof(cp[3])&cp[2](ndo, " value %u", EXTRACT_16BITS(&cp[2]))(ndo, " value %u", ((uint16_t)(((uint16_t)(*((const uint8_t *)(&cp[2]) + 0)) << 8) | ((uint16_t)(*((const uint8_t *)(&cp[2]) + 1)) << 0))))option_code","unknown %uIPOPT_NOPIPOPT_EOL [bad length %u]IPOPT_TSIPOPT_RRIPOPT_SSRRIPOPT_LSRRIPOPT_RA value %uIPOPT_SECURITYip_printtshoplen(ndo, "[bad length %u]", length)[bad length %u](ndo, " TS{") TS{IPOPT_TS_TSONLY(ndo, "[bad ptr %u]", cp[2])[bad ptr %u](ndo, "TSONLY")(ndo, "TS+ADDR")(ndo, "PRESPEC2.0")(ndo, "PRESPEC")(ndo, "[bad ts type %d]", cp[3]&0xF)TSONLYIPOPT_TS_TSANDADDRTS+ADDRPRESPEC2.0PRESPEC[bad ts type %d]" "(ndo, "%s%d@%s", type, EXTRACT_32BITS(&cp[len+hoplen-4]), hoplen!=8 ? "" : ipaddr_string(ndo, &cp[len]))(ndo, "%s%d@%s", type, ((uint32_t)(((uint32_t)(*((const uint8_t *)(&cp[len+hoplen-4]) + 0)) << 24) | ((uint32_t)(*((const uint8_t *)(&cp[len+hoplen-4]) + 1)) << 16) | ((uint32_t)(*((const uint8_t *)(&cp[len+hoplen-4]) + 2)) << 8) | ((uint32_t)(*((const uint8_t *)(&cp[len+hoplen-4]) + 3)) << 0))), hoplen!=8 ? "" : getname(ndo, (const u_char *)(&cp[len])))&cp[len+hoplen-4]&cp[len] ^ " ^ "%s%d@%s(ndo, "%s", ptr == len ? " ^ " : "")(ndo, " [%d hops not recorded]} ", cp[3]>>4)(ndo, "}") [%d hops not recorded]} nextproto4_cksumphdrphcksum_vec[2](uint16_t)len&ph.src&ip->ip_src.s_addr&ph.dst&ip->ip_dst.s_addrphdr *sizeof(ph)covlennext_protoip_finddstretval&retvalcp + len - 4ttip_printroute(ndo, " [bad length %u]", length)(ndo, " [bad ptr %u]", cp[2]) [bad ptr %u](ndo, " %s", ipaddr_string(ndo, &cp[len]))(ndo, " %s", getname(ndo, (const u_char *)(&cp[len])))ip_print_demux_stateoff"+"IP_DFDF"DF"IP_RESrsvd"rsvd"ip_frag_valuesEOL"EOL"NOP"NOP"security"security"RR"RR"SSRR"SSRR"LSRR"LSRR"RA"RA"IPOPT_RFC1393traceroute"traceroute"ip_option_values[|ip]"[|ip]"GUESS_TSO/*
	     * if this isn't the first frag, we're missing the
	     * next level protocol header.  print the ip addr
	     * and the protocol.
	     *//* Ultra quiet now means that all this stuff should be suppressed *//*
	 * If this is fragment zero, hand it to the next higher
	 * level protocol.
	 *//*
	     * for the firewall guys, print id, offset.
             * On all but the last stick a "+" in the flags portion.
	     * For unfragmented datagrams, note the don't fragment flag.
	     *//* ECN bits *//*
	 * Cut off the snapshot length to the end of the IP payload.
	 *//* GUESS_TSO *//* we guess that it is a TSO send *//* print version if != 4 *//*
 * print an IP datagram.
 *//* do it *//* ip6-in-ip encapsulation *//* DVMRP multicast tunnel (ip-in-ip encapsulation) *//*
		 * XXX - the current IANA protocol number assignments
		 * page lists 9 as "any private interior gateway
		 * (used by Cisco for their IGRP)" and 88 as
		 * "EIGRP" from Cisco.
		 *
		 * Recent BSD <netinet/in.h> headers define
		 * IP_PROTO_PIGP as 9 and IP_PROTO_IGRP as 88.
		 * We define IP_PROTO_PIGP as 9 and
		 * IP_PROTO_EIGRP as 88; those names better
		 * match was the current protocol number
		 * assignments say.
		 *//* pass on the MF bit plus the offset to detect fragments *//* The RFC3514 evil ;-) bit *//* nothing to print - fall through *//*
 * print IP options.
 *//* IPOPT_TS_PRESPEC *//*
	 * prespecified should really be 3, but some ones might send 2
	 * instead, and the IPOPT_TS_PRESPEC constant can apparently
	 * have both values, so we have to hard-code it here.
	 *//* pseudo-header.. *//*
 * Compute a V4-style checksum by building a pseudoheader.
 *//*
 * If source-routing is present and valid, return the final destination.
 * Otherwise, return IP destination.
 *
 * This is used for UDP and TCP pseudo-header in the checksum
 * calculation.
 *//*
 * print the recorded route in an IP RR, LSRR or SSRR option.
 *//Users/owura/Repos/codeql_eval/proj_repos/the-tcpdump-group-tcpdump-commit-0f95d441e4b5d7512cc5c326c8668a120e048eda/tcpdump/print-ip6.cip6_print(ndo, "IP6, length: %u (printing not supported)", length)IP6, length: %u (printing not supported)/*
			 * XXX - we don't use "advance"; the current
			 * "Mobility Support in IPv6" draft
			 * (draft-ietf-mobileip-ipv6-24) says that
			 * the next header field in a mobility header
			 * should be IPPROTO_NONE, but speaks of
			 * the possiblity of a future extension in
			 * which payload can be piggybacked atop a
			 * mobility header.
			 *//* RFC 2460 *//* rfc1883 *//*
 * print an IP6 datagram.
 *//* pseudo-header *//*
 * Compute a V6-style checksum by building a pseudoheader.
 *//Users/owura/Repos/codeql_eval/proj_repos/the-tcpdump-group-tcpdump-commit-0f95d441e4b5d7512cc5c326c8668a120e048eda/tcpdump/print-ipcomp.cipcomp_printconst ipcompconst ipcomp *ipcomp *ipcompcpi&ipcomp->comp_cpi(ndo, "[|IPCOMP]")sizeof(struct ipcomp)[|IPCOMP](ndo, "IPComp(cpi=0x%04x)", cpi)IPComp(cpi=0x%04x)comp_cpicomp_flagscomp_nxtdefined(HAVE_LIBZ) && defined(HAVE_ZLIB_H)/*
	 * We may want to decompress the packet here.  Packet buffer
	 * management is a headache (if we decompress, packet will become
	 * larger).
	 *//* Compression parameter index *//*
 * Copyright (c) 1988, 1989, 1990, 1991, 1993, 1994
 *	The Regents of the University of California.  All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that: (1) source code distributions
 * retain the above copyright notice and this paragraph in its entirety, (2)
 * distributions including binary code include the above copyright notice and
 * this paragraph in its entirety in the documentation or other materials
 * provided with the distribution, and (3) all advertising materials mentioning
 * features or use of this software display the following acknowledgement:
 * ``This product includes software developed by the University of California,
 * Lawrence Berkeley Laboratory and its contributors.'' Neither the name of
 * the University nor the names of its contributors may be used to endorse
 * or promote products derived from this software without specific prior
 * written permission.
 * THIS SOFTWARE IS PROVIDED ``AS IS'' AND WITHOUT ANY EXPRESS OR IMPLIED
 * WARRANTIES, INCLUDING, WITHOUT LIMITATION, THE IMPLIED WARRANTIES OF
 * MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE.
 *//Users/owura/Repos/codeql_eval/proj_repos/the-tcpdump-group-tcpdump-commit-0f95d441e4b5d7512cc5c326c8668a120e048eda/tcpdump/print-ipfc.cipfc_if_printIPFC_HDRLEN(IPFC_HDRLEN)ipfc_printconst ipfc_headerconst ipfc_header *ipfc_header *ipfcp(ndo, "[|ipfc]")[|ipfc]ipfc_hdr_printextract_ipfc_addrsipfcdst(const char *)&ipfcp->ipfc_dhost[2], 6ipfcsrc(const char *)&ipfcp->ipfc_shost[2], 6ipfc_headeripfc_shostipfc_dhost/*
 * This is the top level routine of the printer.  'p' points
 * to the Network_Header of the packet, 'h->ts' is the timestamp,
 * 'h->len' is the length of the packet off the wire, and 'h->caplen'
 * is the number of bytes actually captured.
 *//*
		 * Some kinds of LLC packet we cannot
		 * handle intelligently
		 *//* Skip over Network_Header *//*
	 * Get the network addresses into a canonical form
	 *//*
	 * XXX - show the upper 16 bits?  Do so only if "vflag" is set?
	 *//*
 * Print the Network_Header
 *//*
	 * We assume that, as per RFC 2625, the lower 48 bits of the
	 * source and destination addresses are MAC addresses.
	 *//*
 * RFC 2625 IP-over-Fibre Channel.
 *//Users/owura/Repos/codeql_eval/proj_repos/the-tcpdump-group-tcpdump-commit-0f95d441e4b5d7512cc5c326c8668a120e048eda/tcpdump/print-ipnet.cipnet_if_printsizeof(ipnet_hdr_t)(sizeof(ipnet_hdr_t))ipnet_printipnet_hdr_t *ipnet_hdr *(ndo, "[|ipnet]")[|ipnet]IPH_AF_INETIPH_AF_INET6ipnet_hdr_printconst ipnet_hdr_tconst ipnet_hdr_t *(ndo, "%d > %d", hdr->iph_zsrc, hdr->iph_zdst)%d > %d(ndo,", family %s (%d)", tok2str(ipnet_values, "Unknown", hdr->iph_family), hdr->iph_family)(ndo,", %s", tok2str(ipnet_values, "Unknown Ethertype (0x%04x)", hdr->iph_family)), family %s (%d)ipnet_hdr_tipnet_hdriph_zdstiph_zsrciph_grifindexiph_ifindexiph_pktleniph_htypeiph_familyiph_versionipnet_valuesDLT_IPNET/* DLT_IPNET *//* Matches Solaris's AF_INET6 *//* Matches Solaris's AF_INET *//Users/owura/Repos/codeql_eval/proj_repos/the-tcpdump-group-tcpdump-commit-0f95d441e4b5d7512cc5c326c8668a120e048eda/tcpdump/print-ipx.cipx_rip_printipx[0]sizeof(ipx[0])(ndo, "ipx-rip-req")ipx[3]sizeof(ipx[3])(ndo, " %08x/%d.%d", EXTRACT_32BITS(&ipx[0]), EXTRACT_16BITS(&ipx[2]), EXTRACT_16BITS(&ipx[3]))(ndo, " %08x/%d.%d", ((uint32_t)(((uint32_t)(*((const uint8_t *)(&ipx[0]) + 0)) << 24) | ((uint32_t)(*((const uint8_t *)(&ipx[0]) + 1)) << 16) | ((uint32_t)(*((const uint8_t *)(&ipx[0]) + 2)) << 8) | ((uint32_t)(*((const uint8_t *)(&ipx[0]) + 3)) << 0))), ((uint16_t)(((uint16_t)(*((const uint8_t *)(&ipx[2]) + 0)) << 8) | ((uint16_t)(*((const uint8_t *)(&ipx[2]) + 1)) << 0))), ((uint16_t)(((uint16_t)(*((const uint8_t *)(&ipx[3]) + 0)) << 8) | ((uint16_t)(*((const uint8_t *)(&ipx[3]) + 1)) << 0))))&ipx[0]&ipx[2]&ipx[3](ndo, "ipx-rip-resp")(ndo, "ipx-rip-?%x", command)ipx-rip-req %08x/%d.%dipx-rip-respipx-rip-?%x(ndo, "[|ipx %d]", length)[|ipx %d]ipx_sap_print(ndo, "ipx-sap-req")(ndo, "ipx-sap-nearest-req")(ndo, " %s", ipxsap_string(htons(EXTRACT_16BITS(&ipx[0]))))(ndo, " %s", ipxsap_string(((__uint16_t)(__builtin_constant_p(((uint16_t)(((uint16_t)(*((const uint8_t *)(&ipx[0]) + 0)) << 8) | ((uint16_t)(*((const uint8_t *)(&ipx[0]) + 1)) << 0)))) ? ((__uint16_t)((((__uint16_t)(((uint16_t)(((uint16_t)(*((const uint8_t *)(&ipx[0]) + 0)) << 8) | ((uint16_t)(*((const uint8_t *)(&ipx[0]) + 1)) << 0)))) & 0xff00U) >> 8) | (((__uint16_t)(((uint16_t)(((uint16_t)(*((const uint8_t *)(&ipx[0]) + 0)) << 8) | ((uint16_t)(*((const uint8_t *)(&ipx[0]) + 1)) << 0)))) & 0x00ffU) << 8))) : _OSSwapInt16(((uint16_t)(((uint16_t)(*((const uint8_t *)(&ipx[0]) + 0)) << 8) | ((uint16_t)(*((const uint8_t *)(&ipx[0]) + 1)) << 0))))))))EXTRACT_16BITS(&ipx[0])((uint16_t)(((uint16_t)(*((const uint8_t *)(&ipx[0]) + 0)) << 8) | ((uint16_t)(*((const uint8_t *)(&ipx[0]) + 1)) << 0)))(ndo, "ipx-sap-resp")(ndo, "ipx-sap-nearest-resp")(ndo, " %s '", ipxsap_string(htons(EXTRACT_16BITS(&ipx[0]))))(ndo, " %s '", ipxsap_string(((__uint16_t)(__builtin_constant_p(((uint16_t)(((uint16_t)(*((const uint8_t *)(&ipx[0]) + 0)) << 8) | ((uint16_t)(*((const uint8_t *)(&ipx[0]) + 1)) << 0)))) ? ((__uint16_t)((((__uint16_t)(((uint16_t)(((uint16_t)(*((const uint8_t *)(&ipx[0]) + 0)) << 8) | ((uint16_t)(*((const uint8_t *)(&ipx[0]) + 1)) << 0)))) & 0xff00U) >> 8) | (((__uint16_t)(((uint16_t)(((uint16_t)(*((const uint8_t *)(&ipx[0]) + 0)) << 8) | ((uint16_t)(*((const uint8_t *)(&ipx[0]) + 1)) << 0)))) & 0x00ffU) << 8))) : _OSSwapInt16(((uint16_t)(((uint16_t)(*((const uint8_t *)(&ipx[0]) + 0)) << 8) | ((uint16_t)(*((const uint8_t *)(&ipx[0]) + 1)) << 0))))))))ipx[25](ndo, "' addr %s", ipxaddr_string(EXTRACT_32BITS(&ipx[25]), (u_char *)&ipx[27]))(ndo, "' addr %s", ipxaddr_string(((uint32_t)(((uint32_t)(*((const uint8_t *)(&ipx[25]) + 0)) << 24) | ((uint32_t)(*((const uint8_t *)(&ipx[25]) + 1)) << 16) | ((uint32_t)(*((const uint8_t *)(&ipx[25]) + 2)) << 8) | ((uint32_t)(*((const uint8_t *)(&ipx[25]) + 3)) << 0))), (u_char *)&ipx[27]))&ipx[25](ndo, "ipx-sap-?%x", command)ipx-sap-reqipx-sap-nearest-reqipx-sap-respipx-sap-nearest-resp %s '' addr %sipx-sap-?%xipx_decodeconst ipxHdrconst ipxHdr *ipxHdr *&ipx->dstSkt(ndo, "ipx-ncp %d", length)(ndo, "ipx-netbios %d", length)(ndo, "ipx-diags %d", length)(ndo, "ipx-nwlink-dgm %d", length)(ndo, "ipx-#%x %d", dstSkt, length)1105IPX_SKT_NCPdatapipx-ncp %d1106IPX_SKT_SAP1107IPX_SKT_RIP1109IPX_SKT_NETBIOSipx-netbios %d1110IPX_SKT_DIAGNOSTICSipx-diags %d1363IPX_SKT_NWLINK_DGMipx-nwlink-dgm %dIPX_SKT_EIGRPipx-#%x %dipxaddr_string"%08x.%02x:%02x:%02x:%02x:%02x:%02x", net, node[0], node[1], node[2], node[3], node[4], node[5]%08x.%02x:%02x:%02x:%02x:%02x:%02xipx_print(ndo, "IPX ")IPX ipx->srcSktsizeof(ipx->srcSkt)(ndo, "%s.%04x > ", ipxaddr_string(EXTRACT_32BITS(ipx->srcNet), ipx->srcNode), EXTRACT_16BITS(&ipx->srcSkt))(ndo, "%s.%04x > ", ipxaddr_string(((uint32_t)(((uint32_t)(*((const uint8_t *)(ipx->srcNet) + 0)) << 24) | ((uint32_t)(*((const uint8_t *)(ipx->srcNet) + 1)) << 16) | ((uint32_t)(*((const uint8_t *)(ipx->srcNet) + 2)) << 8) | ((uint32_t)(*((const uint8_t *)(ipx->srcNet) + 3)) << 0))), ipx->srcNode), ((uint16_t)(((uint16_t)(*((const uint8_t *)(&ipx->srcSkt) + 0)) << 8) | ((uint16_t)(*((const uint8_t *)(&ipx->srcSkt) + 1)) << 0))))%s.%04x > ipx->srcNet&ipx->srcSkt(ndo, "%s.%04x: ", ipxaddr_string(EXTRACT_32BITS(ipx->dstNet), ipx->dstNode), EXTRACT_16BITS(&ipx->dstSkt))(ndo, "%s.%04x: ", ipxaddr_string(((uint32_t)(((uint32_t)(*((const uint8_t *)(ipx->dstNet) + 0)) << 24) | ((uint32_t)(*((const uint8_t *)(ipx->dstNet) + 1)) << 16) | ((uint32_t)(*((const uint8_t *)(ipx->dstNet) + 2)) << 8) | ((uint32_t)(*((const uint8_t *)(ipx->dstNet) + 3)) << 0))), ipx->dstNode), ((uint16_t)(((uint16_t)(*((const uint8_t *)(&ipx->dstSkt) + 0)) << 8) | ((uint16_t)(*((const uint8_t *)(&ipx->dstSkt) + 1)) << 0))))%s.%04x: ipx->dstNetipx->lengthsizeof(ipx->length)&ipx->lengthipxSizeipxHdrpTypetCtl0x85be0x05530x04560x04550x04530x04520x0451TCPDUMP_DO_SMB/* take length from ipx header *//*
 * Print IPX datagram packets.
 *//* source socket *//* source node *//* source net *//* destination socket *//* destination node *//* destination net *//* Packet Type (i.e. level 2 protocol) *//* Transport Control (i.e. hop count) *//* Length, in bytes, including header *//* Checksum *//* IPX transport header *//* Cisco EIGRP over IPX *//* NWLink datagram, may contain SMB *//* well-known sockets *//*
 * Copyright (c) 1994, 1995, 1996
 *	The Regents of the University of California.  All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that: (1) source code distributions
 * retain the above copyright notice and this paragraph in its entirety, (2)
 * distributions including binary code include the above copyright notice and
 * this paragraph in its entirety in the documentation or other materials
 * provided with the distribution, and (3) all advertising materials mentioning
 * features or use of this software display the following acknowledgement:
 * ``This product includes software developed by the University of California,
 * Lawrence Berkeley Laboratory and its contributors.'' Neither the name of
 * the University nor the names of its contributors may be used to endorse
 * or promote products derived from this software without specific prior
 * written permission.
 * THIS SOFTWARE IS PROVIDED ``AS IS'' AND WITHOUT ANY EXPRESS OR IMPLIED
 * WARRANTIES, INCLUDING, WITHOUT LIMITATION, THE IMPLIED WARRANTIES OF
 * MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE.
 *
 * Format and print Novell IPX packets.
 * Contributed by Brad Parker (brad@fcr.com).
 *//Users/owura/Repos/codeql_eval/proj_repos/the-tcpdump-group-tcpdump-commit-0f95d441e4b5d7512cc5c326c8668a120e048eda/tcpdump/print-isakmp.cisakmp_rfc3948_print(ndo, "isakmp-nat-keep-alive")isakmp-nat-keep-alive(ndo, "NONESP-encap: ")NONESP-encap: (ndo, "UDP-encap: ")UDP-encap: (ndo,"[|isakmp]")[|isakmp]isakmp_printconst isakmpconst isakmp *isakmp *basemajorminor&basesizeof(base)(ndo,"isakmp")isakmpISAKMP_VERS_MAJORISAKMP_VERS_MAJOR_SHIFTISAKMP_VERS_MINORISAKMP_VERS_MINOR_SHIFT(ndo," %d.%d", major, minor) %d.%d(ndo," msgid ") msgid msgid_t *sizeof(base.msgid)(ndo," cookie ")(ndo,"->") cookie cookie_t *sizeof(base.i_ck)->sizeof(base.r_ck)(ndo,":")IKEv1_MAJOR_VERSIONIKEv2_MAJOR_VERSIONikev2_printphasebase->msgid(ndo, " parent_sa")(ndo, " child_sa ") parent_sa child_sa (ndo, " %s", ETYPESTR(base->etype))(ndo, " %s", (((base->etype) < sizeof(etypestr)/sizeof(etypestr[0]) && etypestr[(base->etype)]) ? etypestr[(base->etype)] : numstr(base->etype)))base->etypeetypestrconst char *[38]char *[38](ndo, "[%s%s%s]", base->flags & ISAKMP_FLAG_I ? "I" : "", base->flags & ISAKMP_FLAG_V ? "V" : "", base->flags & ISAKMP_FLAG_R ? "R" : "")(ndo, "[%s%s%s]", base->flags & (1 << 3) ? "I" : "", base->flags & (1 << 4) ? "V" : "", base->flags & (1 << 5) ? "R" : "")[%s%s%s]IV(ndo, " [encrypted %s]", NPSTR(base->np))(ndo, " [encrypted %s]", (((base->np) < sizeof(npstr)/sizeof(npstr[0]) && npstr[(base->np)]) ? npstr[(base->np)] : numstr(base->np)))base->npnpstrp + 1(ndo," [|%s]", NPSTR(base->np))(ndo," [|%s]", (((base->np) < sizeof(npstr)/sizeof(npstr[0]) && npstr[(base->np)]) ? npstr[(base->np)] : numstr(base->np)))const isakmp_genconst isakmp_gen *isakmp_gen *ISAKMP_FLAG_E [encrypted %s]const char *[49]char *[49]392 [|%s]base->len(ndo, " (len mismatch: isakmp %u/ip %u)", (uint32_t)ntohl(base->len), length)(ndo, " (len mismatch: isakmp %u/ip %u)", (uint32_t)(__builtin_constant_p(base->len) ? ((__uint32_t)((((__uint32_t)(base->len) & 0xff000000U) >> 24) | (((__uint32_t)(base->len) & 0x00ff0000U) >> 8) | (((__uint32_t)(base->len) & 0x0000ff00U) << 8) | (((__uint32_t)(base->len) & 0x000000ffU) << 24))) : _OSSwapInt32(base->len)), length) (len mismatch: isakmp %u/ip %u)ikev2_sub_printpcounte*extsizeof(*ext)&esizeof(e)ntohs(e.len)((__uint16_t)(__builtin_constant_p(e.len) ? ((__uint16_t)((((__uint16_t)(e.len) & 0xff00U) >> 8) | (((__uint16_t)(e.len) & 0x00ffU) << 8))) : _OSSwapInt16(e.len)))e.len(ndo,"\n")(ndo,"    ")(ndo,"(")(ndo,")")    (ndo," [|%s]", NPSTR(np))(ndo," [|%s]", (((np) < sizeof(npstr)/sizeof(npstr[0]) && npstr[(np)]) ? npstr[(np)] : numstr(np)))ikev2_sub0_printitem_len(ndo,"%s", NPSTR(np))(ndo,"%s", (((np) < sizeof(npstr)/sizeof(npstr[0]) && npstr[(np)]) ? npstr[(np)] : numstr(np)))ISAKMP_NPTYPE_PISAKMP_NPTYPE_TISAKMP_NPTYPE_v2E..(*[49])(..)doidepth(ndo," [|isakmp]") [|isakmp]ikev1_print(ndo," phase %d", phase)(ndo," phase %d/others", phase) phase %d phase %d/others(ndo," I")(ndo," ?")(ndo," R")sizeof(base->r_ck) I ? R(ndo," %s", ETYPESTR(base->etype))(ndo," %s", (((base->etype) < sizeof(etypestr)/sizeof(etypestr[0]) && etypestr[(base->etype)]) ? etypestr[(base->etype)] : numstr(base->etype)))(ndo,"[%s%s]", base->flags & ISAKMP_FLAG_E ? "E" : "", base->flags & ISAKMP_FLAG_C ? "C" : "")(ndo,"[%s%s]", base->flags & 0x01 ? "E" : "", base->flags & 0x02 ? "C" : "")[%s%s]C(ndo," [encrypted %s]", NPSTR(base->np))(ndo," [encrypted %s]", (((base->np) < sizeof(npstr)/sizeof(npstr[0]) && npstr[(base->np)]) ? npstr[(base->np)] : numstr(base->np)))(ndo," (len mismatch: isakmp %u/ip %u)", (uint32_t)ntohl(base->len), length)(ndo," (len mismatch: isakmp %u/ip %u)", (uint32_t)(__builtin_constant_p(base->len) ? ((__uint32_t)((((__uint32_t)(base->len) & 0xff000000U) >> 24) | (((__uint32_t)(base->len) & 0x00ff0000U) >> 8) | (((__uint32_t)(base->len) & 0x0000ff00U) << 8) | (((__uint32_t)(base->len) & 0x000000ffU) << 24))) : _OSSwapInt32(base->len)), length)numstr"#%d", x#%dikev1_sub_printike_sub0_printikev2_eap_printikev2_cp_printikev2_e_printvolatile inttpay(ndo," len=%d", dlen) len=%d(ndo," ")(ndo," [|%s]", NPSTR(tpay))(ndo," [|%s]", (((tpay) < sizeof(npstr)/sizeof(npstr[0]) && npstr[(tpay)]) ? npstr[(tpay)] : numstr(tpay)))ikev2_TS_printikev2_vid_printvid(ndo," len=%d vid=", ntohs(e.len) - 4)(ndo," len=%d vid=", ((__uint16_t)(__builtin_constant_p(e.len) ? ((__uint16_t)((((__uint16_t)(e.len) & 0xff00U) >> 8) | (((__uint16_t)(e.len) & 0x00ffU) << 8))) : _OSSwapInt16(e.len))) - 4) len=%d vid=*vidvid[i](ndo, "%c", vid[i])ikev2_d_printikev2_n_printikev2_n *showspishowdatashowsomedatanotify_namesizeof(*p)&nsizeof(n)ISAKMP_NPTYPE_N(ndo," prot_id=%s", PROTOIDSTR(n.prot_id))(ndo," prot_id=%s", (((n.prot_id) < sizeof(protoidstr)/sizeof(protoidstr[0]) && protoidstr[(n.prot_id)]) ? protoidstr[(n.prot_id)] : numstr(n.prot_id))) prot_id=%sn.prot_idprotoidstrn.typeIV2_NOTIFY_UNSUPPORTED_CRITICAL_PAYLOADunsupported_critical_payload"unsupported_critical_payload"IV2_NOTIFY_INVALID_IKE_SPIinvalid_ike_spi"invalid_ike_spi"IV2_NOTIFY_INVALID_MAJOR_VERSIONinvalid_major_version"invalid_major_version"IV2_NOTIFY_INVALID_SYNTAXinvalid_syntax"invalid_syntax"IV2_NOTIFY_INVALID_MESSAGE_IDinvalid_message_id"invalid_message_id"IV2_NOTIFY_INVALID_SPIinvalid_spi"invalid_spi"IV2_NOTIFY_NO_PROPOSAL_CHOSENno_protocol_chosen"no_protocol_chosen"IV2_NOTIFY_INVALID_KE_PAYLOADinvalid_ke_payload"invalid_ke_payload"IV2_NOTIFY_AUTHENTICATION_FAILEDauthentication_failed"authentication_failed"IV2_NOTIFY_SINGLE_PAIR_REQUIREDsingle_pair_required"single_pair_required"IV2_NOTIFY_NO_ADDITIONAL_SASno_additional_sas"no_additional_sas"IV2_NOTIFY_INTERNAL_ADDRESS_FAILUREinternal_address_failure"internal_address_failure"IV2_NOTIFY_FAILED_CP_REQUIREDfailed:cp_required"failed:cp_required"IV2_NOTIFY_INVALID_SELECTORSinvalid_selectors"invalid_selectors"IV2_NOTIFY_INITIAL_CONTACTinitial_contact"initial_contact"16385IV2_NOTIFY_SET_WINDOW_SIZEset_window_size"set_window_size"16386IV2_NOTIFY_ADDITIONAL_TS_POSSIBLEadditional_ts_possible"additional_ts_possible"16387IV2_NOTIFY_IPCOMP_SUPPORTEDipcomp_supported"ipcomp_supported"IV2_NOTIFY_NAT_DETECTION_SOURCE_IPnat_detection_source_ip"nat_detection_source_ip"16389IV2_NOTIFY_NAT_DETECTION_DESTINATION_IPnat_detection_destination_ip"nat_detection_destination_ip"16390IV2_NOTIFY_COOKIEcookie"cookie"16391IV2_NOTIFY_USE_TRANSPORT_MODEuse_transport_mode"use_transport_mode"16392IV2_NOTIFY_HTTP_CERT_LOOKUP_SUPPORTEDhttp_cert_lookup_supported"http_cert_lookup_supported"16393IV2_NOTIFY_REKEY_SArekey_sa"rekey_sa"16394IV2_NOTIFY_ESP_TFC_PADDING_NOT_SUPPORTEDtfc_padding_not_supported"tfc_padding_not_supported"16395IV2_NOTIFY_NON_FIRST_FRAGMENTS_ALSOnon_first_fragment_also"non_first_fragment_also""error"private-error"private-error""status"private-status"private-status"(ndo," type=%u(%s)", type, notify_name) type=%u(%s)(ndo," spi=") spi=(ndo," data=(") data=((ndo," [|%s]", NPSTR(ISAKMP_NPTYPE_N))(ndo," [|%s]", (((11) < sizeof(npstr)/sizeof(npstr[0]) && npstr[(11)]) ? npstr[(11)] : numstr(11)))ikev2_nonce_printnonce"nonce"(ndo," len=%d", ntohs(e.len) - 4)(ndo," len=%d", ((__uint16_t)(__builtin_constant_p(e.len) ? ((__uint16_t)((((__uint16_t)(e.len) & 0xff00U) >> 8) | (((__uint16_t)(e.len) & 0x00ffU) << 8))) : _OSSwapInt16(e.len))) - 4)(ndo," nonce=(")(ndo,") ") nonce=(ikev2_auth_printv2_authrsasig"rsasig"shared-secret"shared-secret"dsssig"dsssig"authdatasizeof(a)ikev2_auth *a.h.len(ndo," len=%d method=%s", len-4, STR_OR_ID(a.auth_method, v2_auth))(ndo," len=%d method=%s", len-4, (((a.auth_method) < sizeof(v2_auth)/sizeof(v2_auth[0]) && v2_auth[(a.auth_method)]) ? v2_auth[(a.auth_method)] : numstr(a.auth_method))) len=%d method=%sa.auth_method(ndo," authdata=(") authdata=(ikev2_cr_printikev2_cert_printikev2_ID_printid_lenidtype_lendumpasciidumphextypedata&idsizeof(id)ikev2_id *id.h.len(ndo," len=%d", id_len - 4)sizeof(struct ikev2_id)(ndo, " ipv4:")(ndo, " fqdn:")(ndo, " rfc822:")(ndo, " ipv6:")(ndo, " dn:")(ndo, " gn:")(ndo, " keyid:")ID_IPV4_ADDR ipv4:ID_FQDN fqdn:ID_RFC822_ADDR rfc822:ID_IPV6_ADDR ipv6:ID_DER_ASN1_DN dn:ID_DER_ASN1_GN gn:ID_KEY_ID keyid:*typedatatypedata[i](ndo, "%c", typedata[i])ikev2_ke_printkeikev2_ke *&kesizeof(ke)(ndo," len=%u group=%s", ntohs(ke.h.len) - 8, STR_OR_ID(ntohs(ke.ke_group), dh_p_map))(ndo," len=%u group=%s", ((__uint16_t)(__builtin_constant_p(ke.h.len) ? ((__uint16_t)((((__uint16_t)(ke.h.len) & 0xff00U) >> 8) | (((__uint16_t)(ke.h.len) & 0x00ffU) << 8))) : _OSSwapInt16(ke.h.len))) - 8, (((((__uint16_t)(__builtin_constant_p(ke.ke_group) ? ((__uint16_t)((((__uint16_t)(ke.ke_group) & 0xff00U) >> 8) | (((__uint16_t)(ke.ke_group) & 0x00ffU) << 8))) : _OSSwapInt16(ke.ke_group)))) < sizeof(dh_p_map)/sizeof(dh_p_map[0]) && dh_p_map[(((__uint16_t)(__builtin_constant_p(ke.ke_group) ? ((__uint16_t)((((__uint16_t)(ke.ke_group) & 0xff00U) >> 8) | (((__uint16_t)(ke.ke_group) & 0x00ffU) << 8))) : _OSSwapInt16(ke.ke_group))))]) ? dh_p_map[(((__uint16_t)(__builtin_constant_p(ke.ke_group) ? ((__uint16_t)((((__uint16_t)(ke.ke_group) & 0xff00U) >> 8) | (((__uint16_t)(ke.ke_group) & 0x00ffU) << 8))) : _OSSwapInt16(ke.ke_group))))] : numstr(((__uint16_t)(__builtin_constant_p(ke.ke_group) ? ((__uint16_t)((((__uint16_t)(ke.ke_group) & 0xff00U) >> 8) | (((__uint16_t)(ke.ke_group) & 0x00ffU) << 8))) : _OSSwapInt16(ke.ke_group)))))) len=%u group=%ske.h.lenke.ke_groupntohs(ke.ke_group)((__uint16_t)(__builtin_constant_p(ke.ke_group) ? ((__uint16_t)((((__uint16_t)(ke.ke_group) & 0xff00U) >> 8) | (((__uint16_t)(ke.ke_group) & 0x00ffU) << 8))) : _OSSwapInt16(ke.ke_group)))dh_p_mapconst char *[19]char *[19]ikev2_sa_printosa_lengthsa_length*ext1sizeof(*ext1)ext1"sa"(ndo," len=%d", sa_length)ikev2_p_printconst ikev2_pconst ikev2_p *ikev2_p *prop&propsizeof(prop)(ndo," #%u protoid=%s transform=%d len=%u", prop.p_no, PROTOIDSTR(prop.prot_id), prop.num_t, ntohs(prop.h.len))(ndo," #%u protoid=%s transform=%d len=%u", prop.p_no, (((prop.prot_id) < sizeof(protoidstr)/sizeof(protoidstr[0]) && protoidstr[(prop.prot_id)]) ? protoidstr[(prop.prot_id)] : numstr(prop.prot_id)), prop.num_t, ((__uint16_t)(__builtin_constant_p(prop.h.len) ? ((__uint16_t)((((__uint16_t)(prop.h.len) & 0xff00U) >> 8) | (((__uint16_t)(prop.h.len) & 0x00ffU) << 8))) : _OSSwapInt16(prop.h.len)))) #%u protoid=%s transform=%d len=%uprop.prot_idprop.h.len(ndo," [|%s]", NPSTR(ISAKMP_NPTYPE_P))(ndo," [|%s]", (((2) < sizeof(npstr)/sizeof(npstr[0]) && npstr[(2)]) ? npstr[(2)] : numstr(2)))ikev2_t_printconst ikev2_tconst ikev2_t *ikev2_t *t_ididstrconst attrmapconst attrmap *attrmap *mapnmapep2&tsizeof(t)t.t_idesp_p_mapprf_p_mapinteg_p_mapesn_p_mapIV2_T_ENCRconst char *[13]char *[13]const attrmap[15]attrmap[15]3840sizeof(encr_t_map)sizeof(encr_t_map[0])sizeof(encr_t_map)/sizeof(encr_t_map[0])IV2_T_PRFIV2_T_INTEGconst char *[6]char *[6]IV2_T_DHIV2_T_ESN(ndo," #%u type=%s id=%s ", pcount, STR_OR_ID(t.t_type, ikev2_t_type_map), idstr)(ndo," #%u type=%s id=%s ", pcount, (((t.t_type) < sizeof(ikev2_t_type_map)/sizeof(ikev2_t_type_map[0]) && ikev2_t_type_map[(t.t_type)]) ? ikev2_t_type_map[(t.t_type)] : numstr(t.t_type)), idstr)t.t_typeikev2_t_type_map(ndo," #%u type=%s id=%u ", pcount, STR_OR_ID(t.t_type, ikev2_t_type_map), t.t_id)(ndo," #%u type=%s id=%u ", pcount, (((t.t_type) < sizeof(ikev2_t_type_map)/sizeof(ikev2_t_type_map[0]) && ikev2_t_type_map[(t.t_type)]) ? ikev2_t_type_map[(t.t_type)] : numstr(t.t_type)), t.t_id)doi0proto0 #%u type=%s id=%s  #%u type=%s id=%u (ndo,"...")...(ndo," [|%s]", NPSTR(ISAKMP_NPTYPE_T))(ndo," [|%s]", (((3) < sizeof(npstr)/sizeof(npstr[0]) && npstr[(3)]) ? npstr[(3)] : numstr(3)))ikev2_gen_printikev2_pay_print(ndo,"%s%s:", payname, critical&0x80 ? "[C]" : "")%s%s:[C]ikev1_vid_print(ndo,"%s:", NPSTR(ISAKMP_NPTYPE_VID))(ndo,"%s:", (((13) < sizeof(npstr)/sizeof(npstr[0]) && npstr[(13)]) ? npstr[(13)] : numstr(13)))%s:ISAKMP_NPTYPE_VID(ndo," [|%s]", NPSTR(ISAKMP_NPTYPE_VID))(ndo," [|%s]", (((13) < sizeof(npstr)/sizeof(npstr[0]) && npstr[(13)]) ? npstr[(13)] : numstr(13)))paynamecriticalikev1_d_printconst ikev1_pl_dconst ikev1_pl_d *ikev1_pl_d *dq(ndo,"%s:", NPSTR(ISAKMP_NPTYPE_D))(ndo,"%s:", (((12) < sizeof(npstr)/sizeof(npstr[0]) && npstr[(12)]) ? npstr[(12)] : numstr(12)))ISAKMP_NPTYPE_D&dsizeof(d)d.doi(ndo," doi=%u", doi)(ndo," proto=%u", proto)(ndo," doi=ipsec")(ndo," proto=%s", PROTOIDSTR(proto))(ndo," proto=%s", (((proto) < sizeof(protoidstr)/sizeof(protoidstr[0]) && protoidstr[(proto)]) ? protoidstr[(proto)] : numstr(proto))) doi=%u proto=%u doi=ipsec proto=%s(ndo," spilen=%u", d.spi_size) spilen=%u(ndo," nspi=%u", ntohs(d.num_spi))(ndo," nspi=%u", ((__uint16_t)(__builtin_constant_p(d.num_spi) ? ((__uint16_t)((((__uint16_t)(d.num_spi) & 0xff00U) >> 8) | (((__uint16_t)(d.num_spi) & 0x00ffU) << 8))) : _OSSwapInt16(d.num_spi)))) nspi=%ud.num_spi(ndo,",")(ndo," [|%s]", NPSTR(ISAKMP_NPTYPE_D))(ndo," [|%s]", (((12) < sizeof(npstr)/sizeof(npstr[0]) && npstr[(12)]) ? npstr[(12)] : numstr(12)))ikev1_n_printikev1_pl_n *notify_error_stripsec_notify_error_strnotify_status_stripsec_notify_status_str(ndo,"%s:", NPSTR(ISAKMP_NPTYPE_N))(ndo,"%s:", (((11) < sizeof(npstr)/sizeof(npstr[0]) && npstr[(11)]) ? npstr[(11)] : numstr(11)))n.doi(ndo," doi=%d", doi)(ndo," proto=%d", proto)(ndo," type=%s", NOTIFY_ERROR_STR(ntohs(n.type)))(ndo," type=%s", ((((((__uint16_t)(__builtin_constant_p(n.type) ? ((__uint16_t)((((__uint16_t)(n.type) & 0xff00U) >> 8) | (((__uint16_t)(n.type) & 0x00ffU) << 8))) : _OSSwapInt16(n.type))))) < sizeof(notify_error_str)/sizeof(notify_error_str[0]) && notify_error_str[((((__uint16_t)(__builtin_constant_p(n.type) ? ((__uint16_t)((((__uint16_t)(n.type) & 0xff00U) >> 8) | (((__uint16_t)(n.type) & 0x00ffU) << 8))) : _OSSwapInt16(n.type)))))]) ? notify_error_str[((((__uint16_t)(__builtin_constant_p(n.type) ? ((__uint16_t)((((__uint16_t)(n.type) & 0xff00U) >> 8) | (((__uint16_t)(n.type) & 0x00ffU) << 8))) : _OSSwapInt16(n.type)))))] : numstr((((__uint16_t)(__builtin_constant_p(n.type) ? ((__uint16_t)((((__uint16_t)(n.type) & 0xff00U) >> 8) | (((__uint16_t)(n.type) & 0x00ffU) << 8))) : _OSSwapInt16(n.type)))))))ntohs(n.type)((__uint16_t)(__builtin_constant_p(n.type) ? ((__uint16_t)((((__uint16_t)(n.type) & 0xff00U) >> 8) | (((__uint16_t)(n.type) & 0x00ffU) << 8))) : _OSSwapInt16(n.type)))(((__uint16_t)(__builtin_constant_p(n.type) ? ((__uint16_t)((((__uint16_t)(n.type) & 0xff00U) >> 8) | (((__uint16_t)(n.type) & 0x00ffU) << 8))) : _OSSwapInt16(n.type))))(ndo," type=%s", numstr(ntohs(n.type)))(ndo," type=%s", numstr(((__uint16_t)(__builtin_constant_p(n.type) ? ((__uint16_t)((((__uint16_t)(n.type) & 0xff00U) >> 8) | (((__uint16_t)(n.type) & 0x00ffU) << 8))) : _OSSwapInt16(n.type)))))(ndo," type=%s", NOTIFY_STATUS_STR(ntohs(n.type)))(ndo," type=%s", ((((u_int)((((__uint16_t)(__builtin_constant_p(n.type) ? ((__uint16_t)((((__uint16_t)(n.type) & 0xff00U) >> 8) | (((__uint16_t)(n.type) & 0x00ffU) << 8))) : _OSSwapInt16(n.type)))) - 16384)) < sizeof(notify_status_str)/sizeof(notify_status_str[0]) && notify_status_str[((u_int)((((__uint16_t)(__builtin_constant_p(n.type) ? ((__uint16_t)((((__uint16_t)(n.type) & 0xff00U) >> 8) | (((__uint16_t)(n.type) & 0x00ffU) << 8))) : _OSSwapInt16(n.type)))) - 16384))]) ? notify_status_str[((u_int)((((__uint16_t)(__builtin_constant_p(n.type) ? ((__uint16_t)((((__uint16_t)(n.type) & 0xff00U) >> 8) | (((__uint16_t)(n.type) & 0x00ffU) << 8))) : _OSSwapInt16(n.type)))) - 16384))] : numstr((u_int)((((__uint16_t)(__builtin_constant_p(n.type) ? ((__uint16_t)((((__uint16_t)(n.type) & 0xff00U) >> 8) | (((__uint16_t)(n.type) & 0x00ffU) << 8))) : _OSSwapInt16(n.type)))) - 16384))))(u_int)((((__uint16_t)(__builtin_constant_p(n.type) ? ((__uint16_t)((((__uint16_t)(n.type) & 0xff00U) >> 8) | (((__uint16_t)(n.type) & 0x00ffU) << 8))) : _OSSwapInt16(n.type)))) - 16384) doi=%d proto=%d type=%sconst char *[31]char *[31]24576const char *[1]char *[1](ndo," type=%s", IPSEC_NOTIFY_ERROR_STR(ntohs(n.type)))(ndo," type=%s", ((((u_int)((((__uint16_t)(__builtin_constant_p(n.type) ? ((__uint16_t)((((__uint16_t)(n.type) & 0xff00U) >> 8) | (((__uint16_t)(n.type) & 0x00ffU) << 8))) : _OSSwapInt16(n.type)))) - 8192)) < sizeof(ipsec_notify_error_str)/sizeof(ipsec_notify_error_str[0]) && ipsec_notify_error_str[((u_int)((((__uint16_t)(__builtin_constant_p(n.type) ? ((__uint16_t)((((__uint16_t)(n.type) & 0xff00U) >> 8) | (((__uint16_t)(n.type) & 0x00ffU) << 8))) : _OSSwapInt16(n.type)))) - 8192))]) ? ipsec_notify_error_str[((u_int)((((__uint16_t)(__builtin_constant_p(n.type) ? ((__uint16_t)((((__uint16_t)(n.type) & 0xff00U) >> 8) | (((__uint16_t)(n.type) & 0x00ffU) << 8))) : _OSSwapInt16(n.type)))) - 8192))] : numstr((u_int)((((__uint16_t)(__builtin_constant_p(n.type) ? ((__uint16_t)((((__uint16_t)(n.type) & 0xff00U) >> 8) | (((__uint16_t)(n.type) & 0x00ffU) << 8))) : _OSSwapInt16(n.type)))) - 8192))))(u_int)((((__uint16_t)(__builtin_constant_p(n.type) ? ((__uint16_t)((((__uint16_t)(n.type) & 0xff00U) >> 8) | (((__uint16_t)(n.type) & 0x00ffU) << 8))) : _OSSwapInt16(n.type)))) - 8192)(ndo," type=%s", IPSEC_NOTIFY_STATUS_STR(ntohs(n.type)))(ndo," type=%s", ((((u_int)((((__uint16_t)(__builtin_constant_p(n.type) ? ((__uint16_t)((((__uint16_t)(n.type) & 0xff00U) >> 8) | (((__uint16_t)(n.type) & 0x00ffU) << 8))) : _OSSwapInt16(n.type)))) - 24576)) < sizeof(ipsec_notify_status_str)/sizeof(ipsec_notify_status_str[0]) && ipsec_notify_status_str[((u_int)((((__uint16_t)(__builtin_constant_p(n.type) ? ((__uint16_t)((((__uint16_t)(n.type) & 0xff00U) >> 8) | (((__uint16_t)(n.type) & 0x00ffU) << 8))) : _OSSwapInt16(n.type)))) - 24576))]) ? ipsec_notify_status_str[((u_int)((((__uint16_t)(__builtin_constant_p(n.type) ? ((__uint16_t)((((__uint16_t)(n.type) & 0xff00U) >> 8) | (((__uint16_t)(n.type) & 0x00ffU) << 8))) : _OSSwapInt16(n.type)))) - 24576))] : numstr((u_int)((((__uint16_t)(__builtin_constant_p(n.type) ? ((__uint16_t)((((__uint16_t)(n.type) & 0xff00U) >> 8) | (((__uint16_t)(n.type) & 0x00ffU) << 8))) : _OSSwapInt16(n.type)))) - 24576))))(u_int)((((__uint16_t)(__builtin_constant_p(n.type) ? ((__uint16_t)((((__uint16_t)(n.type) & 0xff00U) >> 8) | (((__uint16_t)(n.type) & 0x00ffU) << 8))) : _OSSwapInt16(n.type)))) - 24576)(ndo," orig=(")(ndo,"replay detection %sabled", EXTRACT_32BITS(cp) ? "en" : "dis")(ndo,"replay detection %sabled", ((uint32_t)(((uint32_t)(*((const uint8_t *)(cp) + 0)) << 24) | ((uint32_t)(*((const uint8_t *)(cp) + 1)) << 16) | ((uint32_t)(*((const uint8_t *)(cp) + 2)) << 8) | ((uint32_t)(*((const uint8_t *)(cp) + 3)) << 0))) ? "en" : "dis") orig=(IPSECDOI_NTYPE_RESPONDER_LIFETIMEconst attrmap[17]attrmap[17]4352sizeof(oakley_t_map)sizeof(oakley_t_map[0])sizeof(oakley_t_map)/sizeof(oakley_t_map[0])IPSECDOI_NTYPE_REPLAY_STATUSreplay detection %sabledendisISAKMP_NTYPE_NO_PROPOSAL_CHOSENISAKMP_NPTYPE_SARESPONDER-LIFETIME"RESPONDER-LIFETIME"REPLAY-STATUS"REPLAY-STATUS"INITIAL-CONTACT"INITIAL-CONTACT"CONNECTED"CONNECTED"RESERVED"RESERVED"INVALID-PAYLOAD-TYPE"INVALID-PAYLOAD-TYPE"DOI-NOT-SUPPORTED"DOI-NOT-SUPPORTED"SITUATION-NOT-SUPPORTED"SITUATION-NOT-SUPPORTED"INVALID-COOKIE"INVALID-COOKIE"INVALID-MAJOR-VERSION"INVALID-MAJOR-VERSION"INVALID-MINOR-VERSION"INVALID-MINOR-VERSION"INVALID-EXCHANGE-TYPE"INVALID-EXCHANGE-TYPE"INVALID-FLAGS"INVALID-FLAGS"INVALID-MESSAGE-ID"INVALID-MESSAGE-ID"INVALID-PROTOCOL-ID"INVALID-PROTOCOL-ID"INVALID-SPI"INVALID-SPI"INVALID-TRANSFORM-ID"INVALID-TRANSFORM-ID"ATTRIBUTES-NOT-SUPPORTED"ATTRIBUTES-NOT-SUPPORTED"NO-PROPOSAL-CHOSEN"NO-PROPOSAL-CHOSEN"BAD-PROPOSAL-SYNTAX"BAD-PROPOSAL-SYNTAX"PAYLOAD-MALFORMED"PAYLOAD-MALFORMED"INVALID-KEY-INFORMATION"INVALID-KEY-INFORMATION"INVALID-ID-INFORMATION"INVALID-ID-INFORMATION"INVALID-CERT-ENCODING"INVALID-CERT-ENCODING"INVALID-CERTIFICATE"INVALID-CERTIFICATE"CERT-TYPE-UNSUPPORTED"CERT-TYPE-UNSUPPORTED"INVALID-CERT-AUTHORITY"INVALID-CERT-AUTHORITY"INVALID-HASH-INFORMATION"INVALID-HASH-INFORMATION"AUTHENTICATION-FAILED"AUTHENTICATION-FAILED"INVALID-SIGNATURE"INVALID-SIGNATURE"ADDRESS-NOTIFICATION"ADDRESS-NOTIFICATION"NOTIFY-SA-LIFETIME"NOTIFY-SA-LIFETIME"CERTIFICATE-UNAVAILABLE"CERTIFICATE-UNAVAILABLE"UNSUPPORTED-EXCHANGE-TYPE"UNSUPPORTED-EXCHANGE-TYPE"UNEQUAL-PAYLOAD-LENGTHS"UNEQUAL-PAYLOAD-LENGTHS"ikev1_nonce_print(ndo,"%s:", NPSTR(ISAKMP_NPTYPE_NONCE))(ndo,"%s:", (((10) < sizeof(npstr)/sizeof(npstr[0]) && npstr[(10)]) ? npstr[(10)] : numstr(10)))ISAKMP_NPTYPE_NONCE(ndo," n len=%d", ntohs(e.len) - 4)(ndo," n len=%d", ((__uint16_t)(__builtin_constant_p(e.len) ? ((__uint16_t)((((__uint16_t)(e.len) & 0xff00U) >> 8) | (((__uint16_t)(e.len) & 0x00ffU) << 8))) : _OSSwapInt16(e.len))) - 4) n len=%d(ndo," [|%s]", NPSTR(ISAKMP_NPTYPE_NONCE))(ndo," [|%s]", (((10) < sizeof(npstr)/sizeof(npstr[0]) && npstr[(10)]) ? npstr[(10)] : numstr(10)))ikev1_sig_print(ndo,"%s:", NPSTR(ISAKMP_NPTYPE_SIG))(ndo,"%s:", (((9) < sizeof(npstr)/sizeof(npstr[0]) && npstr[(9)]) ? npstr[(9)] : numstr(9)))ISAKMP_NPTYPE_SIG(ndo," [|%s]", NPSTR(ISAKMP_NPTYPE_SIG))(ndo," [|%s]", (((9) < sizeof(npstr)/sizeof(npstr[0]) && npstr[(9)]) ? npstr[(9)] : numstr(9)))ikev1_hash_print(ndo,"%s:", NPSTR(ISAKMP_NPTYPE_HASH))(ndo,"%s:", (((8) < sizeof(npstr)/sizeof(npstr[0]) && npstr[(8)]) ? npstr[(8)] : numstr(8)))ISAKMP_NPTYPE_HASH(ndo," [|%s]", NPSTR(ISAKMP_NPTYPE_HASH))(ndo," [|%s]", (((8) < sizeof(npstr)/sizeof(npstr[0]) && npstr[(8)]) ? npstr[(8)] : numstr(8)))ikev1_cr_printconst ikev1_pl_certconst ikev1_pl_cert *ikev1_pl_cert *certcertstr(ndo,"%s:", NPSTR(ISAKMP_NPTYPE_CR))(ndo,"%s:", (((7) < sizeof(npstr)/sizeof(npstr[0]) && npstr[(7)]) ? npstr[(7)] : numstr(7)))ISAKMP_NPTYPE_CR&certsizeof(cert)(ndo," len=%d", item_len - 4)(ndo," type=%s", STR_OR_ID((cert.encode), certstr))(ndo," type=%s", ((((cert.encode)) < sizeof(certstr)/sizeof(certstr[0]) && certstr[((cert.encode))]) ? certstr[((cert.encode))] : numstr((cert.encode))))(cert.encode)const char *[11]char *[11](ndo," [|%s]", NPSTR(ISAKMP_NPTYPE_CR))(ndo," [|%s]", (((7) < sizeof(npstr)/sizeof(npstr[0]) && npstr[(7)]) ? npstr[(7)] : numstr(7)))"none"pkcs7"pkcs7"pgp"pgp"dns"dns"x509sign"x509sign"x509ke"x509ke"kerberos"kerberos"crl"crl"arl"arl"spki"spki"x509attr"x509attr"ikev1_cert_print(ndo,"%s:", NPSTR(ISAKMP_NPTYPE_CERT))(ndo,"%s:", (((6) < sizeof(npstr)/sizeof(npstr[0]) && npstr[(6)]) ? npstr[(6)] : numstr(6)))ISAKMP_NPTYPE_CERT(ndo," [|%s]", NPSTR(ISAKMP_NPTYPE_CERT))(ndo," [|%s]", (((6) < sizeof(npstr)/sizeof(npstr[0]) && npstr[(6)]) ? npstr[(6)] : numstr(6)))ikev1_id_printconst ikev1_pl_idconst ikev1_pl_id *ikev1_pl_id *idtypestripsecidtypestr(ndo,"%s:", NPSTR(ISAKMP_NPTYPE_ID))(ndo,"%s:", (((5) < sizeof(npstr)/sizeof(npstr[0]) && npstr[(5)]) ? npstr[(5)] : numstr(5)))ISAKMP_NPTYPE_ID(ndo," idtype=%s", STR_OR_ID(id.d.id_type, idtypestr))(ndo," idtype=%s", (((id.d.id_type) < sizeof(idtypestr)/sizeof(idtypestr[0]) && idtypestr[(id.d.id_type)]) ? idtypestr[(id.d.id_type)] : numstr(id.d.id_type)))id.d.id_type(ndo," doi_data=%u", (uint32_t)(ntohl(id.d.doi_data) & 0xffffff))(ndo," doi_data=%u", (uint32_t)((__builtin_constant_p(id.d.doi_data) ? ((__uint32_t)((((__uint32_t)(id.d.doi_data) & 0xff000000U) >> 24) | (((__uint32_t)(id.d.doi_data) & 0x00ff0000U) >> 8) | (((__uint32_t)(id.d.doi_data) & 0x0000ff00U) << 8) | (((__uint32_t)(id.d.doi_data) & 0x000000ffU) << 24))) : _OSSwapInt32(id.d.doi_data)) & 0xffffff))id.d.doi_data(ndo," idtype=%s", STR_OR_ID(id.type, ipsecidtypestr))(ndo," idtype=%s", (((id.type) < sizeof(ipsecidtypestr)/sizeof(ipsecidtypestr[0]) && ipsecidtypestr[(id.type)]) ? ipsecidtypestr[(id.type)] : numstr(id.type)))id.type(ndo," protoid=%s", pe->p_name)(ndo," protoid=%u", id.proto_id)(ndo," port=%d", ntohs(id.port))(ndo," port=%d", ((__uint16_t)(__builtin_constant_p(id.port) ? ((__uint16_t)((((__uint16_t)(id.port) & 0xff00U) >> 8) | (((__uint16_t)(id.port) & 0x00ffU) << 8))) : _OSSwapInt16(id.port))))id.port*data(ndo," len=%d [bad: < 4]", len)(ndo," len=%d %s", len, ipaddr_string(ndo, data))(ndo," len=%d %s", len, getname(ndo, (const u_char *)(data)))(ndo," len=%d ", len)(ndo," len=%d [bad: < 8]", len)(ndo," len=%d %s/%u.%u.%u.%u", len, ipaddr_string(ndo, data), mask[0], mask[1], mask[2], mask[3])(ndo," len=%d %s/%u.%u.%u.%u", len, getname(ndo, (const u_char *)(data)), mask[0], mask[1], mask[2], mask[3])(ndo," len=%d %s-%s", len, ipaddr_string(ndo, data), ipaddr_string(ndo, data + sizeof(struct in_addr)))(ndo," len=%d %s-%s", len, getname(ndo, (const u_char *)(data)), getname(ndo, (const u_char *)(data + sizeof(struct in_addr))))data + sizeof(struct in_addr) idtype=%s doi_data=%uconst ipsecdoi_idconst ipsecdoi_id *ipsecdoi_id *pe protoid=%s protoid=%u port=%dIPSECDOI_ID_IPV4_ADDR len=%d [bad: < 4] len=%d %sIPSECDOI_ID_FQDNIPSECDOI_ID_USER_FQDN len=%d IPSECDOI_ID_IPV4_ADDR_SUBNET len=%d [bad: < 8] len=%d %s/%u.%u.%u.%uIPSECDOI_ID_IPV4_ADDR_RANGE len=%d %s-%sIPSECDOI_ID_DER_ASN1_DNIPSECDOI_ID_DER_ASN1_GNIPSECDOI_ID_KEY_ID(ndo," len=%d", len)(ndo," [|%s]", NPSTR(ISAKMP_NPTYPE_ID))(ndo," [|%s]", (((5) < sizeof(npstr)/sizeof(npstr[0]) && npstr[(5)]) ? npstr[(5)] : numstr(5)))FQDN"FQDN"user FQDN"user FQDN"IPv4net"IPv4net"IPv6net"IPv6net"IPv4range"IPv4range"IPv6range"IPv6range"ASN1 DN"ASN1 DN"ASN1 GN"ASN1 GN"keyid"keyid"ikev1_ke_print(ndo,"%s:", NPSTR(ISAKMP_NPTYPE_KE))(ndo,"%s:", (((4) < sizeof(npstr)/sizeof(npstr[0]) && npstr[(4)]) ? npstr[(4)] : numstr(4)))ISAKMP_NPTYPE_KE(ndo," key len=%d", ntohs(e.len) - 4)(ndo," key len=%d", ((__uint16_t)(__builtin_constant_p(e.len) ? ((__uint16_t)((((__uint16_t)(e.len) & 0xff00U) >> 8) | (((__uint16_t)(e.len) & 0x00ffU) << 8))) : _OSSwapInt16(e.len))) - 4) key len=%d(ndo," [|%s]", NPSTR(ISAKMP_NPTYPE_KE))(ndo," [|%s]", (((4) < sizeof(npstr)/sizeof(npstr[0]) && npstr[(4)]) ? npstr[(4)] : numstr(4)))ikev1_t_printconst ikev1_pl_tconst ikev1_pl_t *ikev1_pl_t *(ndo,"%s:", NPSTR(ISAKMP_NPTYPE_T))(ndo,"%s:", (((3) < sizeof(npstr)/sizeof(npstr[0]) && npstr[(3)]) ? npstr[(3)] : numstr(3)))ikev1_p_mapah_p_mapipcomp_p_mapconst attrmap[10]attrmap[10]2560sizeof(ipsec_t_map)sizeof(ipsec_t_map[0])sizeof(ipsec_t_map)/sizeof(ipsec_t_map[0])(ndo," #%d id=%s ", t.t_no, idstr)(ndo," #%d id=%d ", t.t_no, t.t_id) #%d id=%s  #%d id=%d ikev1_p_printconst ikev1_pl_pconst ikev1_pl_p *ikev1_pl_p *(ndo,"%s:", NPSTR(ISAKMP_NPTYPE_P))(ndo,"%s:", (((2) < sizeof(npstr)/sizeof(npstr[0]) && npstr[(2)]) ? npstr[(2)] : numstr(2)))(ndo," #%d protoid=%s transform=%d", prop.p_no, PROTOIDSTR(prop.prot_id), prop.num_t)(ndo," #%d protoid=%s transform=%d", prop.p_no, (((prop.prot_id) < sizeof(protoidstr)/sizeof(protoidstr[0]) && protoidstr[(prop.prot_id)]) ? protoidstr[(prop.prot_id)] : numstr(prop.prot_id)), prop.num_t) #%d protoid=%s transform=%dikev1_sa_printconst ikev1_pl_saconst ikev1_pl_sa *ikev1_pl_sa *sit(ndo,"%s:", NPSTR(ISAKMP_NPTYPE_SA))(ndo,"%s:", (((1) < sizeof(npstr)/sizeof(npstr[0]) && npstr[(1)]) ? npstr[(1)] : numstr(1)))&sasizeof(sa)sa.doisa.sit(ndo," situation=%u", (uint32_t)ntohl(sa.sit))(ndo," situation=%u", (uint32_t)(__builtin_constant_p(sa.sit) ? ((__uint32_t)((((__uint32_t)(sa.sit) & 0xff000000U) >> 24) | (((__uint32_t)(sa.sit) & 0x00ff0000U) >> 8) | (((__uint32_t)(sa.sit) & 0x0000ff00U) << 8) | (((__uint32_t)(sa.sit) & 0x000000ffU) << 24))) : _OSSwapInt32(sa.sit))) situation=%u(ndo," situation=") situation=(ndo,"identity")identity(ndo,"%ssecrecy", t ? "+" : "")%ssecrecy(ndo,"%sintegrity", t ? "+" : "")%sintegrity*(ext + 1)sizeof(ident)&identext + 1(ndo," ident=%u", (uint32_t)ntohl(ident))(ndo," ident=%u", (uint32_t)(__builtin_constant_p(ident) ? ((__uint32_t)((((__uint32_t)(ident) & 0xff000000U) >> 24) | (((__uint32_t)(ident) & 0x00ff0000U) >> 8) | (((__uint32_t)(ident) & 0x0000ff00U) << 8) | (((__uint32_t)(ident) & 0x000000ffU) << 24))) : _OSSwapInt32(ident))) ident=%u(ndo," [|%s]", NPSTR(ISAKMP_NPTYPE_SA))(ndo," [|%s]", (((1) < sizeof(npstr)/sizeof(npstr[0]) && npstr[(1)]) ? npstr[(1)] : numstr(1)))ikev1_attr_printtotlen(ndo,"[|attr]")[|attr]&p[0]327670x7fff(ndo,"type=#%d ", t)type=#%d (ndo,"value=")(ndo,"len=%d value=", EXTRACT_16BITS(&p[2]))(ndo,"len=%d value=", ((uint16_t)(((uint16_t)(*((const uint8_t *)(&p[2]) + 0)) << 8) | ((uint16_t)(*((const uint8_t *)(&p[2]) + 1)) << 0))))value=len=%d value=ikev1_attrmap_print(ndo,"type=%s ", map[t].type)type=%s (ndo,"%s", map[t].value[v])const char *[30]char *[30]const char *constconst char *const *ike_show_somedataendelen 20(ndo, "...")rawprint*lochexprint(ndo,"%02x", p[i] & 0xff)cookie_sidecheck&cookiecache[i].iaddr.in4&cookiecache[i].raddr.in4struct <unnamed>[20]MAXINITIATORScookie_record&cookiecache[ninitiator].iaddr.in4&cookiecache[ninitiator].raddr.in4&cookiecache[ninitiator].initiatorsizeof(*in)initiatorcookie_findiszeroattrmapinaddr_uipsecdoi_idipsecdoi_secrecy_hipsecdoi_saikev2_auth_typeIV2_RSA_SIGIV2_SHAREDIV2_DSS_SIGikev2_authnotify_messagesikev2_n_typeikev2_nikev2_idikev2_id_typeikev2_keikev2_t_typeikev2_tikev2_pisakmp_ph2tabikev1_ph2ikev1_ph1tabikev1_ph1ikev1_pl_dikev1_pl_nikev1_pl_nonceikev1_pl_sigikev1_pl_hashikev1_pl_crikev1_pl_certikev1_pl_idikev1_pl_keikev1_pl_tikev1_pl_pikev1_pl_saisakmp_dataisakmp_genu_char[4]msgid_tcookie_tvaluenvalueraddriaddrin4auth_methodmsgspi_sizeprot_idres2res1ke_res1ke_groupt_typenum_tp_noikev1_ph2 *tailheadikev1_ph1 *num_spinum_certencodedoi_dataid_typet_nolorvmsgidr_cki_ckconst attrmap[]attrmap[]enc"enc"1des"1des"idea"idea"blowfish"blowfish"rc5"rc5"3des"3des"cast"cast"aes"aes"hash"hash"md5"md5"sha1"sha1"tiger"tiger"sha2-256"sha2-256"sha2-384"sha2-384"sha2-512"sha2-512"auth"auth"preshared"preshared"dss"dss"rsa sig"rsa sig"rsa enc"rsa enc"rsa enc revised"rsa enc revised"group desc"group desc"modp768"modp768"modp1024"modp1024"EC2N 2^155"EC2N 2^155"EC2N 2^185"EC2N 2^185"modp1536"modp1536"iana-grp06"iana-grp06"iana-grp07"iana-grp07"iana-grp08"iana-grp08"iana-grp09"iana-grp09"iana-grp10"iana-grp10"iana-grp11"iana-grp11"iana-grp12"iana-grp12"iana-grp13"iana-grp13"modp2048"modp2048"modp3072"modp3072"modp4096"modp4096"modp6144"modp6144"modp8192"modp8192"group type"group type"MODP"MODP"ECP"ECP"EC2N"EC2N"group prime"group prime"group gen1"group gen1"group gen2"group gen2"group curve A"group curve A"group curve B"group curve B"lifetype"lifetype""sec"kb"kb"lifeduration"lifeduration"prf"prf"keylen"keylen"field"field"order"order"oakley_t_mapencr_t_maplife"life"enc mode"enc mode"tunnel"tunnel"transport"transport"hmac-md5"hmac-md5"hmac-sha1"hmac-sha1"1des-mac"1des-mac"keyed"keyed"rounds"rounds"dictsize"dictsize"privalg"privalg"ipsec_t_map"oui"deflate"deflate"lzs"lzs"1des-iv64"1des-iv64"3idea"3idea"1des-iv32"1des-iv32"rc4"rc4"null"null"no-esn"no-esn"esn"esn"hmac-sha"hmac-sha"dec-mac"dec-mac"kpdk-md5"kpdk-md5"aes-xcbc"aes-xcbc"hmac-tiger"hmac-tiger"aes128_xcbc"aes128_xcbc"(reserved)"(reserved)"sha"sha"encr"encr"integ"integ""dh"ike"ike""base""ident"agg"agg"inf"inf"oakley-quick"oakley-quick"oakley-newgroup"oakley-newgroup"ikev2_init"ikev2_init""ikev2_auth"child_sa"child_sa"inf2"inf2"npfunc"p""t""ke""id""cert"cr"cr"sig"sig""n""d""vid"pay14"pay14"pay15"pay15"pay16"pay16"pay17"pay17"pay18"pay18"pay19"pay19"pay20"pay20"pay21"pay21"pay22"pay22"pay23"pay23"pay24"pay24"pay25"pay25"pay26"pay26"pay27"pay27"pay28"pay28"pay29"pay29"pay30"pay30"pay31"pay31"pay32"pay32"v2sa"v2sa"v2ke"v2ke"v2IDi"v2IDi"v2IDr"v2IDr"v2cert"v2cert"v2cr"v2cr"v2auth"v2auth"v2nonce"v2nonce"v2n"v2n"v2d"v2d"v2vid"v2vid"v2TSi"v2TSi"v2TSr"v2TSr"v2e"v2e"v2cp"v2cp"v2eap"v2eap""isakmp"ipsec-ah"ipsec-ah"ipsec-esp"ipsec-esp""ipcomp"cookiecacheninitiatorIPSEC_NOTIFY_STATUS_STR(x)STR_OR_ID((u_int)((x) - 24576), ipsec_notify_status_str)NOTIFY_STATUS_STR(x)STR_OR_ID((u_int)((x) - 16384), notify_status_str)IPSEC_NOTIFY_ERROR_STR(x)STR_OR_ID((u_int)((x) - 8192), ipsec_notify_error_str)NOTIFY_ERROR_STR(x)STR_OR_ID((x), notify_error_str)USE_IPSECDOI_IN_PHASE1cookie_isresponder(x,y)cookie_sidecheck((x), (y), 0)cookie_isinitiator(x,y)cookie_sidecheck((x), (y), 1)NPFUNC(x)(((x) < sizeof(npfunc)/sizeof(npfunc[0]) && npfunc[(x)]) ? npfunc[(x)] : NULL)CHECKLEN(p,np)if (ep < (u_char *)(p)) { ND_PRINT((ndo," [|%s]", NPSTR(np))); goto done; }ETYPESTR(x)STR_OR_ID(x, etypestr)NPSTR(x)STR_OR_ID(x, npstr)PROTOIDSTR(x)STR_OR_ID(x, protoidstr)STR_OR_ID(x,tab)(((x) < sizeof(tab)/sizeof(tab[0]) && tab[(x)]) ? tab[(x)] : numstr(x))DECLARE_PRINTER(func)static const u_char *ike ## func ## _print( netdissect_options *ndo, u_char tpay, const struct isakmp_gen *ext, u_int item_len, const u_char *end_pointer, uint32_t phase, uint32_t doi0, uint32_t proto0, int depth)IPSECDOI_NTYPE_INITIAL_CONTACTIPSECDOI_ID_IPV6_ADDR_RANGEIPSECDOI_ID_IPV6_ADDR_SUBNETIPSECDOI_ID_IPV6_ADDRIPSECDOI_ATTR_COMP_PRIVALGIPSECDOI_ATTR_COMP_DICT_SIZEIPSECDOI_ATTR_KEY_ROUNDSIPSECDOI_ATTR_KEY_LENGTHIPSECDOI_ATTR_AUTH_KPDKIPSECDOI_ATTR_AUTH_DES_MACIPSECDOI_ATTR_AUTH_HMAC_SHA1IPSECDOI_ATTR_AUTH_HMAC_MD5IPSECDOI_ATTR_AUTHIPSECDOI_ATTR_ENC_MODE_TRNSIPSECDOI_ATTR_ENC_MODE_TUNNELIPSECDOI_ATTR_ENC_MODEIPSECDOI_ATTR_GRP_DESCIPSECDOI_ATTR_SA_LDUR_DEFAULT28800IPSECDOI_ATTR_SA_LDURIPSECDOI_ATTR_SA_LTYPE_KBIPSECDOI_ATTR_SA_LTYPE_SECIPSECDOI_ATTR_SA_LTYPE_DEFAULTIPSECDOI_ATTR_SA_LTYPEIPSECDOI_IPCOMP_LZSIPSECDOI_IPCOMP_DEFLATEIPSECDOI_IPCOMP_OUIIPSECDOI_PROTO_IPCOMPIPSECDOI_ESP_AESIPSECDOI_ESP_RIJNDAELIPSECDOI_ESP_NULLIPSECDOI_ESP_RC4IPSECDOI_ESP_DES_IV32IPSECDOI_ESP_3IDEAIPSECDOI_ESP_BLOWFISHIPSECDOI_ESP_CASTIPSECDOI_ESP_IDEAIPSECDOI_ESP_RC5IPSECDOI_ESP_3DESIPSECDOI_ESP_DESIPSECDOI_ESP_DES_IV64IPSECDOI_PROTO_IPSEC_ESPIPSECDOI_AH_SHA2_512IPSECDOI_AH_SHA2_384IPSECDOI_AH_SHA2_256IPSECDOI_AH_DESIPSECDOI_AH_SHAIPSECDOI_AH_MD5IPSECDOI_PROTO_IPSEC_AHIPSECDOI_KEY_IKEIPSECDOI_PROTO_ISAKMPIPSECDOI_SIT_INTEGRITY0x00000004IPSECDOI_SIT_SECRECYIPSECDOI_SIT_IDENTITY_ONLY0x00000001IPSEC_DOIISAKMP_NTYPE_ADDRESS_NOTIFICATIONISAKMP_NTYPE_INVALID_SIGNATUREISAKMP_NTYPE_AUTHENTICATION_FAILEDISAKMP_NTYPE_INVALID_HASH_INFORMATIONISAKMP_NTYPE_INVALID_CERT_AUTHORITYISAKMP_NTYPE_BAD_CERT_REQUEST_SYNTAXISAKMP_NTYPE_INVALID_CERTIFICATEISAKMP_NTYPE_INVALID_CERT_ENCODINGISAKMP_NTYPE_INVALID_ID_INFORMATIONISAKMP_NTYPE_INVALID_KEY_INFORMATIONISAKMP_NTYPE_PAYLOAD_MALFORMEDISAKMP_NTYPE_BAD_PROPOSAL_SYNTAXISAKMP_NTYPE_ATTRIBUTES_NOT_SUPPORTEDISAKMP_NTYPE_INVALID_TRANSFORM_IDISAKMP_NTYPE_INVALID_SPIISAKMP_NTYPE_INVALID_PROTOCOL_IDISAKMP_NTYPE_INVALID_MESSAGE_IDISAKMP_NTYPE_INVALID_FLAGSISAKMP_NTYPE_INVALID_EXCHANGE_TYPEISAKMP_NTYPE_INVALID_MINOR_VERSIONISAKMP_NTYPE_INVALID_MAJOR_VERSIONISAKMP_NTYPE_INVALID_COOKIEISAKMP_NTYPE_SITUATION_NOT_SUPPORTEDISAKMP_NTYPE_DOI_NOT_SUPPORTEDISAKMP_NTYPE_INVALID_PAYLOAD_TYPEISAKMP_FLAG_RISAKMP_FLAG_V(1 << 4)ISAKMP_FLAG_I(1 << 3)ISAKMP_FLAG_extraISAKMP_FLAG_CIKEv2_MINOR_VERSIONIKEv1_MINOR_VERSIONISAKMP_NPTYPE_NONEPORT_ISAKMPv2_eapv2_cpv2_TSv2_vidv2_dv2_nv2_noncev2_crv2_certv2_IDv2_kev2_sav1_vidv1_dend_pointerv1_nv1_noncev1_hashv1_sigv1_crv1_certv1_idv1_kev1_tv1_pv1_sa/* must be an ESP packet *//*
	 * see if this is an IKE packet
	 *//* initialize SAs *//*
			 * encrypted, nothing we can do right now.
			 * we hope to decrypt the packet in the future...
			 *//* regardless of phase... *//* Zero-length subitem *//*pcount,*//*
		 * XXX - what if item_len is too short, or too long,
		 * for this payload type?
		 *//*
	 * Since we can't have a payload length of less than 4 bytes,
	 * we need to bail out here if the generic header is nonsensical
	 * or truncated, otherwise we could loop forever processing
	 * zero-length items or otherwise misdissect the packet.
	 *//* the first packet *//* always return NULL, because E must be at end, and NP refers
	 * to what was inside.
	 *//* got it decrypted, print stuff inside. *//* try to decypt it! *//* notify space is annoying sparse *//* notify payloads *//************************************************************//*                                                          *//*              IKE v2 - rfc4306 - dissector                *//* NULL is dummy *//* 24576 - 32767 *//* 16384 - 24575 *//* 8192 - 16383 *//* 0 - 8191 *//* NOTE: these macro must be called with x in proper range *//* A protocol ID of 0 DOES NOT mean IPPROTO_IP! *//*debug*//* group 18 *//* group 17 *//* group 16 *//* group 15 *//* group 14 *//* group 5 *//* group 4 *//* group 3 *//* group 2 *//* 12,13*//* 10,11*//* 8, 9 *//* 6, 7 *//* 4, 5 *//* 2, 3 *//* 0, 1 *//* really shouldn't happen because of above *//* there is too much data, just show some of it *//*
 * returns false if we run out of data buffer
 *//* record initiator *//* find cookie from initiator cache *//* 34-37 *//* IKEv2 exchange types *//* 32-33 *//* 24-31 *//* 16-23 *//*  8-15 *//* 0-7 *//* IKEv1 exchange types *//* isakmp->etype *//* 46 - special *//* ikev2_e_print,*//* 29- 32 *//* 24- 28 *//* 19- 23 *//* 14- 18 *//* isakmp->np *//* 43- 47 *//* 38- 42 *//* 33- 37 *//* 9 - 13 *//* 0 - 8 *//* protocol id *//* Notify Messages - Status Types *//* 4.6.3 IPSEC DOI Notify Message Types *//* Identification Data *//* Port *//* Protocol ID *//* ID Type *//* 4.6.2.1 Identification Type Values *//* Situation *//* Domain of Interpretation *//* 4.6.1 Security Association Payload *//* V *//* B *//*
	 * When negotiating ESP without authentication, the Auth
	 * Algorithm attribute MUST NOT be included in the proposal.
	 * When negotiating ESP without confidentiality, the Auth
	 * Algorithm attribute MUST be included in the proposal and
	 * the ESP transform ID must be ESP_NULL.
	*//*RFC-1826(Key/Pad/Data/Key)*//* 0 means not to use authentication. *//* default value: host dependent *//* 8 hours *//* 4.5 IPSEC Security Association Attributes *//* 4.4.5 IPSEC IPCOMP Transform Identifiers *//* 4.4.1 IPSEC Security Protocol Identifiers *//* 4.4.4 IPSEC ESP Transform Identifiers *//* 4.4.3 IPSEC AH Transform Values *//* 4.4.2 IPSEC ISAKMP Transform Values *//* 4.2 IPSEC Situation Definition *//* refer to RFC 2407 *//* life duration *//* type of duration of lifetime *//* type of cipher *//* type of hash *//* type of prf *//* method of authentication *//* DH; group *//* spi *//* OAKLEY *//* isakmp sa structure *//* refer to RFC 2409 *//* authentication data *//* Protocol-ID *//* 3.8 Notification Payload *//* Notify Message Type *//* SPI Size *//* 3.10 Notification Payload *//* Notification Data *//* SPI *//* ID type *//* 3.5.  Identification Payloads *//* KE data *//* 3.4.  Key Exchange Payload *//* Transform ID *//* reserved byte *//* Transform Type (ENCR,PRF,INTEG,etc.*//* 3.3.2.  Transform Substructure *//* Number of Transforms *//* Protocol *//* Proposal # *//* 3.3.1.  Proposal Substructure *//* 3.3  Security Association Payload -- generic header *//* IKEv2 (RFC4306) *//* SPI(es) *//* # of SPIs *//* Protocol-Id *//* 3.15 Delete Payload *//* NOTIFY MESSAGES - ERROR TYPES *//* 3.14.1 Notify Message Types *//* 3.14 Notification Payload *//* Nonce Data *//* may not be used, because of having only data. *//* 3.13 Nonce Payload *//* Signature Data *//* 3.12 Signature Payload *//* Hash Data *//* 3.11 Hash Payload *//* Certificate Authorities (variable length) *//* # Certificate Authorities (1 octet) *//*
	Certificate Types (variable length)
	  -- Contains a list of the types of certificates requested,
	  sorted in order of preference.  Each individual certificate
	  type is 1 octet.  This field is NOT requiredo
	*//* # Cert. Types *//* 3.10 Certificate Request Payload *//*
		This field indicates the type of
		certificate or certificate-related information contained in the
		Certificate Data field.
		*//* Certificate Data *//* Cert Encoding *//* 3.9 Certificate Payload *//* DOI Specific ID Data *//* MUST NOT to be used, because of being defined in ipsec-doi. *//* 3.8 Identification Payload *//* Key Exchange Data *//* 3.7 Key Exchange Payload *//* SA Attributes *//* RESERVED2 *//* Transform-Id *//* Transform # *//*
	The value of the next payload field MUST only contain the value "3"
	or "0".  If there are additional Transform payloads in the proposal,
	then this field will be 3.  If the current Transform payload is the
	last within the proposal, then this field will be 0.
	*//* 3.6 Transform Payload *//*
	The value of the next payload field MUST only contain the value "2"
	or "0".  If there are additional Proposal payloads in the message,
	then this field will be 2.  If the current Proposal payload is the
	last within the security association proposal, then this field will
	be 0.
	*//* 3.5 Proposal Payload *//*
	If the current payload is the last in the message,
	then the value of the next payload field will be 0.
	This field MUST NOT contain the
	values for the Proposal or Transform payloads as they are considered
	part of the security association negotiation.  For example, this
	field would contain the value "10" (Nonce payload) in the first
	message of a Base Exchange (see Section 4.4) and the value "0" in the
	first message of an Identity Protect Exchange (see Section 4.5).
	*//* MAY NOT be used, because of being defined in ipsec-doi. *//* 3.4 Security Association Payload *//* if f equal 1, Attribute Value *//* if f equal 0, Attribute Value *//* if f equal 1, Attribute Length *//* defined by DOI-spec, and Attribute Format *//* 3.3 Data Attributes
         0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
        +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
        !A!       Attribute Type        !    AF=0  Attribute Length     !
        !F!                             !    AF=1  Attribute Value      !
        +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
        .                   AF=0  Attribute Value                       .
        .                   AF=1  Not Transmitted                       .
        +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
*//* Payload Length *//* bit 7 - critical, rest is RESERVED *//* Next Payload *//* 3.2 Payload Generic Header
         0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
        +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
        ! Next Payload  !   RESERVED    !         Payload Length        !
        +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
*//* (R)esponse  *//* (V)ersion   *//* (I)nitiator *//* IKEv2 *//* Commit Bit *//* Encryption Bit *//* v2 Encrypted payload *//* Vendor ID *//* Delete *//* Notification *//* Signature *//* Hash *//* Certificate Request *//* Certificate *//* Identification *//* Key Exchange *//* Transform *//* Proposal *//* Security Association *//* NONE*//* Next Payload Type *//* Exchange Type *//* Responder Cookie *//* Initiator Cookie *//* 3.1 ISAKMP Header Format (IKEv1 and IKEv2)
         0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
        +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
        !                          Initiator                            !
        !                            Cookie                             !
        +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
        !                          Responder                            !
        !                            Cookie                             !
        +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
        !  Next Payload ! MjVer ! MnVer ! Exchange Type !     Flags     !
        +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
        !                          Message ID                           !
        +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
        !                            Length                             !
        +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
*//* refer to RFC 2408 *//* The functions from print-esp.c used in this file are only defined when both
 * OpenSSL and evp.h are detected. Employ the same preprocessor device here.
 *//*
 * Copyright (C) 1995, 1996, 1997, and 1998 WIDE Project.
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. Neither the name of the project nor the names of its contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE PROJECT AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE PROJECT OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 *
 *//Users/owura/Repos/codeql_eval/proj_repos/the-tcpdump-group-tcpdump-commit-0f95d441e4b5d7512cc5c326c8668a120e048eda/tcpdump/signature.hsignature_verifysignature_check_valuesCANT_CHECK_SIGNATURESIGNATURE_INVALIDSIGNATURE_VALID/* signature checking result codes *//* for netdissect_options *//*
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that: (1) source code
 * distributions retain the above copyright notice and this paragraph
 * in its entirety, and (2) distributions including binary code include
 * the above copyright notice and this paragraph in its entirety in
 * the documentation or other materials provided with the distribution.
 * THIS SOFTWARE IS PROVIDED ``AS IS'' AND
 * WITHOUT ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, WITHOUT
 * LIMITATION, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS
 * FOR A PARTICULAR PURPOSE.
 *
 * Functions for signature and digest verification.
 *
 * Original code by Hannes Gredler (hannes@juniper.net)
 *//Users/owura/Repos/codeql_eval/proj_repos/the-tcpdump-group-tcpdump-commit-0f95d441e4b5d7512cc5c326c8668a120e048eda/tcpdump/print-isoclns.c"signature.h"osi_print_cksumcalculated_checksum(ndo, "(unverified)")(ndo, " (correct)")(ndo, " (incorrect should be 0x%04x)", calculated_checksum)(unverified) (correct) (incorrect should be 0x%04x)isis_printconst isis_common_headerconst isis_common_header *isis_common_header *isis_headerconst isis_iih_lan_headerconst isis_iih_lan_header *isis_iih_lan_header *header_iih_lanconst isis_iih_ptp_headerconst isis_iih_ptp_header *isis_iih_ptp_header *header_iih_ptpisis_lsp_header *header_lspconst isis_csnp_headerconst isis_csnp_header *isis_csnp_header *header_csnpconst isis_psnp_headerconst isis_psnp_header *isis_psnp_header *header_psnpconst isis_tlv_lspconst isis_tlv_lsp *isis_tlv_lsp *tlv_lspconst isis_tlv_ptp_adjconst isis_tlv_ptp_adj *isis_tlv_ptp_adj *tlv_ptp_adjconst isis_tlv_is_reachconst isis_tlv_is_reach *isis_tlv_is_reach *tlv_is_reachconst isis_tlv_es_reachconst isis_tlv_es_reach *isis_tlv_es_reach *tlv_es_reachpdu_typemax_areaid_lengthtmplan_alenprefix_lenext_is_lenext_ip_lenmt_lenoptrpacket_lenpdu_lenkey_idvendor_idsigcheck*isis_headersizeof(*isis_header)ISIS_COMMON_HEADER_SIZE(ISIS_COMMON_HEADER_SIZE)(ndo, "IS-IS")(ndo, "version %d packet not supported", isis_header->version)ISIS_VERSIONversion %d packet not supported(ndo, "system ID length of %d is not supported", isis_header->id_length)system ID length of %d is not supported(ndo, "version %d packet not supported", isis_header->pdu_version)(ndo, "bad packet -- 255 areas")bad packet -- 255 areas(ndo, "bad packet -- illegal sys-ID length (%u)", id_length)bad packet -- illegal sys-ID length (%u)(ndo, "%s%s", ndo->ndo_eflag ? "" : ", ", tok2str(isis_pdu_values, "unknown PDU-Type %u", pdu_type))(ndo, ", src-id %s", isis_print_id(header_iih_lan->source_id, SYSTEM_ID_LEN))(ndo, ", src-id %s", isis_print_id(header_iih_lan->source_id, 6))(ndo, ", lan-id %s, prio %u", isis_print_id(header_iih_lan->lan_id,NODE_ID_LEN), header_iih_lan->priority)(ndo, ", lan-id %s, prio %u", isis_print_id(header_iih_lan->lan_id,6+1), header_iih_lan->priority)(ndo, ", src-id %s", isis_print_id(header_iih_ptp->source_id, SYSTEM_ID_LEN))(ndo, ", src-id %s", isis_print_id(header_iih_ptp->source_id, 6))(ndo, ", lsp-id %s, seq 0x%08x, lifetime %5us", isis_print_id(header_lsp->lsp_id, LSP_ID_LEN), EXTRACT_32BITS(header_lsp->sequence_number), EXTRACT_16BITS(header_lsp->remaining_lifetime))(ndo, ", lsp-id %s, seq 0x%08x, lifetime %5us", isis_print_id(header_lsp->lsp_id, 6+2), ((uint32_t)(((uint32_t)(*((const uint8_t *)(header_lsp->sequence_number) + 0)) << 24) | ((uint32_t)(*((const uint8_t *)(header_lsp->sequence_number) + 1)) << 16) | ((uint32_t)(*((const uint8_t *)(header_lsp->sequence_number) + 2)) << 8) | ((uint32_t)(*((const uint8_t *)(header_lsp->sequence_number) + 3)) << 0))), ((uint16_t)(((uint16_t)(*((const uint8_t *)(header_lsp->remaining_lifetime) + 0)) << 8) | ((uint16_t)(*((const uint8_t *)(header_lsp->remaining_lifetime) + 1)) << 0))))header_lsp->sequence_numberheader_lsp->remaining_lifetime(ndo, ", src-id %s", isis_print_id(header_csnp->source_id, NODE_ID_LEN))(ndo, ", src-id %s", isis_print_id(header_csnp->source_id, 6+1))(ndo, ", src-id %s", isis_print_id(header_psnp->source_id, NODE_ID_LEN))(ndo, ", src-id %s", isis_print_id(header_psnp->source_id, 6+1))unknown PDU-Type %uISIS_PDU_L1_LAN_IIHISIS_PDU_L2_LAN_IIH, src-id %s, lan-id %s, prio %uuint8_t[7]unsigned char[7]ISIS_PDU_PTP_IIHISIS_PDU_L1_LSPISIS_PDU_L2_LSP, lsp-id %s, seq 0x%08x, lifetime %5usISIS_PDU_L1_CSNPISIS_PDU_L2_CSNPISIS_PDU_L1_PSNPISIS_PDU_L2_PSNP(ndo, "%slength %u", ndo->ndo_eflag ? "" : ", ", length)%slength %u(ndo, "\n\t%s, hlen: %u, v: %u, pdu-v: %u, sys-id-len: %u (%u), max-area: %u (%u)", tok2str(isis_pdu_values, "unknown, type %u", pdu_type), isis_header->fixed_len, isis_header->version, isis_header->pdu_version, id_length, isis_header->id_length, max_area, isis_header->max_area)
	%s, hlen: %u, v: %u, pdu-v: %u, sys-id-len: %u (%u), max-area: %u (%u)unknown, type %u(ndo, ", bogus fixed header length %u should be %lu", isis_header->fixed_len, (unsigned long)ISIS_IIH_LAN_HEADER_SIZE)(ndo, ", bogus fixed header length %u should be %lu", isis_header->fixed_len, (unsigned long)(sizeof(struct isis_iih_lan_header)))header_iih_lan->pdu_len*header_iih_lansizeof(*header_iih_lan)(ndo, "\n\t  source-id: %s,  holding time: %us, Flags: [%s]", isis_print_id(header_iih_lan->source_id,SYSTEM_ID_LEN), EXTRACT_16BITS(header_iih_lan->holding_time), tok2str(isis_iih_circuit_type_values, "unknown circuit type 0x%02x", header_iih_lan->circuit_type))(ndo, "\n\t  source-id: %s,  holding time: %us, Flags: [%s]", isis_print_id(header_iih_lan->source_id,6), ((uint16_t)(((uint16_t)(*((const uint8_t *)(header_iih_lan->holding_time) + 0)) << 8) | ((uint16_t)(*((const uint8_t *)(header_iih_lan->holding_time) + 1)) << 0))), tok2str(isis_iih_circuit_type_values, "unknown circuit type 0x%02x", header_iih_lan->circuit_type))header_iih_lan->holding_time(ndo, "\n\t  lan-id:    %s, Priority: %u, PDU length: %u", isis_print_id(header_iih_lan->lan_id, NODE_ID_LEN), (header_iih_lan->priority) & ISIS_LAN_PRIORITY_MASK, pdu_len)(ndo, "\n\t  lan-id:    %s, Priority: %u, PDU length: %u", isis_print_id(header_iih_lan->lan_id, 6+1), (header_iih_lan->priority) & 0x7F, pdu_len)(ndo, ", bogus fixed header length %u should be %lu", isis_header->fixed_len, (unsigned long)ISIS_IIH_PTP_HEADER_SIZE)(ndo, ", bogus fixed header length %u should be %lu", isis_header->fixed_len, (unsigned long)(sizeof(struct isis_iih_ptp_header)))header_iih_ptp->pdu_len*header_iih_ptpsizeof(*header_iih_ptp)(ndo, "\n\t  source-id: %s, holding time: %us, Flags: [%s]", isis_print_id(header_iih_ptp->source_id,SYSTEM_ID_LEN), EXTRACT_16BITS(header_iih_ptp->holding_time), tok2str(isis_iih_circuit_type_values, "unknown circuit type 0x%02x", header_iih_ptp->circuit_type))(ndo, "\n\t  source-id: %s, holding time: %us, Flags: [%s]", isis_print_id(header_iih_ptp->source_id,6), ((uint16_t)(((uint16_t)(*((const uint8_t *)(header_iih_ptp->holding_time) + 0)) << 8) | ((uint16_t)(*((const uint8_t *)(header_iih_ptp->holding_time) + 1)) << 0))), tok2str(isis_iih_circuit_type_values, "unknown circuit type 0x%02x", header_iih_ptp->circuit_type))header_iih_ptp->holding_time(ndo, "\n\t  circuit-id: 0x%02x, PDU length: %u", header_iih_ptp->circuit_id, pdu_len)(ndo, ", bogus fixed header length %u should be %lu", isis_header->fixed_len, (unsigned long)ISIS_LSP_HEADER_SIZE)(ndo, ", bogus fixed header length %u should be %lu", isis_header->fixed_len, (unsigned long)(sizeof(struct isis_lsp_header)))header_lsp->pdu_len*header_lspsizeof(*header_lsp)(ndo, "\n\t  lsp-id: %s, seq: 0x%08x, lifetime: %5us\n\t  chksum: 0x%04x", isis_print_id(header_lsp->lsp_id, LSP_ID_LEN), EXTRACT_32BITS(header_lsp->sequence_number), EXTRACT_16BITS(header_lsp->remaining_lifetime), EXTRACT_16BITS(header_lsp->checksum))(ndo, "\n\t  lsp-id: %s, seq: 0x%08x, lifetime: %5us\n\t  chksum: 0x%04x", isis_print_id(header_lsp->lsp_id, 6+2), ((uint32_t)(((uint32_t)(*((const uint8_t *)(header_lsp->sequence_number) + 0)) << 24) | ((uint32_t)(*((const uint8_t *)(header_lsp->sequence_number) + 1)) << 16) | ((uint32_t)(*((const uint8_t *)(header_lsp->sequence_number) + 2)) << 8) | ((uint32_t)(*((const uint8_t *)(header_lsp->sequence_number) + 3)) << 0))), ((uint16_t)(((uint16_t)(*((const uint8_t *)(header_lsp->remaining_lifetime) + 0)) << 8) | ((uint16_t)(*((const uint8_t *)(header_lsp->remaining_lifetime) + 1)) << 0))), ((uint16_t)(((uint16_t)(*((const uint8_t *)(header_lsp->checksum) + 0)) << 8) | ((uint16_t)(*((const uint8_t *)(header_lsp->checksum) + 1)) << 0))))header_lsp->checksum(ndo, ", PDU length: %u, Flags: [ %s", pdu_len, ISIS_MASK_LSP_OL_BIT(header_lsp->typeblock) ? "Overload bit set, " : "")(ndo, ", PDU length: %u, Flags: [ %s", pdu_len, ((header_lsp->typeblock)&0x4) ? "Overload bit set, " : "")header_lsp->typeblock(ndo, "%s", ISIS_MASK_LSP_ATT_DEFAULT_BIT(header_lsp->typeblock) ? "default " : "")(ndo, "%s", ((header_lsp->typeblock)&0x8) ? "default " : "")(ndo, "%s", ISIS_MASK_LSP_ATT_DELAY_BIT(header_lsp->typeblock) ? "delay " : "")(ndo, "%s", ((header_lsp->typeblock)&0x10) ? "delay " : "")(ndo, "%s", ISIS_MASK_LSP_ATT_EXPENSE_BIT(header_lsp->typeblock) ? "expense " : "")(ndo, "%s", ((header_lsp->typeblock)&0x20) ? "expense " : "")(ndo, "%s", ISIS_MASK_LSP_ATT_ERROR_BIT(header_lsp->typeblock) ? "error " : "")(ndo, "%s", ((header_lsp->typeblock)&0x40) ? "error " : "")(ndo, "ATT bit set, ")(ndo, "%s", ISIS_MASK_LSP_PARTITION_BIT(header_lsp->typeblock) ? "P bit set, " : "")(ndo, "%s", ((header_lsp->typeblock)&0x80) ? "P bit set, " : "")(ndo, "%s ]", tok2str(isis_lsp_istype_values, "Unknown(0x%x)", ISIS_MASK_LSP_ISTYPE_BITS(header_lsp->typeblock)))(ndo, "%s ]", tok2str(isis_lsp_istype_values, "Unknown(0x%x)", ((header_lsp->typeblock)&0x3)))(ndo, ", bogus fixed header length %u should be %lu", isis_header->fixed_len, (unsigned long)ISIS_CSNP_HEADER_SIZE)(ndo, ", bogus fixed header length %u should be %lu", isis_header->fixed_len, (unsigned long)(sizeof(struct isis_csnp_header)))header_csnp->pdu_len*header_csnpsizeof(*header_csnp)(ndo, "\n\t  source-id:    %s, PDU length: %u", isis_print_id(header_csnp->source_id, NODE_ID_LEN), pdu_len)(ndo, "\n\t  source-id:    %s, PDU length: %u", isis_print_id(header_csnp->source_id, 6+1), pdu_len)(ndo, "\n\t  start lsp-id: %s", isis_print_id(header_csnp->start_lsp_id, LSP_ID_LEN))(ndo, "\n\t  start lsp-id: %s", isis_print_id(header_csnp->start_lsp_id, 6+2))(ndo, "\n\t  end lsp-id:   %s", isis_print_id(header_csnp->end_lsp_id, LSP_ID_LEN))(ndo, "\n\t  end lsp-id:   %s", isis_print_id(header_csnp->end_lsp_id, 6+2))(ndo, "- bogus fixed header length %u should be %lu", isis_header->fixed_len, (unsigned long)ISIS_PSNP_HEADER_SIZE)(ndo, "- bogus fixed header length %u should be %lu", isis_header->fixed_len, (unsigned long)(sizeof(struct isis_psnp_header)))header_psnp->pdu_len*header_psnpsizeof(*header_psnp)(ndo, "\n\t  source-id:    %s, PDU length: %u", isis_print_id(header_psnp->source_id, NODE_ID_LEN), pdu_len)(ndo, "\n\t  source-id:    %s, PDU length: %u", isis_print_id(header_psnp->source_id, 6+1), pdu_len)ISIS_IIH_LAN_HEADER_SIZE(ISIS_COMMON_HEADER_SIZE+ISIS_IIH_LAN_HEADER_SIZE), bogus fixed header length %u should be %lu
	  source-id: %s,  holding time: %us, Flags: [%s]unknown circuit type 0x%02x
	  lan-id:    %s, Priority: %u, PDU length: %uISIS_IIH_PTP_HEADER_SIZE(ISIS_COMMON_HEADER_SIZE+ISIS_IIH_PTP_HEADER_SIZE)
	  source-id: %s, holding time: %us, Flags: [%s]
	  circuit-id: 0x%02x, PDU length: %uISIS_LSP_HEADER_SIZE(ISIS_COMMON_HEADER_SIZE+ISIS_LSP_HEADER_SIZE)
	  lsp-id: %s, seq: 0x%08x, lifetime: %5us
	  chksum: 0x%04x, PDU length: %u, Flags: [ %sOverload bit set, default delay expense error ATT bit set, P bit set, %s ]Unknown(0x%x)ISIS_CSNP_HEADER_SIZE(ISIS_COMMON_HEADER_SIZE+ISIS_CSNP_HEADER_SIZE)
	  source-id:    %s, PDU length: %u
	  start lsp-id: %s
	  end lsp-id:   %sISIS_PSNP_HEADER_SIZE(ISIS_COMMON_HEADER_SIZE+ISIS_PSNP_HEADER_SIZE)- bogus fixed header length %u should be %lu(ndo, "\n\t\t packet exceeded snapshot (%ld) bytes", (long)(pptr - ndo->ndo_snapend))(ndo, "\n\t    %s TLV #%u, length: %u", tok2str(isis_tlv_values, "unknown", tlv_type), tlv_type, tlv_len)(ndo, "\n\t      Area address (length: %u): %s", alen, isonsap_string(tptr, alen))(ndo, "\n\t      SNPA: %s", isis_print_id(tptr, ETHER_ADDR_LEN))(ndo, "\n\t      SNPA: %s", isis_print_id(tptr, 6))(ndo, "\n\t      LAN address length 0 bytes (invalid)")(ndo, "\n\t      LAN address length %u bytes ", lan_alen)(ndo, "\n\t\tIS Neighbor: %s", isis_print_id(tptr, lan_alen))(ndo, "\n\t      %s", tok2str(isis_is_reach_virtual_values, "bogus virtual flag 0x%02x", *tptr++))*tlv_is_reachsizeof(*tlv_is_reach)(ndo, "\n\t      IS Neighbor: %s", isis_print_id(tlv_is_reach->neighbor_nodeid, NODE_ID_LEN))(ndo, "\n\t      IS Neighbor: %s", isis_print_id(tlv_is_reach->neighbor_nodeid, 6+1))*tlv_es_reachsizeof(*tlv_es_reach)(ndo, "\n\t      ES Neighbor: %s", isis_print_id(tlv_es_reach->neighbor_sysid, SYSTEM_ID_LEN))(ndo, "\n\t      ES Neighbor: %s", isis_print_id(tlv_es_reach->neighbor_sysid, 6))(ndo, "\n\t      %s: ", tok2str(isis_subtlv_auth_values, "unknown Authentication type 0x%02x", *tptr))*(tptr + i)(ndo, "%c", *(tptr + i))(ndo, "%02x", *(tptr + i))(ndo, ", (malformed subTLV) ")(ndo, " (%s)", tok2str(signature_check_values, "Unknown", sigcheck))(tptr+1)(ndo, "%u, password: ", key_id)(ndo, "\n\t      Adjacency State: %s (%u)", tok2str(isis_ptp_adjancey_values, "unknown", *tptr), *tptr)tlv_ptp_adj->extd_local_circuit_idsizeof(tlv_ptp_adj->extd_local_circuit_id)(ndo, "\n\t      Extended Local circuit-ID: 0x%08x", EXTRACT_32BITS(tlv_ptp_adj->extd_local_circuit_id))(ndo, "\n\t      Extended Local circuit-ID: 0x%08x", ((uint32_t)(((uint32_t)(*((const uint8_t *)(tlv_ptp_adj->extd_local_circuit_id) + 0)) << 24) | ((uint32_t)(*((const uint8_t *)(tlv_ptp_adj->extd_local_circuit_id) + 1)) << 16) | ((uint32_t)(*((const uint8_t *)(tlv_ptp_adj->extd_local_circuit_id) + 2)) << 8) | ((uint32_t)(*((const uint8_t *)(tlv_ptp_adj->extd_local_circuit_id) + 3)) << 0))))tlv_ptp_adj->neighbor_sysidSYSTEM_ID_LEN(ndo, "\n\t      Neighbor System-ID: %s", isis_print_id(tlv_ptp_adj->neighbor_sysid, SYSTEM_ID_LEN))(ndo, "\n\t      Neighbor System-ID: %s", isis_print_id(tlv_ptp_adj->neighbor_sysid, 6))tlv_ptp_adj->neighbor_extd_local_circuit_idsizeof(tlv_ptp_adj->neighbor_extd_local_circuit_id)(ndo, "\n\t      Neighbor Extended Local circuit-ID: 0x%08x", EXTRACT_32BITS(tlv_ptp_adj->neighbor_extd_local_circuit_id))(ndo, "\n\t      Neighbor Extended Local circuit-ID: 0x%08x", ((uint32_t)(((uint32_t)(*((const uint8_t *)(tlv_ptp_adj->neighbor_extd_local_circuit_id) + 0)) << 24) | ((uint32_t)(*((const uint8_t *)(tlv_ptp_adj->neighbor_extd_local_circuit_id) + 1)) << 16) | ((uint32_t)(*((const uint8_t *)(tlv_ptp_adj->neighbor_extd_local_circuit_id) + 2)) << 8) | ((uint32_t)(*((const uint8_t *)(tlv_ptp_adj->neighbor_extd_local_circuit_id) + 3)) << 0))))(ndo, "\n\t      NLPID(s): ")*(tptr)(ndo, "%s (0x%02x)", tok2str(nlpid_values, "unknown", *tptr), *tptr)(ndo, "\n\t       RES: %d, MTID(s): %d", (EXTRACT_16BITS (tptr) >> 12), (EXTRACT_16BITS (tptr) & 0x0fff))(ndo, "\n\t       RES: %d, MTID(s): %d", (((uint16_t)(((uint16_t)(*((const uint8_t *)(tptr) + 0)) << 8) | ((uint16_t)(*((const uint8_t *)(tptr) + 1)) << 0))) >> 12), (((uint16_t)(((uint16_t)(*((const uint8_t *)(tptr) + 0)) << 8) | ((uint16_t)(*((const uint8_t *)(tptr) + 1)) << 0))) & 0x0fff))(ndo, "\n\t      O: %d, RES: %d, MTID(s): %d", (EXTRACT_16BITS(tptr) >> 15) & 0x01, (EXTRACT_16BITS(tptr) >> 12) & 0x07, EXTRACT_16BITS(tptr) & 0x0fff)(ndo, "\n\t      O: %d, RES: %d, MTID(s): %d", (((uint16_t)(((uint16_t)(*((const uint8_t *)(tptr) + 0)) << 8) | ((uint16_t)(*((const uint8_t *)(tptr) + 1)) << 0))) >> 15) & 0x01, (((uint16_t)(((uint16_t)(*((const uint8_t *)(tptr) + 0)) << 8) | ((uint16_t)(*((const uint8_t *)(tptr) + 1)) << 0))) >> 12) & 0x07, ((uint16_t)(((uint16_t)(*((const uint8_t *)(tptr) + 0)) << 8) | ((uint16_t)(*((const uint8_t *)(tptr) + 1)) << 0))) & 0x0fff)(ndo, "\n\t      Traffic Engineering Router ID: %s", ipaddr_string(ndo, pptr))(ndo, "\n\t      Traffic Engineering Router ID: %s", getname(ndo, (const u_char *)(pptr)))(ndo, "\n\t      IPv4 interface address: %s", ipaddr_string(ndo, tptr))(ndo, "\n\t      IPv4 interface address: %s", getname(ndo, (const u_char *)(tptr)))(ndo, "\n\t      Hostname: ")(ndo, "%c", *tptr++)NODE_ID_LEN6+1(ndo, "\n\t      IS Neighbor: %s", isis_print_id(tptr, NODE_ID_LEN))(ndo, "\n\t      IS Neighbor: %s", isis_print_id(tptr, 6+1))(ndo, ", Flags: [%s]", ISIS_MASK_TLV_SHARED_RISK_GROUP(*tptr++) ? "numbered" : "unnumbered")(ndo, ", Flags: [%s]", ((*tptr++)&0x1) ? "numbered" : "unnumbered")*tptr++(ndo, "\n\t      IPv4 neighbor address: %s", ipaddr_string(ndo, tptr))(ndo, "\n\t      IPv4 neighbor address: %s", getname(ndo, (const u_char *)(tptr)))(ndo, "\n\t      Link-ID: 0x%08x", EXTRACT_32BITS(tptr))(ndo, "\n\t      Link-ID: 0x%08x", ((uint32_t)(((uint32_t)(*((const uint8_t *)(tptr) + 0)) << 24) | ((uint32_t)(*((const uint8_t *)(tptr) + 1)) << 16) | ((uint32_t)(*((const uint8_t *)(tptr) + 2)) << 8) | ((uint32_t)(*((const uint8_t *)(tptr) + 3)) << 0))))(tlv_lsp->lsp_id)[LSP_ID_LEN-1](tlv_lsp->lsp_id)[6+2-1]sizeof((tlv_lsp->lsp_id)[6+2-1])(ndo, "\n\t      lsp-id: %s", isis_print_id(tlv_lsp->lsp_id, LSP_ID_LEN))(ndo, "\n\t      lsp-id: %s", isis_print_id(tlv_lsp->lsp_id, 6+2))tlv_lsp->sequence_number(ndo, ", seq: 0x%08x", EXTRACT_32BITS(tlv_lsp->sequence_number))(ndo, ", seq: 0x%08x", ((uint32_t)(((uint32_t)(*((const uint8_t *)(tlv_lsp->sequence_number) + 0)) << 24) | ((uint32_t)(*((const uint8_t *)(tlv_lsp->sequence_number) + 1)) << 16) | ((uint32_t)(*((const uint8_t *)(tlv_lsp->sequence_number) + 2)) << 8) | ((uint32_t)(*((const uint8_t *)(tlv_lsp->sequence_number) + 3)) << 0))))tlv_lsp->remaining_lifetime(ndo, ", lifetime: %5ds", EXTRACT_16BITS(tlv_lsp->remaining_lifetime))(ndo, ", lifetime: %5ds", ((uint16_t)(((uint16_t)(*((const uint8_t *)(tlv_lsp->remaining_lifetime) + 0)) << 8) | ((uint16_t)(*((const uint8_t *)(tlv_lsp->remaining_lifetime) + 1)) << 0))))tlv_lsp->checksum(ndo, ", chksum: 0x%04x", EXTRACT_16BITS(tlv_lsp->checksum))(ndo, ", chksum: 0x%04x", ((uint16_t)(((uint16_t)(*((const uint8_t *)(tlv_lsp->checksum) + 0)) << 8) | ((uint16_t)(*((const uint8_t *)(tlv_lsp->checksum) + 1)) << 0))))ISIS_TLV_CHECKSUM_MINLEN(ndo, "\n\t      checksum: 0x%04x ", EXTRACT_16BITS(tptr))(ndo, "\n\t      checksum: 0x%04x ", ((uint16_t)(((uint16_t)(*((const uint8_t *)(tptr) + 0)) << 8) | ((uint16_t)(*((const uint8_t *)(tptr) + 1)) << 0))))(ndo, "\n\t      malformed MT-ID")ISIS_TLV_RESTART_SIGNALING_FLAGLEN(ndo, "\n\t      Flags [%s]", bittok2str(isis_restart_flag_values, "none", *tptr))ISIS_TLV_RESTART_SIGNALING_HOLDTIMELEN(ndo, ", Remaining holding time %us", EXTRACT_16BITS(tptr))(ndo, ", Remaining holding time %us", ((uint16_t)(((uint16_t)(*((const uint8_t *)(tptr) + 0)) << 8) | ((uint16_t)(*((const uint8_t *)(tptr) + 1)) << 0))))(ndo, ", for %s", isis_print_id(tptr,SYSTEM_ID_LEN))(ndo, ", for %s", isis_print_id(tptr,6))ISIS_TLV_IDRP_INFO_MINLEN(ndo, "\n\t      Inter-Domain Information Type: %s", tok2str(isis_subtlv_idrp_values, "Unknown (0x%02x)", *tptr))(ndo, "AS Number: %u", EXTRACT_16BITS(tptr))(ndo, "AS Number: %u", ((uint16_t)(((uint16_t)(*((const uint8_t *)(tptr) + 0)) << 8) | ((uint16_t)(*((const uint8_t *)(tptr) + 1)) << 0))))ISIS_TLV_LSP_BUFFERSIZE_MINLEN(ndo, "\n\t      LSP Buffersize: %u", EXTRACT_16BITS(tptr))(ndo, "\n\t      LSP Buffersize: %u", ((uint16_t)(((uint16_t)(*((const uint8_t *)(tptr) + 0)) << 8) | ((uint16_t)(*((const uint8_t *)(tptr) + 1)) << 0))))(ndo, "\n\t      %s", isis_print_id(tptr, SYSTEM_ID_LEN))(ndo, "\n\t      %s", isis_print_id(tptr, 6))sizeof(struct isis_metric_block)(ndo, "\n\t      Metric Block")(ndo, "\n\t\tAddress: prefix length %u < 2", prefix_len)prefix_len / 2(ndo, "\n\t\tAddress: %s/%u", isonsap_string(tptr, prefix_len / 2), prefix_len * 4)ISIS_TLV_IIH_SEQNR_MINLEN(ndo, "\n\t      Sequence number: %u", EXTRACT_32BITS(tptr))(ndo, "\n\t      Sequence number: %u", ((uint32_t)(((uint32_t)(*((const uint8_t *)(tptr) + 0)) << 24) | ((uint32_t)(*((const uint8_t *)(tptr) + 1)) << 16) | ((uint32_t)(*((const uint8_t *)(tptr) + 2)) << 8) | ((uint32_t)(*((const uint8_t *)(tptr) + 3)) << 0))))ISIS_TLV_VENDOR_PRIVATE_MINLEN(ndo, "\n\t      Vendor: %s (%u)", tok2str(oui_values, "Unknown", vendor_id), vendor_id)
		 packet exceeded snapshot (%ld) bytes
	    %s TLV #%u, length: %uconst tok[41]tok[41]ISIS_TLV_AREA_ADDR
	      Area address (length: %u): %sISIS_TLV_ISNEIGH
	      SNPA: %sISIS_TLV_ISNEIGH_VARLEN
	      LAN address length 0 bytes (invalid)
	      LAN address length %u bytes 
		IS Neighbor: %sISIS_TLV_PADDING222ISIS_TLV_MT_IS_REACH2+NODE_ID_LEN2+NODE_ID_LEN+32+NODE_ID_LEN+3+1ISIS_TLV_IS_ALIAS_IDISIS_TLV_EXT_IS_REACHISIS_TLV_IS_REACHbogus virtual flag 0x%02xsizeof(struct isis_tlv_is_reach)
	      IS Neighbor: %sconst isis_metric_blockconst isis_metric_block *isis_metric_block *ISIS_TLV_ESNEIGHsizeof(struct isis_tlv_es_reach)
	      ES Neighbor: %sISIS_TLV_INT_IP_REACHISIS_TLV_EXT_IP_REACHISIS_TLV_EXTD_IP_REACH235ISIS_TLV_MT_IP_REACHISIS_TLV_AUTH
	      %s: unknown Authentication type 0x%02xISIS_SUBTLV_AUTH_SIMPLEISIS_SUBTLV_AUTH_MD5ISIS_SUBTLV_AUTH_MD5_LEN, (malformed subTLV) ISIS_SUBTLV_AUTH_GENERIC%u, password: sizeof(uint16_t)1 + sizeof(uint16_t)ISIS_SUBTLV_AUTH_PRIVATE
		  "\n\t\t  "ISIS_TLV_PTP_ADJ
	      Adjacency State: %s (%u)
	      Extended Local circuit-ID: 0x%08xconst uint8_t[6]const uint8_t(*)[6]
	      Neighbor System-ID: %s
	      Neighbor Extended Local circuit-ID: 0x%08xISIS_TLV_PROTOCOLS
	      NLPID(s): %s (0x%02x)ISIS_TLV_MT_PORT_CAP
	       RES: %d, MTID(s): %dISIS_TLV_MT_CAPABILITY
	      O: %d, RES: %d, MTID(s): %dISIS_TLV_TE_ROUTER_ID
	      Traffic Engineering Router ID: %sISIS_TLV_IPADDR
	      IPv4 interface address: %sISIS_TLV_HOSTNAME
	      Hostname: ISIS_TLV_SHARED_RISK_GROUP(NODE_ID_LEN)numberedunnumbered
	      IPv4 neighbor address: %s
	      Link-ID: 0x%08xISIS_TLV_LSPsizeof(struct isis_tlv_lsp)
	      lsp-id: %s, seq: 0x%08x, lifetime: %5ds, chksum: 0x%04xISIS_TLV_CHECKSUM
	      checksum: 0x%04x 229ISIS_TLV_MT_SUPPORTEDISIS_TLV_MT_SUPPORTED_MINLEN
	      malformed MT-ID211ISIS_TLV_RESTART_SIGNALING
	      Flags [%s], Remaining holding time %us, for %sISIS_TLV_IDRP_INFO
	      Inter-Domain Information Type: %sISIS_SUBTLV_IDRP_ASNAS Number: %uISIS_SUBTLV_IDRP_LOCALISIS_SUBTLV_IDRP_RESISIS_TLV_LSP_BUFFERSIZE
	      LSP Buffersize: %uISIS_TLV_PART_DISISIS_TLV_PREFIX_NEIGH
	      Metric Block
		Address: prefix length %u < 2
		Address: %s/%uISIS_TLV_IIH_SEQNR
	      Sequence number: %uISIS_TLV_VENDOR_PRIVATE
	      Vendor: %s (%u)ISIS_TLV_DECNET_PHASE4ISIS_TLV_LUCENT_PRIVATEISIS_TLV_IPAUTHISIS_TLV_NORTEL_PRIVATE1ISIS_TLV_NORTEL_PRIVATE2(ndo, "\n\t      %u straggler bytes", packet_len)
	      %u straggler bytes(ndo, "[|isis]")[|isis]trunctlvisis_print_extd_ip_reachident_bufferstatus_bytesublenprocessedsubtlvtypesubtlvlen(ndo, "%sIPv4 prefix: bad bit length %u", ident, bit_length)0x3f%sIPv4 prefix: bad bit length %u0, sizeof prefixtptr,byte_length(ndo, "%sIPv4 prefix: %15s/%u", ident, ipaddr_string(ndo, prefix), bit_length)(ndo, "%sIPv4 prefix: %15s/%u", ident, getname(ndo, (const u_char *)(prefix)), bit_length)%sIPv4 prefix: %15s/%u(ndo, ", Distribution: %s, Metric: %u", ISIS_MASK_TLV_EXTD_IP_UPDOWN(status_byte) ? "down" : "up", metric)(ndo, ", Distribution: %s, Metric: %u", ((status_byte)&0x80) ? "down" : "up", metric), Distribution: %s, Metric: %u(ndo, ", sub-TLVs present"), sub-TLVs present(ndo, " (%u)", sublen)sizeof(ident_buffer)"%s  ",ident (%u)%s  isis_print_mtid(ndo, "%s%s", ident, tok2str(isis_mt_values, "Reserved for IETF Consensus", ISIS_MASK_MTID(EXTRACT_16BITS(tptr))))(ndo, "%s%s", ident, tok2str(isis_mt_values, "Reserved for IETF Consensus", ((((uint16_t)(((uint16_t)(*((const uint8_t *)(tptr) + 0)) << 8) | ((uint16_t)(*((const uint8_t *)(tptr) + 1)) << 0))))&0x0fff)))Reserved for IETF ConsensusEXTRACT_16BITS(tptr)((uint16_t)(((uint16_t)(*((const uint8_t *)(tptr) + 0)) << 8) | ((uint16_t)(*((const uint8_t *)(tptr) + 1)) << 0)))(ndo, " Topology (0x%03x), Flags: [%s]", ISIS_MASK_MTID(EXTRACT_16BITS(tptr)), bittok2str(isis_mt_flag_values, "none",ISIS_MASK_MTFLAGS(EXTRACT_16BITS(tptr))))(ndo, " Topology (0x%03x), Flags: [%s]", ((((uint16_t)(((uint16_t)(*((const uint8_t *)(tptr) + 0)) << 8) | ((uint16_t)(*((const uint8_t *)(tptr) + 1)) << 0))))&0x0fff), bittok2str(isis_mt_flag_values, "none",((((uint16_t)(((uint16_t)(*((const uint8_t *)(tptr) + 0)) << 8) | ((uint16_t)(*((const uint8_t *)(tptr) + 1)) << 0))))&0xf000))) Topology (0x%03x), Flags: [%s]61440(2)isis_print_ext_is_reachsubtlv_typesubtlv_lensubtlv_sum_lenproc_bytes(ndo, "%sIS Neighbor: %s", ident, isis_print_id(tptr, NODE_ID_LEN))(ndo, "%sIS Neighbor: %s", ident, isis_print_id(tptr, 6+1))%sIS Neighbor: %s(ndo, ", Metric: %d", EXTRACT_24BITS(tptr))(ndo, ", Metric: %d", ((uint32_t)(((uint32_t)(*((const uint8_t *)(tptr) + 0)) << 16) | ((uint32_t)(*((const uint8_t *)(tptr) + 1)) << 8) | ((uint32_t)(*((const uint8_t *)(tptr) + 2)) << 0)))), Metric: %d(ndo, ", %ssub-TLVs present",subtlv_sum_len ? "" : "no "), %ssub-TLVs presentno (ndo, " (%u)", subtlv_sum_len)isis_print_is_reach_subtlvte_classpriority_levelgmpls_switch_cap(ndo, "%s%s subTLV #%u, length: %u", ident, tok2str(isis_ext_is_reach_subtlv_values, "unknown", subt), subt, subl)%s%s subTLV #%u, length: %usubl(ndo, ", 0x%08x", EXTRACT_32BITS(tptr))(ndo, ", 0x%08x", ((uint32_t)(((uint32_t)(*((const uint8_t *)(tptr) + 0)) << 24) | ((uint32_t)(*((const uint8_t *)(tptr) + 1)) << 16) | ((uint32_t)(*((const uint8_t *)(tptr) + 2)) << 8) | ((uint32_t)(*((const uint8_t *)(tptr) + 3)) << 0))))(ndo, ", 0x%08x", EXTRACT_32BITS(tptr+4))(ndo, ", 0x%08x", ((uint32_t)(((uint32_t)(*((const uint8_t *)(tptr+4) + 0)) << 24) | ((uint32_t)(*((const uint8_t *)(tptr+4) + 1)) << 16) | ((uint32_t)(*((const uint8_t *)(tptr+4) + 2)) << 8) | ((uint32_t)(*((const uint8_t *)(tptr+4) + 3)) << 0))))(ndo, ", %s", ipaddr_string(ndo, tptr))(ndo, ", %s", getname(ndo, (const u_char *)(tptr)))(ndo, ", %.3f Mbps", bw.f * 8 / 1000000)(ndo, "%s  TE-Class %u: %.3f Mbps", ident, te_class, bw.f * 8 / 1000000)(ndo, "%sBandwidth Constraints Model ID: %s (%u)", ident, tok2str(diffserv_te_bc_values, "unknown", *tptr), *tptr)(ndo, "%s  Bandwidth constraint CT%u: %.3f Mbps", ident, te_class, bw.f * 8 / 1000000)(ndo, ", %u", EXTRACT_24BITS(tptr))(ndo, ", %u", ((uint32_t)(((uint32_t)(*((const uint8_t *)(tptr) + 0)) << 16) | ((uint32_t)(*((const uint8_t *)(tptr) + 1)) << 8) | ((uint32_t)(*((const uint8_t *)(tptr) + 2)) << 0))))(ndo, ", [ %s ] (0x%04x)", bittok2str(isis_subtlv_link_attribute_values, "Unknown", EXTRACT_16BITS(tptr)), EXTRACT_16BITS(tptr))(ndo, ", [ %s ] (0x%04x)", bittok2str(isis_subtlv_link_attribute_values, "Unknown", ((uint16_t)(((uint16_t)(*((const uint8_t *)(tptr) + 0)) << 8) | ((uint16_t)(*((const uint8_t *)(tptr) + 1)) << 0)))), ((uint16_t)(((uint16_t)(*((const uint8_t *)(tptr) + 0)) << 8) | ((uint16_t)(*((const uint8_t *)(tptr) + 1)) << 0))))(ndo, ", %s, Priority %u", bittok2str(gmpls_link_prot_values, "none", *tptr), *(tptr+1))(ndo, ", LM: %u", EXTRACT_24BITS(tptr))(ndo, ", LM: %u", ((uint32_t)(((uint32_t)(*((const uint8_t *)(tptr) + 0)) << 16) | ((uint32_t)(*((const uint8_t *)(tptr) + 1)) << 8) | ((uint32_t)(*((const uint8_t *)(tptr) + 2)) << 0))))(ndo, ", P: %u", *(tptr))(ndo, ", P-ID: %u", EXTRACT_16BITS(tptr))(ndo, ", P-ID: %u", ((uint16_t)(((uint16_t)(*((const uint8_t *)(tptr) + 0)) << 8) | ((uint16_t)(*((const uint8_t *)(tptr) + 1)) << 0))))(ndo, "%s  Interface Switching Capability:%s", ident, tok2str(gmpls_switch_cap_values, "Unknown", gmpls_switch_cap))(ndo, ", LSP Encoding: %s", tok2str(gmpls_encoding_values, "Unknown", *(tptr + 1)))(ndo, "%s  Max LSP Bandwidth:", ident)(ndo, "%s    priority level %d: %.3f Mbps", ident, priority_level, bw.f * 8 / 1000000)(ndo, "%s  Min LSP Bandwidth: %.3f Mbps", ident, bw.f * 8 / 1000000)(ndo, "%s  Interface MTU: %u", ident, EXTRACT_16BITS(tptr + 4))(ndo, "%s  Interface MTU: %u", ident, ((uint16_t)(((uint16_t)(*((const uint8_t *)(tptr + 4) + 0)) << 8) | ((uint16_t)(*((const uint8_t *)(tptr + 4) + 1)) << 0))))tptr + 4(ndo, "%s  Indication %s", ident, tok2str(gmpls_switch_cap_tsc_indication_values, "Unknown (%u)", *(tptr + 4)))ISIS_SUBTLV_EXT_IS_REACH_ADMIN_GROUPISIS_SUBTLV_EXT_IS_REACH_LINK_LOCAL_REMOTE_IDISIS_SUBTLV_EXT_IS_REACH_LINK_REMOTE_ID, 0x%08xISIS_SUBTLV_EXT_IS_REACH_IPV4_INTF_ADDRISIS_SUBTLV_EXT_IS_REACH_IPV4_NEIGHBOR_ADDRISIS_SUBTLV_EXT_IS_REACH_MAX_LINK_BWISIS_SUBTLV_EXT_IS_REACH_RESERVABLE_BW, %.3f MbpsISIS_SUBTLV_EXT_IS_REACH_UNRESERVED_BW%s  TE-Class %u: %.3f MbpsISIS_SUBTLV_EXT_IS_REACH_BW_CONSTRAINTSISIS_SUBTLV_EXT_IS_REACH_BW_CONSTRAINTS_OLD%sBandwidth Constraints Model ID: %s (%u)%s  Bandwidth constraint CT%u: %.3f MbpsISIS_SUBTLV_EXT_IS_REACH_TE_METRIC, %usubtISIS_SUBTLV_EXT_IS_REACH_LINK_ATTRIBUTE, [ %s ] (0x%04x)ISIS_SUBTLV_EXT_IS_REACH_LINK_PROTECTION_TYPE, %s, Priority %uISIS_SUBTLV_SPB_METRIC, LM: %u, P: %u, P-ID: %uISIS_SUBTLV_EXT_IS_REACH_INTF_SW_CAP_DESCR%s  Interface Switching Capability:%s, LSP Encoding: %s%s  Max LSP Bandwidth:%s    priority level %d: %.3f Mbps%s  Min LSP Bandwidth: %.3f Mbps%s  Interface MTU: %u%s  Indication %s
		    "\n\t\t    "(ndo, "%spacket exceeded snapshot", ident)%spacket exceeded snapshotisis_print_ip_reach_subtlv(ndo, "%s%s subTLV #%u, length: %u", ident, tok2str(isis_ext_ip_reach_subtlv_values, "unknown", subt), subt, subl)(ndo, ", 0x%08x (=%u)", EXTRACT_32BITS(tptr), EXTRACT_32BITS(tptr))(ndo, ", 0x%08x (=%u)", ((uint32_t)(((uint32_t)(*((const uint8_t *)(tptr) + 0)) << 24) | ((uint32_t)(*((const uint8_t *)(tptr) + 1)) << 16) | ((uint32_t)(*((const uint8_t *)(tptr) + 2)) << 8) | ((uint32_t)(*((const uint8_t *)(tptr) + 3)) << 0))), ((uint32_t)(((uint32_t)(*((const uint8_t *)(tptr) + 0)) << 24) | ((uint32_t)(*((const uint8_t *)(tptr) + 1)) << 16) | ((uint32_t)(*((const uint8_t *)(tptr) + 2)) << 8) | ((uint32_t)(*((const uint8_t *)(tptr) + 3)) << 0))))(ndo, ", 0x%08x%08x", EXTRACT_32BITS(tptr), EXTRACT_32BITS(tptr+4))(ndo, ", 0x%08x%08x", ((uint32_t)(((uint32_t)(*((const uint8_t *)(tptr) + 0)) << 24) | ((uint32_t)(*((const uint8_t *)(tptr) + 1)) << 16) | ((uint32_t)(*((const uint8_t *)(tptr) + 2)) << 8) | ((uint32_t)(*((const uint8_t *)(tptr) + 3)) << 0))), ((uint32_t)(((uint32_t)(*((const uint8_t *)(tptr+4) + 0)) << 24) | ((uint32_t)(*((const uint8_t *)(tptr+4) + 1)) << 16) | ((uint32_t)(*((const uint8_t *)(tptr+4) + 2)) << 8) | ((uint32_t)(*((const uint8_t *)(tptr+4) + 3)) << 0))))ISIS_SUBTLV_EXTD_IP_REACH_MGMT_PREFIX_COLORISIS_SUBTLV_EXTD_IP_REACH_ADMIN_TAG32, 0x%08x (=%u)ISIS_SUBTLV_EXTD_IP_REACH_ADMIN_TAG64, 0x%08x%08xisis_print_tlv_ip_reachconst isis_tlv_ip_reachconst isis_tlv_ip_reach *isis_tlv_ip_reach *tlv_ip_reach(ndo, "short IPv4 Reachability (%d vs %lu)", length, (unsigned long)sizeof(*tlv_ip_reach))*tlv_ip_reachsizeof(*tlv_ip_reach)tlv_ip_reach->mask(ndo, "%sIPv4 prefix: %s mask %s", ident, ipaddr_string(ndo, (tlv_ip_reach->prefix)), ipaddr_string(ndo, (tlv_ip_reach->mask)))(ndo, "%sIPv4 prefix: %s mask %s", ident, getname(ndo, (const u_char *)((tlv_ip_reach->prefix))), getname(ndo, (const u_char *)((tlv_ip_reach->mask))))(tlv_ip_reach->prefix)(tlv_ip_reach->mask)(ndo, "%sIPv4 prefix: %15s/%u", ident, ipaddr_string(ndo, (tlv_ip_reach->prefix)), prefix_len)(ndo, "%sIPv4 prefix: %15s/%u", ident, getname(ndo, (const u_char *)((tlv_ip_reach->prefix))), prefix_len)(ndo, ", Distribution: %s, Metric: %u, %s", ISIS_LSP_TLV_METRIC_UPDOWN(tlv_ip_reach->isis_metric_block.metric_default) ? "down" : "up", ISIS_LSP_TLV_METRIC_VALUE(tlv_ip_reach->isis_metric_block.metric_default), ISIS_LSP_TLV_METRIC_IE(tlv_ip_reach->isis_metric_block.metric_default) ? "External" : "Internal")(ndo, ", Distribution: %s, Metric: %u, %s", ((tlv_ip_reach->isis_metric_block.metric_default)&0x80) ? "down" : "up", ((tlv_ip_reach->isis_metric_block.metric_default)&0x3f), ((tlv_ip_reach->isis_metric_block.metric_default)&0x40) ? "External" : "Internal")tlv_ip_reach->isis_metric_block.metric_defaulttlv_ip_reach->isis_metric_block.metric_delay(ndo, "%s  Delay Metric: %u, %s", ident, ISIS_LSP_TLV_METRIC_VALUE(tlv_ip_reach->isis_metric_block.metric_delay), ISIS_LSP_TLV_METRIC_IE(tlv_ip_reach->isis_metric_block.metric_delay) ? "External" : "Internal")(ndo, "%s  Delay Metric: %u, %s", ident, ((tlv_ip_reach->isis_metric_block.metric_delay)&0x3f), ((tlv_ip_reach->isis_metric_block.metric_delay)&0x40) ? "External" : "Internal")tlv_ip_reach->isis_metric_block.metric_expense(ndo, "%s  Expense Metric: %u, %s", ident, ISIS_LSP_TLV_METRIC_VALUE(tlv_ip_reach->isis_metric_block.metric_expense), ISIS_LSP_TLV_METRIC_IE(tlv_ip_reach->isis_metric_block.metric_expense) ? "External" : "Internal")(ndo, "%s  Expense Metric: %u, %s", ident, ((tlv_ip_reach->isis_metric_block.metric_expense)&0x3f), ((tlv_ip_reach->isis_metric_block.metric_expense)&0x40) ? "External" : "Internal")tlv_ip_reach->isis_metric_block.metric_error(ndo, "%s  Error Metric: %u, %s", ident, ISIS_LSP_TLV_METRIC_VALUE(tlv_ip_reach->isis_metric_block.metric_error), ISIS_LSP_TLV_METRIC_IE(tlv_ip_reach->isis_metric_block.metric_error) ? "External" : "Internal")(ndo, "%s  Error Metric: %u, %s", ident, ((tlv_ip_reach->isis_metric_block.metric_error)&0x3f), ((tlv_ip_reach->isis_metric_block.metric_error)&0x40) ? "External" : "Internal")short IPv4 Reachability (%d vs %lu)%sIPv4 prefix: %s mask %s, Distribution: %s, Metric: %u, %sInternal%s  Delay Metric: %u, %s%s  Expense Metric: %u, %s%s  Error Metric: %u, %ssizeof(struct isis_tlv_ip_reach)isis_print_metric_block(ndo, ", Default Metric: %d, %s", ISIS_LSP_TLV_METRIC_VALUE(isis_metric_block->metric_default), ISIS_LSP_TLV_METRIC_IE(isis_metric_block->metric_default) ? "External" : "Internal")(ndo, ", Default Metric: %d, %s", ((isis_metric_block->metric_default)&0x3f), ((isis_metric_block->metric_default)&0x40) ? "External" : "Internal"), Default Metric: %d, %sisis_metric_block->metric_defaultisis_metric_block->metric_delay(ndo, "\n\t\t  Delay Metric: %d, %s", ISIS_LSP_TLV_METRIC_VALUE(isis_metric_block->metric_delay), ISIS_LSP_TLV_METRIC_IE(isis_metric_block->metric_delay) ? "External" : "Internal")(ndo, "\n\t\t  Delay Metric: %d, %s", ((isis_metric_block->metric_delay)&0x3f), ((isis_metric_block->metric_delay)&0x40) ? "External" : "Internal")
		  Delay Metric: %d, %sisis_metric_block->metric_expense(ndo, "\n\t\t  Expense Metric: %d, %s", ISIS_LSP_TLV_METRIC_VALUE(isis_metric_block->metric_expense), ISIS_LSP_TLV_METRIC_IE(isis_metric_block->metric_expense) ? "External" : "Internal")(ndo, "\n\t\t  Expense Metric: %d, %s", ((isis_metric_block->metric_expense)&0x3f), ((isis_metric_block->metric_expense)&0x40) ? "External" : "Internal")
		  Expense Metric: %d, %sisis_metric_block->metric_error(ndo, "\n\t\t  Error Metric: %d, %s", ISIS_LSP_TLV_METRIC_VALUE(isis_metric_block->metric_error), ISIS_LSP_TLV_METRIC_IE(isis_metric_block->metric_error) ? "External" : "Internal")(ndo, "\n\t\t  Error Metric: %d, %s", ((isis_metric_block->metric_error)&0x3f), ((isis_metric_block->metric_error)&0x40) ? "External" : "Internal")
		  Error Metric: %d, %sisis_print_idsizeof("xxxx.xxxx.xxxx.yy-zz")sizeof(id) - (pos - id)"%02x", *cp++".%02x", *cp++.%02x"-%02x", *cp-%02xisis_print_mt_capability_subtlvstlv_typestlv_len(ndo, "\n\t      %s subTLV #%u, length: %u", tok2str(isis_mt_capability_subtlv_values, "unknown", stlv_type), stlv_type, stlv_len)ISIS_SUBTLV_SPB_INSTANCE_MIN_LEN(ndo, "\n\t        CIST Root-ID: %08x", EXTRACT_32BITS(tptr))(ndo, "\n\t        CIST Root-ID: %08x", ((uint32_t)(((uint32_t)(*((const uint8_t *)(tptr) + 0)) << 24) | ((uint32_t)(*((const uint8_t *)(tptr) + 1)) << 16) | ((uint32_t)(*((const uint8_t *)(tptr) + 2)) << 8) | ((uint32_t)(*((const uint8_t *)(tptr) + 3)) << 0))))(ndo, " %08x", EXTRACT_32BITS(tptr))(ndo, " %08x", ((uint32_t)(((uint32_t)(*((const uint8_t *)(tptr) + 0)) << 24) | ((uint32_t)(*((const uint8_t *)(tptr) + 1)) << 16) | ((uint32_t)(*((const uint8_t *)(tptr) + 2)) << 8) | ((uint32_t)(*((const uint8_t *)(tptr) + 3)) << 0))))(ndo, ", Path Cost: %08x", EXTRACT_32BITS(tptr))(ndo, ", Path Cost: %08x", ((uint32_t)(((uint32_t)(*((const uint8_t *)(tptr) + 0)) << 24) | ((uint32_t)(*((const uint8_t *)(tptr) + 1)) << 16) | ((uint32_t)(*((const uint8_t *)(tptr) + 2)) << 8) | ((uint32_t)(*((const uint8_t *)(tptr) + 3)) << 0))))(ndo, ", Prio: %d", EXTRACT_16BITS(tptr))(ndo, ", Prio: %d", ((uint16_t)(((uint16_t)(*((const uint8_t *)(tptr) + 0)) << 8) | ((uint16_t)(*((const uint8_t *)(tptr) + 1)) << 0))))(ndo, "\n\t        RES: %d", EXTRACT_16BITS(tptr) >> 5)(ndo, "\n\t        RES: %d", ((uint16_t)(((uint16_t)(*((const uint8_t *)(tptr) + 0)) << 8) | ((uint16_t)(*((const uint8_t *)(tptr) + 1)) << 0))) >> 5)(ndo, ", V: %d", (EXTRACT_16BITS(tptr) >> 4) & 0x0001)(ndo, ", V: %d", (((uint16_t)(((uint16_t)(*((const uint8_t *)(tptr) + 0)) << 8) | ((uint16_t)(*((const uint8_t *)(tptr) + 1)) << 0))) >> 4) & 0x0001)(ndo, ", SPSource-ID: %d", (EXTRACT_32BITS(tptr) & 0x000fffff))(ndo, ", SPSource-ID: %d", (((uint32_t)(((uint32_t)(*((const uint8_t *)(tptr) + 0)) << 24) | ((uint32_t)(*((const uint8_t *)(tptr) + 1)) << 16) | ((uint32_t)(*((const uint8_t *)(tptr) + 2)) << 8) | ((uint32_t)(*((const uint8_t *)(tptr) + 3)) << 0))) & 0x000fffff))(ndo, ", No of Trees: %x", *(tptr))ISIS_SUBTLV_SPB_INSTANCE_VLAN_TUPLE_LEN(ndo, "\n\t         U:%d, M:%d, A:%d, RES:%d", *(tptr) >> 7, (*(tptr) >> 6) & 0x01, (*(tptr) >> 5) & 0x01, (*(tptr) & 0x1f))(ndo, ", ECT: %08x", EXTRACT_32BITS(tptr))(ndo, ", ECT: %08x", ((uint32_t)(((uint32_t)(*((const uint8_t *)(tptr) + 0)) << 24) | ((uint32_t)(*((const uint8_t *)(tptr) + 1)) << 16) | ((uint32_t)(*((const uint8_t *)(tptr) + 2)) << 8) | ((uint32_t)(*((const uint8_t *)(tptr) + 3)) << 0))))(ndo, ", BVID: %d, SPVID: %d", (EXTRACT_24BITS(tptr) >> 12) & 0x000fff, EXTRACT_24BITS(tptr) & 0x000fff)(ndo, ", BVID: %d, SPVID: %d", (((uint32_t)(((uint32_t)(*((const uint8_t *)(tptr) + 0)) << 16) | ((uint32_t)(*((const uint8_t *)(tptr) + 1)) << 8) | ((uint32_t)(*((const uint8_t *)(tptr) + 2)) << 0))) >> 12) & 0x000fff, ((uint32_t)(((uint32_t)(*((const uint8_t *)(tptr) + 0)) << 16) | ((uint32_t)(*((const uint8_t *)(tptr) + 1)) << 8) | ((uint32_t)(*((const uint8_t *)(tptr) + 2)) << 0))) & 0x000fff)(ndo, "\n\t        BMAC: %08x", EXTRACT_32BITS(tptr))(ndo, "\n\t        BMAC: %08x", ((uint32_t)(((uint32_t)(*((const uint8_t *)(tptr) + 0)) << 24) | ((uint32_t)(*((const uint8_t *)(tptr) + 1)) << 16) | ((uint32_t)(*((const uint8_t *)(tptr) + 2)) << 8) | ((uint32_t)(*((const uint8_t *)(tptr) + 3)) << 0))))(ndo, "%04x", EXTRACT_16BITS(tptr))(ndo, "%04x", ((uint16_t)(((uint16_t)(*((const uint8_t *)(tptr) + 0)) << 8) | ((uint16_t)(*((const uint8_t *)(tptr) + 1)) << 0))))(ndo, ", RES: %d, VID: %d", EXTRACT_16BITS(tptr) >> 12, (EXTRACT_16BITS(tptr)) & 0x0fff)(ndo, ", RES: %d, VID: %d", ((uint16_t)(((uint16_t)(*((const uint8_t *)(tptr) + 0)) << 8) | ((uint16_t)(*((const uint8_t *)(tptr) + 1)) << 0))) >> 12, (((uint16_t)(((uint16_t)(*((const uint8_t *)(tptr) + 0)) << 8) | ((uint16_t)(*((const uint8_t *)(tptr) + 1)) << 0)))) & 0x0fff)(ndo, "\n\t        T: %d, R: %d, RES: %d, ISID: %d", (EXTRACT_32BITS(tptr) >> 31), (EXTRACT_32BITS(tptr) >> 30) & 0x01, (EXTRACT_32BITS(tptr) >> 24) & 0x03f, (EXTRACT_32BITS(tptr)) & 0x0ffffff)(ndo, "\n\t        T: %d, R: %d, RES: %d, ISID: %d", (((uint32_t)(((uint32_t)(*((const uint8_t *)(tptr) + 0)) << 24) | ((uint32_t)(*((const uint8_t *)(tptr) + 1)) << 16) | ((uint32_t)(*((const uint8_t *)(tptr) + 2)) << 8) | ((uint32_t)(*((const uint8_t *)(tptr) + 3)) << 0))) >> 31), (((uint32_t)(((uint32_t)(*((const uint8_t *)(tptr) + 0)) << 24) | ((uint32_t)(*((const uint8_t *)(tptr) + 1)) << 16) | ((uint32_t)(*((const uint8_t *)(tptr) + 2)) << 8) | ((uint32_t)(*((const uint8_t *)(tptr) + 3)) << 0))) >> 30) & 0x01, (((uint32_t)(((uint32_t)(*((const uint8_t *)(tptr) + 0)) << 24) | ((uint32_t)(*((const uint8_t *)(tptr) + 1)) << 16) | ((uint32_t)(*((const uint8_t *)(tptr) + 2)) << 8) | ((uint32_t)(*((const uint8_t *)(tptr) + 3)) << 0))) >> 24) & 0x03f, (((uint32_t)(((uint32_t)(*((const uint8_t *)(tptr) + 0)) << 24) | ((uint32_t)(*((const uint8_t *)(tptr) + 1)) << 16) | ((uint32_t)(*((const uint8_t *)(tptr) + 2)) << 8) | ((uint32_t)(*((const uint8_t *)(tptr) + 3)) << 0)))) & 0x0ffffff)
	      %s subTLV #%u, length: %uISIS_SUBTLV_SPB_INSTANCE
	        CIST Root-ID: %08x %08x, Path Cost: %08x, Prio: %d
	        RES: %d, V: %d, SPSource-ID: %d, No of Trees: %x
	         U:%d, M:%d, A:%d, RES:%d, ECT: %08x, BVID: %d, SPVID: %dISIS_SUBTLV_SPBM_SI
	        BMAC: %08x%04xisis_metric_block, RES: %d, VID: %d
	        T: %d, R: %d, RES: %d, ISID: %disis_print_mt_port_cap_subtlvconst isis_subtlv_spb_mcidconst isis_subtlv_spb_mcid *isis_subtlv_spb_mcid *subtlv_spb_mcid(ndo, "\n\t       %s subTLV #%u, length: %u", tok2str(isis_mt_port_cap_subtlv_values, "unknown", stlv_type), stlv_type, stlv_len)ISIS_SUBTLV_SPB_MCID_MIN_LEN(ndo, "\n\t         MCID: ")(ndo, "\n\t         AUX-MCID: ")ISIS_SUBTLV_SPB_DIGEST_MIN_LEN(ndo, "\n\t        RES: %d V: %d A: %d D: %d", (*(tptr) >> 5), (((*tptr)>> 4) & 0x01), ((*(tptr) >> 2) & 0x03), ((*tptr) & 0x03))(ndo, "\n\t         Digest: ")(ndo, "%08x ", EXTRACT_32BITS(tptr))(ndo, "%08x ", ((uint32_t)(((uint32_t)(*((const uint8_t *)(tptr) + 0)) << 24) | ((uint32_t)(*((const uint8_t *)(tptr) + 1)) << 16) | ((uint32_t)(*((const uint8_t *)(tptr) + 2)) << 8) | ((uint32_t)(*((const uint8_t *)(tptr) + 3)) << 0))))(ndo, "\n\t                 ")ISIS_SUBTLV_SPB_BVID_MIN_LEN(ndo, "\n\t           ECT: %08x", EXTRACT_32BITS(tptr))(ndo, "\n\t           ECT: %08x", ((uint32_t)(((uint32_t)(*((const uint8_t *)(tptr) + 0)) << 24) | ((uint32_t)(*((const uint8_t *)(tptr) + 1)) << 16) | ((uint32_t)(*((const uint8_t *)(tptr) + 2)) << 8) | ((uint32_t)(*((const uint8_t *)(tptr) + 3)) << 0))))(ndo, " BVID: %d, U:%01x M:%01x ", (EXTRACT_16BITS (tptr) >> 4) , (EXTRACT_16BITS (tptr) >> 3) & 0x01, (EXTRACT_16BITS (tptr) >> 2) & 0x01)(ndo, " BVID: %d, U:%01x M:%01x ", (((uint16_t)(((uint16_t)(*((const uint8_t *)(tptr) + 0)) << 8) | ((uint16_t)(*((const uint8_t *)(tptr) + 1)) << 0))) >> 4) , (((uint16_t)(((uint16_t)(*((const uint8_t *)(tptr) + 0)) << 8) | ((uint16_t)(*((const uint8_t *)(tptr) + 1)) << 0))) >> 3) & 0x01, (((uint16_t)(((uint16_t)(*((const uint8_t *)(tptr) + 0)) << 8) | ((uint16_t)(*((const uint8_t *)(tptr) + 1)) << 0))) >> 2) & 0x01)
	       %s subTLV #%u, length: %uISIS_SUBTLV_SPB_MCID
	         MCID: const isis_spb_mcidconst isis_spb_mcid *isis_spb_mcid *
	         AUX-MCID: sizeof(struct isis_subtlv_spb_mcid)ISIS_SUBTLV_SPB_DIGEST
	        RES: %d V: %d A: %d D: %d
	         Digest: %08x 
	                 ISIS_SUBTLV_SPB_BVID
	           ECT: %08x BVID: %d, U:%01x M:%01x isis_print_mcid(ndo, "ID: %d, Name: ", mcid->format_id)ID: %d, Name: (ndo, "%c", mcid->name[i])uint8_t[32]unsigned char[32](ndo, "\n\t              Lvl: %d", EXTRACT_16BITS(mcid->revision_lvl))(ndo, "\n\t              Lvl: %d", ((uint16_t)(((uint16_t)(*((const uint8_t *)(mcid->revision_lvl) + 0)) << 8) | ((uint16_t)(*((const uint8_t *)(mcid->revision_lvl) + 1)) << 0))))
	              Lvl: %dmcid->revision_lvl(ndo, ", Digest: "), Digest: (ndo, "%.2x ", mcid->digest[i])%.2x esis_printliesis_pdu_typesource_address_lengthsource_address_numberconst esis_header_tconst esis_header_t *esis_header_t *esis_header(ndo, "ES-IS")(ndo, ndo->ndo_qflag ? "bad pkt!" : "no header at all!")bad pkt!no header at all!*esis_headersizeof(*esis_header)(ndo, " nlpid 0x%02x packet not supported", esis_header->nlpid) nlpid 0x%02x packet not supported(ndo, " version %d packet not supported", esis_header->version)ESIS_VERSION version %d packet not supported(ndo, " length indicator(%d) > PDU size (%d)!", li, length) length indicator(%d) > PDU size (%d)!(ndo, " length indicator < min PDU size %d:", li)(ndo, "%02X", *pptr++)sizeof(struct esis_header_t)sizeof(struct esis_header_t) + 2 length indicator < min PDU size %d:%02XESIS_PDU_TYPE_MASK(ndo, "%s%s, length %u", ndo->ndo_eflag ? "" : ", ", tok2str(esis_pdu_values,"unknown type (%u)",esis_pdu_type), length)(ndo, "%slength %u\n\t%s (%u)", ndo->ndo_eflag ? "" : ", ", length, tok2str(esis_pdu_values,"unknown type: %u", esis_pdu_type), esis_pdu_type)%s%s, length %uunknown type (%u)%slength %u
	%s (%u)unknown type: %u(ndo, ", v: %u%s", esis_header->version, esis_header->version == ESIS_VERSION ? "" : "unsupported" )(ndo, ", v: %u%s", esis_header->version, esis_header->version == 1 ? "" : "unsupported" ), v: %u%smcidunsupported(ndo, ", checksum: 0x%04x", EXTRACT_16BITS(esis_header->cksum))(ndo, ", checksum: 0x%04x", ((uint16_t)(((uint16_t)(*((const uint8_t *)(esis_header->cksum) + 0)) << 8) | ((uint16_t)(*((const uint8_t *)(esis_header->cksum) + 1)) << 0)))), checksum: 0x%04xesis_header->cksum(ndo, ", holding time: %us, length indicator: %u", EXTRACT_16BITS(esis_header->holdtime), li)(ndo, ", holding time: %us, length indicator: %u", ((uint16_t)(((uint16_t)(*((const uint8_t *)(esis_header->holdtime) + 0)) << 8) | ((uint16_t)(*((const uint8_t *)(esis_header->holdtime) + 1)) << 0))), li), holding time: %us, length indicator: %uesis_header->holdtimesizeof(*pptr)(ndo, ", bad redirect/li")dstl(ndo, "\n\t  %s", isonsap_string(dst, dstl))snpalnetal(ndo, "\n\t  %s", etheraddr_string(ndo, snpa))(ndo, "\n\t  %s", isonsap_string(neta, netal))(ndo, ", bad esh/li")(ndo, "\n\t  Number of Source Addresses: %u", source_address_number)(ndo, "\n\t  NET (length: %u): %s", source_address_length, isonsap_string(pptr, source_address_length))(ndo, ", bad ish/li")ESIS_PDU_REDIRECTneta, bad redirect/li
	  %sESIS_PDU_ESH, bad esh/li
	  Number of Source Addresses: %u
	  NET (length: %u): %sESIS_PDU_ISH, bad ish/li(ndo, ", bad opts/li")(ndo, ", opt (%d) too long", op)(ndo, "\n\t  %s Option #%u, length %u, value: ", tok2str(esis_option_values,"Unknown",op), op, opli)(ndo, "%us", EXTRACT_16BITS(tptr))(ndo, "%us", ((uint16_t)(((uint16_t)(*((const uint8_t *)(tptr) + 0)) << 8) | ((uint16_t)(*((const uint8_t *)(tptr) + 1)) << 0))))(ndo, "(bad length)")opli, bad opts/li, opt (%d) too long
	  %s Option #%u, length %u, value: 198ESIS_OPTION_ES_CONF_TIME%us(bad length)ESIS_OPTION_PROTOCOLSESIS_OPTION_QOS_MAINTENANCE197ESIS_OPTION_SECURITY205ESIS_OPTION_PRIORITY225ESIS_OPTION_ADDRESS_MASK226ESIS_OPTION_SNPA_MASKclnp_printsource_addressdest_addressnsap_offsetdest_address_lengthclnp_pdu_typeclnp_flagsconst clnp_header_tconst clnp_header_t *clnp_header_t *clnp_headerconst clnp_segment_header_tconst clnp_segment_header_t *clnp_segment_header_t *clnp_segment_headerrfd_error_majorrfd_error_minor*clnp_headersizeof(*clnp_header)(ndo, "CLNP")(ndo, "version %d packet not supported", clnp_header->version)CLNP_VERSIONCLNP_PDU_TYPE_MASKCLNP_FLAG_MASKsizeof(struct clnp_header_t)(ndo, "%s%s > %s, %s, length %u", ndo->ndo_eflag ? "" : ", ", isonsap_string(source_address, source_address_length), isonsap_string(dest_address, dest_address_length), tok2str(clnp_pdu_values,"unknown (%u)",clnp_pdu_type), length)%s%s > %s, %s, length %u(ndo, "\n\t%s PDU, hlen: %u, v: %u, lifetime: %u.%us, Segment PDU length: %u, checksum: 0x%04x", tok2str(clnp_pdu_values, "unknown (%u)",clnp_pdu_type), clnp_header->length_indicator, clnp_header->version, clnp_header->lifetime/2, (clnp_header->lifetime%2)*5, EXTRACT_16BITS(clnp_header->segment_length), EXTRACT_16BITS(clnp_header->cksum))(ndo, "\n\t%s PDU, hlen: %u, v: %u, lifetime: %u.%us, Segment PDU length: %u, checksum: 0x%04x", tok2str(clnp_pdu_values, "unknown (%u)",clnp_pdu_type), clnp_header->length_indicator, clnp_header->version, clnp_header->lifetime/2, (clnp_header->lifetime%2)*5, ((uint16_t)(((uint16_t)(*((const uint8_t *)(clnp_header->segment_length) + 0)) << 8) | ((uint16_t)(*((const uint8_t *)(clnp_header->segment_length) + 1)) << 0))), ((uint16_t)(((uint16_t)(*((const uint8_t *)(clnp_header->cksum) + 0)) << 8) | ((uint16_t)(*((const uint8_t *)(clnp_header->cksum) + 1)) << 0))))
	%s PDU, hlen: %u, v: %u, lifetime: %u.%us, Segment PDU length: %u, checksum: 0x%04xclnp_header->segment_lengthclnp_header->cksum(ndo, "\n\tFlags [%s]", bittok2str(clnp_flag_values, "none", clnp_flags))
	Flags [%s](ndo, "\n\tsource address (length %u): %s\n\tdest   address (length %u): %s", source_address_length, isonsap_string(source_address, source_address_length), dest_address_length, isonsap_string(dest_address, dest_address_length))
	source address (length %u): %s
	dest   address (length %u): %s*clnp_segment_headersizeof(*clnp_segment_header)(ndo, "\n\tData Unit ID: 0x%04x, Segment Offset: %u, Total PDU Length: %u", EXTRACT_16BITS(clnp_segment_header->data_unit_id), EXTRACT_16BITS(clnp_segment_header->segment_offset), EXTRACT_16BITS(clnp_segment_header->total_length))(ndo, "\n\tData Unit ID: 0x%04x, Segment Offset: %u, Total PDU Length: %u", ((uint16_t)(((uint16_t)(*((const uint8_t *)(clnp_segment_header->data_unit_id) + 0)) << 8) | ((uint16_t)(*((const uint8_t *)(clnp_segment_header->data_unit_id) + 1)) << 0))), ((uint16_t)(((uint16_t)(*((const uint8_t *)(clnp_segment_header->segment_offset) + 0)) << 8) | ((uint16_t)(*((const uint8_t *)(clnp_segment_header->segment_offset) + 1)) << 0))), ((uint16_t)(((uint16_t)(*((const uint8_t *)(clnp_segment_header->total_length) + 0)) << 8) | ((uint16_t)(*((const uint8_t *)(clnp_segment_header->total_length) + 1)) << 0))))clnp_segment_header->data_unit_idclnp_segment_header->segment_offsetclnp_segment_header->total_lengthCLNP_SEGMENT_PART
	Data Unit ID: 0x%04x, Segment Offset: %u, Total PDU Length: %usizeof(const struct clnp_segment_header_t)(ndo, "\n\t  %s Option #%u, length %u, value: ", tok2str(clnp_option_values,"Unknown",op), op, opli)(ndo, "%s %s", tok2str(clnp_option_sr_rr_values,"Unknown",*tptr), tok2str(clnp_option_sr_rr_string_values, "Unknown Option %u", op))(ndo, " Bad NSAP offset (0)")(ndo, " Bad NSAP offset (past end of option)")(ndo, "\n\t    NSAP address goes past end of option")*source_address(ndo, "\n\t    NSAP address (length %u): %s", source_address_length, isonsap_string(source_address, source_address_length))(ndo, "0x%1x", *tptr&0x0f)(ndo, "\n\t    Format Code: %s", tok2str(clnp_option_scope_values, "Reserved", *tptr&CLNP_OPTION_SCOPE_MASK))(ndo, "\n\t    Format Code: %s", tok2str(clnp_option_scope_values, "Reserved", *tptr&0xc0))(ndo, "\n\t    QoS Flags [%s]", bittok2str(clnp_option_qos_global_values, "none", *tptr&CLNP_OPTION_OPTION_QOS_MASK))(ndo, "\n\t    QoS Flags [%s]", bittok2str(clnp_option_qos_global_values, "none", *tptr&0x3f))(ndo, "\n\t    Format Code: %s, Security-Level %u", tok2str(clnp_option_scope_values,"Reserved",*tptr&CLNP_OPTION_SCOPE_MASK), *(tptr+1))(ndo, "\n\t    Format Code: %s, Security-Level %u", tok2str(clnp_option_scope_values,"Reserved",*tptr&0xc0), *(tptr+1))(ndo, "\n\t    Class: %s Error (0x%01x), %s (0x%01x)", tok2str(clnp_option_rfd_class_values,"Unknown",rfd_error_major), rfd_error_major, tok2str(clnp_option_rfd_error_class[rfd_error_major],"Unknown",rfd_error_minor), rfd_error_minor)(ndo, "padding data")203CLNP_OPTION_ROUTE_RECORDINGCLNP_OPTION_SOURCE_ROUTING%s %sUnknown Option %u Bad NSAP offset (0) Bad NSAP offset (past end of option)
	    NSAP address goes past end of option
	    NSAP address (length %u): %sCLNP_OPTION_PRIORITY0x%1xCLNP_OPTION_QOS_MAINTENANCE
	    Format Code: %sCLNP_OPTION_SCOPE_MASKCLNP_OPTION_SCOPE_GLOBAL
	    QoS Flags [%s]CLNP_OPTION_SECURITY
	    Format Code: %s, Security-Level %uCLNP_OPTION_DISCARD_REASON
	    Class: %s Error (0x%01x), %s (0x%01x)CLNP_OPTION_PADDINGpadding data(ndo, "\n\t-----original packet-----\n\t")(ndo, "\n\t  undecoded non-header data, length %u", length-clnp_header->length_indicator)CLNP_PDU_ERCLNP_PDU_ERP
	-----original packet-----
	CLNP_PDU_DTCLNP_PDU_MDCLNP_PDU_ERQ
	  undecoded non-header data, length %u(ndo, "[|clnp]")[|clnp]isoclns_print(ndo, "|OSI")|OSI(ndo, "OSI NLPID %s (0x%02x): ", tok2str(nlpid_values, "Unknown", *p), *p)OSI NLPID %s (0x%02x): (ndo, "%slength: %u", ndo->ndo_eflag ? "" : ", ", length)(ndo, "OSI NLPID 0x%02x unknown", *p)%slength: %uOSI NLPID 0x%02x unknownesis_header_tclnp_segment_header_tclnp_header_tisis_tlv_lspisis_psnp_headerisis_csnp_headerisis_lsp_headerisis_iih_ptp_headerisis_iih_lan_headerisis_common_headerisis_tlv_ip_reachisis_tlv_es_reachisis_tlv_is_reachisis_tlv_ptp_adjisis_subtlv_spb_instanceisis_subtlv_spb_mcidisis_spb_mcidlength_indicatorsegment_offsetdata_unit_idsegment_lengthsequence_numberlsp_idremaining_lifetimeend_lsp_idstart_lsp_idtypeblockcircuit_idholding_timecircuit_typelan_idpdu_versionfixed_lenneighbor_sysidneighbor_nodeidmetric_errormetric_expensemetric_delaymetric_defaultneighbor_extd_local_circuit_idextd_local_circuit_idadjacency_stateno_of_treesspsourceidbridge_prioritycist_external_root_path_costcist_root_idaux_mciddigestrevision_lvlformat_idredirect"redirect"ESH"ESH"ISH"ISH"esis_pdu_valuesError Report"Error Report"Echo Request"Echo Request"Echo Response"Echo Response"clnp_pdu_valuesRestart Request"Restart Request"Restart Acknowledgement"Restart Acknowledgement"Suppress adjacency advertisement"Suppress adjacency advertisement"isis_restart_flag_valuesIsNotVirtual"IsNotVirtual"IsVirtual"IsVirtual"isis_is_reach_virtual_valuesISIS_PTP_ADJ_UPISIS_PTP_ADJ_INITInitializing"Initializing"ISIS_PTP_ADJ_DOWNisis_ptp_adjancey_valuesISIS_LSP_TYPE_UNUSED0Unused 0x0 (invalid)"Unused 0x0 (invalid)"ISIS_LSP_TYPE_LEVEL_1L1 IS"L1 IS"ISIS_LSP_TYPE_UNUSED2Unused 0x2 (invalid)"Unused 0x2 (invalid)"ISIS_LSP_TYPE_LEVEL_2L2 IS"L2 IS"isis_lsp_istype_valuesLevel 1 only"Level 1 only"Level 2 only"Level 2 only"Level 1, Level 2"Level 1, Level 2"isis_iih_circuit_type_valuesIPv4 unicast"IPv4 unicast"In-Band Management"In-Band Management"IPv6 unicast"IPv6 unicast"Development, Experimental or Proprietary"Development, Experimental or Proprietary"isis_mt_valuesATT bit set"ATT bit set"Overload bit set"Overload bit set"isis_mt_flag_valuesSegmentation permitted"Segmentation permitted"CLNP_MORE_SEGMENTSmore Segments"more Segments"CLNP_REQUEST_ERrequest Error Report"request Error Report"clnp_flag_valuesSPB Instance"SPB Instance"SPBM Service Identifier and Unicast Address"SPBM Service Identifier and Unicast Address"isis_mt_capability_subtlv_valuesSPB MCID"SPB MCID"SPB Digest"SPB Digest"SPB BVID"SPB BVID"isis_mt_port_cap_subtlv_valuesRouting-Domain Specific"Routing-Domain Specific"AS Number Tag"AS Number Tag"isis_subtlv_idrp_valuessimple text password"simple text password"Generic Crypto key-id"Generic Crypto key-id"HMAC-MD5 password"HMAC-MD5 password"Routing Domain private password"Routing Domain private password"isis_subtlv_auth_valuesLocal Protection Available"Local Protection Available"Link excluded from local protection path"Link excluded from local protection path"Local maintenance required"Local maintenance required"isis_subtlv_link_attribute_values32-Bit Administrative tag"32-Bit Administrative tag"64-Bit Administrative tag"64-Bit Administrative tag"Management Prefix Color"Management Prefix Color"isis_ext_ip_reach_subtlv_valuesAdministrative groups"Administrative groups"Link Local/Remote Identifier"Link Local/Remote Identifier"Link Remote Identifier"Link Remote Identifier"IPv4 interface address"IPv4 interface address"IPv4 neighbor address"IPv4 neighbor address"Maximum link bandwidth"Maximum link bandwidth"Reservable link bandwidth"Reservable link bandwidth"Unreserved bandwidth"Unreserved bandwidth"Traffic Engineering Metric"Traffic Engineering Metric"Link Attribute"Link Attribute"Link Protection Type"Link Protection Type"Interface Switching Capability"Interface Switching Capability"Bandwidth Constraints (old)"Bandwidth Constraints (old)"Bandwidth Constraints"Bandwidth Constraints"SPB Metric"SPB Metric"Reserved for cisco specific extensions"Reserved for cisco specific extensions"Reserved for future expansion"Reserved for future expansion"isis_ext_is_reach_subtlv_valuessequencing vs. delay"sequencing vs. delay"congested"congested"delay vs. cost"delay vs. cost"error vs. delay"error vs. delay"error vs. cost"error vs. cost"clnp_option_qos_global_valuessource routing"source routing"recording of route in progress"recording of route in progress"clnp_option_sr_rr_string_valuespartial"partial"complete"complete"clnp_option_sr_rr_valuesCLNP_OPTION_SCOPE_SA_SPECSource Address Specific"Source Address Specific"CLNP_OPTION_SCOPE_DA_SPECDestination Address Specific"Destination Address Specific"Globally unique"Globally unique"clnp_option_scope_valuesclnp_option_rfd_error_classReassembly interference"Reassembly interference"clnp_option_rfd_reassembly_valuesUnsupported option not specified"Unsupported option not specified"Unsupported protocol version"Unsupported protocol version"Unsupported security option"Unsupported security option"Unsupported source routeing option"Unsupported source routeing option"Unsupported recording of route option"Unsupported recording of route option"clnp_option_rfd_pdu_discard_valuesLifetime expired while data unit in transit"Lifetime expired while data unit in transit"Lifetime expired during reassembly"Lifetime expired during reassembly"clnp_option_rfd_lifetime_valuesUnspecified source routeing error"Unspecified source routeing error"Syntax error in source routeing field"Syntax error in source routeing field"Unknown address in source routeing field"Unknown address in source routeing field"Path not acceptable"Path not acceptable"clnp_option_rfd_source_routeing_valuesDestination address unreachable"Destination address unreachable"Destination address unknown"Destination address unknown"clnp_option_rfd_address_valuesReason not specified"Reason not specified"Protocol procedure error"Protocol procedure error"Incorrect checksum"Incorrect checksum"PDU discarded due to congestion"PDU discarded due to congestion"Header syntax error (cannot be parsed)"Header syntax error (cannot be parsed)"Segmentation needed but not permitted"Segmentation needed but not permitted"Incomplete PDU received"Incomplete PDU received"Duplicate option"Duplicate option"clnp_option_rfd_general_valuesGeneral"General"Source Routeing"Source Routeing"Lifetime"Lifetime"PDU Discarded"PDU Discarded"Reassembly"Reassembly"clnp_option_rfd_class_valuesDiscard Reason"Discard Reason"Priority"Priority"QoS Maintenance"QoS Maintenance"Security"Security"Source Routing"Source Routing"Route Recording"Route Recording"Padding"Padding"clnp_option_valuesProtocols supported"Protocols supported"ES Configuration Time"ES Configuration Time"Addressk Mask"Addressk Mask"SNPA Mask"SNPA Mask"esis_option_valuesArea address(es)"Area address(es)"IS Reachability"IS Reachability"ES Neighbor(s)"ES Neighbor(s)"Partition DIS"Partition DIS"Prefix Neighbors"Prefix Neighbors"IS Neighbor(s)"IS Neighbor(s)"IS Neighbor(s) (variable length)"IS Neighbor(s) (variable length)"LSP entries"LSP entries"Checksum"Checksum"LSP Buffersize"LSP Buffersize"Extended IS Reachability"Extended IS Reachability"IS Alias ID"IS Alias ID"DECnet Phase IV"DECnet Phase IV"Lucent Proprietary"Lucent Proprietary"IPv4 Internal Reachability"IPv4 Internal Reachability"IPv4 External Reachability"IPv4 External Reachability"Inter-Domain Information Type"Inter-Domain Information Type"IPv4 Interface address(es)"IPv4 Interface address(es)"IPv4 authentication (deprecated)"IPv4 authentication (deprecated)"Traffic Engineering Router ID"Traffic Engineering Router ID"Extended IPv4 Reachability"Extended IPv4 Reachability"Shared Risk Link Group"Shared Risk Link Group"Multi-Topology-Aware Port Capability"Multi-Topology-Aware Port Capability"Multi-Topology Capability"Multi-Topology Capability"Nortel Proprietary"Nortel Proprietary"Hostname"Hostname"Restart Signaling"Restart Signaling"Multi Topology IS Reachability"Multi Topology IS Reachability"Multi Topology"Multi Topology"232ISIS_TLV_IP6ADDRIPv6 Interface address(es)"IPv6 Interface address(es)"Multi-Topology IPv4 Reachability"Multi-Topology IPv4 Reachability"236ISIS_TLV_IP6_REACHIPv6 reachability"IPv6 reachability"237ISIS_TLV_MT_IP6_REACHMulti-Topology IP6 Reachability"Multi-Topology IP6 Reachability"Point-to-point Adjacency State"Point-to-point Adjacency State"Hello PDU Sequence Number"Hello PDU Sequence Number"Vendor Private"Vendor Private"isis_tlv_valuesL1 Lan IIH"L1 Lan IIH"L2 Lan IIH"L2 Lan IIH"p2p IIH"p2p IIH"L1 LSP"L1 LSP"L2 LSP"L2 LSP"L1 CSNP"L1 CSNP"L2 CSNP"L2 CSNP"L1 PSNP"L1 PSNP"L2 PSNP"L2 PSNP"isis_pdu_values(sizeof(struct isis_psnp_header))(sizeof(struct isis_csnp_header))(sizeof(struct isis_lsp_header))(sizeof(struct isis_iih_ptp_header))(sizeof(struct isis_iih_lan_header))(sizeof(struct isis_common_header))ISIS_MASK_TLV_SHARED_RISK_GROUP(x)((x)&0x1)ISIS_LSP_TLV_METRIC_VALUE(x)((x)&0x3f)ISIS_LSP_TLV_METRIC_UPDOWN(x)((x)&0x80)ISIS_LSP_TLV_METRIC_IE(x)((x)&0x40)ISIS_LSP_TLV_METRIC_SUPPORTED(x)ISIS_MASK_TLV_EXTD_IP6_SUBTLV(x)((x)&0x20)ISIS_MASK_TLV_EXTD_IP6_IE(x)ISIS_MASK_TLV_EXTD_IP_SUBTLV(x)ISIS_MASK_TLV_EXTD_IP_UPDOWN(x)ISIS_MASK_MTFLAGS(x)((x)&0xf000)ISIS_MASK_MTID(x)((x)&0x0fff)ISIS_MASK_LSP_ATT_DEFAULT_BIT(x)((x)&0x8)ISIS_MASK_LSP_ATT_DELAY_BIT(x)((x)&0x10)ISIS_MASK_LSP_ATT_EXPENSE_BIT(x)ISIS_MASK_LSP_ATT_ERROR_BIT(x)ISIS_MASK_LSP_ATT_BITS(x)((x)&0x78)ISIS_MASK_LSP_PARTITION_BIT(x)ISIS_MASK_LSP_ISTYPE_BITS(x)((x)&0x3)ISIS_MASK_LSP_OL_BIT(x)((x)&0x4)ISIS_SPB_MCID_LENCLNP_OPTION_OPTION_QOS_MASKISIS_LAN_PRIORITY_MASK0xE0ISIS_PDU_TYPE_MASKLSP_ID_LENSYSTEM_ID_LEN+2SYSTEM_ID_LEN+1/* do not attempt to verify the checksum if it is zero *//* hexdump the rest *//* check if enough byte for a full oui *//* check if four bytes are on the wire *//* read out prefix length in semioctets*//* fetch AS number *//* is there an additional sysid field present ?*//* is there anything other than the flags field? *//* first attempt to decode the flags *//* did something go wrong ? *//* length can only be a multiple of 2, otherwise there is
		   something broken -> so decode down until length is 1 *//* do not attempt to verify the checksum if it is zero
             * most likely a HMAC-MD5 TLV is also present and
             * to avoid conflicts the checksum TLV is zeroed.
             * see rfc3358 for details
             *//* further NPLIDs ? - put comma *//* those two TLVs share the same format *//* check if there is one byte left to read out the virtual flag *//* is it worth attempting a decode ? *//* LAN address length *//* min. TLV length *//* if this is the last area address do not attemt a boundary check *//* now check if we have a decoder otherwise do a hexdump at the end*//* something is malformed *//* first lets see if we know the TLVs name*//* copy temporary len & pointer to packet data *//*
     * Now print the TLV's.
     *//* do TLV decoding as long as it makes sense *//*
         * Clear checksum and lifetime prior to signature verification.
         *//* for optionally debugging the common header *//* provide the _o_riginal pointer *//* in non-verbose mode print the basic PDU Type plus PDU specific brief information*//* toss any non 6-byte sys-ID len PDUs *//* entirely useless *//* 1-8 are valid sys-ID lenghts *//* silly shit again *//* silly shit *//* initialize the _o_riginal pointer to the packet start -
                 need it for parsing the checksum TLV and authentication
                 TLV verification *//*
 * isis_print
 * Decode IS-IS packets.  Return 0 on error.
 *//* prepend the ident string *//* print out subTLV length *//* assume that one prefix can hold more
           than one subTLV - therefore the first byte must reflect
           the aggregate bytecount of the subTLVs for this prefix
        *//* copy as much as is stored in the TLV *//* clear the copy buffer *//* prefix has variable length encoding *//* somebody is fooling us *//* fetch status & prefix_len byte *//* fetch status byte *//* shared copy buffer for IPv4 prefixes *//* shared copy buffer for IPv4 and IPv6 prefixes *//*
 * this is the common extended IP reach decoder
 * it is called from TLVs (135,235,236,237)
 * we process the TLV and optional subTLVs and return
 * the amount of processed bytes
 *//*
 * this is the common Multi Topology ID decoder
 * it is called from various MT-TLVs (222,229,235,237)
 *//* read out subTLV length *//* and is therefore skipped *//* the Alias TLV Metric field is implicit 0 *//* how many bytes did we process ? *//*
 * this is the common IS-REACH decoder it is called
 * from various EXTD-IS REACH style TLVs (22,24,222)
 *//* there is some optional stuff left to decode but this is as of yet
                   not specified so just lets hexdump what is left *//* decode BCs until the subTLV ends *//* first lets see if we know the subTLVs name*//* int to float conversion buffer for several subTLVs *//*
 * this is the common IS-REACH subTLV decoder it is called
 * from isis_print_ext_is_reach()
 *//*
 * this is the common IP-REACH subTLV decoder it is called
 * from various EXTD-IP REACH TLVs (135,235,236,237)
 *//* everything is ok *//* print the 4-byte metric block which is common found in the old-style TLVs *//* shared routine for printing system, node and lsp-ids *//*tptr += SPB_MCID_MIN_LEN;
            len -= SPB_MCID_MIN_LEN; *//*len -= TLV_TYPE_LEN_OFFSET;*//*
                 * FIXME those are the defined Options that lack a decoder
                 * you are welcome to contribute code ;-)
                 *//* now walk the options *//*
         * Sanity checking of the header.
         *//* dump the PDU specific data *//* FIXME recursion protection *//* offset to nsap list *//* those two options share the format *//* FIXME further header sanity checking *//*
 * clnp_print
 * Decode CLNP packets.  Return 0 on error.
 *//* units of 500ms *//* enough bytes on the wire ? *//* Packet format version *//* 3 MSbits are reserved *//* Protocol version *//*
 * Katz's point to point adjacency TLV uses codes to tell us the state of
 * the remote adjacency.  Enumerate them.
 *//* rfc 5310 *//* draft-ietf-isis-wg-multi-topology-05 *//* draft-ietf-isis-admin-tags-01 *//* rfc6329 *//* rfc4124 *//* draft-ietf-isis-link-attr-01 *//* draft-ietf-isis-traffic-05 *//* draft-ietf-tewg-diff-te-proto-06 *//* array of 16 error-classes *//* iso8473 *//* iso9542 *//* draft-ietf-isis-experimental-tlv-01 *//* draft-shen-isis-iih-sequence-00 *//* rfc3373 *//* draft-ietf-isis-ipv6-02 *//* rfc3847 *//* rfc6165 *//* draft-ietf-isis-gmpls-extensions *//* rfc2763 *//* rfc1195 *//* rfc1195, rfc2966 *//* draft-ietf-isis-ext-lsp-frags-02 *//* iso10589 rev2 *//* rfc3358 *//* iso10589, rfc3567 *//* iso10589 *//*
 * A TLV is a tuple of a type, length and a value and is normally used for
 * encoding information in all sorts of places.  This is an enumeration of
 * the well known types.
 *
 * list taken from rfc3359 plus some memory from veterans ;-)
 *//*
 * IS-IS is defined in ISO 10589.  Look there for protocol definitions.
 *//*
 * Copyright (c) 1992, 1993, 1994, 1995, 1996
 *	The Regents of the University of California.  All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that: (1) source code distributions
 * retain the above copyright notice and this paragraph in its entirety, (2)
 * distributions including binary code include the above copyright notice and
 * this paragraph in its entirety in the documentation or other materials
 * provided with the distribution, and (3) all advertising materials mentioning
 * features or use of this software display the following acknowledgement:
 * ``This product includes software developed by the University of California,
 * Lawrence Berkeley Laboratory and its contributors.'' Neither the name of
 * the University nor the names of its contributors may be used to endorse
 * or promote products derived from this software without specific prior
 * written permission.
 * THIS SOFTWARE IS PROVIDED ``AS IS'' AND WITHOUT ANY EXPRESS OR IMPLIED
 * WARRANTIES, INCLUDING, WITHOUT LIMITATION, THE IMPLIED WARRANTIES OF
 * MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE.
 *
 * Original code by Matt Thomas, Digital Equipment Corporation
 *
 * Extensively modified by Hannes Gredler (hannes@juniper.net) for more
 * complete IS-IS & CLNP support.
 *//Users/owura/Repos/codeql_eval/proj_repos/the-tcpdump-group-tcpdump-commit-0f95d441e4b5d7512cc5c326c8668a120e048eda/tcpdump/ppp.hPPP_EAP0xc227PPP_SPAP_OLD0xc123PPP_MPCP0xc03dPPP_BAP0xc02dPPP_BACP0xc02bPPP_CHAP0xc223PPP_SPAP0xc027PPP_LQM0xc025PPP_PAP0xc023PPP_LCP0xc021PPP_MPLSCP0x8281PPP_CCP0x80fdPPP_IPV6CP0x8057PPP_VINESCPPPP_STIICP0x8033PPP_IPXCP0x802bPPP_APPLECP0x8029PPP_DECNETCP0x8027PPP_NSCP0x8025PPP_OSICP0x8023PPP_IPCP0x8021PPP_MPLS_MCAST0x0283PPP_MPLS_UCAST0x0281PPP_SNSPPP_LUXCOM0x0231PPP_HELLO0x0201PPP_COMP0x00fdPPP_IPV60x0057PPP_ML0x003dPPP_VINES0x0035PPP_STII0x0033PPP_BRPDU0x0031PPP_VJNC0x002fPPP_VJCPPP_IPX0x002bPPP_APPLEPPP_DECNETPPP_NS0x0025PPP_OSIPPP_IPPPP_WITHDIRECTION_OUTPPP_WITHDIRECTION_INPPP_CONTROLPPP_ADDRESSPPP_HDRLEN/* Multi-Link *//* BAP *//* Bandwidth Allocation Control Protocol *//* Challenge Handshake Authentication Protocol *//* Link Quality Monitoring *//* Password Authentication Protocol *//* Link Control Protocol *//* rfc 3022 *//* Compress Control Protocol *//* IPv6 Control Protocol *//* Banyan Vines Control Protocol *//* Strean Protocol Control Protocol *//* Novell IPX Control Protocol *//* Appletalk Control Protocol *//* DECnet Control Protocol *//* Xerox NS IDP Control Protocol *//* OSI Network Layer Control Protocol *//* IP Control Protocol *//* rfc 3032 *//* Sigma Network Systems *//* Luxcom *//* 802.1d Hello Packets *//* Compressed Datagram *//* Multi-Link PPP *//* Stream Protocol (ST-II) *//* Bridging PDU *//* Van Jacobson Uncompressed TCP/IP *//* Van Jacobson Compressed TCP/IP *//* DECnet Phase IV *//* Xerox NS IDP *//* OSI Network Layer *//* Raw IP *//* Protocol numbers *//* non-standard for DLT_PPP_WITHDIRECTION *//* The control byte value *//* The address byte value *//* length of PPP header *//*
 * Point to Point Protocol (PPP) RFC1331
 *
 * Copyright 1989 by Carnegie Mellon.
 *
 * Permission to use, copy, modify, and distribute this program for any
 * purpose and without fee is hereby granted, provided that this copyright
 * and permission notice appear on all copies and supporting documentation,
 * the name of Carnegie Mellon not be used in advertising or publicity
 * pertaining to distribution of the program without specific prior
 * permission, and notice be given in supporting documentation that copying
 * and distribution is by permission of Carnegie Mellon and Stanford
 * University.  Carnegie Mellon makes no representations about the
 * suitability of this software for any purpose.  It is provided "as is"
 * without express or implied warranty.
 *//Users/owura/Repos/codeql_eval/proj_repos/the-tcpdump-group-tcpdump-commit-0f95d441e4b5d7512cc5c326c8668a120e048eda/tcpdump/print-juniper.c"ppp.h"juniper_services_headerjuniper_monitor_headerjuniper_ipsec_headerjuniper_ggsn_headerjuniper_parse_headerjuniper_l2info_t *const juniper_cookie_table_tconst juniper_cookie_table_t *juniper_cookie_table_t *const juniper_cookie_table_t[12]juniper_cookie_table_t[12]jnx_ext_lenjnx_header_lencontrol_wordtlv_valueJUNIPER_BPF_PKT_IN(ndo, "no magic-number found!")5064515JUNIPER_MGC_NUMBERno magic-number found!(ndo, "%3s ", tok2str(juniper_direction_values, "---", l2info->direction))%3s ---(ndo, "\n\tJuniper PCAP Flags [%s]", bittok2str(jnx_flag_values, "none", l2info->flags))
	Juniper PCAP Flags [%s](ndo, ", PCAP Extension(s) total length %u", jnx_ext_len)(ndo, "\n\t  %s Extension TLV #%u, length %u, value ", tok2str(jnx_ext_tlv_values,"Unknown",tlv_type), tlv_type, tlv_len)(ndo, "%s (%u)", tok2str(juniper_ifmt_values, "Unknown", tlv_value), tlv_value)(ndo, "%s (%u)", tok2str(juniper_ifle_values, "Unknown", tlv_value), tlv_value)(ndo, "%u", tlv_value)JUNIPER_BPF_EXT, PCAP Extension(s) total length %uJUNIPER_EXT_TLV_OVERHEAD
	  %s Extension TLV #%u, length %u, value JUNIPER_EXT_TLV_IFD_NAMEJUNIPER_EXT_TLV_IFD_MEDIATYPEJUNIPER_EXT_TLV_TTP_IFD_MEDIATYPEconst tok[53]tok[53]JUNIPER_EXT_TLV_IFL_ENCAPSJUNIPER_EXT_TLV_TTP_IFL_ENCAPSJUNIPER_EXT_TLV_IFL_IDXJUNIPER_EXT_TLV_IFL_UNITJUNIPER_EXT_TLV_IFD_IDX(ndo, "no-L2-hdr, ")p[jnx_header_len + 4](ndo, "no IP-hdr found!")JUNIPER_BPF_NO_L2no-L2-hdr, no IP-hdr found!(ndo, "%s-PIC, cookie-len %u", lp->s, l2info->cookie_len)l2info->cookie_len(ndo, ", cookie 0x")(ndo, "%02x", p[idx])p+l2info->cookie_lenLS_COOKIE_IDAS_COOKIE_IDDLT_JUNIPER_MFRMFR_BE_MASK%s-PIC, cookie-len %ul2info, cookie 0x&l2info->cookie[6](ndo, "control-word 0x%08x ", control_word)(ndo, "Unknown Juniper DLT_ type %u: ", l2info->pictype)DLT_JUNIPER_MLPPP0xfffJUNIPER_LSQ_L3_PROTO_MASKDLT_JUNIPER_MLFRDLT_JUNIPER_ATM2ATM2_PKT_TYPE_MASK1342177280x080000001378877440x08380000control-word 0x%08x DLT_JUNIPER_GGSNDLT_JUNIPER_ATM1DLT_JUNIPER_PPPDLT_JUNIPER_CHDLCDLT_JUNIPER_ETHERDLT_JUNIPER_FRELAYUnknown Juniper DLT_ type %u: (ndo, "hlen %u, proto 0x%04x, ", l2info->header_len, l2info->proto)hlen %u, proto 0x%04x, (ndo, "[|juniper_hdr], length %u", h->len)[|juniper_hdr], length %ujuniper_read_tlv_valueip_heuristic_guess0x470x480x490x4a0x4c0x4f0x610x620x640x650x660x670x680x690x6a0x6b0x6d0x6ejuniper_ppp_heuristic_guess641643328013280333409491854918749699juniper_atm2_print0xfefe030xaaaa03l2info.cookieATM2_GAP_COUNT_MASKjuniper_atm1_printjuniper_mlfr_print(ndo, "Bundle-ID %u, ", l2info.bundle)Bundle-ID %u, (ndo, "unknown protocol 0x%04x, length %u", l2info.proto, l2info.length)(LLC_UI)(LLC_UI<<8)(LLC_UI<<8 | NLPID_Q933)972(LLC_UI<<8 | NLPID_IP)910(LLC_UI<<8 | NLPID_IP6)unknown protocol 0x%04x, length %ujuniper_mfr_printAS_PIC_COOKIE_LENJUNIPER_LSQ_L3_PROTO_IPV4JUNIPER_LSQ_L3_PROTO_IPV6JUNIPER_LSQ_L3_PROTO_MPLSJUNIPER_LSQ_L3_PROTO_ISOLLCSAP_ISONS<<8 | LLCSAP_ISONS(LLCSAP_ISONS<<8 | LLCSAP_ISONS)juniper_mlppp_print&l2info.cookie(ndo, "Bundle-ID %u: ", l2info.bundle)65283(PPP_ADDRESS << 8 | PPP_CONTROL)Bundle-ID %u: JUNIPER_LSQ_COOKIE_REJUNIPER_LSQ_COOKIE_DIR(JUNIPER_LSQ_COOKIE_RE|JUNIPER_LSQ_COOKIE_DIR)juniper_pppoe_atm_printDLT_JUNIPER_PPPOE_ATM(ndo, "unknown ethertype 0x%04x", extracted_ethertype)unknown ethertype 0x%04xjuniper_chdlc_printjuniper_frelay_printjuniper_ppp_printjuniper_ether_printjuniper_pppoe_printDLT_JUNIPER_PPPOEjuniper_services_printconst juniper_services_headerconst juniper_services_header *juniper_services_header *shDLT_JUNIPER_SERVICES(ndo, "service-id %u flags 0x%02x service-set-id 0x%04x iif %u: ", sh->svc_id, sh->flags_len, EXTRACT_16BITS(&sh->svc_set_id), EXTRACT_24BITS(&sh->dir_iif[1]))(ndo, "service-id %u flags 0x%02x service-set-id 0x%04x iif %u: ", sh->svc_id, sh->flags_len, ((uint16_t)(((uint16_t)(*((const uint8_t *)(&sh->svc_set_id) + 0)) << 8) | ((uint16_t)(*((const uint8_t *)(&sh->svc_set_id) + 1)) << 0))), ((uint32_t)(((uint32_t)(*((const uint8_t *)(&sh->dir_iif[1]) + 0)) << 16) | ((uint32_t)(*((const uint8_t *)(&sh->dir_iif[1]) + 1)) << 8) | ((uint32_t)(*((const uint8_t *)(&sh->dir_iif[1]) + 2)) << 0))))&sh->svc_set_id&sh->dir_iif[1]service-id %u flags 0x%02x service-set-id 0x%04x iif %u: char[58]juniper_monitor_printconst juniper_monitor_headerconst juniper_monitor_header *juniper_monitor_header *mhDLT_JUNIPER_MONITOR(ndo, "service-id %u, iif %u, pkt-type %u: ", EXTRACT_32BITS(&mh->service_id), EXTRACT_16BITS(&mh->iif), mh->pkt_type)(ndo, "service-id %u, iif %u, pkt-type %u: ", ((uint32_t)(((uint32_t)(*((const uint8_t *)(&mh->service_id) + 0)) << 24) | ((uint32_t)(*((const uint8_t *)(&mh->service_id) + 1)) << 16) | ((uint32_t)(*((const uint8_t *)(&mh->service_id) + 2)) << 8) | ((uint32_t)(*((const uint8_t *)(&mh->service_id) + 3)) << 0))), ((uint16_t)(((uint16_t)(*((const uint8_t *)(&mh->iif) + 0)) << 8) | ((uint16_t)(*((const uint8_t *)(&mh->iif) + 1)) << 0))), mh->pkt_type)&mh->service_id&mh->iifservice-id %u, iif %u, pkt-type %u: juniper_es_printrewrite_lenes_type_bundleconst juniper_ipsec_headerconst juniper_ipsec_header *juniper_ipsec_header *ihDLT_JUNIPER_ES(ndo, "ES Invalid type %u, length %u", ih->type, l2info.length)JUNIPER_IPSEC_O_ESP_ENCRYPT_ESP_AUTHEN_TYPEJUNIPER_IPSEC_O_ESP_ENCRYPT_AH_AUTHEN_TYPEJUNIPER_IPSEC_O_ESP_AUTHENTICATION_TYPEJUNIPER_IPSEC_O_AH_AUTHENTICATION_TYPEJUNIPER_IPSEC_O_ESP_ENCRYPTION_TYPEES Invalid type %u, length %u(ndo, "ES SA, index %u, ttl %u type %s (%u), spi %u, Tunnel %s > %s, length %u\n", EXTRACT_16BITS(&ih->sa_index), ih->ttl, tok2str(juniper_ipsec_type_values,"Unknown",ih->type), ih->type, EXTRACT_32BITS(&ih->spi), ipaddr_string(ndo, &ih->src_ip), ipaddr_string(ndo, &ih->dst_ip), l2info.length)(ndo, "ES SA, index %u, ttl %u type %s (%u), spi %u, Tunnel %s > %s, length %u\n", ((uint16_t)(((uint16_t)(*((const uint8_t *)(&ih->sa_index) + 0)) << 8) | ((uint16_t)(*((const uint8_t *)(&ih->sa_index) + 1)) << 0))), ih->ttl, tok2str(juniper_ipsec_type_values,"Unknown",ih->type), ih->type, ((uint32_t)(((uint32_t)(*((const uint8_t *)(&ih->spi) + 0)) << 24) | ((uint32_t)(*((const uint8_t *)(&ih->spi) + 1)) << 16) | ((uint32_t)(*((const uint8_t *)(&ih->spi) + 2)) << 8) | ((uint32_t)(*((const uint8_t *)(&ih->spi) + 3)) << 0))), getname(ndo, (const u_char *)(&ih->src_ip)), getname(ndo, (const u_char *)(&ih->dst_ip)), l2info.length)&ih->sa_index&ih->spi&ih->src_ip&ih->dst_ip(ndo, "ES SA, index %u, ttl %u type %s (%u), length %u\n", EXTRACT_16BITS(&ih->sa_index), ih->ttl, tok2str(juniper_ipsec_type_values,"Unknown",ih->type), ih->type, l2info.length)(ndo, "ES SA, index %u, ttl %u type %s (%u), length %u\n", ((uint16_t)(((uint16_t)(*((const uint8_t *)(&ih->sa_index) + 0)) << 8) | ((uint16_t)(*((const uint8_t *)(&ih->sa_index) + 1)) << 0))), ih->ttl, tok2str(juniper_ipsec_type_values,"Unknown",ih->type), ih->type, l2info.length)ES SA, index %u, ttl %u type %s (%u), spi %u, Tunnel %s > %s, length %u
ES SA, index %u, ttl %u type %s (%u), length %u
juniper_ggsn_printconst juniper_ggsn_headerconst juniper_ggsn_header *juniper_ggsn_header *gh(ndo, "proto %s (%u), vlan %u: ", tok2str(juniper_protocol_values,"Unknown",gh->proto), gh->proto, EXTRACT_16BITS(&gh->vlan_id[0]))(ndo, "proto %s (%u), vlan %u: ", tok2str(juniper_protocol_values,"Unknown",gh->proto), gh->proto, ((uint16_t)(((uint16_t)(*((const uint8_t *)(&gh->vlan_id[0]) + 0)) << 8) | ((uint16_t)(*((const uint8_t *)(&gh->vlan_id[0]) + 1)) << 0))))&gh->vlan_id[0]proto %s (%u), vlan %u: (ndo, "unknown GGSN proto (%u)", gh->proto)JUNIPER_PROTO_IPV4JUNIPER_PROTO_IPV6unknown GGSN proto (%u)juniper_l2info_tjuniper_cookie_table_tdir_iifsvc_set_idflags_lensvc_idservice_idiifpaddingpkt_typedst_ipsrc_ipsa_indexvlan_idbundlecookie_typecookie_lenheader_lenpictypeJUNIPER_PROTO_NULLNull"Null"juniper_protocol_valuesconst juniper_cookie_table_t[]juniper_cookie_table_t[]ATM1"ATM1"ATM2"ATM2"MLPPP"MLPPP"MLFR"MLFR"MFR"MFR"PPPoE"PPPoE"PPPoE ATM"PPPoE ATM"GGSN"GGSN"MONITOR"MONITOR"AS"AS"ES"ES"juniper_cookie_tableJUNIPER_IFLE_AGGREGATORJUNIPER_IFLE_ATM_CCCCCC over ATM"CCC over ATM"JUNIPER_IFLE_ATM_CELLRELAY_CCCATM CCC Cell Relay"ATM CCC Cell Relay"JUNIPER_IFLE_ATM_CISCO_NLPIDCISCO compatible NLPID"CISCO compatible NLPID"JUNIPER_IFLE_ATM_EOA_CCCEthernet over ATM CCC"Ethernet over ATM CCC"JUNIPER_IFLE_ATM_EOA_LLCEthernet over ATM LLC"Ethernet over ATM LLC"JUNIPER_IFLE_ATM_ETHER_VPLS_ATM_LLCEthernet VPLS over ATM LLC"Ethernet VPLS over ATM LLC"JUNIPER_IFLE_ATM_LLCATM LLC"ATM LLC"JUNIPER_IFLE_ATM_MLPPP_LLCMLPPP over ATM LLC"MLPPP over ATM LLC"JUNIPER_IFLE_ATM_NLPIDATM NLPID"ATM NLPID"JUNIPER_IFLE_ATM_PPPOE_LLCPPPoE over ATM LLC"PPPoE over ATM LLC"JUNIPER_IFLE_ATM_PPP_FUNIPPP over FUNI"PPP over FUNI"JUNIPER_IFLE_ATM_PPP_LLCPPP over ATM LLC"PPP over ATM LLC"JUNIPER_IFLE_ATM_PPP_VCMUXPPP over ATM VCMUX"PPP over ATM VCMUX"JUNIPER_IFLE_ATM_SNAPATM SNAP"ATM SNAP"JUNIPER_IFLE_ATM_SNAP_TCCATM SNAP TCC"ATM SNAP TCC"JUNIPER_IFLE_ATM_TCCATM VCMUX TCC"ATM VCMUX TCC"JUNIPER_IFLE_ATM_VCMUXATM VCMUX"ATM VCMUX"JUNIPER_IFLE_CISCOHDLCC-HDLC"C-HDLC"JUNIPER_IFLE_CISCOHDLC_CCCC-HDLC CCC"C-HDLC CCC"JUNIPER_IFLE_CISCOHDLC_SUBORDINATEC-HDLC via dialer"C-HDLC via dialer"JUNIPER_IFLE_CISCOHDLC_TCCC-HDLC TCC"C-HDLC TCC"JUNIPER_IFLE_COLLECTORCollector"Collector"JUNIPER_IFLE_CRYPTOCrypto"Crypto"JUNIPER_IFLE_ENET2JUNIPER_IFLE_ETHERNET_CCCEthernet CCC"Ethernet CCC"JUNIPER_IFLE_ETHERNET_EXTENDED_VLAN_VPLSExtended VLAN VPLS"Extended VLAN VPLS"JUNIPER_IFLE_ETHERNET_PPPOEPPPoE over Ethernet"PPPoE over Ethernet"JUNIPER_IFLE_ETHERNET_TCCEthernet TCC"Ethernet TCC"JUNIPER_IFLE_ETHERNET_VLAN_VPLSVLAN VPLS"VLAN VPLS"JUNIPER_IFLE_ETHERNET_VPLSJUNIPER_IFLE_EXTENDED_VLAN_CCCExtended VLAN CCC"Extended VLAN CCC"JUNIPER_IFLE_EXTENDED_VLAN_TCCExtended VLAN TCC"Extended VLAN TCC"JUNIPER_IFLE_FR_CCCFR CCC"FR CCC"JUNIPER_IFLE_FR_NLPIDFR NLPID"FR NLPID"JUNIPER_IFLE_FR_PORT_CCCJUNIPER_IFLE_FR_PPPFR PPP"FR PPP"JUNIPER_IFLE_FR_SNAPFR SNAP"FR SNAP"JUNIPER_IFLE_FR_TCCFR TCC"FR TCC"JUNIPER_IFLE_GGSNJUNIPER_IFLE_GRE_NULLGRE NULL"GRE NULL"JUNIPER_IFLE_GRE_PPPPPP over GRE"PPP over GRE"JUNIPER_IFLE_IPIP_NULLJUNIPER_IFLE_LAPDLAPD"LAPD"JUNIPER_IFLE_LSI_NULLLSI Null"LSI Null"JUNIPER_IFLE_LT_VLANLT VLAN"LT VLAN"JUNIPER_IFLE_MFRJUNIPER_IFLE_MLFRJUNIPER_IFLE_MLPPPJUNIPER_IFLE_MONITORMonitor"Monitor"JUNIPER_IFLE_PIMD_DECAPSPIMd"PIMd"JUNIPER_IFLE_PIM_NULLPIM Null"PIM Null"JUNIPER_IFLE_PPPJUNIPER_IFLE_PPPOEJUNIPER_IFLE_PPP_CCCPPP CCC"PPP CCC"JUNIPER_IFLE_PPP_SUBORDINATEJUNIPER_IFLE_PPP_TCCPPP TCC"PPP TCC"JUNIPER_IFLE_SERVICESGeneral Services"General Services"JUNIPER_IFLE_VLAN_CCCVLAN CCC"VLAN CCC"JUNIPER_IFLE_VLAN_TCCVLAN TCC"VLAN TCC"JUNIPER_IFLE_VTVT"VT"juniper_ifle_valuesJUNIPER_IFML_ETHERJUNIPER_IFML_FDDIJUNIPER_IFML_TOKENRINGToken-Ring"Token-Ring"JUNIPER_IFML_PPPJUNIPER_IFML_PPP_SUBORDINATEPPP-Subordinate"PPP-Subordinate"JUNIPER_IFML_FRAMERELAYFrame-Relay"Frame-Relay"JUNIPER_IFML_CISCOHDLCJUNIPER_IFML_SMDSDXISMDS-DXI"SMDS-DXI"JUNIPER_IFML_ATMPVCATM-PVC"ATM-PVC"JUNIPER_IFML_PPP_CCCPPP-CCC"PPP-CCC"JUNIPER_IFML_FRAMERELAY_CCCFrame-Relay-CCC"Frame-Relay-CCC"JUNIPER_IFML_FRAMERELAY_EXT_CCCExtended FR-CCC"Extended FR-CCC"JUNIPER_IFML_IPIPIP-over-IP"IP-over-IP"JUNIPER_IFML_GREJUNIPER_IFML_PIMPIM-Encapsulator"PIM-Encapsulator"JUNIPER_IFML_PIMDPIM-Decapsulator"PIM-Decapsulator"JUNIPER_IFML_CISCOHDLC_CCCCisco-HDLC-CCC"Cisco-HDLC-CCC"JUNIPER_IFML_VLAN_CCCVLAN-CCC"VLAN-CCC"JUNIPER_IFML_EXTENDED_VLAN_CCCExtended-VLAN-CCC"Extended-VLAN-CCC"JUNIPER_IFML_MLPPPMultilink-PPP"Multilink-PPP"JUNIPER_IFML_MLFRMultilink-FR"Multilink-FR"JUNIPER_IFML_MFRMultilink-FR-UNI-NNI"Multilink-FR-UNI-NNI"JUNIPER_IFML_MLMultilink"Multilink"JUNIPER_IFML_LSLinkService"LinkService"JUNIPER_IFML_LSILSI"LSI"JUNIPER_IFML_ATM_CELLRELAY_CCCATM-CCC-Cell-Relay"ATM-CCC-Cell-Relay"JUNIPER_IFML_CRYPTOIPSEC-over-IP"IPSEC-over-IP"JUNIPER_IFML_GGSNJUNIPER_IFML_PPP_TCCPPP-TCC"PPP-TCC"JUNIPER_IFML_FRAMERELAY_TCCFrame-Relay-TCC"Frame-Relay-TCC"JUNIPER_IFML_FRAMERELAY_EXT_TCCExtended FR-TCC"Extended FR-TCC"JUNIPER_IFML_CISCOHDLC_TCCCisco-HDLC-TCC"Cisco-HDLC-TCC"JUNIPER_IFML_ETHERNET_CCCEthernet-CCC"Ethernet-CCC"JUNIPER_IFML_VTVPN-Loopback-tunnel"VPN-Loopback-tunnel"JUNIPER_IFML_ETHER_OVER_ATMEthernet-over-ATM"Ethernet-over-ATM"JUNIPER_IFML_ETHER_VPLS_OVER_ATMEthernet-VPLS-over-ATM"Ethernet-VPLS-over-ATM"JUNIPER_IFML_MONITORJUNIPER_IFML_ETHERNET_TCCEthernet-TCC"Ethernet-TCC"JUNIPER_IFML_VLAN_TCCVLAN-TCC"VLAN-TCC"JUNIPER_IFML_EXTENDED_VLAN_TCCExtended-VLAN-TCC"Extended-VLAN-TCC"JUNIPER_IFML_CONTROLLERController"Controller"JUNIPER_IFML_ETHERNET_VPLSJUNIPER_IFML_ETHERNET_VLAN_VPLSVLAN-VPLS"VLAN-VPLS"JUNIPER_IFML_ETHERNET_EXTENDED_VLAN_VPLSExtended-VLAN-VPLS"Extended-VLAN-VPLS"JUNIPER_IFML_LTLogical-tunnel"Logical-tunnel"JUNIPER_IFML_SERVICESGeneral-Services"General-Services"JUNIPER_IFML_PPPOEJUNIPER_IFML_ETHERNET_FLEXFlexible-Ethernet-Services"Flexible-Ethernet-Services"JUNIPER_IFML_FRAMERELAY_FLEXFlexible-FrameRelay"Flexible-FrameRelay"JUNIPER_IFML_COLLECTORFlow-collection"Flow-collection"JUNIPER_IFML_PICPEERPIC Peer"PIC Peer"JUNIPER_IFML_DFCDynamic-Flow-Capture"Dynamic-Flow-Capture"juniper_ifmt_valuesExt"Ext"JUNIPER_BPF_FILTERFilter"Filter"JUNIPER_BPF_IIFIIF"IIF"no-L2"no-L2"In"In"jnx_flag_valuesDevice Interface Index"Device Interface Index"Device Interface Name"Device Interface Name"Device Media Type"Device Media Type"Logical Interface Index"Logical Interface Index"Logical Unit Number"Logical Unit Number"Logical Interface Encapsulation"Logical Interface Encapsulation"TTP derived Device Media Type"TTP derived Device Media Type"TTP derived Logical Interface Encapsulation"TTP derived Logical Interface Encapsulation"jnx_ext_tlv_valuesJUNIPER_BPF_INJUNIPER_BPF_OUTOut"Out"juniper_direction_valuesESP ENCR-AUTH"ESP ENCR-AUTH"ESP ENCR-AH AUTH"ESP ENCR-AH AUTH"ESP AUTH"ESP AUTH"AH AUTH"AH AUTH"ESP ENCR"ESP ENCR"juniper_ipsec_type_valuesATM2_COOKIE_LENATM1_COOKIE_LENLS_MFR_COOKIE_LENML_MLFR_COOKIE_LENLS_MLFR_COOKIE_LENJUNIPER_IFLE_PICPEERJUNIPER_IFLE_DFCJUNIPER_IFLE_AGGREGATE_UNUSEDJUNIPER_IFLE_IEEE8023_LLCJUNIPER_IFLE_IEEE8023_SNAPJUNIPER_IFML_CISCOHDLC_SUBORDINATEJUNIPER_IFML_LAPDJUNIPER_IFML_AGGREGATORJUNIPER_IFML_GGSNIJUNIPER_IFML_FR_PORT_CCCJUNIPER_IFML_LSI_CISCOHDLCJUNIPER_IFML_LSI_PPPJUNIPER_IFML_DFE(3 << JUNIPER_LSQ_L3_PROTO_SHIFT)(2 << JUNIPER_LSQ_L3_PROTO_SHIFT)(1 << JUNIPER_LSQ_L3_PROTO_SHIFT)(0 << JUNIPER_LSQ_L3_PROTO_SHIFT)(0x17 << JUNIPER_LSQ_L3_PROTO_SHIFT)JUNIPER_LSQ_L3_PROTO_SHIFT(1 << 2)0x4d4743/* everything went ok so far. continue parsing *//* cntl word plus cell length (56) >= JUNOS 7.4*//* < JUNOS 7.4 control-word *//* zero control word *//* some control word heuristics *//* ATM cell relay control word present ? *//* DLT_ specific parsing *//* print demarc b/w L2/L3*//* copy cookie data *//* MFR child links don't carry cookies *//* search through the cookie table and copy values matching for our PIC type *//* stop parsing the output further *//* there is no link-layer present -
         * perform the v4/v6 heuristics
         * to figure out what it is
         *//* nail up the total length -
         * just in case something goes wrong
         * with TLV parsing *//* ok to read extension length ? *//* extensions present ?  - calculate how much bytes to skip *//* magic number + flags *//* print direction *//* magic number found ? *//* TLVs >= 128 are big endian encoded *//* TLVs < 128 are little endian encoded *//* we printed an v4/v6 packet *//* did not find a ip header *//* we printed a ppp packet *//* did not find a ppp header *//* try to guess, based on all PPP protos that are supported in
 * a juniper router if the payload data is encapsulated using PPP *//* last try - vcmux encaps ? *//* PPPoA vcmux encaps ? *//* FIXME check if frame was recognized *//* Cisco style NLPID encaps ? *//* ether-over-1483 encaps ? *//* SNAP encaps ? *//* NLPID encaps ? *//* OAM cell ? *//*
 *     ATM2 PIC cookie format
 *
 *     +-------------------------------+---------+---+-----+-----------+
 *     |     channel ID                |  reserv |AAL| CCRQ| gap cnt   |
 *     +-------------------------------+---------+---+-----+-----------+
 *//*
 *     ATM1 PIC cookie format
 *
 *     +-----+-------------------------+-------------------------------+
 *     |fmtid|     vc index            |  channel  ID                  |
 *     +-----+-------------------------+-------------------------------+
 *//* pass IP{4,6} to the OSI layer for proper link-layer printing *//* suppress Bundle-ID if frame was captured on a child-link *//* first try the LSQ protos *//* child-link ? *//* zero length cookie ? *//* IP traffic going to the RE would not have a cookie
             * -> this must be incoming IS-IS over PPP
             *//* suppress Bundle-ID if frame was captured on a child-link
         * best indicator if the cookie looks like a proto *//* this DLT contains nothing but raw PPPoE frames,
         * prepended with a type field*//* this DLT contains nothing but raw c-hdlc frames *//* this DLT contains nothing but raw frame-relay frames *//* this DLT contains nothing but raw ppp frames *//* this DLT contains nothing but raw Ethernet frames *//* this DLT contains nothing but raw ethernet frames *//* no proto field - lets guess by first byte of IP header*//* pic name *//* cookie len *//* pic type *//* 1 byte type and 1-byte length *//* codepoints for encoding extensions to a .pcap file *//* = "MGC" *//* extensions present *//* BPF filtering is supported *//* IIF is valid *//* L2 header stripped *//* Incoming packet *//* Outgoing packet *//*     NetBSD: print-juniper.c,v 1.2 2007/07/24 11:53:45 drochner Exp        *//Users/owura/Repos/codeql_eval/proj_repos/the-tcpdump-group-tcpdump-commit-0f95d441e4b5d7512cc5c326c8668a120e048eda/tcpdump/print-krb.ckrb_printconst krbconst krb *krb *kpconst char[13](ndo, " v%d", kp->pvno)(ndo, " v5") v%d v5krb4_print0xFF5100xFF << 1(0xFF << 1)(ndo, " %s %s: ", IS_LENDIAN(kp) ? "le" : "be", tok2str(type2str, NULL, type))(ndo, " %s %s: ", (((kp)->type & 0x01) != 0) ? "le" : "be", tok2str(type2str, ((void *)0), type)) %s %s: lebe(ndo, " %dmin ", *cp++ * 5)(ndo, "v%d ", *cp++)(ndo, " (%d)", *cp++)(ndo, " (%d)", *cp)(ndo, " (%d)", len)(ndo, " %s ", tok2str(kerr2str, NULL, KTOHSP(kp, cp)))(ndo, " %s ", tok2str(kerr2str, ((void *)0), ((((kp)->type & 0x01) != 0) ? ((uint16_t)(((uint16_t)(*((const uint8_t *)(cp) + 1)) << 8) | ((uint16_t)(*((const uint8_t *)(cp) + 0)) << 0))) : ((uint16_t)(((uint16_t)(*((const uint8_t *)(cp) + 0)) << 8) | ((uint16_t)(*((const uint8_t *)(cp) + 1)) << 0))))))(ndo, "(unknown)")AUTH_MSG_KDC_REQUEST %dmin AUTH_MSG_APPL_REQUESTv%d AUTH_MSG_KDC_REPLYAUTH_MSG_ERR_REPLY %s (unknown)krb4_print_hdrc_print(ndo, "M-")(ndo, "^")(ndo, "%c", c)M-^krbpvnoKERB_ERR_OKOK"OK"KERB_ERR_NAME_EXPNAME_EXP"NAME_EXP"KERB_ERR_SERVICE_EXPSERVICE_EXP"SERVICE_EXP"KERB_ERR_AUTH_EXPAUTH_EXP"AUTH_EXP"KERB_ERR_PKT_VERPKT_VER"PKT_VER"KERB_ERR_NAME_MAST_KEY_VERNAME_MAST_KEY_VER"NAME_MAST_KEY_VER"KERB_ERR_SERV_MAST_KEY_VERSERV_MAST_KEY_VER"SERV_MAST_KEY_VER"KERB_ERR_BYTE_ORDERBYTE_ORDER"BYTE_ORDER"KERB_ERR_PRINCIPAL_UNKNOWNPRINCIPAL_UNKNOWN"PRINCIPAL_UNKNOWN"KERB_ERR_PRINCIPAL_NOT_UNIQUEPRINCIPAL_NOT_UNIQUE"PRINCIPAL_NOT_UNIQUE"KERB_ERR_NULL_KEYNULL_KEY"NULL_KEY"kerr2strKDC_REQUEST"KDC_REQUEST"KDC_REPLY"KDC_REPLY"APPL_REQUEST"APPL_REQUEST"AUTH_MSG_APPL_REQUEST_MUTUALAPPL_REQUEST_MUTUAL"APPL_REQUEST_MUTUAL"ERR_REPLY"ERR_REPLY"AUTH_MSG_PRIVATEPRIVATE"PRIVATE"AUTH_MSG_SAFESAFE"SAFE"AUTH_MSG_APPL_ERRAPPL_ERR"APPL_ERR"AUTH_MSG_DIEDIE"DIE" [|kerberos]" [|kerberos]"KTOHSP(kp,cp)(IS_LENDIAN(kp) ? EXTRACT_LE_16BITS(cp) : EXTRACT_16BITS(cp))IS_LENDIAN(kp)(((kp)->type & 0x01) != 0)PRINTif ((cp = c_print(ndo, cp, ndo->ndo_snapend)) == NULL) goto trunc63<<18<<17<<16<<15<<14<<13<<12<<11<<1/* Decode ASN.1 here "someday" *//* timestamp + n + exp + kvno *//* ctime *//*  True if struct krb is little endian *//* DEL to ?, others to alpha *//* Type+B *//* Protocol Version *//*
 * Copyright (c) 1995, 1996, 1997
 *	The Regents of the University of California.  All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that: (1) source code distributions
 * retain the above copyright notice and this paragraph in its entirety, (2)
 * distributions including binary code include the above copyright notice and
 * this paragraph in its entirety in the documentation or other materials
 * provided with the distribution, and (3) all advertising materials mentioning
 * features or use of this software display the following acknowledgement:
 * ``This product includes software developed by the University of California,
 * Lawrence Berkeley Laboratory and its contributors.'' Neither the name of
 * the University nor the names of its contributors may be used to endorse
 * or promote products derived from this software without specific prior
 * written permission.
 * THIS SOFTWARE IS PROVIDED ``AS IS'' AND WITHOUT ANY EXPRESS OR IMPLIED
 * WARRANTIES, INCLUDING, WITHOUT LIMITATION, THE IMPLIED WARRANTIES OF
 * MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE.
 *
 * Initial contribution from John Hawkinson (jhawk@mit.edu).
 *//Users/owura/Repos/codeql_eval/proj_repos/the-tcpdump-group-tcpdump-commit-0f95d441e4b5d7512cc5c326c8668a120e048eda/tcpdump/print-l2tp.cl2tp_printcntflag_tflag_lflag_sflag_ol2tp_len*ptr(ndo, " l2tp:")(ndo, " l2f:")(ndo, " Unknown Version, neither L2F(1) nor L2TP(2)")L2TP_VERSION_MASKL2TP_VERSION_L2TP l2tp:L2TP_VERSION_L2F l2f: Unknown Version, neither L2F(1) nor L2TP(2)(ndo, "[")[(ndo, "T")L2TP_FLAG_TYPE(ndo, "L")L2TP_FLAG_LENGTHL(ndo, "S")L2TP_FLAG_SEQUENCE(ndo, "O")L2TP_FLAG_OFFSET(ndo, "P")L2TP_FLAG_PRIORITY(ndo, "(%u/", EXTRACT_16BITS(ptr))(ndo, "(%u/", ((uint16_t)(((uint16_t)(*((const uint8_t *)(ptr) + 0)) << 8) | ((uint16_t)(*((const uint8_t *)(ptr) + 1)) << 0))))(%u/(ndo, "%u)", EXTRACT_16BITS(ptr))(ndo, "%u)", ((uint16_t)(((uint16_t)(*((const uint8_t *)(ptr) + 0)) << 8) | ((uint16_t)(*((const uint8_t *)(ptr) + 1)) << 0))))%u)(ndo, "Ns=%u,", EXTRACT_16BITS(ptr))(ndo, "Ns=%u,", ((uint16_t)(((uint16_t)(*((const uint8_t *)(ptr) + 0)) << 8) | ((uint16_t)(*((const uint8_t *)(ptr) + 1)) << 0))))(ndo, "Nr=%u", EXTRACT_16BITS(ptr))(ndo, "Nr=%u", ((uint16_t)(((uint16_t)(*((const uint8_t *)(ptr) + 0)) << 8) | ((uint16_t)(*((const uint8_t *)(ptr) + 1)) << 0))))Ns=%u,Nr=%u(ndo, " Length %u larger than packet", l2tp_len) Length %u larger than packet(ndo, " Length %u smaller than header length", length) Length %u smaller than header length(ndo, " No length")(ndo, " ZLB") No length ZLBl2tp_avp_printattr_typehidden FALSEsizeof(*ptr)L2TP_AVP_HDR_LEN_MASK(ndo, "*")L2TP_AVP_HDR_FLAG_MANDATORY(ndo, "?")L2TP_AVP_HDR_FLAG_HIDDEN(ndo, "VENDOR%04x:", EXTRACT_16BITS(ptr))(ndo, "VENDOR%04x:", ((uint16_t)(((uint16_t)(*((const uint8_t *)(ptr) + 0)) << 8) | ((uint16_t)(*((const uint8_t *)(ptr) + 1)) << 0))))(ndo, "ATTR%04x", EXTRACT_16BITS(ptr))(ndo, "ATTR%04x", ((uint16_t)(((uint16_t)(*((const uint8_t *)(ptr) + 0)) << 8) | ((uint16_t)(*((const uint8_t *)(ptr) + 1)) << 0))))(ndo, "%s", tok2str(l2tp_avp2str, "AVP-#%u", attr_type))(ndo, "???")VENDOR%04x:ATTR%04xconst tok[42]tok[42]AVP-#%u???L2TP_AVP_MSGTYPEL2TP_AVP_RESULT_CODEL2TP_AVP_PROTO_VERL2TP_AVP_FRAMING_CAPL2TP_AVP_BEARER_CAPL2TP_AVP_TIE_BREAKERL2TP_AVP_FIRM_VERL2TP_AVP_ASSND_TUN_IDL2TP_AVP_RECV_WIN_SIZEL2TP_AVP_ASSND_SESS_IDL2TP_AVP_HOST_NAMEL2TP_AVP_VENDOR_NAMEL2TP_AVP_CALLING_NUMBERL2TP_AVP_CALLED_NUMBERL2TP_AVP_SUB_ADDRESSL2TP_AVP_PROXY_AUTH_NAMEL2TP_AVP_PRIVATE_GRP_IDL2TP_AVP_CHALLENGEL2TP_AVP_INI_RECV_LCPL2TP_AVP_LAST_SENT_LCPL2TP_AVP_LAST_RECV_LCPL2TP_AVP_PROXY_AUTH_CHALL2TP_AVP_PROXY_AUTH_RESPL2TP_AVP_RANDOM_VECTORL2TP_AVP_Q931_CCL2TP_AVP_CHALLENGE_RESPL2TP_AVP_CALL_SER_NUML2TP_AVP_MINIMUM_BPSL2TP_AVP_MAXIMUM_BPSL2TP_AVP_TX_CONN_SPEEDL2TP_AVP_PHY_CHANNEL_IDL2TP_AVP_RX_CONN_SPEEDL2TP_AVP_BEARER_TYPEL2TP_AVP_FRAMING_TYPEL2TP_AVP_PACKET_PROC_DELAYL2TP_AVP_PROXY_AUTH_TYPEL2TP_AVP_PROXY_AUTH_IDL2TP_AVP_CALL_ERRORSL2TP_AVP_ACCML2TP_AVP_SEQ_REQUIREDL2TP_AVP_PPP_DISCON_CC(ndo, "|...")|...l2tp_ppp_discon_cc_print(ndo, "%04x, ", EXTRACT_16BITS(ptr))(ndo, "%04x, ", ((uint16_t)(((uint16_t)(*((const uint8_t *)(ptr) + 0)) << 8) | ((uint16_t)(*((const uint8_t *)(ptr) + 1)) << 0))))%04x, (ndo, "%04x ", EXTRACT_16BITS(ptr))(ndo, "%04x ", ((uint16_t)(((uint16_t)(*((const uint8_t *)(ptr) + 0)) << 8) | ((uint16_t)(*((const uint8_t *)(ptr) + 1)) << 0))))(ndo, "%s", tok2str(l2tp_cc_direction2str, "Direction-#%u", *((u_char *)ptr++)))Direction-#%ul2tp_accm_printval_hval_l(ndo, "send=%08x ", (val_h<<16) + val_l)send=%08x (ndo, "recv=%08x ", (val_h<<16) + val_l)recv=%08x l2tp_call_errors_print(ndo, "CRCErr=%u ", (val_h<<16) + val_l)CRCErr=%u (ndo, "FrameErr=%u ", (val_h<<16) + val_l)FrameErr=%u (ndo, "HardOver=%u ", (val_h<<16) + val_l)HardOver=%u (ndo, "BufOver=%u ", (val_h<<16) + val_l)BufOver=%u (ndo, "Timeout=%u ", (val_h<<16) + val_l)Timeout=%u (ndo, "AlignErr=%u ", (val_h<<16) + val_l)AlignErr=%u l2tp_proxy_auth_id_print(ndo, "%u", EXTRACT_16BITS(ptr) & L2TP_PROXY_AUTH_ID_MASK)(ndo, "%u", ((uint16_t)(((uint16_t)(*((const uint8_t *)(ptr) + 0)) << 8) | ((uint16_t)(*((const uint8_t *)(ptr) + 1)) << 0))) & 0x00ff)l2tp_proxy_auth_type_print(ndo, "%s", tok2str(l2tp_authentype2str, "AuthType-#%u", EXTRACT_16BITS(ptr)))(ndo, "%s", tok2str(l2tp_authentype2str, "AuthType-#%u", ((uint16_t)(((uint16_t)(*((const uint8_t *)(ptr) + 0)) << 8) | ((uint16_t)(*((const uint8_t *)(ptr) + 1)) << 0)))))AuthType-#%ul2tp_packet_proc_delay_print(ndo, "obsolete")obsoletel2tp_framing_type_print(ndo, "A")L2TP_FRAMING_TYPE_ASYNC_MASKL2TP_FRAMING_TYPE_SYNC_MASKl2tp_bearer_type_printL2TP_BEARER_TYPE_ANALOG_MASK(ndo, "D")L2TP_BEARER_TYPE_DIGITAL_MASKDl2tp_q931_cc_print(ndo, ", %02x", dat[2]), %02xl2tp_bearer_cap_printL2TP_BEARER_CAP_ANALOG_MASKL2TP_BEARER_CAP_DIGITAL_MASKl2tp_framing_cap_printL2TP_FRAMING_CAP_ASYNC_MASKL2TP_FRAMING_CAP_SYNC_MASKl2tp_proto_ver_print(ndo, "%u.%u", (EXTRACT_16BITS(dat) >> 8), (EXTRACT_16BITS(dat) & 0xff))(ndo, "%u.%u", (((uint16_t)(((uint16_t)(*((const uint8_t *)(dat) + 0)) << 8) | ((uint16_t)(*((const uint8_t *)(dat) + 1)) << 0))) >> 8), (((uint16_t)(((uint16_t)(*((const uint8_t *)(dat) + 0)) << 8) | ((uint16_t)(*((const uint8_t *)(dat) + 1)) << 0))) & 0xff))l2tp_result_code_print(ndo, "%u", EXTRACT_16BITS(ptr))(ndo, "%u", ((uint16_t)(((uint16_t)(*((const uint8_t *)(ptr) + 0)) << 8) | ((uint16_t)(*((const uint8_t *)(ptr) + 1)) << 0))))(ndo, "/%u", EXTRACT_16BITS(ptr))(ndo, "/%u", ((uint16_t)(((uint16_t)(*((const uint8_t *)(ptr) + 0)) << 8) | ((uint16_t)(*((const uint8_t *)(ptr) + 1)) << 0))))l2tp_msgtype_print(ndo, "%s", tok2str(l2tp_msgtype2str, "MSGTYPE-#%u", EXTRACT_16BITS(ptr)))(ndo, "%s", tok2str(l2tp_msgtype2str, "MSGTYPE-#%u", ((uint16_t)(((uint16_t)(*((const uint8_t *)(ptr) + 0)) << 8) | ((uint16_t)(*((const uint8_t *)(ptr) + 1)) << 0)))))MSGTYPE-#%uprint_32bits_val(ndo, "%lu", (u_long)EXTRACT_32BITS(dat))(ndo, "%lu", (u_long)((uint32_t)(((uint32_t)(*((const uint8_t *)(dat) + 0)) << 24) | ((uint32_t)(*((const uint8_t *)(dat) + 1)) << 16) | ((uint32_t)(*((const uint8_t *)(dat) + 2)) << 8) | ((uint32_t)(*((const uint8_t *)(dat) + 3)) << 0))))%luprint_16bits_val(ndo, "%u", EXTRACT_16BITS(dat))(ndo, "%u", ((uint16_t)(((uint16_t)(*((const uint8_t *)(dat) + 0)) << 8) | ((uint16_t)(*((const uint8_t *)(dat) + 1)) << 0))))print_octets(ndo, "%02x", *dat++)print_string(ndo, "%c", *dat++)L2TP_PPP_DISCON_CC_DIRECTION_GLOBALglobal error"global error"L2TP_PPP_DISCON_CC_DIRECTION_AT_PEERat peer"at peer"L2TP_PPP_DISCON_CC_DIRECTION_AT_LOCALat local"at local"l2tp_cc_direction2strL2TP_AUTHEN_TYPE_RESERVEDL2TP_AUTHEN_TYPE_TEXTUALTextual"Textual"L2TP_AUTHEN_TYPE_CHAPCHAP"CHAP"L2TP_AUTHEN_TYPE_PAPPAP"PAP"L2TP_AUTHEN_TYPE_NO_AUTHNo Auth"No Auth"L2TP_AUTHEN_TYPE_MSCHAPv1MS-CHAPv1"MS-CHAPv1"l2tp_authentype2strMSGTYPE"MSGTYPE"RESULT_CODE"RESULT_CODE"PROTO_VER"PROTO_VER"FRAMING_CAP"FRAMING_CAP"BEARER_CAP"BEARER_CAP"TIE_BREAKER"TIE_BREAKER"FIRM_VER"FIRM_VER"HOST_NAME"HOST_NAME"VENDOR_NAME"VENDOR_NAME"ASSND_TUN_ID"ASSND_TUN_ID"RECV_WIN_SIZE"RECV_WIN_SIZE"CHALLENGE"CHALLENGE"Q931_CC"Q931_CC"CHALLENGE_RESP"CHALLENGE_RESP"ASSND_SESS_ID"ASSND_SESS_ID"CALL_SER_NUM"CALL_SER_NUM"MINIMUM_BPS"MINIMUM_BPS"MAXIMUM_BPS"MAXIMUM_BPS"BEARER_TYPE"BEARER_TYPE"FRAMING_TYPE"FRAMING_TYPE"PACKET_PROC_DELAY"PACKET_PROC_DELAY"CALLED_NUMBER"CALLED_NUMBER"CALLING_NUMBER"CALLING_NUMBER"SUB_ADDRESS"SUB_ADDRESS"TX_CONN_SPEED"TX_CONN_SPEED"PHY_CHANNEL_ID"PHY_CHANNEL_ID"INI_RECV_LCP"INI_RECV_LCP"LAST_SENT_LCP"LAST_SENT_LCP"LAST_RECV_LCP"LAST_RECV_LCP"PROXY_AUTH_TYPE"PROXY_AUTH_TYPE"PROXY_AUTH_NAME"PROXY_AUTH_NAME"PROXY_AUTH_CHAL"PROXY_AUTH_CHAL"PROXY_AUTH_ID"PROXY_AUTH_ID"PROXY_AUTH_RESP"PROXY_AUTH_RESP"CALL_ERRORS"CALL_ERRORS"ACCM"ACCM"RANDOM_VECTOR"RANDOM_VECTOR"PRIVATE_GRP_ID"PRIVATE_GRP_ID"RX_CONN_SPEED"RX_CONN_SPEED"SEQ_REQUIRED"SEQ_REQUIRED"PPP_DISCON_CC"PPP_DISCON_CC"l2tp_avp2strL2TP_MSGTYPE_SCCRQSCCRQ"SCCRQ"L2TP_MSGTYPE_SCCRPSCCRP"SCCRP"L2TP_MSGTYPE_SCCCNSCCCN"SCCCN"L2TP_MSGTYPE_STOPCCNStopCCN"StopCCN"L2TP_MSGTYPE_HELLOHELLO"HELLO"L2TP_MSGTYPE_OCRQOCRQ"OCRQ"L2TP_MSGTYPE_OCRPOCRP"OCRP"L2TP_MSGTYPE_OCCNOCCN"OCCN"L2TP_MSGTYPE_ICRQICRQ"ICRQ"L2TP_MSGTYPE_ICRPICRP"ICRP"L2TP_MSGTYPE_ICCNICCN"ICCN"L2TP_MSGTYPE_CDNCDN"CDN"L2TP_MSGTYPE_WENWEN"WEN"L2TP_MSGTYPE_SLISLI"SLI"l2tp_msgtype2str [|l2tp]" [|l2tp]"L2TP_PROXY_AUTH_ID_MASK0x00ff0x03ff0x000f/* Offset Size *//* Nr *//* Ns *//* Session ID *//* Tunnel ID *//* nothing we can do *//* nothing to do *//* Flags & Version *//* total octets consumed *//* No Attribute Value *//* IETF-defined Attributes *//* Vendor Specific Attribute *//* After this point, no need to worry about truncation *//* If it goes past the end of the remaining length of the captured
	   data, we'll give up. *//* If it goes past the end of the remaining length of the packet,
	   we'll give up. *//* If it is not long enough to contain the header, we'll give up. *//* Flags & Length *//* Control Protocol Number *//* Disconnect Code *//* skip "Reserved" *//* Error Message (opt) *//* Error Code (opt) *//* Result Code *//***********************************//* AVP-specific print out routines *//******************************//* generic print out routines *//* PPP Disconnect Cause Code *//* Sequencing Required *//* (Rx) Connect Speed *//* Private Group ID *//* Random Vector *//* ACCM *//* Call Errors *//* Proxy Authen Response *//* Proxy Authen ID *//* Proxy Authen Challenge *//* Proxy Authen Name *//* Proxy Authen Type *//* Last Received LCP CONFREQ *//* Last Sent LCP CONFREQ *//* Initial Received LCP CONFREQ *//* Physical Channel ID *//* (Tx) Connect Speed *//* Sub-Address *//* Calling Number *//* Called Number *//* Packet Processing Delay (OBSOLETE) *//* Framing Type *//* Bearer Type *//* Maximum BPS *//* Minimum BPS *//* Call Serial Number *//* Assigned Session ID *//* Challenge Response *//* Q.931 Cause Code *//* Challenge *//* Receive Window Size *//* Assigned Tunnel ID *//* Vendor Name *//* Host Name *//* Firmware Revision *//* Tie Breaker *//* Bearer Capabilities *//* Framing Capabilities *//* Message Type *//* Set-Link-Info *//* WAN-Error-Notify *//* Call-Disconnect-Notify *//* Incoming-Call-Connected *//* Incoming-Call-Reply *//* Incoming-Call-Request *//* Outgoing-Call-Connected *//* Outgoing-Call-Reply *//* Outgoing-Call-Request *//* Hello *//* Stop-Control-Connection-Notification *//* Start-Control-Connection-Connected *//* Start-Control-Connection-Reply *//* Start-Control-Connection-Request *//* MSCHAPv1 *//* No Authentication *//* PPP PAP *//* PPP CHAP *//* Textual username/password exchange *//* Authen Type *//* Analog *//* Digital *//* Asynchronous *//* Synchronous *//* Length Mask *//* Hidden Flag *//* Mandatory Flag *//* L2TP *//* L2F *//* Version Mask *//* Priority *//* Offset *//* Sequence *//* Type (0=Data, 1=Control) *//*
 * Copyright (c) 1991, 1993, 1994, 1995, 1996, 1997
 *      The Regents of the University of California.  All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that: (1) source code distributions
 * retain the above copyright notice and this paragraph in its entirety, (2)
 * distributions including binary code include the above copyright notice and
 * this paragraph in its entirety in the documentation or other materials
 * provided with the distribution, and (3) all advertising materials mentioning
 * features or use of this software display the following acknowledgement:
 * ``This product includes software developed by the University of California,
 * Lawrence Berkeley Laboratory and its contributors.'' Neither the name of
 * the University nor the names of its contributors may be used to endorse
 * or promote products derived from this software without specific prior
 * written permission.
 * THIS SOFTWARE IS PROVIDED ``AS IS'' AND WITHOUT ANY EXPRESS OR IMPLIED
 * WARRANTIES, INCLUDING, WITHOUT LIMITATION, THE IMPLIED WARRANTIES OF
 * MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE.
 *
 * L2TP support contributed by Motonori Shindo (mshindo@mshindo.net)
 *//Users/owura/Repos/codeql_eval/proj_repos/the-tcpdump-group-tcpdump-commit-0f95d441e4b5d7512cc5c326c8668a120e048eda/tcpdump/print-lane.clane_if_printsizeof(struct lecdatahdr_8023)(sizeof(struct lecdatahdr_8023))lane_printlane_controlhdr *lec(ndo, "[|lane]")sizeof(struct lane_controlhdr)[|lane]&lec->lec_header(ndo, "lec: proto %x vers %x %s", lec->lec_proto, lec->lec_vers, tok2str(lecop2str, "opcode-#%u", EXTRACT_16BITS(&lec->lec_opcode)))(ndo, "lec: proto %x vers %x %s", lec->lec_proto, lec->lec_vers, tok2str(lecop2str, "opcode-#%u", ((uint16_t)(((uint16_t)(*((const uint8_t *)(&lec->lec_opcode) + 0)) << 8) | ((uint16_t)(*((const uint8_t *)(&lec->lec_opcode) + 1)) << 0)))))&lec->lec_opcodelec: proto %x vers %x %sopcode-#%ulane_hdr_print(ndo, "lecid:%x ", EXTRACT_16BITS(bp))(ndo, "lecid:%x ", ((uint16_t)(((uint16_t)(*((const uint8_t *)(bp) + 0)) << 8) | ((uint16_t)(*((const uint8_t *)(bp) + 1)) << 0))))lecid:%x lane_controlhdrlecdatahdr_8023lec_opcodelec_verslec_protolec_headerh_typeh_sourceh_destle_headerconfigure request"configure request"0x0101configure response"configure response"join request"join request"join response"join response"ready query"ready query"ready indication"ready indication"register request"register request"0x0104register response"register response"unregister request"unregister request"unregister response"unregister response"ARP request"ARP request"2620x0106ARP response"ARP response"flush request"flush request"flush response"flush response"NARP request"NARP request"topology request"topology request"lecop2str/*
	 * Now print the encapsulated frame, under the assumption
	 * that it's an Ethernet frame.
	 *//*
	 * Go past the LE header.
	 *//*
		 * LE Control.
		 *//*
 * This is the top level routine of the printer.  'p' points
 * to the LANE header of the packet, 'h->ts' is the timestamp,
 * 'h->len' is the length of the packet off the wire, and 'h->caplen'
 * is the number of bytes actually captured.
 *
 * This assumes 802.3, not 802.5, LAN emulation.
 *//Users/owura/Repos/codeql_eval/proj_repos/the-tcpdump-group-tcpdump-commit-0f95d441e4b5d7512cc5c326c8668a120e048eda/tcpdump/print-ldp.cldp_tlv_headerldp_msg_printconst ldp_common_headerconst ldp_common_header *ldp_common_header *ldp_com_headerconst ldp_msg_headerconst ldp_msg_header *ldp_msg_header *ldp_msg_headermsg_tptrmsg_lenmsg_tlen*ldp_com_headersizeof(*ldp_com_header)&ldp_com_header->version(ndo, "%sLDP version %u packet not supported", (ndo->ndo_vflag < 1) ? "" : "\n\t", EXTRACT_16BITS(&ldp_com_header->version))(ndo, "%sLDP version %u packet not supported", (ndo->ndo_vflag < 1) ? "" : "\n\t", ((uint16_t)(((uint16_t)(*((const uint8_t *)(&ldp_com_header->version) + 0)) << 8) | ((uint16_t)(*((const uint8_t *)(&ldp_com_header->version) + 1)) << 0))))LDP_VERSION%sLDP version %u packet not supported&ldp_com_header->pdu_length(ndo, "%sLDP, Label-Space-ID: %s:%u, pdu-length: %u", (ndo->ndo_vflag < 1) ? "" : "\n\t", ipaddr_string(ndo, &ldp_com_header->lsr_id), EXTRACT_16BITS(&ldp_com_header->label_space), pdu_len)(ndo, "%sLDP, Label-Space-ID: %s:%u, pdu-length: %u", (ndo->ndo_vflag < 1) ? "" : "\n\t", getname(ndo, (const u_char *)(&ldp_com_header->lsr_id)), ((uint16_t)(((uint16_t)(*((const uint8_t *)(&ldp_com_header->label_space) + 0)) << 8) | ((uint16_t)(*((const uint8_t *)(&ldp_com_header->label_space) + 1)) << 0))), pdu_len)%sLDP, Label-Space-ID: %s:%u, pdu-length: %u&ldp_com_header->lsr_id&ldp_com_header->label_spacesizeof(const struct ldp_common_header)sizeof(const struct ldp_common_header)-4sizeof(struct ldp_msg_header)ldp_msg_header->lengthEXTRACT_16BITS(ldp_msg_header->type)((uint16_t)(((uint16_t)(*((const uint8_t *)(ldp_msg_header->type) + 0)) << 8) | ((uint16_t)(*((const uint8_t *)(ldp_msg_header->type) + 1)) << 0)))ldp_msg_header->type(ndo, "\n\t  %s Message (0x%04x), length: %u, Message ID: 0x%08x, Flags: [%s if unknown]", tok2str(ldp_msg_values, "Unknown", msg_type), msg_type, msg_len, EXTRACT_32BITS(&ldp_msg_header->id), LDP_MASK_U_BIT(EXTRACT_16BITS(&ldp_msg_header->type)) ? "continue processing" : "ignore")(ndo, "\n\t  %s Message (0x%04x), length: %u, Message ID: 0x%08x, Flags: [%s if unknown]", tok2str(ldp_msg_values, "Unknown", msg_type), msg_type, msg_len, ((uint32_t)(((uint32_t)(*((const uint8_t *)(&ldp_msg_header->id) + 0)) << 24) | ((uint32_t)(*((const uint8_t *)(&ldp_msg_header->id) + 1)) << 16) | ((uint32_t)(*((const uint8_t *)(&ldp_msg_header->id) + 2)) << 8) | ((uint32_t)(*((const uint8_t *)(&ldp_msg_header->id) + 3)) << 0))), ((((uint16_t)(((uint16_t)(*((const uint8_t *)(&ldp_msg_header->type) + 0)) << 8) | ((uint16_t)(*((const uint8_t *)(&ldp_msg_header->type) + 1)) << 0))))&0x8000) ? "continue processing" : "ignore")&ldp_msg_header->idEXTRACT_16BITS(&ldp_msg_header->type)((uint16_t)(((uint16_t)(*((const uint8_t *)(&ldp_msg_header->type) + 0)) << 8) | ((uint16_t)(*((const uint8_t *)(&ldp_msg_header->type) + 1)) << 0)))&ldp_msg_header->type
	  %s Message (0x%04x), length: %u, Message ID: 0x%08x, Flags: [%s if unknown]continue processingignoreLDP_MSG_NOTIFLDP_MSG_HELLOLDP_MSG_INIT513LDP_MSG_KEEPALIVELDP_MSG_ADDRESSLDP_MSG_LABEL_MAPPINGLDP_MSG_ADDRESS_WITHDRAW1026LDP_MSG_LABEL_WITHDRAW1025LDP_MSG_LABEL_REQUEST1027LDP_MSG_LABEL_RELEASE1028LDP_MSG_LABEL_ABORT_REQUESTldp_printsizeof(struct ldp_common_header)sizeof(struct ldp_common_header) + sizeof(struct ldp_msg_header)(sizeof(struct ldp_common_header) + sizeof(struct ldp_msg_header))ldp_tlv_printconst ldp_tlv_headerconst ldp_tlv_header *ldp_tlv_header *ft_flagsfec_typeuivc_info_lenvc_info_tlv_typevc_info_tlv_lenchar[100]ldp_tlv_header->lengthEXTRACT_16BITS(ldp_tlv_header->type)((uint16_t)(((uint16_t)(*((const uint8_t *)(ldp_tlv_header->type) + 0)) << 8) | ((uint16_t)(*((const uint8_t *)(ldp_tlv_header->type) + 1)) << 0)))ldp_tlv_header->type(ndo, "\n\t    %s TLV (0x%04x), length: %u, Flags: [%s and %s forward if unknown]", tok2str(ldp_tlv_values, "Unknown", tlv_type), tlv_type, tlv_len, LDP_MASK_U_BIT(EXTRACT_16BITS(&ldp_tlv_header->type)) ? "continue processing" : "ignore", LDP_MASK_F_BIT(EXTRACT_16BITS(&ldp_tlv_header->type)) ? "do" : "don't")(ndo, "\n\t    %s TLV (0x%04x), length: %u, Flags: [%s and %s forward if unknown]", tok2str(ldp_tlv_values, "Unknown", tlv_type), tlv_type, tlv_len, ((((uint16_t)(((uint16_t)(*((const uint8_t *)(&ldp_tlv_header->type) + 0)) << 8) | ((uint16_t)(*((const uint8_t *)(&ldp_tlv_header->type) + 1)) << 0))))&0x8000) ? "continue processing" : "ignore", ((((uint16_t)(((uint16_t)(*((const uint8_t *)(&ldp_tlv_header->type) + 0)) << 8) | ((uint16_t)(*((const uint8_t *)(&ldp_tlv_header->type) + 1)) << 0))))&0x4000) ? "do" : "don't")
	    %s TLV (0x%04x), length: %u, Flags: [%s and %s forward if unknown]&ldp_tlv_header->typeEXTRACT_16BITS(&ldp_tlv_header->type)((uint16_t)(((uint16_t)(*((const uint8_t *)(&ldp_tlv_header->type) + 0)) << 8) | ((uint16_t)(*((const uint8_t *)(&ldp_tlv_header->type) + 1)) << 0)))dodon'tsizeof(struct ldp_tlv_header)(ndo, "\n\t      Hold Time: %us, Flags: [%s Hello%s]", EXTRACT_16BITS(tptr), (EXTRACT_16BITS(tptr+2)&0x8000) ? "Targeted" : "Link", (EXTRACT_16BITS(tptr+2)&0x4000) ? ", Request for targeted Hellos" : "")(ndo, "\n\t      Hold Time: %us, Flags: [%s Hello%s]", ((uint16_t)(((uint16_t)(*((const uint8_t *)(tptr) + 0)) << 8) | ((uint16_t)(*((const uint8_t *)(tptr) + 1)) << 0))), (((uint16_t)(((uint16_t)(*((const uint8_t *)(tptr+2) + 0)) << 8) | ((uint16_t)(*((const uint8_t *)(tptr+2) + 1)) << 0)))&0x8000) ? "Targeted" : "Link", (((uint16_t)(((uint16_t)(*((const uint8_t *)(tptr+2) + 0)) << 8) | ((uint16_t)(*((const uint8_t *)(tptr+2) + 1)) << 0)))&0x4000) ? ", Request for targeted Hellos" : "")(ndo, "\n\t      IPv4 Transport Address: %s", ipaddr_string(ndo, tptr))(ndo, "\n\t      IPv4 Transport Address: %s", getname(ndo, (const u_char *)(tptr)))(ndo, "\n\t      Sequence Number: %u", EXTRACT_32BITS(tptr))(ndo, "\n\t      Sequence Number: %u", ((uint32_t)(((uint32_t)(*((const uint8_t *)(tptr) + 0)) << 24) | ((uint32_t)(*((const uint8_t *)(tptr) + 1)) << 16) | ((uint32_t)(*((const uint8_t *)(tptr) + 2)) << 8) | ((uint32_t)(*((const uint8_t *)(tptr) + 3)) << 0))))LDP_TLV_ADDRESS_LIST_AFNUM_LEN(ndo, "\n\t      Address Family: %s, addresses", tok2str(af_values, "Unknown (%u)", af))(ndo, " %s", ipaddr_string(ndo, tptr))(ndo, " %s", getname(ndo, (const u_char *)(tptr)))(ndo, "\n\t      Version: %u, Keepalive: %us, Flags: [Downstream %s, Loop Detection %s]", EXTRACT_16BITS(tptr), EXTRACT_16BITS(tptr+2), (EXTRACT_16BITS(tptr+6)&0x8000) ? "On Demand" : "Unsolicited", (EXTRACT_16BITS(tptr+6)&0x4000) ? "Enabled" : "Disabled" )(ndo, "\n\t      Version: %u, Keepalive: %us, Flags: [Downstream %s, Loop Detection %s]", ((uint16_t)(((uint16_t)(*((const uint8_t *)(tptr) + 0)) << 8) | ((uint16_t)(*((const uint8_t *)(tptr) + 1)) << 0))), ((uint16_t)(((uint16_t)(*((const uint8_t *)(tptr+2) + 0)) << 8) | ((uint16_t)(*((const uint8_t *)(tptr+2) + 1)) << 0))), (((uint16_t)(((uint16_t)(*((const uint8_t *)(tptr+6) + 0)) << 8) | ((uint16_t)(*((const uint8_t *)(tptr+6) + 1)) << 0)))&0x8000) ? "On Demand" : "Unsolicited", (((uint16_t)(((uint16_t)(*((const uint8_t *)(tptr+6) + 0)) << 8) | ((uint16_t)(*((const uint8_t *)(tptr+6) + 1)) << 0)))&0x4000) ? "Enabled" : "Disabled" )(ndo, "\n\t      %s FEC (0x%02x)", tok2str(ldp_fec_values, "Unknown", fec_type), fec_type)(ndo, ": IPv4 prefix (goes past end of TLV)")(ndo, ": IPv4 prefix (invalid length)")(ndo, ": IPv4 prefix %s", buf)(ndo, ": Address family %u prefix", af)(ndo, ": %s, %scontrol word, group-ID %u, VC-info-length: %u", tok2str(l2vpn_encaps_values, "Unknown", EXTRACT_16BITS(tptr)&0x7fff), EXTRACT_16BITS(tptr)&0x8000 ? "" : "no ", EXTRACT_32BITS(tptr+3), vc_info_len)(ndo, ": %s, %scontrol word, group-ID %u, VC-info-length: %u", tok2str(l2vpn_encaps_values, "Unknown", ((uint16_t)(((uint16_t)(*((const uint8_t *)(tptr) + 0)) << 8) | ((uint16_t)(*((const uint8_t *)(tptr) + 1)) << 0)))&0x7fff), ((uint16_t)(((uint16_t)(*((const uint8_t *)(tptr) + 0)) << 8) | ((uint16_t)(*((const uint8_t *)(tptr) + 1)) << 0)))&0x8000 ? "" : "no ", ((uint32_t)(((uint32_t)(*((const uint8_t *)(tptr+3) + 0)) << 24) | ((uint32_t)(*((const uint8_t *)(tptr+3) + 1)) << 16) | ((uint32_t)(*((const uint8_t *)(tptr+3) + 2)) << 8) | ((uint32_t)(*((const uint8_t *)(tptr+3) + 3)) << 0))), vc_info_len)(ndo, ": %s, %scontrol word, group-ID %u, VC-ID %u, VC-info-length: %u", tok2str(l2vpn_encaps_values, "Unknown", EXTRACT_16BITS(tptr)&0x7fff), EXTRACT_16BITS(tptr)&0x8000 ? "" : "no ", EXTRACT_32BITS(tptr+3), EXTRACT_32BITS(tptr+7), vc_info_len)(ndo, ": %s, %scontrol word, group-ID %u, VC-ID %u, VC-info-length: %u", tok2str(l2vpn_encaps_values, "Unknown", ((uint16_t)(((uint16_t)(*((const uint8_t *)(tptr) + 0)) << 8) | ((uint16_t)(*((const uint8_t *)(tptr) + 1)) << 0)))&0x7fff), ((uint16_t)(((uint16_t)(*((const uint8_t *)(tptr) + 0)) << 8) | ((uint16_t)(*((const uint8_t *)(tptr) + 1)) << 0)))&0x8000 ? "" : "no ", ((uint32_t)(((uint32_t)(*((const uint8_t *)(tptr+3) + 0)) << 24) | ((uint32_t)(*((const uint8_t *)(tptr+3) + 1)) << 16) | ((uint32_t)(*((const uint8_t *)(tptr+3) + 2)) << 8) | ((uint32_t)(*((const uint8_t *)(tptr+3) + 3)) << 0))), ((uint32_t)(((uint32_t)(*((const uint8_t *)(tptr+7) + 0)) << 24) | ((uint32_t)(*((const uint8_t *)(tptr+7) + 1)) << 16) | ((uint32_t)(*((const uint8_t *)(tptr+7) + 2)) << 8) | ((uint32_t)(*((const uint8_t *)(tptr+7) + 3)) << 0))), vc_info_len)tptr+7(ndo, "\n\t\tInterface Parameter: %s (0x%02x), len %u", tok2str(ldp_fec_martini_ifparm_values,"Unknown",vc_info_tlv_type), vc_info_tlv_type, vc_info_tlv_len)(ndo, ": %u", EXTRACT_16BITS(tptr+2))(ndo, ": %u", ((uint16_t)(((uint16_t)(*((const uint8_t *)(tptr+2) + 0)) << 8) | ((uint16_t)(*((const uint8_t *)(tptr+2) + 1)) << 0))))(ndo, "\n\t\t  Control Channels (0x%02x) = [%s]", *(tptr+2), bittok2str(ldp_fec_martini_ifparm_vccv_cc_values, "none", *(tptr+2)))(ndo, "\n\t\t  CV Types (0x%02x) = [%s]", *(tptr+3), bittok2str(ldp_fec_martini_ifparm_vccv_cv_values, "none", *(tptr+3)))(ndo, "\n\t      Label: %u", EXTRACT_32BITS(tptr) & 0xfffff)(ndo, "\n\t      Label: %u", ((uint32_t)(((uint32_t)(*((const uint8_t *)(tptr) + 0)) << 24) | ((uint32_t)(*((const uint8_t *)(tptr) + 1)) << 16) | ((uint32_t)(*((const uint8_t *)(tptr) + 2)) << 8) | ((uint32_t)(*((const uint8_t *)(tptr) + 3)) << 0))) & 0xfffff)(ndo, "\n\t      Status: 0x%02x, Flags: [%s and %s forward]", ui&0x3fffffff, ui&0x80000000 ? "Fatal error" : "Advisory Notification", ui&0x40000000 ? "do" : "don't")(ndo, ", causing Message ID: 0x%08x", ui)(ndo, "\n\t      Flags: [%sReconnect, %sSave State, %sAll-Label Protection, %s Checkpoint, %sRe-Learn State]", ft_flags&0x8000 ? "" : "No ", ft_flags&0x8 ? "" : "Don't ", ft_flags&0x4 ? "" : "No ", ft_flags&0x2 ? "Sequence Numbered Label" : "All Labels", ft_flags&0x1 ? "" : "Don't ")(ndo, ", Reconnect Timeout: %ums", ui)(ndo, ", Recovery Time: %ums", ui)(ndo, "\n\t      MTU: %u", EXTRACT_16BITS(tptr))(ndo, "\n\t      MTU: %u", ((uint16_t)(((uint16_t)(*((const uint8_t *)(tptr) + 0)) << 8) | ((uint16_t)(*((const uint8_t *)(tptr) + 1)) << 0))))LDP_TLV_COMMON_HELLO
	      Hold Time: %us, Flags: [%s Hello%s]TargetedLink, Request for targeted HellosLDP_TLV_IPV4_TRANSPORT_ADDR
	      IPv4 Transport Address: %sLDP_TLV_CONFIG_SEQ_NUMBER
	      Sequence Number: %uLDP_TLV_ADDRESS_LIST
	      Address Family: %s, addressesLDP_TLV_COMMON_SESSION
	      Version: %u, Keepalive: %us, Flags: [Downstream %s, Loop Detection %s]char[79]On DemandUnsolicitedEnabledDisabledLDP_TLV_FEC
	      %s FEC (0x%02x)LDP_FEC_WILDCARDLDP_FEC_PREFIX: IPv4 prefix (goes past end of TLV): IPv4 prefix (invalid length): IPv4 prefix %s: Address family %u prefixLDP_FEC_HOSTADDRESSLDP_FEC_MARTINI_VC: %s, %scontrol word, group-ID %u, VC-info-length: %u: %s, %scontrol word, group-ID %u, VC-ID %u, VC-info-length: %u
		Interface Parameter: %s (0x%02x), len %uLDP_FEC_MARTINI_IFPARM_MTU: %uLDP_FEC_MARTINI_IFPARM_DESCLDP_FEC_MARTINI_IFPARM_VCCV
		  Control Channels (0x%02x) = [%s]
		  CV Types (0x%02x) = [%s]LDP_TLV_GENERIC_LABEL
	      Label: %uLDP_TLV_STATUS
	      Status: 0x%02x, Flags: [%s and %s forward]Fatal errorAdvisory Notification, causing Message ID: 0x%08x1283LDP_TLV_FT_SESSION
	      Flags: [%sReconnect, %sSave State, %sAll-Label Protection, %s Checkpoint, %sRe-Learn State]No Don't Sequence Numbered LabelAll Labels, Reconnect Timeout: %ums, Recovery Time: %ums1537LDP_TLV_MTU
	      MTU: %uLDP_TLV_HOP_COUNTLDP_TLV_PATH_VECTORLDP_TLV_ATM_LABELLDP_TLV_FR_LABELLDP_TLV_EXTD_STATUSLDP_TLV_RETURNED_PDULDP_TLV_RETURNED_MSG1281LDP_TLV_ATM_SESSION_PARM1282LDP_TLV_FR_SESSION_PARMLDP_TLV_LABEL_REQUEST_MSG_ID(ndo, "\n\t\t TLV contents go past end of TLV")
		 TLV contents go past end of TLVldp_common_headerlabel_spacelsr_idpdu_lengthICMP Ping"ICMP Ping"LSP Ping"LSP Ping"BFD"BFD"ldp_fec_martini_ifparm_vccv_cv_valuesPWE3 control word"PWE3 control word"MPLS Router Alert Label"MPLS Router Alert Label"MPLS inner label TTL = 1"MPLS inner label TTL = 1"ldp_fec_martini_ifparm_vccv_cc_valuesDescription"Description"VCCV"VCCV"ldp_fec_martini_ifparm_valuesWildcard"Wildcard"Prefix"Prefix"Host address"Host address"Martini VC"Martini VC"ldp_fec_valuesFEC"FEC"Address List"Address List"Hop Count"Hop Count"Path Vector"Path Vector"Generic Label"Generic Label"ATM Label"ATM Label"Frame-Relay Label"Frame-Relay Label"Extended Status"Extended Status"Returned PDU"Returned PDU"Returned Message"Returned Message"Common Hello Parameters"Common Hello Parameters"IPv4 Transport Address"IPv4 Transport Address"Configuration Sequence Number"Configuration Sequence Number"LDP_TLV_IPV6_TRANSPORT_ADDRIPv6 Transport Address"IPv6 Transport Address"Common Session Parameters"Common Session Parameters"ATM Session Parameters"ATM Session Parameters"Frame-Relay Session Parameters"Frame-Relay Session Parameters"Fault-Tolerant Session Parameters"Fault-Tolerant Session Parameters"Label Request Message ID"Label Request Message ID"ldp_tlv_valuesInitialization"Initialization"Address Withdraw"Address Withdraw"Label Mapping"Label Mapping"Label Request"Label Request"Label Withdraw"Label Withdraw"Label Release"Label Release"Label Abort Request"Label Abort Request"ldp_msg_valuesTLV_TCHECK(minlen)ND_TCHECK2(*tptr, minlen); if (tlv_tlen < minlen) goto badtlv;0x06010x05030x05020x05010x04030x04020x04010x03010x0300LDP_MASK_F_BIT(x)((x)&0x4000)LDP_MASK_TLV_TYPE(x)((x)&0x3fff)LDP_EXPERIMENTAL_MAXLDP_EXPERIMENTAL_MIN0x3f00LDP_VENDOR_PRIVATE_MAX0x3effLDP_VENDOR_PRIVATE_MIN0x3e000x0404LDP_MASK_U_BIT(x)((x)&0x8000)LDP_MASK_MSG_TYPE(x)((x)&0x7fff)/*
         *  FIXME those are the defined messages that lack a decoder
         *  you are welcome to contribute code ;-)
         *//* did we capture enough for fully decoding the message ? *//* Type & Length fields not included *//* FIXME vendor private / experimental check *//* did we capture enough for fully decoding the msg header ? *//* bail out if non-verbose *//* print the LSR-ID, label-space & length *//*
     *  FIXME those are the defined TLVs that lack a decoder
     *  you are welcome to contribute code ;-)
     *//* Skip past the fixed information and the VC ID *//* subtract out the VC ID, giving the length of the interface parameters *//* minimum 4, for the VC ID *//* Make sure we have the VC ID as well *//*
	     * According to RFC 4908, the VC info Length field can be zero,
	     * in which case not only are there no interface parameters,
	     * there's no VC ID.
	     *//* unknown AF *//*
 * ldp tlv header
 *
 *  0                   1                   2                   3
 *  0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
 * +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
 * |U|F|        Type               |            Length             |
 * +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
 * |                                                               |
 * |                             Value                             |
 * ~                                                               ~
 * |                                                               |
 * |                               +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
 * |                               |
 * +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
 *//* draft-ietf-pwe3-vccv-04.txt *//* From RFC 4906; should probably be updated to RFC 4447 (e.g., VC -> PW) *//* rfc 3988 *//*
 * ldp message header
 *
 *  0                   1                   2                   3
 *  0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
 * +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
 * |U|   Message Type              |      Message Length           |
 * +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
 * |                     Message ID                                |
 * +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
 * |                                                               |
 * +                                                               +
 * |                     Mandatory Parameters                      |
 * +                                                               +
 * |                                                               |
 * +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
 * |                                                               |
 * +                                                               +
 * |                     Optional Parameters                       |
 * +                                                               +
 * |                                                               |
 * +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
 *//*
 * ldp common header
 *
 *  0                   1                   2                   3
 *  0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
 * +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
 * |  Version                      |         PDU Length            |
 * +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
 * |                         LDP Identifier                        |
 * +                               +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
 * |                               |
 * +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
 *
 *//*
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that: (1) source code
 * distributions retain the above copyright notice and this paragraph
 * in its entirety, and (2) distributions including binary code include
 * the above copyright notice and this paragraph in its entirety in
 * the documentation or other materials provided with the distribution.
 * THIS SOFTWARE IS PROVIDED ``AS IS'' AND
 * WITHOUT ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, WITHOUT
 * LIMITATION, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS
 * FOR A PARTICULAR PURPOSE.
 *
 * Original code by Hannes Gredler (hannes@juniper.net)
 *  and Steinar Haug (sthaug@nethelp.no)
 *//Users/owura/Repos/codeql_eval/proj_repos/the-tcpdump-group-tcpdump-commit-0f95d441e4b5d7512cc5c326c8668a120e048eda/tcpdump/print-llc.csnap_printorgcodeetp + 3(ndo, "oui %s (0x%06x), %s %s (0x%04x): ", tok2str(oui_values, "Unknown", orgcode), orgcode, (orgcode == 0x000000 ? "ethertype" : "pid"), tok2str(tok, "Unknown", et), et)tokconst oui_tokconst oui_tok *oui_tok *otpconst oui_tok[6]oui_tok[6]oui %s (0x%06x), %s %s (0x%04x): ethertypepidbridge_padbridge_pad + 181968195268(ndo, "[|snap]")[|snap]llc_printdsap_fielddsapssap_fieldssapis_u(ndo, "[|llc]")(u_char *)p[|llc](ndo, "IPX 802.3: ")IPX 802.3: ~LLC_IG~LLC_GSAP(ndo, "LLC, dsap %s (0x%02x) %s, ssap %s (0x%02x) %s", tok2str(llc_values, "Unknown", dsap), dsap, tok2str(llc_ig_flag_values, "Unknown", dsap_field & LLC_IG), tok2str(llc_values, "Unknown", ssap), ssap, tok2str(llc_flag_values, "Unknown", ssap_field & LLC_GSAP))(ndo, "LLC, dsap %s (0x%02x) %s, ssap %s (0x%02x) %s", tok2str(llc_values, "Unknown", dsap), dsap, tok2str(llc_ig_flag_values, "Unknown", dsap_field & 1), tok2str(llc_values, "Unknown", ssap), ssap, tok2str(llc_flag_values, "Unknown", ssap_field & 1))(ndo, ", ctrl 0x%02x: ", control)(ndo, ", ctrl 0x%04x: ", control)LLC, dsap %s (0x%02x) %s, ssap %s (0x%02x) %sesrcedst, ctrl 0x%02x: , ctrl 0x%04x: (ndo, "IPX 802.2: ")IPX 802.2: (ndo, "%s ", tok2str(llc_values, "Unknown DSAP 0x%02x", dsap))(ndo, "%s > %s %s ", etheraddr_string(ndo, esrc), etheraddr_string(ndo, edst), tok2str(llc_values, "Unknown DSAP 0x%02x", dsap))(ndo, "%s > %s ", tok2str(llc_values, "Unknown SSAP 0x%02x", ssap), tok2str(llc_values, "Unknown DSAP 0x%02x", dsap))(ndo, "%s %s > %s %s ", etheraddr_string(ndo, esrc), tok2str(llc_values, "Unknown SSAP 0x%02x", ssap), etheraddr_string(ndo, edst), tok2str(llc_values, "Unknown DSAP 0x%02x", dsap))Unknown DSAP 0x%02x%s > %s %s %s > %s Unknown SSAP 0x%02x%s %s > %s %s (ndo, "Unnumbered, %s, Flags [%s], length %u", tok2str(llc_cmd_values, "%02x", LLC_U_CMD(control)), tok2str(llc_flag_values,"?",(ssap_field & LLC_GSAP) | (control & LLC_U_POLL)), length)(ndo, "Unnumbered, %s, Flags [%s], length %u", tok2str(llc_cmd_values, "%02x", ((control) & 0xef)), tok2str(llc_flag_values,"?",(ssap_field & 1) | (control & 0x10)), length)(ndo, ": %02x %02x", p[1], p[2])(ndo, "Supervisory, %s, rcv seq %u, Flags [%s], length %u", tok2str(llc_supervisory_values,"?",LLC_S_CMD(control)), LLC_IS_NR(control), tok2str(llc_flag_values,"?",(ssap_field & LLC_GSAP) | (control & LLC_IS_POLL)), length)(ndo, "Supervisory, %s, rcv seq %u, Flags [%s], length %u", tok2str(llc_supervisory_values,"?",(((control) >> 2) & 0x03)), (((control) >> 9) & 0x7f), tok2str(llc_flag_values,"?",(ssap_field & 1) | (control & 0x0100)), length)(ndo, "Information, send seq %u, rcv seq %u, Flags [%s], length %u", LLC_I_NS(control), LLC_IS_NR(control), tok2str(llc_flag_values,"?",(ssap_field & LLC_GSAP) | (control & LLC_IS_POLL)), length)(ndo, "Information, send seq %u, rcv seq %u, Flags [%s], length %u", (((control) >> 1) & 0x7f), (((control) >> 9) & 0x7f), tok2str(llc_flag_values,"?",(ssap_field & 1) | (control & 0x0100)), length)Unnumbered, %s, Flags [%s], length %u239-17~LLC_U_POLL: %02x %02xSupervisory, %s, rcv seq %u, Flags [%s], length %uInformation, send seq %u, rcv seq %u, Flags [%s], length %uoui_tokconst oui_tok[]oui_tok[]oui_to_toknull_valuesEthernet + FCS"Ethernet + FCS"Ethernet w/o FCS"Ethernet w/o FCS"802.4 + FCS"802.4 + FCS"802.4 w/o FCS"802.4 w/o FCS"Token Ring + FCS"Token Ring + FCS"Token Ring w/o FCS"Token Ring w/o FCS"FDDI + FCS"FDDI + FCS"FDDI w/o FCS"FDDI w/o FCS"802.6 + FCS"802.6 + FCS"802.6 w/o FCS"802.6 w/o FCS"BPDU"BPDU"bridged_valuesCDP"CDP"VTP"VTP"DTP"DTP"UDLD"UDLD"PVST"PVST"VLAN Bridge"VLAN Bridge"cisco_valuesReceiver Ready"Receiver Ready"Receiver not Ready"Receiver not Ready"Reject"Reject"llc_supervisory_valuesIndividual"Individual"Group"Group"llc_ig_flag_valuesllc_flag_values"ui"227test"test"xid"xid"ua"ua"disc"disc"dm"dm"sabme"sabme"frmr"frmr"llc_cmd_valuesGlobal"Global"802.1B I"802.1B I"802.1B G"802.1B G"SNA"SNA"ProWay NM"ProWay NM"STP"STP"RS511"RS511"ISO8208"ISO8208"ProWay"ProWay"NetBeui"NetBeui"llc_values/*
			 * What remains is an FDDI packet.
			 *//*
			 * Skip the padding.
			 *//*
			 * XXX - remove the last two bytes for
			 * PID_RFC2684_ETH_FCS?
			 *//*
			 * What remains is an 802.5 Token Ring
			 * packet.
			 *//*
			 * Skip the padding, but not the Access
			 * Control field.
			 *//*
			 * What remains is an Ethernet packet.
			 *//*
			 * No, I have no idea why Apple used one
			 * of their own OUIs, rather than
			 * 0x000000, and an Ethernet packet
			 * type, for Appletalk data packets,
			 * but used 0x000000 and an Ethernet
			 * packet type for AARP packets.
			 *//*
		 * This is an encapsulated Ethernet packet,
		 * or a packet bridged by some piece of
		 * Cisco hardware; the protocol ID is
		 * an Ethernet protocol type.
		 *//*
		 * XXX - what *is* the right bridge pad value here?
		 * Does anybody ever bridge one form of LAN traffic
		 * over a networking type that uses 802.2 LLC?
		 *//*
		 * Skip the LLC header.
		 *//*
		 * we don't actually have a full netbeui parser yet, but the
		 * smb parser can handle many smb-in-netbeui packets, which
		 * is very useful, so we call that
		 *
		 * We don't call it for S frames, however, just I frames
		 * (which are frames that don't have the low-order bit,
		 * LLC_S_FMT, set in the first byte of the control field)
		 * and UI frames (whose control field is just 3, LLC_U_FMT).
		 *//*
		 * This is an Ethernet_802.2 IPX frame, with an 802.3
		 * header and an 802.2 LLC header with the source and
		 * destination SAPs being the IPX SAP.
		 *
		 * Skip DSAP, LSAP, and control field.
		 *//*
		 * This is an Ethernet_802.3 IPX frame; it has an
		 * 802.3 header (i.e., an Ethernet header where the
		 * type/length field is <= ETHERMTU, i.e. it's a length
		 * field, not a type field), but has no 802.2 header -
		 * the IPX packet starts right after the Ethernet header,
		 * with a signature of two bytes of 0xFF (which is
		 * LLCSAP_GLOBAL).
		 *
		 * (It might also have been an Ethernet_802.3 IPX at
		 * one time, but got bridged onto another network,
		 * such as an 802.11 network; this has appeared in at
		 * least one capture file.)
		 *//*
		 * ...and is little-endian.
		 *//*
		 * The control field in I and S frames is
		 * 2 bytes...
		 *//*
		 * U frame.
		 *//*
	 * OK, what type of LLC frame is this?  The length
	 * of the control field depends on that - I frames
	 * have a two-byte control field, and U frames have
	 * a one-byte control field.
	 *//*
 * Returns non-zero IFF it succeeds in printing the header
 *//* bridged, RFC 2427 FR or RFC 2864 ATM *//* uses some Ethertype values *//*
 * Copyright (c) 1992, 1993, 1994, 1995, 1996, 1997
 *	The Regents of the University of California.  All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that: (1) source code distributions
 * retain the above copyright notice and this paragraph in its entirety, (2)
 * distributions including binary code include the above copyright notice and
 * this paragraph in its entirety in the documentation or other materials
 * provided with the distribution, and (3) all advertising materials mentioning
 * features or use of this software display the following acknowledgement:
 * ``This product includes software developed by the University of California,
 * Lawrence Berkeley Laboratory and its contributors.'' Neither the name of
 * the University nor the names of its contributors may be used to endorse
 * or promote products derived from this software without specific prior
 * written permission.
 * THIS SOFTWARE IS PROVIDED ``AS IS'' AND WITHOUT ANY EXPRESS OR IMPLIED
 * WARRANTIES, INCLUDING, WITHOUT LIMITATION, THE IMPLIED WARRANTIES OF
 * MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE.
 *
 * Code by Matt Thomas, Digital Equipment Corporation
 *	with an awful lot of hacking by Jeffrey Mogul, DECWRL
 *//Users/owura/Repos/codeql_eval/proj_repos/the-tcpdump-group-tcpdump-commit-0f95d441e4b5d7512cc5c326c8668a120e048eda/tcpdump/print-lldp.clldp_printcapena_capnetwork_addr(ndo, "LLDP, length %u", len)LLDP, length %usizeof(tlv)(ndo, "\n\t%s TLV (%u), length %u", tok2str(lldp_tlv_values, "Unknown", tlv_type), tlv_type, tlv_len)(ndo, "\n\t  Subtype %s (%u): ", tok2str(lldp_chassis_subtype_values, "Unknown", subtype), subtype)(ndo, "%s", etheraddr_string(ndo, tptr + 1))(ndo, "%s", network_addr)(ndo, "\n\t  Subtype %s (%u): ", tok2str(lldp_port_subtype_values, "Unknown", subtype), subtype)(ndo, ": TTL %us", EXTRACT_16BITS(tptr))(ndo, ": TTL %us", ((uint16_t)(((uint16_t)(*((const uint8_t *)(tptr) + 0)) << 8) | ((uint16_t)(*((const uint8_t *)(tptr) + 1)) << 0))))(ndo, "\n\t  System  Capabilities [%s] (0x%04x)", bittok2str(lldp_cap_values, "none", cap), cap)(ndo, "\n\t  Enabled Capabilities [%s] (0x%04x)", bittok2str(lldp_cap_values, "none", ena_cap), ena_cap)(ndo, ": OUI %s (0x%06x)", tok2str(oui_values, "Unknown", oui), oui)
	%s TLV (%u), length %uLLDP_CHASSIS_ID_TLV
	  Subtype %s (%u): LLDP_CHASSIS_MAC_ADDR_SUBTYPE1+6LLDP_CHASSIS_INTF_NAME_SUBTYPELLDP_CHASSIS_LOCAL_SUBTYPELLDP_CHASSIS_CHASSIS_COMP_SUBTYPELLDP_CHASSIS_INTF_ALIAS_SUBTYPELLDP_CHASSIS_PORT_COMP_SUBTYPELLDP_CHASSIS_NETWORK_ADDR_SUBTYPELLDP_PORT_ID_TLVLLDP_PORT_MAC_ADDR_SUBTYPELLDP_PORT_INTF_NAME_SUBTYPELLDP_PORT_LOCAL_SUBTYPELLDP_PORT_AGENT_CIRC_ID_SUBTYPELLDP_PORT_INTF_ALIAS_SUBTYPELLDP_PORT_PORT_COMP_SUBTYPELLDP_PORT_NETWORK_ADDR_SUBTYPELLDP_TTL_TLV: TTL %usLLDP_PORT_DESCR_TLVLLDP_SYSTEM_NAME_TLVLLDP_SYSTEM_DESCR_TLVLLDP_SYSTEM_CAP_TLV
	  System  Capabilities [%s] (0x%04x)
	  Enabled Capabilities [%s] (0x%04x)LLDP_MGMT_ADDR_TLVLLDP_PRIVATE_TLV: OUI %s (0x%06x)(ndo, "\n\t[|LLDP]")
	[|LLDP]lldp_mgmt_addr_tlv_printmgmt_addr_lenintf_num_subtypeoid_lenmgmt_addr(ndo, "\n\t  Management Address length %u, %s", mgmt_addr_len, mgmt_addr)
	  Management Address length %u, %sLLDP_INTF_NUM_LEN(ndo, "\n\t  %s Interface Numbering (%u): %u", tok2str(lldp_intf_numb_subtype_values, "Unknown", intf_num_subtype), intf_num_subtype, EXTRACT_32BITS(tptr + 1))(ndo, "\n\t  %s Interface Numbering (%u): %u", tok2str(lldp_intf_numb_subtype_values, "Unknown", intf_num_subtype), intf_num_subtype, ((uint32_t)(((uint32_t)(*((const uint8_t *)(tptr + 1) + 0)) << 24) | ((uint32_t)(*((const uint8_t *)(tptr + 1) + 1)) << 16) | ((uint32_t)(*((const uint8_t *)(tptr + 1) + 2)) << 8) | ((uint32_t)(*((const uint8_t *)(tptr + 1) + 3)) << 0))))
	  %s Interface Numbering (%u): %u(ndo, "\n\t  OID length %u", oid_len)
	  OID length %ulldp_network_addr_printpfunc"AFI %s (%u), no AF printer !", tok2str(af_values, "Unknown", af), af"AFI %s (%u): %s", tok2str(af_values, "Unknown", af), af, (*pfunc)(ndo, tptr+1)AFI %s (%u), no AF printer !AFI %s (%u): %slldp_private_dcbx_printtvalpgvaluvalmptr(ndo, "\n\t  %s Subtype (%u)", tok2str(lldp_dcbx_subtype_values, "unknown", subtype), subtype)
	  %s Subtype (%u)LLDP_DCBX_SUBTYPE_1(ndo, "\n\t    Control - Protocol Control (type 0x%x, length %d)", LLDP_DCBX_CONTROL_TLV, tlv_len)(ndo, "\n\t    Control - Protocol Control (type 0x%x, length %d)", 1, tlv_len)(ndo, "\n\t      Oper_Version: %d", *tptr)(ndo, "\n\t      Max_Version: %d", *(tptr + 1))(ndo, "\n\t      Sequence Number: %d", EXTRACT_32BITS(tptr + 2))(ndo, "\n\t      Sequence Number: %d", ((uint32_t)(((uint32_t)(*((const uint8_t *)(tptr + 2) + 0)) << 24) | ((uint32_t)(*((const uint8_t *)(tptr + 2) + 1)) << 16) | ((uint32_t)(*((const uint8_t *)(tptr + 2) + 2)) << 8) | ((uint32_t)(*((const uint8_t *)(tptr + 2) + 3)) << 0))))tptr + 2(ndo, "\n\t      Acknowledgement Number: %d", EXTRACT_32BITS(tptr + 6))(ndo, "\n\t      Acknowledgement Number: %d", ((uint32_t)(((uint32_t)(*((const uint8_t *)(tptr + 6) + 0)) << 24) | ((uint32_t)(*((const uint8_t *)(tptr + 6) + 1)) << 16) | ((uint32_t)(*((const uint8_t *)(tptr + 6) + 2)) << 8) | ((uint32_t)(*((const uint8_t *)(tptr + 6) + 3)) << 0))))(ndo, "\n\t    Feature - Priority Group (type 0x%x, length %d)", LLDP_DCBX_PRIORITY_GROUPS_TLV, tlv_len)(ndo, "\n\t    Feature - Priority Group (type 0x%x, length %d)", 2, tlv_len)(ndo, "\n\t      Info block(0x%02X): ", *(tptr + 2))(ndo, "Enable bit: %d, Willing bit: %d, Error Bit: %d", (tval & 0x80) ? 1 : 0, (tval & 0x40) ? 1 : 0, (tval & 0x20) ? 1 : 0)(ndo, "\n\t      SubType: %d", *(tptr + 3))(ndo, "\n\t      Priority Allocation")(ndo, "\n\t          PgId_%d: %d", i, (pgval >> (28 - 4 * i)) & 0xF)(ndo, "\n\t      Priority Group Allocation")(ndo, "\n\t          Pg percentage[%d]: %d", i, *(tptr + 8 + i))(ndo, "\n\t      NumTCsSupported: %d", *(tptr + 8 + 8))(ndo, "\n\t    Feature - Priority Flow Control")(ndo, " (type 0x%x, length %d)", LLDP_DCBX_PRIORITY_FLOW_CONTROL_TLV, tlv_len)(ndo, " (type 0x%x, length %d)", 3, tlv_len)(ndo, "\n\t      PFC Config (0x%02X)", *(tptr + 4))(ndo, "\n\t          Priority Bit %d: %s", i, (tval & (1 << i)) ? "Enabled" : "Disabled")(ndo, "\n\t      NumTCPFCSupported: %d", *(tptr + 5))(ndo, "\n\t    Feature - Application (type 0x%x, length %d)", LLDP_DCBX_APPLICATION_TLV, tlv_len)(ndo, "\n\t    Feature - Application (type 0x%x, length %d)", 4, tlv_len)(ndo, "\n\t      Application Value")(ndo, "\n\t          Application Protocol ID: 0x%04x", EXTRACT_16BITS(mptr))(ndo, "\n\t          Application Protocol ID: 0x%04x", ((uint16_t)(((uint16_t)(*((const uint8_t *)(mptr) + 0)) << 8) | ((uint16_t)(*((const uint8_t *)(mptr) + 1)) << 0))))mptr+2(ndo, "\n\t          SF (0x%x) Application Protocol ID is %s", (uval >> 22), (uval >> 22) ? "Socket Number" : "L2 EtherType")(ndo, "\n\t          OUI: 0x%06x", uval & 0x3fffff)(ndo, "\n\t          User Priority Map: 0x%02x", *(mptr + 5))LLDP_DCBX_CONTROL_TLV
	    Control - Protocol Control (type 0x%x, length %d)char[56]
	      Oper_Version: %d
	      Max_Version: %d
	      Sequence Number: %d
	      Acknowledgement Number: %dLLDP_DCBX_PRIORITY_GROUPS_TLV
	    Feature - Priority Group (type 0x%x, length %d)
	      Info block(0x%02X): Enable bit: %d, Willing bit: %d, Error Bit: %d
	      SubType: %d
	      Priority Allocation
	          PgId_%d: %d
	      Priority Group Allocation
	          Pg percentage[%d]: %d
	      NumTCsSupported: %dLLDP_DCBX_PRIORITY_FLOW_CONTROL_TLV
	    Feature - Priority Flow Control (type 0x%x, length %d)
	      PFC Config (0x%02X)
	          Priority Bit %d: %s
	      NumTCPFCSupported: %dLLDP_DCBX_APPLICATION_TLV
	    Feature - Application (type 0x%x, length %d)
	      Application Value
	          Application Protocol ID: 0x%04x
	          SF (0x%x) Application Protocol ID is %schar[52]Socket NumberL2 EtherType
	          OUI: 0x%06x4194303
	          User Priority Map: 0x%02xlldp_private_tia_printlocation_formatpower_vallci_lenca_typeca_len(ndo, "\n\t  %s Subtype (%u)", tok2str(lldp_tia_subtype_values, "unknown", subtype), subtype)(ndo, "\n\t    Media capabilities [%s] (0x%04x)", bittok2str(lldp_tia_capabilities_values, "none", EXTRACT_16BITS(tptr + 4)), EXTRACT_16BITS(tptr + 4))(ndo, "\n\t    Media capabilities [%s] (0x%04x)", bittok2str(lldp_tia_capabilities_values, "none", ((uint16_t)(((uint16_t)(*((const uint8_t *)(tptr + 4) + 0)) << 8) | ((uint16_t)(*((const uint8_t *)(tptr + 4) + 1)) << 0)))), ((uint16_t)(((uint16_t)(*((const uint8_t *)(tptr + 4) + 0)) << 8) | ((uint16_t)(*((const uint8_t *)(tptr + 4) + 1)) << 0))))(ndo, "\n\t    Device type [%s] (0x%02x)", tok2str(lldp_tia_device_type_values, "unknown", *(tptr+6)), *(tptr + 6))(ndo, "\n\t    Application type [%s] (0x%02x)", tok2str(lldp_tia_application_type_values, "none", *(tptr+4)), *(tptr + 4))(ndo, ", Flags [%s]", bittok2str( lldp_tia_network_policy_bits_values, "none", *(tptr + 5)))(ndo, "\n\t    Vlan id %u", LLDP_EXTRACT_NETWORK_POLICY_VLAN(EXTRACT_16BITS(tptr + 5)))(ndo, "\n\t    Vlan id %u", (((((uint16_t)(((uint16_t)(*((const uint8_t *)(tptr + 5) + 0)) << 8) | ((uint16_t)(*((const uint8_t *)(tptr + 5) + 1)) << 0))))&0x1ffe)>>1))EXTRACT_16BITS(tptr + 5)((uint16_t)(((uint16_t)(*((const uint8_t *)(tptr + 5) + 0)) << 8) | ((uint16_t)(*((const uint8_t *)(tptr + 5) + 1)) << 0)))tptr + 5(ndo, ", L2 priority %u", LLDP_EXTRACT_NETWORK_POLICY_L2_PRIORITY(EXTRACT_16BITS(tptr + 6)))(ndo, ", L2 priority %u", (((((uint16_t)(((uint16_t)(*((const uint8_t *)(tptr + 6) + 0)) << 8) | ((uint16_t)(*((const uint8_t *)(tptr + 6) + 1)) << 0))))&0x01ff)>>6))EXTRACT_16BITS(tptr + 6)((uint16_t)(((uint16_t)(*((const uint8_t *)(tptr + 6) + 0)) << 8) | ((uint16_t)(*((const uint8_t *)(tptr + 6) + 1)) << 0)))(ndo, ", DSCP value %u", LLDP_EXTRACT_NETWORK_POLICY_DSCP(EXTRACT_16BITS(tptr + 6)))(ndo, ", DSCP value %u", ((((uint16_t)(((uint16_t)(*((const uint8_t *)(tptr + 6) + 0)) << 8) | ((uint16_t)(*((const uint8_t *)(tptr + 6) + 1)) << 0))))&0x003f))(ndo, "\n\t    Location data format %s (0x%02x)", tok2str(lldp_tia_location_data_format_values, "unknown", location_format), location_format)(ndo, "\n\t    Latitude resolution %u, latitude value %" PRIu64, (*(tptr + 5) >> 2), lldp_extract_latlon(tptr + 5))(ndo, "\n\t    Latitude resolution %u, latitude value %" "ll" "u", (*(tptr + 5) >> 2), lldp_extract_latlon(tptr + 5))(ndo, "\n\t    Longitude resolution %u, longitude value %" PRIu64, (*(tptr + 10) >> 2), lldp_extract_latlon(tptr + 10))(ndo, "\n\t    Longitude resolution %u, longitude value %" "ll" "u", (*(tptr + 10) >> 2), lldp_extract_latlon(tptr + 10))(ndo, "\n\t    Altitude type %s (%u)", tok2str(lldp_tia_location_altitude_type_values, "unknown",(*(tptr+15)>>4)), (*(tptr + 15) >> 4))(ndo, "\n\t    Altitude resolution %u, altitude value 0x%x", (EXTRACT_16BITS(tptr+15)>>6)&0x3f, ((EXTRACT_32BITS(tptr + 16) & 0x3fffffff)))(ndo, "\n\t    Altitude resolution %u, altitude value 0x%x", (((uint16_t)(((uint16_t)(*((const uint8_t *)(tptr+15) + 0)) << 8) | ((uint16_t)(*((const uint8_t *)(tptr+15) + 1)) << 0)))>>6)&0x3f, ((((uint32_t)(((uint32_t)(*((const uint8_t *)(tptr + 16) + 0)) << 24) | ((uint32_t)(*((const uint8_t *)(tptr + 16) + 1)) << 16) | ((uint32_t)(*((const uint8_t *)(tptr + 16) + 2)) << 8) | ((uint32_t)(*((const uint8_t *)(tptr + 16) + 3)) << 0))) & 0x3fffffff)))tptr+15tptr + 16(ndo, "\n\t    Datum %s (0x%02x)", tok2str(lldp_tia_location_datum_type_values, "unknown", *(tptr+20)), *(tptr + 20))(ndo, "\n\t    LCI length %u, LCI what %s (0x%02x), Country-code ", lci_len, tok2str(lldp_tia_location_lci_what_values, "unknown", *(tptr+6)), *(tptr + 6))(ndo, "\n\t      CA type \'%s\' (%u), length %u: ", tok2str(lldp_tia_location_lci_catype_values, "unknown", ca_type), ca_type, ca_len)(ndo, "\n\t    ECS ELIN id ")(ndo, "\n\t    Location ID ")(ndo, "\n\t    Power type [%s]", (*(tptr + 4) & 0xC0 >> 6) ? "PD device" : "PSE device")(ndo, ", Power source [%s]", tok2str(lldp_tia_power_source_values, "none", (*(tptr + 4) & 0x30) >> 4))(ndo, "\n\t    Power priority [%s] (0x%02x)", tok2str(lldp_tia_power_priority_values, "none", *(tptr+4)&0x0f), *(tptr + 4) & 0x0f)tptr+5(ndo, ", Power %.1f Watts", ((float)power_val) / 10)(ndo, ", Power %u (Reserved)", power_val)(ndo, "\n\t  %s ", tok2str(lldp_tia_inventory_values, "unknown", subtype))LLDP_PRIVATE_TIA_SUBTYPE_CAPABILITIES
	    Media capabilities [%s] (0x%04x)
	    Device type [%s] (0x%02x)LLDP_PRIVATE_TIA_SUBTYPE_NETWORK_POLICY
	    Application type [%s] (0x%02x)
	    Vlan id %u8190, L2 priority %u, DSCP value %uLLDP_PRIVATE_TIA_SUBTYPE_LOCAL_ID
	    Location data format %s (0x%02x)LLDP_TIA_LOCATION_DATA_FORMAT_COORDINATE_BASED
	    Latitude resolution %u, latitude value %llu
	    Longitude resolution %u, longitude value %llu
	    Altitude type %s (%u)
	    Altitude resolution %u, altitude value 0x%x
	    Datum %s (0x%02x)LLDP_TIA_LOCATION_DATA_FORMAT_CIVIC_ADDRESS
	    LCI length %u, LCI what %s (0x%02x), Country-code 
	      CA type '%s' (%u), length %u: LLDP_TIA_LOCATION_DATA_FORMAT_ECS_ELIN
	    ECS ELIN id 
	    Location ID LLDP_PRIVATE_TIA_SUBTYPE_EXTENDED_POWER_MDI
	    Power type [%s]PD devicePSE device, Power source [%s]
	    Power priority [%s] (0x%02x)LLDP_TIA_POWER_VAL_MAX, Power %.1f Watts, Power %u (Reserved)LLDP_PRIVATE_TIA_SUBTYPE_INVENTORY_HARDWARE_REVLLDP_PRIVATE_TIA_SUBTYPE_INVENTORY_FIRMWARE_REVLLDP_PRIVATE_TIA_SUBTYPE_INVENTORY_SOFTWARE_REVLLDP_PRIVATE_TIA_SUBTYPE_INVENTORY_SERIAL_NUMBERLLDP_PRIVATE_TIA_SUBTYPE_INVENTORY_MANUFACTURER_NAMELLDP_PRIVATE_TIA_SUBTYPE_INVENTORY_MODEL_NAMELLDP_PRIVATE_TIA_SUBTYPE_INVENTORY_ASSET_ID
	  %s lldp_extract_latlonlatlontptr+1lldp_private_8023_print(ndo, "\n\t  %s Subtype (%u)", tok2str(lldp_8023_subtype_values, "unknown", subtype), subtype)(ndo, "\n\t    autonegotiation [%s] (0x%02x)", bittok2str(lldp_8023_autonegotiation_values, "none", *(tptr+4)), *(tptr + 4))(ndo, "\n\t    PMD autoneg capability [%s] (0x%04x)", bittok2str(lldp_pmd_capability_values,"unknown", EXTRACT_16BITS(tptr+5)), EXTRACT_16BITS(tptr + 5))(ndo, "\n\t    PMD autoneg capability [%s] (0x%04x)", bittok2str(lldp_pmd_capability_values,"unknown", ((uint16_t)(((uint16_t)(*((const uint8_t *)(tptr+5) + 0)) << 8) | ((uint16_t)(*((const uint8_t *)(tptr+5) + 1)) << 0)))), ((uint16_t)(((uint16_t)(*((const uint8_t *)(tptr + 5) + 0)) << 8) | ((uint16_t)(*((const uint8_t *)(tptr + 5) + 1)) << 0))))(ndo, "\n\t    MAU type %s (0x%04x)", tok2str(lldp_mau_types_values, "unknown", EXTRACT_16BITS(tptr+7)), EXTRACT_16BITS(tptr + 7))(ndo, "\n\t    MAU type %s (0x%04x)", tok2str(lldp_mau_types_values, "unknown", ((uint16_t)(((uint16_t)(*((const uint8_t *)(tptr+7) + 0)) << 8) | ((uint16_t)(*((const uint8_t *)(tptr+7) + 1)) << 0)))), ((uint16_t)(((uint16_t)(*((const uint8_t *)(tptr + 7) + 0)) << 8) | ((uint16_t)(*((const uint8_t *)(tptr + 7) + 1)) << 0))))tptr + 7(ndo, "\n\t    MDI power support [%s], power pair %s, power class %s", bittok2str(lldp_mdi_values, "none", *(tptr+4)), tok2str(lldp_mdi_power_pairs_values, "unknown", *(tptr+5)), tok2str(lldp_mdi_power_class_values, "unknown", *(tptr + 6)))(ndo, "\n\t    aggregation status [%s], aggregation port ID %u", bittok2str(lldp_aggregation_values, "none", *(tptr+4)), EXTRACT_32BITS(tptr + 5))(ndo, "\n\t    aggregation status [%s], aggregation port ID %u", bittok2str(lldp_aggregation_values, "none", *(tptr+4)), ((uint32_t)(((uint32_t)(*((const uint8_t *)(tptr + 5) + 0)) << 24) | ((uint32_t)(*((const uint8_t *)(tptr + 5) + 1)) << 16) | ((uint32_t)(*((const uint8_t *)(tptr + 5) + 2)) << 8) | ((uint32_t)(*((const uint8_t *)(tptr + 5) + 3)) << 0))))(ndo, "\n\t    MTU size %u", EXTRACT_16BITS(tptr + 4))(ndo, "\n\t    MTU size %u", ((uint16_t)(((uint16_t)(*((const uint8_t *)(tptr + 4) + 0)) << 8) | ((uint16_t)(*((const uint8_t *)(tptr + 4) + 1)) << 0))))LLDP_PRIVATE_8023_SUBTYPE_MACPHY
	    autonegotiation [%s] (0x%02x)
	    PMD autoneg capability [%s] (0x%04x)
	    MAU type %s (0x%04x)LLDP_PRIVATE_8023_SUBTYPE_MDIPOWER
	    MDI power support [%s], power pair %s, power class %sLLDP_PRIVATE_8023_SUBTYPE_LINKAGGR
	    aggregation status [%s], aggregation port ID %uLLDP_PRIVATE_8023_SUBTYPE_MTU
	    MTU size %ulldp_private_8021_print(ndo, "\n\t  %s Subtype (%u)", tok2str(lldp_8021_subtype_values, "unknown", subtype), subtype)(ndo, "\n\t    port vlan id (PVID): %u", EXTRACT_16BITS(tptr + 4))(ndo, "\n\t    port vlan id (PVID): %u", ((uint16_t)(((uint16_t)(*((const uint8_t *)(tptr + 4) + 0)) << 8) | ((uint16_t)(*((const uint8_t *)(tptr + 4) + 1)) << 0))))(ndo, "\n\t    port and protocol vlan id (PPVID): %u, flags [%s] (0x%02x)", EXTRACT_16BITS(tptr+5), bittok2str(lldp_8021_port_protocol_id_values, "none", *(tptr+4)), *(tptr + 4))(ndo, "\n\t    port and protocol vlan id (PPVID): %u, flags [%s] (0x%02x)", ((uint16_t)(((uint16_t)(*((const uint8_t *)(tptr+5) + 0)) << 8) | ((uint16_t)(*((const uint8_t *)(tptr+5) + 1)) << 0))), bittok2str(lldp_8021_port_protocol_id_values, "none", *(tptr+4)), *(tptr + 4))(ndo, "\n\t    vlan id (VID): %u", EXTRACT_16BITS(tptr + 4))(ndo, "\n\t    vlan id (VID): %u", ((uint16_t)(((uint16_t)(*((const uint8_t *)(tptr + 4) + 0)) << 8) | ((uint16_t)(*((const uint8_t *)(tptr + 4) + 1)) << 0))))(ndo, "\n\t    vlan name: ")(ndo, "\n\t    protocol identity: ")(ndo, "\n\t    Pre-Priority CNPV Indicator")(ndo, "\n\t     Priority : 0  1  2  3  4  5  6  7")(ndo, "\n\t     Value    : ")(ndo, "%-2d ", (tval >> i) & 0x01)(ndo, "\n\t    Pre-Priority Ready Indicator")(ndo, "\n\t    Willing:%d, CBS:%d, RES:%d, Max TCs:%d", tval >> 7, (tval >> 6) & 0x02, (tval >> 3) & 0x07, tval & 0x07)(ndo, "\n\t    RES: %d", *(tptr + 4))(ndo, "\n\t    Willing: %d, MBC: %d, RES: %d, PFC cap:%d ", tval >> 7, (tval >> 6) & 0x01, (tval >> 4) & 0x03, (tval & 0x0f))(ndo, "\n\t    PFC Enable")(ndo, "\n\t    Application Priority Table")(ndo, "\n\t      Priority: %d, RES: %d, Sel: %d", tval >> 5, (tval >> 3) & 0x03, (tval & 0x07))(ndo, "Protocol ID: %d", EXTRACT_16BITS(tptr + i + 5))(ndo, "Protocol ID: %d", ((uint16_t)(((uint16_t)(*((const uint8_t *)(tptr + i + 5) + 0)) << 8) | ((uint16_t)(*((const uint8_t *)(tptr + i + 5) + 1)) << 0))))tptr + i + 5(ndo, "\n\t    EVB Bridge Status")(ndo, "\n\t      RES: %d, BGID: %d, RRCAP: %d, RRCTR: %d", tval >> 3, (tval >> 2) & 0x01, (tval >> 1) & 0x01, tval & 0x01)(ndo, "\n\t    EVB Station Status")(ndo, "\n\t      RES: %d, SGID: %d, RRREQ: %d,RRSTAT: %d", tval >> 4, (tval >> 3) & 0x01, (tval >> 2) & 0x01, tval & 0x03)(ndo, "\n\t    R: %d, RTE: %d, ",tval >> 5, tval & 0x1f)(ndo, "EVB Mode: %s [%d]", tok2str(lldp_evb_mode_values, "unknown", tval >> 6), tval >> 6)(ndo, "\n\t    ROL: %d, RWD: %d, ", (tval >> 5) & 0x01, tval & 0x1f)(ndo, "RES: %d, ROL: %d, RKA: %d", tval >> 6, (tval >> 5) & 0x01, tval & 0x1f)(ndo, "\n\t    Role: %d, RES: %d, Scomp: %d ", tval >> 7, (tval >> 4) & 0x07, (tval >> 3) & 0x01)(ndo, "ChnCap: %d", EXTRACT_16BITS(tptr + 6) & 0x0fff)(ndo, "ChnCap: %d", ((uint16_t)(((uint16_t)(*((const uint8_t *)(tptr + 6) + 0)) << 8) | ((uint16_t)(*((const uint8_t *)(tptr + 6) + 1)) << 0))) & 0x0fff)tptr+i+8(ndo, "\n\t    SCID: %d, SVID: %d", tval >> 12, tval & 0x000fff)LLDP_PRIVATE_8021_SUBTYPE_PORT_VLAN_ID
	    port vlan id (PVID): %uLLDP_PRIVATE_8021_SUBTYPE_PROTOCOL_VLAN_ID
	    port and protocol vlan id (PPVID): %u, flags [%s] (0x%02x)LLDP_PRIVATE_8021_SUBTYPE_VLAN_NAME
	    vlan id (VID): %u
	    vlan name: LLDP_PRIVATE_8021_SUBTYPE_PROTOCOL_IDENTITY
	    protocol identity: LLDP_PRIVATE_8021_SUBTYPE_CONGESTION_NOTIFICATIONLLDP_PRIVATE_8021_SUBTYPE_CONGESTION_NOTIFICATION_LENGTH
	    Pre-Priority CNPV Indicator
	     Priority : 0  1  2  3  4  5  6  7
	     Value    : NO_OF_BITS%-2d 
	    Pre-Priority Ready IndicatorLLDP_PRIVATE_8021_SUBTYPE_ETS_CONFIGURATIONLLDP_PRIVATE_8021_SUBTYPE_ETS_CONFIGURATION_LENGTH
	    Willing:%d, CBS:%d, RES:%d, Max TCs:%dLLDP_PRIVATE_8021_SUBTYPE_ETS_RECOMMENDATIONLLDP_PRIVATE_8021_SUBTYPE_ETS_RECOMMENDATION_LENGTH
	    RES: %dLLDP_PRIVATE_8021_SUBTYPE_PFC_CONFIGURATIONLLDP_PRIVATE_8021_SUBTYPE_PFC_CONFIGURATION_LENGTH
	    Willing: %d, MBC: %d, RES: %d, PFC cap:%d 
	    PFC EnableLLDP_PRIVATE_8021_SUBTYPE_APPLICATION_PRIORITYLLDP_PRIVATE_8021_SUBTYPE_APPLICATION_PRIORITY_MIN_LENGTH
	    Application Priority Table
	      Priority: %d, RES: %d, Sel: %dProtocol ID: %dLLDP_PRIVATE_8021_SUBTYPE_EVBLLDP_PRIVATE_8021_SUBTYPE_EVB_LENGTH
	    EVB Bridge Status
	      RES: %d, BGID: %d, RRCAP: %d, RRCTR: %d
	    EVB Station Status
	      RES: %d, SGID: %d, RRREQ: %d,RRSTAT: %d
	    R: %d, RTE: %d, EVB Mode: %s [%d]
	    ROL: %d, RWD: %d, RES: %d, ROL: %d, RKA: %dLLDP_PRIVATE_8021_SUBTYPE_CDCPLLDP_PRIVATE_8021_SUBTYPE_CDCP_MIN_LENGTH
	    Role: %d, RES: %d, Scomp: %d ChnCap: %d
	    SCID: %d, SVID: %dprint_tsa_assignment_table(ndo, "\n\t    TSA Assignment Table")
	    TSA Assignment Table(ndo, "\n\t     Traffic Class: 0   1   2   3   4   5   6   7")
	     Traffic Class: 0   1   2   3   4   5   6   7(ndo, "\n\t     Value        : %-3d %-3d %-3d %-3d %-3d %-3d %-3d %-3d", ptr[0], ptr[1], ptr[2], ptr[3], ptr[4], ptr[5], ptr[6], ptr[7])
	     Value        : %-3d %-3d %-3d %-3d %-3d %-3d %-3d %-3dprint_tc_bandwidth_table(ndo, "\n\t    TC Bandwidth Table")
	    TC Bandwidth Table(ndo, "\n\t     TC%%   : 0   1   2   3   4   5   6   7")
	     TC%%   : 0   1   2   3   4   5   6   7(ndo, "\n\t     Value : %-3d %-3d %-3d %-3d %-3d %-3d %-3d %-3d", ptr[0], ptr[1], ptr[2], ptr[3], ptr[4], ptr[5], ptr[6], ptr[7])
	     Value : %-3d %-3d %-3d %-3d %-3d %-3d %-3d %-3dprint_ets_priority_assignment_table(ndo, "\n\t    Priority Assignment Table")
	    Priority Assignment Table(ndo, "\n\t     Priority : 0   1   2   3   4   5   6   7")
	     Priority : 0   1   2   3   4   5   6   7(ndo, "\n\t     Value    : %-3d %-3d %-3d %-3d %-3d %-3d %-3d %-3d", ptr[0]>>4,ptr[0]&0x0f,ptr[1]>>4,ptr[1]&0x0f,ptr[2]>>4, ptr[2] & 0x0f, ptr[3] >> 4, ptr[3] & 0x0f)
	     Value    : %-3d %-3d %-3d %-3d %-3d %-3d %-3d %-3dLLDP_EVB_MODE_NOT_SUPPORTEDNot Supported"Not Supported"LLDP_EVB_MODE_EVB_BRIDGEEVB Bridge"EVB Bridge"LLDP_EVB_MODE_EVB_STATIONEVB Staion"EVB Staion"LLDP_EVB_MODE_RESERVEDReserved for future Standardization"Reserved for future Standardization"lldp_evb_mode_valuesLLDP_INTF_NUMB_IFX_SUBTYPEInterface Index"Interface Index"LLDP_INTF_NUMB_SYSPORT_SUBTYPESystem Port Number"System Port Number"lldp_intf_numb_subtype_valuesDCB Capability Exchange Protocol Rev 1"DCB Capability Exchange Protocol Rev 1"LLDP_DCBX_SUBTYPE_2DCB Capability Exchange Protocol Rev 1.01"DCB Capability Exchange Protocol Rev 1.01"lldp_dcbx_subtype_valuesLLDP_AGGREGATION_CAPABILTIYsupported"supported"LLDP_AGGREGATION_STATUSenabled"enabled"lldp_aggregation_valuesLLDP_MDI_POWER_CLASS0class0"class0"LLDP_MDI_POWER_CLASS1class1"class1"LLDP_MDI_POWER_CLASS2class2"class2"LLDP_MDI_POWER_CLASS3class3"class3"LLDP_MDI_POWER_CLASS4class4"class4"lldp_mdi_power_class_valuesLLDP_MDI_PSE_PORT_POWER_PAIRS_SIGNALsignal"signal"LLDP_MDI_PSE_PORT_POWER_PAIRS_SPAREspare"spare"lldp_mdi_power_pairs_valuesLLDP_MDI_PORT_CLASSPSE"PSE"LLDP_MDI_POWER_SUPPORTLLDP_MDI_POWER_STATELLDP_MDI_PAIR_CONTROL_ABILITYcan be controlled"can be controlled"lldp_mdi_valuesLLDP_MAU_PMD_10BASE_T10BASE-T hdx"10BASE-T hdx"LLDP_MAU_PMD_10BASE_T_FD10BASE-T fdx"10BASE-T fdx"LLDP_MAU_PMD_100BASE_T4100BASE-T4"100BASE-T4"LLDP_MAU_PMD_100BASE_TX100BASE-TX hdx"100BASE-TX hdx"LLDP_MAU_PMD_100BASE_TX_FD100BASE-TX fdx"100BASE-TX fdx"LLDP_MAU_PMD_100BASE_T2100BASE-T2 hdx"100BASE-T2 hdx"LLDP_MAU_PMD_100BASE_T2_FD100BASE-T2 fdx"100BASE-T2 fdx"LLDP_MAU_PMD_FDXPAUSEPause for fdx links"Pause for fdx links"LLDP_MAU_PMD_FDXAPAUSEAsym PAUSE for fdx"Asym PAUSE for fdx"LLDP_MAU_PMD_FDXSPAUSESym PAUSE for fdx"Sym PAUSE for fdx"LLDP_MAU_PMD_FDXBPAUSEAsym and Sym PAUSE for fdx"Asym and Sym PAUSE for fdx"LLDP_MAU_PMD_1000BASE_X1000BASE-{X LX SX CX} hdx"1000BASE-{X LX SX CX} hdx"LLDP_MAU_PMD_1000BASE_X_FD1000BASE-{X LX SX CX} fdx"1000BASE-{X LX SX CX} fdx"LLDP_MAU_PMD_1000BASE_T1000BASE-T hdx"1000BASE-T hdx"LLDP_MAU_PMD_1000BASE_T_FD1000BASE-T fdx"1000BASE-T fdx"lldp_pmd_capability_valuesHardware revision"Hardware revision"Firmware revision"Firmware revision"Software revision"Software revision"Serial number"Serial number"Manufacturer name"Manufacturer name"Model name"Model name"Asset ID"Asset ID"lldp_tia_inventory_valuesLLDP_TIA_POWER_PRIORITY_CRITICAL"critical"LLDP_TIA_POWER_PRIORITY_HIGHhigh"high"LLDP_TIA_POWER_PRIORITY_LOWlow"low"lldp_tia_power_priority_valuesLLDP_TIA_POWER_SOURCE_PSEPSE - primary power source"PSE - primary power source"LLDP_TIA_POWER_SOURCE_LOCALlocal - backup power source"local - backup power source"LLDP_TIA_POWER_SOURCE_PSE_AND_LOCALPSE+local - reserved"PSE+local - reserved"lldp_tia_power_source_valuesLLDP_TIA_LOCATION_DATUM_WGS_84World Geodesic System 1984"World Geodesic System 1984"LLDP_TIA_LOCATION_DATUM_NAD_83_NAVD_88North American Datum 1983 (NAVD88)"North American Datum 1983 (NAVD88)"LLDP_TIA_LOCATION_DATUM_NAD_83_MLLWNorth American Datum 1983 (MLLW)"North American Datum 1983 (MLLW)"lldp_tia_location_datum_type_valuescoordinate-based LCI"coordinate-based LCI"civic address LCI"civic address LCI"ECS ELIN"ECS ELIN"lldp_tia_location_data_format_valuesLLDP_TIA_NETWORK_POLICY_U_BITLLDP_TIA_NETWORK_POLICY_T_BITTagged"Tagged"LLDP_TIA_NETWORK_POLICY_X_BITlldp_tia_network_policy_bits_valuesLLDP_TIA_APPLICATION_TYPE_VOICEvoice"voice"LLDP_TIA_APPLICATION_TYPE_VOICE_SIGNALINGvoice signaling"voice signaling"LLDP_TIA_APPLICATION_TYPE_GUEST_VOICEguest voice"guest voice"LLDP_TIA_APPLICATION_TYPE_GUEST_VOICE_SIGNALINGguest voice signaling"guest voice signaling"LLDP_TIA_APPLICATION_TYPE_SOFTPHONE_VOICEsoftphone voice"softphone voice"LLDP_TIA_APPLICATION_TYPE_VIDEO_CONFERENCINGvideo conferencing"video conferencing"LLDP_TIA_APPLICATION_TYPE_STREAMING_VIDEOstreaming video"streaming video"LLDP_TIA_APPLICATION_TYPE_VIDEO_SIGNALINGvideo signaling"video signaling"lldp_tia_application_type_valuesLLDP_TIA_DEVICE_TYPE_ENDPOINT_CLASS_1endpoint class 1"endpoint class 1"LLDP_TIA_DEVICE_TYPE_ENDPOINT_CLASS_2endpoint class 2"endpoint class 2"LLDP_TIA_DEVICE_TYPE_ENDPOINT_CLASS_3endpoint class 3"endpoint class 3"LLDP_TIA_DEVICE_TYPE_NETWORK_CONNECTIVITYnetwork connectivity"network connectivity"lldp_tia_device_type_valuesLLDP_TIA_CAPABILITY_MEDLLDP-MED capabilities"LLDP-MED capabilities"LLDP_TIA_CAPABILITY_NETWORK_POLICYnetwork policy"network policy"LLDP_TIA_CAPABILITY_LOCATION_IDENTIFICATIONlocation identification"location identification"LLDP_TIA_CAPABILITY_EXTENDED_POWER_MDI_PSEextended power via MDI-PSE"extended power via MDI-PSE"LLDP_TIA_CAPABILITY_EXTENDED_POWER_MDI_PDextended power via MDI-PD"extended power via MDI-PD"LLDP_TIA_CAPABILITY_INVENTORYInventory"Inventory"lldp_tia_capabilities_valuesLLDP_8023_AUTONEGOTIATION_SUPPORTLLDP_8023_AUTONEGOTIATION_STATUSlldp_8023_autonegotiation_valuesLLDP_MAU_TYPE_UNKNOWNLLDP_MAU_TYPE_AUIAUI"AUI"LLDP_MAU_TYPE_10BASE_510BASE_5"10BASE_5"LLDP_MAU_TYPE_FOIRLFOIRL"FOIRL"LLDP_MAU_TYPE_10BASE_210BASE2"10BASE2"LLDP_MAU_TYPE_10BASE_T10BASET duplex mode unknown"10BASET duplex mode unknown"LLDP_MAU_TYPE_10BASE_FP10BASEFP"10BASEFP"LLDP_MAU_TYPE_10BASE_FB10BASEFB"10BASEFB"LLDP_MAU_TYPE_10BASE_FL10BASEFL duplex mode unknown"10BASEFL duplex mode unknown"LLDP_MAU_TYPE_10BROAD3610BROAD36"10BROAD36"LLDP_MAU_TYPE_10BASE_T_HD10BASET hdx"10BASET hdx"LLDP_MAU_TYPE_10BASE_T_FD10BASET fdx"10BASET fdx"LLDP_MAU_TYPE_10BASE_FL_HD10BASEFL hdx"10BASEFL hdx"LLDP_MAU_TYPE_10BASE_FL_FD10BASEFL fdx"10BASEFL fdx"LLDP_MAU_TYPE_100BASE_T4100BASET4"100BASET4"LLDP_MAU_TYPE_100BASE_TX_HD100BASETX hdx"100BASETX hdx"LLDP_MAU_TYPE_100BASE_TX_FD100BASETX fdx"100BASETX fdx"LLDP_MAU_TYPE_100BASE_FX_HD100BASEFX hdx"100BASEFX hdx"LLDP_MAU_TYPE_100BASE_FX_FD100BASEFX fdx"100BASEFX fdx"LLDP_MAU_TYPE_100BASE_T2_HD100BASET2 hdx"100BASET2 hdx"LLDP_MAU_TYPE_100BASE_T2_FD100BASET2 fdx"100BASET2 fdx"LLDP_MAU_TYPE_1000BASE_X_HD1000BASEX hdx"1000BASEX hdx"LLDP_MAU_TYPE_1000BASE_X_FD1000BASEX fdx"1000BASEX fdx"LLDP_MAU_TYPE_1000BASE_LX_HD1000BASELX hdx"1000BASELX hdx"LLDP_MAU_TYPE_1000BASE_LX_FD1000BASELX fdx"1000BASELX fdx"LLDP_MAU_TYPE_1000BASE_SX_HD1000BASESX hdx"1000BASESX hdx"LLDP_MAU_TYPE_1000BASE_SX_FD1000BASESX fdx"1000BASESX fdx"LLDP_MAU_TYPE_1000BASE_CX_HD1000BASECX hdx"1000BASECX hdx"LLDP_MAU_TYPE_1000BASE_CX_FD1000BASECX fdx"1000BASECX fdx"LLDP_MAU_TYPE_1000BASE_T_HD1000BASET hdx"1000BASET hdx"LLDP_MAU_TYPE_1000BASE_T_FD1000BASET fdx"1000BASET fdx"LLDP_MAU_TYPE_10GBASE_X10GBASEX"10GBASEX"LLDP_MAU_TYPE_10GBASE_LX410GBASELX4"10GBASELX4"LLDP_MAU_TYPE_10GBASE_R10GBASER"10GBASER"LLDP_MAU_TYPE_10GBASE_ER10GBASEER"10GBASEER"LLDP_MAU_TYPE_10GBASE_LR10GBASELR"10GBASELR"LLDP_MAU_TYPE_10GBASE_SR10GBASESR"10GBASESR"LLDP_MAU_TYPE_10GBASE_W10GBASEW"10GBASEW"LLDP_MAU_TYPE_10GBASE_EW10GBASEEW"10GBASEEW"LLDP_MAU_TYPE_10GBASE_LW10GBASELW"10GBASELW"LLDP_MAU_TYPE_10GBASE_SW10GBASESW"10GBASESW"lldp_mau_types_valueslocation of DHCP server"location of DHCP server"location of the network element believed to be closest to the client"location of the network element believed to be closest to the client"location of the client"location of the client"lldp_tia_location_lci_what_valuesLLDP_PRIVATE_TIA_LOCATION_LCI_CATYPE_A1national subdivisions (state,canton,region,province,prefecture)"national subdivisions (state,canton,region,province,prefecture)"LLDP_PRIVATE_TIA_LOCATION_LCI_CATYPE_A2county, parish, gun, district"county, parish, gun, district"LLDP_PRIVATE_TIA_LOCATION_LCI_CATYPE_A3city, township, shi"city, township, shi"LLDP_PRIVATE_TIA_LOCATION_LCI_CATYPE_A4city division, borough, city district, ward chou"city division, borough, city district, ward chou"LLDP_PRIVATE_TIA_LOCATION_LCI_CATYPE_A5neighborhood, block"neighborhood, block"LLDP_PRIVATE_TIA_LOCATION_LCI_CATYPE_A6street"street"lldp_tia_location_lci_catype_valuesLLDP_PRIVATE_TIA_LOCATION_ALTITUDE_METERSmeters"meters"LLDP_PRIVATE_TIA_LOCATION_ALTITUDE_FLOORSfloors"floors"lldp_tia_location_altitude_type_valuesLLDP-MED Capabilities"LLDP-MED Capabilities"Network policy"Network policy"Location identification"Location identification"Extended power-via-MDI"Extended power-via-MDI"Inventory - hardware revision"Inventory - hardware revision"Inventory - firmware revision"Inventory - firmware revision"Inventory - software revision"Inventory - software revision"Inventory - serial number"Inventory - serial number"Inventory - manufacturer name"Inventory - manufacturer name"Inventory - model name"Inventory - model name"Inventory - asset ID"Inventory - asset ID"lldp_tia_subtype_valuesMAC/PHY configuration/status"MAC/PHY configuration/status"Power via MDI"Power via MDI"Link aggregation"Link aggregation"Max frame size"Max frame size"lldp_8023_subtype_valuesLLDP_8021_PORT_PROTOCOL_VLAN_SUPPORTLLDP_8021_PORT_PROTOCOL_VLAN_STATUSlldp_8021_port_protocol_id_valuesPort VLAN Id"Port VLAN Id"Port and Protocol VLAN ID"Port and Protocol VLAN ID"VLAN name"VLAN name"Protocol Identity"Protocol Identity"Congestion Notification"Congestion Notification"ETS Configuration"ETS Configuration"ETS Recommendation"ETS Recommendation"Priority Flow Control Configuration"Priority Flow Control Configuration"Application Priority"Application Priority"EVB"EVB"CDCP"CDCP"lldp_8021_subtype_valuesLLDP_CAP_OTHEROther"Other"LLDP_CAP_REPEATERRepeater"Repeater"LLDP_CAP_BRIDGEBridge"Bridge"LLDP_CAP_WLAN_APWLAN AP"WLAN AP"LLDP_CAP_ROUTERLLDP_CAP_PHONETelephone"Telephone"LLDP_CAP_DOCSISDocsis"Docsis"LLDP_CAP_STATION_ONLYStation Only"Station Only"lldp_cap_valuesNetwork Address"Network Address"Interface Name"Interface Name"Agent circuit ID"Agent circuit ID"Local"Local"lldp_port_subtype_valueslldp_chassis_subtype_valuesLLDP_END_TLVChassis ID"Chassis ID"Port ID"Port ID"Time to Live"Time to Live"Port Description"Port Description"System Description"System Description"System Capabilities"System Capabilities"Management Address"Management Address"Organization specific"Organization specific"lldp_tlv_values(1 << 1)(1 << 0)(1 << 8)(1 << 9)(1 << 10)(1 << 11)(1 << 12)(1 << 13)(1 << 14)LLDP_MAU_PMD_OTHER(1 << 15)LLDP_EXTRACT_NETWORK_POLICY_DSCP(x)((x)&0x003f)LLDP_EXTRACT_NETWORK_POLICY_L2_PRIORITY(x)(((x)&0x01ff)>>6)LLDP_EXTRACT_NETWORK_POLICY_VLAN(x)(((x)&0x1ffe)>>1)LLDP_EXTRACT_LEN(x)((x)&0x01ff)LLDP_EXTRACT_TYPE(x)(((x)&0xfe00)>>9)/* do we also want to see a hex dump ? *//*
                 * XXX - IEEE Std 802.1AB-2009 says the first octet
                 * if a chassis ID subtype, with the system
                 * capabilities and enabled capabilities following
                 * it.
                 *//*
             * The system name is also print in non-verbose mode
             * similar to the CDP printer.
             *//*
     * The OID is optional.
     *//*
	     * Array of 8 4-bit priority group ID values; we fetch all
	     * 32 bits and extract each nibble.
	     *//* decode every tlv *//* loop check *//* by passing old version *//*
 * Print DCBX Protocol fields (V 1.01).
 *//* basic sanity check *//* Decode each civic address element *//* Country code *//*
 * Print private TIA extensions.
 *//*
 * Extract 34bits of latitude/longitude coordinates.
 *//*
 * Print IEEE 802.3 private extensions. (802.3bc)
 *//*  Length of Application Priority Table *//* Print TSA Assignment Table *//*Print TC Bandwidth Table *//*Print Priority Assignment Table *//*Print TC Bandwidth Table*//*Print Priority Assignment Table*//*
 * Print IEEE 802.1 private extensions. (802.1AB annex E)
 *//*
 * Interface numbering subtypes.
 *//*
 * DCBX protocol subtypes.
 *//*
 * From RFC 3636 - ifMauAutoNegCapAdvertisedBits
 *//*
 * From RFC 3636 - dot3MauType
 *//* ANSI/TIA-1057 - Annex B *//*
 * System Capabilities
 *//*
 * Port ID subtypes
 *//*
 * Chassis ID subtypes
 *//*
 * TLV type codes
 *//*
 * Copyright (c) 1998-2007 The TCPDUMP project
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that: (1) source code
 * distributions retain the above copyright notice and this paragraph
 * in its entirety, and (2) distributions including binary code include
 * the above copyright notice and this paragraph in its entirety in
 * the documentation or other materials provided with the distribution.
 * THIS SOFTWARE IS PROVIDED ``AS IS'' AND
 * WITHOUT ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, WITHOUT
 * LIMITATION, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS
 * FOR A PARTICULAR PURPOSE.
 *
 * support for the IEEE Link Discovery Protocol as per 802.1AB
 *
 * Original code by Hannes Gredler (hannes@juniper.net)
 * IEEE and TIA extensions by Carles Kishimoto <carles.kishimoto@gmail.com>
 * DCBX extensions by Kaladhar Musunuru <kaladharm@sourceforge.net>
 *//Users/owura/Repos/codeql_eval/proj_repos/the-tcpdump-group-tcpdump-commit-0f95d441e4b5d7512cc5c326c8668a120e048eda/tcpdump/print-lmp.clmp_printconst lmp_common_headerconst lmp_common_header *lmp_common_header *lmp_com_headerconst lmp_object_headerconst lmp_object_header *lmp_object_header *lmp_obj_headerlmp_obj_lenlmp_obj_ctypesubobj_typesubobj_lentotal_subobj_lenlink_type*lmp_com_headersizeof(*lmp_com_header)lmp_com_header->version_res[0](ndo, "LMP version %u packet not supported", LMP_EXTRACT_VERSION(lmp_com_header->version_res[0]))(ndo, "LMP version %u packet not supported", (((lmp_com_header->version_res[0])&0xf0)>>4))LMP_VERSIONLMP version %u packet not supported(ndo, "LMPv%u %s Message, length: %u", LMP_EXTRACT_VERSION(lmp_com_header->version_res[0]), tok2str(lmp_msg_type_values, "unknown (%u)",lmp_com_header->msg_type), len)(ndo, "LMPv%u %s Message, length: %u", (((lmp_com_header->version_res[0])&0xf0)>>4), tok2str(lmp_msg_type_values, "unknown (%u)",lmp_com_header->msg_type), len)LMPv%u %s Message, length: %uconst tok[24]tok[24]lmp_com_header->length(ndo, "\n\tLMPv%u, msg-type: %s, Flags: [%s], length: %u", LMP_EXTRACT_VERSION(lmp_com_header->version_res[0]), tok2str(lmp_msg_type_values, "unknown, type: %u",lmp_com_header->msg_type), bittok2str(lmp_header_flag_values,"none",lmp_com_header->flags), tlen)(ndo, "\n\tLMPv%u, msg-type: %s, Flags: [%s], length: %u", (((lmp_com_header->version_res[0])&0xf0)>>4), tok2str(lmp_msg_type_values, "unknown, type: %u",lmp_com_header->msg_type), bittok2str(lmp_header_flag_values,"none",lmp_com_header->flags), tlen)
	LMPv%u, msg-type: %s, Flags: [%s], length: %usizeof(const struct lmp_common_header)sizeof(struct lmp_object_header)lmp_obj_header->length(ndo, "\n\t  %s Object (%u), Class-Type: %s (%u) Flags: [%snegotiable], length: %u", tok2str(lmp_obj_values, "Unknown", lmp_obj_header->class_num), lmp_obj_header->class_num, tok2str(lmp_ctype_values, "Unknown", ((lmp_obj_header->class_num)<<8)+lmp_obj_ctype), lmp_obj_ctype, (lmp_obj_header->ctype)&0x80 ? "" : "non-", lmp_obj_len)(ndo, "\n\t    Control Channel ID: %u (0x%08x)", EXTRACT_32BITS(obj_tptr), EXTRACT_32BITS(obj_tptr))(ndo, "\n\t    Control Channel ID: %u (0x%08x)", ((uint32_t)(((uint32_t)(*((const uint8_t *)(obj_tptr) + 0)) << 24) | ((uint32_t)(*((const uint8_t *)(obj_tptr) + 1)) << 16) | ((uint32_t)(*((const uint8_t *)(obj_tptr) + 2)) << 8) | ((uint32_t)(*((const uint8_t *)(obj_tptr) + 3)) << 0))), ((uint32_t)(((uint32_t)(*((const uint8_t *)(obj_tptr) + 0)) << 24) | ((uint32_t)(*((const uint8_t *)(obj_tptr) + 1)) << 16) | ((uint32_t)(*((const uint8_t *)(obj_tptr) + 2)) << 8) | ((uint32_t)(*((const uint8_t *)(obj_tptr) + 3)) << 0))))(ndo, "\n\t    IPv4 Link ID: %s (0x%08x)", ipaddr_string(ndo, obj_tptr), EXTRACT_32BITS(obj_tptr))(ndo, "\n\t    IPv4 Link ID: %s (0x%08x)", getname(ndo, (const u_char *)(obj_tptr)), ((uint32_t)(((uint32_t)(*((const uint8_t *)(obj_tptr) + 0)) << 24) | ((uint32_t)(*((const uint8_t *)(obj_tptr) + 1)) << 16) | ((uint32_t)(*((const uint8_t *)(obj_tptr) + 2)) << 8) | ((uint32_t)(*((const uint8_t *)(obj_tptr) + 3)) << 0))))(ndo, "\n\t    Link ID: %u (0x%08x)", EXTRACT_32BITS(obj_tptr), EXTRACT_32BITS(obj_tptr))(ndo, "\n\t    Link ID: %u (0x%08x)", ((uint32_t)(((uint32_t)(*((const uint8_t *)(obj_tptr) + 0)) << 24) | ((uint32_t)(*((const uint8_t *)(obj_tptr) + 1)) << 16) | ((uint32_t)(*((const uint8_t *)(obj_tptr) + 2)) << 8) | ((uint32_t)(*((const uint8_t *)(obj_tptr) + 3)) << 0))), ((uint32_t)(((uint32_t)(*((const uint8_t *)(obj_tptr) + 0)) << 24) | ((uint32_t)(*((const uint8_t *)(obj_tptr) + 1)) << 16) | ((uint32_t)(*((const uint8_t *)(obj_tptr) + 2)) << 8) | ((uint32_t)(*((const uint8_t *)(obj_tptr) + 3)) << 0))))(ndo, "\n\t    Message ID: %u (0x%08x)", EXTRACT_32BITS(obj_tptr), EXTRACT_32BITS(obj_tptr))(ndo, "\n\t    Message ID: %u (0x%08x)", ((uint32_t)(((uint32_t)(*((const uint8_t *)(obj_tptr) + 0)) << 24) | ((uint32_t)(*((const uint8_t *)(obj_tptr) + 1)) << 16) | ((uint32_t)(*((const uint8_t *)(obj_tptr) + 2)) << 8) | ((uint32_t)(*((const uint8_t *)(obj_tptr) + 3)) << 0))), ((uint32_t)(((uint32_t)(*((const uint8_t *)(obj_tptr) + 0)) << 24) | ((uint32_t)(*((const uint8_t *)(obj_tptr) + 1)) << 16) | ((uint32_t)(*((const uint8_t *)(obj_tptr) + 2)) << 8) | ((uint32_t)(*((const uint8_t *)(obj_tptr) + 3)) << 0))))(ndo, "\n\t    Message ID Ack: %u (0x%08x)", EXTRACT_32BITS(obj_tptr), EXTRACT_32BITS(obj_tptr))(ndo, "\n\t    Message ID Ack: %u (0x%08x)", ((uint32_t)(((uint32_t)(*((const uint8_t *)(obj_tptr) + 0)) << 24) | ((uint32_t)(*((const uint8_t *)(obj_tptr) + 1)) << 16) | ((uint32_t)(*((const uint8_t *)(obj_tptr) + 2)) << 8) | ((uint32_t)(*((const uint8_t *)(obj_tptr) + 3)) << 0))), ((uint32_t)(((uint32_t)(*((const uint8_t *)(obj_tptr) + 0)) << 24) | ((uint32_t)(*((const uint8_t *)(obj_tptr) + 1)) << 16) | ((uint32_t)(*((const uint8_t *)(obj_tptr) + 2)) << 8) | ((uint32_t)(*((const uint8_t *)(obj_tptr) + 3)) << 0))))(ndo, "\n\t    Node ID: %s (0x%08x)", ipaddr_string(ndo, obj_tptr), EXTRACT_32BITS(obj_tptr))(ndo, "\n\t    Node ID: %s (0x%08x)", getname(ndo, (const u_char *)(obj_tptr)), ((uint32_t)(((uint32_t)(*((const uint8_t *)(obj_tptr) + 0)) << 24) | ((uint32_t)(*((const uint8_t *)(obj_tptr) + 1)) << 16) | ((uint32_t)(*((const uint8_t *)(obj_tptr) + 2)) << 8) | ((uint32_t)(*((const uint8_t *)(obj_tptr) + 3)) << 0))))(ndo, "\n\t    Hello Interval: %u\n\t    Hello Dead Interval: %u", EXTRACT_16BITS(obj_tptr), EXTRACT_16BITS(obj_tptr+2))(ndo, "\n\t    Hello Interval: %u\n\t    Hello Dead Interval: %u", ((uint16_t)(((uint16_t)(*((const uint8_t *)(obj_tptr) + 0)) << 8) | ((uint16_t)(*((const uint8_t *)(obj_tptr) + 1)) << 0))), ((uint16_t)(((uint16_t)(*((const uint8_t *)(obj_tptr+2) + 0)) << 8) | ((uint16_t)(*((const uint8_t *)(obj_tptr+2) + 1)) << 0))))obj_tptr+2(ndo, "\n\t    Tx Seq: %u, Rx Seq: %u", EXTRACT_32BITS(obj_tptr), EXTRACT_32BITS(obj_tptr+4))(ndo, "\n\t    Tx Seq: %u, Rx Seq: %u", ((uint32_t)(((uint32_t)(*((const uint8_t *)(obj_tptr) + 0)) << 24) | ((uint32_t)(*((const uint8_t *)(obj_tptr) + 1)) << 16) | ((uint32_t)(*((const uint8_t *)(obj_tptr) + 2)) << 8) | ((uint32_t)(*((const uint8_t *)(obj_tptr) + 3)) << 0))), ((uint32_t)(((uint32_t)(*((const uint8_t *)(obj_tptr+4) + 0)) << 24) | ((uint32_t)(*((const uint8_t *)(obj_tptr+4) + 1)) << 16) | ((uint32_t)(*((const uint8_t *)(obj_tptr+4) + 2)) << 8) | ((uint32_t)(*((const uint8_t *)(obj_tptr+4) + 3)) << 0))))obj_tptr+4(ndo, "\n\t    Flags: [%s]", bittok2str(lmp_obj_te_link_flag_values, "none", EXTRACT_16BITS(obj_tptr)>>8))(ndo, "\n\t    Flags: [%s]", bittok2str(lmp_obj_te_link_flag_values, "none", ((uint16_t)(((uint16_t)(*((const uint8_t *)(obj_tptr) + 0)) << 8) | ((uint16_t)(*((const uint8_t *)(obj_tptr) + 1)) << 0)))>>8))(ndo, "\n\t    Local Link-ID: %s (0x%08x)" "\n\t    Remote Link-ID: %s (0x%08x)", ipaddr_string(ndo, obj_tptr+4), EXTRACT_32BITS(obj_tptr+4), ipaddr_string(ndo, obj_tptr+8), EXTRACT_32BITS(obj_tptr+8))(ndo, "\n\t    Local Link-ID: %s (0x%08x)" "\n\t    Remote Link-ID: %s (0x%08x)", getname(ndo, (const u_char *)(obj_tptr+4)), ((uint32_t)(((uint32_t)(*((const uint8_t *)(obj_tptr+4) + 0)) << 24) | ((uint32_t)(*((const uint8_t *)(obj_tptr+4) + 1)) << 16) | ((uint32_t)(*((const uint8_t *)(obj_tptr+4) + 2)) << 8) | ((uint32_t)(*((const uint8_t *)(obj_tptr+4) + 3)) << 0))), getname(ndo, (const u_char *)(obj_tptr+8)), ((uint32_t)(((uint32_t)(*((const uint8_t *)(obj_tptr+8) + 0)) << 24) | ((uint32_t)(*((const uint8_t *)(obj_tptr+8) + 1)) << 16) | ((uint32_t)(*((const uint8_t *)(obj_tptr+8) + 2)) << 8) | ((uint32_t)(*((const uint8_t *)(obj_tptr+8) + 3)) << 0))))obj_tptr+8(ndo, "\n\t    Flags: [%s]", bittok2str(lmp_obj_data_link_flag_values, "none", EXTRACT_16BITS(obj_tptr)>>8))(ndo, "\n\t    Flags: [%s]", bittok2str(lmp_obj_data_link_flag_values, "none", ((uint16_t)(((uint16_t)(*((const uint8_t *)(obj_tptr) + 0)) << 8) | ((uint16_t)(*((const uint8_t *)(obj_tptr) + 1)) << 0)))>>8))(ndo, "\n\t    Local Interface ID: %s (0x%08x)" "\n\t    Remote Interface ID: %s (0x%08x)", ipaddr_string(ndo, obj_tptr+4), EXTRACT_32BITS(obj_tptr+4), ipaddr_string(ndo, obj_tptr+8), EXTRACT_32BITS(obj_tptr+8))(ndo, "\n\t    Local Interface ID: %s (0x%08x)" "\n\t    Remote Interface ID: %s (0x%08x)", getname(ndo, (const u_char *)(obj_tptr+4)), ((uint32_t)(((uint32_t)(*((const uint8_t *)(obj_tptr+4) + 0)) << 24) | ((uint32_t)(*((const uint8_t *)(obj_tptr+4) + 1)) << 16) | ((uint32_t)(*((const uint8_t *)(obj_tptr+4) + 2)) << 8) | ((uint32_t)(*((const uint8_t *)(obj_tptr+4) + 3)) << 0))), getname(ndo, (const u_char *)(obj_tptr+8)), ((uint32_t)(((uint32_t)(*((const uint8_t *)(obj_tptr+8) + 0)) << 24) | ((uint32_t)(*((const uint8_t *)(obj_tptr+8) + 1)) << 16) | ((uint32_t)(*((const uint8_t *)(obj_tptr+8) + 2)) << 8) | ((uint32_t)(*((const uint8_t *)(obj_tptr+8) + 3)) << 0))))obj_tptr+offset(ndo, "\n\t    Subobject, Type: %s (%u), Length: %u", tok2str(lmp_data_link_subobj, "Unknown", subobj_type), subobj_type, subobj_len)(ndo, "\n\t      Switching Type: %s (%u)", tok2str(gmpls_switch_cap_values, "Unknown", EXTRACT_16BITS(obj_tptr+offset+2)>>8), EXTRACT_16BITS(obj_tptr+offset+2)>>8)(ndo, "\n\t      Switching Type: %s (%u)", tok2str(gmpls_switch_cap_values, "Unknown", ((uint16_t)(((uint16_t)(*((const uint8_t *)(obj_tptr+offset+2) + 0)) << 8) | ((uint16_t)(*((const uint8_t *)(obj_tptr+offset+2) + 1)) << 0)))>>8), ((uint16_t)(((uint16_t)(*((const uint8_t *)(obj_tptr+offset+2) + 0)) << 8) | ((uint16_t)(*((const uint8_t *)(obj_tptr+offset+2) + 1)) << 0)))>>8)obj_tptr+offset+2(ndo, "\n\t      Encoding Type: %s (%u)", tok2str(gmpls_encoding_values, "Unknown", EXTRACT_16BITS(obj_tptr+offset+2)&0x00FF), EXTRACT_16BITS(obj_tptr+offset+2)&0x00FF)(ndo, "\n\t      Encoding Type: %s (%u)", tok2str(gmpls_encoding_values, "Unknown", ((uint16_t)(((uint16_t)(*((const uint8_t *)(obj_tptr+offset+2) + 0)) << 8) | ((uint16_t)(*((const uint8_t *)(obj_tptr+offset+2) + 1)) << 0)))&0x00FF), ((uint16_t)(((uint16_t)(*((const uint8_t *)(obj_tptr+offset+2) + 0)) << 8) | ((uint16_t)(*((const uint8_t *)(obj_tptr+offset+2) + 1)) << 0)))&0x00FF)obj_tptr+offset+4(ndo, "\n\t      Min Reservable Bandwidth: %.3f Mbps", bw.f*8/1000000)obj_tptr+offset+8(ndo, "\n\t      Max Reservable Bandwidth: %.3f Mbps", bw.f*8/1000000)(ndo, "\n\t      Wavelength: %u", EXTRACT_32BITS(obj_tptr+offset+4))(ndo, "\n\t      Wavelength: %u", ((uint32_t)(((uint32_t)(*((const uint8_t *)(obj_tptr+offset+4) + 0)) << 24) | ((uint32_t)(*((const uint8_t *)(obj_tptr+offset+4) + 1)) << 16) | ((uint32_t)(*((const uint8_t *)(obj_tptr+offset+4) + 2)) << 8) | ((uint32_t)(*((const uint8_t *)(obj_tptr+offset+4) + 3)) << 0))))(ndo, "\n\t    Flags: %s", bittok2str(lmp_obj_begin_verify_flag_values, "none", EXTRACT_16BITS(obj_tptr)))(ndo, "\n\t    Flags: %s", bittok2str(lmp_obj_begin_verify_flag_values, "none", ((uint16_t)(((uint16_t)(*((const uint8_t *)(obj_tptr) + 0)) << 8) | ((uint16_t)(*((const uint8_t *)(obj_tptr) + 1)) << 0)))))(ndo, "\n\t    Verify Interval: %u", EXTRACT_16BITS(obj_tptr+2))(ndo, "\n\t    Verify Interval: %u", ((uint16_t)(((uint16_t)(*((const uint8_t *)(obj_tptr+2) + 0)) << 8) | ((uint16_t)(*((const uint8_t *)(obj_tptr+2) + 1)) << 0))))(ndo, "\n\t    Data links: %u", EXTRACT_32BITS(obj_tptr+4))(ndo, "\n\t    Data links: %u", ((uint32_t)(((uint32_t)(*((const uint8_t *)(obj_tptr+4) + 0)) << 24) | ((uint32_t)(*((const uint8_t *)(obj_tptr+4) + 1)) << 16) | ((uint32_t)(*((const uint8_t *)(obj_tptr+4) + 2)) << 8) | ((uint32_t)(*((const uint8_t *)(obj_tptr+4) + 3)) << 0))))(ndo, "\n\t    Encoding type: %s", tok2str(gmpls_encoding_values, "Unknown", *(obj_tptr+8)))(ndo, "\n\t    Verify Transport Mechanism: %u (0x%x)%s", EXTRACT_16BITS(obj_tptr+10), EXTRACT_16BITS(obj_tptr+10), EXTRACT_16BITS(obj_tptr+10)&8000 ? " (Payload test messages capable)" : "")(ndo, "\n\t    Verify Transport Mechanism: %u (0x%x)%s", ((uint16_t)(((uint16_t)(*((const uint8_t *)(obj_tptr+10) + 0)) << 8) | ((uint16_t)(*((const uint8_t *)(obj_tptr+10) + 1)) << 0))), ((uint16_t)(((uint16_t)(*((const uint8_t *)(obj_tptr+10) + 0)) << 8) | ((uint16_t)(*((const uint8_t *)(obj_tptr+10) + 1)) << 0))), ((uint16_t)(((uint16_t)(*((const uint8_t *)(obj_tptr+10) + 0)) << 8) | ((uint16_t)(*((const uint8_t *)(obj_tptr+10) + 1)) << 0)))&8000 ? " (Payload test messages capable)" : "")obj_tptr+10obj_tptr+12(ndo, "\n\t    Transmission Rate: %.3f Mbps",bw.f*8/1000000)(ndo, "\n\t    Wavelength: %u", EXTRACT_32BITS(obj_tptr+16))(ndo, "\n\t    Wavelength: %u", ((uint32_t)(((uint32_t)(*((const uint8_t *)(obj_tptr+16) + 0)) << 24) | ((uint32_t)(*((const uint8_t *)(obj_tptr+16) + 1)) << 16) | ((uint32_t)(*((const uint8_t *)(obj_tptr+16) + 2)) << 8) | ((uint32_t)(*((const uint8_t *)(obj_tptr+16) + 3)) << 0))))obj_tptr+16(ndo, "\n\t    Verify Dead Interval: %u" "\n\t    Verify Transport Response: %u", EXTRACT_16BITS(obj_tptr), EXTRACT_16BITS(obj_tptr+2))(ndo, "\n\t    Verify Dead Interval: %u" "\n\t    Verify Transport Response: %u", ((uint16_t)(((uint16_t)(*((const uint8_t *)(obj_tptr) + 0)) << 8) | ((uint16_t)(*((const uint8_t *)(obj_tptr) + 1)) << 0))), ((uint16_t)(((uint16_t)(*((const uint8_t *)(obj_tptr+2) + 0)) << 8) | ((uint16_t)(*((const uint8_t *)(obj_tptr+2) + 1)) << 0))))(ndo, "\n\t    Verify ID: %u", EXTRACT_32BITS(obj_tptr))(ndo, "\n\t    Verify ID: %u", ((uint32_t)(((uint32_t)(*((const uint8_t *)(obj_tptr) + 0)) << 24) | ((uint32_t)(*((const uint8_t *)(obj_tptr) + 1)) << 16) | ((uint32_t)(*((const uint8_t *)(obj_tptr) + 2)) << 8) | ((uint32_t)(*((const uint8_t *)(obj_tptr) + 3)) << 0))))(ndo, "\n\t    Interface ID: %s (0x%08x)", ipaddr_string(ndo, obj_tptr+offset), EXTRACT_32BITS(obj_tptr+offset))(ndo, "\n\t    Interface ID: %s (0x%08x)", getname(ndo, (const u_char *)(obj_tptr+offset)), ((uint32_t)(((uint32_t)(*((const uint8_t *)(obj_tptr+offset) + 0)) << 24) | ((uint32_t)(*((const uint8_t *)(obj_tptr+offset) + 1)) << 16) | ((uint32_t)(*((const uint8_t *)(obj_tptr+offset) + 2)) << 8) | ((uint32_t)(*((const uint8_t *)(obj_tptr+offset) + 3)) << 0))))(ndo, "\n\t\t    Active: %s (%u)", (EXTRACT_32BITS(obj_tptr+offset+4)>>31) ? "Allocated" : "Non-allocated", (EXTRACT_32BITS(obj_tptr+offset+4)>>31))(ndo, "\n\t\t    Active: %s (%u)", (((uint32_t)(((uint32_t)(*((const uint8_t *)(obj_tptr+offset+4) + 0)) << 24) | ((uint32_t)(*((const uint8_t *)(obj_tptr+offset+4) + 1)) << 16) | ((uint32_t)(*((const uint8_t *)(obj_tptr+offset+4) + 2)) << 8) | ((uint32_t)(*((const uint8_t *)(obj_tptr+offset+4) + 3)) << 0)))>>31) ? "Allocated" : "Non-allocated", (((uint32_t)(((uint32_t)(*((const uint8_t *)(obj_tptr+offset+4) + 0)) << 24) | ((uint32_t)(*((const uint8_t *)(obj_tptr+offset+4) + 1)) << 16) | ((uint32_t)(*((const uint8_t *)(obj_tptr+offset+4) + 2)) << 8) | ((uint32_t)(*((const uint8_t *)(obj_tptr+offset+4) + 3)) << 0)))>>31))(ndo, "\n\t\t    Direction: %s (%u)", (EXTRACT_32BITS(obj_tptr+offset+4)>>30)&0x1 ? "Transmit" : "Receive", (EXTRACT_32BITS(obj_tptr+offset+4)>>30)&0x1)(ndo, "\n\t\t    Direction: %s (%u)", (((uint32_t)(((uint32_t)(*((const uint8_t *)(obj_tptr+offset+4) + 0)) << 24) | ((uint32_t)(*((const uint8_t *)(obj_tptr+offset+4) + 1)) << 16) | ((uint32_t)(*((const uint8_t *)(obj_tptr+offset+4) + 2)) << 8) | ((uint32_t)(*((const uint8_t *)(obj_tptr+offset+4) + 3)) << 0)))>>30)&0x1 ? "Transmit" : "Receive", (((uint32_t)(((uint32_t)(*((const uint8_t *)(obj_tptr+offset+4) + 0)) << 24) | ((uint32_t)(*((const uint8_t *)(obj_tptr+offset+4) + 1)) << 16) | ((uint32_t)(*((const uint8_t *)(obj_tptr+offset+4) + 2)) << 8) | ((uint32_t)(*((const uint8_t *)(obj_tptr+offset+4) + 3)) << 0)))>>30)&0x1)(ndo, "\n\t\t    Channel Status: %s (%u)", tok2str(lmp_obj_channel_status_values, "Unknown", EXTRACT_32BITS(obj_tptr+offset+4)&0x3FFFFFF), EXTRACT_32BITS(obj_tptr+offset+4)&0x3FFFFFF)(ndo, "\n\t\t    Channel Status: %s (%u)", tok2str(lmp_obj_channel_status_values, "Unknown", ((uint32_t)(((uint32_t)(*((const uint8_t *)(obj_tptr+offset+4) + 0)) << 24) | ((uint32_t)(*((const uint8_t *)(obj_tptr+offset+4) + 1)) << 16) | ((uint32_t)(*((const uint8_t *)(obj_tptr+offset+4) + 2)) << 8) | ((uint32_t)(*((const uint8_t *)(obj_tptr+offset+4) + 3)) << 0)))&0x3FFFFFF), ((uint32_t)(((uint32_t)(*((const uint8_t *)(obj_tptr+offset+4) + 0)) << 24) | ((uint32_t)(*((const uint8_t *)(obj_tptr+offset+4) + 1)) << 16) | ((uint32_t)(*((const uint8_t *)(obj_tptr+offset+4) + 2)) << 8) | ((uint32_t)(*((const uint8_t *)(obj_tptr+offset+4) + 3)) << 0)))&0x3FFFFFF)(ndo, "\n\t    Error Code: %s", bittok2str(lmp_obj_begin_verify_error_values, "none", EXTRACT_32BITS(obj_tptr)))(ndo, "\n\t    Error Code: %s", bittok2str(lmp_obj_begin_verify_error_values, "none", ((uint32_t)(((uint32_t)(*((const uint8_t *)(obj_tptr) + 0)) << 24) | ((uint32_t)(*((const uint8_t *)(obj_tptr) + 1)) << 16) | ((uint32_t)(*((const uint8_t *)(obj_tptr) + 2)) << 8) | ((uint32_t)(*((const uint8_t *)(obj_tptr) + 3)) << 0)))))(ndo, "\n\t    Error Code: %s", bittok2str(lmp_obj_link_summary_error_values, "none", EXTRACT_32BITS(obj_tptr)))(ndo, "\n\t    Error Code: %s", bittok2str(lmp_obj_link_summary_error_values, "none", ((uint32_t)(((uint32_t)(*((const uint8_t *)(obj_tptr) + 0)) << 24) | ((uint32_t)(*((const uint8_t *)(obj_tptr) + 1)) << 16) | ((uint32_t)(*((const uint8_t *)(obj_tptr) + 2)) << 8) | ((uint32_t)(*((const uint8_t *)(obj_tptr) + 3)) << 0)))))(ndo, "\n\t Flags: %s", bittok2str(lmp_obj_service_config_sp_flag_values, "none", EXTRACT_16BITS(obj_tptr)>>8))(ndo, "\n\t Flags: %s", bittok2str(lmp_obj_service_config_sp_flag_values, "none", ((uint16_t)(((uint16_t)(*((const uint8_t *)(obj_tptr) + 0)) << 8) | ((uint16_t)(*((const uint8_t *)(obj_tptr) + 1)) << 0)))>>8))(ndo, "\n\t  UNI Version: %u", EXTRACT_16BITS(obj_tptr) & 0x00FF)(ndo, "\n\t  UNI Version: %u", ((uint16_t)(((uint16_t)(*((const uint8_t *)(obj_tptr) + 0)) << 8) | ((uint16_t)(*((const uint8_t *)(obj_tptr) + 1)) << 0))) & 0x00FF)(ndo, "\n\t Link Type: %s (%u)", tok2str(lmp_sd_service_config_cpsa_link_type_values, "Unknown", link_type), link_type)(ndo, "\n\t Signal Type: %s (%u)", tok2str(lmp_sd_service_config_cpsa_signal_type_sdh_values, "Unknown", EXTRACT_16BITS(obj_tptr) & 0x00FF), EXTRACT_16BITS(obj_tptr) & 0x00FF)(ndo, "\n\t Signal Type: %s (%u)", tok2str(lmp_sd_service_config_cpsa_signal_type_sdh_values, "Unknown", ((uint16_t)(((uint16_t)(*((const uint8_t *)(obj_tptr) + 0)) << 8) | ((uint16_t)(*((const uint8_t *)(obj_tptr) + 1)) << 0))) & 0x00FF), ((uint16_t)(((uint16_t)(*((const uint8_t *)(obj_tptr) + 0)) << 8) | ((uint16_t)(*((const uint8_t *)(obj_tptr) + 1)) << 0))) & 0x00FF)(ndo, "\n\t Signal Type: %s (%u)", tok2str(lmp_sd_service_config_cpsa_signal_type_sonet_values, "Unknown", EXTRACT_16BITS(obj_tptr) & 0x00FF), EXTRACT_16BITS(obj_tptr) & 0x00FF)(ndo, "\n\t Signal Type: %s (%u)", tok2str(lmp_sd_service_config_cpsa_signal_type_sonet_values, "Unknown", ((uint16_t)(((uint16_t)(*((const uint8_t *)(obj_tptr) + 0)) << 8) | ((uint16_t)(*((const uint8_t *)(obj_tptr) + 1)) << 0))) & 0x00FF), ((uint16_t)(((uint16_t)(*((const uint8_t *)(obj_tptr) + 0)) << 8) | ((uint16_t)(*((const uint8_t *)(obj_tptr) + 1)) << 0))) & 0x00FF)(ndo, "\n\t Transparency: %s", bittok2str(lmp_obj_service_config_cpsa_tp_flag_values, "none", EXTRACT_16BITS(obj_tptr+2)>>8))(ndo, "\n\t Transparency: %s", bittok2str(lmp_obj_service_config_cpsa_tp_flag_values, "none", ((uint16_t)(((uint16_t)(*((const uint8_t *)(obj_tptr+2) + 0)) << 8) | ((uint16_t)(*((const uint8_t *)(obj_tptr+2) + 1)) << 0)))>>8))(ndo, "\n\t Contiguous Concatenation Types: %s", bittok2str(lmp_obj_service_config_cpsa_cct_flag_values, "none", EXTRACT_16BITS(obj_tptr+2)>>8 & 0x00FF))(ndo, "\n\t Contiguous Concatenation Types: %s", bittok2str(lmp_obj_service_config_cpsa_cct_flag_values, "none", ((uint16_t)(((uint16_t)(*((const uint8_t *)(obj_tptr+2) + 0)) << 8) | ((uint16_t)(*((const uint8_t *)(obj_tptr+2) + 1)) << 0)))>>8 & 0x00FF))(ndo, "\n\t Minimum NCC: %u", EXTRACT_16BITS(obj_tptr+4))(ndo, "\n\t Minimum NCC: %u", ((uint16_t)(((uint16_t)(*((const uint8_t *)(obj_tptr+4) + 0)) << 8) | ((uint16_t)(*((const uint8_t *)(obj_tptr+4) + 1)) << 0))))(ndo, "\n\t Maximum NCC: %u", EXTRACT_16BITS(obj_tptr+6))(ndo, "\n\t Maximum NCC: %u", ((uint16_t)(((uint16_t)(*((const uint8_t *)(obj_tptr+6) + 0)) << 8) | ((uint16_t)(*((const uint8_t *)(obj_tptr+6) + 1)) << 0))))obj_tptr+6(ndo, "\n\t Minimum NVC:%u", EXTRACT_16BITS(obj_tptr+8))(ndo, "\n\t Minimum NVC:%u", ((uint16_t)(((uint16_t)(*((const uint8_t *)(obj_tptr+8) + 0)) << 8) | ((uint16_t)(*((const uint8_t *)(obj_tptr+8) + 1)) << 0))))(ndo, "\n\t Maximum NVC:%u", EXTRACT_16BITS(obj_tptr+10))(ndo, "\n\t Maximum NVC:%u", ((uint16_t)(((uint16_t)(*((const uint8_t *)(obj_tptr+10) + 0)) << 8) | ((uint16_t)(*((const uint8_t *)(obj_tptr+10) + 1)) << 0))))(ndo, "\n\t    Local Interface ID: %s (0x%08x)", ipaddr_string(ndo, obj_tptr+12), EXTRACT_32BITS(obj_tptr+12))(ndo, "\n\t    Local Interface ID: %s (0x%08x)", getname(ndo, (const u_char *)(obj_tptr+12)), ((uint32_t)(((uint32_t)(*((const uint8_t *)(obj_tptr+12) + 0)) << 24) | ((uint32_t)(*((const uint8_t *)(obj_tptr+12) + 1)) << 16) | ((uint32_t)(*((const uint8_t *)(obj_tptr+12) + 2)) << 8) | ((uint32_t)(*((const uint8_t *)(obj_tptr+12) + 3)) << 0))))(ndo, "\n\t Transparency Flags: %s", bittok2str( lmp_obj_service_config_nsa_transparency_flag_values, "none", EXTRACT_32BITS(obj_tptr)))(ndo, "\n\t Transparency Flags: %s", bittok2str( lmp_obj_service_config_nsa_transparency_flag_values, "none", ((uint32_t)(((uint32_t)(*((const uint8_t *)(obj_tptr) + 0)) << 24) | ((uint32_t)(*((const uint8_t *)(obj_tptr) + 1)) << 16) | ((uint32_t)(*((const uint8_t *)(obj_tptr) + 2)) << 8) | ((uint32_t)(*((const uint8_t *)(obj_tptr) + 3)) << 0)))))(ndo, "\n\t TCM Monitoring Flags: %s", bittok2str( lmp_obj_service_config_nsa_tcm_flag_values, "none", EXTRACT_16BITS(obj_tptr+6) & 0x00FF))(ndo, "\n\t TCM Monitoring Flags: %s", bittok2str( lmp_obj_service_config_nsa_tcm_flag_values, "none", ((uint16_t)(((uint16_t)(*((const uint8_t *)(obj_tptr+6) + 0)) << 8) | ((uint16_t)(*((const uint8_t *)(obj_tptr+6) + 1)) << 0))) & 0x00FF))(ndo, "\n\t Diversity: Flags: %s", bittok2str( lmp_obj_service_config_nsa_network_diversity_flag_values, "none", EXTRACT_16BITS(obj_tptr+2) & 0x00FF))(ndo, "\n\t Diversity: Flags: %s", bittok2str( lmp_obj_service_config_nsa_network_diversity_flag_values, "none", ((uint16_t)(((uint16_t)(*((const uint8_t *)(obj_tptr+2) + 0)) << 8) | ((uint16_t)(*((const uint8_t *)(obj_tptr+2) + 1)) << 0))) & 0x00FF))
	  %s Object (%u), Class-Type: %s (%u) Flags: [%snegotiable], length: %unon-LMP_OBJ_CC_IDLMP_CTYPE_LOCLMP_CTYPE_RMT
	    Control Channel ID: %u (0x%08x)LMP_OBJ_LINK_IDLMP_OBJ_INTERFACE_IDLMP_CTYPE_IPV4_LOCLMP_CTYPE_IPV4_RMT
	    IPv4 Link ID: %s (0x%08x)LMP_CTYPE_UNMD_LOCLMP_CTYPE_UNMD_RMT
	    Link ID: %u (0x%08x)LMP_OBJ_MESSAGE_IDLMP_CTYPE_1
	    Message ID: %u (0x%08x)LMP_CTYPE_2
	    Message ID Ack: %u (0x%08x)LMP_OBJ_NODE_ID
	    Node ID: %s (0x%08x)LMP_OBJ_CONFIGLMP_CTYPE_HELLO_CONFIG
	    Hello Interval: %u
	    Hello Dead Interval: %uLMP_OBJ_HELLOLMP_CTYPE_HELLO
	    Tx Seq: %u, Rx Seq: %uLMP_OBJ_TE_LINK
	    Flags: [%s]LMP_CTYPE_IPV4
	    Local Link-ID: %s (0x%08x)
	    Remote Link-ID: %s (0x%08x)char[66]LMP_CTYPE_UNMDLMP_OBJ_DATA_LINK
	    Local Interface ID: %s (0x%08x)
	    Remote Interface ID: %s (0x%08x)
	    Subobject, Type: %s (%u), Length: %uINT_SWITCHING_TYPE_SUBOBJ
	      Switching Type: %s (%u)
	      Encoding Type: %s (%u)
	      Min Reservable Bandwidth: %.3f Mbps
	      Max Reservable Bandwidth: %.3f MbpsWAVELENGTH_SUBOBJ
	      Wavelength: %uLMP_OBJ_VERIFY_BEGIN
	    Flags: %s
	    Verify Interval: %u
	    Data links: %u
	    Encoding type: %s
	    Verify Transport Mechanism: %u (0x%x)%s8000 (Payload test messages capable)
	    Transmission Rate: %.3f Mbps
	    Wavelength: %uLMP_OBJ_VERIFY_BEGIN_ACK
	    Verify Dead Interval: %u
	    Verify Transport Response: %uLMP_OBJ_VERIFY_ID
	    Verify ID: %uLMP_OBJ_CHANNEL_STATUS(int)sizeof(struct lmp_object_header)
	    Interface ID: %s (0x%08x)
		    Active: %s (%u)AllocatedNon-allocated
		    Direction: %s (%u)TransmitReceive
		    Channel Status: %s (%u)67108863LMP_OBJ_CHANNEL_STATUS_REQLMP_OBJ_ERROR_CODELMP_CTYPE_BEGIN_VERIFY_ERROR
	    Error Code: %sLMP_CTYPE_LINK_SUMMARY_ERRORLMP_OBJ_SERVICE_CONFIGLMP_CTYPE_SERVICE_CONFIG_SP
	 Flags: %s
	  UNI Version: %uLMP_CTYPE_SERVICE_CONFIG_CPSA
	 Link Type: %s (%u)LMP_SD_SERVICE_CONFIG_CPSA_LINK_TYPE_SDH
	 Signal Type: %s (%u)LMP_SD_SERVICE_CONFIG_CPSA_LINK_TYPE_SONET
	 Transparency: %s
	 Contiguous Concatenation Types: %s
	 Minimum NCC: %u
	 Maximum NCC: %u
	 Minimum NVC:%u
	 Maximum NVC:%u
	    Local Interface ID: %s (0x%08x)LMP_CTYPE_SERVICE_CONFIG_TRANSPARENCY_TCM
	 Transparency Flags: %s
	 TCM Monitoring Flags: %sLMP_CTYPE_SERVICE_CONFIG_NETWORK_DIVERSITY
	 Diversity: Flags: %slmp_object_headerlmp_common_headerversion_res256*LMP_OBJ_CC_ID256*LMP_OBJ_CC_ID+LMP_CTYPE_LOC256*LMP_OBJ_CC_ID+LMP_CTYPE_RMTRemote"Remote"256*LMP_OBJ_NODE_ID256*LMP_OBJ_NODE_ID+LMP_CTYPE_LOC256*LMP_OBJ_NODE_ID+LMP_CTYPE_RMT256*LMP_OBJ_LINK_ID256*LMP_OBJ_LINK_ID+LMP_CTYPE_IPV4_LOCIPv4 Local"IPv4 Local"256*LMP_OBJ_LINK_ID+LMP_CTYPE_IPV4_RMTIPv4 Remote"IPv4 Remote"LMP_CTYPE_IPV6_LOC256*LMP_OBJ_LINK_ID+LMP_CTYPE_IPV6_LOCIPv6 Local"IPv6 Local"LMP_CTYPE_IPV6_RMT256*LMP_OBJ_LINK_ID+LMP_CTYPE_IPV6_RMTIPv6 Remote"IPv6 Remote"773256*LMP_OBJ_LINK_ID+LMP_CTYPE_UNMD_LOCUnnumbered Local"Unnumbered Local"256*LMP_OBJ_LINK_ID+LMP_CTYPE_UNMD_RMTUnnumbered Remote"Unnumbered Remote"256*LMP_OBJ_INTERFACE_ID256*LMP_OBJ_INTERFACE_ID+LMP_CTYPE_IPV4_LOC256*LMP_OBJ_INTERFACE_ID+LMP_CTYPE_IPV4_RMT256*LMP_OBJ_INTERFACE_ID+LMP_CTYPE_IPV6_LOC256*LMP_OBJ_INTERFACE_ID+LMP_CTYPE_IPV6_RMT1029256*LMP_OBJ_INTERFACE_ID+LMP_CTYPE_UNMD_LOC1030256*LMP_OBJ_INTERFACE_ID+LMP_CTYPE_UNMD_RMT256*LMP_OBJ_MESSAGE_ID256*LMP_OBJ_MESSAGE_ID+LMP_CTYPE_1"1"256*LMP_OBJ_MESSAGE_ID+LMP_CTYPE_2"2"256*LMP_OBJ_CONFIG256*LMP_OBJ_CONFIG+LMP_CTYPE_1256*LMP_OBJ_HELLO1793256*LMP_OBJ_HELLO+LMP_CTYPE_1256*LMP_OBJ_VERIFY_BEGIN256*LMP_OBJ_VERIFY_BEGIN+LMP_CTYPE_12304256*LMP_OBJ_VERIFY_BEGIN_ACK2305256*LMP_OBJ_VERIFY_BEGIN_ACK+LMP_CTYPE_1256*LMP_OBJ_VERIFY_ID2561256*LMP_OBJ_VERIFY_ID+LMP_CTYPE_12816256*LMP_OBJ_TE_LINK2817256*LMP_OBJ_TE_LINK+LMP_CTYPE_IPV4LMP_CTYPE_IPV62818256*LMP_OBJ_TE_LINK+LMP_CTYPE_IPV62819256*LMP_OBJ_TE_LINK+LMP_CTYPE_UNMDUnnumbered"Unnumbered"3072256*LMP_OBJ_DATA_LINK3073256*LMP_OBJ_DATA_LINK+LMP_CTYPE_IPV43074256*LMP_OBJ_DATA_LINK+LMP_CTYPE_IPV63075256*LMP_OBJ_DATA_LINK+LMP_CTYPE_UNMD3328256*LMP_OBJ_CHANNEL_STATUS3329256*LMP_OBJ_CHANNEL_STATUS+LMP_CTYPE_IPV43330256*LMP_OBJ_CHANNEL_STATUS+LMP_CTYPE_IPV63331256*LMP_OBJ_CHANNEL_STATUS+LMP_CTYPE_UNMD256*LMP_OBJ_CHANNEL_STATUS_REQ3585256*LMP_OBJ_CHANNEL_STATUS_REQ+LMP_CTYPE_IPV43586256*LMP_OBJ_CHANNEL_STATUS_REQ+LMP_CTYPE_IPV63587256*LMP_OBJ_CHANNEL_STATUS_REQ+LMP_CTYPE_UNMD5120256*LMP_OBJ_ERROR_CODE5121256*LMP_OBJ_ERROR_CODE+LMP_CTYPE_15122256*LMP_OBJ_ERROR_CODE+LMP_CTYPE_213056256*LMP_OBJ_SERVICE_CONFIG13057256*LMP_OBJ_SERVICE_CONFIG+LMP_CTYPE_SERVICE_CONFIG_SP13058256*LMP_OBJ_SERVICE_CONFIG+LMP_CTYPE_SERVICE_CONFIG_CPSA13059256*LMP_OBJ_SERVICE_CONFIG+LMP_CTYPE_SERVICE_CONFIG_TRANSPARENCY_TCM"3"13060256*LMP_OBJ_SERVICE_CONFIG+LMP_CTYPE_SERVICE_CONFIG_NETWORK_DIVERSITY"4"lmp_ctype_valuesInterface Switching Type"Interface Switching Type"Wavelength"Wavelength"lmp_data_link_subobjControl Channel ID"Control Channel ID"Node ID"Node ID"Interface ID"Interface ID"Message ID"Message ID"Configuration"Configuration"Verify Begin"Verify Begin"Verify Begin ACK"Verify Begin ACK"Verify ID"Verify ID"TE Link"TE Link"Data Link"Data Link"Channel Status"Channel Status"Channel Status Request"Channel Status Request"Error Code"Error Code"Service Config"Service Config"lmp_obj_valuesLMP_MSGTYPE_CONFIGLMP_MSGTYPE_CONFIG_ACKConfig ACK"Config ACK"LMP_MSGTYPE_CONFIG_NACKConfig NACK"Config NACK"LMP_MSGTYPE_HELLOLMP_MSGTYPE_VERIFY_BEGINBegin Verify"Begin Verify"LMP_MSGTYPE_VERIFY_BEGIN_ACKBegin Verify ACK"Begin Verify ACK"LMP_MSGTYPE_VERIFY_BEGIN_NACKBegin Verify NACK"Begin Verify NACK"LMP_MSGTYPE_VERIFY_ENDEnd Verify"End Verify"LMP_MSGTYPE_VERIFY_END_ACKEnd Verify ACK"End Verify ACK"LMP_MSGTYPE_TESTTest"Test"LMP_MSGTYPE_TEST_STATUS_SUCCESSTest Status Success"Test Status Success"LMP_MSGTYPE_TEST_STATUS_FAILURETest Status Failure"Test Status Failure"LMP_MSGTYPE_TEST_STATUS_ACKTest Status ACK"Test Status ACK"LMP_MSGTYPE_LINK_SUMMARYLink Summary"Link Summary"LMP_MSGTYPE_LINK_SUMMARY_ACKLink Summary ACK"Link Summary ACK"LMP_MSGTYPE_LINK_SUMMARY_NACKLink Summary NACK"Link Summary NACK"LMP_MSGTYPE_CHANNEL_STATUSLMP_MSGTYPE_CHANNEL_STATUS_ACKChannel Status ACK"Channel Status ACK"LMP_MSGTYPE_CHANNEL_STATUS_REQLMP_MSGTYPE_CHANNEL_STATUS_RESPChannel Status Response"Channel Status Response"LMP_MSGTYPE_SERVICE_CONFIGLMP_MSGTYPE_SERVICE_CONFIG_ACKService Config ACK"Service Config ACK"LMP_MSGTYPE_SERVICE_CONFIG_NACKService Config NACK"Service Config NACK"lmp_msg_type_valuesNode Diversity Supported"Node Diversity Supported"Link Diversity Supported"Link Diversity Supported"SRLG Diversity Supported"SRLG Diversity Supported"lmp_obj_service_config_nsa_network_diversity_flag_valuesTransparent Tandem Connection Monitoring Supported"Transparent Tandem Connection Monitoring Supported"lmp_obj_service_config_nsa_tcm_flag_valuesStandard SOH/RSOH Transparency Supported"Standard SOH/RSOH Transparency Supported"Standard LOH/MSOH Transparency Supported"Standard LOH/MSOH Transparency Supported"lmp_obj_service_config_nsa_transparency_flag_valuesContiguous Concatenation Types Supported"Contiguous Concatenation Types Supported"lmp_obj_service_config_cpsa_cct_flag_valuesPath/VC Overhead Transparency Supported"Path/VC Overhead Transparency Supported"Line/MS Overhead Transparency Supported"Line/MS Overhead Transparency Supported"Section/RS Overhead Transparency Supported"Section/RS Overhead Transparency Supported"lmp_obj_service_config_cpsa_tp_flag_valuesRSVP Supported"RSVP Supported"LDP Supported"LDP Supported"lmp_obj_service_config_sp_flag_valuesUnacceptable non-negotiable LINK-SUMMARY parameters"Unacceptable non-negotiable LINK-SUMMARY parameters"Renegotiate LINK-SUMMARY parameters"Renegotiate LINK-SUMMARY parameters"Invalid TE-LINK Object"Invalid TE-LINK Object"Invalid DATA-LINK Object"Invalid DATA-LINK Object"Unknown TE-LINK Object c-type"Unknown TE-LINK Object c-type"Unknown DATA-LINK Object c-type"Unknown DATA-LINK Object c-type"lmp_obj_link_summary_error_valuesLink Verification Procedure Not supported"Link Verification Procedure Not supported"Unwilling to verify"Unwilling to verify"Unsupported verification transport mechanism"Unsupported verification transport mechanism"Link-Id configuration error"Link-Id configuration error"Unknown object c-type"Unknown object c-type"lmp_obj_begin_verify_error_valuesVerify all links"Verify all links"Data link type"Data link type"lmp_obj_begin_verify_flag_valuesSignal Okay"Signal Okay"Signal Degraded"Signal Degraded"Signal Fail"Signal Fail"lmp_obj_channel_status_valuesData Link Port"Data Link Port"Allocated for user traffic"Allocated for user traffic"Failed link"Failed link"lmp_obj_data_link_flag_valuesFault Management Supported"Fault Management Supported"Link Verification Supported"Link Verification Supported"lmp_obj_te_link_flag_valuesControl Channel Down"Control Channel Down"LMP restart"LMP restart"lmp_header_flag_valuesLMP_EXTRACT_VERSION(x)/* Decode pairs: <Interface_ID (4 bytes), Channel_status (4 bytes)> *//* Any Unknown Subobject ==> Exit loop *//* int to float conversion buffer *//*
 * the ctypes are not globally unique so for
 * translating it to strings we build a table based
 * on objects offsetted by the ctype
 *//* UNI 1.0 Sec 9.4.2 *//*
 * Different link types allowed in the Client Port Service Attributes
 * subobject defined for LMP Service Discovery in the UNI 1.0 spec
 *//* C-Types for Service Config Object *//* defined in UNI 1.0 *//*
 * LMP object header
 *
 *  0                   1                   2                   3
 *  0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
 * +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
 * |N|   C-Type    |     Class     |            Length             |
 * +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
 * |                                                               |
 * //                       (object contents)                     //
 * |                                                               |
 * +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
 *//* LMP Service Discovery message types defined by UNI 1.0 *//* Network Service Attributes Network Diversity Flags *//* Service Config Network Service Attributes TCM Monitoring Flags *//* Service Config Network Service Attributes Transparency Flags *//* Service Config Client Port Service Attribute Contiguous Concatenation Types Flags *//* Service Config Client Port Service Attribute Transparency Flags *//* Service Config Supported Protocols Flags *//*
 * LMP common header
 *
 *  0                   1                   2                   3
 *  0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
 * +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
 * | Vers  |      (Reserved)       |    Flags      |    Msg Type   |
 * +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
 * |          LMP Length           |          (Reserved)           |
 * +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
 *//*
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that: (1) source code
 * distributions retain the above copyright notice and this paragraph
 * in its entirety, and (2) distributions including binary code include
 * the above copyright notice and this paragraph in its entirety in
 * the documentation or other materials provided with the distribution.
 * THIS SOFTWARE IS PROVIDED ``AS IS'' AND
 * WITHOUT ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, WITHOUT
 * LIMITATION, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS
 * FOR A PARTICULAR PURPOSE.
 *
 * Support for the Link Management Protocol as per rfc 4204.
 *
 * Original code by Hannes Gredler (hannes@juniper.net)
 * Support for LMP service discovery extensions (defined by UNI 1.0) added
 * by Manu Pathak (mapathak@cisco.com), May 2005
 *//Users/owura/Repos/codeql_eval/proj_repos/the-tcpdump-group-tcpdump-commit-0f95d441e4b5d7512cc5c326c8668a120e048eda/tcpdump/print-loopback.cloopback_printskipCount(ndo, "Loopback")(ndo, ", skipCount %u", skipCount), skipCount %u(ndo, " (bogus)") (bogus)loopback_message_printfunction(ndo, ", %s", tok2str(fcode_str, " invalid (%u)", function)) invalid (%u)(ndo, ", receipt number %u", EXTRACT_LE_16BITS(cp))(ndo, ", receipt number %u", ((uint16_t)(((uint16_t)(*((const uint8_t *)(cp) + 1)) << 8) | ((uint16_t)(*((const uint8_t *)(cp) + 0)) << 0))))(ndo, ", data (%u octets)", len - 4)len - 4(ndo, ", forwarding address %s", etheraddr_string(ndo, cp))(ndo, ", data (%u octets)", len - 8)len - 8len - 2LOOPBACK_REPLY, receipt number %u, data (%u octets)LOOPBACK_FWDDATA, forwarding address %sForward Data"Forward Data"fcode_str [|loopback]" [|loopback]"/* skipCount *//* forwarding address *//* receipt number *//* function *//*
 * This module implements decoding of the Loopback Protocol, originally
 * defined as the Configuration Testing Protocol. It is based on the following
 * specification:
 * http://www.mit.edu/people/jhawk/ctp.pdf
 *
 * Copyright (c) 2014 The TCPDUMP project
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
 * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
 * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS
 * FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE
 * COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT,
 * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,
 * BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
 * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
 * CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN
 * ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
 * POSSIBILITY OF SUCH DAMAGE.
 *//Users/owura/Repos/codeql_eval/proj_repos/the-tcpdump-group-tcpdump-commit-0f95d441e4b5d7512cc5c326c8668a120e048eda/tcpdump/print-lspping.clspping_printconst lspping_common_headerconst lspping_common_header *lspping_common_header *lspping_com_headerconst lspping_tlv_headerconst lspping_tlv_header *lspping_tlv_header *lspping_tlv_headerlspping_subtlv_headersubtlv_tptrlspping_tlv_lenlspping_tlv_typetlv_hexdumpsubtlv_hexdumplspping_subtlv_lenlspping_subtlv_typesubtlv_ptr*lspping_com_headersizeof(*lspping_com_header)&lspping_com_header->version[0](ndo, "LSP-PING version %u packet not supported", EXTRACT_16BITS(&lspping_com_header->version[0]))(ndo, "LSP-PING version %u packet not supported", ((uint16_t)(((uint16_t)(*((const uint8_t *)(&lspping_com_header->version[0]) + 0)) << 8) | ((uint16_t)(*((const uint8_t *)(&lspping_com_header->version[0]) + 1)) << 0))))LSPPING_VERSIONLSP-PING version %u packet not supported(ndo, "LSP-PINGv%u, %s, seq %u, length: %u", EXTRACT_16BITS(&lspping_com_header->version[0]), tok2str(lspping_msg_type_values, "unknown (%u)",lspping_com_header->msg_type), EXTRACT_32BITS(lspping_com_header->seq_number), len)(ndo, "LSP-PINGv%u, %s, seq %u, length: %u", ((uint16_t)(((uint16_t)(*((const uint8_t *)(&lspping_com_header->version[0]) + 0)) << 8) | ((uint16_t)(*((const uint8_t *)(&lspping_com_header->version[0]) + 1)) << 0))), tok2str(lspping_msg_type_values, "unknown (%u)",lspping_com_header->msg_type), ((uint32_t)(((uint32_t)(*((const uint8_t *)(lspping_com_header->seq_number) + 0)) << 24) | ((uint32_t)(*((const uint8_t *)(lspping_com_header->seq_number) + 1)) << 16) | ((uint32_t)(*((const uint8_t *)(lspping_com_header->seq_number) + 2)) << 8) | ((uint32_t)(*((const uint8_t *)(lspping_com_header->seq_number) + 3)) << 0))), len)lspping_com_header->seq_numberLSP-PINGv%u, %s, seq %u, length: %u(ndo, "\n\tLSP-PINGv%u, msg-type: %s (%u), length: %u\n\t  reply-mode: %s (%u)", EXTRACT_16BITS(&lspping_com_header->version[0]), tok2str(lspping_msg_type_values, "unknown",lspping_com_header->msg_type), lspping_com_header->msg_type, len, tok2str(lspping_reply_mode_values, "unknown",lspping_com_header->reply_mode), lspping_com_header->reply_mode)(ndo, "\n\tLSP-PINGv%u, msg-type: %s (%u), length: %u\n\t  reply-mode: %s (%u)", ((uint16_t)(((uint16_t)(*((const uint8_t *)(&lspping_com_header->version[0]) + 0)) << 8) | ((uint16_t)(*((const uint8_t *)(&lspping_com_header->version[0]) + 1)) << 0))), tok2str(lspping_msg_type_values, "unknown",lspping_com_header->msg_type), lspping_com_header->msg_type, len, tok2str(lspping_reply_mode_values, "unknown",lspping_com_header->reply_mode), lspping_com_header->reply_mode)
	LSP-PINGv%u, msg-type: %s (%u), length: %u
	  reply-mode: %s (%u)(ndo, "\n\t  Return Code: %s %u (%u)\n\t  Return Subcode: (%u)", tok2str(lspping_return_code_values, "unknown",lspping_com_header->return_code), lspping_com_header->return_subcode, lspping_com_header->return_code, lspping_com_header->return_subcode)(ndo, "\n\t  Return Code: %s (%u)\n\t  Return Subcode: (%u)", tok2str(lspping_return_code_values, "unknown",lspping_com_header->return_code), lspping_com_header->return_code, lspping_com_header->return_subcode)
	  Return Code: %s %u (%u)
	  Return Subcode: (%u)
	  Return Code: %s (%u)
	  Return Subcode: (%u)(ndo, "\n\t  Sender Handle: 0x%08x, Sequence: %u", EXTRACT_32BITS(lspping_com_header->sender_handle), EXTRACT_32BITS(lspping_com_header->seq_number))(ndo, "\n\t  Sender Handle: 0x%08x, Sequence: %u", ((uint32_t)(((uint32_t)(*((const uint8_t *)(lspping_com_header->sender_handle) + 0)) << 24) | ((uint32_t)(*((const uint8_t *)(lspping_com_header->sender_handle) + 1)) << 16) | ((uint32_t)(*((const uint8_t *)(lspping_com_header->sender_handle) + 2)) << 8) | ((uint32_t)(*((const uint8_t *)(lspping_com_header->sender_handle) + 3)) << 0))), ((uint32_t)(((uint32_t)(*((const uint8_t *)(lspping_com_header->seq_number) + 0)) << 24) | ((uint32_t)(*((const uint8_t *)(lspping_com_header->seq_number) + 1)) << 16) | ((uint32_t)(*((const uint8_t *)(lspping_com_header->seq_number) + 2)) << 8) | ((uint32_t)(*((const uint8_t *)(lspping_com_header->seq_number) + 3)) << 0))))
	  Sender Handle: 0x%08x, Sequence: %ulspping_com_header->sender_handlelspping_com_header->ts_sent_seclspping_com_header->ts_sent_usec(ndo, "\n\t  Sender Timestamp: ")
	  Sender Timestamp: lspping_com_header->ts_rcvd_seclspping_com_header->ts_rcvd_usec(ndo, "Receiver Timestamp: ")Receiver Timestamp: (ndo, "no timestamp")no timestampsizeof(const struct lspping_common_header)sizeof(struct lspping_tlv_header)lspping_tlv_header->typelspping_tlv_header->length(ndo, "\n\t  ERROR: TLV %u bogus size %u",lspping_tlv_type,lspping_tlv_len)(ndo, "\n\t  %s TLV (%u), length: %u", tok2str(lspping_tlv_values, "Unknown", lspping_tlv_type), lspping_tlv_type, lspping_tlv_len)lspping_subtlv_header->typelspping_subtlv_header->length(ndo, "\n\t    %s subTLV (%u), length: %u", tok2str(lspping_tlvtargetfec_subtlv_values, "Unknown", lspping_subtlv_type), lspping_subtlv_type, lspping_subtlv_len)(ndo, "\n\t      %s/%u", ipaddr_string(ndo, subtlv_ptr.lspping_tlv_targetfec_subtlv_ldp_ipv4->prefix), subtlv_ptr.lspping_tlv_targetfec_subtlv_ldp_ipv4->prefix_len)(ndo, "\n\t      %s/%u", getname(ndo, (const u_char *)(subtlv_ptr.lspping_tlv_targetfec_subtlv_ldp_ipv4->prefix)), subtlv_ptr.lspping_tlv_targetfec_subtlv_ldp_ipv4->prefix_len)subtlv_ptr.lspping_tlv_targetfec_subtlv_ldp_ipv4->prefix(ndo, "\n\t      %s/%u, sender-id %s", ipaddr_string(ndo, subtlv_ptr.lspping_tlv_targetfec_subtlv_bgp_ipv4->prefix), subtlv_ptr.lspping_tlv_targetfec_subtlv_bgp_ipv4->prefix_len, ipaddr_string(ndo, subtlv_ptr.lspping_tlv_targetfec_subtlv_bgp_ipv4->sender_id))(ndo, "\n\t      %s/%u, sender-id %s", getname(ndo, (const u_char *)(subtlv_ptr.lspping_tlv_targetfec_subtlv_bgp_ipv4->prefix)), subtlv_ptr.lspping_tlv_targetfec_subtlv_bgp_ipv4->prefix_len, getname(ndo, (const u_char *)(subtlv_ptr.lspping_tlv_targetfec_subtlv_bgp_ipv4->sender_id)))subtlv_ptr.lspping_tlv_targetfec_subtlv_bgp_ipv4->prefixsubtlv_ptr.lspping_tlv_targetfec_subtlv_bgp_ipv4->sender_id(ndo, "\n\t      tunnel end-point %s, tunnel sender %s, lsp-id 0x%04x" "\n\t      tunnel-id 0x%04x, extended tunnel-id %s", ipaddr_string(ndo, subtlv_ptr.lspping_tlv_targetfec_subtlv_rsvp_ipv4->tunnel_endpoint), ipaddr_string(ndo, subtlv_ptr.lspping_tlv_targetfec_subtlv_rsvp_ipv4->tunnel_sender), EXTRACT_16BITS(subtlv_ptr.lspping_tlv_targetfec_subtlv_rsvp_ipv4->lsp_id), EXTRACT_16BITS(subtlv_ptr.lspping_tlv_targetfec_subtlv_rsvp_ipv4->tunnel_id), ipaddr_string(ndo, subtlv_ptr.lspping_tlv_targetfec_subtlv_rsvp_ipv4->extended_tunnel_id))(ndo, "\n\t      tunnel end-point %s, tunnel sender %s, lsp-id 0x%04x" "\n\t      tunnel-id 0x%04x, extended tunnel-id %s", getname(ndo, (const u_char *)(subtlv_ptr.lspping_tlv_targetfec_subtlv_rsvp_ipv4->tunnel_endpoint)), getname(ndo, (const u_char *)(subtlv_ptr.lspping_tlv_targetfec_subtlv_rsvp_ipv4->tunnel_sender)), ((uint16_t)(((uint16_t)(*((const uint8_t *)(subtlv_ptr.lspping_tlv_targetfec_subtlv_rsvp_ipv4->lsp_id) + 0)) << 8) | ((uint16_t)(*((const uint8_t *)(subtlv_ptr.lspping_tlv_targetfec_subtlv_rsvp_ipv4->lsp_id) + 1)) << 0))), ((uint16_t)(((uint16_t)(*((const uint8_t *)(subtlv_ptr.lspping_tlv_targetfec_subtlv_rsvp_ipv4->tunnel_id) + 0)) << 8) | ((uint16_t)(*((const uint8_t *)(subtlv_ptr.lspping_tlv_targetfec_subtlv_rsvp_ipv4->tunnel_id) + 1)) << 0))), getname(ndo, (const u_char *)(subtlv_ptr.lspping_tlv_targetfec_subtlv_rsvp_ipv4->extended_tunnel_id)))subtlv_ptr.lspping_tlv_targetfec_subtlv_rsvp_ipv4->tunnel_endpointsubtlv_ptr.lspping_tlv_targetfec_subtlv_rsvp_ipv4->tunnel_sendersubtlv_ptr.lspping_tlv_targetfec_subtlv_rsvp_ipv4->lsp_idsubtlv_ptr.lspping_tlv_targetfec_subtlv_rsvp_ipv4->tunnel_idsubtlv_ptr.lspping_tlv_targetfec_subtlv_rsvp_ipv4->extended_tunnel_id(ndo, "\n\t      RD: %s, %s/%u", bgp_vpn_rd_print(ndo, subtlv_ptr.lspping_tlv_targetfec_subtlv_l3vpn_ipv4->rd), ipaddr_string(ndo, subtlv_ptr.lspping_tlv_targetfec_subtlv_l3vpn_ipv4->prefix), subtlv_ptr.lspping_tlv_targetfec_subtlv_l3vpn_ipv4->prefix_len)(ndo, "\n\t      RD: %s, %s/%u", bgp_vpn_rd_print(ndo, subtlv_ptr.lspping_tlv_targetfec_subtlv_l3vpn_ipv4->rd), getname(ndo, (const u_char *)(subtlv_ptr.lspping_tlv_targetfec_subtlv_l3vpn_ipv4->prefix)), subtlv_ptr.lspping_tlv_targetfec_subtlv_l3vpn_ipv4->prefix_len)subtlv_ptr.lspping_tlv_targetfec_subtlv_l3vpn_ipv4->prefix(ndo, "\n\t      RD: %s, Sender CE-ID: %u, Receiver CE-ID: %u" "\n\t      Encapsulation Type: %s (%u)", bgp_vpn_rd_print(ndo, subtlv_ptr.lspping_tlv_targetfec_subtlv_l2vpn_endpt->rd), EXTRACT_16BITS(subtlv_ptr.lspping_tlv_targetfec_subtlv_l2vpn_endpt->sender_ce_id), EXTRACT_16BITS(subtlv_ptr.lspping_tlv_targetfec_subtlv_l2vpn_endpt->receiver_ce_id), tok2str(l2vpn_encaps_values, "unknown", EXTRACT_16BITS(subtlv_ptr.lspping_tlv_targetfec_subtlv_l2vpn_endpt->encapsulation)), EXTRACT_16BITS(subtlv_ptr.lspping_tlv_targetfec_subtlv_l2vpn_endpt->encapsulation))(ndo, "\n\t      RD: %s, Sender CE-ID: %u, Receiver CE-ID: %u" "\n\t      Encapsulation Type: %s (%u)", bgp_vpn_rd_print(ndo, subtlv_ptr.lspping_tlv_targetfec_subtlv_l2vpn_endpt->rd), ((uint16_t)(((uint16_t)(*((const uint8_t *)(subtlv_ptr.lspping_tlv_targetfec_subtlv_l2vpn_endpt->sender_ce_id) + 0)) << 8) | ((uint16_t)(*((const uint8_t *)(subtlv_ptr.lspping_tlv_targetfec_subtlv_l2vpn_endpt->sender_ce_id) + 1)) << 0))), ((uint16_t)(((uint16_t)(*((const uint8_t *)(subtlv_ptr.lspping_tlv_targetfec_subtlv_l2vpn_endpt->receiver_ce_id) + 0)) << 8) | ((uint16_t)(*((const uint8_t *)(subtlv_ptr.lspping_tlv_targetfec_subtlv_l2vpn_endpt->receiver_ce_id) + 1)) << 0))), tok2str(l2vpn_encaps_values, "unknown", ((uint16_t)(((uint16_t)(*((const uint8_t *)(subtlv_ptr.lspping_tlv_targetfec_subtlv_l2vpn_endpt->encapsulation) + 0)) << 8) | ((uint16_t)(*((const uint8_t *)(subtlv_ptr.lspping_tlv_targetfec_subtlv_l2vpn_endpt->encapsulation) + 1)) << 0)))), ((uint16_t)(((uint16_t)(*((const uint8_t *)(subtlv_ptr.lspping_tlv_targetfec_subtlv_l2vpn_endpt->encapsulation) + 0)) << 8) | ((uint16_t)(*((const uint8_t *)(subtlv_ptr.lspping_tlv_targetfec_subtlv_l2vpn_endpt->encapsulation) + 1)) << 0))))subtlv_ptr.lspping_tlv_targetfec_subtlv_l2vpn_endpt->sender_ce_idsubtlv_ptr.lspping_tlv_targetfec_subtlv_l2vpn_endpt->receiver_ce_idsubtlv_ptr.lspping_tlv_targetfec_subtlv_l2vpn_endpt->encapsulation(ndo, "\n\t      Remote PE: %s" "\n\t      VC-ID: 0x%08x, Encapsulation Type: %s (%u)", ipaddr_string(ndo, subtlv_ptr.lspping_tlv_targetfec_subtlv_l2vpn_vcid_old->remote_pe_address), EXTRACT_32BITS(subtlv_ptr.lspping_tlv_targetfec_subtlv_l2vpn_vcid_old->vc_id), tok2str(l2vpn_encaps_values, "unknown", EXTRACT_16BITS(subtlv_ptr.lspping_tlv_targetfec_subtlv_l2vpn_vcid_old->encapsulation)), EXTRACT_16BITS(subtlv_ptr.lspping_tlv_targetfec_subtlv_l2vpn_vcid_old->encapsulation))(ndo, "\n\t      Remote PE: %s" "\n\t      VC-ID: 0x%08x, Encapsulation Type: %s (%u)", getname(ndo, (const u_char *)(subtlv_ptr.lspping_tlv_targetfec_subtlv_l2vpn_vcid_old->remote_pe_address)), ((uint32_t)(((uint32_t)(*((const uint8_t *)(subtlv_ptr.lspping_tlv_targetfec_subtlv_l2vpn_vcid_old->vc_id) + 0)) << 24) | ((uint32_t)(*((const uint8_t *)(subtlv_ptr.lspping_tlv_targetfec_subtlv_l2vpn_vcid_old->vc_id) + 1)) << 16) | ((uint32_t)(*((const uint8_t *)(subtlv_ptr.lspping_tlv_targetfec_subtlv_l2vpn_vcid_old->vc_id) + 2)) << 8) | ((uint32_t)(*((const uint8_t *)(subtlv_ptr.lspping_tlv_targetfec_subtlv_l2vpn_vcid_old->vc_id) + 3)) << 0))), tok2str(l2vpn_encaps_values, "unknown", ((uint16_t)(((uint16_t)(*((const uint8_t *)(subtlv_ptr.lspping_tlv_targetfec_subtlv_l2vpn_vcid_old->encapsulation) + 0)) << 8) | ((uint16_t)(*((const uint8_t *)(subtlv_ptr.lspping_tlv_targetfec_subtlv_l2vpn_vcid_old->encapsulation) + 1)) << 0)))), ((uint16_t)(((uint16_t)(*((const uint8_t *)(subtlv_ptr.lspping_tlv_targetfec_subtlv_l2vpn_vcid_old->encapsulation) + 0)) << 8) | ((uint16_t)(*((const uint8_t *)(subtlv_ptr.lspping_tlv_targetfec_subtlv_l2vpn_vcid_old->encapsulation) + 1)) << 0))))subtlv_ptr.lspping_tlv_targetfec_subtlv_l2vpn_vcid_old->remote_pe_addresssubtlv_ptr.lspping_tlv_targetfec_subtlv_l2vpn_vcid_old->vc_idsubtlv_ptr.lspping_tlv_targetfec_subtlv_l2vpn_vcid_old->encapsulation(ndo, "\n\t      Sender PE: %s, Remote PE: %s" "\n\t      VC-ID: 0x%08x, Encapsulation Type: %s (%u)", ipaddr_string(ndo, subtlv_ptr.lspping_tlv_targetfec_subtlv_l2vpn_vcid->sender_pe_address), ipaddr_string(ndo, subtlv_ptr.lspping_tlv_targetfec_subtlv_l2vpn_vcid->remote_pe_address), EXTRACT_32BITS(subtlv_ptr.lspping_tlv_targetfec_subtlv_l2vpn_vcid->vc_id), tok2str(l2vpn_encaps_values, "unknown", EXTRACT_16BITS(subtlv_ptr.lspping_tlv_targetfec_subtlv_l2vpn_vcid->encapsulation)), EXTRACT_16BITS(subtlv_ptr.lspping_tlv_targetfec_subtlv_l2vpn_vcid->encapsulation))(ndo, "\n\t      Sender PE: %s, Remote PE: %s" "\n\t      VC-ID: 0x%08x, Encapsulation Type: %s (%u)", getname(ndo, (const u_char *)(subtlv_ptr.lspping_tlv_targetfec_subtlv_l2vpn_vcid->sender_pe_address)), getname(ndo, (const u_char *)(subtlv_ptr.lspping_tlv_targetfec_subtlv_l2vpn_vcid->remote_pe_address)), ((uint32_t)(((uint32_t)(*((const uint8_t *)(subtlv_ptr.lspping_tlv_targetfec_subtlv_l2vpn_vcid->vc_id) + 0)) << 24) | ((uint32_t)(*((const uint8_t *)(subtlv_ptr.lspping_tlv_targetfec_subtlv_l2vpn_vcid->vc_id) + 1)) << 16) | ((uint32_t)(*((const uint8_t *)(subtlv_ptr.lspping_tlv_targetfec_subtlv_l2vpn_vcid->vc_id) + 2)) << 8) | ((uint32_t)(*((const uint8_t *)(subtlv_ptr.lspping_tlv_targetfec_subtlv_l2vpn_vcid->vc_id) + 3)) << 0))), tok2str(l2vpn_encaps_values, "unknown", ((uint16_t)(((uint16_t)(*((const uint8_t *)(subtlv_ptr.lspping_tlv_targetfec_subtlv_l2vpn_vcid->encapsulation) + 0)) << 8) | ((uint16_t)(*((const uint8_t *)(subtlv_ptr.lspping_tlv_targetfec_subtlv_l2vpn_vcid->encapsulation) + 1)) << 0)))), ((uint16_t)(((uint16_t)(*((const uint8_t *)(subtlv_ptr.lspping_tlv_targetfec_subtlv_l2vpn_vcid->encapsulation) + 0)) << 8) | ((uint16_t)(*((const uint8_t *)(subtlv_ptr.lspping_tlv_targetfec_subtlv_l2vpn_vcid->encapsulation) + 1)) << 0))))subtlv_ptr.lspping_tlv_targetfec_subtlv_l2vpn_vcid->sender_pe_addresssubtlv_ptr.lspping_tlv_targetfec_subtlv_l2vpn_vcid->remote_pe_addresssubtlv_ptr.lspping_tlv_targetfec_subtlv_l2vpn_vcid->vc_idsubtlv_ptr.lspping_tlv_targetfec_subtlv_l2vpn_vcid->encapsulation(ndo, "\n\t    MTU: %u, Address-Type: %s (%u)", EXTRACT_16BITS(tlv_ptr.lspping_tlv_downstream_map_ipv4->mtu), tok2str(lspping_tlv_downstream_addr_values, "unknown", tlv_ptr.lspping_tlv_downstream_map_ipv4->address_type), tlv_ptr.lspping_tlv_downstream_map_ipv4->address_type)(ndo, "\n\t    MTU: %u, Address-Type: %s (%u)", ((uint16_t)(((uint16_t)(*((const uint8_t *)(tlv_ptr.lspping_tlv_downstream_map_ipv4->mtu) + 0)) << 8) | ((uint16_t)(*((const uint8_t *)(tlv_ptr.lspping_tlv_downstream_map_ipv4->mtu) + 1)) << 0))), tok2str(lspping_tlv_downstream_addr_values, "unknown", tlv_ptr.lspping_tlv_downstream_map_ipv4->address_type), tlv_ptr.lspping_tlv_downstream_map_ipv4->address_type)tlv_ptr.lspping_tlv_downstream_map_ipv4->mtu(ndo, "\n\t    Downstream IP: %s" "\n\t    Downstream Interface IP: %s", ipaddr_string(ndo, tlv_ptr.lspping_tlv_downstream_map_ipv4->downstream_ip), ipaddr_string(ndo, tlv_ptr.lspping_tlv_downstream_map_ipv4->downstream_interface))(ndo, "\n\t    Downstream IP: %s" "\n\t    Downstream Interface IP: %s", getname(ndo, (const u_char *)(tlv_ptr.lspping_tlv_downstream_map_ipv4->downstream_ip)), getname(ndo, (const u_char *)(tlv_ptr.lspping_tlv_downstream_map_ipv4->downstream_interface)))tlv_ptr.lspping_tlv_downstream_map_ipv4->downstream_iptlv_ptr.lspping_tlv_downstream_map_ipv4->downstream_interface(ndo, "\n\t    Downstream IP: %s" "\n\t    Downstream Interface Index: 0x%08x", ipaddr_string(ndo, tlv_ptr.lspping_tlv_downstream_map_ipv4->downstream_ip), EXTRACT_32BITS(tlv_ptr.lspping_tlv_downstream_map_ipv4->downstream_interface))(ndo, "\n\t    Downstream IP: %s" "\n\t    Downstream Interface Index: 0x%08x", getname(ndo, (const u_char *)(tlv_ptr.lspping_tlv_downstream_map_ipv4->downstream_ip)), ((uint32_t)(((uint32_t)(*((const uint8_t *)(tlv_ptr.lspping_tlv_downstream_map_ipv4->downstream_interface) + 0)) << 24) | ((uint32_t)(*((const uint8_t *)(tlv_ptr.lspping_tlv_downstream_map_ipv4->downstream_interface) + 1)) << 16) | ((uint32_t)(*((const uint8_t *)(tlv_ptr.lspping_tlv_downstream_map_ipv4->downstream_interface) + 2)) << 8) | ((uint32_t)(*((const uint8_t *)(tlv_ptr.lspping_tlv_downstream_map_ipv4->downstream_interface) + 3)) << 0))))LSPPING_TLV_BFD_DISCRIMINATOR_LEN(ndo, "\n\t    BFD Discriminator 0x%08x", EXTRACT_32BITS(tptr))(ndo, "\n\t    BFD Discriminator 0x%08x", ((uint32_t)(((uint32_t)(*((const uint8_t *)(tptr) + 0)) << 24) | ((uint32_t)(*((const uint8_t *)(tptr) + 1)) << 16) | ((uint32_t)(*((const uint8_t *)(tptr) + 2)) << 8) | ((uint32_t)(*((const uint8_t *)(tptr) + 3)) << 0))))LSPPING_TLV_VENDOR_ENTERPRISE_LEN(ndo, "\n\t    Vendor: %s (0x%04x)", tok2str(smi_values, "Unknown", vendor_id), vendor_id)(int)sizeof(struct lspping_tlv_header)
	  ERROR: TLV %u bogus size %u
	  %s TLV (%u), length: %uLSPPING_TLV_TARGET_FEC_STACK
	    %s subTLV (%u), length: %uLSPPING_TLV_TARGETFEC_SUBTLV_LDP_IPV4const lspping_tlv_targetfec_subtlv_ldp_ipv4_tconst lspping_tlv_targetfec_subtlv_ldp_ipv4_t *lspping_tlv_targetfec_subtlv_ldp_ipv4_t *
	      %s/%uLSPPING_TLV_TARGETFEC_SUBTLV_BGP_IPV4const lspping_tlv_targetfec_subtlv_bgp_ipv4_tconst lspping_tlv_targetfec_subtlv_bgp_ipv4_t *lspping_tlv_targetfec_subtlv_bgp_ipv4_t *
	      %s/%u, sender-id %sLSPPING_TLV_TARGETFEC_SUBTLV_RSVP_IPV4const lspping_tlv_targetfec_subtlv_rsvp_ipv4_tconst lspping_tlv_targetfec_subtlv_rsvp_ipv4_t *lspping_tlv_targetfec_subtlv_rsvp_ipv4_t *
	      tunnel end-point %s, tunnel sender %s, lsp-id 0x%04x
	      tunnel-id 0x%04x, extended tunnel-id %schar[108]LSPPING_TLV_TARGETFEC_SUBTLV_L3VPN_IPV4const lspping_tlv_targetfec_subtlv_l3vpn_ipv4_tconst lspping_tlv_targetfec_subtlv_l3vpn_ipv4_t *lspping_tlv_targetfec_subtlv_l3vpn_ipv4_t *
	      RD: %s, %s/%uLSPPING_TLV_TARGETFEC_SUBTLV_L2VPN_ENDPTconst lspping_tlv_targetfec_subtlv_l2vpn_endpt_tconst lspping_tlv_targetfec_subtlv_l2vpn_endpt_t *lspping_tlv_targetfec_subtlv_l2vpn_endpt_t *
	      RD: %s, Sender CE-ID: %u, Receiver CE-ID: %u
	      Encapsulation Type: %s (%u)char[88]LSPPING_TLV_TARGETFEC_SUBTLV_L2VPN_VCID_OLDconst lspping_tlv_targetfec_subtlv_l2vpn_vcid_old_tconst lspping_tlv_targetfec_subtlv_l2vpn_vcid_old_t *lspping_tlv_targetfec_subtlv_l2vpn_vcid_old_t *
	      Remote PE: %s
	      VC-ID: 0x%08x, Encapsulation Type: %s (%u)LSPPING_TLV_TARGETFEC_SUBTLV_L2VPN_VCIDconst lspping_tlv_targetfec_subtlv_l2vpn_vcid_tconst lspping_tlv_targetfec_subtlv_l2vpn_vcid_t *lspping_tlv_targetfec_subtlv_l2vpn_vcid_t *
	      Sender PE: %s, Remote PE: %s
	      VC-ID: 0x%08x, Encapsulation Type: %s (%u)LSPPING_TLV_DOWNSTREAM_MAPPINGconst lspping_tlv_downstream_map_ipv4_tconst lspping_tlv_downstream_map_ipv4_t *lspping_tlv_downstream_map_ipv4_t *const lspping_tlv_downstream_map_ipv6_tconst lspping_tlv_downstream_map_ipv6_t *lspping_tlv_downstream_map_ipv6_t *
	    MTU: %u, Address-Type: %s (%u)LSPPING_AFI_IPV4
	    Downstream IP: %s
	    Downstream Interface IP: %ssizeof(struct lspping_tlv_downstream_map_ipv4_t)LSPPING_AFI_UNMB
	    Downstream IP: %s
	    Downstream Interface Index: 0x%08xconst lspping_tlv_downstream_map_info_tconst lspping_tlv_downstream_map_info_t *lspping_tlv_downstream_map_info_t *sizeof(struct lspping_tlv_downstream_map_info_t)LSPPING_TLV_BFD_DISCRIMINATOR
	    BFD Discriminator 0x%08xLSPPING_TLV_VENDOR_ENTERPRISE
	    Vendor: %s (0x%04x)LSPPING_TLV_PADLSPPING_TLV_ERROR_CODELSPPING_TLV_VENDOR_PRIVATElspping_tlv_downstream_map_info_tlspping_tlv_downstream_map_ipv6_tlspping_tlv_downstream_map_ipv4_tlspping_tlv_targetfec_subtlv_l2vpn_vcid_tlspping_tlv_targetfec_subtlv_l2vpn_vcid_old_tlspping_tlv_targetfec_subtlv_l2vpn_endpt_tlspping_tlv_targetfec_subtlv_l3vpn_ipv6_tlspping_tlv_targetfec_subtlv_l3vpn_ipv4_tlspping_tlv_targetfec_subtlv_rsvp_ipv6_tlspping_tlv_targetfec_subtlv_rsvp_ipv4_tlspping_tlv_targetfec_subtlv_bgp_ipv6_tlspping_tlv_targetfec_subtlv_bgp_ipv4_tlspping_tlv_targetfec_subtlv_ldp_ipv6_tlspping_tlv_targetfec_subtlv_ldp_ipv4_tlspping_common_headerconst lspping_tlv_targetfec_subtlv_bgp_ipv6_tconst lspping_tlv_targetfec_subtlv_bgp_ipv6_t *lspping_tlv_targetfec_subtlv_bgp_ipv6_t *lspping_tlv_targetfec_subtlv_bgp_ipv6lspping_tlv_targetfec_subtlv_bgp_ipv4lspping_tlv_targetfec_subtlv_l2vpn_vcidlspping_tlv_targetfec_subtlv_l2vpn_vcid_oldlspping_tlv_targetfec_subtlv_l2vpn_endptconst lspping_tlv_targetfec_subtlv_l3vpn_ipv6_tconst lspping_tlv_targetfec_subtlv_l3vpn_ipv6_t *lspping_tlv_targetfec_subtlv_l3vpn_ipv6_t *lspping_tlv_targetfec_subtlv_l3vpn_ipv6lspping_tlv_targetfec_subtlv_l3vpn_ipv4const lspping_tlv_targetfec_subtlv_rsvp_ipv6_tconst lspping_tlv_targetfec_subtlv_rsvp_ipv6_t *lspping_tlv_targetfec_subtlv_rsvp_ipv6_t *lspping_tlv_targetfec_subtlv_rsvp_ipv6lspping_tlv_targetfec_subtlv_rsvp_ipv4const lspping_tlv_targetfec_subtlv_ldp_ipv6_tconst lspping_tlv_targetfec_subtlv_ldp_ipv6_t *lspping_tlv_targetfec_subtlv_ldp_ipv6_t *lspping_tlv_targetfec_subtlv_ldp_ipv6lspping_tlv_targetfec_subtlv_ldp_ipv4lspping_tlv_downstream_map_infolspping_tlv_downstream_map_ipv6lspping_tlv_downstream_map_ipv4multipath_lengthdepth_limithash_key_typedownstream_interfacedownstream_ipaddress_typeencapsulationvc_idremote_pe_addresssender_pe_addressreceiver_ce_idsender_ce_idtunnel_senderextended_tunnel_idtunnel_idtunnel_endpointsender_idts_rcvd_usects_rcvd_sects_sent_usects_sent_secseq_numbersender_handlereturn_subcodereturn_codereply_modeLSPPING_AFI_IPV6lspping_tlv_downstream_addr_valuesLDP IPv4 prefix"LDP IPv4 prefix"LSPPING_TLV_TARGETFEC_SUBTLV_LDP_IPV6LDP IPv6 prefix"LDP IPv6 prefix"RSVP IPv4 Session Query"RSVP IPv4 Session Query"LSPPING_TLV_TARGETFEC_SUBTLV_RSVP_IPV6RSVP IPv6 Session Query"RSVP IPv6 Session Query"VPN IPv4 prefix"VPN IPv4 prefix"LSPPING_TLV_TARGETFEC_SUBTLV_L3VPN_IPV6VPN IPv6 prefix"VPN IPv6 prefix"L2 VPN endpoint"L2 VPN endpoint"L2 circuit ID (old)"L2 circuit ID (old)"L2 circuit ID"L2 circuit ID"BGP labeled IPv4 prefix"BGP labeled IPv4 prefix"LSPPING_TLV_TARGETFEC_SUBTLV_BGP_IPV6BGP labeled IPv6 prefix"BGP labeled IPv6 prefix"lspping_tlvtargetfec_subtlv_valuesTarget FEC Stack"Target FEC Stack"Downstream Mapping"Downstream Mapping"Vendor Enterprise Code"Vendor Enterprise Code"LSPPING_TLV_INTERFACE_LABEL_STACKInterface Label Stack"Interface Label Stack"LSPPING_TLV_REPLY_TOS_BYTEReply TOS Byte"Reply TOS Byte"BFD Discriminator"BFD Discriminator"Vendor Private Code"Vendor Private Code"lspping_tlv_valuesNo return code or return code contained in the Error Code TLV"No return code or return code contained in the Error Code TLV"Malformed echo request received"Malformed echo request received"One or more of the TLVs was not understood"One or more of the TLVs was not understood"Replying router is an egress for the FEC at stack depth"Replying router is an egress for the FEC at stack depth"Replying router has no mapping for the FEC at stack depth"Replying router has no mapping for the FEC at stack depth"Label switched at stack-depth"Label switched at stack-depth"Label switched but no MPLS forwarding at stack-depth"Label switched but no MPLS forwarding at stack-depth"Mapping for this FEC is not the given label at stack depth"Mapping for this FEC is not the given label at stack depth"No label entry at stack-depth"No label entry at stack-depth"Protocol not associated with interface at FEC stack depth"Protocol not associated with interface at FEC stack depth"lspping_return_code_valuesDo not reply"Do not reply"Reply via an IPv4/IPv6 UDP packet"Reply via an IPv4/IPv6 UDP packet"Reply via an IPv4/IPv6 UDP packet with Router Alert"Reply via an IPv4/IPv6 UDP packet with Router Alert"Reply via application level control channel"Reply via application level control channel"lspping_reply_mode_valuesMPLS Echo Request"MPLS Echo Request"MPLS Echo Reply"MPLS Echo Reply"lspping_msg_type_values0xfc00/* All TLVs are aligned to four octet boundary *//* do we want to see an additionally tlv hexdump ? *//*
             *  FIXME those are the defined TLVs that lack a decoder
             *  you are welcome to contribute code ;-)
             *//* dump the TLV until code complete *//* FIXME print downstream labels *//* FIXME add hash-key type, depth limit, multipath processing *//* should not happen ! - no error message - tok2str() has barked already *//* that strange thing with the downstream map TLV is that until now
             * we do not know if its IPv4 or IPv6 , after we found the adress-type
             * lets recast the tlv_tptr and move on *//* do we want to see an additionally subtlv hexdump ? *//* unknown subTLV just hexdump it *//* the old L2VPN VCID subTLV does not have support for the sender field *//* did we capture enough for fully decoding the subtlv header ? *//* did we capture enough for fully decoding the tlv ? *//* header not included -> no adjustment *//* did we capture enough for fully decoding the tlv header ? *//*
     *  the following return codes require that the subcode is attached
     *  at the end of the translated token output
     *//*
 *  0                   1                   2                   3
 *  0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
 * +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
 * |               MTU             | Address Type  |  Resvd (SBZ)  |
 * +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
 * |             Downstream IP Address (4 or 16 octets)            |
 * +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
 * |         Downstream Interface Address (4 or 16 octets)         |
 * +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
 * | Hash Key Type | Depth Limit   |        Multipath Length       |
 * +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
 * .                                                               .
 * .                     (Multipath Information)                   .
 * .                                                               .
 * +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
 * |               Downstream Label                |    Protocol   |
 * +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
 * .                                                               .
 * .                                                               .
 * .                                                               .
 * +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
 * |               Downstream Label                |    Protocol   |
 * +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
 *//*
 *  0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
 * +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
 * |                     Sender's PE Address                       |
 * +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
 * |                      Remote PE Address                        |
 * +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
 * |                             VC ID                             |
 * +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
 * |      Encapsulation Type       |         Must Be Zero          |
 * +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
 *//*
 *  0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
 * +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
 * |                      Remote PE Address                        |
 * +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
 * |                             VC ID                             |
 * +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
 * |      Encapsulation Type       |         Must Be Zero          |
 * +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
 *//*
 *  0                   1                   2                   3
 *  0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
 * +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
 * |                      Route Distinguisher                      |
 * |                          (8 octets)                           |
 * +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
 * |         Sender's CE ID        |       Receiver's CE ID        |
 * +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
 * |      Encapsulation Type       |         Must Be Zero          |
 * +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
 *  0                   1                   2                   3
 *//*
 *  0                   1                   2                   3
 *  0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
 * +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
 * |                      Route Distinguisher                      |
 * |                          (8 octets)                           |
 * +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
 * |                          IPv6 prefix                          |
 * |                          (16 octets)                          |
 * |                                                               |
 * |                                                               |
 * +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
 * | Prefix Length |                 Must Be Zero                  |
 * +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
 *//*
 *  0                   1                   2                   3
 *  0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
 * +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
 * |                      Route Distinguisher                      |
 * |                          (8 octets)                           |
 * +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
 * |                         IPv4 prefix                           |
 * +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
 * | Prefix Length |                 Must Be Zero                  |
 * +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
 *//*
 *  0                   1                   2                   3
 *  0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
 * +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
 * |                 IPv6 tunnel end point address                 |
 * |                                                               |
 * |                                                               |
 * |                                                               |
 * +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
 * |          Must Be Zero         |          Tunnel ID            |
 * +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
 * |                       Extended Tunnel ID                      |
 * |                                                               |
 * |                                                               |
 * |                                                               |
 * +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
 * |                   IPv6 tunnel sender address                  |
 * |                                                               |
 * |                                                               |
 * |                                                               |
 * +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
 * |          Must Be Zero         |            LSP ID             |
 * +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
 *//*
 *  0                   1                   2                   3
 *  0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
 * +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
 * |                 IPv4 tunnel end point address                 |
 * +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
 * |          Must Be Zero         |     Tunnel ID                 |
 * +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
 * |                       Extended Tunnel ID                      |
 * +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
 * |                   IPv4 tunnel sender address                  |
 * +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
 * |          Must Be Zero         |            LSP ID             |
 * +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
 *//*
 * 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
 * +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
 * |                    Sender identifier                          |
 * |                          (16 octets)                          |
 * |                                                               |
 * |                                                               |
 * +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
 * |                          IPv6 prefix                          |
 * |                          (16 octets)                          |
 * |                                                               |
 * |                                                               |
 * +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
 * | Prefix Length |                 Must Be Zero                  |
 * +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
 *//*
 * 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
 * +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
 * |                    Sender identifier                          |
 * +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
 * |                         IPv4 prefix                           |
 * +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
 * | Prefix Length |                 Must Be Zero                  |
 * +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
 *//*
 *  0                   1                   2                   3
 *  0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
 * +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
 * |                          IPv6 prefix                          |
 * |                          (16 octets)                          |
 * |                                                               |
 * |                                                               |
 * +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
 * | Prefix Length |         Must Be Zero                          |
 * +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
 *//*
 *  0                   1                   2                   3
 *  0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
 * +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
 * |                          IPv4 prefix                          |
 * +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
 * | Prefix Length |         Must Be Zero                          |
 * +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
 *//* draft-ietf-bfd-mpls-02 *//*
 * LSPPING TLV header
 *  0                   1                   2                   3
 *  0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
 * +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
 * |             Type              |            Length             |
 * +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
 * |                             Value                             |
 * .                                                               .
 * .                                                               .
 * .                                                               .
 * |                                                               |
 * +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
 *//*
 * LSPPING common header
 *
 *  0                   1                   2                   3
 *  0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
 * +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
 * |         Version Number        |         Must Be Zero          |
 * +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
 * |  Message Type |   Reply mode  |  Return Code  | Return Subcode|
 * +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
 * |                        Sender's Handle                        |
 * +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
 * |                        Sequence Number                        |
 * +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
 * |                    TimeStamp Sent (seconds)                   |
 * +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
 * |                  TimeStamp Sent (microseconds)                |
 * +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
 * |                  TimeStamp Received (seconds)                 |
 * +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
 * |                TimeStamp Received (microseconds)              |
 * +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
 * |                            TLVs ...                           |
 * .                                                               .
 * .                                                               .
 * .                                                               .
 *//Users/owura/Repos/codeql_eval/proj_repos/the-tcpdump-group-tcpdump-commit-0f95d441e4b5d7512cc5c326c8668a120e048eda/tcpdump/print-lwapp.clwapp_data_printconst lwapp_transport_headerconst lwapp_transport_header *lwapp_transport_header *lwapp_trans_header*lwapp_trans_headersizeof(*lwapp_trans_header)lwapp_trans_header->version(ndo, "LWAPP version %u packet not supported", LWAPP_EXTRACT_VERSION(lwapp_trans_header->version))(ndo, "LWAPP version %u packet not supported", (((lwapp_trans_header->version)&0xC0)>>6))LWAPP_VERSIONLWAPP version %u packet not supported(ndo, "LWAPPv%u, %s frame, Flags [%s], length %u", LWAPP_EXTRACT_VERSION(lwapp_trans_header->version), LWAPP_EXTRACT_CONTROL_BIT(lwapp_trans_header->version) ? "Control" : "Data", bittok2str(lwapp_header_bits_values,"none",(lwapp_trans_header->version)&0x07), len)(ndo, "LWAPPv%u, %s frame, Flags [%s], length %u", (((lwapp_trans_header->version)&0xC0)>>6), (((lwapp_trans_header->version)&0x04)>>2) ? "Control" : "Data", bittok2str(lwapp_header_bits_values,"none",(lwapp_trans_header->version)&0x07), len)LWAPPv%u, %s frame, Flags [%s], length %ulwapp_trans_header->length(ndo, "LWAPPv%u, %s frame, Radio-id  %u, Flags [%s], Frag-id  %u, length %u", LWAPP_EXTRACT_VERSION(lwapp_trans_header->version), LWAPP_EXTRACT_CONTROL_BIT(lwapp_trans_header->version) ? "Control" : "Data", LWAPP_EXTRACT_RID(lwapp_trans_header->version), bittok2str(lwapp_header_bits_values,"none",(lwapp_trans_header->version)&0x07), lwapp_trans_header->frag_id, tlen)(ndo, "LWAPPv%u, %s frame, Radio-id  %u, Flags [%s], Frag-id  %u, length %u", (((lwapp_trans_header->version)&0xC0)>>6), (((lwapp_trans_header->version)&0x04)>>2) ? "Control" : "Data", (((lwapp_trans_header->version)&0x38)>>3), bittok2str(lwapp_header_bits_values,"none",(lwapp_trans_header->version)&0x07), lwapp_trans_header->frag_id, tlen)LWAPPv%u, %s frame, Radio-id  %u, Flags [%s], Frag-id  %u, length %usizeof(const struct lwapp_transport_header)lwapp_control_printconst lwapp_control_headerconst lwapp_control_header *lwapp_control_header *lwapp_control_header(ndo, "LWAPPv%u, %s frame, Radio-id %u, Flags [%s], Frag-id %u, length %u", LWAPP_EXTRACT_VERSION(lwapp_trans_header->version), LWAPP_EXTRACT_CONTROL_BIT(lwapp_trans_header->version) ? "Control" : "Data", LWAPP_EXTRACT_RID(lwapp_trans_header->version), bittok2str(lwapp_header_bits_values,"none",(lwapp_trans_header->version)&0x07), lwapp_trans_header->frag_id, tlen)(ndo, "LWAPPv%u, %s frame, Radio-id %u, Flags [%s], Frag-id %u, length %u", (((lwapp_trans_header->version)&0xC0)>>6), (((lwapp_trans_header->version)&0x04)>>2) ? "Control" : "Data", (((lwapp_trans_header->version)&0x38)>>3), bittok2str(lwapp_header_bits_values,"none",(lwapp_trans_header->version)&0x07), lwapp_trans_header->frag_id, tlen)LWAPPv%u, %s frame, Radio-id %u, Flags [%s], Frag-id %u, length %u(ndo, "\n\tAP identity: %s", etheraddr_string(ndo, tptr))
	AP identity: %ssizeof(const struct lwapp_transport_header)+6sizeof(struct lwapp_control_header)lwapp_control_header->len(ndo, "\n\t  Msg type: %s (%u), Seqnum: %u, Msg len: %d, Session: 0x%08x", tok2str(lwapp_msg_type_values,"Unknown",lwapp_control_header->msg_type), lwapp_control_header->msg_type, lwapp_control_header->seq_num, msg_tlen, EXTRACT_32BITS(lwapp_control_header->session_id))(ndo, "\n\t  Msg type: %s (%u), Seqnum: %u, Msg len: %d, Session: 0x%08x", tok2str(lwapp_msg_type_values,"Unknown",lwapp_control_header->msg_type), lwapp_control_header->msg_type, lwapp_control_header->seq_num, msg_tlen, ((uint32_t)(((uint32_t)(*((const uint8_t *)(lwapp_control_header->session_id) + 0)) << 24) | ((uint32_t)(*((const uint8_t *)(lwapp_control_header->session_id) + 1)) << 16) | ((uint32_t)(*((const uint8_t *)(lwapp_control_header->session_id) + 2)) << 8) | ((uint32_t)(*((const uint8_t *)(lwapp_control_header->session_id) + 3)) << 0))))lwapp_control_header->session_id
	  Msg type: %s (%u), Seqnum: %u, Msg len: %d, Session: 0x%08xconst tok[32]tok[32]has_ap_identLWAPP_MSGTYPE_DISCOVERY_REQUESTLWAPP_MSGTYPE_DISCOVERY_RESPONSELWAPP_MSGTYPE_JOIN_REQUESTLWAPP_MSGTYPE_JOIN_RESPONSELWAPP_MSGTYPE_JOIN_ACKLWAPP_MSGTYPE_JOIN_CONFIRMLWAPP_MSGTYPE_CONFIGURE_REQUESTLWAPP_MSGTYPE_CONFIGURE_RESPONSELWAPP_MSGTYPE_CONF_UPDATE_REQUESTLWAPP_MSGTYPE_CONF_UPDATE_RESPONSELWAPP_MSGTYPE_WTP_EVENT_REQUESTLWAPP_MSGTYPE_WTP_EVENT_RESPONSELWAPP_MSGTYPE_CHANGE_STATE_EVENT_REQUESTLWAPP_MSGTYPE_CHANGE_STATE_EVENT_RESPONSELWAPP_MSGTYPE_ECHO_REQUESTLWAPP_MSGTYPE_ECHO_RESPONSELWAPP_MSGTYPE_IMAGE_DATA_REQUESTLWAPP_MSGTYPE_IMAGE_DATA_RESPONSELWAPP_MSGTYPE_RESET_REQUESTLWAPP_MSGTYPE_RESET_RESPONSELWAPP_MSGTYPE_KEY_UPDATE_REQUESTLWAPP_MSGTYPE_KEY_UPDATE_RESPONSELWAPP_MSGTYPE_PRIMARY_DISCOVERY_REQUESTLWAPP_MSGTYPE_PRIMARY_DISCOVERY_RESPONSELWAPP_MSGTYPE_DATA_TRANSFER_REQUESTLWAPP_MSGTYPE_DATA_TRANSFER_RESPONSELWAPP_MSGTYPE_CLEAR_CONFIG_INDICATIONLWAPP_MSGTYPE_WLAN_CONFIG_REQUESTLWAPP_MSGTYPE_WLAN_CONFIG_RESPONSELWAPP_MSGTYPE_MOBILE_CONFIG_REQUESTLWAPP_MSGTYPE_MOBILE_CONFIG_RESPONSElwapp_message_headerlwapp_transport_headersession_idseq_numfrag_idDiscovery req"Discovery req"Discovery resp"Discovery resp"Join req"Join req"Join resp"Join resp"Join ack"Join ack"Join confirm"Join confirm"Configure req"Configure req"Configure resp"Configure resp"Update req"Update req"Update resp"Update resp"WTP event req"WTP event req"WTP event resp"WTP event resp"Change state event req"Change state event req"Change state event resp"Change state event resp"Echo req"Echo req"Echo resp"Echo resp"Image data req"Image data req"Image data resp"Image data resp"Channel status req"Channel status req"Channel status resp"Channel status resp"Key update req"Key update req"Key update resp"Key update resp"Primary discovery req"Primary discovery req"Primary discovery resp"Primary discovery resp"Data transfer req"Data transfer req"Data transfer resp"Data transfer resp"Clear config ind"Clear config ind"Wlan config req"Wlan config req"Wlan config resp"Wlan config resp"Mobile config req"Mobile config req"Mobile config resp"Mobile config resp"lwapp_msg_type_valuesLast Fragment Bit"Last Fragment Bit"Fragment Bit"Fragment Bit"Control Bit"Control Bit"lwapp_header_bits_valuesLWAPP_EXTRACT_CONTROL_BIT(x)(((x)&0x04)>>2)LWAPP_EXTRACT_RID(x)(((x)&0x38)>>3)LWAPP_EXTRACT_VERSION(x)(((x)&0xC0)>>6)/* FIX - An IEEE 802.11 frame follows - hexdump for now *//* non-verbose *//* check if enough bytes for AP identity *//* XXX - Decode sub messages for each message *//* did we capture enough for fully decoding the message *//* print message header *//*
 * LWAPP message elements
 *
 * 0                   1                   2                   3
 * 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
 * +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
 * |      Type     |             Length            |   Value ...   |
 * +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
 *//*
 * LWAPP control header
 *      0                   1                   2                   3
 *      0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
 *     +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
 *     |  Message Type |    Seq Num    |      Msg Element Length       |
 *     +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
 *     |                           Session ID                          |
 *     +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
 *     |      Msg Element [0..N]       |
 *     +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
 *//*
 * LWAPP transport (common) header
 *      0                   1                   2                   3
 *     0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
 *    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
 *    |VER| RID |C|F|L|    Frag ID    |            Length             |
 *    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
 *    |          Status/WLANs         |   Payload...  |
 *    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
 *
 *//*
 * Copyright (c) 1998-2007 The TCPDUMP project
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that: (1) source code
 * distributions retain the above copyright notice and this paragraph
 * in its entirety, and (2) distributions including binary code include
 * the above copyright notice and this paragraph in its entirety in
 * the documentation or other materials provided with the distribution.
 * THIS SOFTWARE IS PROVIDED ``AS IS'' AND
 * WITHOUT ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, WITHOUT
 * LIMITATION, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS
 * FOR A PARTICULAR PURPOSE.
 *
 * Support for the Light Weight Access Point Protocol as per draft-ohara-capwap-lwapp-04
 *
 * Original code by Carles Kishimoto <carles.kishimoto@gmail.com>
 *//Users/owura/Repos/codeql_eval/proj_repos/the-tcpdump-group-tcpdump-commit-0f95d441e4b5d7512cc5c326c8668a120e048eda/tcpdump/print-lwres.clwres_printconst lwres_lwpacketconst lwres_lwpacket *lwres_lwpacket *responsenp->authlengthsizeof(np->authlength)const lwres_uint16_tconst lwres_uint16_t *(ndo, " lwres") lwres&np->version(ndo, " v%u", v)LWRES_LWPACKETVERSION_0 v%u&np->lengthconst lwres_uint32_tconst lwres_uint32_t *&np->pktflagsLWRES_LWPACKETFLAG_RESPONSE&np->opcode#0x%x"#0x%x"(ndo, " %s%s", s, response ? "" : "?")(ndo, "[0x%x]", v)~LWRES_LWPACKETFLAG_RESPONSE[0x%x](ndo, "serial:0x%x", EXTRACT_32BITS(&np->serial))(ndo, "serial:0x%x", ((uint32_t)(((uint32_t)(*((const uint8_t *)(&np->serial) + 0)) << 24) | ((uint32_t)(*((const uint8_t *)(&np->serial) + 1)) << 16) | ((uint32_t)(*((const uint8_t *)(&np->serial) + 2)) << 8) | ((uint32_t)(*((const uint8_t *)(&np->serial) + 3)) << 0))))&np->serial(ndo, " result:0x%x", EXTRACT_32BITS(&np->result))(ndo, " result:0x%x", ((uint32_t)(((uint32_t)(*((const uint8_t *)(&np->result) + 0)) << 24) | ((uint32_t)(*((const uint8_t *)(&np->result) + 1)) << 16) | ((uint32_t)(*((const uint8_t *)(&np->result) + 2)) << 8) | ((uint32_t)(*((const uint8_t *)(&np->result) + 3)) << 0))))&np->result(ndo, " recvlen:%u", EXTRACT_32BITS(&np->recvlength))(ndo, " recvlen:%u", ((uint32_t)(((uint32_t)(*((const uint8_t *)(&np->recvlength) + 0)) << 24) | ((uint32_t)(*((const uint8_t *)(&np->recvlength) + 1)) << 16) | ((uint32_t)(*((const uint8_t *)(&np->recvlength) + 2)) << 8) | ((uint32_t)(*((const uint8_t *)(&np->recvlength) + 3)) << 0))))&np->recvlength(ndo, " authtype:0x%x", EXTRACT_16BITS(&np->authtype))(ndo, " authtype:0x%x", ((uint16_t)(((uint16_t)(*((const uint8_t *)(&np->authtype) + 0)) << 8) | ((uint16_t)(*((const uint8_t *)(&np->authtype) + 1)) << 0))))&np->authtype(ndo, " authlen:%u", EXTRACT_16BITS(&np->authlength))(ndo, " authlen:%u", ((uint16_t)(((uint16_t)(*((const uint8_t *)(&np->authlength) + 0)) << 8) | ((uint16_t)(*((const uint8_t *)(&np->authlength) + 1)) << 0))))&np->authlengthserial:0x%x result:0x%x recvlen:%u authtype:0x%x authlen:%ugabn->namelensizeof(gabn->namelen)&gabn->namelen(ndo, " flags:0x%x", EXTRACT_32BITS(&gabn->flags))(ndo, " flags:0x%x", ((uint32_t)(((uint32_t)(*((const uint8_t *)(&gabn->flags) + 0)) << 24) | ((uint32_t)(*((const uint8_t *)(&gabn->flags) + 1)) << 16) | ((uint32_t)(*((const uint8_t *)(&gabn->flags) + 2)) << 8) | ((uint32_t)(*((const uint8_t *)(&gabn->flags) + 3)) << 0))))&gabn->flags&gabn->addrtypes(ndo, " IPv4")(ndo, " IPv6")(ndo, " IPv4/6")gnba->addrsizeof(gnba->addr)(ndo, " flags:0x%x", EXTRACT_32BITS(&gnba->flags))(ndo, " flags:0x%x", ((uint32_t)(((uint32_t)(*((const uint8_t *)(&gnba->flags) + 0)) << 24) | ((uint32_t)(*((const uint8_t *)(&gnba->flags) + 1)) << 16) | ((uint32_t)(*((const uint8_t *)(&gnba->flags) + 2)) << 8) | ((uint32_t)(*((const uint8_t *)(&gnba->flags) + 3)) << 0))))&gnba->flagsgrbn->namelensizeof(grbn->namelen)(ndo, " flags:0x%x", EXTRACT_32BITS(&grbn->flags))(ndo, " flags:0x%x", ((uint32_t)(((uint32_t)(*((const uint8_t *)(&grbn->flags) + 0)) << 24) | ((uint32_t)(*((const uint8_t *)(&grbn->flags) + 1)) << 16) | ((uint32_t)(*((const uint8_t *)(&grbn->flags) + 2)) << 8) | ((uint32_t)(*((const uint8_t *)(&grbn->flags) + 3)) << 0))))&grbn->flags(ndo, " %s", tok2str(ns_type2str, "Type%d", EXTRACT_16BITS(&grbn->rdtype)))(ndo, " %s", tok2str(ns_type2str, "Type%d", ((uint16_t)(((uint16_t)(*((const uint8_t *)(&grbn->rdtype) + 0)) << 8) | ((uint16_t)(*((const uint8_t *)(&grbn->rdtype) + 1)) << 0)))))&grbn->rdtype&grbn->rdclass(ndo, " %s", tok2str(ns_class2str, "Class%d", EXTRACT_16BITS(&grbn->rdclass)))(ndo, " %s", tok2str(ns_class2str, "Class%d", ((uint16_t)(((uint16_t)(*((const uint8_t *)(&grbn->rdclass) + 0)) << 8) | ((uint16_t)(*((const uint8_t *)(&grbn->rdclass) + 1)) << 0)))))&grbn->namelengabn->realnamelensizeof(gabn->realnamelen)&gabn->realnamelen(ndo, " %u/%u", EXTRACT_16BITS(&gabn->naliases), EXTRACT_16BITS(&gabn->naddrs))(ndo, " %u/%u", ((uint16_t)(((uint16_t)(*((const uint8_t *)(&gabn->naliases) + 0)) << 8) | ((uint16_t)(*((const uint8_t *)(&gabn->naliases) + 1)) << 0))), ((uint16_t)(((uint16_t)(*((const uint8_t *)(&gabn->naddrs) + 0)) << 8) | ((uint16_t)(*((const uint8_t *)(&gabn->naddrs) + 1)) << 0))))&gabn->naliases&gabn->naddrsgnba->realnamelensizeof(gnba->realnamelen)&gnba->realnamelen(ndo, " %u", EXTRACT_16BITS(&gnba->naliases))(ndo, " %u", ((uint16_t)(((uint16_t)(*((const uint8_t *)(&gnba->naliases) + 0)) << 8) | ((uint16_t)(*((const uint8_t *)(&gnba->naliases) + 1)) << 0))))&gnba->naliasesgrbn->nsigssizeof(grbn->nsigs)(ndo, " TTL ")&grbn->ttl(ndo, " %u/%u", EXTRACT_16BITS(&grbn->nrdatas), EXTRACT_16BITS(&grbn->nsigs))(ndo, " %u/%u", ((uint16_t)(((uint16_t)(*((const uint8_t *)(&grbn->nrdatas) + 0)) << 8) | ((uint16_t)(*((const uint8_t *)(&grbn->nrdatas) + 1)) << 0))), ((uint16_t)(((uint16_t)(*((const uint8_t *)(&grbn->nsigs) + 0)) << 8) | ((uint16_t)(*((const uint8_t *)(&grbn->nsigs) + 1)) << 0))))&grbn->nrdatas&grbn->nsigslwres_gabnrequest_t *gabnlwres_gnbarequest_t *gnbalwres_grbnrequest_t *grbnLWRES_OPCODE_NOOP65537LWRES_OPCODE_GETADDRSBYNAMElwres_uint16_t * flags:0x%xlwres_uint32_t *LWRES_ADDRTYPE_V4LWRES_ADDRTYPE_V6(LWRES_ADDRTYPE_V4 | LWRES_ADDRTYPE_V6) IPv4 IPv6 IPv4/6~(LWRES_ADDRTYPE_V4 | LWRES_ADDRTYPE_V6)65538LWRES_OPCODE_GETNAMEBYADDRlwres_addr_t *lwres_addr *65539LWRES_OPCODE_GETRDATABYNAMEClass%dlwres_gabnresponse_t *lwres_gnbaresponse_t *lwres_grbnresponse_t *na %u/%u TTL (ndo, " [len: %u != %u]", EXTRACT_32BITS(&np->length), length)(ndo, " [len: %u != %u]", ((uint32_t)(((uint32_t)(*((const uint8_t *)(&np->length) + 0)) << 24) | ((uint32_t)(*((const uint8_t *)(&np->length) + 1)) << 16) | ((uint32_t)(*((const uint8_t *)(&np->length) + 2)) << 8) | ((uint32_t)(*((const uint8_t *)(&np->length) + 3)) << 0))), length) [len: %u != %u](ndo, "[extra]")[extra](ndo, "[|lwres]")[|lwres]lwres_printaddrap->lengthsizeof(ap->length)&ap->length&ap->family(ndo, " %s", ipaddr_string(ndo, p))(ndo, " %s", getname(ndo, (const u_char *)(p)))(ndo, " %u/", EXTRACT_32BITS(&ap->family))(ndo, " %u/", ((uint32_t)(((uint32_t)(*((const uint8_t *)(&ap->family) + 0)) << 24) | ((uint32_t)(*((const uint8_t *)(&ap->family) + 1)) << 16) | ((uint32_t)(*((const uint8_t *)(&ap->family) + 2)) << 8) | ((uint32_t)(*((const uint8_t *)(&ap->family) + 3)) << 0))))(ndo, "%02x", *p++) %u/lwres_printbinlenlwres_printnamelenlwres_printnamelwres_grbnresponse_tlwres_grbnrequest_tlwres_gnbaresponse_tlwres_gnbarequest_tlwres_gabnresponse_tlwres_gabnrequest_tlwres_addr_tlwres_addrlwres_noopresponse_tlwres_nooprequest_tlwres_lwpacketlwres_uint8_tlwres_uint16_tlwres_uint32_tnsigsnrdatasrdtyperdclassnamelenrealnamelennaliasesnaddrsaddrtypesfamilydatalengthauthlengthauthtyperecvlengthserialpktflagsnoop"noop"getaddrsbyname"getaddrsbyname"getnamebyaddr"getnamebyaddr"getrdatabyname"getrdatabyname"LWRES_MAX_ADDRSLWRES_MAX_ALIASES0x00000002U0x00000001ULWRDATA_VALIDATED0x00010003U0x00010002U0x00010001U0x00000000ULWRES_FLAG_SECUREDATALWRES_FLAG_TRUSTNOTREQUIRED0x0001U/* length mismatch *//* XXX how should we print it? *//* sigs *//* XXX should decode resource data *//* rdatas *//* XXX grbn points to packed struct *//* BIND910: not used *//* XXX no trace, not tested *//* aliases *//* XXX gnba points to packed struct *//* addrs *//* XXX gabn points to packed struct *//*
		 * responses
		 *//*
		 * queries
		 *//* per-opcode content *//*(*//*)*//* pktflags *//* opcode and pktflags *//* IPv4 *//* XXX ap points to packed struct *//* skip terminating \0 *//* + 1 for terminating \0 *//* print-domain.c *//* max # of addrs *//* max # of aliases *//* ipv6 *//* ipv4 *//* signatures here (len + name) *//* rdata here (len + name) *//* realname here (len + name) *//* public *//* name follows *//*
 * get rdata by name
 *//* realname follows *//* aliases follows *//* addr body follows *//*
 * get name by address
 *//* addrs follows *//* address folows *//*
 * get addresses by name
 *//* data follows *//*
 * no-op
 *//* if set, pkt is a response *//* BIND9 lib/lwres/include/lwres *//*
 * Copyright (C) 2001 WIDE Project.
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. Neither the name of the project nor the names of its contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE PROJECT AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE PROJECT OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 */p0/Users/owura/Repos/codeql_eval/proj_repos/the-tcpdump-group-tcpdump-commit-0f95d441e4b5d7512cc5c326c8668a120e048eda/tcpdump/print-m3ua.cm3ua_printconst m3ua_common_headerconst m3ua_common_header *m3ua_common_header *dictsizeof(struct m3ua_common_header)M3UA_REL_1_0M3UA_MSGC_MGMTM3UA_MSGC_TRANSFERM3UA_MSGC_SSNMM3UA_MSGC_ASPSMM3UA_MSGC_ASPTMM3UA_MSGC_RKM(ndo, "\n\t\t%s", tok2str(MessageClasses, "Unknown message class %i", hdr->msg_class))
		%sUnknown message class %i(ndo, " %s Message", tok2str(dict, "Unknown (0x%02x)", hdr->msg_type)) %s Message&hdr->len(ndo, "\n\t\t\t@@@@@@ Corrupted length %u of message @@@@@@", EXTRACT_32BITS(&hdr->len))(ndo, "\n\t\t\t@@@@@@ Corrupted length %u of message @@@@@@", ((uint32_t)(((uint32_t)(*((const uint8_t *)(&hdr->len) + 0)) << 24) | ((uint32_t)(*((const uint8_t *)(&hdr->len) + 1)) << 16) | ((uint32_t)(*((const uint8_t *)(&hdr->len) + 2)) << 8) | ((uint32_t)(*((const uint8_t *)(&hdr->len) + 3)) << 0))))
			@@@@@@ Corrupted length %u of message @@@@@@*bufm3ua_tags_printalignhdr_tagsizeof(struct m3ua_param_header)(ndo, "\n\t\t\t%s: ", tok2str(ParamName, "Unknown Parameter (0x%04x)", hdr_tag))hdr_len + align
			%s: const tok[25]tok[25]Unknown Parameter (0x%04x)tag_value_print(ndo, "0x%08x", EXTRACT_32BITS(buf))(ndo, "0x%08x", ((uint32_t)(((uint32_t)(*((const uint8_t *)(buf) + 0)) << 24) | ((uint32_t)(*((const uint8_t *)(buf) + 1)) << 16) | ((uint32_t)(*((const uint8_t *)(buf) + 2)) << 8) | ((uint32_t)(*((const uint8_t *)(buf) + 3)) << 0))))(ndo, "(length %u)", size + (u_int)sizeof(struct m3ua_param_header))M3UA_PARAM_NETWORK_APPEARANCEM3UA_PARAM_ROUTING_CTXM3UA_PARAM_CORR_ID(length %u)m3ua_param_headerm3ua_common_headermsg_classM3UA_PARAM_INFOINFO String"INFO String"Routing Context"Routing Context"M3UA_PARAM_DIAGNOSTICDiagnostic Info"Diagnostic Info"M3UA_PARAM_HB_DATAHeartbeat Data"Heartbeat Data"M3UA_PARAM_TRAFFIC_MODE_TYPETraffic Mode Type"Traffic Mode Type"M3UA_PARAM_ERROR_CODEM3UA_PARAM_STATUSM3UA_PARAM_ASP_IDASP Identifier"ASP Identifier"M3UA_PARAM_AFFECTED_POINT_CODEAffected Point Code"Affected Point Code"Correlation ID"Correlation ID"Network Appearance"Network Appearance"M3UA_PARAM_USERUser/Cause"User/Cause"M3UA_PARAM_CONGESTION_INDICATIONCongestion Indications"Congestion Indications"518M3UA_PARAM_CONCERNED_DSTConcerned Destination"Concerned Destination"519M3UA_PARAM_ROUTING_KEYRouting Key"Routing Key"M3UA_PARAM_REG_RESULTRegistration Result"Registration Result"521M3UA_PARAM_DEREG_RESULTDeregistration Result"Deregistration Result"522M3UA_PARAM_LOCAL_ROUTING_KEY_IDLocal Routing Key Identifier"Local Routing Key Identifier"523M3UA_PARAM_DST_POINT_CODEDestination Point Code"Destination Point Code"524M3UA_PARAM_SIService Indicators"Service Indicators"526M3UA_PARAM_ORIGIN_POINT_CODE_LISTOriginating Point Code List"Originating Point Code List"528M3UA_PARAM_PROTO_DATAProtocol Data"Protocol Data"530M3UA_PARAM_REG_STATUSRegistration Status"Registration Status"531M3UA_PARAM_DEREG_STATUSDeregistration Status"Deregistration Status"ParamNameM3UA_RKM_REQRegistration Request"Registration Request"M3UA_RKM_RSPRegistration Response"Registration Response"M3UA_RKM_DEREQDeregistration Request"Deregistration Request"M3UA_RKM_DERSPDeregistration Response"Deregistration Response"RoutingKeyMgmtMessagesM3UA_ASP_AC"Active"M3UA_ASP_IA"Inactive"M3UA_ASP_AC_ACKActive Acknowledgement"Active Acknowledgement"M3UA_ASP_IA_ACKInactive Acknowledgement"Inactive Acknowledgement"ASPTrafficMessagesM3UA_ASP_UPM3UA_ASP_DNM3UA_ASP_BEATHeartbeat"Heartbeat"M3UA_ASP_UP_ACKUp Acknowledgement"Up Acknowledgement"M3UA_ASP_DN_ACKDown Acknowledgement"Down Acknowledgement"M3UA_ASP_BEAT_ACKHeartbeat Acknowledgement"Heartbeat Acknowledgement"ASPStateMessagesM3UA_SSNM_DUNADestination Unavailable"Destination Unavailable"M3UA_SSNM_DAVADestination Available"Destination Available"M3UA_SSNM_DAUDDestination State Audit"Destination State Audit"M3UA_SSNM_SCONSignalling Congestion"Signalling Congestion"M3UA_SSNM_DUPUDestination User Part Unavailable"Destination User Part Unavailable"M3UA_SSNM_DRSTDestination Restricted"Destination Restricted"SS7MessagesM3UA_TRANSFER_DATATransferMessagesM3UA_MGMT_ERRORM3UA_MGMT_NOTIFYNotify"Notify"MgmtMessagesManagement"Management"Transfer"Transfer"SS7"SS7"ASP"ASP"Routing Key Managment"Routing Key Managment"MessageClasses [|m3ua]" [|m3ua]"0x02130x02120x02100x020e0x020c0x020b0x020a0x02090x02080x02070x02060x00130x00120x000d0x000c/* size includes the header *//*
 *     0                   1                   2                   3
 *     0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
 *    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
 *    |    Version    |   Reserved    | Message Class | Message Type  |
 *    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
 *    |                        Message Length                         |
 *    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
 *    \                                                               \
 *    /                                                               /
 *//* Parameter Value *//* Parameter Length *//* Parameter Tag *//*
 *     0                   1                   2                   3
 *     0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
 *    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
 *    |          Parameter Tag        |       Parameter Length        |
 *    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
 *    \                                                               \
 *    /                       Parameter Value                         /
 *    \                                                               \
 *    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
 *//* ... *//* buf and size don't include the header *//* M3UA Parameters *//* Routing Key Management messages *//* ASP Traffic Maintenance messages *//* ASP State Maintenance messages *//* SS7 Signaling Network Management messages *//* transfer messages *//* management messages *//* reserved values *//* message classes *//* RFC 4666 *//* Copyright (c) 2013, The TCPDUMP project
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *
 * 1. Redistributions of source code must retain the above copyright notice, this
 *    list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright notice,
 *    this list of conditions and the following disclaimer in the documentation
 *    and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
 * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR
 * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
 * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
 * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
 * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
 * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 *//Users/owura/Repos/codeql_eval/proj_repos/the-tcpdump-group-tcpdump-commit-0f95d441e4b5d7512cc5c326c8668a120e048eda/tcpdump/print-mobile.cmobile_printconst mobile_ipconst mobile_ip *mobile_ip *mobcrcosp*mobsizeof(*mob)(ndo, "[|mobile]")MOBILE_SIZE[|mobile](ndo, "mobile: ")mobile: &mob->proto&mob->hcheckOSRC_PRES(ndo, "[S] ")(ndo, "%s ", ipaddr_string(ndo, &mob->osrc))(ndo, "%s ", getname(ndo, (const u_char *)(&mob->osrc)))&mob->osrc(ndo, "[] ")[S] [] (ndo, "> %s ", ipaddr_string(ndo, &mob->odst))(ndo, "> %s ", getname(ndo, (const u_char *)(&mob->odst)))&mob->odst(ndo, "(oproto=%d)", proto>>8)> %s (oproto=%d)(ndo, " (bad checksum %d)", crc) (bad checksum %d)mobile_iposrcodsthcheck(8)/* old source address present *//*
 * Deencapsulate and print a mobile-tunneled IP datagram
 *//* old source is present *//*
 * (c) 1998 The NetBSD Foundation, Inc.
 * All rights reserved.
 *
 * This code is derived from software contributed to The NetBSD Foundation
 * by Heiko W.Rupp <hwr@pilhuhn.de>
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *        This product includes software developed by the NetBSD
 *        Foundation, Inc. and its contributors.
 * 4. Neither the name of The NetBSD Foundation nor the names of its
 *    contributors may be used to endorse or promote products derived
 *    from this software without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE NETBSD FOUNDATION, INC. AND CONTRIBUTORS
 * ``AS IS'' AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED
 * TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
 * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL THE FOUNDATION OR CONTRIBUTORS
 * BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
 * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
 * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
 * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
 * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
 * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
 * POSSIBILITY OF SUCH DAMAGE.
 *//*	$NetBSD: print-mobile.c,v 1.2 1998/09/30 08:57:01 hwr Exp $ *//Users/owura/Repos/codeql_eval/proj_repos/the-tcpdump-group-tcpdump-commit-0f95d441e4b5d7512cc5c326c8668a120e048eda/tcpdump/print-mpcp.cmpcp_printmpcpgrant_numbersgrantqueue_setsqueue_setreport_bitmapreportconst mpcp_common_header_tconst mpcp_common_header_t *mpcp_common_header_t *sizeof(const struct mpcp_common_header_t)mpcp.common_header->opcode(ndo, "MPCP, Opcode %s", tok2str(mpcp_opcode_values, "Unknown (%u)", opcode))MPCP, Opcode %s(ndo, ", Timestamp %u ticks", EXTRACT_32BITS(mpcp.common_header->timestamp))(ndo, ", Timestamp %u ticks", ((uint32_t)(((uint32_t)(*((const uint8_t *)(mpcp.common_header->timestamp) + 0)) << 24) | ((uint32_t)(*((const uint8_t *)(mpcp.common_header->timestamp) + 1)) << 16) | ((uint32_t)(*((const uint8_t *)(mpcp.common_header->timestamp) + 2)) << 8) | ((uint32_t)(*((const uint8_t *)(mpcp.common_header->timestamp) + 3)) << 0))))mpcp.common_header->timestampMPCP_OPCODE_PAUSE, Timestamp %u ticksMPCP_TIMESTAMP_LENMPCP_GRANT_NUMBER_LEN(ndo, "\n\tGrant Numbers %u, Flags [ %s ]", grant_numbers, bittok2str(mpcp_grant_flag_values, "?", *tptr &~ MPCP_GRANT_NUMBER_MASK))(ndo, "\n\tGrant Numbers %u, Flags [ %s ]", grant_numbers, bittok2str(mpcp_grant_flag_values, "?", *tptr &~ 0x7))sizeof(const struct mpcp_grant_t)(ndo, "\n\tGrant #%u, Start-Time %u ticks, duration %u ticks", grant, EXTRACT_32BITS(mpcp.grant->starttime), EXTRACT_16BITS(mpcp.grant->duration))(ndo, "\n\tGrant #%u, Start-Time %u ticks, duration %u ticks", grant, ((uint32_t)(((uint32_t)(*((const uint8_t *)(mpcp.grant->starttime) + 0)) << 24) | ((uint32_t)(*((const uint8_t *)(mpcp.grant->starttime) + 1)) << 16) | ((uint32_t)(*((const uint8_t *)(mpcp.grant->starttime) + 2)) << 8) | ((uint32_t)(*((const uint8_t *)(mpcp.grant->starttime) + 3)) << 0))), ((uint16_t)(((uint16_t)(*((const uint8_t *)(mpcp.grant->duration) + 0)) << 8) | ((uint16_t)(*((const uint8_t *)(mpcp.grant->duration) + 1)) << 0))))mpcp.grant->starttimempcp.grant->durationMPCP_TIMESTAMP_DURATION_LEN(ndo, "\n\tSync-Time %u ticks", EXTRACT_16BITS(tptr))(ndo, "\n\tSync-Time %u ticks", ((uint16_t)(((uint16_t)(*((const uint8_t *)(tptr) + 0)) << 8) | ((uint16_t)(*((const uint8_t *)(tptr) + 1)) << 0))))MPCP_REPORT_QUEUESETS_LEN(ndo, "\n\tTotal Queue-Sets %u", queue_sets)MPCP_REPORT_REPORTBITMAP_LEN(ndo, "\n\t  Queue-Set #%u, Report-Bitmap [ %s ]", queue_sets, bittok2str(mpcp_report_bitmap_values, "Unknown", report_bitmap))(ndo, "\n\t    Q%u Report, Duration %u ticks", report, EXTRACT_16BITS(tptr))(ndo, "\n\t    Q%u Report, Duration %u ticks", report, ((uint16_t)(((uint16_t)(*((const uint8_t *)(tptr) + 0)) << 8) | ((uint16_t)(*((const uint8_t *)(tptr) + 1)) << 0))))sizeof(const struct mpcp_reg_req_t)(ndo, "\n\tFlags [ %s ], Pending-Grants %u", bittok2str(mpcp_reg_req_flag_values, "Reserved", mpcp.reg_req->flags), mpcp.reg_req->pending_grants)sizeof(const struct mpcp_reg_t)(ndo, "\n\tAssigned-Port %u, Flags [ %s ]" "\n\tSync-Time %u ticks, Echoed-Pending-Grants %u", EXTRACT_16BITS(mpcp.reg->assigned_port), bittok2str(mpcp_reg_flag_values, "Reserved", mpcp.reg->flags), EXTRACT_16BITS(mpcp.reg->sync_time), mpcp.reg->echoed_pending_grants)(ndo, "\n\tAssigned-Port %u, Flags [ %s ]" "\n\tSync-Time %u ticks, Echoed-Pending-Grants %u", ((uint16_t)(((uint16_t)(*((const uint8_t *)(mpcp.reg->assigned_port) + 0)) << 8) | ((uint16_t)(*((const uint8_t *)(mpcp.reg->assigned_port) + 1)) << 0))), bittok2str(mpcp_reg_flag_values, "Reserved", mpcp.reg->flags), ((uint16_t)(((uint16_t)(*((const uint8_t *)(mpcp.reg->sync_time) + 0)) << 8) | ((uint16_t)(*((const uint8_t *)(mpcp.reg->sync_time) + 1)) << 0))), mpcp.reg->echoed_pending_grants)mpcp.reg->assigned_portmpcp.reg->sync_timesizeof(const struct mpcp_reg_ack_t)(ndo, "\n\tEchoed-Assigned-Port %u, Flags [ %s ]" "\n\tEchoed-Sync-Time %u ticks", EXTRACT_16BITS(mpcp.reg_ack->echoed_assigned_port), bittok2str(mpcp_reg_ack_flag_values, "Reserved", mpcp.reg_ack->flags), EXTRACT_16BITS(mpcp.reg_ack->echoed_sync_time))(ndo, "\n\tEchoed-Assigned-Port %u, Flags [ %s ]" "\n\tEchoed-Sync-Time %u ticks", ((uint16_t)(((uint16_t)(*((const uint8_t *)(mpcp.reg_ack->echoed_assigned_port) + 0)) << 8) | ((uint16_t)(*((const uint8_t *)(mpcp.reg_ack->echoed_assigned_port) + 1)) << 0))), bittok2str(mpcp_reg_ack_flag_values, "Reserved", mpcp.reg_ack->flags), ((uint16_t)(((uint16_t)(*((const uint8_t *)(mpcp.reg_ack->echoed_sync_time) + 0)) << 8) | ((uint16_t)(*((const uint8_t *)(mpcp.reg_ack->echoed_sync_time) + 1)) << 0))))mpcp.reg_ack->echoed_assigned_portmpcp.reg_ack->echoed_sync_timeMPCP_OPCODE_GATEMPCP_GRANT_NUMBER_MASK
	Grant Numbers %u, Flags [ %s ]-8const mpcp_grant_tconst mpcp_grant_t *mpcp_grant_t *
	Grant #%u, Start-Time %u ticks, duration %u ticks
	Sync-Time %u ticksMPCP_OPCODE_REPORT
	Total Queue-Sets %u
	  Queue-Set #%u, Report-Bitmap [ %s ]
	    Q%u Report, Duration %u ticksMPCP_OPCODE_REG_REQconst mpcp_reg_req_tconst mpcp_reg_req_t *mpcp_reg_req_t *
	Flags [ %s ], Pending-Grants %uMPCP_OPCODE_REGconst mpcp_reg_tconst mpcp_reg_t *mpcp_reg_t *
	Assigned-Port %u, Flags [ %s ]
	Sync-Time %u ticks, Echoed-Pending-Grants %uMPCP_OPCODE_REG_ACKconst mpcp_reg_ack_tconst mpcp_reg_ack_t *mpcp_reg_ack_t *
	Echoed-Assigned-Port %u, Flags [ %s ]
	Echoed-Sync-Time %u ticks(ndo, "\n\t[|MPCP]")
	[|MPCP]mpcp_reg_ack_tmpcp_reg_tmpcp_reg_req_tmpcp_grant_tmpcp_common_header_treg_ackregreg_reqcommon_headerechoed_sync_timeechoed_assigned_portechoed_pending_grantssync_timeassigned_portpending_grantsstarttimempcp_reg_ack_flag_valuesQ0"Q0"Q1"Q1"Q2"Q2"Q3"Q3"Q4"Q4"Q5"Q5"Q6"Q6"Q7"Q7"mpcp_report_bitmap_valuesRe-Register"Re-Register"De-Register"De-Register"mpcp_reg_flag_valuesRegister"Register"mpcp_reg_req_flag_valuesDiscovery"Discovery"Force Grant #1"Force Grant #1"Force Grant #2"Force Grant #2"Force Grant #3"Force Grant #3"Force Grant #4"Force Grant #4"mpcp_grant_flag_valuesPause"Pause"Gate"Gate"Report"Report"Register Request"Register Request"Register ACK"Register ACK"mpcp_opcode_values/* unknown opcode - hexdump for now *//*
 * Copyright (c) 1998-2006 The TCPDUMP project
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that: (1) source code
 * distributions retain the above copyright notice and this paragraph
 * in its entirety, and (2) distributions including binary code include
 * the above copyright notice and this paragraph in its entirety in
 * the documentation or other materials provided with the distribution.
 * THIS SOFTWARE IS PROVIDED ``AS IS'' AND
 * WITHOUT ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, WITHOUT
 * LIMITATION, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS
 * FOR A PARTICULAR PURPOSE.
 *
 * support for the IEEE MPCP protocol as per 802.3ah
 *
 * Original code by Hannes Gredler (hannes@juniper.net)
 *//Users/owura/Repos/codeql_eval/proj_repos/the-tcpdump-group-tcpdump-commit-0f95d441e4b5d7512cc5c326c8668a120e048eda/tcpdump/print-mpls.cmpls_printlabel_entrylabel_stack_depthPT_UNKNOWN(ndo, "MPLS")MPLSsizeof(label_entry)(ndo, "%s(label %u", (label_stack_depth && ndo->ndo_vflag) ? "\n\t" : " ", MPLS_LABEL(label_entry))(ndo, "%s(label %u", (label_stack_depth && ndo->ndo_vflag) ? "\n\t" : " ", (((label_entry) & 0xfffff000) >> 12))(ndo, " (%s)", mpls_labelname[MPLS_LABEL(label_entry)])(ndo, " (%s)", mpls_labelname[(((label_entry) & 0xfffff000) >> 12)])(ndo, ", exp %u", MPLS_EXP(label_entry))(ndo, ", exp %u", (((label_entry) & 0x00000e00) >> 9))(ndo, ", ttl %u)", MPLS_TTL(label_entry))(ndo, ", ttl %u)", (((label_entry) & 0x000000ff) >> 0))%s(label %usizeof(mpls_labelname)sizeof(mpls_labelname[0])sizeof(mpls_labelname) / sizeof(mpls_labelname[0]), exp %u, ttl %u)PT_IPV4PT_IPV6PT_OSIlength - (p - bp)(ndo, ndo->ndo_vflag ? "\n\t" : " ")(ndo, "[|MPLS]")[|MPLS]mpls_packet_typeIPv4 explicit NULL"IPv4 explicit NULL"router alert"router alert"IPv6 explicit NULL"IPv6 explicit NULL"implicit NULL"implicit NULL"mpls_labelname/*
	 * Print the payload.
	 *//* ok bail out - we did not figure out what it is*//*
		 * Generally there's no indication of protocol in MPLS label
		 * encoding.
		 *
		 * However, draft-hsmit-isis-aal5mux-00.txt describes a
		 * technique for encapsulating IS-IS and IP traffic on the
		 * same ATM virtual circuit; you look at the first payload
		 * byte to determine the network layer protocol, based on
		 * the fact that
		 *
		 *	1) the first byte of an IP header is 0x45-0x4f
		 *	   for IPv4 and 0x60-0x6f for IPv6;
		 *
		 *	2) the first byte of an OSI CLNP packet is 0x81,
		 *	   the first byte of an OSI ES-IS packet is 0x82,
		 *	   and the first byte of an OSI IS-IS packet is
		 *	   0x83;
		 *
		 * so the network layer protocol can be inferred from the
		 * first byte of the packet, if the protocol is one of the
		 * ones listed above.
		 *
		 * Cisco sends control-plane traffic MPLS-encapsulated in
		 * this fashion.
		 *//* IPv6 explicit NULL label *//* IPv4 implicit NULL label *//* IPv4 explicit NULL label *//*
	 * Try to figure out the packet type.
	 *//*
 * RFC3032: MPLS label stack encoding
 *//*15*//*10*//*5*//*0*//Users/owura/Repos/codeql_eval/proj_repos/the-tcpdump-group-tcpdump-commit-0f95d441e4b5d7512cc5c326c8668a120e048eda/tcpdump/print-mptcp.cmptcp_printmptcp_option *MPTCP_OPT_SUBTYPE(opt->sub_etc)(((opt->sub_etc) >> 4) & 0xF)MPTCP_SUB_FCLOSE + 10x7 + 1opt->sub_etc(ndo, " %s", mptcp_options[subtype].name)const struct <unnamed>const struct <unnamed>[9]struct <unnamed>[9]const struct <unnamed> *mp_fast_close_print(ndo, " key 0x%" PRIx64, EXTRACT_64BITS(opt + 4))(ndo, " key 0x%" "ll" "x", ((uint64_t)(((uint64_t)(*((const uint8_t *)(opt + 4) + 0)) << 56) | ((uint64_t)(*((const uint8_t *)(opt + 4) + 1)) << 48) | ((uint64_t)(*((const uint8_t *)(opt + 4) + 2)) << 40) | ((uint64_t)(*((const uint8_t *)(opt + 4) + 3)) << 32) | ((uint64_t)(*((const uint8_t *)(opt + 4) + 4)) << 24) | ((uint64_t)(*((const uint8_t *)(opt + 4) + 5)) << 16) | ((uint64_t)(*((const uint8_t *)(opt + 4) + 6)) << 8) | ((uint64_t)(*((const uint8_t *)(opt + 4) + 7)) << 0)))) key 0x%llxopt + 4mp_fail_print(ndo, " seq %" PRIu64, EXTRACT_64BITS(opt + 4))(ndo, " seq %" "ll" "u", ((uint64_t)(((uint64_t)(*((const uint8_t *)(opt + 4) + 0)) << 56) | ((uint64_t)(*((const uint8_t *)(opt + 4) + 1)) << 48) | ((uint64_t)(*((const uint8_t *)(opt + 4) + 2)) << 40) | ((uint64_t)(*((const uint8_t *)(opt + 4) + 3)) << 32) | ((uint64_t)(*((const uint8_t *)(opt + 4) + 4)) << 24) | ((uint64_t)(*((const uint8_t *)(opt + 4) + 5)) << 16) | ((uint64_t)(*((const uint8_t *)(opt + 4) + 6)) << 8) | ((uint64_t)(*((const uint8_t *)(opt + 4) + 7)) << 0)))) seq %llump_prio_printmp_prio *mpp(ndo, " backup")(ndo, " non-backup")MP_PRIO_B backup non-backup(ndo, " id %u", mpp->addr_id) id %uremove_addr_printmp_remove_addr *remove_addraddr_id(ndo, " id") id(ndo, " %u", *addr_id++)add_addr_printmp_add_addr *add_addradd_addr->sub_ipveripver(ndo, " id %u", add_addr->addr_id)(ndo, " %s", ipaddr_string(ndo, add_addr->u.v4.addr))(ndo, " %s", getname(ndo, (const u_char *)(add_addr->u.v4.addr)))add_addr->u.v4.addr(ndo, ":%u", EXTRACT_16BITS(add_addr->u.v4.port))(ndo, ":%u", ((uint16_t)(((uint16_t)(*((const uint8_t *)(add_addr->u.v4.port) + 0)) << 8) | ((uint16_t)(*((const uint8_t *)(add_addr->u.v4.port) + 1)) << 0))))add_addr->u.v4.port(ndo, ":%u", EXTRACT_16BITS(add_addr->u.v6.port))(ndo, ":%u", ((uint16_t)(((uint16_t)(*((const uint8_t *)(add_addr->u.v6.port) + 0)) << 8) | ((uint16_t)(*((const uint8_t *)(add_addr->u.v6.port) + 1)) << 0))))add_addr->u.v6.portopt_lenmp_dss_printmp_dss *mdss(ndo, " fin")MP_DSS_F fin(ndo, " ack ")(ndo, "%" PRIu64, EXTRACT_64BITS(opt))(ndo, "%" "ll" "u", ((uint64_t)(((uint64_t)(*((const uint8_t *)(opt) + 0)) << 56) | ((uint64_t)(*((const uint8_t *)(opt) + 1)) << 48) | ((uint64_t)(*((const uint8_t *)(opt) + 2)) << 40) | ((uint64_t)(*((const uint8_t *)(opt) + 3)) << 32) | ((uint64_t)(*((const uint8_t *)(opt) + 4)) << 24) | ((uint64_t)(*((const uint8_t *)(opt) + 5)) << 16) | ((uint64_t)(*((const uint8_t *)(opt) + 6)) << 8) | ((uint64_t)(*((const uint8_t *)(opt) + 7)) << 0))))(ndo, "%u", EXTRACT_32BITS(opt))(ndo, "%u", ((uint32_t)(((uint32_t)(*((const uint8_t *)(opt) + 0)) << 24) | ((uint32_t)(*((const uint8_t *)(opt) + 1)) << 16) | ((uint32_t)(*((const uint8_t *)(opt) + 2)) << 8) | ((uint32_t)(*((const uint8_t *)(opt) + 3)) << 0))))MP_DSS_A ack MP_DSS_a%llu(ndo, " seq ")(ndo, " subseq %u", EXTRACT_32BITS(opt))(ndo, " subseq %u", ((uint32_t)(((uint32_t)(*((const uint8_t *)(opt) + 0)) << 24) | ((uint32_t)(*((const uint8_t *)(opt) + 1)) << 16) | ((uint32_t)(*((const uint8_t *)(opt) + 2)) << 8) | ((uint32_t)(*((const uint8_t *)(opt) + 3)) << 0))))(ndo, " len %u", EXTRACT_16BITS(opt))(ndo, " len %u", ((uint16_t)(((uint16_t)(*((const uint8_t *)(opt) + 0)) << 8) | ((uint16_t)(*((const uint8_t *)(opt) + 1)) << 0))))(ndo, " csum 0x%x", EXTRACT_16BITS(opt))(ndo, " csum 0x%x", ((uint16_t)(((uint16_t)(*((const uint8_t *)(opt) + 0)) << 8) | ((uint16_t)(*((const uint8_t *)(opt) + 1)) << 0))))MP_DSS_M seq MP_DSS_m subseq %u csum 0x%xmp_dss_lenmp_join_printmcsummp_join *mpj(TH_SYN | TH_ACK)(ndo, " id %u", mpj->addr_id)MP_JOIN_B(ndo, " token 0x%x" " nonce 0x%x", EXTRACT_32BITS(mpj->u.syn.token), EXTRACT_32BITS(mpj->u.syn.nonce))(ndo, " token 0x%x" " nonce 0x%x", ((uint32_t)(((uint32_t)(*((const uint8_t *)(mpj->u.syn.token) + 0)) << 24) | ((uint32_t)(*((const uint8_t *)(mpj->u.syn.token) + 1)) << 16) | ((uint32_t)(*((const uint8_t *)(mpj->u.syn.token) + 2)) << 8) | ((uint32_t)(*((const uint8_t *)(mpj->u.syn.token) + 3)) << 0))), ((uint32_t)(((uint32_t)(*((const uint8_t *)(mpj->u.syn.nonce) + 0)) << 24) | ((uint32_t)(*((const uint8_t *)(mpj->u.syn.nonce) + 1)) << 16) | ((uint32_t)(*((const uint8_t *)(mpj->u.syn.nonce) + 2)) << 8) | ((uint32_t)(*((const uint8_t *)(mpj->u.syn.nonce) + 3)) << 0))))mpj->u.syn.tokenmpj->u.syn.nonce(ndo, " hmac 0x%" PRIx64 " nonce 0x%x", EXTRACT_64BITS(mpj->u.synack.mac), EXTRACT_32BITS(mpj->u.synack.nonce))(ndo, " hmac 0x%" "ll" "x" " nonce 0x%x", ((uint64_t)(((uint64_t)(*((const uint8_t *)(mpj->u.synack.mac) + 0)) << 56) | ((uint64_t)(*((const uint8_t *)(mpj->u.synack.mac) + 1)) << 48) | ((uint64_t)(*((const uint8_t *)(mpj->u.synack.mac) + 2)) << 40) | ((uint64_t)(*((const uint8_t *)(mpj->u.synack.mac) + 3)) << 32) | ((uint64_t)(*((const uint8_t *)(mpj->u.synack.mac) + 4)) << 24) | ((uint64_t)(*((const uint8_t *)(mpj->u.synack.mac) + 5)) << 16) | ((uint64_t)(*((const uint8_t *)(mpj->u.synack.mac) + 6)) << 8) | ((uint64_t)(*((const uint8_t *)(mpj->u.synack.mac) + 7)) << 0))), ((uint32_t)(((uint32_t)(*((const uint8_t *)(mpj->u.synack.nonce) + 0)) << 24) | ((uint32_t)(*((const uint8_t *)(mpj->u.synack.nonce) + 1)) << 16) | ((uint32_t)(*((const uint8_t *)(mpj->u.synack.nonce) + 2)) << 8) | ((uint32_t)(*((const uint8_t *)(mpj->u.synack.nonce) + 3)) << 0))))mpj->u.synack.macmpj->u.synack.nonce(ndo, " hmac 0x")(ndo, "%02x", mpj->u.ack.mac[i]) token 0x%x nonce 0x%x hmac 0x%llx nonce 0x%x hmac 0xsizeof(mpj->u.ack.mac)mp_capable_printmp_capable *mpcmpc->sub_ver(ndo, " Unknown Version (%d)", MP_CAPABLE_OPT_VERSION(mpc->sub_ver))(ndo, " Unknown Version (%d)", (((mpc->sub_ver) >> 0) & 0xF)) Unknown Version (%d)(ndo, " csum")MP_CAPABLE_C csum(ndo, " {0x%" PRIx64, EXTRACT_64BITS(mpc->sender_key))(ndo, " {0x%" "ll" "x", ((uint64_t)(((uint64_t)(*((const uint8_t *)(mpc->sender_key) + 0)) << 56) | ((uint64_t)(*((const uint8_t *)(mpc->sender_key) + 1)) << 48) | ((uint64_t)(*((const uint8_t *)(mpc->sender_key) + 2)) << 40) | ((uint64_t)(*((const uint8_t *)(mpc->sender_key) + 3)) << 32) | ((uint64_t)(*((const uint8_t *)(mpc->sender_key) + 4)) << 24) | ((uint64_t)(*((const uint8_t *)(mpc->sender_key) + 5)) << 16) | ((uint64_t)(*((const uint8_t *)(mpc->sender_key) + 6)) << 8) | ((uint64_t)(*((const uint8_t *)(mpc->sender_key) + 7)) << 0)))) {0x%llxmpc->sender_key(ndo, ",0x%" PRIx64, EXTRACT_64BITS(mpc->receiver_key))(ndo, ",0x%" "ll" "x", ((uint64_t)(((uint64_t)(*((const uint8_t *)(mpc->receiver_key) + 0)) << 56) | ((uint64_t)(*((const uint8_t *)(mpc->receiver_key) + 1)) << 48) | ((uint64_t)(*((const uint8_t *)(mpc->receiver_key) + 2)) << 40) | ((uint64_t)(*((const uint8_t *)(mpc->receiver_key) + 3)) << 32) | ((uint64_t)(*((const uint8_t *)(mpc->receiver_key) + 4)) << 24) | ((uint64_t)(*((const uint8_t *)(mpc->receiver_key) + 5)) << 16) | ((uint64_t)(*((const uint8_t *)(mpc->receiver_key) + 6)) << 8) | ((uint64_t)(*((const uint8_t *)(mpc->receiver_key) + 7)) << 0))))mpc->receiver_key,0x%llxdummy_printmp_priomp_closemp_failmp_remove_addrmp_add_addrmp_dssmp_joinmp_capablemptcp_optionsub_bkindkeyrsvsubdata_seqresvaddrs_idsub_ipverv6v4synacksynmactokenreceiver_keysender_keysub_versub_etcconst struct <unnamed>[]struct <unnamed>[]capable"capable"join"join"add-addr"add-addr"rem-addr"rem-addr"prio"prio""fail"fast-close"fast-close"mptcp_optionsMP_ADD_ADDR_IPVER(sub_ipver)(((sub_ipver) >> 0) & 0xF)MP_CAPABLE_SMP_CAPABLE_OPT_VERSION(sub_ver)(((sub_ver) >> 0) & 0xF)MPTCP_OPT_SUBTYPE(sub_etc)(((sub_etc) >> 4) & 0xF)MPTCP_SUB_FCLOSEMPTCP_SUB_FAILMPTCP_SUB_PRIOMPTCP_SUB_REMOVE_ADDRMPTCP_SUB_ADD_ADDRMPTCP_SUB_DSSMPTCP_SUB_JOINMPTCP_SUB_CAPABLE/*
                 * The Checksum is present only if negotiated.
                 *//*
                 * Data Sequence Number (DSN), Subflow Sequence Number (SSN),
                 * Data-Level Length present, and Checksum possibly present.
                 * All but the Checksum are 10 bytes if the m flag is
                 * clear (4-byte DSN) and 14 bytes if the m flag is set
                 * (8-byte DSN).
                 *//* Ack present - 4 or 8 octets *//* ACK *//* SYN/ACK *//* SYN *//* list of addr_id *//* subtype upper 4 bits, other stuff lower 4 bits *//**
 * Copyright (c) 2012
 *
 * Gregory Detal <gregory.detal@uclouvain.be>
 * Christoph Paasch <christoph.paasch@uclouvain.be>
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 *
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 *
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 *
 * 3. Neither the name of the University nor of the Laboratory may be used
 *    to endorse or promote products derived from this software without
 *    specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 *//Users/owura/Repos/codeql_eval/proj_repos/the-tcpdump-group-tcpdump-commit-0f95d441e4b5d7512cc5c326c8668a120e048eda/tcpdump/print-msdp.cmsdp_print*spsp + 1MSDP_TYPE_MAX(ndo, " msdp:") msdp:(ndo, " [len %u]", len)(ndo, " SA")(ndo, " SA-Response")sizeof(*sp)(ndo, " %u entries", *sp)(ndo, " [w/data]")(ndo, " SA-Request")(ndo, " for %s", ipaddr_string(ndo, sp + 1))(ndo, " for %s", getname(ndo, (const u_char *)(sp + 1)))(ndo, " Keepalive")(ndo, "[len=%d] ", len)(ndo, " Notification")(ndo, " [type=%d len=%d]", type, len)1400 [len %u] SA SA-Response %u entries [w/data] SA-Request for %s Keepalive[len=%d]  Notification [type=%d len=%d](ndo, " [|msdp]") [|msdp]/* IPv4 Source-Active Response *//* IPv4 Source-Active *//* not really truncated, but still not decodable *//* See if we think we're at the beginning of a compound packet *//*
 * Copyright (c) 2001 William C. Fenner.
 *                All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that: (1) source code
 * distributions retain the above copyright notice and this paragraph
 * in its entirety, and (2) distributions including binary code include
 * the above copyright notice and this paragraph in its entirety in
 * the documentation or other materials provided with the distribution.
 * The name of William C. Fenner may not be used to endorse or
 * promote products derived from this software without specific prior
 * written permission.  THIS SOFTWARE IS PROVIDED ``AS IS'' AND
 * WITHOUT ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, WITHOUT
 * LIMITATION, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS
 * FOR A PARTICULAR PURPOSE.
 */sp/Users/owura/Repos/codeql_eval/proj_repos/the-tcpdump-group-tcpdump-commit-0f95d441e4b5d7512cc5c326c8668a120e048eda/tcpdump/print-msnlb.cmsnlb_printconst msnlb_heartbeat_pktconst msnlb_heartbeat_pkt *msnlb_heartbeat_pkt *hb*hbsizeof(*hb)(ndo, "MS NLB heartbeat, host priority: %u,", EXTRACT_LE_32BITS(&(hb->host_prio)))(ndo, "MS NLB heartbeat, host priority: %u,", ((uint32_t)(((uint32_t)(*((const uint8_t *)(&(hb->host_prio)) + 3)) << 24) | ((uint32_t)(*((const uint8_t *)(&(hb->host_prio)) + 2)) << 16) | ((uint32_t)(*((const uint8_t *)(&(hb->host_prio)) + 1)) << 8) | ((uint32_t)(*((const uint8_t *)(&(hb->host_prio)) + 0)) << 0))))MS NLB heartbeat, host priority: %u,&(hb->host_prio)(ndo, " cluster IP: %s,", ipaddr_string(ndo, &(hb->virtual_ip)))(ndo, " cluster IP: %s,", getname(ndo, (const u_char *)(&(hb->virtual_ip)))) cluster IP: %s,&(hb->virtual_ip)(ndo, " host IP: %s", ipaddr_string(ndo, &(hb->host_ip)))(ndo, " host IP: %s", getname(ndo, (const u_char *)(&(hb->host_ip)))) host IP: %s&(hb->host_ip)(ndo, "[|MS NLB]")[|MS NLB]msnlb_heartbeat_pkthost_ipvirtual_iphost_priounknown2unknown1/* the protocol is undocumented so we ignore the rest *//* little-endian *//*
 * Copyright (c) 2013 Romain Francoise <romain@orebokech.com>
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. Neither the name of the project nor the names of its contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE PROJECT AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE PROJECT OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 *//Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX.sdk/usr/include/pcap/nflog.hnflog_timestamp_tnflog_timestampnflog_hwaddr_tnflog_hwaddrnflog_packet_hdr_tnflog_packet_hdrnflog_tlv_tnflog_tlvnflog_hdr_tnflog_hdrusechw_addrhw_addrlenhookhw_protocoltlv_lengthnflog_ridnflog_versionnflog_familyNFULA_HWLENNFULA_HWHEADERNFULA_HWTYPENFULA_GIDNFULA_SEQ_GLOBALNFULA_SEQNFULA_UIDNFULA_PREFIXNFULA_PAYLOADNFULA_HWADDRNFULA_IFINDEX_PHYSOUTDEVNFULA_IFINDEX_PHYSINDEVNFULA_IFINDEX_OUTDEVNFULA_IFINDEX_INDEVNFULA_TIMESTAMPNFULA_MARKNFULA_PACKET_HDRlib_pcap_nflog_h/* length of skbuff's MAC-layer header *//* skbuff's MAC-layer header *//* ARPHRD_ type of skbuff's device *//* GID owning socket on which packet was sent/received *//* sequence number of pakets on all NFLOG sockets *//* sequence number of packets on this NFLOG socket *//* UID owning socket on which packet was sent/received *//* text string - null-terminated, count includes NUL *//* packet payload *//* nflog_hwaddr_t for hardware address *//* ifindex of physical device on which packet transmitted (not bridge group) *//* ifindex of physical device on which packet received (not bridge group) *//* ifindex of device on which packet transmitted (possibly bridge group) *//* ifindex of device on which packet received (possibly bridge group) *//* nflog_timestamp_t for skbuff's time stamp *//* packet mark from skbuff *//* nflog_packet_hdr_t *//*
 * TLV types.
 *//* address, up to 8 bytes *//* padding to 32-bit boundary *//* padding to 32 bits *//* netfilter hook *//* hw protocol *//* value follows this *//* tlv type *//* tlv length *//* resource ID *//* version *//* address family *//*
 * Structure of an NFLOG header and TLV parts, as described at
 * https://www.tcpdump.org/linktypes/LINKTYPE_NFLOG.html
 *
 * The NFLOG header is big-endian.
 *
 * The TLV length and type are in host byte order.  The value is either
 * big-endian or is an array of bytes in some externally-specified byte
 * order (text string, link-layer address, link-layer header, packet
 * data, etc.).
 *//*
 * Copyright (c) 2013, Petar Alilovic,
 * Faculty of Electrical Engineering and Computing, University of Zagreb
 * All rights reserved
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *
 * * Redistributions of source code must retain the above copyright notice,
 *	 this list of conditions and the following disclaimer.
 * * Redistributions in binary form must reproduce the above copyright
 *	 notice, this list of conditions and the following disclaimer in the
 *	 documentation and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE AUTHOR AND CONTRIBUTORS ``AS IS'' AND ANY
 * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
 * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED. IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS BE LIABLE FOR ANY
 * DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
 * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
 * SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
 * CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH
 * DAMAGE.
 *//Users/owura/Repos/codeql_eval/proj_repos/the-tcpdump-group-tcpdump-commit-0f95d441e4b5d7512cc5c326c8668a120e048eda/tcpdump/print-nflog.c<pcap/nflog.h>nflog_if_printconst nflog_hdr_tconst nflog_hdr_t *nflog_hdr *const nflog_tlv_tconst nflog_tlv_t *nflog_tlv *h_sizesizeof(nflog_hdr_t)(ndo, "[|nflog]")(int) sizeof(nflog_hdr_t)[|nflog](ndo, "version %u (unknown)", hdr->nflog_version)version %u (unknown)sizeof(nflog_tlv_t)nflog_hdr_print(ndo, "version %d, resource ID %d", hdr->nflog_version, ntohs(hdr->nflog_rid))(ndo, "version %d, resource ID %d", hdr->nflog_version, ((__uint16_t)(__builtin_constant_p(hdr->nflog_rid) ? ((__uint16_t)((((__uint16_t)(hdr->nflog_rid) & 0xff00U) >> 8) | (((__uint16_t)(hdr->nflog_rid) & 0x00ffU) << 8))) : _OSSwapInt16(hdr->nflog_rid))))version %d, resource ID %dhdr->nflog_rid(ndo,", family %s (%d)", tok2str(nflog_values, "Unknown", hdr->nflog_family), hdr->nflog_family)(ndo,", %s", tok2str(nflog_values, "Unknown NFLOG (0x%02x)", hdr->nflog_family))Unknown NFLOG (0x%02x)nflog_valuesdefined(DLT_NFLOG) && defined(HAVE_PCAP_NFLOG_H)/* defined(DLT_NFLOG) && defined(HAVE_PCAP_NFLOG_H) *//* AF_INET6 *//*
			 * This TLV's data is the packet payload.
			 * Skip past the TLV header, and break out
			 * of the loop so we print the packet data.
			 *//* No. *//* Do we have enough data for the full TLV? *//* Yes. Give up now. *//* Is the TLV's length less than the minimum? *//* We have some data.  Do we have enough for the TLV header? *//Users/owura/Repos/codeql_eval/proj_repos/the-tcpdump-group-tcpdump-commit-0f95d441e4b5d7512cc5c326c8668a120e048eda/tcpdump/nfs.hnfsv3_pathconfnfsv3_fsinfonfs_statfsnfsv3_sattrnfsv2_sattrnfs_fattrnfsv3specnfsv3_specnfsuint64nfs_uquadnfstime3nfsv3_timenfstime2nfsv2_timenfsfh_tnfsfhnfs_typeNFNONNFREGNFDIRNFBLKNFCHRNFLNKNFSOCKNFFIFOpc_casepreservingpc_caseinsensitivepc_chownrestrictedpc_notruncpc_namemaxpc_linkmaxfs_propertiesfs_timedeltafs_maxfilesizefs_dtpreffs_wtmultfs_wtpreffs_wtmaxfs_rtmultfs_rtpreffs_rtmaxsf_unsf_nfsv3sf_nfsv2nfsv3sf_invarsecnfsv3sf_afilesnfsv3sf_ffilesnfsv3sf_tfilesnfsv3sf_abytesnfsv3sf_fbytesnfsv3sf_tbytesnfsv2sf_bavailnfsv2sf_bfreenfsv2sf_blocksnfsv2sf_bsizenfsv2sf_tsizesa_mtimesa_mtimetypesa_atimesa_atimetypesa_sizesa_sizesetsa_gidsa_gidsetsa_uidsa_uidsetsa_modesa_modesetfa_unfa_gidfa_uidfa_nlinkfa_modefa_typefa_nfsv3fa_nfsv2nfsv3fa_ctimenfsv3fa_mtimenfsv3fa_atimenfsv3fa_fileidnfsv3fa_fsidnfsv3fa_rdevnfsv3fa_usednfsv3fa_sizenfsv2fa_ctimenfsv2fa_mtimenfsv2fa_atimenfsv2fa_fileidnfsv2fa_fsidnfsv2fa_blocksnfsv2fa_rdevnfsv2fa_blocksizenfsv2fa_sizespecdata2specdata1uint32_t[2]unsigned int[2]nfsuquadnfsv3_nsecnfsv3_secnfsv2_usecnfsv2_secu_char[64]NFS_SMALLFHfh_bytessf_invarsecsf_un.sf_nfsv3.nfsv3sf_invarsecsf_afilessf_un.sf_nfsv3.nfsv3sf_afilessf_ffilessf_un.sf_nfsv3.nfsv3sf_ffilessf_tfilessf_un.sf_nfsv3.nfsv3sf_tfilessf_abytessf_un.sf_nfsv3.nfsv3sf_abytessf_fbytessf_un.sf_nfsv3.nfsv3sf_fbytessf_tbytessf_un.sf_nfsv3.nfsv3sf_tbytessf_bavailsf_un.sf_nfsv2.nfsv2sf_bavailsf_bfreesf_un.sf_nfsv2.nfsv2sf_bfreesf_blockssf_un.sf_nfsv2.nfsv2sf_blockssf_bsizesf_un.sf_nfsv2.nfsv2sf_bsizesf_tsizesf_un.sf_nfsv2.nfsv2sf_tsizefa3_ctimefa_un.fa_nfsv3.nfsv3fa_ctimefa3_mtimefa_un.fa_nfsv3.nfsv3fa_mtimefa3_atimefa_un.fa_nfsv3.nfsv3fa_atimefa3_fileidfa_un.fa_nfsv3.nfsv3fa_fileidfa3_fsidfa_un.fa_nfsv3.nfsv3fa_fsidfa3_rdevfa_un.fa_nfsv3.nfsv3fa_rdevfa3_usedfa_un.fa_nfsv3.nfsv3fa_usedfa3_sizefa_un.fa_nfsv3.nfsv3fa_sizefa2_ctimefa_un.fa_nfsv2.nfsv2fa_ctimefa2_mtimefa_un.fa_nfsv2.nfsv2fa_mtimefa2_atimefa_un.fa_nfsv2.nfsv2fa_atimefa2_fileidfa_un.fa_nfsv2.nfsv2fa_fileidfa2_fsidfa_un.fa_nfsv2.nfsv2fa_fsidfa2_blocksfa_un.fa_nfsv2.nfsv2fa_blocksfa2_rdevfa_un.fa_nfsv2.nfsv2fa_rdevfa2_blocksizefa_un.fa_nfsv2.nfsv2fa_blocksizefa2_sizefa_un.fa_nfsv2.nfsv2fa_sizenfsv3tov_type(a)nv3tov_type[fxdr_unsigned(uint32_t,(a))&0x7]nfsv2tov_type(a)nv2tov_type[fxdr_unsigned(uint32_t,(a))&0x7]vtonfsv3_type(a)txdr_unsigned(nfsv3_type[((int32_t)(a))])vtonfsv2_type(a)txdr_unsigned(nfsv2_type[((int32_t)(a))])nfstov_mode(a)(fxdr_unsigned(uint16_t, (a))&07777)vtonfsv3_mode(m)txdr_unsigned((m) & 07777)vtonfsv2_mode(t,m)txdr_unsigned(((t) == VFIFO) ? MAKEIMODE(VCHR, (m)) : MAKEIMODE((t), (m)))NFSV3FSINFO_CANSETTIMENFSV3FSINFO_HOMOGENEOUSNFSV3FSINFO_SYMLINKNFSV3FSINFO_LINKNFSV3CREATE_NMODESNFSV3CREATE_EXCLUSIVENFSV3CREATE_GUARDEDNFSV3CREATE_UNCHECKEDNFSV3WRITE_NMODESNFSV3WRITE_FILESYNCNFSV3WRITE_DATASYNCNFSV3WRITE_UNSTABLENFSV3ACCESS_FULLNFSV3ACCESS_EXECUTENFSV3ACCESS_DELETENFSV3ACCESS_EXTENDNFSV3ACCESS_MODIFYNFSV3ACCESS_LOOKUPNFSV3ACCESS_READNFSV3ATTRTIME_NMODESNFSV3SATTRTIME_TOCLIENTNFSV3SATTRTIME_TOSERVERNFSV3SATTRTIME_DONTCHANGENFSV2PROC_STATFSNFSV2PROC_READDIRNFSV2PROC_RMDIRNFSV2PROC_MKDIRNFSV2PROC_SYMLINKNFSV2PROC_LINKNFSV2PROC_RENAMENFSV2PROC_REMOVENFSV2PROC_CREATENFSV2PROC_WRITENFSV2PROC_WRITECACHENFSV2PROC_NOOPNFSV2PROC_READNFSV2PROC_READLINKNFSV2PROC_LOOKUPNFSV2PROC_ROOTNFSV2PROC_SETATTRNFSV2PROC_GETATTRNFSV2PROC_NULLNFS_NPROCSNFSPROC_NOOPNQNFSPROC_EVICTEDNQNFSPROC_VACATEDNQNFSPROC_GETLEASENFSPROC_COMMITNFSPROC_PATHCONFNFSPROC_FSINFONFSPROC_FSSTATNFSPROC_READDIRPLUSNFSPROC_READDIRNFSPROC_LINKNFSPROC_RENAMENFSPROC_RMDIRNFSPROC_REMOVENFSPROC_MKNODNFSPROC_SYMLINKNFSPROC_MKDIRNFSPROC_CREATENFSPROC_WRITENFSPROC_READNFSPROC_READLINKNFSPROC_ACCESSNFSPROC_LOOKUPNFSPROC_SETATTRNFSPROC_GETATTRNFSPROC_NULLNFSX_STATFS(v3)((v3) ? NFSX_V3STATFS : NFSX_V2STATFS)NFSX_READDIR(v3)((v3) ? (5 * NFSX_UNSIGNED) : (2 * NFSX_UNSIGNED))NFSX_WRITEVERF(v3)((v3) ? NFSX_V3WRITEVERF : 0)NFSX_COOKIEVERF(v3)((v3) ? NFSX_V3COOKIEVERF : 0)NFSX_SATTR(v3)((v3) ? NFSX_V3SATTR : NFSX_V2SATTR)NFSX_WCCORFATTR(v3)((v3) ? NFSX_V3WCCDATA : NFSX_V2FATTR)NFSX_WCCDATA(v3)((v3) ? NFSX_V3WCCDATA : 0)NFSX_POSTOPORFATTR(v3)((v3) ? (NFSX_V3FATTR + NFSX_UNSIGNED) : NFSX_V2FATTR)NFSX_POSTOPATTR(v3)((v3) ? (NFSX_V3FATTR + NFSX_UNSIGNED) : 0)NFSX_PREOPATTR(v3)((v3) ? (7 * NFSX_UNSIGNED) : 0)NFSX_FATTR(v3)((v3) ? NFSX_V3FATTR : NFSX_V2FATTR)NFSX_SRVFH(v3)((v3) ? NFSX_V3FH : NFSX_V2FH)NFSX_FH(v3)((v3) ? (NFSX_V3FHMAX + NFSX_UNSIGNED) : NFSX_V2FH)NFSX_V3PATHCONFNFSX_V3FSINFONFSX_V3STATFSNFSX_V3CREATEVERFNFSX_V3WRITEVERFNFSX_V3COOKIEVERFNFSX_V3WCCDATA(NFSX_V3POSTOPATTR + 8 * NFSX_UNSIGNED)NFSX_V3POSTOPATTR(NFSX_V3FATTR + NFSX_UNSIGNED)NFSX_V3SRVSATTR(sizeof (struct nfsv3_sattr))NFSX_V3SATTRNFSX_V3FATTRNFSX_V3FHMAXNFSX_V2STATFSNFSX_V2COOKIENFSX_V2SATTRNFSX_V2FATTRNFSX_V2FHNFSX_UNSIGNEDNFSERR_RETERR0x80000000NFSERR_AUTHERRNFSERR_RETVOID0x20000000NFSERR_STALEWRITEVERF30001NFSERR_TRYLATERNFSERR_JUKEBOX10008NFSERR_BADTYPE10007NFSERR_SERVERFAULT10006NFSERR_TOOSMALL10005NFSERR_NOTSUPP10004NFSERR_BAD_COOKIE10003NFSERR_NOT_SYNC10002NFSERR_BADHANDLE10001NFSERR_WFLUSHNFSERR_REMOTENFSERR_STALENFSERR_DQUOTNFSERR_NOTEMPTYNFSERR_NAMETOLNFSERR_MLINKNFSERR_ROFSNFSERR_NOSPCNFSERR_FBIGNFSERR_INVALNFSERR_ISDIRNFSERR_NOTDIRNFSERR_NODEVNFSERR_XDEVNFSERR_EXISTNFSERR_ACCESNFSERR_NXIONFSERR_IONFSERR_NOENTNFSERR_PERMNFS_OKNFS_FABLKSIZENFS_MINPACKETNFS_MAXPACKET(NFS_MAXPKTHDR + NFS_MAXDATA)NFS_MAXPKTHDR404NFS_MAXNAMLENNFS_MAXPATHLENNFS_MAXDATANFS_MAXDGRAMDATANFS_V2MAXDATANFS_VER3NFS_VER2NFS_PROG100003/*
 * NFS Version 3 sattr structure for the new node creation case.
 *//* and some ugly defines for accessing union components *//*
 * File attributes and setable attributes. These structures cover both
 * NFS version 2 and the version 3 protocol. Note that the union is only
 * used so that one pointer can refer to both variants. These structures
 * go out on the wire and must be densely packed, so no quad data types
 * are used. (all fields are longs or u_longs or structures of same)
 * NB: You can't do sizeof(struct nfs_fattr), you must use the
 *     NFSX_FATTR(v3) macro.
 *//*
 * NFS Version 3 special file number.
 *//*
 * Quads are defined as arrays of 2 longs to ensure dense packing for the
 * protocol and to facilitate xdr conversion.
 *//*	fhandle_t fh_generic; *//*
 * File Handle (32 bytes for version 2), variable up to 64 for version 3.
 * File Handles of up to NFS_SMALLFH in size are stored directly in the
 * nfs node, whereas larger ones are malloc'd. (This never happens when
 * NFS_SMALLFH is set to 64.)
 * NFS_SMALLFH should be in the range of 32 to 64 and be divisible by 4.
 *//* Structs for common parts of the rpc's *//* File types *//* Conversion macros *//*
 * Constants used by the Version 3 protocol for various RPCs
 *//* Obsolete *//* Actual Version 2 procedure numbers *//* And leasing (nqnfs) procedure numbers (must be last) *//* nfs rpc procedure numbers (before version mapping) *//* variants for both versions *//* max. all fields filled in *//* max. allowed by protocol *//* size this server uses *//* specific to NFS Version 3 *//* specific to NFS Version 2 *//* Sizes in bytes of various nfs rpc components *//* Mark an error return for V3 *//* Mark an authentication error *//* Return void, not error *//* Fake return for nfs_commit() *//* The rest Version 3 only *//* Version 2 only *//* Version 3 only *//* Stat numbers for rpc returns (version 2 and 3) *//* Size in bytes of a block wrt fa_blocks *//*
 * Constants as defined in the Sun NFS Version 2 and 3 specs.
 * "NFS: Network File System Protocol Specification" RFC1094
 * and in the "NFS: Network File System Version 3 Protocol
 * Specification"
 *//*
 * nfs definitions as per the Version 2 and 3 specs
 *//*
 * Copyright (c) 1989, 1993
 *	The Regents of the University of California.  All rights reserved.
 *
 * This code is derived from software contributed to Berkeley by
 * Rick Macklem at The University of Guelph.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *	This product includes software developed by the University of
 *	California, Berkeley and its contributors.
 * 4. Neither the name of the University nor the names of its contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 *
 *	@(#)nfsproto.h	8.2 (Berkeley) 3/30/95
 *//*	NetBSD: nfs.h,v 1.1 1996/05/23 22:49:53 fvdl Exp 	*//Users/owura/Repos/codeql_eval/proj_repos/the-tcpdump-group-tcpdump-commit-0f95d441e4b5d7512cc5c326c8668a120e048eda/tcpdump/rpc_auth.hsunrpc_opaque_authsunrpc_auth_statSUNRPC_AUTH_OKSUNRPC_AUTH_BADCREDSUNRPC_AUTH_REJECTEDCREDSUNRPC_AUTH_BADVERFSUNRPC_AUTH_REJECTEDVERFSUNRPC_AUTH_TOOWEAKSUNRPC_AUTH_INVALIDRESPSUNRPC_AUTH_FAILEDoa_lenoa_flavorSUNRPC_AUTH_DESSUNRPC_AUTH_SHORTSUNRPC_AUTH_SYSSUNRPC_AUTH_UNIXSUNRPC_AUTH_NULLSUNRPC_AUTH_NONE/* des style (encrypted timestamps) *//* short hand unix style *//* unix style (uid, gids) *//* backward compatibility *//* no authentication *//* zero or more bytes of body *//* length of opaque body *//* flavor of auth *//*
 * Authentication info.  Opaque to client.
 *//* some unknown reason *//* bogus response verifier *//*
	 * failed locally
	*//* rejected due to security reasons *//* verifier expired or was replayed *//* bogus verifier (seal broken) *//* client should begin new session *//* bogus credentials (seal broken) *//*
	 * failed at remote end
	 *//*
 * Status returned from authentication check
 *//*
 * auth.h, Authentication interface.
 *
 * Copyright (C) 1984, Sun Microsystems, Inc.
 *
 * The data structures are completely opaque to the client.  The client
 * is required to pass a AUTH * to routines that create rpc
 * "sessions".
 *//*
 * Sun RPC is a product of Sun Microsystems, Inc. and is provided for
 * unrestricted use provided that this legend is included on all tape
 * media and as a part of the software program in whole or part.  Users
 * may copy or modify Sun RPC without charge, but are not authorized
 * to license or distribute it to anyone else except as part of a product or
 * program developed by the user.
 *
 * SUN RPC IS PROVIDED AS IS WITH NO WARRANTIES OF ANY KIND INCLUDING THE
 * WARRANTIES OF DESIGN, MERCHANTABILITY AND FITNESS FOR A PARTICULAR
 * PURPOSE, OR ARISING FROM A COURSE OF DEALING, USAGE OR TRADE PRACTICE.
 *
 * Sun RPC is provided with no support and without any obligation on the
 * part of Sun Microsystems, Inc. to assist in its use, correction,
 * modification or enhancement.
 *
 * SUN MICROSYSTEMS, INC. SHALL HAVE NO LIABILITY WITH RESPECT TO THE
 * INFRINGEMENT OF COPYRIGHTS, TRADE SECRETS OR ANY PATENTS BY SUN RPC
 * OR ANY PART THEREOF.
 *
 * In no event will Sun Microsystems, Inc. be liable for any lost revenue
 * or profits or other special, indirect and consequential damages, even if
 * Sun has been advised of the possibility of such damages.
 *
 * Sun Microsystems, Inc.
 * 2550 Garcia Avenue
 * Mountain View, California  94043
 *
 *	from: @(#)auth.h 1.17 88/02/08 SMI
 *	from: @(#)auth.h	2.3 88/08/07 4.0 RPCSRC
 * $FreeBSD: src/include/rpc/auth.h,v 1.14.2.1 1999/08/29 14:39:02 peter Exp $
 *//Users/owura/Repos/codeql_eval/proj_repos/the-tcpdump-group-tcpdump-commit-0f95d441e4b5d7512cc5c326c8668a120e048eda/tcpdump/rpc_msg.hsunrpc_msgsunrpc_call_bodysunrpc_reply_bodysunrpc_rejected_replysunrpc_reject_statSUNRPC_RPC_MISMATCHSUNRPC_AUTH_ERRORsunrpc_accept_statSUNRPC_SUCCESSSUNRPC_PROG_UNAVAILSUNRPC_PROG_MISMATCHSUNRPC_PROC_UNAVAILSUNRPC_GARBAGE_ARGSSUNRPC_SYSTEM_ERRsunrpc_reply_statSUNRPC_MSG_ACCEPTEDSUNRPC_MSG_DENIEDsunrpc_msg_typeSUNRPC_CALLSUNRPC_REPLYrurm_directionrm_xidRM_rmbRM_cmbcb_credcb_proccb_verscb_progcb_rpcversrp_rejectrp_statrj_statRJ_whyRJ_versionsrjcted_rplyru.RM_rmb.ru.RP_dracpted_rplyru.RM_rmb.ru.RP_arrm_replyru.RM_rmbrm_callru.RM_cmbrj_whyru.RJ_whyrj_versru.RJ_versionsSUNRPC_MSG_VERSION((uint32_t) 2)/* enum msg_type *//*
 * The rpc message
 *//* followed by opaque verifier *//* must be equal to two *//*
 * Body of an rpc request call.
 *//* if rejected *//* enum reply_stat *//*
 * Body of a reply to an rpc request.
 *//* enum auth_stat - why authentication did not work *//* enum reject_stat *//*
 * Reply to an rpc request that was rejected by the server.
 *//*
 * Reply part of an rpc exchange
 *//*
 * Bottom up definition of an rpc message.
 * NOTE: call and reply use the same overall stuct but
 * different parts of unions within it.
 *//*
 * rpc_msg.h
 * rpc message definition
 *
 * Copyright (C) 1984, Sun Microsystems, Inc.
 *//*
 * Sun RPC is a product of Sun Microsystems, Inc. and is provided for
 * unrestricted use provided that this legend is included on all tape
 * media and as a part of the software program in whole or part.  Users
 * may copy or modify Sun RPC without charge, but are not authorized
 * to license or distribute it to anyone else except as part of a product or
 * program developed by the user.
 *
 * SUN RPC IS PROVIDED AS IS WITH NO WARRANTIES OF ANY KIND INCLUDING THE
 * WARRANTIES OF DESIGN, MERCHANTABILITY AND FITNESS FOR A PARTICULAR
 * PURPOSE, OR ARISING FROM A COURSE OF DEALING, USAGE OR TRADE PRACTICE.
 *
 * Sun RPC is provided with no support and without any obligation on the
 * part of Sun Microsystems, Inc. to assist in its use, correction,
 * modification or enhancement.
 *
 * SUN MICROSYSTEMS, INC. SHALL HAVE NO LIABILITY WITH RESPECT TO THE
 * INFRINGEMENT OF COPYRIGHTS, TRADE SECRETS OR ANY PATENTS BY SUN RPC
 * OR ANY PART THEREOF.
 *
 * In no event will Sun Microsystems, Inc. be liable for any lost revenue
 * or profits or other special, indirect and consequential damages, even if
 * Sun has been advised of the possibility of such damages.
 *
 * Sun Microsystems, Inc.
 * 2550 Garcia Avenue
 * Mountain View, California  94043
 *
 *	from: @(#)rpc_msg.h 1.7 86/07/16 SMI
 *	from: @(#)rpc_msg.h	2.1 88/07/29 4.0 RPCSRC
 * $FreeBSD: src/include/rpc/rpc_msg.h,v 1.11.2.1 1999/08/29 14:39:07 peter Exp $
 *//Users/owura/Repos/codeql_eval/proj_repos/the-tcpdump-group-tcpdump-commit-0f95d441e4b5d7512cc5c326c8668a120e048eda/tcpdump/print-nfs.c"rpc_msg.h""rpc_auth.h""nfs.h"interp_replyconst sunrpc_msgconst sunrpc_msg *sunrpc_msg *v3eruint32_t[26]unsigned int[26](ndo, " %s", tok2str(nfsproc_str, "proc-%u", proc))proc-%u(ndo, " post dattr:")(ndo, " attr:")(ndo, " c %04x", EXTRACT_32BITS(&dp[0]))(ndo, " c %04x", ((uint32_t)(((uint32_t)(*((const uint8_t *)(&dp[0]) + 0)) << 24) | ((uint32_t)(*((const uint8_t *)(&dp[0]) + 1)) << 16) | ((uint32_t)(*((const uint8_t *)(&dp[0]) + 2)) << 8) | ((uint32_t)(*((const uint8_t *)(&dp[0]) + 3)) << 0))))&dp[0]dp[1]sizeof(dp[1])(ndo, " %u bytes", EXTRACT_32BITS(&dp[0]))(ndo, " %u bytes", ((uint32_t)(((uint32_t)(*((const uint8_t *)(&dp[0]) + 0)) << 24) | ((uint32_t)(*((const uint8_t *)(&dp[0]) + 1)) << 16) | ((uint32_t)(*((const uint8_t *)(&dp[0]) + 2)) << 8) | ((uint32_t)(*((const uint8_t *)(&dp[0]) + 3)) << 0))))&dp[1](ndo, " EOF")dp[0]sizeof(dp[0])(ndo, " <%s>", tok2str(nfsv3_writemodes, NULL, EXTRACT_32BITS(&dp[1])))(ndo, " <%s>", tok2str(nfsv3_writemodes, ((void *)0), ((uint32_t)(((uint32_t)(*((const uint8_t *)(&dp[1]) + 0)) << 24) | ((uint32_t)(*((const uint8_t *)(&dp[1]) + 1)) << 16) | ((uint32_t)(*((const uint8_t *)(&dp[1]) + 2)) << 8) | ((uint32_t)(*((const uint8_t *)(&dp[1]) + 3)) << 0)))))(ndo, " from:")(ndo, " to:")(ndo, " file POST:")(ndo, " dir:") post dattr: attr: c %04x %u bytes EOFproc <%s> from: to: file POST: dir:parsepathconfnfsv3_pathconf *spp(ndo, " POST:") POST:*sppsizeof(*spp)(ndo, " linkmax %u namemax %u %s %s %s %s", EXTRACT_32BITS(&spp->pc_linkmax), EXTRACT_32BITS(&spp->pc_namemax), EXTRACT_32BITS(&spp->pc_notrunc) ? "notrunc" : "", EXTRACT_32BITS(&spp->pc_chownrestricted) ? "chownres" : "", EXTRACT_32BITS(&spp->pc_caseinsensitive) ? "igncase" : "", EXTRACT_32BITS(&spp->pc_casepreserving) ? "keepcase" : "")(ndo, " linkmax %u namemax %u %s %s %s %s", ((uint32_t)(((uint32_t)(*((const uint8_t *)(&spp->pc_linkmax) + 0)) << 24) | ((uint32_t)(*((const uint8_t *)(&spp->pc_linkmax) + 1)) << 16) | ((uint32_t)(*((const uint8_t *)(&spp->pc_linkmax) + 2)) << 8) | ((uint32_t)(*((const uint8_t *)(&spp->pc_linkmax) + 3)) << 0))), ((uint32_t)(((uint32_t)(*((const uint8_t *)(&spp->pc_namemax) + 0)) << 24) | ((uint32_t)(*((const uint8_t *)(&spp->pc_namemax) + 1)) << 16) | ((uint32_t)(*((const uint8_t *)(&spp->pc_namemax) + 2)) << 8) | ((uint32_t)(*((const uint8_t *)(&spp->pc_namemax) + 3)) << 0))), ((uint32_t)(((uint32_t)(*((const uint8_t *)(&spp->pc_notrunc) + 0)) << 24) | ((uint32_t)(*((const uint8_t *)(&spp->pc_notrunc) + 1)) << 16) | ((uint32_t)(*((const uint8_t *)(&spp->pc_notrunc) + 2)) << 8) | ((uint32_t)(*((const uint8_t *)(&spp->pc_notrunc) + 3)) << 0))) ? "notrunc" : "", ((uint32_t)(((uint32_t)(*((const uint8_t *)(&spp->pc_chownrestricted) + 0)) << 24) | ((uint32_t)(*((const uint8_t *)(&spp->pc_chownrestricted) + 1)) << 16) | ((uint32_t)(*((const uint8_t *)(&spp->pc_chownrestricted) + 2)) << 8) | ((uint32_t)(*((const uint8_t *)(&spp->pc_chownrestricted) + 3)) << 0))) ? "chownres" : "", ((uint32_t)(((uint32_t)(*((const uint8_t *)(&spp->pc_caseinsensitive) + 0)) << 24) | ((uint32_t)(*((const uint8_t *)(&spp->pc_caseinsensitive) + 1)) << 16) | ((uint32_t)(*((const uint8_t *)(&spp->pc_caseinsensitive) + 2)) << 8) | ((uint32_t)(*((const uint8_t *)(&spp->pc_caseinsensitive) + 3)) << 0))) ? "igncase" : "", ((uint32_t)(((uint32_t)(*((const uint8_t *)(&spp->pc_casepreserving) + 0)) << 24) | ((uint32_t)(*((const uint8_t *)(&spp->pc_casepreserving) + 1)) << 16) | ((uint32_t)(*((const uint8_t *)(&spp->pc_casepreserving) + 2)) << 8) | ((uint32_t)(*((const uint8_t *)(&spp->pc_casepreserving) + 3)) << 0))) ? "keepcase" : "") linkmax %u namemax %u %s %s %s %s&spp->pc_linkmax&spp->pc_namemax&spp->pc_notruncnotrunc&spp->pc_chownrestrictedchownres&spp->pc_caseinsensitiveigncase&spp->pc_casepreservingkeepcaseparsefsinfonfsv3_fsinfo *sfp*sfpsizeof(*sfp)(ndo, " rtmax %u rtpref %u wtmax %u wtpref %u dtpref %u", EXTRACT_32BITS(&sfp->fs_rtmax), EXTRACT_32BITS(&sfp->fs_rtpref), EXTRACT_32BITS(&sfp->fs_wtmax), EXTRACT_32BITS(&sfp->fs_wtpref), EXTRACT_32BITS(&sfp->fs_dtpref))(ndo, " rtmax %u rtpref %u wtmax %u wtpref %u dtpref %u", ((uint32_t)(((uint32_t)(*((const uint8_t *)(&sfp->fs_rtmax) + 0)) << 24) | ((uint32_t)(*((const uint8_t *)(&sfp->fs_rtmax) + 1)) << 16) | ((uint32_t)(*((const uint8_t *)(&sfp->fs_rtmax) + 2)) << 8) | ((uint32_t)(*((const uint8_t *)(&sfp->fs_rtmax) + 3)) << 0))), ((uint32_t)(((uint32_t)(*((const uint8_t *)(&sfp->fs_rtpref) + 0)) << 24) | ((uint32_t)(*((const uint8_t *)(&sfp->fs_rtpref) + 1)) << 16) | ((uint32_t)(*((const uint8_t *)(&sfp->fs_rtpref) + 2)) << 8) | ((uint32_t)(*((const uint8_t *)(&sfp->fs_rtpref) + 3)) << 0))), ((uint32_t)(((uint32_t)(*((const uint8_t *)(&sfp->fs_wtmax) + 0)) << 24) | ((uint32_t)(*((const uint8_t *)(&sfp->fs_wtmax) + 1)) << 16) | ((uint32_t)(*((const uint8_t *)(&sfp->fs_wtmax) + 2)) << 8) | ((uint32_t)(*((const uint8_t *)(&sfp->fs_wtmax) + 3)) << 0))), ((uint32_t)(((uint32_t)(*((const uint8_t *)(&sfp->fs_wtpref) + 0)) << 24) | ((uint32_t)(*((const uint8_t *)(&sfp->fs_wtpref) + 1)) << 16) | ((uint32_t)(*((const uint8_t *)(&sfp->fs_wtpref) + 2)) << 8) | ((uint32_t)(*((const uint8_t *)(&sfp->fs_wtpref) + 3)) << 0))), ((uint32_t)(((uint32_t)(*((const uint8_t *)(&sfp->fs_dtpref) + 0)) << 24) | ((uint32_t)(*((const uint8_t *)(&sfp->fs_dtpref) + 1)) << 16) | ((uint32_t)(*((const uint8_t *)(&sfp->fs_dtpref) + 2)) << 8) | ((uint32_t)(*((const uint8_t *)(&sfp->fs_dtpref) + 3)) << 0)))) rtmax %u rtpref %u wtmax %u wtpref %u dtpref %u&sfp->fs_rtmax&sfp->fs_rtpref&sfp->fs_wtmax&sfp->fs_wtpref&sfp->fs_dtpref(ndo, " rtmult %u wtmult %u maxfsz %" PRIu64, EXTRACT_32BITS(&sfp->fs_rtmult), EXTRACT_32BITS(&sfp->fs_wtmult), EXTRACT_64BITS((uint32_t *)&sfp->fs_maxfilesize))(ndo, " rtmult %u wtmult %u maxfsz %" "ll" "u", ((uint32_t)(((uint32_t)(*((const uint8_t *)(&sfp->fs_rtmult) + 0)) << 24) | ((uint32_t)(*((const uint8_t *)(&sfp->fs_rtmult) + 1)) << 16) | ((uint32_t)(*((const uint8_t *)(&sfp->fs_rtmult) + 2)) << 8) | ((uint32_t)(*((const uint8_t *)(&sfp->fs_rtmult) + 3)) << 0))), ((uint32_t)(((uint32_t)(*((const uint8_t *)(&sfp->fs_wtmult) + 0)) << 24) | ((uint32_t)(*((const uint8_t *)(&sfp->fs_wtmult) + 1)) << 16) | ((uint32_t)(*((const uint8_t *)(&sfp->fs_wtmult) + 2)) << 8) | ((uint32_t)(*((const uint8_t *)(&sfp->fs_wtmult) + 3)) << 0))), ((uint64_t)(((uint64_t)(*((const uint8_t *)((uint32_t *)&sfp->fs_maxfilesize) + 0)) << 56) | ((uint64_t)(*((const uint8_t *)((uint32_t *)&sfp->fs_maxfilesize) + 1)) << 48) | ((uint64_t)(*((const uint8_t *)((uint32_t *)&sfp->fs_maxfilesize) + 2)) << 40) | ((uint64_t)(*((const uint8_t *)((uint32_t *)&sfp->fs_maxfilesize) + 3)) << 32) | ((uint64_t)(*((const uint8_t *)((uint32_t *)&sfp->fs_maxfilesize) + 4)) << 24) | ((uint64_t)(*((const uint8_t *)((uint32_t *)&sfp->fs_maxfilesize) + 5)) << 16) | ((uint64_t)(*((const uint8_t *)((uint32_t *)&sfp->fs_maxfilesize) + 6)) << 8) | ((uint64_t)(*((const uint8_t *)((uint32_t *)&sfp->fs_maxfilesize) + 7)) << 0))))&sfp->fs_rtmult&sfp->fs_wtmult(uint32_t *)&sfp->fs_maxfilesize(ndo, " delta %u.%06u ", EXTRACT_32BITS(&sfp->fs_timedelta.nfsv3_sec), EXTRACT_32BITS(&sfp->fs_timedelta.nfsv3_nsec))(ndo, " delta %u.%06u ", ((uint32_t)(((uint32_t)(*((const uint8_t *)(&sfp->fs_timedelta.nfsv3_sec) + 0)) << 24) | ((uint32_t)(*((const uint8_t *)(&sfp->fs_timedelta.nfsv3_sec) + 1)) << 16) | ((uint32_t)(*((const uint8_t *)(&sfp->fs_timedelta.nfsv3_sec) + 2)) << 8) | ((uint32_t)(*((const uint8_t *)(&sfp->fs_timedelta.nfsv3_sec) + 3)) << 0))), ((uint32_t)(((uint32_t)(*((const uint8_t *)(&sfp->fs_timedelta.nfsv3_nsec) + 0)) << 24) | ((uint32_t)(*((const uint8_t *)(&sfp->fs_timedelta.nfsv3_nsec) + 1)) << 16) | ((uint32_t)(*((const uint8_t *)(&sfp->fs_timedelta.nfsv3_nsec) + 2)) << 8) | ((uint32_t)(*((const uint8_t *)(&sfp->fs_timedelta.nfsv3_nsec) + 3)) << 0))))&sfp->fs_timedelta.nfsv3_sec&sfp->fs_timedelta.nfsv3_nsec rtmult %u wtmult %u maxfsz %llunfsuint64 *nfs_uquad * delta %u.%06u parsev3rddirres(ndo, " verf %08x%08x", dp[0], dp[1]) verf %08x%08xparsewccresparsecreateopres(ndo, " dir attr:") dir attr:parse_wcc_data(ndo, " PRE:") PRE:parse_post_op_attrsizeof (uint32_t)(NFSX_V3FATTR / sizeof (uint32_t))parse_pre_op_attrverbose*dpparse_wcc_attr(ndo, " sz %" PRIu64, EXTRACT_64BITS(&dp[0]))(ndo, " sz %" "ll" "u", ((uint64_t)(((uint64_t)(*((const uint8_t *)(&dp[0]) + 0)) << 56) | ((uint64_t)(*((const uint8_t *)(&dp[0]) + 1)) << 48) | ((uint64_t)(*((const uint8_t *)(&dp[0]) + 2)) << 40) | ((uint64_t)(*((const uint8_t *)(&dp[0]) + 3)) << 32) | ((uint64_t)(*((const uint8_t *)(&dp[0]) + 4)) << 24) | ((uint64_t)(*((const uint8_t *)(&dp[0]) + 5)) << 16) | ((uint64_t)(*((const uint8_t *)(&dp[0]) + 6)) << 8) | ((uint64_t)(*((const uint8_t *)(&dp[0]) + 7)) << 0)))) sz %llu(ndo, " mtime %u.%06u ctime %u.%06u", EXTRACT_32BITS(&dp[2]), EXTRACT_32BITS(&dp[3]), EXTRACT_32BITS(&dp[4]), EXTRACT_32BITS(&dp[5]))(ndo, " mtime %u.%06u ctime %u.%06u", ((uint32_t)(((uint32_t)(*((const uint8_t *)(&dp[2]) + 0)) << 24) | ((uint32_t)(*((const uint8_t *)(&dp[2]) + 1)) << 16) | ((uint32_t)(*((const uint8_t *)(&dp[2]) + 2)) << 8) | ((uint32_t)(*((const uint8_t *)(&dp[2]) + 3)) << 0))), ((uint32_t)(((uint32_t)(*((const uint8_t *)(&dp[3]) + 0)) << 24) | ((uint32_t)(*((const uint8_t *)(&dp[3]) + 1)) << 16) | ((uint32_t)(*((const uint8_t *)(&dp[3]) + 2)) << 8) | ((uint32_t)(*((const uint8_t *)(&dp[3]) + 3)) << 0))), ((uint32_t)(((uint32_t)(*((const uint8_t *)(&dp[4]) + 0)) << 24) | ((uint32_t)(*((const uint8_t *)(&dp[4]) + 1)) << 16) | ((uint32_t)(*((const uint8_t *)(&dp[4]) + 2)) << 8) | ((uint32_t)(*((const uint8_t *)(&dp[4]) + 3)) << 0))), ((uint32_t)(((uint32_t)(*((const uint8_t *)(&dp[5]) + 0)) << 24) | ((uint32_t)(*((const uint8_t *)(&dp[5]) + 1)) << 16) | ((uint32_t)(*((const uint8_t *)(&dp[5]) + 2)) << 8) | ((uint32_t)(*((const uint8_t *)(&dp[5]) + 3)) << 0)))) mtime %u.%06u ctime %u.%06u&dp[2]&dp[3]&dp[4]&dp[5]parserddiresdp[2]sizeof(dp[2])(ndo, " offset 0x%x size %d ", EXTRACT_32BITS(&dp[0]), EXTRACT_32BITS(&dp[1]))(ndo, " offset 0x%x size %d ", ((uint32_t)(((uint32_t)(*((const uint8_t *)(&dp[0]) + 0)) << 24) | ((uint32_t)(*((const uint8_t *)(&dp[0]) + 1)) << 16) | ((uint32_t)(*((const uint8_t *)(&dp[0]) + 2)) << 8) | ((uint32_t)(*((const uint8_t *)(&dp[0]) + 3)) << 0))), ((uint32_t)(((uint32_t)(*((const uint8_t *)(&dp[1]) + 0)) << 24) | ((uint32_t)(*((const uint8_t *)(&dp[1]) + 1)) << 16) | ((uint32_t)(*((const uint8_t *)(&dp[1]) + 2)) << 8) | ((uint32_t)(*((const uint8_t *)(&dp[1]) + 3)) << 0)))) offset 0x%x size %d (ndo, " eof") eofparsestatfsconst nfs_statfsconst nfs_statfs *nfs_statfs *sfsp(v3 ? NFSX_V3STATFS : NFSX_V2STATFS)(v3 ? 52 : 20)(ndo, " tbytes %" PRIu64 " fbytes %" PRIu64 " abytes %" PRIu64, EXTRACT_64BITS((uint32_t *)&sfsp->sf_tbytes), EXTRACT_64BITS((uint32_t *)&sfsp->sf_fbytes), EXTRACT_64BITS((uint32_t *)&sfsp->sf_abytes))(ndo, " tbytes %" "ll" "u" " fbytes %" "ll" "u" " abytes %" "ll" "u", ((uint64_t)(((uint64_t)(*((const uint8_t *)((uint32_t *)&sfsp->sf_un.sf_nfsv3.nfsv3sf_tbytes) + 0)) << 56) | ((uint64_t)(*((const uint8_t *)((uint32_t *)&sfsp->sf_un.sf_nfsv3.nfsv3sf_tbytes) + 1)) << 48) | ((uint64_t)(*((const uint8_t *)((uint32_t *)&sfsp->sf_un.sf_nfsv3.nfsv3sf_tbytes) + 2)) << 40) | ((uint64_t)(*((const uint8_t *)((uint32_t *)&sfsp->sf_un.sf_nfsv3.nfsv3sf_tbytes) + 3)) << 32) | ((uint64_t)(*((const uint8_t *)((uint32_t *)&sfsp->sf_un.sf_nfsv3.nfsv3sf_tbytes) + 4)) << 24) | ((uint64_t)(*((const uint8_t *)((uint32_t *)&sfsp->sf_un.sf_nfsv3.nfsv3sf_tbytes) + 5)) << 16) | ((uint64_t)(*((const uint8_t *)((uint32_t *)&sfsp->sf_un.sf_nfsv3.nfsv3sf_tbytes) + 6)) << 8) | ((uint64_t)(*((const uint8_t *)((uint32_t *)&sfsp->sf_un.sf_nfsv3.nfsv3sf_tbytes) + 7)) << 0))), ((uint64_t)(((uint64_t)(*((const uint8_t *)((uint32_t *)&sfsp->sf_un.sf_nfsv3.nfsv3sf_fbytes) + 0)) << 56) | ((uint64_t)(*((const uint8_t *)((uint32_t *)&sfsp->sf_un.sf_nfsv3.nfsv3sf_fbytes) + 1)) << 48) | ((uint64_t)(*((const uint8_t *)((uint32_t *)&sfsp->sf_un.sf_nfsv3.nfsv3sf_fbytes) + 2)) << 40) | ((uint64_t)(*((const uint8_t *)((uint32_t *)&sfsp->sf_un.sf_nfsv3.nfsv3sf_fbytes) + 3)) << 32) | ((uint64_t)(*((const uint8_t *)((uint32_t *)&sfsp->sf_un.sf_nfsv3.nfsv3sf_fbytes) + 4)) << 24) | ((uint64_t)(*((const uint8_t *)((uint32_t *)&sfsp->sf_un.sf_nfsv3.nfsv3sf_fbytes) + 5)) << 16) | ((uint64_t)(*((const uint8_t *)((uint32_t *)&sfsp->sf_un.sf_nfsv3.nfsv3sf_fbytes) + 6)) << 8) | ((uint64_t)(*((const uint8_t *)((uint32_t *)&sfsp->sf_un.sf_nfsv3.nfsv3sf_fbytes) + 7)) << 0))), ((uint64_t)(((uint64_t)(*((const uint8_t *)((uint32_t *)&sfsp->sf_un.sf_nfsv3.nfsv3sf_abytes) + 0)) << 56) | ((uint64_t)(*((const uint8_t *)((uint32_t *)&sfsp->sf_un.sf_nfsv3.nfsv3sf_abytes) + 1)) << 48) | ((uint64_t)(*((const uint8_t *)((uint32_t *)&sfsp->sf_un.sf_nfsv3.nfsv3sf_abytes) + 2)) << 40) | ((uint64_t)(*((const uint8_t *)((uint32_t *)&sfsp->sf_un.sf_nfsv3.nfsv3sf_abytes) + 3)) << 32) | ((uint64_t)(*((const uint8_t *)((uint32_t *)&sfsp->sf_un.sf_nfsv3.nfsv3sf_abytes) + 4)) << 24) | ((uint64_t)(*((const uint8_t *)((uint32_t *)&sfsp->sf_un.sf_nfsv3.nfsv3sf_abytes) + 5)) << 16) | ((uint64_t)(*((const uint8_t *)((uint32_t *)&sfsp->sf_un.sf_nfsv3.nfsv3sf_abytes) + 6)) << 8) | ((uint64_t)(*((const uint8_t *)((uint32_t *)&sfsp->sf_un.sf_nfsv3.nfsv3sf_abytes) + 7)) << 0))))(uint32_t *)&sfsp->sf_tbytes(uint32_t *)&sfsp->sf_un.sf_nfsv3.nfsv3sf_tbytes(uint32_t *)&sfsp->sf_fbytes(uint32_t *)&sfsp->sf_un.sf_nfsv3.nfsv3sf_fbytes(uint32_t *)&sfsp->sf_abytes(uint32_t *)&sfsp->sf_un.sf_nfsv3.nfsv3sf_abytes(ndo, " tfiles %" PRIu64 " ffiles %" PRIu64 " afiles %" PRIu64 " invar %u", EXTRACT_64BITS((uint32_t *)&sfsp->sf_tfiles), EXTRACT_64BITS((uint32_t *)&sfsp->sf_ffiles), EXTRACT_64BITS((uint32_t *)&sfsp->sf_afiles), EXTRACT_32BITS(&sfsp->sf_invarsec))(ndo, " tfiles %" "ll" "u" " ffiles %" "ll" "u" " afiles %" "ll" "u" " invar %u", ((uint64_t)(((uint64_t)(*((const uint8_t *)((uint32_t *)&sfsp->sf_un.sf_nfsv3.nfsv3sf_tfiles) + 0)) << 56) | ((uint64_t)(*((const uint8_t *)((uint32_t *)&sfsp->sf_un.sf_nfsv3.nfsv3sf_tfiles) + 1)) << 48) | ((uint64_t)(*((const uint8_t *)((uint32_t *)&sfsp->sf_un.sf_nfsv3.nfsv3sf_tfiles) + 2)) << 40) | ((uint64_t)(*((const uint8_t *)((uint32_t *)&sfsp->sf_un.sf_nfsv3.nfsv3sf_tfiles) + 3)) << 32) | ((uint64_t)(*((const uint8_t *)((uint32_t *)&sfsp->sf_un.sf_nfsv3.nfsv3sf_tfiles) + 4)) << 24) | ((uint64_t)(*((const uint8_t *)((uint32_t *)&sfsp->sf_un.sf_nfsv3.nfsv3sf_tfiles) + 5)) << 16) | ((uint64_t)(*((const uint8_t *)((uint32_t *)&sfsp->sf_un.sf_nfsv3.nfsv3sf_tfiles) + 6)) << 8) | ((uint64_t)(*((const uint8_t *)((uint32_t *)&sfsp->sf_un.sf_nfsv3.nfsv3sf_tfiles) + 7)) << 0))), ((uint64_t)(((uint64_t)(*((const uint8_t *)((uint32_t *)&sfsp->sf_un.sf_nfsv3.nfsv3sf_ffiles) + 0)) << 56) | ((uint64_t)(*((const uint8_t *)((uint32_t *)&sfsp->sf_un.sf_nfsv3.nfsv3sf_ffiles) + 1)) << 48) | ((uint64_t)(*((const uint8_t *)((uint32_t *)&sfsp->sf_un.sf_nfsv3.nfsv3sf_ffiles) + 2)) << 40) | ((uint64_t)(*((const uint8_t *)((uint32_t *)&sfsp->sf_un.sf_nfsv3.nfsv3sf_ffiles) + 3)) << 32) | ((uint64_t)(*((const uint8_t *)((uint32_t *)&sfsp->sf_un.sf_nfsv3.nfsv3sf_ffiles) + 4)) << 24) | ((uint64_t)(*((const uint8_t *)((uint32_t *)&sfsp->sf_un.sf_nfsv3.nfsv3sf_ffiles) + 5)) << 16) | ((uint64_t)(*((const uint8_t *)((uint32_t *)&sfsp->sf_un.sf_nfsv3.nfsv3sf_ffiles) + 6)) << 8) | ((uint64_t)(*((const uint8_t *)((uint32_t *)&sfsp->sf_un.sf_nfsv3.nfsv3sf_ffiles) + 7)) << 0))), ((uint64_t)(((uint64_t)(*((const uint8_t *)((uint32_t *)&sfsp->sf_un.sf_nfsv3.nfsv3sf_afiles) + 0)) << 56) | ((uint64_t)(*((const uint8_t *)((uint32_t *)&sfsp->sf_un.sf_nfsv3.nfsv3sf_afiles) + 1)) << 48) | ((uint64_t)(*((const uint8_t *)((uint32_t *)&sfsp->sf_un.sf_nfsv3.nfsv3sf_afiles) + 2)) << 40) | ((uint64_t)(*((const uint8_t *)((uint32_t *)&sfsp->sf_un.sf_nfsv3.nfsv3sf_afiles) + 3)) << 32) | ((uint64_t)(*((const uint8_t *)((uint32_t *)&sfsp->sf_un.sf_nfsv3.nfsv3sf_afiles) + 4)) << 24) | ((uint64_t)(*((const uint8_t *)((uint32_t *)&sfsp->sf_un.sf_nfsv3.nfsv3sf_afiles) + 5)) << 16) | ((uint64_t)(*((const uint8_t *)((uint32_t *)&sfsp->sf_un.sf_nfsv3.nfsv3sf_afiles) + 6)) << 8) | ((uint64_t)(*((const uint8_t *)((uint32_t *)&sfsp->sf_un.sf_nfsv3.nfsv3sf_afiles) + 7)) << 0))), ((uint32_t)(((uint32_t)(*((const uint8_t *)(&sfsp->sf_un.sf_nfsv3.nfsv3sf_invarsec) + 0)) << 24) | ((uint32_t)(*((const uint8_t *)(&sfsp->sf_un.sf_nfsv3.nfsv3sf_invarsec) + 1)) << 16) | ((uint32_t)(*((const uint8_t *)(&sfsp->sf_un.sf_nfsv3.nfsv3sf_invarsec) + 2)) << 8) | ((uint32_t)(*((const uint8_t *)(&sfsp->sf_un.sf_nfsv3.nfsv3sf_invarsec) + 3)) << 0))))(uint32_t *)&sfsp->sf_tfiles(uint32_t *)&sfsp->sf_un.sf_nfsv3.nfsv3sf_tfiles(uint32_t *)&sfsp->sf_ffiles(uint32_t *)&sfsp->sf_un.sf_nfsv3.nfsv3sf_ffiles(uint32_t *)&sfsp->sf_afiles(uint32_t *)&sfsp->sf_un.sf_nfsv3.nfsv3sf_afiles&sfsp->sf_invarsec&sfsp->sf_un.sf_nfsv3.nfsv3sf_invarsec(ndo, " tsize %d bsize %d blocks %d bfree %d bavail %d", EXTRACT_32BITS(&sfsp->sf_tsize), EXTRACT_32BITS(&sfsp->sf_bsize), EXTRACT_32BITS(&sfsp->sf_blocks), EXTRACT_32BITS(&sfsp->sf_bfree), EXTRACT_32BITS(&sfsp->sf_bavail))(ndo, " tsize %d bsize %d blocks %d bfree %d bavail %d", ((uint32_t)(((uint32_t)(*((const uint8_t *)(&sfsp->sf_un.sf_nfsv2.nfsv2sf_tsize) + 0)) << 24) | ((uint32_t)(*((const uint8_t *)(&sfsp->sf_un.sf_nfsv2.nfsv2sf_tsize) + 1)) << 16) | ((uint32_t)(*((const uint8_t *)(&sfsp->sf_un.sf_nfsv2.nfsv2sf_tsize) + 2)) << 8) | ((uint32_t)(*((const uint8_t *)(&sfsp->sf_un.sf_nfsv2.nfsv2sf_tsize) + 3)) << 0))), ((uint32_t)(((uint32_t)(*((const uint8_t *)(&sfsp->sf_un.sf_nfsv2.nfsv2sf_bsize) + 0)) << 24) | ((uint32_t)(*((const uint8_t *)(&sfsp->sf_un.sf_nfsv2.nfsv2sf_bsize) + 1)) << 16) | ((uint32_t)(*((const uint8_t *)(&sfsp->sf_un.sf_nfsv2.nfsv2sf_bsize) + 2)) << 8) | ((uint32_t)(*((const uint8_t *)(&sfsp->sf_un.sf_nfsv2.nfsv2sf_bsize) + 3)) << 0))), ((uint32_t)(((uint32_t)(*((const uint8_t *)(&sfsp->sf_un.sf_nfsv2.nfsv2sf_blocks) + 0)) << 24) | ((uint32_t)(*((const uint8_t *)(&sfsp->sf_un.sf_nfsv2.nfsv2sf_blocks) + 1)) << 16) | ((uint32_t)(*((const uint8_t *)(&sfsp->sf_un.sf_nfsv2.nfsv2sf_blocks) + 2)) << 8) | ((uint32_t)(*((const uint8_t *)(&sfsp->sf_un.sf_nfsv2.nfsv2sf_blocks) + 3)) << 0))), ((uint32_t)(((uint32_t)(*((const uint8_t *)(&sfsp->sf_un.sf_nfsv2.nfsv2sf_bfree) + 0)) << 24) | ((uint32_t)(*((const uint8_t *)(&sfsp->sf_un.sf_nfsv2.nfsv2sf_bfree) + 1)) << 16) | ((uint32_t)(*((const uint8_t *)(&sfsp->sf_un.sf_nfsv2.nfsv2sf_bfree) + 2)) << 8) | ((uint32_t)(*((const uint8_t *)(&sfsp->sf_un.sf_nfsv2.nfsv2sf_bfree) + 3)) << 0))), ((uint32_t)(((uint32_t)(*((const uint8_t *)(&sfsp->sf_un.sf_nfsv2.nfsv2sf_bavail) + 0)) << 24) | ((uint32_t)(*((const uint8_t *)(&sfsp->sf_un.sf_nfsv2.nfsv2sf_bavail) + 1)) << 16) | ((uint32_t)(*((const uint8_t *)(&sfsp->sf_un.sf_nfsv2.nfsv2sf_bavail) + 2)) << 8) | ((uint32_t)(*((const uint8_t *)(&sfsp->sf_un.sf_nfsv2.nfsv2sf_bavail) + 3)) << 0))))&sfsp->sf_tsize&sfsp->sf_un.sf_nfsv2.nfsv2sf_tsize&sfsp->sf_bsize&sfsp->sf_un.sf_nfsv2.nfsv2sf_bsize&sfsp->sf_blocks&sfsp->sf_un.sf_nfsv2.nfsv2sf_blocks&sfsp->sf_bfree&sfsp->sf_un.sf_nfsv2.nfsv2sf_bfree&sfsp->sf_bavail&sfsp->sf_un.sf_nfsv2.nfsv2sf_bavail tbytes %llu fbytes %llu abytes %lluconst nfsuint64const nfsuint64 * tfiles %llu ffiles %llu afiles %llu invar %u tsize %d bsize %d blocks %d bfree %d bavail %dparselinkresparsediropresparseattrstatparsefattrconst nfs_fattrconst nfs_fattr *nfs_fattr *fapfap->fa_gidsizeof(fap->fa_gid)(ndo, " %s %o ids %d/%d", tok2str(type2str, "unk-ft %d ", EXTRACT_32BITS(&fap->fa_type)), EXTRACT_32BITS(&fap->fa_mode), EXTRACT_32BITS(&fap->fa_uid), EXTRACT_32BITS(&fap->fa_gid))(ndo, " %s %o ids %d/%d", tok2str(type2str, "unk-ft %d ", ((uint32_t)(((uint32_t)(*((const uint8_t *)(&fap->fa_type) + 0)) << 24) | ((uint32_t)(*((const uint8_t *)(&fap->fa_type) + 1)) << 16) | ((uint32_t)(*((const uint8_t *)(&fap->fa_type) + 2)) << 8) | ((uint32_t)(*((const uint8_t *)(&fap->fa_type) + 3)) << 0)))), ((uint32_t)(((uint32_t)(*((const uint8_t *)(&fap->fa_mode) + 0)) << 24) | ((uint32_t)(*((const uint8_t *)(&fap->fa_mode) + 1)) << 16) | ((uint32_t)(*((const uint8_t *)(&fap->fa_mode) + 2)) << 8) | ((uint32_t)(*((const uint8_t *)(&fap->fa_mode) + 3)) << 0))), ((uint32_t)(((uint32_t)(*((const uint8_t *)(&fap->fa_uid) + 0)) << 24) | ((uint32_t)(*((const uint8_t *)(&fap->fa_uid) + 1)) << 16) | ((uint32_t)(*((const uint8_t *)(&fap->fa_uid) + 2)) << 8) | ((uint32_t)(*((const uint8_t *)(&fap->fa_uid) + 3)) << 0))), ((uint32_t)(((uint32_t)(*((const uint8_t *)(&fap->fa_gid) + 0)) << 24) | ((uint32_t)(*((const uint8_t *)(&fap->fa_gid) + 1)) << 16) | ((uint32_t)(*((const uint8_t *)(&fap->fa_gid) + 2)) << 8) | ((uint32_t)(*((const uint8_t *)(&fap->fa_gid) + 3)) << 0))))&fap->fa_type&fap->fa_mode&fap->fa_uid&fap->fa_gidfap->fa3_sizefap->fa_un.fa_nfsv3.nfsv3fa_sizesizeof(fap->fa_un.fa_nfsv3.nfsv3fa_size)(ndo, " sz %" PRIu64, EXTRACT_64BITS((uint32_t *)&fap->fa3_size))(ndo, " sz %" "ll" "u", ((uint64_t)(((uint64_t)(*((const uint8_t *)((uint32_t *)&fap->fa_un.fa_nfsv3.nfsv3fa_size) + 0)) << 56) | ((uint64_t)(*((const uint8_t *)((uint32_t *)&fap->fa_un.fa_nfsv3.nfsv3fa_size) + 1)) << 48) | ((uint64_t)(*((const uint8_t *)((uint32_t *)&fap->fa_un.fa_nfsv3.nfsv3fa_size) + 2)) << 40) | ((uint64_t)(*((const uint8_t *)((uint32_t *)&fap->fa_un.fa_nfsv3.nfsv3fa_size) + 3)) << 32) | ((uint64_t)(*((const uint8_t *)((uint32_t *)&fap->fa_un.fa_nfsv3.nfsv3fa_size) + 4)) << 24) | ((uint64_t)(*((const uint8_t *)((uint32_t *)&fap->fa_un.fa_nfsv3.nfsv3fa_size) + 5)) << 16) | ((uint64_t)(*((const uint8_t *)((uint32_t *)&fap->fa_un.fa_nfsv3.nfsv3fa_size) + 6)) << 8) | ((uint64_t)(*((const uint8_t *)((uint32_t *)&fap->fa_un.fa_nfsv3.nfsv3fa_size) + 7)) << 0))))(uint32_t *)&fap->fa3_size(uint32_t *)&fap->fa_un.fa_nfsv3.nfsv3fa_sizefap->fa2_sizefap->fa_un.fa_nfsv2.nfsv2fa_sizesizeof(fap->fa_un.fa_nfsv2.nfsv2fa_size)(ndo, " sz %d", EXTRACT_32BITS(&fap->fa2_size))(ndo, " sz %d", ((uint32_t)(((uint32_t)(*((const uint8_t *)(&fap->fa_un.fa_nfsv2.nfsv2fa_size) + 0)) << 24) | ((uint32_t)(*((const uint8_t *)(&fap->fa_un.fa_nfsv2.nfsv2fa_size) + 1)) << 16) | ((uint32_t)(*((const uint8_t *)(&fap->fa_un.fa_nfsv2.nfsv2fa_size) + 2)) << 8) | ((uint32_t)(*((const uint8_t *)(&fap->fa_un.fa_nfsv2.nfsv2fa_size) + 3)) << 0))))&fap->fa2_size&fap->fa_un.fa_nfsv2.nfsv2fa_size %s %o ids %d/%dunk-ft %d  sz %dfap->fa3_ctimefap->fa_un.fa_nfsv3.nfsv3fa_ctimesizeof(fap->fa_un.fa_nfsv3.nfsv3fa_ctime)(ndo, " nlink %d rdev %d/%d", EXTRACT_32BITS(&fap->fa_nlink), EXTRACT_32BITS(&fap->fa3_rdev.specdata1), EXTRACT_32BITS(&fap->fa3_rdev.specdata2))(ndo, " nlink %d rdev %d/%d", ((uint32_t)(((uint32_t)(*((const uint8_t *)(&fap->fa_nlink) + 0)) << 24) | ((uint32_t)(*((const uint8_t *)(&fap->fa_nlink) + 1)) << 16) | ((uint32_t)(*((const uint8_t *)(&fap->fa_nlink) + 2)) << 8) | ((uint32_t)(*((const uint8_t *)(&fap->fa_nlink) + 3)) << 0))), ((uint32_t)(((uint32_t)(*((const uint8_t *)(&fap->fa_un.fa_nfsv3.nfsv3fa_rdev.specdata1) + 0)) << 24) | ((uint32_t)(*((const uint8_t *)(&fap->fa_un.fa_nfsv3.nfsv3fa_rdev.specdata1) + 1)) << 16) | ((uint32_t)(*((const uint8_t *)(&fap->fa_un.fa_nfsv3.nfsv3fa_rdev.specdata1) + 2)) << 8) | ((uint32_t)(*((const uint8_t *)(&fap->fa_un.fa_nfsv3.nfsv3fa_rdev.specdata1) + 3)) << 0))), ((uint32_t)(((uint32_t)(*((const uint8_t *)(&fap->fa_un.fa_nfsv3.nfsv3fa_rdev.specdata2) + 0)) << 24) | ((uint32_t)(*((const uint8_t *)(&fap->fa_un.fa_nfsv3.nfsv3fa_rdev.specdata2) + 1)) << 16) | ((uint32_t)(*((const uint8_t *)(&fap->fa_un.fa_nfsv3.nfsv3fa_rdev.specdata2) + 2)) << 8) | ((uint32_t)(*((const uint8_t *)(&fap->fa_un.fa_nfsv3.nfsv3fa_rdev.specdata2) + 3)) << 0))))&fap->fa_nlink&fap->fa3_rdev.specdata1&fap->fa_un.fa_nfsv3.nfsv3fa_rdev.specdata1&fap->fa3_rdev.specdata2&fap->fa_un.fa_nfsv3.nfsv3fa_rdev.specdata2(ndo, " fsid %" PRIx64, EXTRACT_64BITS((uint32_t *)&fap->fa3_fsid))(ndo, " fsid %" "ll" "x", ((uint64_t)(((uint64_t)(*((const uint8_t *)((uint32_t *)&fap->fa_un.fa_nfsv3.nfsv3fa_fsid) + 0)) << 56) | ((uint64_t)(*((const uint8_t *)((uint32_t *)&fap->fa_un.fa_nfsv3.nfsv3fa_fsid) + 1)) << 48) | ((uint64_t)(*((const uint8_t *)((uint32_t *)&fap->fa_un.fa_nfsv3.nfsv3fa_fsid) + 2)) << 40) | ((uint64_t)(*((const uint8_t *)((uint32_t *)&fap->fa_un.fa_nfsv3.nfsv3fa_fsid) + 3)) << 32) | ((uint64_t)(*((const uint8_t *)((uint32_t *)&fap->fa_un.fa_nfsv3.nfsv3fa_fsid) + 4)) << 24) | ((uint64_t)(*((const uint8_t *)((uint32_t *)&fap->fa_un.fa_nfsv3.nfsv3fa_fsid) + 5)) << 16) | ((uint64_t)(*((const uint8_t *)((uint32_t *)&fap->fa_un.fa_nfsv3.nfsv3fa_fsid) + 6)) << 8) | ((uint64_t)(*((const uint8_t *)((uint32_t *)&fap->fa_un.fa_nfsv3.nfsv3fa_fsid) + 7)) << 0))))(uint32_t *)&fap->fa3_fsid(uint32_t *)&fap->fa_un.fa_nfsv3.nfsv3fa_fsid(ndo, " fileid %" PRIx64, EXTRACT_64BITS((uint32_t *)&fap->fa3_fileid))(ndo, " fileid %" "ll" "x", ((uint64_t)(((uint64_t)(*((const uint8_t *)((uint32_t *)&fap->fa_un.fa_nfsv3.nfsv3fa_fileid) + 0)) << 56) | ((uint64_t)(*((const uint8_t *)((uint32_t *)&fap->fa_un.fa_nfsv3.nfsv3fa_fileid) + 1)) << 48) | ((uint64_t)(*((const uint8_t *)((uint32_t *)&fap->fa_un.fa_nfsv3.nfsv3fa_fileid) + 2)) << 40) | ((uint64_t)(*((const uint8_t *)((uint32_t *)&fap->fa_un.fa_nfsv3.nfsv3fa_fileid) + 3)) << 32) | ((uint64_t)(*((const uint8_t *)((uint32_t *)&fap->fa_un.fa_nfsv3.nfsv3fa_fileid) + 4)) << 24) | ((uint64_t)(*((const uint8_t *)((uint32_t *)&fap->fa_un.fa_nfsv3.nfsv3fa_fileid) + 5)) << 16) | ((uint64_t)(*((const uint8_t *)((uint32_t *)&fap->fa_un.fa_nfsv3.nfsv3fa_fileid) + 6)) << 8) | ((uint64_t)(*((const uint8_t *)((uint32_t *)&fap->fa_un.fa_nfsv3.nfsv3fa_fileid) + 7)) << 0))))(uint32_t *)&fap->fa3_fileid(uint32_t *)&fap->fa_un.fa_nfsv3.nfsv3fa_fileid(ndo, " a/m/ctime %u.%06u", EXTRACT_32BITS(&fap->fa3_atime.nfsv3_sec), EXTRACT_32BITS(&fap->fa3_atime.nfsv3_nsec))(ndo, " a/m/ctime %u.%06u", ((uint32_t)(((uint32_t)(*((const uint8_t *)(&fap->fa_un.fa_nfsv3.nfsv3fa_atime.nfsv3_sec) + 0)) << 24) | ((uint32_t)(*((const uint8_t *)(&fap->fa_un.fa_nfsv3.nfsv3fa_atime.nfsv3_sec) + 1)) << 16) | ((uint32_t)(*((const uint8_t *)(&fap->fa_un.fa_nfsv3.nfsv3fa_atime.nfsv3_sec) + 2)) << 8) | ((uint32_t)(*((const uint8_t *)(&fap->fa_un.fa_nfsv3.nfsv3fa_atime.nfsv3_sec) + 3)) << 0))), ((uint32_t)(((uint32_t)(*((const uint8_t *)(&fap->fa_un.fa_nfsv3.nfsv3fa_atime.nfsv3_nsec) + 0)) << 24) | ((uint32_t)(*((const uint8_t *)(&fap->fa_un.fa_nfsv3.nfsv3fa_atime.nfsv3_nsec) + 1)) << 16) | ((uint32_t)(*((const uint8_t *)(&fap->fa_un.fa_nfsv3.nfsv3fa_atime.nfsv3_nsec) + 2)) << 8) | ((uint32_t)(*((const uint8_t *)(&fap->fa_un.fa_nfsv3.nfsv3fa_atime.nfsv3_nsec) + 3)) << 0))))&fap->fa3_atime.nfsv3_sec&fap->fa_un.fa_nfsv3.nfsv3fa_atime.nfsv3_sec&fap->fa3_atime.nfsv3_nsec&fap->fa_un.fa_nfsv3.nfsv3fa_atime.nfsv3_nsec(ndo, " %u.%06u", EXTRACT_32BITS(&fap->fa3_mtime.nfsv3_sec), EXTRACT_32BITS(&fap->fa3_mtime.nfsv3_nsec))(ndo, " %u.%06u", ((uint32_t)(((uint32_t)(*((const uint8_t *)(&fap->fa_un.fa_nfsv3.nfsv3fa_mtime.nfsv3_sec) + 0)) << 24) | ((uint32_t)(*((const uint8_t *)(&fap->fa_un.fa_nfsv3.nfsv3fa_mtime.nfsv3_sec) + 1)) << 16) | ((uint32_t)(*((const uint8_t *)(&fap->fa_un.fa_nfsv3.nfsv3fa_mtime.nfsv3_sec) + 2)) << 8) | ((uint32_t)(*((const uint8_t *)(&fap->fa_un.fa_nfsv3.nfsv3fa_mtime.nfsv3_sec) + 3)) << 0))), ((uint32_t)(((uint32_t)(*((const uint8_t *)(&fap->fa_un.fa_nfsv3.nfsv3fa_mtime.nfsv3_nsec) + 0)) << 24) | ((uint32_t)(*((const uint8_t *)(&fap->fa_un.fa_nfsv3.nfsv3fa_mtime.nfsv3_nsec) + 1)) << 16) | ((uint32_t)(*((const uint8_t *)(&fap->fa_un.fa_nfsv3.nfsv3fa_mtime.nfsv3_nsec) + 2)) << 8) | ((uint32_t)(*((const uint8_t *)(&fap->fa_un.fa_nfsv3.nfsv3fa_mtime.nfsv3_nsec) + 3)) << 0))))&fap->fa3_mtime.nfsv3_sec&fap->fa_un.fa_nfsv3.nfsv3fa_mtime.nfsv3_sec&fap->fa3_mtime.nfsv3_nsec&fap->fa_un.fa_nfsv3.nfsv3fa_mtime.nfsv3_nsec(ndo, " %u.%06u", EXTRACT_32BITS(&fap->fa3_ctime.nfsv3_sec), EXTRACT_32BITS(&fap->fa3_ctime.nfsv3_nsec))(ndo, " %u.%06u", ((uint32_t)(((uint32_t)(*((const uint8_t *)(&fap->fa_un.fa_nfsv3.nfsv3fa_ctime.nfsv3_sec) + 0)) << 24) | ((uint32_t)(*((const uint8_t *)(&fap->fa_un.fa_nfsv3.nfsv3fa_ctime.nfsv3_sec) + 1)) << 16) | ((uint32_t)(*((const uint8_t *)(&fap->fa_un.fa_nfsv3.nfsv3fa_ctime.nfsv3_sec) + 2)) << 8) | ((uint32_t)(*((const uint8_t *)(&fap->fa_un.fa_nfsv3.nfsv3fa_ctime.nfsv3_sec) + 3)) << 0))), ((uint32_t)(((uint32_t)(*((const uint8_t *)(&fap->fa_un.fa_nfsv3.nfsv3fa_ctime.nfsv3_nsec) + 0)) << 24) | ((uint32_t)(*((const uint8_t *)(&fap->fa_un.fa_nfsv3.nfsv3fa_ctime.nfsv3_nsec) + 1)) << 16) | ((uint32_t)(*((const uint8_t *)(&fap->fa_un.fa_nfsv3.nfsv3fa_ctime.nfsv3_nsec) + 2)) << 8) | ((uint32_t)(*((const uint8_t *)(&fap->fa_un.fa_nfsv3.nfsv3fa_ctime.nfsv3_nsec) + 3)) << 0))))&fap->fa3_ctime.nfsv3_sec&fap->fa_un.fa_nfsv3.nfsv3fa_ctime.nfsv3_sec&fap->fa3_ctime.nfsv3_nsec&fap->fa_un.fa_nfsv3.nfsv3fa_ctime.nfsv3_nsecfap->fa2_ctimefap->fa_un.fa_nfsv2.nfsv2fa_ctimesizeof(fap->fa_un.fa_nfsv2.nfsv2fa_ctime)(ndo, " nlink %d rdev 0x%x fsid 0x%x nodeid 0x%x a/m/ctime", EXTRACT_32BITS(&fap->fa_nlink), EXTRACT_32BITS(&fap->fa2_rdev), EXTRACT_32BITS(&fap->fa2_fsid), EXTRACT_32BITS(&fap->fa2_fileid))(ndo, " nlink %d rdev 0x%x fsid 0x%x nodeid 0x%x a/m/ctime", ((uint32_t)(((uint32_t)(*((const uint8_t *)(&fap->fa_nlink) + 0)) << 24) | ((uint32_t)(*((const uint8_t *)(&fap->fa_nlink) + 1)) << 16) | ((uint32_t)(*((const uint8_t *)(&fap->fa_nlink) + 2)) << 8) | ((uint32_t)(*((const uint8_t *)(&fap->fa_nlink) + 3)) << 0))), ((uint32_t)(((uint32_t)(*((const uint8_t *)(&fap->fa_un.fa_nfsv2.nfsv2fa_rdev) + 0)) << 24) | ((uint32_t)(*((const uint8_t *)(&fap->fa_un.fa_nfsv2.nfsv2fa_rdev) + 1)) << 16) | ((uint32_t)(*((const uint8_t *)(&fap->fa_un.fa_nfsv2.nfsv2fa_rdev) + 2)) << 8) | ((uint32_t)(*((const uint8_t *)(&fap->fa_un.fa_nfsv2.nfsv2fa_rdev) + 3)) << 0))), ((uint32_t)(((uint32_t)(*((const uint8_t *)(&fap->fa_un.fa_nfsv2.nfsv2fa_fsid) + 0)) << 24) | ((uint32_t)(*((const uint8_t *)(&fap->fa_un.fa_nfsv2.nfsv2fa_fsid) + 1)) << 16) | ((uint32_t)(*((const uint8_t *)(&fap->fa_un.fa_nfsv2.nfsv2fa_fsid) + 2)) << 8) | ((uint32_t)(*((const uint8_t *)(&fap->fa_un.fa_nfsv2.nfsv2fa_fsid) + 3)) << 0))), ((uint32_t)(((uint32_t)(*((const uint8_t *)(&fap->fa_un.fa_nfsv2.nfsv2fa_fileid) + 0)) << 24) | ((uint32_t)(*((const uint8_t *)(&fap->fa_un.fa_nfsv2.nfsv2fa_fileid) + 1)) << 16) | ((uint32_t)(*((const uint8_t *)(&fap->fa_un.fa_nfsv2.nfsv2fa_fileid) + 2)) << 8) | ((uint32_t)(*((const uint8_t *)(&fap->fa_un.fa_nfsv2.nfsv2fa_fileid) + 3)) << 0))))&fap->fa2_rdev&fap->fa_un.fa_nfsv2.nfsv2fa_rdev&fap->fa2_fsid&fap->fa_un.fa_nfsv2.nfsv2fa_fsid&fap->fa2_fileid&fap->fa_un.fa_nfsv2.nfsv2fa_fileid(ndo, " %u.%06u", EXTRACT_32BITS(&fap->fa2_atime.nfsv2_sec), EXTRACT_32BITS(&fap->fa2_atime.nfsv2_usec))(ndo, " %u.%06u", ((uint32_t)(((uint32_t)(*((const uint8_t *)(&fap->fa_un.fa_nfsv2.nfsv2fa_atime.nfsv2_sec) + 0)) << 24) | ((uint32_t)(*((const uint8_t *)(&fap->fa_un.fa_nfsv2.nfsv2fa_atime.nfsv2_sec) + 1)) << 16) | ((uint32_t)(*((const uint8_t *)(&fap->fa_un.fa_nfsv2.nfsv2fa_atime.nfsv2_sec) + 2)) << 8) | ((uint32_t)(*((const uint8_t *)(&fap->fa_un.fa_nfsv2.nfsv2fa_atime.nfsv2_sec) + 3)) << 0))), ((uint32_t)(((uint32_t)(*((const uint8_t *)(&fap->fa_un.fa_nfsv2.nfsv2fa_atime.nfsv2_usec) + 0)) << 24) | ((uint32_t)(*((const uint8_t *)(&fap->fa_un.fa_nfsv2.nfsv2fa_atime.nfsv2_usec) + 1)) << 16) | ((uint32_t)(*((const uint8_t *)(&fap->fa_un.fa_nfsv2.nfsv2fa_atime.nfsv2_usec) + 2)) << 8) | ((uint32_t)(*((const uint8_t *)(&fap->fa_un.fa_nfsv2.nfsv2fa_atime.nfsv2_usec) + 3)) << 0))))&fap->fa2_atime.nfsv2_sec&fap->fa_un.fa_nfsv2.nfsv2fa_atime.nfsv2_sec&fap->fa2_atime.nfsv2_usec&fap->fa_un.fa_nfsv2.nfsv2fa_atime.nfsv2_usec(ndo, " %u.%06u", EXTRACT_32BITS(&fap->fa2_mtime.nfsv2_sec), EXTRACT_32BITS(&fap->fa2_mtime.nfsv2_usec))(ndo, " %u.%06u", ((uint32_t)(((uint32_t)(*((const uint8_t *)(&fap->fa_un.fa_nfsv2.nfsv2fa_mtime.nfsv2_sec) + 0)) << 24) | ((uint32_t)(*((const uint8_t *)(&fap->fa_un.fa_nfsv2.nfsv2fa_mtime.nfsv2_sec) + 1)) << 16) | ((uint32_t)(*((const uint8_t *)(&fap->fa_un.fa_nfsv2.nfsv2fa_mtime.nfsv2_sec) + 2)) << 8) | ((uint32_t)(*((const uint8_t *)(&fap->fa_un.fa_nfsv2.nfsv2fa_mtime.nfsv2_sec) + 3)) << 0))), ((uint32_t)(((uint32_t)(*((const uint8_t *)(&fap->fa_un.fa_nfsv2.nfsv2fa_mtime.nfsv2_usec) + 0)) << 24) | ((uint32_t)(*((const uint8_t *)(&fap->fa_un.fa_nfsv2.nfsv2fa_mtime.nfsv2_usec) + 1)) << 16) | ((uint32_t)(*((const uint8_t *)(&fap->fa_un.fa_nfsv2.nfsv2fa_mtime.nfsv2_usec) + 2)) << 8) | ((uint32_t)(*((const uint8_t *)(&fap->fa_un.fa_nfsv2.nfsv2fa_mtime.nfsv2_usec) + 3)) << 0))))&fap->fa2_mtime.nfsv2_sec&fap->fa_un.fa_nfsv2.nfsv2fa_mtime.nfsv2_sec&fap->fa2_mtime.nfsv2_usec&fap->fa_un.fa_nfsv2.nfsv2fa_mtime.nfsv2_usec(ndo, " %u.%06u", EXTRACT_32BITS(&fap->fa2_ctime.nfsv2_sec), EXTRACT_32BITS(&fap->fa2_ctime.nfsv2_usec))(ndo, " %u.%06u", ((uint32_t)(((uint32_t)(*((const uint8_t *)(&fap->fa_un.fa_nfsv2.nfsv2fa_ctime.nfsv2_sec) + 0)) << 24) | ((uint32_t)(*((const uint8_t *)(&fap->fa_un.fa_nfsv2.nfsv2fa_ctime.nfsv2_sec) + 1)) << 16) | ((uint32_t)(*((const uint8_t *)(&fap->fa_un.fa_nfsv2.nfsv2fa_ctime.nfsv2_sec) + 2)) << 8) | ((uint32_t)(*((const uint8_t *)(&fap->fa_un.fa_nfsv2.nfsv2fa_ctime.nfsv2_sec) + 3)) << 0))), ((uint32_t)(((uint32_t)(*((const uint8_t *)(&fap->fa_un.fa_nfsv2.nfsv2fa_ctime.nfsv2_usec) + 0)) << 24) | ((uint32_t)(*((const uint8_t *)(&fap->fa_un.fa_nfsv2.nfsv2fa_ctime.nfsv2_usec) + 1)) << 16) | ((uint32_t)(*((const uint8_t *)(&fap->fa_un.fa_nfsv2.nfsv2fa_ctime.nfsv2_usec) + 2)) << 8) | ((uint32_t)(*((const uint8_t *)(&fap->fa_un.fa_nfsv2.nfsv2fa_ctime.nfsv2_usec) + 3)) << 0))))&fap->fa2_ctime.nfsv2_sec&fap->fa_un.fa_nfsv2.nfsv2fa_ctime.nfsv2_sec&fap->fa2_ctime.nfsv2_usec&fap->fa_un.fa_nfsv2.nfsv2fa_ctime.nfsv2_usecconst nfstime3const nfstime3 *nfsv3_time * nlink %d rdev %d/%d fsid %llx fileid %llx a/m/ctime %u.%06u %u.%06uconst nfstime2const nfstime2 *nfsv2_time * nlink %d rdev 0x%x fsid 0x%x nodeid 0x%x a/m/ctimeparsestatuserrnum(ndo, " ERROR: %s", tok2str(status2str, "unk %d", errnum)) ERROR: %sconst tok[35]tok[35]unk %dparserepastatconst sunrpc_reply_bodyconst sunrpc_reply_body *sunrpc_reply_body *2*sizeof(uint32_t)2*sizeof(uint32_t) + 3(2*sizeof(uint32_t) + 3)(ndo, " %s", tok2str(sunrpc_str, "ar_stat %d", astat))ar_stat %dsizeof(astat)xid_map_findxid_map_entry *xmep&xmep->serversizeof(ip->ip_src)&xmep->clientsizeof(ip->ip_dst)xid_map_entry[64]XIDMAPSIZEnextitemxid_map_enterrp->rm_call.cb_versrp->ru.RM_cmb.cb_verssizeof(rp->ru.RM_cmb.cb_vers)(struct ip *)bp&xmep->xid&rp->rm_xidsizeof(xmep->xid)&rp->rm_call.cb_proc&rp->ru.RM_cmb.cb_proc&rp->rm_call.cb_vers&rp->ru.RM_cmb.cb_versnfs_printfhfsidinosfsnamespacep(ndo, " fh[")(ndo, "%s%x", sep, dp[i]) fh[%s%x":"sfsname, NFSX_V3FHMAXsfsname, 64(ndo, " fh %s/", temp)(ndo, " fh %d,%d/", fsid.Fsid_dev.Major, fsid.Fsid_dev.Minor)sizeof(temp)sizeof(temp) - 1 fh %s/ fh %d,%d/(ndo, "%s", fsid.Opaque_Handle)(ndo, "%ld", (long) ino)%ldnfsreq_print_noaddraccess_flagssa3(ndo, "%d", length)(ndo, " %04x", access_flags)(ndo, " NFS_ACCESS_FULL")(ndo, " NFS_ACCESS_READ")(ndo, "%cNFS_ACCESS_LOOKUP", separator)(ndo, "%cNFS_ACCESS_MODIFY", separator)(ndo, "%cNFS_ACCESS_EXTEND", separator)(ndo, "%cNFS_ACCESS_DELETE", separator)(ndo, "%cNFS_ACCESS_EXECUTE", separator)(ndo, " %u bytes @ %" PRIu64, EXTRACT_32BITS(&dp[2]), EXTRACT_64BITS(&dp[0]))(ndo, " %u bytes @ %" "ll" "u", ((uint32_t)(((uint32_t)(*((const uint8_t *)(&dp[2]) + 0)) << 24) | ((uint32_t)(*((const uint8_t *)(&dp[2]) + 1)) << 16) | ((uint32_t)(*((const uint8_t *)(&dp[2]) + 2)) << 8) | ((uint32_t)(*((const uint8_t *)(&dp[2]) + 3)) << 0))), ((uint64_t)(((uint64_t)(*((const uint8_t *)(&dp[0]) + 0)) << 56) | ((uint64_t)(*((const uint8_t *)(&dp[0]) + 1)) << 48) | ((uint64_t)(*((const uint8_t *)(&dp[0]) + 2)) << 40) | ((uint64_t)(*((const uint8_t *)(&dp[0]) + 3)) << 32) | ((uint64_t)(*((const uint8_t *)(&dp[0]) + 4)) << 24) | ((uint64_t)(*((const uint8_t *)(&dp[0]) + 5)) << 16) | ((uint64_t)(*((const uint8_t *)(&dp[0]) + 6)) << 8) | ((uint64_t)(*((const uint8_t *)(&dp[0]) + 7)) << 0))))(ndo, " %u bytes @ %u", EXTRACT_32BITS(&dp[1]), EXTRACT_32BITS(&dp[0]))(ndo, " %u bytes @ %u", ((uint32_t)(((uint32_t)(*((const uint8_t *)(&dp[1]) + 0)) << 24) | ((uint32_t)(*((const uint8_t *)(&dp[1]) + 1)) << 16) | ((uint32_t)(*((const uint8_t *)(&dp[1]) + 2)) << 8) | ((uint32_t)(*((const uint8_t *)(&dp[1]) + 3)) << 0))), ((uint32_t)(((uint32_t)(*((const uint8_t *)(&dp[0]) + 0)) << 24) | ((uint32_t)(*((const uint8_t *)(&dp[0]) + 1)) << 16) | ((uint32_t)(*((const uint8_t *)(&dp[0]) + 2)) << 8) | ((uint32_t)(*((const uint8_t *)(&dp[0]) + 3)) << 0))))(ndo, " %u (%u) bytes @ %" PRIu64, EXTRACT_32BITS(&dp[4]), EXTRACT_32BITS(&dp[2]), EXTRACT_64BITS(&dp[0]))(ndo, " %u (%u) bytes @ %" "ll" "u", ((uint32_t)(((uint32_t)(*((const uint8_t *)(&dp[4]) + 0)) << 24) | ((uint32_t)(*((const uint8_t *)(&dp[4]) + 1)) << 16) | ((uint32_t)(*((const uint8_t *)(&dp[4]) + 2)) << 8) | ((uint32_t)(*((const uint8_t *)(&dp[4]) + 3)) << 0))), ((uint32_t)(((uint32_t)(*((const uint8_t *)(&dp[2]) + 0)) << 24) | ((uint32_t)(*((const uint8_t *)(&dp[2]) + 1)) << 16) | ((uint32_t)(*((const uint8_t *)(&dp[2]) + 2)) << 8) | ((uint32_t)(*((const uint8_t *)(&dp[2]) + 3)) << 0))), ((uint64_t)(((uint64_t)(*((const uint8_t *)(&dp[0]) + 0)) << 56) | ((uint64_t)(*((const uint8_t *)(&dp[0]) + 1)) << 48) | ((uint64_t)(*((const uint8_t *)(&dp[0]) + 2)) << 40) | ((uint64_t)(*((const uint8_t *)(&dp[0]) + 3)) << 32) | ((uint64_t)(*((const uint8_t *)(&dp[0]) + 4)) << 24) | ((uint64_t)(*((const uint8_t *)(&dp[0]) + 5)) << 16) | ((uint64_t)(*((const uint8_t *)(&dp[0]) + 6)) << 8) | ((uint64_t)(*((const uint8_t *)(&dp[0]) + 7)) << 0))))(ndo, " <%s>", tok2str(nfsv3_writemodes, NULL, EXTRACT_32BITS(dp)))(ndo, " <%s>", tok2str(nfsv3_writemodes, ((void *)0), ((uint32_t)(((uint32_t)(*((const uint8_t *)(dp) + 0)) << 24) | ((uint32_t)(*((const uint8_t *)(dp) + 1)) << 16) | ((uint32_t)(*((const uint8_t *)(dp) + 2)) << 8) | ((uint32_t)(*((const uint8_t *)(dp) + 3)) << 0)))))dp[3]sizeof(dp[3])(ndo, " %u (%u) bytes @ %u (%u)", EXTRACT_32BITS(&dp[3]), EXTRACT_32BITS(&dp[2]), EXTRACT_32BITS(&dp[1]), EXTRACT_32BITS(&dp[0]))(ndo, " %u (%u) bytes @ %u (%u)", ((uint32_t)(((uint32_t)(*((const uint8_t *)(&dp[3]) + 0)) << 24) | ((uint32_t)(*((const uint8_t *)(&dp[3]) + 1)) << 16) | ((uint32_t)(*((const uint8_t *)(&dp[3]) + 2)) << 8) | ((uint32_t)(*((const uint8_t *)(&dp[3]) + 3)) << 0))), ((uint32_t)(((uint32_t)(*((const uint8_t *)(&dp[2]) + 0)) << 24) | ((uint32_t)(*((const uint8_t *)(&dp[2]) + 1)) << 16) | ((uint32_t)(*((const uint8_t *)(&dp[2]) + 2)) << 8) | ((uint32_t)(*((const uint8_t *)(&dp[2]) + 3)) << 0))), ((uint32_t)(((uint32_t)(*((const uint8_t *)(&dp[1]) + 0)) << 24) | ((uint32_t)(*((const uint8_t *)(&dp[1]) + 1)) << 16) | ((uint32_t)(*((const uint8_t *)(&dp[1]) + 2)) << 8) | ((uint32_t)(*((const uint8_t *)(&dp[1]) + 3)) << 0))), ((uint32_t)(((uint32_t)(*((const uint8_t *)(&dp[0]) + 0)) << 24) | ((uint32_t)(*((const uint8_t *)(&dp[0]) + 1)) << 16) | ((uint32_t)(*((const uint8_t *)(&dp[0]) + 2)) << 8) | ((uint32_t)(*((const uint8_t *)(&dp[0]) + 3)) << 0))))(ndo, " ->")sizeof(*dp)(ndo, " %s", tok2str(type2str, "unk-ft %d", type))(ndo, " %u/%u", EXTRACT_32BITS(&dp[0]), EXTRACT_32BITS(&dp[1]))(ndo, " %u/%u", ((uint32_t)(((uint32_t)(*((const uint8_t *)(&dp[0]) + 0)) << 24) | ((uint32_t)(*((const uint8_t *)(&dp[0]) + 1)) << 16) | ((uint32_t)(*((const uint8_t *)(&dp[0]) + 2)) << 8) | ((uint32_t)(*((const uint8_t *)(&dp[0]) + 3)) << 0))), ((uint32_t)(((uint32_t)(*((const uint8_t *)(&dp[1]) + 0)) << 24) | ((uint32_t)(*((const uint8_t *)(&dp[1]) + 1)) << 16) | ((uint32_t)(*((const uint8_t *)(&dp[1]) + 2)) << 8) | ((uint32_t)(*((const uint8_t *)(&dp[1]) + 3)) << 0))))dp[4]sizeof(dp[4])(ndo, " %u bytes @ %" PRId64, EXTRACT_32BITS(&dp[4]), EXTRACT_64BITS(&dp[0]))(ndo, " %u bytes @ %" "ll" "d", ((uint32_t)(((uint32_t)(*((const uint8_t *)(&dp[4]) + 0)) << 24) | ((uint32_t)(*((const uint8_t *)(&dp[4]) + 1)) << 16) | ((uint32_t)(*((const uint8_t *)(&dp[4]) + 2)) << 8) | ((uint32_t)(*((const uint8_t *)(&dp[4]) + 3)) << 0))), ((uint64_t)(((uint64_t)(*((const uint8_t *)(&dp[0]) + 0)) << 56) | ((uint64_t)(*((const uint8_t *)(&dp[0]) + 1)) << 48) | ((uint64_t)(*((const uint8_t *)(&dp[0]) + 2)) << 40) | ((uint64_t)(*((const uint8_t *)(&dp[0]) + 3)) << 32) | ((uint64_t)(*((const uint8_t *)(&dp[0]) + 4)) << 24) | ((uint64_t)(*((const uint8_t *)(&dp[0]) + 5)) << 16) | ((uint64_t)(*((const uint8_t *)(&dp[0]) + 6)) << 8) | ((uint64_t)(*((const uint8_t *)(&dp[0]) + 7)) << 0))))(ndo, " verf %08x%08x", dp[2], dp[3])(ndo, " %u bytes @ %d", EXTRACT_32BITS(&dp[1]), EXTRACT_32BITS(&dp[0]))(ndo, " %u bytes @ %d", ((uint32_t)(((uint32_t)(*((const uint8_t *)(&dp[1]) + 0)) << 24) | ((uint32_t)(*((const uint8_t *)(&dp[1]) + 1)) << 16) | ((uint32_t)(*((const uint8_t *)(&dp[1]) + 2)) << 8) | ((uint32_t)(*((const uint8_t *)(&dp[1]) + 3)) << 0))), ((uint32_t)(((uint32_t)(*((const uint8_t *)(&dp[0]) + 0)) << 24) | ((uint32_t)(*((const uint8_t *)(&dp[0]) + 1)) << 16) | ((uint32_t)(*((const uint8_t *)(&dp[0]) + 2)) << 8) | ((uint32_t)(*((const uint8_t *)(&dp[0]) + 3)) << 0))))dp[5]sizeof(dp[5])(ndo, " max %u verf %08x%08x", EXTRACT_32BITS(&dp[5]), dp[2], dp[3])(ndo, " max %u verf %08x%08x", ((uint32_t)(((uint32_t)(*((const uint8_t *)(&dp[5]) + 0)) << 24) | ((uint32_t)(*((const uint8_t *)(&dp[5]) + 1)) << 16) | ((uint32_t)(*((const uint8_t *)(&dp[5]) + 2)) << 8) | ((uint32_t)(*((const uint8_t *)(&dp[5]) + 3)) << 0))), dp[2], dp[3])4294967232~NFSV3ACCESS_FULL %04x NFS_ACCESS_FULLseparator NFS_ACCESS_READ'|'%cNFS_ACCESS_LOOKUP%cNFS_ACCESS_MODIFY%cNFS_ACCESS_EXTEND%cNFS_ACCESS_DELETE%cNFS_ACCESS_EXECUTE %u bytes @ %llu %u bytes @ %u %u (%u) bytes @ %llu %u (%u) bytes @ %u (%u) ->nfsv3_sattr *const nfsv3_sattrconst nfsv3_sattr *unk-ft %d %u bytes @ %lld %u bytes @ %d max %u verf %08x%08xparsefhnparsefn(__uint32_t)len((len + 3) & ~3)~3parsefhlen * sizeof(*dp)parsereqconst sunrpc_opaque_authconst sunrpc_opaque_auth *sunrpc_opaque_auth *2 * sizeof(*dp)2 * sizeof(*dp) + 3(2 * sizeof(*dp) + 3)nfsreply_print_noaddrreply_statrstatrlowrhighrwhyrp->rm_reply.rp_statrp->ru.RM_rmb.rp_statsizeof(rp->ru.RM_rmb.rp_stat)&rp->rm_reply.rp_stat&rp->ru.RM_rmb.rp_stat(ndo, "reply ok %u", length)(ndo, "reply ERR %u: ", length)rp->rm_reply.rp_reject.rj_statrp->ru.RM_rmb.rp_reject.rj_statsizeof(rp->ru.RM_rmb.rp_reject.rj_stat)&rp->rm_reply.rp_reject.rj_stat&rp->ru.RM_rmb.rp_reject.rj_statrp->rm_reply.rp_reject.rj_vers.highrp->ru.RM_rmb.rp_reject.ru.RJ_versions.highsizeof(rp->ru.RM_rmb.rp_reject.ru.RJ_versions.high)&rp->rm_reply.rp_reject.rj_vers.low&rp->ru.RM_rmb.rp_reject.ru.RJ_versions.low&rp->rm_reply.rp_reject.rj_vers.high&rp->ru.RM_rmb.rp_reject.ru.RJ_versions.high(ndo, "RPC Version mismatch (%u-%u)", rlow, rhigh)rp->rm_reply.rp_reject.rj_whyrp->ru.RM_rmb.rp_reject.ru.RJ_whysizeof(rp->ru.RM_rmb.rp_reject.ru.RJ_why)&rp->rm_reply.rp_reject.rj_why&rp->ru.RM_rmb.rp_reject.ru.RJ_why(ndo, "Auth %s", tok2str(sunrpc_auth_str, "Invalid failure code %u", rwhy))(ndo, "Unknown reason for rejecting rpc message %u", (unsigned int)rstat)(ndo, "reply Unknown rpc response code=%u %u", reply_stat, length)reply ok %ureply ERR %u: RPC Version mismatch (%u-%u)Auth %sInvalid failure code %uUnknown reason for rejecting rpc message %ureply Unknown rpc response code=%u %unfsreply_printsrciddstidrp->rm_xidsizeof(rp->rm_xid)"nfs", sizeof(srcid)sizeof(dstid)"%u", EXTRACT_32BITS(&rp->rm_xid)"%u", ((uint32_t)(((uint32_t)(*((const uint8_t *)(&rp->rm_xid) + 0)) << 24) | ((uint32_t)(*((const uint8_t *)(&rp->rm_xid) + 1)) << 16) | ((uint32_t)(*((const uint8_t *)(&rp->rm_xid) + 2)) << 8) | ((uint32_t)(*((const uint8_t *)(&rp->rm_xid) + 3)) << 0)))sizeof(srcid)"%u", NFS_PORT"%u", 2049__builtin___strlcpy_chknfsprint_sattr3(ndo, " mode %o", sa3->sa_mode) mode %o(ndo, " uid %u", sa3->sa_uid) uid %u(ndo, " gid %u", sa3->sa_gid) gid %u(ndo, " atime %u.%06u", sa3->sa_atime.nfsv3_sec, sa3->sa_atime.nfsv3_nsec)(ndo, " mtime %u.%06u", sa3->sa_mtime.nfsv3_sec, sa3->sa_mtime.nfsv3_nsec) atime %u.%06u mtime %u.%06uparse_sattr3print_nfsaddrINET_ADDRSTRLENsrcaddrdstaddripaddr_string(ndo, &ip->ip_src), sizeof(srcaddr)getname(ndo, (const u_char *)(&ip->ip_src)), sizeof(srcaddr)ipaddr_string(ndo, &ip->ip_dst), sizeof(dstaddr)getname(ndo, (const u_char *)(&ip->ip_dst)), sizeof(dstaddr)"?", sizeof(srcaddr)"?", sizeof(dstaddr)(ndo, "%s.%s > %s.%s: ", srcaddr, s, dstaddr, d)%s.%s > %s.%s: xid_map_entryserverclientxid_map_hintxid_map_nextxid_mapnfserrPROG_UNAVAIL"PROG_UNAVAIL"PROG_MISMATCH"PROG_MISMATCH"PROC_UNAVAIL"PROC_UNAVAIL"GARBAGE_ARGS"GARBAGE_ARGS"SYSTEM_ERR"SYSTEM_ERR"sunrpc_strBogus Credentials (seal broken)"Bogus Credentials (seal broken)"Rejected Credentials (client should begin new session)"Rejected Credentials (client should begin new session)"Bogus Verifier (seal broken)"Bogus Verifier (seal broken)"Verifier expired or was replayed"Verifier expired or was replayed"Credentials are too weak"Credentials are too weak"Bogus response verifier"Bogus response verifier"Unknown failure"Unknown failure"sunrpc_auth_strNON"NON"REG"REG"DIR"DIR"BLK"BLK"CHR"CHR"LNK"LNK"FIFO"FIFO"unstable"unstable"datasync"datasync"filesync"filesync"nfsv3_writemodesOperation not permitted"Operation not permitted"No such file or directory"No such file or directory"Input/output error"Input/output error"Device not configured"Device not configured"Resource deadlock avoided"Resource deadlock avoided"Cannot allocate memory"Cannot allocate memory"Permission denied"Permission denied"File exists"File exists"Cross-device link"Cross-device link"Operation not supported by device"Operation not supported by device"Not a directory"Not a directory"Is a directory"Is a directory"Invalid argument"Invalid argument"Text file busy"Text file busy"File too large"File too large"No space left on device"No space left on device"Read-only file system"Read-only file system"Too many links"Too many links"Operation not supported"Operation not supported"Too many levels of symbolic links"Too many levels of symbolic links"File name too long"File name too long"Directory not empty"Directory not empty"Disc quota exceeded"Disc quota exceeded"Stale NFS file handle"Stale NFS file handle"Too many levels of remote in path"Too many levels of remote in path"Write cache flushed to disk"Write cache flushed to disk"Illegal NFS file handle"Illegal NFS file handle"Update synchronization mismatch"Update synchronization mismatch"READDIR/READDIRPLUS cookie is stale"READDIR/READDIRPLUS cookie is stale"Buffer or request is too small"Buffer or request is too small"Unspecified error on server"Unspecified error on server"Object of that type not supported"Object of that type not supported"Request couldn't be completed in time"Request couldn't be completed in time"status2strgetattr"getattr"setattr"setattr"lookup"lookup"access"access"readlink"readlink"read"read"write"write"create"create"mkdir"mkdir"symlink"symlink"mknod"mknod"remove"remove"rmdir"rmdir"rename"rename"link"link"readdir"readdir"readdirplus"readdirplus"fsstat"fsstat"fsinfo"fsinfo"pathconf"pathconf"commit"commit"nfsproc_strnfsv3_procid [|nfs]" [|nfs]"/*
 * Post operation attributes are printed if vflag >= 1
 *//* If not verbose enough, just skip over wcc_attr *//*
 * Pre operation attributes. Print only if vflag > 1.
 *//* print lots more stuff *//* successful return *//* suppress trunc string *//*
	 * now we can check the ar_stat field
	 *//*
	 * skip past the ar_verf credentials.
	 *//*
	 * Portability note:
	 * Here we find the address of the ar_verf credentials.
	 * Originally, this calculation was
	 *	dp = (uint32_t *)&rp->rm_reply.rp_acpt.ar_verf
	 * On the wire, the rp_acpt field starts immediately after
	 * the (32 bit) rp_stat field.  However, rp_acpt (which is a
	 * "struct accepted_reply") contains a "struct opaque_auth",
	 * whose internal representation contains a pointer, so on a
	 * 64-bit machine the compiler inserts 32 bits of padding
	 * before rp->rm_reply.rp_acpt.ar_verf.  So, we cannot use
	 * the internal representation to parse the on-the-wire
	 * representation.  Instead, we skip past the rp_stat field,
	 * which is an "enum" and so occupies one 32-bit word.
	 *//*
 * Return a pointer to the beginning of the actual results.
 * If the packet was truncated, return 0.
 *//*
 * Routines for parsing reply packets
 *//* search failed *//* match *//* Start searching from where we last left off *//*
 * Returns 0 and puts NFSPROC_xxx in proc return and
 * version in vers return, or returns -1 on failure
 *//*
 * Map entries are kept in an array that we manage as a ring;
 * new entries are always added at the tail of the ring.  Initially,
 * all the entries are zero and hence don't match anything.
 *//* program version (host order) *//* call proc number (host order) *//* server IP address (net order) *//* client IP address (net order) *//* IP version (4 or 6) *//* transaction ID (net order) *//*
 * Maintain a small cache of recent client.XID.server/proc pairs, to allow
 * us to match up replies with requests and thus to know how to parse
 * the reply.
 *//* Print the undecoded handle *//* Remove trailing spaces *//* Make sure string is null-terminated *//* file system ID is ASCII, not numeric, for this server OS *//*
 * Print out an NFS file handle.
 * We assume packet was not truncated before the end of the
 * file handle pointed to by dp.
 *
 * Note: new version (using portable file-handle parser) doesn't produce
 * generation number.  It probably could be made to do that, with some
 * additional hacking on the parser code.
 *//*
			 * We don't try to interpret the offset
			 * cookie here.
			 *//*
				 * Print the offset as signed, since -1 is
				 * common, but offsets > 2^31 aren't.
				 *//*
				 * We shouldn't really try to interpret the
				 * offset cookie here.
				 *//* NFSV3ACCESS definitions aren't up to date *//* record proc number for later on *//* assume no error *//*
 * Print out file handle and file name.
 * Return pointer to 32-bit word past file name.
 * If packet was truncated (or there was some other error), return 0.
 *//* Update 32-bit pointer (NFS filenames padded to 32-bit boundaries) *//* Fetch string length; convert to host order *//* Bail if we don't have the string length *//*
 * Print out a file name and return pointer to 32-bit word past it.
 * If packet was truncated, return 0.
 *//*
 * Print out an NFS file handle and return a pointer to following word.
 * If packet was truncated, return 0.
 *//*
	 * find the start of the req data (if we captured it)
	 *//*
 * Return a pointer to the first file handle in the packet.
 * If the packet was truncated, return 0.
 *//*fits 32bit*//* true if we error rather than trunc *//* NFS3ERR_JUKEBOX *//* NFS3ERR_BADTYPE *//* NFS3ERR_SERVERFAULT *//* NFS3ERR_TOOSMALL *//* NFS3ERR_NOTSUPP *//* NFS3ERR_BAD_COOKIE *//* NFS3ERR_NOT_SYNC *//* NFS3ERR_BADHANDLE *//* NFSERR_WFLUSH (not used) *//* EREMOTE *//* ESTALE *//* EDQUOT *//* ENOTEMPTY *//* ENAMETOOLONG *//* ELOOP *//* EOPNOTSUPP *//* EMLINK *//* EROFS *//* ENOSPC *//* EFBIG *//* ETXTBSY *//* EINVAL *//* EISDIR *//* ENOTDIR *//* ENODEV *//* EXDEV *//* EEXIST *//* EACCES *//* ENOMEM *//* EDEADLK *//* ENXIO *//* EIO *//* ENOENT *//* EPERM *//*
 * NFS V2 and V3 status values.
 *
 * Some of these come from the RFCs for NFS V2 and V3, with the message
 * strings taken from the FreeBSD C library "errlst.c".
 *
 * Others are errors that are not in the RFC but that I suspect some
 * NFS servers could return; the values are FreeBSD errno values, as
 * the first NFS server was the SunOS 2.0 one, and until 5.0 SunOS
 * was primarily BSD-derived.
 *//*
 * Mapping of old NFS Version 2 RPC numbers to generic numbers.
 *//Users/owura/Repos/codeql_eval/proj_repos/the-tcpdump-group-tcpdump-commit-0f95d441e4b5d7512cc5c326c8668a120e048eda/tcpdump/print-ntp.c<time.h>p_ntp_deltaconst l_fixedptconst l_fixedpt *l_fixedpt *ufououfffsignbit&lfp->int_part&olfp->int_part&lfp->fraction&olfp->fraction4294967296.0FMAXINT1000000000.0(ndo, "%s%d.%09d", signbit ? "-" : "+", i, f)%s%d.%09dp_ntp_time(ndo, "%u.%09d", i, f)%u.%09d(ndo, " (%s)", time_buf)seconds2208988800JAN_1970time_bufsizeof (time_buf)%Y/%m/%d %H:%M:%S"%Y/%m/%d %H:%M:%S"p_sfixconst s_fixedptconst s_fixedpt *s_fixedpt *&sfp->int_part&sfp->fractionolfplfp65536.0(ndo, "%d.%06d", i, f)%d.%06dntp_printconst ntpdataconst ntpdata *ntpdata *modeleapindbp->statussizeof(bp->status)VERSIONMASK(ndo, "NTPv%d", version)NTPv%dMODEMASK(ndo, ", %s, length %u", tok2str(ntp_mode_values, "Unknown mode", mode), length), %s, length %uUnknown mode(ndo, ", length %u\n\t%s", length, tok2str(ntp_mode_values, "Unknown mode", mode)), length %u
	%sLEAPMASK(ndo, ", Leap indicator: %s (%u)", tok2str(ntp_leapind_values, "Unknown", leapind), leapind), Leap indicator: %s (%u)bp->stratumsizeof(bp->stratum)(ndo, ", Stratum %u (%s)", bp->stratum, tok2str(ntp_stratum_values, (bp->stratum >=2 && bp->stratum<=15) ? "secondary reference" : "reserved", bp->stratum)), Stratum %u (%s)secondary referencebp->ppollsizeof(bp->ppoll)(ndo, ", poll %u (%us)", bp->ppoll, 1 << bp->ppoll), poll %u (%us)bp->root_delay(ndo, ", precision %d", bp->precision), precision %dsizeof(bp->root_delay)(ndo, "\n\tRoot Delay: ")
	Root Delay: bp->root_dispersionsizeof(bp->root_dispersion)(ndo, ", Root dispersion: "), Root dispersion: bp->refidsizeof(bp->refid)(ndo, ", Reference-ID: "), Reference-ID: (ndo, "(unspec)")(ndo, "%s INFO_QUERY", ipaddr_string(ndo, &(bp->refid)))(ndo, "%s INFO_QUERY", getname(ndo, (const u_char *)(&(bp->refid))))&(bp->refid)(ndo, "%s INFO_REPLY", ipaddr_string(ndo, &(bp->refid)))(ndo, "%s INFO_REPLY", getname(ndo, (const u_char *)(&(bp->refid))))(ndo, "%s", ipaddr_string(ndo, &(bp->refid)))(ndo, "%s", getname(ndo, (const u_char *)(&(bp->refid))))UNSPECIFIED(unspec)PRIM_REFINFO_QUERY%s INFO_QUERYINFO_REPLY%s INFO_REPLYbp->ref_timestampsizeof(bp->ref_timestamp)(ndo, "\n\t  Reference Timestamp:  ")
	  Reference Timestamp:  bp->org_timestampsizeof(bp->org_timestamp)(ndo, "\n\t  Originator Timestamp: ")
	  Originator Timestamp: bp->rec_timestampsizeof(bp->rec_timestamp)(ndo, "\n\t  Receive Timestamp:    ")
	  Receive Timestamp:    bp->xmt_timestampsizeof(bp->xmt_timestamp)(ndo, "\n\t  Transmit Timestamp:   ")
	  Transmit Timestamp:   (ndo, "\n\t    Originator - Receive Timestamp:  ")
	    Originator - Receive Timestamp:  (ndo, "\n\t    Originator - Transmit Timestamp: ")
	    Originator - Transmit Timestamp: bp->key_idsizeof(bp->key_id)(ndo, "\n\tKey id: %u", bp->key_id)bp->message_digestsizeof (bp->message_digest)(ndo, "\n\tAuthentication: %08x%08x%08x%08x", EXTRACT_32BITS(bp->message_digest), EXTRACT_32BITS(bp->message_digest + 4), EXTRACT_32BITS(bp->message_digest + 8), EXTRACT_32BITS(bp->message_digest + 12))(ndo, "\n\tAuthentication: %08x%08x%08x%08x", ((uint32_t)(((uint32_t)(*((const uint8_t *)(bp->message_digest) + 0)) << 24) | ((uint32_t)(*((const uint8_t *)(bp->message_digest) + 1)) << 16) | ((uint32_t)(*((const uint8_t *)(bp->message_digest) + 2)) << 8) | ((uint32_t)(*((const uint8_t *)(bp->message_digest) + 3)) << 0))), ((uint32_t)(((uint32_t)(*((const uint8_t *)(bp->message_digest + 4) + 0)) << 24) | ((uint32_t)(*((const uint8_t *)(bp->message_digest + 4) + 1)) << 16) | ((uint32_t)(*((const uint8_t *)(bp->message_digest + 4) + 2)) << 8) | ((uint32_t)(*((const uint8_t *)(bp->message_digest + 4) + 3)) << 0))), ((uint32_t)(((uint32_t)(*((const uint8_t *)(bp->message_digest + 8) + 0)) << 24) | ((uint32_t)(*((const uint8_t *)(bp->message_digest + 8) + 1)) << 16) | ((uint32_t)(*((const uint8_t *)(bp->message_digest + 8) + 2)) << 8) | ((uint32_t)(*((const uint8_t *)(bp->message_digest + 8) + 3)) << 0))), ((uint32_t)(((uint32_t)(*((const uint8_t *)(bp->message_digest + 12) + 0)) << 24) | ((uint32_t)(*((const uint8_t *)(bp->message_digest + 12) + 1)) << 16) | ((uint32_t)(*((const uint8_t *)(bp->message_digest + 12) + 2)) << 8) | ((uint32_t)(*((const uint8_t *)(bp->message_digest + 12) + 3)) << 0))))bp->message_digest + 4bp->message_digest + 8bp->message_digest + 12sizeof(struct ntpdata)
	Key id: %uconst uint8_t(*)[16]
	Authentication: %08x%08x%08x%08x(ndo, " [|ntp]") [|ntp]ntpdatas_fixedptl_fixedptmessage_digestxmt_timestamprec_timestamporg_timestampref_timestamprefidroot_dispersionroot_delayprecisionppollstratumfractionint_partprimary reference"primary reference"ntp_stratum_valuesNO_WARNINGPLUS_SEC+1s"+1s"MINUS_SEC-1s"-1s"ALARMclock unsynchronized"clock unsynchronized"ntp_leapind_valuesMODE_UNSPECMODE_SYM_ACTsymmetric active"symmetric active"MODE_SYM_PASsymmetric passive"symmetric passive"MODE_CLIENTClient"Client"MODE_SERVERServer"Server"MODE_BROADCASTMODE_RES1MODE_RES2ntp_mode_values(4294967296.0)0x38NTPVERSION_12208988800UHAVE_STRFTIME/* treat fraction as parts per billion *//* shift radix point by 32 bits *//* some compilers are buggy *//* int_part is zero *//* must carry into the high-order bits *//* new is definitely less than old *//* must borrow from high-order bits *//* new is definitely greater than old *//* Prints time difference between *lfp and *olfp *//*
	 * print the time in human-readable format.
	 *//* floating point rep. of MAXINT *//* Treat fraction as parts per million *//* shift radix point by 16 bits *//* Optional: key-id + authentication *//* Optional: key-id *//* this is too complex to be worth printing *//* this doesn't have more content *//* Interpretation depends on stratum *//* Can't ND_TCHECK bp->precision bitfield so bp->distance + 0 instead *//*
 * Print ntp requests
 *//* **** THIS implementation dependent **** *//* radio clock *//*
 *	Stratum Definitions
 *//* broadcast *//* server *//* client *//* symmetric passive *//* symmetric active *//* unspecified *//*
 *	Code values
 *//* Solaris sucks *//*
 *	Clock Status Bits that Encode Version
 *//* alarm condition (clock unsynchronized) *//* minus a second (59 seconds) *//* add a second (61 seconds) *//* no warning *//*
 *	Leap Second Codes (high order two bits)
 *//* poll value *//* Stratum level *//* status of local clock and leap info *//* rfc2030
 *                      1                   2                   3
 *  0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
 * +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
 * |LI | VN  |Mode |    Stratum    |     Poll      |   Precision   |
 * +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
 * |                          Root Delay                           |
 * +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
 * |                       Root Dispersion                         |
 * +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
 * |                     Reference Identifier                      |
 * +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
 * |                                                               |
 * |                   Reference Timestamp (64)                    |
 * |                                                               |
 * +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
 * |                                                               |
 * |                   Originate Timestamp (64)                    |
 * |                                                               |
 * +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
 * |                                                               |
 * |                    Receive Timestamp (64)                     |
 * |                                                               |
 * +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
 * |                                                               |
 * |                    Transmit Timestamp (64)                    |
 * |                                                               |
 * +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
 * |                 Key Identifier (optional) (32)                |
 * +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
 * |                                                               |
 * |                                                               |
 * |                 Message Digest (optional) (128)               |
 * |                                                               |
 * |                                                               |
 * +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
 *//*
 * Structure definitions for NTP fixed point values
 *
 *    0			  1		      2			  3
 *    0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
 *   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
 *   |			       Integer Part			     |
 *   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
 *   |			       Fraction Part			     |
 *   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
 *
 *    0			  1		      2			  3
 *    0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
 *   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
 *   |		  Integer Part	     |	   Fraction Part	     |
 *   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
*//* 1970 - 1900 in seconds *//*
 *  Definitions for the masses
 *//*
 * Based on ntp.h from the U of MD implementation
 *	This file is based on Version 2 of the NTP spec (RFC1119).
 *//*
 * Copyright (c) 1990, 1991, 1992, 1993, 1994, 1995, 1996, 1997
 *	The Regents of the University of California.  All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that: (1) source code distributions
 * retain the above copyright notice and this paragraph in its entirety, (2)
 * distributions including binary code include the above copyright notice and
 * this paragraph in its entirety in the documentation or other materials
 * provided with the distribution, and (3) all advertising materials mentioning
 * features or use of this software display the following acknowledgement:
 * ``This product includes software developed by the University of California,
 * Lawrence Berkeley Laboratory and its contributors.'' Neither the name of
 * the University nor the names of its contributors may be used to endorse
 * or promote products derived from this software without specific prior
 * written permission.
 * THIS SOFTWARE IS PROVIDED ``AS IS'' AND WITHOUT ANY EXPRESS OR IMPLIED
 * WARRANTIES, INCLUDING, WITHOUT LIMITATION, THE IMPLIED WARRANTIES OF
 * MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE.
 *
 * Format and print ntp packets.
 *	By Jeffrey Mogul/DECWRL
 *	loosely based on print-bootp.c
 *//Users/owura/Repos/codeql_eval/proj_repos/the-tcpdump-group-tcpdump-commit-0f95d441e4b5d7512cc5c326c8668a120e048eda/tcpdump/print-null.cnull_if_print(ndo, "[|null]")NULL_HDRLEN[|null](NULL_HDRLEN)(char *)&family(char *)p, sizeof(family)0xFFFF0000null_hdr_print(ndo, "AF %s (%u)", tok2str(bsd_af_values,"Unknown",family),family)(ndo, "%s", tok2str(bsd_af_values,"Unknown AF %u",family))AF %s (%u)Unknown AF %uSWAPLONG(y)((((y)&0xff)<<24) | (((y)&0xff00)<<8) | (((y)&0xff0000)>>8) | (((y)>>24)&0xff))/* unknown AF_ value *//*
	 * This isn't necessarily in our host byte order; if this is
	 * a DLT_LOOP capture, it's in network byte order, and if
	 * this is a DLT_NULL capture from a machine with the opposite
	 * byte-order, it's in the opposite byte order from ours.
	 *
	 * If the upper 16 bits aren't all zero, assume it's byte-swapped.
	 *//*
 * Byte-swap a 32-bit number.
 * ("htonl()" or "ntohl()" won't work - we want to byte-swap even on
 * big-endian platforms.)
 *//*
 * The DLT_NULL packet header is 4 bytes long. It contains a host-byte-order
 * 32-bit integer that specifies the family, e.g. AF_INET.
 *
 * Note here that "host" refers to the host on which the packets were
 * captured; that isn't necessarily *this* host.
 *
 * The OpenBSD DLT_LOOP packet header is the same, except that the integer
 * is in network byte order.
 *//*
 * Copyright (c) 1991, 1993, 1994, 1995, 1996, 1997
 *	The Regents of the University of California.  All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that: (1) source code distributions
 * retain the above copyright notice and this paragraph in its entirety, (2)
 * distributions including binary code include the above copyright notice and
 * this paragraph in its entirety in the documentation or other materials
 * provided with the distribution, and (3) all advertising materials mentioning
 * features or use of this software display the following acknowledgement:
 * ``This product includes software developed by the University of California,
 * Lawrence Berkeley Laboratory and its contributors.'' Neither the name of
 * the University nor the names of its contributors may be used to endorse
 * or promote products derived from this software without specific prior
 * written permission.
 * THIS SOFTWARE IS PROVIDED ``AS IS'' AND WITHOUT ANY EXPRESS OR IMPLIED
 * WARRANTIES, INCLUDING, WITHOUT LIMITATION, THE IMPLIED WARRANTIES OF
 * MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE.
 *//Users/owura/Repos/codeql_eval/proj_repos/the-tcpdump-group-tcpdump-commit-0f95d441e4b5d7512cc5c326c8668a120e048eda/tcpdump/print-olsr.colsr_printhello_lenname_entry_typename_entry_lenname_entry_paddingneighbor_typemsg_datasizeof(struct olsr_common)const olsr_commonconst olsr_common *olsr_common *EXTRACT_16BITS(ptr.common->packet_len)((uint16_t)(((uint16_t)(*((const uint8_t *)(ptr.common->packet_len) + 0)) << 8) | ((uint16_t)(*((const uint8_t *)(ptr.common->packet_len) + 1)) << 0)))ptr.common->packet_len(ndo, "OLSRv%i, seq 0x%04x, length %u", (is_ipv6 == 0) ? 4 : 6, EXTRACT_16BITS(ptr.common->packet_seq), length)(ndo, "OLSRv%i, seq 0x%04x, length %u", (is_ipv6 == 0) ? 4 : 6, ((uint16_t)(((uint16_t)(*((const uint8_t *)(ptr.common->packet_seq) + 0)) << 8) | ((uint16_t)(*((const uint8_t *)(ptr.common->packet_seq) + 1)) << 0))), length)OLSRv%i, seq 0x%04x, length %uptr.common->packet_seqsizeof(struct olsr_msg4)msgptr.v4->msg_len(ndo, "\n\t%s Message (%#04x), originator %s, ttl %u, hop %u" "\n\t  vtime %.3lfs, msg-seq 0x%04x, length %u%s", tok2str(olsr_msg_values, "Unknown", msg_type), msg_type, ipaddr_string(ndo, msgptr.v4->originator), msgptr.v4->ttl, msgptr.v4->hopcount, ME_TO_DOUBLE(msgptr.v4->vtime), EXTRACT_16BITS(msgptr.v4->msg_seq), msg_len, (msg_len_valid == 0) ? " (invalid)" : "")(ndo, "\n\t%s Message (%#04x), originator %s, ttl %u, hop %u" "\n\t  vtime %.3lfs, msg-seq 0x%04x, length %u%s", tok2str(olsr_msg_values, "Unknown", msg_type), msg_type, getname(ndo, (const u_char *)(msgptr.v4->originator)), msgptr.v4->ttl, msgptr.v4->hopcount, (double)(0.0625*(1+(double)(msgptr.v4->vtime>>4)/16)*(double)(1<<(msgptr.v4->vtime&0x0F))), ((uint16_t)(((uint16_t)(*((const uint8_t *)(msgptr.v4->msg_seq) + 0)) << 8) | ((uint16_t)(*((const uint8_t *)(msgptr.v4->msg_seq) + 1)) << 0))), msg_len, (msg_len_valid == 0) ? " (invalid)" : "")msgptr.v4->originatormsgptr.v4->vtimemsgptr.v4->msg_seq*msg_datasizeof(struct olsr_hello)(ndo, "\n\t  hello-time %.3lfs, MPR willingness %u", ME_TO_DOUBLE(ptr.hello->htime), ptr.hello->will)(ndo, "\n\t  hello-time %.3lfs, MPR willingness %u", (double)(0.0625*(1+(double)(ptr.hello->htime>>4)/16)*(double)(1<<(ptr.hello->htime&0x0F))), ptr.hello->will)ptr.hello->htimesizeof(struct olsr_hello_link)ptr.hello_link->lenptr.hello_link->link_code(ndo, "\n\t    link-type %s, neighbor-type %s, len %u%s", tok2str(olsr_link_type_values, "Unknown", link_type), tok2str(olsr_neighbor_type_values, "Unknown", neighbor_type), hello_len, (hello_len_valid == 0) ? " (invalid)" : "")sizeof(struct olsr_tc)(ndo, "\n\t    advertised neighbor seq 0x%04x", EXTRACT_16BITS(ptr.tc->ans_seq))(ndo, "\n\t    advertised neighbor seq 0x%04x", ((uint16_t)(((uint16_t)(*((const uint8_t *)(ptr.tc->ans_seq) + 0)) << 8) | ((uint16_t)(*((const uint8_t *)(ptr.tc->ans_seq) + 1)) << 0))))ptr.tc->ans_seqaddr_size(ndo, "\n\t  interface address %s", ipaddr_string(ndo, msg_data))(ndo, "\n\t  interface address %s", getname(ndo, (const u_char *)(msg_data)))(ndo, "\n\t  Advertised networks (total %u)", (unsigned int) (msg_tlen / sizeof(struct olsr_hna6)))sizeof(struct olsr_hna4)(ndo, "%s%s/%u", col == 0 ? "\n\t    " : ", ", ipaddr_string(ndo, ptr.hna->network), mask2plen(EXTRACT_32BITS(ptr.hna->mask)))(ndo, "%s%s/%u", col == 0 ? "\n\t    " : ", ", getname(ndo, (const u_char *)(ptr.hna->network)), mask2plen(((uint32_t)(((uint32_t)(*((const uint8_t *)(ptr.hna->mask) + 0)) << 24) | ((uint32_t)(*((const uint8_t *)(ptr.hna->mask) + 1)) << 16) | ((uint32_t)(*((const uint8_t *)(ptr.hna->mask) + 2)) << 8) | ((uint32_t)(*((const uint8_t *)(ptr.hna->mask) + 3)) << 0)))))ptr.hna->networkptr.hna->maskmsg_data+2(ndo, "\n\t  Version %u, Entries %u%s", EXTRACT_16BITS(msg_data), name_entries, (name_entries_valid == 0) ? " (invalid)" : "")(ndo, "\n\t  Version %u, Entries %u%s", ((uint16_t)(((uint16_t)(*((const uint8_t *)(msg_data) + 0)) << 8) | ((uint16_t)(*((const uint8_t *)(msg_data) + 1)) << 0))), name_entries, (name_entries_valid == 0) ? " (invalid)" : "")(ndo, "\n\t    #%u: type %#06x, length %u%s", (unsigned int) i, name_entry_type, name_entry_len, (name_entry_len_valid == 0) ? " (invalid)" : "")addr_size + name_entry_len + name_entry_padding(ndo, ", address %s, name \"", ipaddr_string(ndo, msg_data))(ndo, ", address %s, name \"", getname(ndo, (const u_char *)(msg_data)))msgptrmsg_len_validolsr_msg4 *sizeof (struct olsr_msg4)
	%s Message (%#04x), originator %s, ttl %u, hop %u
	  vtime %.3lfs, msg-seq 0x%04x, length %u%schar[97]0.062516.0 (invalid)OLSR_HELLO_MSG201OLSR_HELLO_LQ_MSGconst olsr_helloconst olsr_hello *olsr_hello *
	  hello-time %.3lfs, MPR willingness %uhello_len_validconst olsr_hello_linkconst olsr_hello_link *olsr_hello_link *
	    link-type %s, neighbor-type %s, len %u%sis_ipv6OLSR_TC_MSG202OLSR_TC_LQ_MSGconst olsr_tcconst olsr_tc *olsr_tc *
	    advertised neighbor seq 0x%04xOLSR_MID_MSG
	  interface address %sOLSR_HNA_MSG
	  Advertised networks (total %u)colconst olsr_hna4const olsr_hna4 *olsr_hna4 *OLSR_NAMESERVICE_MSGname_entriesname_entries_valid
	  Version %u, Entries %u%sname_entry_len_valid
	    #%u: type %#06x, length %u%s, address %s, name "OLSR_POWERINFO_MSG(ndo, "[|olsr]")[|olsr]olsr_print_neighborneighbor(ndo, "\n\t      neighbor\n\t\t")
	      neighbor
		(ndo, "%s%s", ipaddr_string(ndo, msg_data), neighbor % 4 == 0 ? "\n\t\t" : " ")(ndo, "%s%s", getname(ndo, (const u_char *)(msg_data)), neighbor % 4 == 0 ? "\n\t\t" : " ")olsr_print_lq_neighbor4olsr_lq_neighbor4 *lq_neighbor(ndo, "\n\t      neighbor %s, link-quality %.2lf%%" ", neighbor-link-quality %.2lf%%", ipaddr_string(ndo, lq_neighbor->neighbor), ((double)lq_neighbor->link_quality/2.55), ((double)lq_neighbor->neighbor_link_quality/2.55))(ndo, "\n\t      neighbor %s, link-quality %.2lf%%" ", neighbor-link-quality %.2lf%%", getname(ndo, (const u_char *)(lq_neighbor->neighbor)), ((double)lq_neighbor->link_quality/2.55), ((double)lq_neighbor->neighbor_link_quality/2.55))lq_neighbor->neighborsizeof(struct olsr_lq_neighbor4)
	      neighbor %s, link-quality %.2lf%%, neighbor-link-quality %.2lf%%2.549999999999999822olsr_lq_neighbor6olsr_lq_neighbor4olsr_hna6olsr_hna4olsr_tcolsr_hello_linkolsr_helloolsr_msg6olsr_msg4olsr_commonolsr_msg6 *hnahello_linkconst olsr_msg6const olsr_msg6 *msg6const olsr_msg4const olsr_msg4 *msg4commonneighbor_link_qualitylink_qualitynetworkans_seqlink_codewillhtimemsg_seqoriginatorvtimepacket_seqNot-Neighbor"Not-Neighbor"Symmetric"Symmetric"Symmetric-MPR"Symmetric-MPR"olsr_neighbor_type_valuesUnspecified"Unspecified"Asymmetric"Asymmetric"Lost"Lost"olsr_link_type_valuesTC"TC"MID"MID"HNA"HNA"Powerinfo"Powerinfo"Nameservice"Nameservice"Hello-LQ"Hello-LQ"TC-LQ"TC-LQ"olsr_msg_valuesME_TO_DOUBLE(me)(double)(VTIME_SCALE_FACTOR*(1+(double)(me>>4)/16)*(double)(1<<(me&0x0F)))VTIME_SCALE_FACTOROLSR_EXTRACT_NEIGHBOR_TYPE(link_code)(link_code >> 2)OLSR_EXTRACT_LINK_TYPE(link_code)(link_code & 0x3)/* while (tptr < (pptr+length)) *//* switch (msg_type) *//*
             * FIXME those are the defined messages that lack a decoder
             * you are welcome to contribute code ;-)
             *//* case OLSR_NAMESERVICE_MSG *//* for (i = 0; i < name_entries; i++) *//* 32-bit alignment *//* print 4 prefixes per line *//*
                 * link-type.
                 *//* (!is_ipv6) *//* print 4 neighbors per line *//*
 * print a neighbor list.
 *//*
 * print a neighbor list with LQ extensions.
 *//*
 * macro to convert the 8-bit mantissa/exponent to a double float
 * taken from olsr.org.
 *//* LQ extensions olsr.org *//*
 * RFC 3626 common header
 *
 *  0                   1                   2                   3
 *  0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
 * +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
 * |         Packet Length         |    Packet Sequence Number     |
 * +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
 * |  Message Type |     Vtime     |         Message Size          |
 * +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
 * |                      Originator Address                       |
 * +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
 * |  Time To Live |   Hop Count   |    Message Sequence Number    |
 * +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
 * |                                                               |
 * :                            MESSAGE                            :
 * |                                                               |
 * +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
 * |  Message Type |     Vtime     |         Message Size          |
 * +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
 * |                      Originator Address                       |
 * +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
 * |  Time To Live |   Hop Count   |    Message Sequence Number    |
 * +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
 * |                                                               |
 * :                            MESSAGE                            :
 * |                                                               |
 * +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
 * :                                                               :
 *//*
 * Copyright (c) 1998-2007 The TCPDUMP project
 * Copyright (c) 2009  Florian Forster
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that: (1) source code
 * distributions retain the above copyright notice and this paragraph
 * in its entirety, and (2) distributions including binary code include
 * the above copyright notice and this paragraph in its entirety in
 * the documentation or other materials provided with the distribution.
 * THIS SOFTWARE IS PROVIDED ``AS IS'' AND
 * WITHOUT ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, WITHOUT
 * LIMITATION, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS
 * FOR A PARTICULAR PURPOSE.
 *
 * Optimized Link State Protocl (OLSR) as per rfc3626
 *
 * Original code by Hannes Gredler <hannes@juniper.net>
 * IPv6 additions by Florian Forster <octo at verplant.org>
 *//Users/owura/Repos/codeql_eval/proj_repos/the-tcpdump-group-tcpdump-commit-0f95d441e4b5d7512cc5c326c8668a120e048eda/tcpdump/openflow.hOF_HEADER_LENof10_header_body_print/*
 * Routines to print packets for various versions of OpenFlow.
 *//* OpenFlow: protocol between controller and datapath. *//*
 * Copyright (c) 2013 The TCPDUMP project
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
 * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
 * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS
 * FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE
 * COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT,
 * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,
 * BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
 * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
 * CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN
 * ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
 * POSSIBILITY OF SUCH DAMAGE.
 *//Users/owura/Repos/codeql_eval/proj_repos/the-tcpdump-group-tcpdump-commit-0f95d441e4b5d7512cc5c326c8668a120e048eda/tcpdump/print-openflow-1.0.c"openflow.h"cp0len0(ndo, "\n\tversion 1.0, type %s, length %u, xid 0x%08x", tok2str(ofpt_str, "invalid (0x%02x)", type), len, xid)
	version 1.0, type %s, length %u, xid 0x%08xinvalid (0x%02x)(ndo, "\n\t flags %s", tok2str(ofp_config_str, "invalid (0x%04x)", EXTRACT_16BITS(cp)))(ndo, "\n\t flags %s", tok2str(ofp_config_str, "invalid (0x%04x)", ((uint16_t)(((uint16_t)(*((const uint8_t *)(cp) + 0)) << 8) | ((uint16_t)(*((const uint8_t *)(cp) + 1)) << 0)))))(ndo, ", miss_send_len %u", EXTRACT_16BITS(cp))(ndo, ", miss_send_len %u", ((uint16_t)(((uint16_t)(*((const uint8_t *)(cp) + 0)) << 8) | ((uint16_t)(*((const uint8_t *)(cp) + 1)) << 0))))(ndo, "\n\t port_no %s", tok2str(ofpp_str, "%u", EXTRACT_16BITS(cp)))(ndo, "\n\t port_no %s", tok2str(ofpp_str, "%u", ((uint16_t)(((uint16_t)(*((const uint8_t *)(cp) + 0)) << 8) | ((uint16_t)(*((const uint8_t *)(cp) + 1)) << 0)))))(ndo, "\n\t reason %s", tok2str(ofppr_str, "invalid (0x%02x)", *cp))OFPT_FEATURES_REQUESTOFPT_GET_CONFIG_REQUESTOFPT_BARRIER_REQUESTOFPT_BARRIER_REPLYOFPT_SET_CONFIGOFPT_GET_CONFIG_REPLYOF_SWITCH_CONFIG_LEN
	 flags %sinvalid (0x%04x), miss_send_len %uOFPT_PORT_MODOF_PORT_MOD_LENOFPT_QUEUE_GET_CONFIG_REQUESTOF_QUEUE_GET_CONFIG_REQUEST_LEN
	 port_no %sOFPT_FLOW_REMOVEDOF_FLOW_REMOVED_LENOFPT_PORT_STATUSOF_PORT_STATUS_LEN
	 reason %sOF_PHY_PORT_LENOFPT_FEATURES_REPLYOF_SWITCH_FEATURES_LENOFPT_HELLOOFPT_ECHO_REQUESTOFPT_ECHO_REPLYOFPT_ERROROF_ERROR_MSG_LENOFPT_VENDOROF_VENDOR_HEADER_LENOFPT_PACKET_INOF_PACKET_IN_LENOFPT_STATS_REQUESTOF_STATS_REQUEST_LENOFPT_STATS_REPLYOF_STATS_REPLY_LENOFPT_PACKET_OUTOF_PACKET_OUT_LENOFPT_FLOW_MODOF_FLOW_MOD_LENOFPT_QUEUE_GET_CONFIG_REPLYOF_QUEUE_GET_CONFIG_REPLY_LENnext_message*cp0len0 - OF_HEADER_LENlen0 - 8of10_error_printcode_str(ndo, "\n\t type %s", tok2str(ofpet_str, "invalid (0x%04x)", type))
	 type %sOFPET_HELLO_FAILEDOFPET_BAD_REQUESTOFPET_BAD_ACTIONOFPET_FLOW_MOD_FAILEDOFPET_PORT_MOD_FAILEDOFPET_QUEUE_OP_FAILED(ndo, ", code %s", tok2str(code_str, "invalid (0x%04x)", EXTRACT_16BITS(cp)))(ndo, ", code %s", tok2str(code_str, "invalid (0x%04x)", ((uint16_t)(((uint16_t)(*((const uint8_t *)(cp) + 0)) << 8) | ((uint16_t)(*((const uint8_t *)(cp) + 1)) << 0))))), code %sof10_flow_removed_print(ndo, "\n\t cookie 0x%016" PRIx64, EXTRACT_64BITS(cp))(ndo, "\n\t cookie 0x%016" "ll" "x", ((uint64_t)(((uint64_t)(*((const uint8_t *)(cp) + 0)) << 56) | ((uint64_t)(*((const uint8_t *)(cp) + 1)) << 48) | ((uint64_t)(*((const uint8_t *)(cp) + 2)) << 40) | ((uint64_t)(*((const uint8_t *)(cp) + 3)) << 32) | ((uint64_t)(*((const uint8_t *)(cp) + 4)) << 24) | ((uint64_t)(*((const uint8_t *)(cp) + 5)) << 16) | ((uint64_t)(*((const uint8_t *)(cp) + 6)) << 8) | ((uint64_t)(*((const uint8_t *)(cp) + 7)) << 0))))
	 cookie 0x%016llx(ndo, ", priority %u", EXTRACT_16BITS(cp))(ndo, ", priority %u", ((uint16_t)(((uint16_t)(*((const uint8_t *)(cp) + 0)) << 8) | ((uint16_t)(*((const uint8_t *)(cp) + 1)) << 0)))), priority %u(ndo, ", reason %s", tok2str(ofprr_str, "unknown (0x%02x)", *cp)), reason %s(ndo, ", duration_sec %u", EXTRACT_32BITS(cp))(ndo, ", duration_sec %u", ((uint32_t)(((uint32_t)(*((const uint8_t *)(cp) + 0)) << 24) | ((uint32_t)(*((const uint8_t *)(cp) + 1)) << 16) | ((uint32_t)(*((const uint8_t *)(cp) + 2)) << 8) | ((uint32_t)(*((const uint8_t *)(cp) + 3)) << 0)))), duration_sec %u(ndo, ", duration_nsec %u", EXTRACT_32BITS(cp))(ndo, ", duration_nsec %u", ((uint32_t)(((uint32_t)(*((const uint8_t *)(cp) + 0)) << 24) | ((uint32_t)(*((const uint8_t *)(cp) + 1)) << 16) | ((uint32_t)(*((const uint8_t *)(cp) + 2)) << 8) | ((uint32_t)(*((const uint8_t *)(cp) + 3)) << 0)))), duration_nsec %u(ndo, ", idle_timeout %u", EXTRACT_16BITS(cp))(ndo, ", idle_timeout %u", ((uint16_t)(((uint16_t)(*((const uint8_t *)(cp) + 0)) << 8) | ((uint16_t)(*((const uint8_t *)(cp) + 1)) << 0)))), idle_timeout %u(ndo, ", packet_count %" PRIu64, EXTRACT_64BITS(cp))(ndo, ", packet_count %" "ll" "u", ((uint64_t)(((uint64_t)(*((const uint8_t *)(cp) + 0)) << 56) | ((uint64_t)(*((const uint8_t *)(cp) + 1)) << 48) | ((uint64_t)(*((const uint8_t *)(cp) + 2)) << 40) | ((uint64_t)(*((const uint8_t *)(cp) + 3)) << 32) | ((uint64_t)(*((const uint8_t *)(cp) + 4)) << 24) | ((uint64_t)(*((const uint8_t *)(cp) + 5)) << 16) | ((uint64_t)(*((const uint8_t *)(cp) + 6)) << 8) | ((uint64_t)(*((const uint8_t *)(cp) + 7)) << 0)))), packet_count %llu(ndo, ", byte_count %" PRIu64, EXTRACT_64BITS(cp))(ndo, ", byte_count %" "ll" "u", ((uint64_t)(((uint64_t)(*((const uint8_t *)(cp) + 0)) << 56) | ((uint64_t)(*((const uint8_t *)(cp) + 1)) << 48) | ((uint64_t)(*((const uint8_t *)(cp) + 2)) << 40) | ((uint64_t)(*((const uint8_t *)(cp) + 3)) << 32) | ((uint64_t)(*((const uint8_t *)(cp) + 4)) << 24) | ((uint64_t)(*((const uint8_t *)(cp) + 5)) << 16) | ((uint64_t)(*((const uint8_t *)(cp) + 6)) << 8) | ((uint64_t)(*((const uint8_t *)(cp) + 7)) << 0)))), byte_count %lluof10_packet_in_print(ndo, "\n\t buffer_id %s", tok2str(bufferid_str, "0x%08x", EXTRACT_32BITS(cp)))(ndo, "\n\t buffer_id %s", tok2str(bufferid_str, "0x%08x", ((uint32_t)(((uint32_t)(*((const uint8_t *)(cp) + 0)) << 24) | ((uint32_t)(*((const uint8_t *)(cp) + 1)) << 16) | ((uint32_t)(*((const uint8_t *)(cp) + 2)) << 8) | ((uint32_t)(*((const uint8_t *)(cp) + 3)) << 0)))))
	 buffer_id %s(ndo, ", total_len %u", EXTRACT_16BITS(cp))(ndo, ", total_len %u", ((uint16_t)(((uint16_t)(*((const uint8_t *)(cp) + 0)) << 8) | ((uint16_t)(*((const uint8_t *)(cp) + 1)) << 0)))), total_len %u(ndo, ", in_port %s", tok2str(ofpp_str, "%u", EXTRACT_16BITS(cp)))(ndo, ", in_port %s", tok2str(ofpp_str, "%u", ((uint16_t)(((uint16_t)(*((const uint8_t *)(cp) + 0)) << 8) | ((uint16_t)(*((const uint8_t *)(cp) + 1)) << 0))))), in_port %s(ndo, ", reason %s", tok2str(ofpr_str, "invalid (0x%02x)", *cp))(OF_PACKET_IN_LEN - 2)of10_packet_out_printactions_len(ndo, "\n\t buffer_id 0x%08x", EXTRACT_32BITS(cp))(ndo, "\n\t buffer_id 0x%08x", ((uint32_t)(((uint32_t)(*((const uint8_t *)(cp) + 0)) << 24) | ((uint32_t)(*((const uint8_t *)(cp) + 1)) << 16) | ((uint32_t)(*((const uint8_t *)(cp) + 2)) << 8) | ((uint32_t)(*((const uint8_t *)(cp) + 3)) << 0))))
	 buffer_id 0x%08xof10_stats_reply_print(ndo, "\n\t type %s", tok2str(ofpst_str, "invalid (0x%04x)", type))(ndo, ", flags 0x%04x", EXTRACT_16BITS(cp))(ndo, ", flags 0x%04x", ((uint16_t)(((uint16_t)(*((const uint8_t *)(cp) + 0)) << 8) | ((uint16_t)(*((const uint8_t *)(cp) + 1)) << 0)))), flags 0x%04xOFPSF_REPLY_UdecoderOFPST_DESCOFPST_FLOWOFPST_AGGREGATEOFPST_TABLEOFPST_PORTOFPST_QUEUEOFPST_VENDORof10_queue_stats_reply_print(ndo, "\n\t  port_no %s", tok2str(ofpp_str, "%u", EXTRACT_16BITS(cp)))(ndo, "\n\t  port_no %s", tok2str(ofpp_str, "%u", ((uint16_t)(((uint16_t)(*((const uint8_t *)(cp) + 0)) << 8) | ((uint16_t)(*((const uint8_t *)(cp) + 1)) << 0)))))(ndo, ", queue_id %u", EXTRACT_32BITS(cp))(ndo, ", queue_id %u", ((uint32_t)(((uint32_t)(*((const uint8_t *)(cp) + 0)) << 24) | ((uint32_t)(*((const uint8_t *)(cp) + 1)) << 16) | ((uint32_t)(*((const uint8_t *)(cp) + 2)) << 8) | ((uint32_t)(*((const uint8_t *)(cp) + 3)) << 0))))(ndo, ", tx_bytes %" PRIu64, EXTRACT_64BITS(cp))(ndo, ", tx_bytes %" "ll" "u", ((uint64_t)(((uint64_t)(*((const uint8_t *)(cp) + 0)) << 56) | ((uint64_t)(*((const uint8_t *)(cp) + 1)) << 48) | ((uint64_t)(*((const uint8_t *)(cp) + 2)) << 40) | ((uint64_t)(*((const uint8_t *)(cp) + 3)) << 32) | ((uint64_t)(*((const uint8_t *)(cp) + 4)) << 24) | ((uint64_t)(*((const uint8_t *)(cp) + 5)) << 16) | ((uint64_t)(*((const uint8_t *)(cp) + 6)) << 8) | ((uint64_t)(*((const uint8_t *)(cp) + 7)) << 0))))(ndo, ", tx_packets %" PRIu64, EXTRACT_64BITS(cp))(ndo, ", tx_packets %" "ll" "u", ((uint64_t)(((uint64_t)(*((const uint8_t *)(cp) + 0)) << 56) | ((uint64_t)(*((const uint8_t *)(cp) + 1)) << 48) | ((uint64_t)(*((const uint8_t *)(cp) + 2)) << 40) | ((uint64_t)(*((const uint8_t *)(cp) + 3)) << 32) | ((uint64_t)(*((const uint8_t *)(cp) + 4)) << 24) | ((uint64_t)(*((const uint8_t *)(cp) + 5)) << 16) | ((uint64_t)(*((const uint8_t *)(cp) + 6)) << 8) | ((uint64_t)(*((const uint8_t *)(cp) + 7)) << 0))))(ndo, ", tx_errors %" PRIu64, EXTRACT_64BITS(cp))(ndo, ", tx_errors %" "ll" "u", ((uint64_t)(((uint64_t)(*((const uint8_t *)(cp) + 0)) << 56) | ((uint64_t)(*((const uint8_t *)(cp) + 1)) << 48) | ((uint64_t)(*((const uint8_t *)(cp) + 2)) << 40) | ((uint64_t)(*((const uint8_t *)(cp) + 3)) << 32) | ((uint64_t)(*((const uint8_t *)(cp) + 4)) << 24) | ((uint64_t)(*((const uint8_t *)(cp) + 5)) << 16) | ((uint64_t)(*((const uint8_t *)(cp) + 6)) << 8) | ((uint64_t)(*((const uint8_t *)(cp) + 7)) << 0))))OF_QUEUE_STATS_LEN
	  port_no %s, queue_id %u, tx_bytes %llu, tx_packets %llu, tx_errors %lluof10_port_stats_reply_printOF_PORT_STATS_LEN - 2104 - 2(ndo, ", rx_packets %" PRIu64, EXTRACT_64BITS(cp))(ndo, ", rx_packets %" "ll" "u", ((uint64_t)(((uint64_t)(*((const uint8_t *)(cp) + 0)) << 56) | ((uint64_t)(*((const uint8_t *)(cp) + 1)) << 48) | ((uint64_t)(*((const uint8_t *)(cp) + 2)) << 40) | ((uint64_t)(*((const uint8_t *)(cp) + 3)) << 32) | ((uint64_t)(*((const uint8_t *)(cp) + 4)) << 24) | ((uint64_t)(*((const uint8_t *)(cp) + 5)) << 16) | ((uint64_t)(*((const uint8_t *)(cp) + 6)) << 8) | ((uint64_t)(*((const uint8_t *)(cp) + 7)) << 0))))(ndo, ", rx_bytes %" PRIu64, EXTRACT_64BITS(cp))(ndo, ", rx_bytes %" "ll" "u", ((uint64_t)(((uint64_t)(*((const uint8_t *)(cp) + 0)) << 56) | ((uint64_t)(*((const uint8_t *)(cp) + 1)) << 48) | ((uint64_t)(*((const uint8_t *)(cp) + 2)) << 40) | ((uint64_t)(*((const uint8_t *)(cp) + 3)) << 32) | ((uint64_t)(*((const uint8_t *)(cp) + 4)) << 24) | ((uint64_t)(*((const uint8_t *)(cp) + 5)) << 16) | ((uint64_t)(*((const uint8_t *)(cp) + 6)) << 8) | ((uint64_t)(*((const uint8_t *)(cp) + 7)) << 0))))(ndo, ", rx_dropped %" PRIu64, EXTRACT_64BITS(cp))(ndo, ", rx_dropped %" "ll" "u", ((uint64_t)(((uint64_t)(*((const uint8_t *)(cp) + 0)) << 56) | ((uint64_t)(*((const uint8_t *)(cp) + 1)) << 48) | ((uint64_t)(*((const uint8_t *)(cp) + 2)) << 40) | ((uint64_t)(*((const uint8_t *)(cp) + 3)) << 32) | ((uint64_t)(*((const uint8_t *)(cp) + 4)) << 24) | ((uint64_t)(*((const uint8_t *)(cp) + 5)) << 16) | ((uint64_t)(*((const uint8_t *)(cp) + 6)) << 8) | ((uint64_t)(*((const uint8_t *)(cp) + 7)) << 0))))(ndo, ", tx_dropped %" PRIu64, EXTRACT_64BITS(cp))(ndo, ", tx_dropped %" "ll" "u", ((uint64_t)(((uint64_t)(*((const uint8_t *)(cp) + 0)) << 56) | ((uint64_t)(*((const uint8_t *)(cp) + 1)) << 48) | ((uint64_t)(*((const uint8_t *)(cp) + 2)) << 40) | ((uint64_t)(*((const uint8_t *)(cp) + 3)) << 32) | ((uint64_t)(*((const uint8_t *)(cp) + 4)) << 24) | ((uint64_t)(*((const uint8_t *)(cp) + 5)) << 16) | ((uint64_t)(*((const uint8_t *)(cp) + 6)) << 8) | ((uint64_t)(*((const uint8_t *)(cp) + 7)) << 0))))(ndo, ", rx_errors %" PRIu64, EXTRACT_64BITS(cp))(ndo, ", rx_errors %" "ll" "u", ((uint64_t)(((uint64_t)(*((const uint8_t *)(cp) + 0)) << 56) | ((uint64_t)(*((const uint8_t *)(cp) + 1)) << 48) | ((uint64_t)(*((const uint8_t *)(cp) + 2)) << 40) | ((uint64_t)(*((const uint8_t *)(cp) + 3)) << 32) | ((uint64_t)(*((const uint8_t *)(cp) + 4)) << 24) | ((uint64_t)(*((const uint8_t *)(cp) + 5)) << 16) | ((uint64_t)(*((const uint8_t *)(cp) + 6)) << 8) | ((uint64_t)(*((const uint8_t *)(cp) + 7)) << 0))))(ndo, ", rx_frame_err %" PRIu64, EXTRACT_64BITS(cp))(ndo, ", rx_frame_err %" "ll" "u", ((uint64_t)(((uint64_t)(*((const uint8_t *)(cp) + 0)) << 56) | ((uint64_t)(*((const uint8_t *)(cp) + 1)) << 48) | ((uint64_t)(*((const uint8_t *)(cp) + 2)) << 40) | ((uint64_t)(*((const uint8_t *)(cp) + 3)) << 32) | ((uint64_t)(*((const uint8_t *)(cp) + 4)) << 24) | ((uint64_t)(*((const uint8_t *)(cp) + 5)) << 16) | ((uint64_t)(*((const uint8_t *)(cp) + 6)) << 8) | ((uint64_t)(*((const uint8_t *)(cp) + 7)) << 0))))(ndo, ", rx_over_err %" PRIu64, EXTRACT_64BITS(cp))(ndo, ", rx_over_err %" "ll" "u", ((uint64_t)(((uint64_t)(*((const uint8_t *)(cp) + 0)) << 56) | ((uint64_t)(*((const uint8_t *)(cp) + 1)) << 48) | ((uint64_t)(*((const uint8_t *)(cp) + 2)) << 40) | ((uint64_t)(*((const uint8_t *)(cp) + 3)) << 32) | ((uint64_t)(*((const uint8_t *)(cp) + 4)) << 24) | ((uint64_t)(*((const uint8_t *)(cp) + 5)) << 16) | ((uint64_t)(*((const uint8_t *)(cp) + 6)) << 8) | ((uint64_t)(*((const uint8_t *)(cp) + 7)) << 0))))(ndo, ", rx_crc_err %" PRIu64, EXTRACT_64BITS(cp))(ndo, ", rx_crc_err %" "ll" "u", ((uint64_t)(((uint64_t)(*((const uint8_t *)(cp) + 0)) << 56) | ((uint64_t)(*((const uint8_t *)(cp) + 1)) << 48) | ((uint64_t)(*((const uint8_t *)(cp) + 2)) << 40) | ((uint64_t)(*((const uint8_t *)(cp) + 3)) << 32) | ((uint64_t)(*((const uint8_t *)(cp) + 4)) << 24) | ((uint64_t)(*((const uint8_t *)(cp) + 5)) << 16) | ((uint64_t)(*((const uint8_t *)(cp) + 6)) << 8) | ((uint64_t)(*((const uint8_t *)(cp) + 7)) << 0))))(ndo, ", collisions %" PRIu64, EXTRACT_64BITS(cp))(ndo, ", collisions %" "ll" "u", ((uint64_t)(((uint64_t)(*((const uint8_t *)(cp) + 0)) << 56) | ((uint64_t)(*((const uint8_t *)(cp) + 1)) << 48) | ((uint64_t)(*((const uint8_t *)(cp) + 2)) << 40) | ((uint64_t)(*((const uint8_t *)(cp) + 3)) << 32) | ((uint64_t)(*((const uint8_t *)(cp) + 4)) << 24) | ((uint64_t)(*((const uint8_t *)(cp) + 5)) << 16) | ((uint64_t)(*((const uint8_t *)(cp) + 6)) << 8) | ((uint64_t)(*((const uint8_t *)(cp) + 7)) << 0))))OF_PORT_STATS_LEN, rx_packets %llu, rx_bytes %llu, rx_dropped %llu, tx_dropped %llu, rx_errors %llu, rx_frame_err %llu, rx_over_err %llu, rx_crc_err %llu, collisions %llunext_portof10_table_stats_reply_print(ndo, "\n\t table_id %s", tok2str(tableid_str, "%u", *cp))OFP_MAX_TABLE_NAME_LEN(ndo, ", name '")(ndo, "\n\t  wildcards 0x%08x", EXTRACT_32BITS(cp))(ndo, "\n\t  wildcards 0x%08x", ((uint32_t)(((uint32_t)(*((const uint8_t *)(cp) + 0)) << 24) | ((uint32_t)(*((const uint8_t *)(cp) + 1)) << 16) | ((uint32_t)(*((const uint8_t *)(cp) + 2)) << 8) | ((uint32_t)(*((const uint8_t *)(cp) + 3)) << 0))))(ndo, "\n\t  max_entries %u", EXTRACT_32BITS(cp))(ndo, "\n\t  max_entries %u", ((uint32_t)(((uint32_t)(*((const uint8_t *)(cp) + 0)) << 24) | ((uint32_t)(*((const uint8_t *)(cp) + 1)) << 16) | ((uint32_t)(*((const uint8_t *)(cp) + 2)) << 8) | ((uint32_t)(*((const uint8_t *)(cp) + 3)) << 0))))(ndo, ", active_count %u", EXTRACT_32BITS(cp))(ndo, ", active_count %u", ((uint32_t)(((uint32_t)(*((const uint8_t *)(cp) + 0)) << 24) | ((uint32_t)(*((const uint8_t *)(cp) + 1)) << 16) | ((uint32_t)(*((const uint8_t *)(cp) + 2)) << 8) | ((uint32_t)(*((const uint8_t *)(cp) + 3)) << 0))))(ndo, ", lookup_count %" PRIu64, EXTRACT_64BITS(cp))(ndo, ", lookup_count %" "ll" "u", ((uint64_t)(((uint64_t)(*((const uint8_t *)(cp) + 0)) << 56) | ((uint64_t)(*((const uint8_t *)(cp) + 1)) << 48) | ((uint64_t)(*((const uint8_t *)(cp) + 2)) << 40) | ((uint64_t)(*((const uint8_t *)(cp) + 3)) << 32) | ((uint64_t)(*((const uint8_t *)(cp) + 4)) << 24) | ((uint64_t)(*((const uint8_t *)(cp) + 5)) << 16) | ((uint64_t)(*((const uint8_t *)(cp) + 6)) << 8) | ((uint64_t)(*((const uint8_t *)(cp) + 7)) << 0))))(ndo, ", matched_count %" PRIu64, EXTRACT_64BITS(cp))(ndo, ", matched_count %" "ll" "u", ((uint64_t)(((uint64_t)(*((const uint8_t *)(cp) + 0)) << 56) | ((uint64_t)(*((const uint8_t *)(cp) + 1)) << 48) | ((uint64_t)(*((const uint8_t *)(cp) + 2)) << 40) | ((uint64_t)(*((const uint8_t *)(cp) + 3)) << 32) | ((uint64_t)(*((const uint8_t *)(cp) + 4)) << 24) | ((uint64_t)(*((const uint8_t *)(cp) + 5)) << 16) | ((uint64_t)(*((const uint8_t *)(cp) + 6)) << 8) | ((uint64_t)(*((const uint8_t *)(cp) + 7)) << 0))))OF_TABLE_STATS_LEN
	 table_id %s, name '
	  wildcards 0x%08x4194304-41943044290772992OFPFW_U
	  max_entries %u, active_count %u, lookup_count %llu, matched_count %lluof10_aggregate_stats_reply_printOF_AGGREGATE_STATS_REPLY_LEN(ndo, "\n\t packet_count %" PRIu64, EXTRACT_64BITS(cp))(ndo, "\n\t packet_count %" "ll" "u", ((uint64_t)(((uint64_t)(*((const uint8_t *)(cp) + 0)) << 56) | ((uint64_t)(*((const uint8_t *)(cp) + 1)) << 48) | ((uint64_t)(*((const uint8_t *)(cp) + 2)) << 40) | ((uint64_t)(*((const uint8_t *)(cp) + 3)) << 32) | ((uint64_t)(*((const uint8_t *)(cp) + 4)) << 24) | ((uint64_t)(*((const uint8_t *)(cp) + 5)) << 16) | ((uint64_t)(*((const uint8_t *)(cp) + 6)) << 8) | ((uint64_t)(*((const uint8_t *)(cp) + 7)) << 0))))
	 packet_count %llu(ndo, ", flow_count %u", EXTRACT_32BITS(cp))(ndo, ", flow_count %u", ((uint32_t)(((uint32_t)(*((const uint8_t *)(cp) + 0)) << 24) | ((uint32_t)(*((const uint8_t *)(cp) + 1)) << 16) | ((uint32_t)(*((const uint8_t *)(cp) + 2)) << 8) | ((uint32_t)(*((const uint8_t *)(cp) + 3)) << 0)))), flow_count %uof10_flow_stats_reply_printentry_len(ndo, "\n\t length %u", entry_len)(ndo, ", table_id %s", tok2str(tableid_str, "%u", *cp))(ndo, "\n\t  duration_sec %u", EXTRACT_32BITS(cp))(ndo, "\n\t  duration_sec %u", ((uint32_t)(((uint32_t)(*((const uint8_t *)(cp) + 0)) << 24) | ((uint32_t)(*((const uint8_t *)(cp) + 1)) << 16) | ((uint32_t)(*((const uint8_t *)(cp) + 2)) << 8) | ((uint32_t)(*((const uint8_t *)(cp) + 3)) << 0))))(ndo, ", hard_timeout %u", EXTRACT_16BITS(cp))(ndo, ", hard_timeout %u", ((uint16_t)(((uint16_t)(*((const uint8_t *)(cp) + 0)) << 8) | ((uint16_t)(*((const uint8_t *)(cp) + 1)) << 0))))(ndo, ", cookie 0x%016" PRIx64, EXTRACT_64BITS(cp))(ndo, ", cookie 0x%016" "ll" "x", ((uint64_t)(((uint64_t)(*((const uint8_t *)(cp) + 0)) << 56) | ((uint64_t)(*((const uint8_t *)(cp) + 1)) << 48) | ((uint64_t)(*((const uint8_t *)(cp) + 2)) << 40) | ((uint64_t)(*((const uint8_t *)(cp) + 3)) << 32) | ((uint64_t)(*((const uint8_t *)(cp) + 4)) << 24) | ((uint64_t)(*((const uint8_t *)(cp) + 5)) << 16) | ((uint64_t)(*((const uint8_t *)(cp) + 6)) << 8) | ((uint64_t)(*((const uint8_t *)(cp) + 7)) << 0))))OF_FLOW_STATS_LEN
	 length %u, table_id %s
	  duration_sec %u, hard_timeout %u, cookie 0x%016llxof10_desc_stats_reply_print1056OF_DESC_STATS_LENDESC_STR_LEN(ndo, "\n\t  mfr_desc '")
	  mfr_desc '(ndo, "\n\t  hw_desc '")
	  hw_desc '(ndo, "\n\t  sw_desc '")
	  sw_desc 'SERIAL_NUM_LEN(ndo, "\n\t  serial_num '")
	  serial_num '(ndo, "\n\t  dp_desc '")
	  dp_desc 'of10_stats_request_print(ndo, ", out_port %s", tok2str(ofpp_str, "%u", EXTRACT_16BITS(cp)))(ndo, ", out_port %s", tok2str(ofpp_str, "%u", ((uint16_t)(((uint16_t)(*((const uint8_t *)(cp) + 0)) << 8) | ((uint16_t)(*((const uint8_t *)(cp) + 1)) << 0)))))(ndo, ", queue_id %s", tok2str(ofpq_str, "%u", EXTRACT_32BITS(cp)))(ndo, ", queue_id %s", tok2str(ofpq_str, "%u", ((uint32_t)(((uint32_t)(*((const uint8_t *)(cp) + 0)) << 24) | ((uint32_t)(*((const uint8_t *)(cp) + 1)) << 16) | ((uint32_t)(*((const uint8_t *)(cp) + 2)) << 8) | ((uint32_t)(*((const uint8_t *)(cp) + 3)) << 0)))))OF_FLOW_STATS_REQUEST_LEN, out_port %sOF_PORT_STATS_REQUEST_LENOF_QUEUE_STATS_REQUEST_LEN, queue_id %sof10_port_mod_print(ndo, ", hw_addr %s", etheraddr_string(ndo, cp)), hw_addr %s(ndo, "\n\t config 0x%08x", EXTRACT_32BITS(cp))(ndo, "\n\t config 0x%08x", ((uint32_t)(((uint32_t)(*((const uint8_t *)(cp) + 0)) << 24) | ((uint32_t)(*((const uint8_t *)(cp) + 1)) << 16) | ((uint32_t)(*((const uint8_t *)(cp) + 2)) << 8) | ((uint32_t)(*((const uint8_t *)(cp) + 3)) << 0))))
	 config 0x%08x-1284294967168OFPPC_U(ndo, "\n\t mask 0x%08x", EXTRACT_32BITS(cp))(ndo, "\n\t mask 0x%08x", ((uint32_t)(((uint32_t)(*((const uint8_t *)(cp) + 0)) << 24) | ((uint32_t)(*((const uint8_t *)(cp) + 1)) << 16) | ((uint32_t)(*((const uint8_t *)(cp) + 2)) << 8) | ((uint32_t)(*((const uint8_t *)(cp) + 3)) << 0))))
	 mask 0x%08x(ndo, "\n\t advertise 0x%08x", EXTRACT_32BITS(cp))(ndo, "\n\t advertise 0x%08x", ((uint32_t)(((uint32_t)(*((const uint8_t *)(cp) + 0)) << 24) | ((uint32_t)(*((const uint8_t *)(cp) + 1)) << 16) | ((uint32_t)(*((const uint8_t *)(cp) + 2)) << 8) | ((uint32_t)(*((const uint8_t *)(cp) + 3)) << 0))))
	 advertise 0x%08x2047-4096OFPPF_Uof10_flow_mod_print(ndo, ", command %s", tok2str(ofpfc_str, "invalid (0x%04x)", command)), command %s(ndo, ", buffer_id %s", tok2str(bufferid_str, "0x%08x", EXTRACT_32BITS(cp)))(ndo, ", buffer_id %s", tok2str(bufferid_str, "0x%08x", ((uint32_t)(((uint32_t)(*((const uint8_t *)(cp) + 0)) << 24) | ((uint32_t)(*((const uint8_t *)(cp) + 1)) << 16) | ((uint32_t)(*((const uint8_t *)(cp) + 2)) << 8) | ((uint32_t)(*((const uint8_t *)(cp) + 3)) << 0)))))OFPFC_ADDOFPFC_MODIFYOFPFC_MODIFY_STRICT, buffer_id %sOFPFC_DELETEOFPFC_DELETE_STRICT4294967288OFPFF_Uof10_features_reply_print(ndo, "\n\t dpid 0x%016" PRIx64, EXTRACT_64BITS(cp))(ndo, "\n\t dpid 0x%016" "ll" "x", ((uint64_t)(((uint64_t)(*((const uint8_t *)(cp) + 0)) << 56) | ((uint64_t)(*((const uint8_t *)(cp) + 1)) << 48) | ((uint64_t)(*((const uint8_t *)(cp) + 2)) << 40) | ((uint64_t)(*((const uint8_t *)(cp) + 3)) << 32) | ((uint64_t)(*((const uint8_t *)(cp) + 4)) << 24) | ((uint64_t)(*((const uint8_t *)(cp) + 5)) << 16) | ((uint64_t)(*((const uint8_t *)(cp) + 6)) << 8) | ((uint64_t)(*((const uint8_t *)(cp) + 7)) << 0))))
	 dpid 0x%016llx(ndo, ", n_buffers %u", EXTRACT_32BITS(cp))(ndo, ", n_buffers %u", ((uint32_t)(((uint32_t)(*((const uint8_t *)(cp) + 0)) << 24) | ((uint32_t)(*((const uint8_t *)(cp) + 1)) << 16) | ((uint32_t)(*((const uint8_t *)(cp) + 2)) << 8) | ((uint32_t)(*((const uint8_t *)(cp) + 3)) << 0)))), n_buffers %u(ndo, ", n_tables %u", *cp), n_tables %u(ndo, "\n\t capabilities 0x%08x", EXTRACT_32BITS(cp))(ndo, "\n\t capabilities 0x%08x", ((uint32_t)(((uint32_t)(*((const uint8_t *)(cp) + 0)) << 24) | ((uint32_t)(*((const uint8_t *)(cp) + 1)) << 16) | ((uint32_t)(*((const uint8_t *)(cp) + 2)) << 8) | ((uint32_t)(*((const uint8_t *)(cp) + 3)) << 0))))
	 capabilities 0x%08x-2404294967056OFPCAP_U(ndo, "\n\t actions 0x%08x", EXTRACT_32BITS(cp))(ndo,   cy    